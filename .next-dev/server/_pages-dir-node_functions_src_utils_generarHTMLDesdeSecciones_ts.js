"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_functions_src_utils_generarHTMLDesdeSecciones_ts";
exports.ids = ["_pages-dir-node_functions_src_utils_generarHTMLDesdeSecciones_ts"];
exports.modules = {

/***/ "(pages-dir-node)/./functions/src/models/lineConstants.ts":
/*!***********************************************!*\
  !*** ./functions/src/models/lineConstants.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LINE_CONSTANTS: () => (/* binding */ LINE_CONSTANTS)\n/* harmony export */ });\n// functions/src/models/lineConstants.ts\n// Mismas constantes para el backend (TypeScript)\nconst LINE_CONSTANTS = {\n    STROKE_WIDTH: 2,\n    HIT_STROKE_WIDTH: 15,\n    DEFAULT_LENGTH: 100,\n    DEFAULT_COLOR: \"#000000\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvbW9kZWxzL2xpbmVDb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDMUMsTUFBTUEsaUJBQWlCO0lBQzVCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0FBQ2pCLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFxtb2RlbHNcXGxpbmVDb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy9tb2RlbHMvbGluZUNvbnN0YW50cy50c1xyXG4vLyBNaXNtYXMgY29uc3RhbnRlcyBwYXJhIGVsIGJhY2tlbmQgKFR5cGVTY3JpcHQpXHJcbmV4cG9ydCBjb25zdCBMSU5FX0NPTlNUQU5UUyA9IHtcclxuICBTVFJPS0VfV0lEVEg6IDIsXHJcbiAgSElUX1NUUk9LRV9XSURUSDogMTUsXHJcbiAgREVGQVVMVF9MRU5HVEg6IDEwMCxcclxuICBERUZBVUxUX0NPTE9SOiBcIiMwMDAwMDBcIlxyXG59OyJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsIlNUUk9LRV9XSURUSCIsIkhJVF9TVFJPS0VfV0lEVEgiLCJERUZBVUxUX0xFTkdUSCIsIkRFRkFVTFRfQ09MT1IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/models/lineConstants.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeObjetos.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   generarHTMLDesdeObjetos: () => (/* binding */ generarHTMLDesdeObjetos)\n/* harmony export */ });\n/* harmony import */ var _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/lineConstants */ \"(pages-dir-node)/./functions/src/models/lineConstants.ts\");\n\n// ✅ Escapar strings para meterlos en atributos/HTML\nfunction escHTML(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction escapeAttr(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction getLinkProps(obj) {\n    const raw = obj?.enlace;\n    if (!raw) return null;\n    if (typeof raw === \"string\") {\n        const href = escapeAttr(raw);\n        if (!href) return null;\n        return {\n            href,\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n        };\n    }\n    const href = escapeAttr(raw.href || \"\");\n    if (!href) return null;\n    const target = escapeAttr(raw.target || \"_blank\");\n    const rel = escapeAttr(raw.rel || \"noopener noreferrer\");\n    return {\n        href,\n        target,\n        rel\n    };\n}\nfunction envolverSiEnlace(htmlElemento, obj) {\n    if (obj?.tipo === \"rsvp-boton\") return htmlElemento;\n    const link = getLinkProps(obj);\n    if (!link) return htmlElemento;\n    return `<a href=\"${link.href}\" target=\"${link.target}\" rel=\"${link.rel}\" style=\"text-decoration:none;color:inherit;display:contents\">${htmlElemento}</a>`;\n}\nfunction escapeHTML(texto = \"\") {\n    return texto.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction generarHTMLDesdeObjetos(objetos, _secciones) {\n    const altoModoPorSeccion = new Map((_secciones || []).map((s)=>[\n            s.id,\n            String(s.altoModo || \"fijo\").toLowerCase()\n        ]));\n    function esSeccionPantalla(obj) {\n        const modo = altoModoPorSeccion.get(obj?.seccionId) || \"fijo\";\n        return modo === \"pantalla\";\n    }\n    function isFullBleed(obj) {\n        return String(obj?.anclaje || \"\").toLowerCase() === \"fullbleed\";\n    }\n    /**\r\n   * ✅ Escala uniforme del CONTENIDO:\r\n   * - pantalla: var(--sfinal) (fit si hace falta)\r\n   * - fijo: var(--sx)\r\n   */ function sContenidoVar(obj) {\n        return esSeccionPantalla(obj) ? \"var(--sfinal)\" : \"var(--sx)\";\n    }\n    /**\r\n   * ✅ X scale:\r\n   * - fullBleed: var(--bx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sX(obj) {\n        return isFullBleed(obj) ? \"var(--bx)\" : sContenidoVar(obj);\n    }\n    /**\r\n   * ✅ Y scale:\r\n   * - fullBleed: var(--sx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sY(obj) {\n        return isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n    }\n    function pxX(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return `calc(${sX(obj)} * ${n}px)`;\n    }\n    function pxY(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return `calc(${sY(obj)} * ${n}px)`;\n    }\n    // ===========================\n    // ✅ PANTALLA: top por porcentaje\n    // ===========================\n    const ALTURA_EDITOR_PANTALLA = 500;\n    // ✅ Offsets en secciones Pantalla: ON\n    // ⚠️ IMPORTANTE: este archivo SOLO genera objetos.\n    // El valor DESKTOP/MOBILE real se controla vía CSS global con:\n    //   :root { --pantalla-y-offset: Xpx }\n    //   @media (max-width: 640px) { :root { --pantalla-y-offset: Ypx } }\n    //\n    // Acá dejamos fallback (desktop) por si la variable CSS no existe.\n    const PANTALLA_Y_OFFSET_DESKTOP_PX = -28;\n    function clamp01(n) {\n        const x = Number(n);\n        if (!Number.isFinite(x)) return null;\n        return Math.max(0, Math.min(1, x));\n    }\n    function getYPxEditor(obj) {\n        // ✅ En Pantalla ON: yNorm es la fuente de verdad (0..1)\n        const yn = clamp01(obj?.yNorm);\n        if (yn != null) return yn * ALTURA_EDITOR_PANTALLA;\n        // fallback: si no hay yNorm, usamos y como \"editor px\"\n        const yPx = Number(obj?.y);\n        if (Number.isFinite(yPx)) return yPx;\n        return 0;\n    }\n    /**\r\n   * ✅ topCSS:\r\n   * - Pantalla ON: usa var(--vh-logical) * yn\r\n   * - Texto en Pantalla ON: suma offset (CSS var) escalado por sContenidoVar\r\n   * - Fijo: pxY(obj, y)\r\n   */ function topCSS(obj) {\n        if (esSeccionPantalla(obj)) {\n            const yPxEditor = getYPxEditor(obj);\n            const yn = clamp01(yPxEditor / ALTURA_EDITOR_PANTALLA) ?? 0;\n            // ✅ Altura “de diseño” escalada por el mismo factor que usan tamaños (sfinal)\n            const designScaledH = `(${sContenidoVar(obj)} * ${ALTURA_EDITOR_PANTALLA}px)`;\n            // ✅ Centrado vertical: si el viewport lógico es más alto que el diseño escalado,\n            // agregamos un offset constante. (En desktop suele dar ~0 porque sfinal = vh/500)\n            const centerOffset = `max(0px, calc((var(--vh-logical) - ${designScaledH}) / 2))`;\n            return `calc(\n  ${centerOffset}\n  + (${designScaledH} * ${yn})\n  + (${sContenidoVar(obj)} * var(--pantalla-y-offset, ${PANTALLA_Y_OFFSET_DESKTOP_PX}px))\n)`;\n        }\n        const y = Number(obj?.y || 0);\n        return pxY(obj, y);\n    }\n    /**\r\n   * ✅ Variante para cuando ya tenés yPx (en \"px editor\")\r\n   */ function topCSSFromYPx(obj, yPx) {\n        if (esSeccionPantalla(obj)) {\n            const yn = clamp01(yPx / ALTURA_EDITOR_PANTALLA) ?? 0;\n            return `calc((var(--vh-logical) * ${yn}) + (${sContenidoVar(obj)} * var(--pantalla-y-offset, ${PANTALLA_Y_OFFSET_DESKTOP_PX}px)))`;\n        }\n        return pxY(obj, yPx);\n    }\n    function stylePosBase(obj) {\n        const x = Number(obj?.x || 0);\n        const rot = obj?.rotation ?? 0;\n        const scaleX = obj?.scaleX ?? 1;\n        const scaleY = obj?.scaleY ?? 1;\n        const zIndex = Number.isFinite(obj?.zIndex) ? obj.zIndex : undefined;\n        return `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSS(obj)};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: top left;\n${zIndex !== undefined ? `z-index:${zIndex};` : \"\"}\npointer-events: auto;\n`.trim();\n    }\n    function styleSize(obj, w, h) {\n        const ww = Number.isFinite(w) ? w : undefined;\n        const hh = Number.isFinite(h) ? h : undefined;\n        const parts = [];\n        if (ww !== undefined) parts.push(`width: ${pxX(obj, ww)};`);\n        if (hh !== undefined) parts.push(`height: ${pxY(obj, hh)};`);\n        return parts.join(\"\\n\");\n    }\n    function renderIconoSvgNuevoInline(obj) {\n        const viewBox = obj.viewBox || \"0 0 24 24\";\n        const color = obj.color || \"#000\";\n        const paths = Array.isArray(obj.paths) ? obj.paths : [];\n        if (!paths.length) return \"\";\n        const w = Number.isFinite(obj?.width) ? obj.width : 24;\n        const h = Number.isFinite(obj?.height) ? obj.height : 24;\n        const rot = obj?.rotation ?? 0;\n        const scaleX = obj?.scaleX ?? 1;\n        const scaleY = obj?.scaleY ?? 1;\n        const x = Number(obj?.x || 0);\n        const yPx = getYPxEditor(obj);\n        const pathsHtml = paths.map((p)=>p?.d ? `<path d=\"${escHTML(p.d)}\" fill=\"${escHTML(color)}\"></path>` : \"\").join(\"\");\n        const style = `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSSFromYPx(obj, yPx)};\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: top left;\npointer-events: auto;\n`.trim();\n        return `<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${escHTML(viewBox)}\" style=\"${style}\">${pathsHtml}</svg>`;\n    }\n    return objetos.map((obj)=>{\n        const tipo = obj?.tipo;\n        // ---------------- TEXTO ----------------\n        if (tipo === \"texto\") {\n            const align = String(obj.align || obj.textAlign || \"left\").toLowerCase();\n            const color = obj.colorTexto || obj.color || obj.fill || \"#000\";\n            const baseLineHeight = typeof obj.lineHeight === \"number\" && obj.lineHeight > 0 ? obj.lineHeight : 1.2;\n            const lineHeightFinal = baseLineHeight * 0.92;\n            const safeTexto = escHTML(obj.texto || \"\");\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const fs = Number.isFinite(obj?.fontSize) ? obj.fontSize : 24;\n            // ⚠️ texto fullBleed NO hace fit => escala con var(--sx)\n            const sFont = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const rot = obj?.rotation ?? 0;\n            const scaleX = obj?.scaleX ?? 1;\n            const scaleY = obj?.scaleY ?? 1;\n            const origin = align === \"center\" ? \"top center\" : align === \"right\" ? \"top right\" : \"top left\";\n            const xComp = align === \"left\" ? \"calc((1 - var(--text-zoom, 1)) * 50%)\" : align === \"right\" ? \"calc((var(--text-zoom, 1) - 1) * 50%)\" : \"0px\";\n            const style = `\n${baseStyle}\n/* ✅ para que el zoom no “empuje” a la derecha */\ntransform-origin: ${origin};\n/* ✅ compensa el corrimiento por scale */\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY}) translateX(${xComp}) scale(var(--text-zoom, 1));\n${w !== undefined ? `width: ${pxX(obj, w)};` : \"\"}\nfont-size: calc(${sFont} * ${fs}px);\nfont-family: ${obj.fontFamily || \"sans-serif\"};\nfont-weight: ${obj.fontWeight || \"normal\"};\nfont-style: ${obj.fontStyle || \"normal\"};\ntext-decoration: ${obj.textDecoration || \"none\"};\ncolor: ${color};\ntext-align: ${align};\nwhite-space: pre-wrap;\nline-height: ${lineHeightFinal};\npadding: 0;\nmargin: 0;\nbox-sizing: content-box;\n${obj.stroke && obj.strokeWidth > 0 ? `-webkit-text-stroke: ${obj.strokeWidth}px ${obj.stroke};` : \"\"}\n${obj.shadowColor ? `text-shadow: ${obj.shadowOffsetX || 0}px ${obj.shadowOffsetY || 0}px ${obj.shadowBlur || 0}px ${obj.shadowColor};` : \"text-shadow: none;\"}\n`.trim();\n            return envolverSiEnlace(`<div class=\"objeto\" data-debug-texto=\"1\" style=\"${style}\">${safeTexto}</div>`, obj);\n        }\n        // ---------------- IMAGEN ----------------\n        if (tipo === \"imagen\") {\n            const src = obj.src || obj.url || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const style = `\n${baseStyle}\n${styleSize(obj, w, h)}\nobject-fit: contain;\ndisplay: block;\n`.trim();\n            return envolverSiEnlace(`<img class=\"objeto\" src=\"${escapeAttr(src)}\" style=\"${style}\" />`, obj);\n        }\n        // ---------------- ICONO (nuevo) ----------------\n        if (tipo === \"icono\") {\n            if (obj.formato === \"svg\") {\n                const svgHtml = renderIconoSvgNuevoInline(obj);\n                if (!svgHtml) return \"\";\n                return envolverSiEnlace(svgHtml, obj);\n            }\n            const src = obj.url || obj.src || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const style = `\n${baseStyle}\n${styleSize(obj, w, h)}\nobject-fit: contain;\ndisplay: block;\n`.trim();\n            return envolverSiEnlace(`<img class=\"objeto\" src=\"${escapeAttr(src)}\" style=\"${style}\" />`, obj);\n        }\n        // ---------------- ICONO LEGACY (icono-svg) ----------------\n        if (tipo === \"icono-svg\" && obj.d) {\n            const vb = obj.viewBox || \"0 0 100 100\";\n            const fill = obj.color || \"#000\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : 100;\n            const h = Number.isFinite(obj?.height) ? obj.height : 100;\n            const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nfill: ${escapeAttr(fill)};\n`.trim();\n            const svg = `<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${escapeAttr(vb)}\" style=\"${style}\"><path d=\"${escHTML(obj.d)}\" /></svg>`;\n            return envolverSiEnlace(svg, obj);\n        }\n        // ---------------- COUNTDOWN ----------------\n        if (tipo === \"countdown\") {\n            const targetISO = obj.targetISO || obj.fechaObjetivo || obj.fechaISO || \"\";\n            const textColor = obj.colorTexto ?? obj.color ?? \"#111\";\n            const fontFamily = obj.fontFamily || \"Inter, system-ui, sans-serif\";\n            const preset = obj.presetId || obj.layout || \"pills\";\n            const isMinimal = String(preset).toLowerCase().includes(\"minimal\");\n            // ✅ ancho/alto del objeto (si existen)\n            const wObj = Number.isFinite(obj?.width) ? Number(obj.width) : null;\n            const hObj = Number.isFinite(obj?.height) ? Number(obj.height) : null;\n            // ✅ gap: si viene de Konva, respetarlo\n            const gap = Number.isFinite(obj.gap) ? Number(obj.gap) : Number.isFinite(obj.spacing) ? Number(obj.spacing) : 8;\n            // ✅ Si tu Konva guarda chipWidth / paddingX, respetalos\n            // chipWidth: ancho interno del texto (sin padding)\n            const chipWidthProp = Number.isFinite(obj.chipWidth) ? Number(obj.chipWidth) : null;\n            const paddingXProp = Number.isFinite(obj.paddingX) ? Number(obj.paddingX) : null;\n            // ✅ Derivación raíz (cuando no hay props)\n            const n = 4;\n            // chipWTotal: ancho total de cada chip (incluye padding)\n            let chipWTotal = 56; // fallback razonable\n            if (wObj && wObj > 0) {\n                chipWTotal = Math.max(40, (wObj - gap * (n - 1)) / n);\n            }\n            // paddingX derivado del chipWTotal (si no vino)\n            const paddingX = paddingXProp ?? Math.max(6, Math.round(chipWTotal * 0.18)); // ~18%\n            const paddingY = Math.max(5, Math.round(paddingX * 0.65));\n            // chipWidth (texto) derivado si no vino\n            const chipWidth = chipWidthProp ?? Math.max(10, Math.round(chipWTotal - paddingX * 2));\n            // ✅ font sizes: si vienen, respetar; si no, derivar desde chipWTotal\n            const valueSize = Number.isFinite(obj.fontSize) ? Number(obj.fontSize) : Math.max(14, Math.round(chipWTotal * 0.34));\n            const labelSize = Number.isFinite(obj.labelSize) ? Number(obj.labelSize) : Math.max(9, Math.round(valueSize * 0.62));\n            const labelColor = obj.labelColor ?? \"#6b7280\";\n            const fontWeight = Number.isFinite(obj.fontWeight) ? obj.fontWeight : 700;\n            const letterSpacing = Number.isFinite(obj.letterSpacing) ? obj.letterSpacing : 0;\n            // ✅ estilos de chip\n            const containerBgFinal = \"transparent\";\n            const chipBgFinal = isMinimal ? \"transparent\" : obj.chipBackground ?? obj.boxBg ?? \"rgba(255,255,255,.75)\";\n            const chipBorderColorFinal = isMinimal ? \"transparent\" : obj.chipBorder ?? obj.boxBorder ?? \"rgba(0,0,0,.08)\";\n            const containerRadius = Number.isFinite(obj.boxRadius) ? obj.boxRadius : Number.isFinite(obj.radius) ? obj.radius : 10;\n            const chipRadiusFinal = Number.isFinite(obj.chipRadius) ? obj.chipRadius : containerRadius;\n            const baseStyle = stylePosBase(obj);\n            // ✅ Escala correcta (respeta pantalla y bleed)\n            const sChip = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const containerStyle = `\n${baseStyle}\n${wObj ? `width: ${pxX(obj, wObj)};` : \"\"}\n${hObj ? `height: ${pxY(obj, hObj)};` : \"\"}\ndisplay: flex;\nalign-items: center;\njustify-content: center;\ngap: calc(${sChip} * ${gap}px);\nfont-family: ${fontFamily};\ncolor: ${textColor};\nbackground: ${containerBgFinal};\nborder-radius: calc(${sChip} * ${containerRadius}px);\nletter-spacing: calc(${sChip} * ${letterSpacing}px);\n`.trim();\n            const chipStyle = `\nwidth: calc(${sChip} * ${Math.round(chipWTotal)}px);\npadding: calc(${sChip} * ${paddingY}px) calc(${sChip} * ${paddingX}px);\nborder: ${isMinimal ? \"0\" : `calc(${sChip} * 1px) solid ${chipBorderColorFinal}`};\nborder-radius: calc(${sChip} * ${chipRadiusFinal}px);\ndisplay: flex;\nflex-direction: column;\nalign-items: center;\njustify-content: center;\nbackground: ${chipBgFinal};\nbox-sizing: border-box;\n`.trim();\n            const valueStyle = `\nfont-weight: ${fontWeight};\nfont-size: calc(${sChip} * ${valueSize}px);\nline-height: 1;\n`.trim();\n            const labelStyle = `\nfont-size: calc(${sChip} * ${labelSize}px);\ncolor: ${labelColor};\nline-height: 1.05;\n`.trim();\n            const showLabels = obj.showLabels !== false;\n            const labels = obj.labels ?? {\n                dias: \"Días\",\n                horas: \"Horas\",\n                min: \"Min\",\n                seg: \"Seg\"\n            };\n            return `\n<div class=\"objeto\"\n  data-mobile-cluster=\"isolated\"\n  data-mobile-center=\"force\"\n  data-countdown\n  data-target=\"${escapeAttr(targetISO)}\"\n  data-preset=\"${escapeAttr(preset)}\" style=\"${containerStyle}\">\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.dias)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.horas)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.min)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.seg)}</span>` : \"\"}\n  </div>\n</div>\n`.trim();\n        }\n        // ---------------- GALERÍA ----------------\n        if (tipo === \"galeria\") {\n            const rows = Math.max(1, parseInt(obj.rows || 1, 10));\n            const cols = Math.max(1, parseInt(obj.cols || 1, 10));\n            const gapPx = Math.max(0, parseInt(obj.gap || 0, 10));\n            const radiusPx = Math.max(0, parseInt(obj.radius || 0, 10));\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const sGrid = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const styleContenedor = `\n${baseStyle}\n${styleSize(obj, w, h)}\ndisplay: grid;\ngrid-template-columns: repeat(${cols}, 1fr);\ngrid-template-rows: repeat(${rows}, 1fr);\ngap: calc(${sGrid} * ${gapPx}px);\nbox-sizing: border-box;\n`.trim();\n            const total = rows * cols;\n            const cells = Array.from({\n                length: total\n            }, (_, i)=>{\n                const c = obj.cells && obj.cells[i] || {};\n                return {\n                    mediaUrl: c.mediaUrl || \"\",\n                    fit: c.fit === \"contain\" ? \"contain\" : \"cover\",\n                    bg: c.bg || \"#f3f4f6\"\n                };\n            });\n            const htmlCeldas = cells.map((cell, idx)=>{\n                const safeSrc = escapeAttr(cell.mediaUrl || \"\");\n                const celdaStyle = `\nposition: relative;\nwidth: 100%;\nheight: 100%;\noverflow: hidden;\nborder-radius: calc(${sGrid} * ${radiusPx}px);\nbackground: ${cell.bg};\n`.trim();\n                if (!safeSrc) {\n                    return `<div class=\"galeria-celda\" data-index=\"${idx}\" style=\"${celdaStyle}\"></div>`;\n                }\n                return `\n<div class=\"galeria-celda\" data-index=\"${idx}\" style=\"${celdaStyle}\">\n  <img src=\"${safeSrc}\" alt=\"\" loading=\"lazy\" decoding=\"async\"\n       style=\"width:100%;height:100%;object-fit:${cell.fit};display:block;\" />\n</div>\n`.trim();\n            }).join(\"\");\n            const htmlGaleria = `<div class=\"objeto galeria\" style=\"${styleContenedor}\">${htmlCeldas}</div>`;\n            return envolverSiEnlace(htmlGaleria, obj);\n        }\n        // ---------------- RSVP BOTÓN ----------------\n        if (tipo === \"rsvp-boton\") {\n            const texto = escapeHTML(obj.texto || \"Confirmar asistencia\");\n            const w = Number.isFinite(obj?.ancho) ? obj.ancho : 200;\n            const h = Number.isFinite(obj?.alto) ? obj.alto : 50;\n            const color = obj.color || \"#773dbe\";\n            const colorTexto = obj.colorTexto || \"#ffffff\";\n            const fontSize = Number.isFinite(obj?.fontSize) ? obj.fontSize : 18;\n            const fontFamily = obj.fontFamily || \"sans-serif\";\n            const fontWeight = obj.fontWeight || \"bold\";\n            const fontStyle = obj.fontStyle || \"normal\";\n            const textDecoration = obj.textDecoration || \"none\";\n            const align = obj.align || \"center\";\n            const baseStyle = stylePosBase(obj);\n            // RSVP (contenido): si está en pantalla, fittea (sContenidoVar)\n            const sBtn = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nbackground-color: ${color};\ncolor: ${colorTexto};\nfont-size: calc(${sBtn} * ${fontSize}px);\nfont-family: ${fontFamily};\nfont-weight: ${fontWeight};\nfont-style: ${fontStyle};\ntext-decoration: ${textDecoration};\ntext-align: ${align};\ndisplay: flex;\nalign-items: center;\njustify-content: center;\nborder-radius: calc(${sBtn} * 8px);\ncursor: pointer;\n`.trim();\n            return `\n<div class=\"objeto is-interactive rsvp-boton\"\n  id=\"abrirModalRSVP\"\n  data-accion=\"abrir-rsvp\"\n  data-rsvp-open\n  role=\"button\"\n  tabindex=\"0\"\n  aria-label=\"Confirmar asistencia\"\n  style=\"${style}\">\n  ${texto}\n</div>\n`.trim();\n        }\n        // ---------------- FORMAS ----------------\n        if (tipo === \"forma\") {\n            const fill = obj.color || \"#000\";\n            const figura = obj.figura;\n            if (figura === \"rect\") {\n                const w = Number.isFinite(obj?.width) ? obj.width : 100;\n                const h = Number.isFinite(obj?.height) ? obj.height : 100;\n                const cornerRadius = obj.cornerRadius || 0;\n                const fontSize = obj.fontSize || 24;\n                const fontFamily = obj.fontFamily || \"sans-serif\";\n                const fontWeight = obj.fontWeight || \"normal\";\n                const fontStyle = obj.fontStyle || \"normal\";\n                const textDecoration = obj.textDecoration || \"none\";\n                const align = obj.align || \"center\";\n                const colorTexto = obj.colorTexto || \"#000000\";\n                const texto = escHTML(obj.texto || \"\");\n                const baseStyle = stylePosBase(obj);\n                const sRectText = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n                const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nbackground: ${fill};\nborder-radius: calc(${sRectText} * ${cornerRadius}px);\ndisplay: flex;\nalign-items: center;\njustify-content: ${align === \"left\" ? \"flex-start\" : align === \"right\" ? \"flex-end\" : \"center\"};\ntext-align: ${align};\npadding: calc(${sRectText} * 4px);\nbox-sizing: border-box;\n`.trim();\n                const inner = `\n<div style=\"\n  width: 100%;\n  font-size: calc(${sRectText} * ${fontSize}px);\n  font-family: ${fontFamily};\n  font-weight: ${fontWeight};\n  font-style: ${fontStyle};\n  text-decoration: ${textDecoration};\n  color: ${colorTexto};\n  line-height: 1.2;\n  white-space: pre-wrap;\n  word-break: break-word;\n\">${texto}</div>\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${style}\">${inner}</div>`, obj);\n            }\n            if (figura === \"circle\") {\n                const radius = Number.isFinite(obj?.radius) ? obj.radius : 50;\n                const diameter = radius * 2;\n                const x = Number(obj?.x || 0) - radius;\n                const yPxCenter = getYPxEditor(obj);\n                const yPxTopLeft = yPxCenter - radius;\n                const rot = obj?.rotation ?? 0;\n                const scaleX = obj?.scaleX ?? 1;\n                const scaleY = obj?.scaleY ?? 1;\n                const style = `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSSFromYPx(obj, yPxTopLeft)};\nwidth: ${pxX(obj, diameter)};\nheight: ${pxY(obj, diameter)};\nborder-radius: 50%;\nbackground: ${fill};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: center center;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${style}\"></div>`, obj);\n            }\n            if (figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH,\n                    0\n                ];\n                const x1 = parseFloat(points[0]) || 0;\n                const y1 = parseFloat(points[1]) || 0;\n                const x2 = parseFloat(points[2]) || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH;\n                const y2 = parseFloat(points[3]) || 0;\n                const strokeWidth = obj.strokeWidth || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.STROKE_WIDTH;\n                const deltaX = x2 - x1;\n                const deltaY = y2 - y1;\n                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n                const startX = Number(obj?.x || 0) + x1;\n                const baseY = getYPxEditor(obj);\n                const startY = baseY + y1;\n                const totalRotation = angle + (obj.rotation || 0);\n                const scaleX = obj?.scaleX ?? 1;\n                const scaleY = obj?.scaleY ?? 1;\n                // alto de línea: usamos escala Y del objeto (contenido: sfinal/sx, bleed: sx)\n                const lineH = `calc(${sY(obj)} * ${strokeWidth}px)`;\n                const style = `\nposition: absolute;\nleft: ${pxX(obj, startX)};\ntop: ${topCSSFromYPx(obj, startY)};\nwidth: ${pxX(obj, length)};\nheight: ${lineH};\nbackground: ${fill};\ntransform: rotate(${totalRotation}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: 0 50%;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto linea\" style=\"${style}\"></div>`, obj);\n            }\n            if (figura === \"triangle\") {\n                const radius = obj.radius || 60;\n                const sin60 = Math.sqrt(3) / 2;\n                const cos60 = 0.5;\n                const triangleWidth = 2 * radius * sin60;\n                const triangleHeight = radius * (1 + cos60);\n                const centroidOffsetY = triangleHeight / 3;\n                const baseY = getYPxEditor(obj);\n                const topContainerPx = baseY - (triangleHeight - centroidOffsetY);\n                const leftContainer = Number(obj?.x || 0) - triangleWidth / 2;\n                const baseStyle = `\nposition: absolute;\nleft: ${pxX(obj, leftContainer)};\ntop: ${topCSSFromYPx(obj, topContainerPx)};\nwidth: ${pxX(obj, triangleWidth)};\nheight: ${pxY(obj, triangleHeight)};\nbackground: ${fill};\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%);\ntransform: rotate(${obj.rotation ?? 0}deg) scale(${obj.scaleX ?? 1}, ${obj.scaleY ?? 1});\ntransform-origin: center center;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${baseStyle}\"></div>`, obj);\n            }\n            return \"\";\n        }\n        return \"\";\n    }).join(\"\\n\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBRXpELG9EQUFvRDtBQUNwRCxTQUFTQyxRQUFRQyxNQUFXLEVBQUU7SUFDNUIsT0FBT0MsT0FBT0QsS0FDWEUsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxTQUFTQyxXQUFXSCxNQUFjLEVBQUU7SUFDbEMsT0FBT0MsT0FBT0QsS0FDWEUsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxTQUFTRSxhQUFhQyxHQUFRO0lBQzVCLE1BQU1DLE1BQU1ELEtBQUtFO0lBQ2pCLElBQUksQ0FBQ0QsS0FBSyxPQUFPO0lBRWpCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQzNCLE1BQU1FLE9BQU9MLFdBQVdHO1FBQ3hCLElBQUksQ0FBQ0UsTUFBTSxPQUFPO1FBQ2xCLE9BQU87WUFBRUE7WUFBTUMsUUFBUTtZQUFVQyxLQUFLO1FBQXNCO0lBQzlEO0lBRUEsTUFBTUYsT0FBT0wsV0FBV0csSUFBSUUsSUFBSSxJQUFJO0lBQ3BDLElBQUksQ0FBQ0EsTUFBTSxPQUFPO0lBRWxCLE1BQU1DLFNBQVNOLFdBQVdHLElBQUlHLE1BQU0sSUFBSTtJQUN4QyxNQUFNQyxNQUFNUCxXQUFXRyxJQUFJSSxHQUFHLElBQUk7SUFDbEMsT0FBTztRQUFFRjtRQUFNQztRQUFRQztJQUFJO0FBQzdCO0FBRUEsU0FBU0MsaUJBQWlCQyxZQUFvQixFQUFFUCxHQUFRO0lBQ3RELElBQUlBLEtBQUtRLFNBQVMsY0FBYyxPQUFPRDtJQUV2QyxNQUFNRSxPQUFPVixhQUFhQztJ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aUUsS0FBSTtnQkFDekMsTUFBTUcsa0JBQWtCRCxpQkFBaUI7Z0JBRXpDLE1BQU1QLFFBQVFsSyxhQUFhNUM7Z0JBQzNCLE1BQU11TixpQkFBaUJULFFBQVNPLENBQUFBLGlCQUFpQkMsZUFBYztnQkFDL0QsTUFBTUUsZ0JBQWdCdEwsT0FBT2xDLEtBQUt3QyxLQUFLLEtBQUs0SyxnQkFBZ0I7Z0JBRTVELE1BQU16SCxZQUFZLENBQUM7O01BRXZCLEVBQUU1RCxJQUFJL0IsS0FBS3dOLGVBQWU7S0FDM0IsRUFBRW5LLGNBQWNyRCxLQUFLdU4sZ0JBQWdCO09BQ25DLEVBQUV4TCxJQUFJL0IsS0FBS29OLGVBQWU7UUFDekIsRUFBRWhMLElBQUlwQyxLQUFLcU4sZ0JBQWdCO1lBQ3ZCLEVBQUUvSCxLQUFLOztrQkFFRCxFQUFFdEYsSUFBSXdELFFBQVEsSUFBSSxFQUFFLFdBQVcsRUFBRXhELElBQUl5RCxNQUFNLElBQUksRUFBRSxFQUFFLEVBQUV6RCxJQUFJMEQsTUFBTSxJQUFJLEVBQUU7OztBQUd2RixDQUFDLENBQUNHLElBQUk7Z0JBRUksT0FBT3ZELGlCQUFpQixDQUFDLDJCQUEyQixFQUFFcUYsVUFBVSxRQUFRLENBQUMsRUFBRTNGO1lBQzdFO1lBRUEsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNULEdBQ0NxRSxJQUFJLENBQUM7QUFDViIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxnZW5lcmFySFRNTERlc2RlT2JqZXRvcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMSU5FX0NPTlNUQU5UUyB9IGZyb20gXCIuLi9tb2RlbHMvbGluZUNvbnN0YW50c1wiO1xyXG5cclxuLy8g4pyFIEVzY2FwYXIgc3RyaW5ncyBwYXJhIG1ldGVybG9zIGVuIGF0cmlidXRvcy9IVE1MXHJcbmZ1bmN0aW9uIGVzY0hUTUwoc3RyOiBhbnkgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gU3RyaW5nKHN0cilcclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcclxuICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHN0cjogc3RyaW5nID0gXCJcIik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIFN0cmluZyhzdHIpXHJcbiAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXHJcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcclxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRMaW5rUHJvcHMob2JqOiBhbnkpIHtcclxuICBjb25zdCByYXcgPSBvYmo/LmVubGFjZTtcclxuICBpZiAoIXJhdykgcmV0dXJuIG51bGw7XHJcblxyXG4gIGlmICh0eXBlb2YgcmF3ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBjb25zdCBocmVmID0gZXNjYXBlQXR0cihyYXcpO1xyXG4gICAgaWYgKCFocmVmKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB7IGhyZWYsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaHJlZiA9IGVzY2FwZUF0dHIocmF3LmhyZWYgfHwgXCJcIik7XHJcbiAgaWYgKCFocmVmKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgY29uc3QgdGFyZ2V0ID0gZXNjYXBlQXR0cihyYXcudGFyZ2V0IHx8IFwiX2JsYW5rXCIpO1xyXG4gIGNvbnN0IHJlbCA9IGVzY2FwZUF0dHIocmF3LnJlbCB8fCBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIik7XHJcbiAgcmV0dXJuIHsgaHJlZiwgdGFyZ2V0LCByZWwgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW52b2x2ZXJTaUVubGFjZShodG1sRWxlbWVudG86IHN0cmluZywgb2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gIGlmIChvYmo/LnRpcG8gPT09IFwicnN2cC1ib3RvblwiKSByZXR1cm4gaHRtbEVsZW1lbnRvO1xyXG5cclxuICBjb25zdCBsaW5rID0gZ2V0TGlua1Byb3BzKG9iaik7XHJcbiAgaWYgKCFsaW5rKSByZXR1cm4gaHRtbEVsZW1lbnRvO1xyXG5cclxuICByZXR1cm4gYDxhIGhyZWY9XCIke2xpbmsuaHJlZn1cIiB0YXJnZXQ9XCIke2xpbmsudGFyZ2V0fVwiIHJlbD1cIiR7bGluay5yZWx9XCIgc3R5bGU9XCJ0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjppbmhlcml0O2Rpc3BsYXk6Y29udGVudHNcIj4ke2h0bWxFbGVtZW50b308L2E+YDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUhUTUwodGV4dG86IHN0cmluZyA9IFwiXCIpOiBzdHJpbmcge1xyXG4gIHJldHVybiB0ZXh0b1xyXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcclxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxyXG4gICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyhvYmpldG9zOiBhbnlbXSwgX3NlY2Npb25lczogYW55W10pOiBzdHJpbmcge1xyXG4gIGNvbnN0IGFsdG9Nb2RvUG9yU2VjY2lvbiA9IG5ldyBNYXAoXHJcbiAgICAoX3NlY2Npb25lcyB8fCBbXSkubWFwKChzOiBhbnkpID0+IFtzLmlkLCBTdHJpbmcocy5hbHRvTW9kbyB8fCBcImZpam9cIikudG9Mb3dlckNhc2UoKV0pXHJcbiAgKTtcclxuXHJcbiAgZnVuY3Rpb24gZXNTZWNjaW9uUGFudGFsbGEob2JqOiBhbnkpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IG1vZG8gPSBhbHRvTW9kb1BvclNlY2Npb24uZ2V0KG9iaj8uc2VjY2lvbklkKSB8fCBcImZpam9cIjtcclxuICAgIHJldHVybiBtb2RvID09PSBcInBhbnRhbGxhXCI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0Z1bGxCbGVlZChvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIFN0cmluZyhvYmo/LmFuY2xhamUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJmdWxsYmxlZWRcIjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOKchSBFc2NhbGEgdW5pZm9ybWUgZGVsIENPTlRFTklETzpcclxuICAgKiAtIHBhbnRhbGxhOiB2YXIoLS1zZmluYWwpIChmaXQgc2kgaGFjZSBmYWx0YSlcclxuICAgKiAtIGZpam86IHZhcigtLXN4KVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNDb250ZW5pZG9WYXIob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGVzU2VjY2lvblBhbnRhbGxhKG9iaikgPyBcInZhcigtLXNmaW5hbClcIiA6IFwidmFyKC0tc3gpXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgWCBzY2FsZTpcclxuICAgKiAtIGZ1bGxCbGVlZDogdmFyKC0tYngpIChOTyBmaXQpXHJcbiAgICogLSBjb250ZW5pZG86IHNDb250ZW5pZG9WYXIgKGZpdCBzaSBwYW50YWxsYSlcclxuICAgKi9cclxuICBmdW5jdGlvbiBzWChvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tYngpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgWSBzY2FsZTpcclxuICAgKiAtIGZ1bGxCbGVlZDogdmFyKC0tc3gpIChOTyBmaXQpXHJcbiAgICogLSBjb250ZW5pZG86IHNDb250ZW5pZG9WYXIgKGZpdCBzaSBwYW50YWxsYSlcclxuICAgKi9cclxuICBmdW5jdGlvbiBzWShvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBweFgob2JqOiBhbnksIHB4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbiA9IE51bWJlci5pc0Zpbml0ZShweCkgPyBweCA6IDA7XHJcbiAgICByZXR1cm4gYGNhbGMoJHtzWChvYmopfSAqICR7bn1weClgO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHhZKG9iajogYW55LCBweDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG4gPSBOdW1iZXIuaXNGaW5pdGUocHgpID8gcHggOiAwO1xyXG4gICAgcmV0dXJuIGBjYWxjKCR7c1kob2JqKX0gKiAke259cHgpYDtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIOKchSBQQU5UQUxMQTogdG9wIHBvciBwb3JjZW50YWplXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgY29uc3QgQUxUVVJBX0VESVRPUl9QQU5UQUxMQSA9IDUwMDtcclxuXHJcbiAgLy8g4pyFIE9mZnNldHMgZW4gc2VjY2lvbmVzIFBhbnRhbGxhOiBPTlxyXG4gIC8vIOKaoO+4jyBJTVBPUlRBTlRFOiBlc3RlIGFyY2hpdm8gU09MTyBnZW5lcmEgb2JqZXRvcy5cclxuICAvLyBFbCB2YWxvciBERVNLVE9QL01PQklMRSByZWFsIHNlIGNvbnRyb2xhIHbDrWEgQ1NTIGdsb2JhbCBjb246XHJcbiAgLy8gICA6cm9vdCB7IC0tcGFudGFsbGEteS1vZmZzZXQ6IFhweCB9XHJcbiAgLy8gICBAbWVkaWEgKG1heC13aWR0aDogNjQwcHgpIHsgOnJvb3QgeyAtLXBhbnRhbGxhLXktb2Zmc2V0OiBZcHggfSB9XHJcbiAgLy9cclxuICAvLyBBY8OhIGRlamFtb3MgZmFsbGJhY2sgKGRlc2t0b3ApIHBvciBzaSBsYSB2YXJpYWJsZSBDU1Mgbm8gZXhpc3RlLlxyXG4gIGNvbnN0IFBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFggPSAtMjg7XHJcblxyXG4gIGZ1bmN0aW9uIGNsYW1wMDEobjogYW55KTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICBjb25zdCB4ID0gTnVtYmVyKG4pO1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFlQeEVkaXRvcihvYmo6IGFueSk6IG51bWJlciB7XHJcbiAgICAvLyDinIUgRW4gUGFudGFsbGEgT046IHlOb3JtIGVzIGxhIGZ1ZW50ZSBkZSB2ZXJkYWQgKDAuLjEpXHJcbiAgICBjb25zdCB5biA9IGNsYW1wMDEob2JqPy55Tm9ybSk7XHJcbiAgICBpZiAoeW4gIT0gbnVsbCkgcmV0dXJuIHluICogQUxUVVJBX0VESVRPUl9QQU5UQUxMQTtcclxuXHJcbiAgICAvLyBmYWxsYmFjazogc2kgbm8gaGF5IHlOb3JtLCB1c2Ftb3MgeSBjb21vIFwiZWRpdG9yIHB4XCJcclxuICAgIGNvbnN0IHlQeCA9IE51bWJlcihvYmo/LnkpO1xyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh5UHgpKSByZXR1cm4geVB4O1xyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog4pyFIHRvcENTUzpcclxuICAgKiAtIFBhbnRhbGxhIE9OOiB1c2EgdmFyKC0tdmgtbG9naWNhbCkgKiB5blxyXG4gICAqIC0gVGV4dG8gZW4gUGFudGFsbGEgT046IHN1bWEgb2Zmc2V0IChDU1MgdmFyKSBlc2NhbGFkbyBwb3Igc0NvbnRlbmlkb1ZhclxyXG4gICAqIC0gRmlqbzogcHhZKG9iaiwgeSlcclxuICAgKi9cclxuICBmdW5jdGlvbiB0b3BDU1Mob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgaWYgKGVzU2VjY2lvblBhbnRhbGxhKG9iaikpIHtcclxuICAgICAgY29uc3QgeVB4RWRpdG9yID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcbiAgICAgIGNvbnN0IHluID0gY2xhbXAwMSh5UHhFZGl0b3IgLyBBTFRVUkFfRURJVE9SX1BBTlRBTExBKSA/PyAwO1xyXG5cclxuXHJcbiAgICAgIC8vIOKchSBBbHR1cmEg4oCcZGUgZGlzZcOxb+KAnSBlc2NhbGFkYSBwb3IgZWwgbWlzbW8gZmFjdG9yIHF1ZSB1c2FuIHRhbWHDsW9zIChzZmluYWwpXHJcbiAgICAgIGNvbnN0IGRlc2lnblNjYWxlZEggPSBgKCR7c0NvbnRlbmlkb1ZhcihvYmopfSAqICR7QUxUVVJBX0VESVRPUl9QQU5UQUxMQX1weClgO1xyXG5cclxuICAgICAgLy8g4pyFIENlbnRyYWRvIHZlcnRpY2FsOiBzaSBlbCB2aWV3cG9ydCBsw7NnaWNvIGVzIG3DoXMgYWx0byBxdWUgZWwgZGlzZcOxbyBlc2NhbGFkbyxcclxuICAgICAgLy8gYWdyZWdhbW9zIHVuIG9mZnNldCBjb25zdGFudGUuIChFbiBkZXNrdG9wIHN1ZWxlIGRhciB+MCBwb3JxdWUgc2ZpbmFsID0gdmgvNTAwKVxyXG4gICAgICBjb25zdCBjZW50ZXJPZmZzZXQgPSBgbWF4KDBweCwgY2FsYygodmFyKC0tdmgtbG9naWNhbCkgLSAke2Rlc2lnblNjYWxlZEh9KSAvIDIpKWA7XHJcblxyXG4gICAgICByZXR1cm4gYGNhbGMoXHJcbiAgJHtjZW50ZXJPZmZzZXR9XHJcbiAgKyAoJHtkZXNpZ25TY2FsZWRIfSAqICR7eW59KVxyXG4gICsgKCR7c0NvbnRlbmlkb1ZhcihvYmopfSAqIHZhcigtLXBhbnRhbGxhLXktb2Zmc2V0LCAke1BBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFh9cHgpKVxyXG4pYDtcclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB5ID0gTnVtYmVyKG9iaj8ueSB8fCAwKTtcclxuICAgIHJldHVybiBweFkob2JqLCB5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOKchSBWYXJpYW50ZSBwYXJhIGN1YW5kbyB5YSB0ZW7DqXMgeVB4IChlbiBcInB4IGVkaXRvclwiKVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRvcENTU0Zyb21ZUHgob2JqOiBhbnksIHlQeDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGlmIChlc1NlY2Npb25QYW50YWxsYShvYmopKSB7XHJcbiAgICAgIGNvbnN0IHluID0gY2xhbXAwMSh5UHggLyBBTFRVUkFfRURJVE9SX1BBTlRBTExBKSA/PyAwO1xyXG5cclxuXHJcbiAgICAgIHJldHVybiBgY2FsYygodmFyKC0tdmgtbG9naWNhbCkgKiAke3lufSkgKyAoJHtzQ29udGVuaWRvVmFyKFxyXG4gICAgICAgIG9ialxyXG4gICAgICApfSAqIHZhcigtLXBhbnRhbGxhLXktb2Zmc2V0LCAke1BBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFh9cHgpKSlgO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHhZKG9iaiwgeVB4KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0eWxlUG9zQmFzZShvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCB4ID0gTnVtYmVyKG9iaj8ueCB8fCAwKTtcclxuXHJcbiAgICBjb25zdCByb3QgPSBvYmo/LnJvdGF0aW9uID8/IDA7XHJcbiAgICBjb25zdCBzY2FsZVggPSBvYmo/LnNjYWxlWCA/PyAxO1xyXG4gICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICBjb25zdCB6SW5kZXggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy56SW5kZXgpID8gb2JqLnpJbmRleCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICByZXR1cm4gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgeCl9O1xyXG50b3A6ICR7dG9wQ1NTKG9iail9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XHJcbiR7ekluZGV4ICE9PSB1bmRlZmluZWQgPyBgei1pbmRleDoke3pJbmRleH07YCA6IFwiXCJ9XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0eWxlU2l6ZShvYmo6IGFueSwgdz86IG51bWJlciwgaD86IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCB3dyA9IE51bWJlci5pc0Zpbml0ZSh3KSA/ICh3IGFzIG51bWJlcikgOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBoaCA9IE51bWJlci5pc0Zpbml0ZShoKSA/IChoIGFzIG51bWJlcikgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XHJcbiAgICBpZiAod3cgIT09IHVuZGVmaW5lZCkgcGFydHMucHVzaChgd2lkdGg6ICR7cHhYKG9iaiwgd3cpfTtgKTtcclxuICAgIGlmIChoaCAhPT0gdW5kZWZpbmVkKSBwYXJ0cy5wdXNoKGBoZWlnaHQ6ICR7cHhZKG9iaiwgaGgpfTtgKTtcclxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVySWNvbm9TdmdOdWV2b0lubGluZShvYmo6IGFueSkge1xyXG4gICAgY29uc3Qgdmlld0JveCA9IG9iai52aWV3Qm94IHx8IFwiMCAwIDI0IDI0XCI7XHJcbiAgICBjb25zdCBjb2xvciA9IG9iai5jb2xvciB8fCBcIiMwMDBcIjtcclxuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShvYmoucGF0aHMpID8gb2JqLnBhdGhzIDogW107XHJcbiAgICBpZiAoIXBhdGhzLmxlbmd0aCkgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IDI0O1xyXG4gICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogMjQ7XHJcblxyXG4gICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgY29uc3QgeCA9IE51bWJlcihvYmo/LnggfHwgMCk7XHJcbiAgICBjb25zdCB5UHggPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuXHJcbiAgICBjb25zdCBwYXRoc0h0bWwgPSBwYXRoc1xyXG4gICAgICAubWFwKChwOiBhbnkpID0+IChwPy5kID8gYDxwYXRoIGQ9XCIke2VzY0hUTUwocC5kKX1cIiBmaWxsPVwiJHtlc2NIVE1MKGNvbG9yKX1cIj48L3BhdGg+YCA6IFwiXCIpKVxyXG4gICAgICAuam9pbihcIlwiKTtcclxuXHJcbiAgICBjb25zdCBzdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHgpfTtcclxudG9wOiAke3RvcENTU0Zyb21ZUHgob2JqLCB5UHgpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgdyl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgaCl9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICByZXR1cm4gYDxzdmcgY2xhc3M9XCJvYmpldG9cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIiR7ZXNjSFRNTChcclxuICAgICAgdmlld0JveFxyXG4gICAgKX1cIiBzdHlsZT1cIiR7c3R5bGV9XCI+JHtwYXRoc0h0bWx9PC9zdmc+YDtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYmpldG9zXHJcbiAgICAubWFwKChvYmopID0+IHtcclxuICAgICAgY29uc3QgdGlwbyA9IG9iaj8udGlwbztcclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gVEVYVE8gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJ0ZXh0b1wiKSB7XHJcbiAgICAgICAgY29uc3QgYWxpZ24gPSBTdHJpbmcob2JqLmFsaWduIHx8IG9iai50ZXh0QWxpZ24gfHwgXCJsZWZ0XCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBvYmouY29sb3JUZXh0byB8fCBvYmouY29sb3IgfHwgb2JqLmZpbGwgfHwgXCIjMDAwXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VMaW5lSGVpZ2h0ID1cclxuICAgICAgICAgIHR5cGVvZiBvYmoubGluZUhlaWdodCA9PT0gXCJudW1iZXJcIiAmJiBvYmoubGluZUhlaWdodCA+IDAgPyBvYmoubGluZUhlaWdodCA6IDEuMjtcclxuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0RmluYWwgPSBiYXNlTGluZUhlaWdodCAqIDAuOTI7XHJcblxyXG4gICAgICAgIGNvbnN0IHNhZmVUZXh0byA9IGVzY0hUTUwob2JqLnRleHRvIHx8IFwiXCIpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG5cclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGZzID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uZm9udFNpemUpID8gb2JqLmZvbnRTaXplIDogMjQ7XHJcblxyXG4gICAgICAgIC8vIOKaoO+4jyB0ZXh0byBmdWxsQmxlZWQgTk8gaGFjZSBmaXQgPT4gZXNjYWxhIGNvbiB2YXIoLS1zeClcclxuICAgICAgICBjb25zdCBzRm9udCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCByb3QgPSBvYmo/LnJvdGF0aW9uID8/IDA7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgICAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgICAgICBjb25zdCBvcmlnaW4gPVxyXG4gICAgICAgICAgYWxpZ24gPT09IFwiY2VudGVyXCIgPyBcInRvcCBjZW50ZXJcIiA6XHJcbiAgICAgICAgICAgIChhbGlnbiA9PT0gXCJyaWdodFwiID8gXCJ0b3AgcmlnaHRcIiA6IFwidG9wIGxlZnRcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHhDb21wID1cclxuICAgICAgICAgIGFsaWduID09PSBcImxlZnRcIiA/IFwiY2FsYygoMSAtIHZhcigtLXRleHQtem9vbSwgMSkpICogNTAlKVwiIDpcclxuICAgICAgICAgICAgYWxpZ24gPT09IFwicmlnaHRcIiA/IFwiY2FsYygodmFyKC0tdGV4dC16b29tLCAxKSAtIDEpICogNTAlKVwiIDpcclxuICAgICAgICAgICAgICBcIjBweFwiO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuLyog4pyFIHBhcmEgcXVlIGVsIHpvb20gbm8g4oCcZW1wdWpl4oCdIGEgbGEgZGVyZWNoYSAqL1xyXG50cmFuc2Zvcm0tb3JpZ2luOiAke29yaWdpbn07XHJcbi8qIOKchSBjb21wZW5zYSBlbCBjb3JyaW1pZW50byBwb3Igc2NhbGUgKi9cclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSkgdHJhbnNsYXRlWCgke3hDb21wfSkgc2NhbGUodmFyKC0tdGV4dC16b29tLCAxKSk7XHJcbiR7dyAhPT0gdW5kZWZpbmVkID8gYHdpZHRoOiAke3B4WChvYmosIHcpfTtgIDogXCJcIn1cclxuZm9udC1zaXplOiBjYWxjKCR7c0ZvbnR9ICogJHtmc31weCk7XHJcbmZvbnQtZmFtaWx5OiAke29iai5mb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwifTtcclxuZm9udC13ZWlnaHQ6ICR7b2JqLmZvbnRXZWlnaHQgfHwgXCJub3JtYWxcIn07XHJcbmZvbnQtc3R5bGU6ICR7b2JqLmZvbnRTdHlsZSB8fCBcIm5vcm1hbFwifTtcclxudGV4dC1kZWNvcmF0aW9uOiAke29iai50ZXh0RGVjb3JhdGlvbiB8fCBcIm5vbmVcIn07XHJcbmNvbG9yOiAke2NvbG9yfTtcclxudGV4dC1hbGlnbjogJHthbGlnbn07XHJcbndoaXRlLXNwYWNlOiBwcmUtd3JhcDtcclxubGluZS1oZWlnaHQ6ICR7bGluZUhlaWdodEZpbmFsfTtcclxucGFkZGluZzogMDtcclxubWFyZ2luOiAwO1xyXG5ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcclxuJHtvYmouc3Ryb2tlICYmIG9iai5zdHJva2VXaWR0aCA+IDBcclxuICAgICAgICAgICAgPyBgLXdlYmtpdC10ZXh0LXN0cm9rZTogJHtvYmouc3Ryb2tlV2lkdGh9cHggJHtvYmouc3Ryb2tlfTtgXHJcbiAgICAgICAgICAgIDogXCJcIlxyXG4gICAgICAgICAgfVxyXG4ke29iai5zaGFkb3dDb2xvclxyXG4gICAgICAgICAgICA/IGB0ZXh0LXNoYWRvdzogJHtvYmouc2hhZG93T2Zmc2V0WCB8fCAwfXB4ICR7b2JqLnNoYWRvd09mZnNldFkgfHwgMH1weCAke29iai5zaGFkb3dCbHVyIHx8IDB9cHggJHtvYmouc2hhZG93Q29sb3J9O2BcclxuICAgICAgICAgICAgOiBcInRleHQtc2hhZG93OiBub25lO1wiXHJcbiAgICAgICAgICB9XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShcclxuICAgICAgICAgIGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgZGF0YS1kZWJ1Zy10ZXh0bz1cIjFcIiBzdHlsZT1cIiR7c3R5bGV9XCI+JHtzYWZlVGV4dG99PC9kaXY+YCxcclxuICAgICAgICAgIG9ialxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIElNQUdFTiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImltYWdlblwiKSB7XHJcbiAgICAgICAgY29uc3Qgc3JjID0gb2JqLnNyYyB8fCBvYmoudXJsIHx8IFwiXCI7XHJcbiAgICAgICAgaWYgKCFzcmMpIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3N0eWxlU2l6ZShvYmosIHcsIGgpfVxyXG5vYmplY3QtZml0OiBjb250YWluO1xyXG5kaXNwbGF5OiBibG9jaztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8aW1nIGNsYXNzPVwib2JqZXRvXCIgc3JjPVwiJHtlc2NhcGVBdHRyKHNyYyl9XCIgc3R5bGU9XCIke3N0eWxlfVwiIC8+YCwgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBJQ09OTyAobnVldm8pIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiaWNvbm9cIikge1xyXG4gICAgICAgIGlmIChvYmouZm9ybWF0byA9PT0gXCJzdmdcIikge1xyXG4gICAgICAgICAgY29uc3Qgc3ZnSHRtbCA9IHJlbmRlckljb25vU3ZnTnVldm9JbmxpbmUob2JqKTtcclxuICAgICAgICAgIGlmICghc3ZnSHRtbCkgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShzdmdIdG1sLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3JjID0gb2JqLnVybCB8fCBvYmouc3JjIHx8IFwiXCI7XHJcbiAgICAgICAgaWYgKCFzcmMpIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3N0eWxlU2l6ZShvYmosIHcsIGgpfVxyXG5vYmplY3QtZml0OiBjb250YWluO1xyXG5kaXNwbGF5OiBibG9jaztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8aW1nIGNsYXNzPVwib2JqZXRvXCIgc3JjPVwiJHtlc2NhcGVBdHRyKHNyYyl9XCIgc3R5bGU9XCIke3N0eWxlfVwiIC8+YCwgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBJQ09OTyBMRUdBQ1kgKGljb25vLXN2ZykgLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJpY29uby1zdmdcIiAmJiBvYmouZCkge1xyXG4gICAgICAgIGNvbnN0IHZiID0gb2JqLnZpZXdCb3ggfHwgXCIwIDAgMTAwIDEwMFwiO1xyXG4gICAgICAgIGNvbnN0IGZpbGwgPSBvYmouY29sb3IgfHwgXCIjMDAwXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiAxMDA7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogMTAwO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxuZmlsbDogJHtlc2NhcGVBdHRyKGZpbGwpfTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGA8c3ZnIGNsYXNzPVwib2JqZXRvXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIke2VzY2FwZUF0dHIoXHJcbiAgICAgICAgICB2YlxyXG4gICAgICAgICl9XCIgc3R5bGU9XCIke3N0eWxlfVwiPjxwYXRoIGQ9XCIke2VzY0hUTUwob2JqLmQpfVwiIC8+PC9zdmc+YDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2Uoc3ZnLCBvYmopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIENPVU5URE9XTiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImNvdW50ZG93blwiKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SVNPID0gb2JqLnRhcmdldElTTyB8fCBvYmouZmVjaGFPYmpldGl2byB8fCBvYmouZmVjaGFJU08gfHwgXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gb2JqLmNvbG9yVGV4dG8gPz8gb2JqLmNvbG9yID8/IFwiIzExMVwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseSB8fCBcIkludGVyLCBzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIjtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlc2V0ID0gb2JqLnByZXNldElkIHx8IG9iai5sYXlvdXQgfHwgXCJwaWxsc1wiO1xyXG4gICAgICAgIGNvbnN0IGlzTWluaW1hbCA9IFN0cmluZyhwcmVzZXQpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJtaW5pbWFsXCIpO1xyXG5cclxuICAgICAgICAvLyDinIUgYW5jaG8vYWx0byBkZWwgb2JqZXRvIChzaSBleGlzdGVuKVxyXG4gICAgICAgIGNvbnN0IHdPYmogPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBOdW1iZXIob2JqLndpZHRoKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgaE9iaiA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBOdW1iZXIob2JqLmhlaWdodCkgOiBudWxsO1xyXG5cclxuICAgICAgICAvLyDinIUgZ2FwOiBzaSB2aWVuZSBkZSBLb252YSwgcmVzcGV0YXJsb1xyXG4gICAgICAgIGNvbnN0IGdhcCA9IE51bWJlci5pc0Zpbml0ZShvYmouZ2FwKVxyXG4gICAgICAgICAgPyBOdW1iZXIob2JqLmdhcClcclxuICAgICAgICAgIDogTnVtYmVyLmlzRmluaXRlKG9iai5zcGFjaW5nKVxyXG4gICAgICAgICAgICA/IE51bWJlcihvYmouc3BhY2luZylcclxuICAgICAgICAgICAgOiA4O1xyXG5cclxuICAgICAgICAvLyDinIUgU2kgdHUgS29udmEgZ3VhcmRhIGNoaXBXaWR0aCAvIHBhZGRpbmdYLCByZXNwZXRhbG9zXHJcbiAgICAgICAgLy8gY2hpcFdpZHRoOiBhbmNobyBpbnRlcm5vIGRlbCB0ZXh0byAoc2luIHBhZGRpbmcpXHJcbiAgICAgICAgY29uc3QgY2hpcFdpZHRoUHJvcCA9IE51bWJlci5pc0Zpbml0ZShvYmouY2hpcFdpZHRoKSA/IE51bWJlcihvYmouY2hpcFdpZHRoKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1hQcm9wID0gTnVtYmVyLmlzRmluaXRlKG9iai5wYWRkaW5nWCkgPyBOdW1iZXIob2JqLnBhZGRpbmdYKSA6IG51bGw7XHJcblxyXG4gICAgICAgIC8vIOKchSBEZXJpdmFjacOzbiByYcOteiAoY3VhbmRvIG5vIGhheSBwcm9wcylcclxuICAgICAgICBjb25zdCBuID0gNDtcclxuXHJcbiAgICAgICAgLy8gY2hpcFdUb3RhbDogYW5jaG8gdG90YWwgZGUgY2FkYSBjaGlwIChpbmNsdXllIHBhZGRpbmcpXHJcbiAgICAgICAgbGV0IGNoaXBXVG90YWwgPSA1NjsgLy8gZmFsbGJhY2sgcmF6b25hYmxlXHJcbiAgICAgICAgaWYgKHdPYmogJiYgd09iaiA+IDApIHtcclxuICAgICAgICAgIGNoaXBXVG90YWwgPSBNYXRoLm1heCg0MCwgKHdPYmogLSBnYXAgKiAobiAtIDEpKSAvIG4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcGFkZGluZ1ggZGVyaXZhZG8gZGVsIGNoaXBXVG90YWwgKHNpIG5vIHZpbm8pXHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSBwYWRkaW5nWFByb3AgPz8gTWF0aC5tYXgoNiwgTWF0aC5yb3VuZChjaGlwV1RvdGFsICogMC4xOCkpOyAvLyB+MTglXHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSBNYXRoLm1heCg1LCBNYXRoLnJvdW5kKHBhZGRpbmdYICogMC42NSkpO1xyXG5cclxuICAgICAgICAvLyBjaGlwV2lkdGggKHRleHRvKSBkZXJpdmFkbyBzaSBubyB2aW5vXHJcbiAgICAgICAgY29uc3QgY2hpcFdpZHRoID0gY2hpcFdpZHRoUHJvcCA/PyBNYXRoLm1heCgxMCwgTWF0aC5yb3VuZChjaGlwV1RvdGFsIC0gcGFkZGluZ1ggKiAyKSk7XHJcblxyXG4gICAgICAgIC8vIOKchSBmb250IHNpemVzOiBzaSB2aWVuZW4sIHJlc3BldGFyOyBzaSBubywgZGVyaXZhciBkZXNkZSBjaGlwV1RvdGFsXHJcbiAgICAgICAgY29uc3QgdmFsdWVTaXplID1cclxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShvYmouZm9udFNpemUpID8gTnVtYmVyKG9iai5mb250U2l6ZSkgOiBNYXRoLm1heCgxNCwgTWF0aC5yb3VuZChjaGlwV1RvdGFsICogMC4zNCkpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsU2l6ZSA9XHJcbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2JqLmxhYmVsU2l6ZSkgPyBOdW1iZXIob2JqLmxhYmVsU2l6ZSkgOiBNYXRoLm1heCg5LCBNYXRoLnJvdW5kKHZhbHVlU2l6ZSAqIDAuNjIpKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWxDb2xvciA9IG9iai5sYWJlbENvbG9yID8/IFwiIzZiNzI4MFwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRXZWlnaHQgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmZvbnRXZWlnaHQpID8gb2JqLmZvbnRXZWlnaHQgOiA3MDA7XHJcbiAgICAgICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IE51bWJlci5pc0Zpbml0ZShvYmoubGV0dGVyU3BhY2luZykgPyBvYmoubGV0dGVyU3BhY2luZyA6IDA7XHJcblxyXG4gICAgICAgIC8vIOKchSBlc3RpbG9zIGRlIGNoaXBcclxuICAgICAgICBjb25zdCBjb250YWluZXJCZ0ZpbmFsID0gXCJ0cmFuc3BhcmVudFwiO1xyXG4gICAgICAgIGNvbnN0IGNoaXBCZ0ZpbmFsID0gaXNNaW5pbWFsID8gXCJ0cmFuc3BhcmVudFwiIDogb2JqLmNoaXBCYWNrZ3JvdW5kID8/IG9iai5ib3hCZyA/PyBcInJnYmEoMjU1LDI1NSwyNTUsLjc1KVwiO1xyXG4gICAgICAgIGNvbnN0IGNoaXBCb3JkZXJDb2xvckZpbmFsID0gaXNNaW5pbWFsID8gXCJ0cmFuc3BhcmVudFwiIDogb2JqLmNoaXBCb3JkZXIgPz8gb2JqLmJveEJvcmRlciA/PyBcInJnYmEoMCwwLDAsLjA4KVwiO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXJSYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmJveFJhZGl1cylcclxuICAgICAgICAgID8gb2JqLmJveFJhZGl1c1xyXG4gICAgICAgICAgOiBOdW1iZXIuaXNGaW5pdGUob2JqLnJhZGl1cylcclxuICAgICAgICAgICAgPyBvYmoucmFkaXVzXHJcbiAgICAgICAgICAgIDogMTA7XHJcblxyXG4gICAgICAgIGNvbnN0IGNoaXBSYWRpdXNGaW5hbCA9IE51bWJlci5pc0Zpbml0ZShvYmouY2hpcFJhZGl1cykgPyBvYmouY2hpcFJhZGl1cyA6IGNvbnRhaW5lclJhZGl1cztcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcblxyXG4gICAgICAgIC8vIOKchSBFc2NhbGEgY29ycmVjdGEgKHJlc3BldGEgcGFudGFsbGEgeSBibGVlZClcclxuICAgICAgICBjb25zdCBzQ2hpcCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbiR7d09iaiA/IGB3aWR0aDogJHtweFgob2JqLCB3T2JqKX07YCA6IFwiXCJ9XHJcbiR7aE9iaiA/IGBoZWlnaHQ6ICR7cHhZKG9iaiwgaE9iail9O2AgOiBcIlwifVxyXG5kaXNwbGF5OiBmbGV4O1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuZ2FwOiBjYWxjKCR7c0NoaXB9ICogJHtnYXB9cHgpO1xyXG5mb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcclxuY29sb3I6ICR7dGV4dENvbG9yfTtcclxuYmFja2dyb3VuZDogJHtjb250YWluZXJCZ0ZpbmFsfTtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NDaGlwfSAqICR7Y29udGFpbmVyUmFkaXVzfXB4KTtcclxubGV0dGVyLXNwYWNpbmc6IGNhbGMoJHtzQ2hpcH0gKiAke2xldHRlclNwYWNpbmd9cHgpO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2hpcFN0eWxlID0gYFxyXG53aWR0aDogY2FsYygke3NDaGlwfSAqICR7TWF0aC5yb3VuZChjaGlwV1RvdGFsKX1weCk7XHJcbnBhZGRpbmc6IGNhbGMoJHtzQ2hpcH0gKiAke3BhZGRpbmdZfXB4KSBjYWxjKCR7c0NoaXB9ICogJHtwYWRkaW5nWH1weCk7XHJcbmJvcmRlcjogJHtpc01pbmltYWwgPyBcIjBcIiA6IGBjYWxjKCR7c0NoaXB9ICogMXB4KSBzb2xpZCAke2NoaXBCb3JkZXJDb2xvckZpbmFsfWB9O1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c0NoaXB9ICogJHtjaGlwUmFkaXVzRmluYWx9cHgpO1xyXG5kaXNwbGF5OiBmbGV4O1xyXG5mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuYmFja2dyb3VuZDogJHtjaGlwQmdGaW5hbH07XHJcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCB2YWx1ZVN0eWxlID0gYFxyXG5mb250LXdlaWdodDogJHtmb250V2VpZ2h0fTtcclxuZm9udC1zaXplOiBjYWxjKCR7c0NoaXB9ICogJHt2YWx1ZVNpemV9cHgpO1xyXG5saW5lLWhlaWdodDogMTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsU3R5bGUgPSBgXHJcbmZvbnQtc2l6ZTogY2FsYygke3NDaGlwfSAqICR7bGFiZWxTaXplfXB4KTtcclxuY29sb3I6ICR7bGFiZWxDb2xvcn07XHJcbmxpbmUtaGVpZ2h0OiAxLjA1O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2hvd0xhYmVscyA9IG9iai5zaG93TGFiZWxzICE9PSBmYWxzZTtcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBvYmoubGFiZWxzID8/IHsgZGlhczogXCJEw61hc1wiLCBob3JhczogXCJIb3Jhc1wiLCBtaW46IFwiTWluXCIsIHNlZzogXCJTZWdcIiB9O1xyXG5cclxuICAgICAgICByZXR1cm4gYFxyXG48ZGl2IGNsYXNzPVwib2JqZXRvXCJcclxuICBkYXRhLW1vYmlsZS1jbHVzdGVyPVwiaXNvbGF0ZWRcIlxyXG4gIGRhdGEtbW9iaWxlLWNlbnRlcj1cImZvcmNlXCJcclxuICBkYXRhLWNvdW50ZG93blxyXG4gIGRhdGEtdGFyZ2V0PVwiJHtlc2NhcGVBdHRyKHRhcmdldElTTyl9XCJcclxuICBkYXRhLXByZXNldD1cIiR7ZXNjYXBlQXR0cihcclxuICAgICAgICAgIHByZXNldFxyXG4gICAgICAgICl9XCIgc3R5bGU9XCIke2NvbnRhaW5lclN0eWxlfVwiPlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLmRpYXMpfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5ob3Jhcyl9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLm1pbil9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLnNlZyl9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuYC50cmltKCk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIEdBTEVSw41BIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiZ2FsZXJpYVwiKSB7XHJcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIHBhcnNlSW50KG9iai5yb3dzIHx8IDEsIDEwKSk7XHJcbiAgICAgICAgY29uc3QgY29scyA9IE1hdGgubWF4KDEsIHBhcnNlSW50KG9iai5jb2xzIHx8IDEsIDEwKSk7XHJcbiAgICAgICAgY29uc3QgZ2FwUHggPSBNYXRoLm1heCgwLCBwYXJzZUludChvYmouZ2FwIHx8IDAsIDEwKSk7XHJcbiAgICAgICAgY29uc3QgcmFkaXVzUHggPSBNYXRoLm1heCgwLCBwYXJzZUludChvYmoucmFkaXVzIHx8IDAsIDEwKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBjb25zdCBzR3JpZCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZUNvbnRlbmVkb3IgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3N0eWxlU2l6ZShvYmosIHcsIGgpfVxyXG5kaXNwbGF5OiBncmlkO1xyXG5ncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgke2NvbHN9LCAxZnIpO1xyXG5ncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgke3Jvd3N9LCAxZnIpO1xyXG5nYXA6IGNhbGMoJHtzR3JpZH0gKiAke2dhcFB4fXB4KTtcclxuYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvdGFsID0gcm93cyAqIGNvbHM7XHJcbiAgICAgICAgY29uc3QgY2VsbHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0b3RhbCB9LCAoXywgaSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgYyA9IChvYmouY2VsbHMgJiYgb2JqLmNlbGxzW2ldKSB8fCB7fTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1lZGlhVXJsOiBjLm1lZGlhVXJsIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGZpdDogYy5maXQgPT09IFwiY29udGFpblwiID8gXCJjb250YWluXCIgOiBcImNvdmVyXCIsXHJcbiAgICAgICAgICAgIGJnOiBjLmJnIHx8IFwiI2YzZjRmNlwiLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgaHRtbENlbGRhcyA9IGNlbGxzXHJcbiAgICAgICAgICAubWFwKChjZWxsLCBpZHgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2FmZVNyYyA9IGVzY2FwZUF0dHIoY2VsbC5tZWRpYVVybCB8fCBcIlwiKTtcclxuICAgICAgICAgICAgY29uc3QgY2VsZGFTdHlsZSA9IGBcclxucG9zaXRpb246IHJlbGF0aXZlO1xyXG53aWR0aDogMTAwJTtcclxuaGVpZ2h0OiAxMDAlO1xyXG5vdmVyZmxvdzogaGlkZGVuO1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c0dyaWR9ICogJHtyYWRpdXNQeH1weCk7XHJcbmJhY2tncm91bmQ6ICR7Y2VsbC5iZ307XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzYWZlU3JjKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiZ2FsZXJpYS1jZWxkYVwiIGRhdGEtaW5kZXg9XCIke2lkeH1cIiBzdHlsZT1cIiR7Y2VsZGFTdHlsZX1cIj48L2Rpdj5gO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG48ZGl2IGNsYXNzPVwiZ2FsZXJpYS1jZWxkYVwiIGRhdGEtaW5kZXg9XCIke2lkeH1cIiBzdHlsZT1cIiR7Y2VsZGFTdHlsZX1cIj5cclxuICA8aW1nIHNyYz1cIiR7c2FmZVNyY31cIiBhbHQ9XCJcIiBsb2FkaW5nPVwibGF6eVwiIGRlY29kaW5nPVwiYXN5bmNcIlxyXG4gICAgICAgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO29iamVjdC1maXQ6JHtjZWxsLmZpdH07ZGlzcGxheTpibG9jaztcIiAvPlxyXG48L2Rpdj5cclxuYC50cmltKCk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWxHYWxlcmlhID0gYDxkaXYgY2xhc3M9XCJvYmpldG8gZ2FsZXJpYVwiIHN0eWxlPVwiJHtzdHlsZUNvbnRlbmVkb3J9XCI+JHtodG1sQ2VsZGFzfTwvZGl2PmA7XHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoaHRtbEdhbGVyaWEsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gUlNWUCBCT1TDk04gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJyc3ZwLWJvdG9uXCIpIHtcclxuICAgICAgICBjb25zdCB0ZXh0byA9IGVzY2FwZUhUTUwob2JqLnRleHRvIHx8IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmFuY2hvKSA/IG9iai5hbmNobyA6IDIwMDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uYWx0bykgPyBvYmouYWx0byA6IDUwO1xyXG5cclxuICAgICAgICBjb25zdCBjb2xvciA9IG9iai5jb2xvciB8fCBcIiM3NzNkYmVcIjtcclxuICAgICAgICBjb25zdCBjb2xvclRleHRvID0gb2JqLmNvbG9yVGV4dG8gfHwgXCIjZmZmZmZmXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5mb250U2l6ZSkgPyBvYmouZm9udFNpemUgOiAxODtcclxuICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHkgfHwgXCJzYW5zLXNlcmlmXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IG9iai5mb250V2VpZ2h0IHx8IFwiYm9sZFwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IG9iai5mb250U3R5bGUgfHwgXCJub3JtYWxcIjtcclxuICAgICAgICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IG9iai50ZXh0RGVjb3JhdGlvbiB8fCBcIm5vbmVcIjtcclxuICAgICAgICBjb25zdCBhbGlnbiA9IG9iai5hbGlnbiB8fCBcImNlbnRlclwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuXHJcbiAgICAgICAgLy8gUlNWUCAoY29udGVuaWRvKTogc2kgZXN0w6EgZW4gcGFudGFsbGEsIGZpdHRlYSAoc0NvbnRlbmlkb1ZhcilcclxuICAgICAgICBjb25zdCBzQnRuID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxud2lkdGg6ICR7cHhYKG9iaiwgdyl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgaCl9O1xyXG5iYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yfTtcclxuY29sb3I6ICR7Y29sb3JUZXh0b307XHJcbmZvbnQtc2l6ZTogY2FsYygke3NCdG59ICogJHtmb250U2l6ZX1weCk7XHJcbmZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xyXG5mb250LXdlaWdodDogJHtmb250V2VpZ2h0fTtcclxuZm9udC1zdHlsZTogJHtmb250U3R5bGV9O1xyXG50ZXh0LWRlY29yYXRpb246ICR7dGV4dERlY29yYXRpb259O1xyXG50ZXh0LWFsaWduOiAke2FsaWdufTtcclxuZGlzcGxheTogZmxleDtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzQnRufSAqIDhweCk7XHJcbmN1cnNvcjogcG9pbnRlcjtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBgXHJcbjxkaXYgY2xhc3M9XCJvYmpldG8gaXMtaW50ZXJhY3RpdmUgcnN2cC1ib3RvblwiXHJcbiAgaWQ9XCJhYnJpck1vZGFsUlNWUFwiXHJcbiAgZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJcclxuICBkYXRhLXJzdnAtb3BlblxyXG4gIHJvbGU9XCJidXR0b25cIlxyXG4gIHRhYmluZGV4PVwiMFwiXHJcbiAgYXJpYS1sYWJlbD1cIkNvbmZpcm1hciBhc2lzdGVuY2lhXCJcclxuICBzdHlsZT1cIiR7c3R5bGV9XCI+XHJcbiAgJHt0ZXh0b31cclxuPC9kaXY+XHJcbmAudHJpbSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIEZPUk1BUyAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImZvcm1hXCIpIHtcclxuICAgICAgICBjb25zdCBmaWxsID0gb2JqLmNvbG9yIHx8IFwiIzAwMFwiO1xyXG4gICAgICAgIGNvbnN0IGZpZ3VyYSA9IG9iai5maWd1cmE7XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwicmVjdFwiKSB7XHJcbiAgICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogMTAwO1xyXG4gICAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogMTAwO1xyXG4gICAgICAgICAgY29uc3QgY29ybmVyUmFkaXVzID0gb2JqLmNvcm5lclJhZGl1cyB8fCAwO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gb2JqLmZvbnRTaXplIHx8IDI0O1xyXG4gICAgICAgICAgY29uc3QgZm9udEZhbWlseSA9IG9iai5mb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwiO1xyXG4gICAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IG9iai5mb250V2VpZ2h0IHx8IFwibm9ybWFsXCI7XHJcbiAgICAgICAgICBjb25zdCBmb250U3R5bGUgPSBvYmouZm9udFN0eWxlIHx8IFwibm9ybWFsXCI7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IG9iai50ZXh0RGVjb3JhdGlvbiB8fCBcIm5vbmVcIjtcclxuICAgICAgICAgIGNvbnN0IGFsaWduID0gb2JqLmFsaWduIHx8IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICBjb25zdCBjb2xvclRleHRvID0gb2JqLmNvbG9yVGV4dG8gfHwgXCIjMDAwMDAwXCI7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0byA9IGVzY0hUTUwob2JqLnRleHRvIHx8IFwiXCIpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgICAgY29uc3Qgc1JlY3RUZXh0ID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbmJhY2tncm91bmQ6ICR7ZmlsbH07XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzUmVjdFRleHR9ICogJHtjb3JuZXJSYWRpdXN9cHgpO1xyXG5kaXNwbGF5OiBmbGV4O1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6ICR7YWxpZ24gPT09IFwibGVmdFwiID8gXCJmbGV4LXN0YXJ0XCIgOiBhbGlnbiA9PT0gXCJyaWdodFwiID8gXCJmbGV4LWVuZFwiIDogXCJjZW50ZXJcIlxyXG4gICAgICAgICAgICB9O1xyXG50ZXh0LWFsaWduOiAke2FsaWdufTtcclxucGFkZGluZzogY2FsYygke3NSZWN0VGV4dH0gKiA0cHgpO1xyXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbm5lciA9IGBcclxuPGRpdiBzdHlsZT1cIlxyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIGZvbnQtc2l6ZTogY2FsYygke3NSZWN0VGV4dH0gKiAke2ZvbnRTaXplfXB4KTtcclxuICBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcclxuICBmb250LXdlaWdodDogJHtmb250V2VpZ2h0fTtcclxuICBmb250LXN0eWxlOiAke2ZvbnRTdHlsZX07XHJcbiAgdGV4dC1kZWNvcmF0aW9uOiAke3RleHREZWNvcmF0aW9ufTtcclxuICBjb2xvcjogJHtjb2xvclRleHRvfTtcclxuICBsaW5lLWhlaWdodDogMS4yO1xyXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcclxuICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xyXG5cIj4ke3RleHRvfTwvZGl2PlxyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGRpdiBjbGFzcz1cIm9iamV0b1wiIHN0eWxlPVwiJHtzdHlsZX1cIj4ke2lubmVyfTwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcImNpcmNsZVwiKSB7XHJcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5yYWRpdXMpID8gb2JqLnJhZGl1cyA6IDUwO1xyXG4gICAgICAgICAgY29uc3QgZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHggPSBOdW1iZXIob2JqPy54IHx8IDApIC0gcmFkaXVzO1xyXG4gICAgICAgICAgY29uc3QgeVB4Q2VudGVyID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcbiAgICAgICAgICBjb25zdCB5UHhUb3BMZWZ0ID0geVB4Q2VudGVyIC0gcmFkaXVzO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJvdCA9IG9iaj8ucm90YXRpb24gPz8gMDtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgeCl9O1xyXG50b3A6ICR7dG9wQ1NTRnJvbVlQeChvYmosIHlQeFRvcExlZnQpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgZGlhbWV0ZXIpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGRpYW1ldGVyKX07XHJcbmJvcmRlci1yYWRpdXM6IDUwJTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGRpdiBjbGFzcz1cIm9iamV0b1wiIHN0eWxlPVwiJHtzdHlsZX1cIj48L2Rpdj5gLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZpZ3VyYSA9PT0gXCJsaW5lXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHBvaW50cyA9IG9iai5wb2ludHMgfHwgWzAsIDAsIExJTkVfQ09OU1RBTlRTLkRFRkFVTFRfTEVOR1RILCAwXTtcclxuICAgICAgICAgIGNvbnN0IHgxID0gcGFyc2VGbG9hdChwb2ludHNbMF0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCB5MSA9IHBhcnNlRmxvYXQocG9pbnRzWzFdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgeDIgPSBwYXJzZUZsb2F0KHBvaW50c1syXSkgfHwgTElORV9DT05TVEFOVFMuREVGQVVMVF9MRU5HVEg7XHJcbiAgICAgICAgICBjb25zdCB5MiA9IHBhcnNlRmxvYXQocG9pbnRzWzNdKSB8fCAwO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb2JqLnN0cm9rZVdpZHRoIHx8IExJTkVfQ09OU1RBTlRTLlNUUk9LRV9XSURUSDtcclxuXHJcbiAgICAgICAgICBjb25zdCBkZWx0YVggPSB4MiAtIHgxO1xyXG4gICAgICAgICAgY29uc3QgZGVsdGFZID0geTIgLSB5MTtcclxuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xyXG4gICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGRlbHRhWSwgZGVsdGFYKSAqICgxODAgLyBNYXRoLlBJKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdGFydFggPSBOdW1iZXIob2JqPy54IHx8IDApICsgeDE7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVkgPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGJhc2VZICsgeTE7XHJcblxyXG4gICAgICAgICAgY29uc3QgdG90YWxSb3RhdGlvbiA9IGFuZ2xlICsgKG9iai5yb3RhdGlvbiB8fCAwKTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgICAgICAgIC8vIGFsdG8gZGUgbMOtbmVhOiB1c2Ftb3MgZXNjYWxhIFkgZGVsIG9iamV0byAoY29udGVuaWRvOiBzZmluYWwvc3gsIGJsZWVkOiBzeClcclxuICAgICAgICAgIGNvbnN0IGxpbmVIID0gYGNhbGMoJHtzWShvYmopfSAqICR7c3Ryb2tlV2lkdGh9cHgpYDtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHN0YXJ0WCl9O1xyXG50b3A6ICR7dG9wQ1NTRnJvbVlQeChvYmosIHN0YXJ0WSl9O1xyXG53aWR0aDogJHtweFgob2JqLCBsZW5ndGgpfTtcclxuaGVpZ2h0OiAke2xpbmVIfTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHt0b3RhbFJvdGF0aW9ufWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiAwIDUwJTtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvIGxpbmVhXCIgc3R5bGU9XCIke3N0eWxlfVwiPjwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcInRyaWFuZ2xlXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IG9iai5yYWRpdXMgfHwgNjA7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc2luNjAgPSBNYXRoLnNxcnQoMykgLyAyO1xyXG4gICAgICAgICAgY29uc3QgY29zNjAgPSAwLjU7XHJcblxyXG4gICAgICAgICAgY29uc3QgdHJpYW5nbGVXaWR0aCA9IDIgKiByYWRpdXMgKiBzaW42MDtcclxuICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlSGVpZ2h0ID0gcmFkaXVzICogKDEgKyBjb3M2MCk7XHJcbiAgICAgICAgICBjb25zdCBjZW50cm9pZE9mZnNldFkgPSB0cmlhbmdsZUhlaWdodCAvIDM7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVkgPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHRvcENvbnRhaW5lclB4ID0gYmFzZVkgLSAodHJpYW5nbGVIZWlnaHQgLSBjZW50cm9pZE9mZnNldFkpO1xyXG4gICAgICAgICAgY29uc3QgbGVmdENvbnRhaW5lciA9IE51bWJlcihvYmo/LnggfHwgMCkgLSB0cmlhbmdsZVdpZHRoIC8gMjtcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCBsZWZ0Q29udGFpbmVyKX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgdG9wQ29udGFpbmVyUHgpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgdHJpYW5nbGVXaWR0aCl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgdHJpYW5nbGVIZWlnaHQpfTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxuY2xpcC1wYXRoOiBwb2x5Z29uKDUwJSAwJSwgMCUgMTAwJSwgMTAwJSAxMDAlKTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtvYmoucm90YXRpb24gPz8gMH1kZWcpIHNjYWxlKCR7b2JqLnNjYWxlWCA/PyAxfSwgJHtvYmouc2NhbGVZID8/IDF9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgc3R5bGU9XCIke2Jhc2VTdHlsZX1cIj48L2Rpdj5gLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfSlcclxuICAgIC5qb2luKFwiXFxuXCIpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsImVzY0hUTUwiLCJzdHIiLCJTdHJpbmciLCJyZXBsYWNlIiwiZXNjYXBlQXR0ciIsImdldExpbmtQcm9wcyIsIm9iaiIsInJhdyIsImVubGFjZSIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJlbnZvbHZlclNpRW5sYWNlIiwiaHRtbEVsZW1lbnRvIiwidGlwbyIsImxpbmsiLCJlc2NhcGVIVE1MIiwidGV4dG8iLCJnZW5lcmFySFRNTERlc2RlT2JqZXRvcyIsIm9iamV0b3MiLCJfc2VjY2lvbmVzIiwiYWx0b01vZG9Qb3JTZWNjaW9uIiwiTWFwIiwibWFwIiwicyIsImlkIiwiYWx0b01vZG8iLCJ0b0xvd2VyQ2FzZSIsImVzU2VjY2lvblBhbnRhbGxhIiwibW9kbyIsImdldCIsInNlY2Npb25JZCIsImlzRnVsbEJsZWVkIiwiYW5jbGFqZSIsInNDb250ZW5pZG9WYXIiLCJzWCIsInNZIiwicHhYIiwicHgiLCJuIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJweFkiLCJBTFRVUkFfRURJVE9SX1BBTlRBTExBIiwiUEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWCIsImNsYW1wMDEiLCJ4IiwiTWF0aCIsIm1heCIsIm1pbiIsImdldFlQeEVkaXRvciIsInluIiwieU5vcm0iLCJ5UHgiLCJ5IiwidG9wQ1NTIiwieVB4RWRpdG9yIiwiZGVzaWduU2NhbGVkSCIsImNlbnRlck9mZnNldCIsInRvcENTU0Zyb21ZUHgiLCJzdHlsZVBvc0Jhc2UiLCJyb3QiLCJyb3RhdGlvbiIsInNjYWxlWCIsInNjYWxlWSIsInpJbmRleCIsInVuZGVmaW5lZCIsInRyaW0iLCJzdHlsZVNpemUiLCJ3IiwiaCIsInd3IiwiaGgiLCJwYXJ0cyIsInB1c2giLCJqb2luIiwicmVuZGVySWNvbm9TdmdOdWV2b0lubGluZSIsInZpZXdCb3giLCJjb2xvciIsInBhdGhzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwid2lkdGgiLCJoZWlnaHQiLCJwYXRoc0h0bWwiLCJwIiwiZCIsInN0eWxlIiwiYWxpZ24iLCJ0ZXh0QWxpZ24iLCJjb2xvclRleHRvIiwiZmlsbCIsImJhc2VMaW5lSGVpZ2h0IiwibGluZUhlaWdodCIsImxpbmVIZWlnaHRGaW5hbCIsInNhZmVUZXh0byIsImJhc2VTdHlsZSIsImZzIiwiZm9udFNpemUiLCJzRm9udCIsIm9yaWdpbiIsInhDb21wIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJ0ZXh0RGVjb3JhdGlvbiIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic2hhZG93Q29sb3IiLCJzaGFkb3dPZmZzZXRYIiwic2hhZG93T2Zmc2V0WSIsInNoYWRvd0JsdXIiLCJzcmMiLCJ1cmwiLCJmb3JtYXRvIiwic3ZnSHRtbCIsInZiIiwic3ZnIiwidGFyZ2V0SVNPIiwiZmVjaGFPYmpldGl2byIsImZlY2hhSVNPIiwidGV4dENvbG9yIiwicHJlc2V0IiwicHJlc2V0SWQiLCJsYXlvdXQiLCJpc01pbmltYWwiLCJpbmNsdWRlcyIsIndPYmoiLCJoT2JqIiwiZ2FwIiwic3BhY2luZyIsImNoaXBXaWR0aFByb3AiLCJjaGlwV2lkdGgiLCJwYWRkaW5nWFByb3AiLCJwYWRkaW5nWCIsImNoaXBXVG90YWwiLCJyb3VuZCIsInBhZGRpbmdZIiwidmFsdWVTaXplIiwibGFiZWxTaXplIiwibGFiZWxDb2xvciIsImxldHRlclNwYWNpbmciLCJjb250YWluZXJCZ0ZpbmFsIiwiY2hpcEJnRmluYWwiLCJjaGlwQmFja2dyb3VuZCIsImJveEJnIiwiY2hpcEJvcmRlckNvbG9yRmluYWwiLCJjaGlwQm9yZGVyIiwiYm94Qm9yZGVyIiwiY29udGFpbmVyUmFkaXVzIiwiYm94UmFkaXVzIiwicmFkaXVzIiwiY2hpcFJhZGl1c0ZpbmFsIiwiY2hpcFJhZGl1cyIsInNDaGlwIiwiY29udGFpbmVyU3R5bGUiLCJjaGlwU3R5bGUiLCJ2YWx1ZVN0eWxlIiwibGFiZWxTdHlsZSIsInNob3dMYWJlbHMiLCJsYWJlbHMiLCJkaWFzIiwiaG9yYXMiLCJzZWciLCJyb3dzIiwicGFyc2VJbnQiLCJjb2xzIiwiZ2FwUHgiLCJyYWRpdXNQeCIsInNHcmlkIiwic3R5bGVDb250ZW5lZG9yIiwidG90YWwiLCJjZWxscyIsImZyb20iLCJfIiwiaSIsImMiLCJtZWRpYVVybCIsImZpdCIsImJnIiwiaHRtbENlbGRhcyIsImNlbGwiLCJpZHgiLCJzYWZlU3JjIiwiY2VsZGFTdHlsZSIsImh0bWxHYWxlcmlhIiwiYW5jaG8iLCJhbHRvIiwic0J0biIsImZpZ3VyYSIsImNvcm5lclJhZGl1cyIsInNSZWN0VGV4dCIsImlubmVyIiwiZGlhbWV0ZXIiLCJ5UHhDZW50ZXIiLCJ5UHhUb3BMZWZ0IiwicG9pbnRzIiwiREVGQVVMVF9MRU5HVEgiLCJ4MSIsInBhcnNlRmxvYXQiLCJ5MSIsIngyIiwieTIiLCJTVFJPS0VfV0lEVEgiLCJkZWx0YVgiLCJkZWx0YVkiLCJzcXJ0IiwiYW5nbGUiLCJhdGFuMiIsIlBJIiwic3RhcnRYIiwiYmFzZVkiLCJzdGFydFkiLCJ0b3RhbFJvdGF0aW9uIiwibGluZUgiLCJzaW42MCIsImNvczYwIiwidHJpYW5nbGVXaWR0aCIsInRyaWFuZ2xlSGVpZ2h0IiwiY2VudHJvaWRPZmZzZXRZIiwidG9wQ29udGFpbmVyUHgiLCJsZWZ0Q29udGFpbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarHTMLDesdeSecciones.ts":
/*!**********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeSecciones.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarHTMLDesdeSecciones: () => (/* binding */ generarHTMLDesdeSecciones)\n/* harmony export */ });\n/* harmony import */ var _generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generarHTMLDesdeObjetos */ \"(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts\");\n/* harmony import */ var _models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/dimensionesBase */ \"(pages-dir-node)/./functions/src/models/dimensionesBase.ts\");\n/* harmony import */ var _generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generarModalRSVP */ \"(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts\");\n/* harmony import */ var _mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mobileSmartSectionLayout */ \"(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts\");\n\n\n\n\nconst ENABLE_MOBILE_SMART_LAYOUT = true; // ✅ empezamos apagado\nconst EXCLUDE_FONTS = new Set([\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\",\n    \"Arial\",\n    \"Helvetica\",\n    \"Times\",\n    \"Times New Roman\",\n    \"Georgia\",\n    \"Courier New\"\n]);\nconst ALTURA_REFERENCIA_PANTALLA = 500;\n// ✅ Offsets SOLO para texto en secciones Pantalla: ON\n// - Desktop: aplica cuando vw > 767px\n// - Mobile: aplica cuando vw <= 767px\n// (Estos valores se vuelcan a CSS variables en :root)\nconst PANTALLA_Y_OFFSET_DESKTOP_PX = -28;\nconst PANTALLA_Y_OFFSET_MOBILE_PX = 0;\nfunction buildGoogleFontsLink(fonts) {\n    const familias = fonts.map((f)=>f.replace(/['\"]/g, \"\").split(\",\")[0].trim()).filter((n)=>n && !EXCLUDE_FONTS.has(n)).map((n)=>`family=${n.replace(/ /g, \"+\")}`).join(\"&\");\n    if (!familias) return \"\";\n    return `\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?${familias}&display=swap\" rel=\"stylesheet\">`.trim();\n}\nfunction escapeAttr(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction buildFondoStyle(seccion) {\n    const fondoValue = seccion?.fondo || \"transparent\";\n    const esImagenFondo = seccion?.fondoTipo === \"imagen\" && seccion?.fondoImagen;\n    let estilosFondo = \"\";\n    if (esImagenFondo) {\n        let imageUrl = seccion.fondoImagen;\n        if (imageUrl && imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        let backgroundPosition = \"center center\";\n        if (seccion.fondoImagenOffsetX !== undefined || seccion.fondoImagenOffsetY !== undefined) {\n            const offsetX = seccion.fondoImagenOffsetX || 0;\n            const offsetY = seccion.fondoImagenOffsetY || 0;\n            const offsetXPercent = offsetX !== 0 ? `calc(50% - ${-offsetX}px)` : \"50%\";\n            const offsetYPercent = offsetY !== 0 ? `calc(50% - ${-offsetY}px)` : \"50%\";\n            backgroundPosition = `${offsetXPercent} ${offsetYPercent}`;\n        }\n        estilosFondo = `background-image: url('${imageUrl}'); background-size: cover; background-position: ${backgroundPosition}; background-repeat: no-repeat;`;\n    } else if (fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\")) {\n        let imageUrl = fondoValue.replace(\"url(\", \"\").replace(\")\", \"\");\n        if (imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        estilosFondo = `background-image: url('${imageUrl}'); background-size: cover; background-position: center center; background-repeat: no-repeat;`;\n    } else {\n        estilosFondo = `background: ${fondoValue};`;\n    }\n    return estilosFondo.replace(/\\s+/g, \" \").trim();\n}\nfunction generarHTMLDesdeSecciones(secciones, objetos, rsvp, opciones, opts) {\n    const slug = opciones?.slug ?? \"\";\n    const slugPublica = opts?.slug ?? \"\";\n    const fuentesUsadas = [\n        ...new Set(objetos.filter((o)=>(o.tipo === \"texto\" || o.tipo === \"countdown\") && o.fontFamily).map((o)=>o.fontFamily))\n    ];\n    const googleFontsLink = buildGoogleFontsLink(fuentesUsadas);\n    const hayRSVPEnCanvas = objetos?.some((o)=>o.tipo === \"rsvp-boton\");\n    const botonRSVP = \"\"; // (si querés agregar un botón fijo fuera del canvas, hacelo acá)\n    const modalRSVP = hayRSVPEnCanvas && rsvp?.enabled ? (0,_generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__.generarModalRSVPHTML)(rsvp) : \"\";\n    function hayCountdown(objs) {\n        return Array.isArray(objs) && objs.some((o)=>o?.tipo === \"countdown\");\n    }\n    const scriptCountdown = hayCountdown(objetos) ? `\n<script>\n(function(){\n  function pad(n){ n=Math.floor(Math.abs(n)); return n<10 ? \"0\"+n : \"\"+n; }\n  function diffParts(target){\n    const now = Date.now();\n    let ms = Math.max(0, target.getTime() - now);\n    const d = Math.floor(ms / 86400000); ms -= d*86400000;\n    const h = Math.floor(ms / 3600000);  ms -= h*3600000;\n    const m = Math.floor(ms / 60000);    ms -= m*60000;\n    const s = Math.floor(ms / 1000);\n    return { d, h, m, s };\n  }\n  function tickOne(root){\n    const iso = root.getAttribute(\"data-target\");\n    if(!iso) return;\n    const t = new Date(iso);\n    if(isNaN(t.getTime())) return;\n    const p = diffParts(t);\n    const vals = root.querySelectorAll(\".cd-val\");\n    if(vals && vals.length >= 4){\n      vals[0].textContent = String(p.d).padStart(2,\"0\");\n      vals[1].textContent = pad(p.h);\n      vals[2].textContent = pad(p.m);\n      vals[3].textContent = pad(p.s);\n    }\n  }\n  function boot(){\n    const roots = Array.from(document.querySelectorAll(\"[data-countdown]\"));\n    if(!roots.length) return;\n    roots.forEach(tickOne);\n    setInterval(() => roots.forEach(tickOne), 1000);\n  }\n  if(document.readyState === \"loading\"){\n    document.addEventListener(\"DOMContentLoaded\", boot);\n  } else {\n    boot();\n  }\n})();\n</script>\n`.trim() : \"\";\n    const seccionesOrdenadas = [\n        ...secciones || []\n    ].sort((a, b)=>(Number(a?.orden) || 0) - (Number(b?.orden) || 0));\n    const htmlSecciones = seccionesOrdenadas.map((seccion)=>{\n        const modo = String(seccion?.altoModo || \"fijo\").toLowerCase();\n        const hbase = Number.isFinite(seccion?.altura) ? Number(seccion.altura) : 600;\n        const objsDeSeccion = objetos.filter((o)=>o.seccionId === seccion.id);\n        const objsBleed = objsDeSeccion.filter((o)=>String(o?.anclaje || \"\").toLowerCase() === \"fullbleed\");\n        const objsContenido = objsDeSeccion.filter((o)=>String(o?.anclaje || \"\").toLowerCase() !== \"fullbleed\");\n        const fondoStyle = buildFondoStyle(seccion);\n        const htmlBleed = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsBleed, seccionesOrdenadas);\n        const htmlContenido = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsContenido, seccionesOrdenadas);\n        return `\n<section class=\"sec\" data-modo=\"${escapeAttr(modo)}\" style=\"--hbase:${hbase}\">\n  <div class=\"sec-zoom\">\n    <div class=\"sec-bg\" style=\"${fondoStyle}\"></div>\n    <div class=\"sec-bleed\">${htmlBleed}</div>\n    <div class=\"sec-content\">${htmlContenido}</div>\n  </div>\n</section>\n`.trim();\n    }).join(\"\\n\");\n    const scriptMobileSmart = (0,_mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_3__.buildMobileSmartSectionLayoutScript)({\n        enabled: ENABLE_MOBILE_SMART_LAYOUT,\n        minGapPx: 1,\n        paddingTopPx: 0,\n        paddingBottomPx: 2,\n        onlyFixedSections: true,\n        minPerColumn2: 1,\n        fitMinScale: 0.88,\n        fitMaxScale: 1.16,\n        fitTargetWidthRatio: 0.94,\n        fitMinFillRatio: 0.9\n    });\n    return `\n<!DOCTYPE html>\n<html lang=\"es\"${slug ? ` data-slug=\"${escapeAttr(slug)}\"` : \"\"}>\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\" />\n  <title>Invitación</title>\n  ${googleFontsLink}\n  <style>\n    * { box-sizing: border-box; margin: 0; padding: 0; }\n\n    html, body {\n      width: 100%;\n      height: 100%;\n      background: white;\n      overflow-x: hidden;\n      font-family: sans-serif;\n    }\n\n    /* ✅ SOLO MOBILE: evita “auto-resize / font boosting” del texto */\n    @media (max-width: 767px){\n      html{\n        -webkit-text-size-adjust: 100%;\n        text-size-adjust: 100%;\n      }\n      \n        :root{ --text-zoom: 1.25; } /* probá 1.10–1.25 */\n    }\n\n    :root{\n      --safe-top: env(safe-area-inset-top, 0px);\n      --safe-right: env(safe-area-inset-right, 0px);\n      --safe-bottom: env(safe-area-inset-bottom, 0px);\n      --safe-left: env(safe-area-inset-left, 0px);\n      --bp-mobile: 767px;\n      \n\n\n      /* Global scales */\n      --content-w: ${_models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__.CANVAS_BASE.ANCHO}px;\n      --sx: 1;   /* contentW/800 */\n      --bx: 1;   /* viewportW/800 */\n\n      /* vh lógico por defecto */\n      --vh-safe: 100vh;\n      --vh-logical: var(--vh-safe);\n\n      /* ✅ Offset SOLO para texto en Pantalla: ON (desktop default) */\n      --pantalla-y-offset: ${PANTALLA_Y_OFFSET_DESKTOP_PX}px;\n    }\n\n    /* ✅ Mobile: offset distinto SOLO para texto en Pantalla: ON */\n    @media (max-width: 767px){\n      :root{\n        --pantalla-y-offset: ${PANTALLA_Y_OFFSET_MOBILE_PX}px;\n      }\n    }\n\n    .inv{ width: 100%; background: white; }\n\n    .sec{\n      position: relative;\n      width: 100vw;\n      left: 50%;\n      transform: translateX(-50%);\n      overflow: visible; /* bleed puede salirse */\n    }\n\n    /* ✅ Wrapper que hace “zoom” centrado (evita corrimiento a la derecha) */\n    .sec-zoom{\n      position: relative;\n      width: 100%;\n      height: 100%;\n      transform-origin: top center;\n      transform: scale(var(--zoom, 1));\n    }\n\n    /* ✅ Pantalla ON: recorte para que el zoom no desborde */\n    .sec[data-modo=\"pantalla\"]{\n      overflow: hidden;\n      height: 100dvh;\n      height: 100vh;\n      padding-top: var(--safe-top);\n      padding-bottom: var(--safe-bottom);\n\n      /* fallback CSS (JS lo pisa en mobile con px reales) */\n      --vh-safe: calc(100dvh - var(--safe-top) - var(--safe-bottom));\n\n      /* el zoom extra va por --zoom (NO por sfinal) */\n      --zoom: 1;\n      --bgzoom: 1;\n\n      /* factor final para CONTENIDO (se setea por JS) */\n      --sfinal: 1;\n    }\n\n    .sec[data-modo=\"fijo\"]{\n      /* altura fija escalada por ancho; JS setea --sfinal = sx */\n      height: calc(var(--sfinal) * var(--hbase) * 1px);\n      --zoom: 1;\n      --bgzoom: 1;\n    }\n\n    /* Fondo */\n    .sec-bg{\n      position: absolute;\n      inset: 0;\n      z-index: 0;\n      pointer-events: none;\n    }\n\n    /* ✅ Fondo agrandable solo en pantalla (acompaña el zoom hero) */\n    .sec[data-modo=\"pantalla\"] .sec-bg{\n      transform: scale(var(--bgzoom, 1));\n      transform-origin: center;\n    }\n\n    .sec-bleed{\n      position: absolute;\n      inset: 0;\n      z-index: 2;\n      overflow: visible;\n      pointer-events: none;\n    }\n\n    .sec-content{\n      position: relative;\n      z-index: 3;\n      width: var(--content-w);\n      margin: 0 auto;\n      height: 100%;\n      pointer-events: none;\n    }\n\n    /* ✅ Pantalla ON: el ancho del “content” puede crecer con la escala vertical */\n    .sec[data-modo=\"pantalla\"] .sec-content{\n      width: var(--content-w-pantalla, var(--content-w));\n    }\n\n    @media (max-width: 767px){\n      .sec-content{\n        width: 100%;\n        margin: 0;\n        box-sizing: border-box;\n        padding-left: var(--safe-left);\n        padding-right: var(--safe-right);\n      }\n    }\n\n    .objeto{\n      position: absolute;\n      transform-origin: top left;\n      overflow: visible;\n      pointer-events: auto;\n    }\n\n    .objeto.is-interactive{ pointer-events: auto; }\n\n    .cd-chip { backdrop-filter: saturate(1.1); }\n  </style>\n</head>\n\n<body data-slug=\"${escapeAttr(slugPublica)}\">\n  <div class=\"inv\">\n    ${htmlSecciones}\n  </div>\n\n  ${botonRSVP}\n  ${modalRSVP}\n\n  ${scriptCountdown}\n\n  <script>\n    (function(){\n      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }\n\n      function compute(){\n        var vw = document.documentElement.clientWidth;\n        var BASE_W = 800; // = CANVAS_BASE.ANCHO\n\n        // contentW (sin vw-32)\n        var contentW = Math.min(BASE_W, vw);\n\n        var sx = contentW / BASE_W;\n        var bx = vw / BASE_W;\n\n        document.documentElement.style.setProperty(\"--content-w\", contentW + \"px\");\n        document.documentElement.style.setProperty(\"--sx\", String(sx));\n        document.documentElement.style.setProperty(\"--bx\", String(bx));\n\n        var secs = Array.from(document.querySelectorAll(\".sec\"));\n        var isMobile = vw <= 767;\n\n        // viewport real (más estable en mobile)\n        var vv = window.visualViewport;\n        var viewportH = (vv && vv.height) ? vv.height : window.innerHeight;\n\n        // safe areas (css env)\n        var safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-top\")) || 0;\n        var safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-bottom\")) || 0;\n\n        // diseño base del modo \"pantalla\" (800 x 500)\n        var DESIGN_W = BASE_W;\n        var DESIGN_H = ${ALTURA_REFERENCIA_PANTALLA}; // = ALTURA_REFERENCIA_PANTALLA\n        var designAR = DESIGN_H / DESIGN_W; // 0.625\n        var deviceAR = viewportH / vw;\n\n        // zoom extra (solo si el device es más vertical que el diseño)\n        var zoomExtra = 1;\n        if (isMobile && deviceAR > designAR){\n          var k = deviceAR / designAR;\n          zoomExtra = clamp(1 + (k - 1) * 0.18, 1, 1.35);\n        }\n\n        // 🔧 Ajuste fino: cuánto acompaña el fondo al zoom hero (0..1.2)\n        // 0   => el fondo NO agrega zoom extra propio (solo el zoom del wrapper)\n        // 1   => comportamiento actual (fondo queda zoomExtra²)\n        // 0.3 => recomendado para empezar (sutil)\n        var BG_ZOOM_FACTOR = 0;\n\n        // 🔧 Ajuste fino: cuánto acompaña el CONTENIDO (texto/objetos) al zoom hero\n        // 0   => comportamiento actual\n        // 0.3 => recomendado\n        // 1   => texto escala igual que el hero (no aconsejado)\n        var TEXT_ZOOM_FACTOR = 0;\n\n\n        secs.forEach(function(sec){\n          var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n\n          // defaults\n          var zoom = 1;\n          var bgzoom = 1;\n\n          // ✅ Por defecto, tamaños escalan por ancho (comportamiento actual)\n          var sfinal = sx;\n\n          // limpiar custom width si no aplica\n          sec.style.removeProperty(\"--content-w-pantalla\");\n\n          if (modo === \"pantalla\"){\n            // vh-safe real en px\n            var vhSafePx = Math.max(0, viewportH - safeTop - safeBottom);\n            sec.style.setProperty(\"--vh-safe\", vhSafePx + \"px\");\n\n            // 🔥 Desktop: escalar el contenido por ALTURA (vhSafe/500)\n            // Esto alinea el HTML publicado con lo que ves en preview\n            if (!isMobile){\n              var sh = vhSafePx / DESIGN_H;\n              sfinal = sh;\n\n              // para que el \"content\" quede centrado y coherente con la nueva escala vertical\n              sec.style.setProperty(\"--content-w-pantalla\", (DESIGN_W * sh) + \"px\");\n            }\n\n            // ✅ Mobile: mantenemos tu comportamiento actual (zoom hero suave)\n            if (isMobile){\n              zoom = zoomExtra;\n              bgzoom = 1 + (zoomExtra - 1) * BG_ZOOM_FACTOR;\n\n              // 🔥 NUEVO: el contenido acompaña parcialmente el zoom\n              sfinal = sx * (1 + (zoomExtra - 1) * TEXT_ZOOM_FACTOR);\n            }\n          }\n\n          sec.style.setProperty(\"--sfinal\", String(sfinal));\n          sec.style.setProperty(\"--zoom\", String(zoom));\n          sec.style.setProperty(\"--bgzoom\", String(bgzoom));\n\n          // ✅ Solo en mobile + pantalla: corregir el \"vh\" que después se escala con zoom\n          if (isMobile && modo === \"pantalla\") {\n            // --vh-logical = --vh-safe / --zoom\n            sec.style.setProperty(\"--vh-logical\", \"calc(var(--vh-safe) / var(--zoom))\");\n          } else {\n            // resto: se comporta como siempre\n            sec.style.setProperty(\"--vh-logical\", \"var(--vh-safe)\");\n          }\n        });\n\n\n      }\n\n      window.addEventListener(\"load\", compute);\n      window.addEventListener(\"resize\", compute);\n\n      if (window.visualViewport){\n        window.visualViewport.addEventListener(\"resize\", compute);\n        window.visualViewport.addEventListener(\"scroll\", compute);\n      }\n\n      window.addEventListener(\"orientationchange\", function(){\n        setTimeout(compute, 50);\n        setTimeout(compute, 250);\n      });\n\n      compute();\n    })();\n  </script>\n\n    \n\n\n   ${scriptMobileSmart}\n \n</body>\n</html>\n`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRTtBQUNaO0FBQ2tDO0FBQ1Q7QUFFakYsTUFBTUksNkJBQTZCLE1BQU0sc0JBQXNCO0FBRS9ELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJO0lBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsNkJBQTZCO0FBRW5DLHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxNQUFNQywrQkFBK0IsQ0FBQztBQUN0QyxNQUFNQyw4QkFBOEI7QUFFcEMsU0FBU0MscUJBQXFCQyxLQUFlO0lBQzNDLE1BQU1DLFdBQVdELE1BQ2RFLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxPQUFPLENBQUMsU0FBUyxJQUFJQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxJQUNwREMsTUFBTSxDQUFDLENBQUNDLElBQU1BLEtBQUssQ0FBQ2QsY0FBY2UsR0FBRyxDQUFDRCxJQUN0Q04sR0FBRyxDQUFDLENBQUNNLElBQU0sQ0FBQyxPQUFPLEVBQUVBLEVBQUVKLE9BQU8sQ0FBQyxNQUFNLE1BQU0sRUFDM0NNLElBQUksQ0FBQztJQUVSLElBQUksQ0FBQ1QsVUFBVSxPQUFPO0lBRXRCLE9BQU8sQ0FBQzs7OENBRW9DLEVBQUVBLFNBQVMsZ0NBQWdDLENBQUMsQ0FBQ0ssSUFBSTtBQUMvRjtBQU1BLFNBQVNLLFdBQVdDLE1BQWMsRUFBRTtJQUNsQyxPQUFPQyxPQUFPRCxLQUNYUixPQUFPLENBQUMsTUFBTSxTQUNkQSxPQUFPLENBQUMsTUFBTSxVQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTTtBQUNuQjtBQUVBLFNBQVNVLGdCQUFnQkMsT0FBWTtJ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QWM7UUFDZEMsaUJBQWlCO1FBQ2pCQyxtQkFBbUI7UUFDbkJDLGVBQWU7UUFDZkMsYUFBYTtRQUNiQyxhQUFhO1FBQ2JDLHFCQUFxQjtRQUNyQkMsaUJBQWlCO0lBQ25CO0lBRUEsT0FBTyxDQUFDOztlQUVLLEVBQUVoRCxPQUFPLENBQUMsWUFBWSxFQUFFNUIsV0FBVzRCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRzs7Ozs7RUFLOUQsRUFBRU0sZ0JBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFnQ0QsRUFBRXZELGdFQUFXQSxDQUFDa0csS0FBSyxDQUFDOzs7Ozs7Ozs7MkJBU1osRUFBRTNGLDZCQUE2Qjs7Ozs7OzZCQU03QixFQUFFQyw0QkFBNEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkE0RzFDLEVBQUVhLFdBQVc2QixhQUFhOztJQUV2QyxFQUFFc0IsY0FBYzs7O0VBR2xCLEVBQUVkLFVBQVU7RUFDWixFQUFFQyxVQUFVOztFQUVaLEVBQUVNLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQWlDRyxFQUFFM0QsMkJBQTJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtR2pELEVBQUVrRixrQkFBa0I7Ozs7QUFJdkIsQ0FBQztBQUNEIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXGdlbmVyYXJIVE1MRGVzZGVTZWNjaW9uZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MgfSBmcm9tIFwiLi9nZW5lcmFySFRNTERlc2RlT2JqZXRvc1wiO1xyXG5pbXBvcnQgeyBDQU5WQVNfQkFTRSB9IGZyb20gXCIuLi9tb2RlbHMvZGltZW5zaW9uZXNCYXNlXCI7XHJcbmltcG9ydCB7IGdlbmVyYXJNb2RhbFJTVlBIVE1MLCB0eXBlIFJTVlBDb25maWcgYXMgTW9kYWxDb25maWcgfSBmcm9tIFwiLi9nZW5lcmFyTW9kYWxSU1ZQXCI7XHJcbmltcG9ydCB7IGJ1aWxkTW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0U2NyaXB0IH0gZnJvbSBcIi4vbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0XCI7XHJcblxyXG5jb25zdCBFTkFCTEVfTU9CSUxFX1NNQVJUX0xBWU9VVCA9IHRydWU7IC8vIOKchSBlbXBlemFtb3MgYXBhZ2Fkb1xyXG5cclxuY29uc3QgRVhDTFVERV9GT05UUyA9IG5ldyBTZXQoW1xyXG4gIFwic2VyaWZcIixcclxuICBcInNhbnMtc2VyaWZcIixcclxuICBcIm1vbm9zcGFjZVwiLFxyXG4gIFwiY3Vyc2l2ZVwiLFxyXG4gIFwiZmFudGFzeVwiLFxyXG4gIFwic3lzdGVtLXVpXCIsXHJcbiAgXCJBcmlhbFwiLFxyXG4gIFwiSGVsdmV0aWNhXCIsXHJcbiAgXCJUaW1lc1wiLFxyXG4gIFwiVGltZXMgTmV3IFJvbWFuXCIsXHJcbiAgXCJHZW9yZ2lhXCIsXHJcbiAgXCJDb3VyaWVyIE5ld1wiLFxyXG5dKTtcclxuXHJcbmNvbnN0IEFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBID0gNTAwO1xyXG5cclxuLy8g4pyFIE9mZnNldHMgU09MTyBwYXJhIHRleHRvIGVuIHNlY2Npb25lcyBQYW50YWxsYTogT05cclxuLy8gLSBEZXNrdG9wOiBhcGxpY2EgY3VhbmRvIHZ3ID4gNzY3cHhcclxuLy8gLSBNb2JpbGU6IGFwbGljYSBjdWFuZG8gdncgPD0gNzY3cHhcclxuLy8gKEVzdG9zIHZhbG9yZXMgc2UgdnVlbGNhbiBhIENTUyB2YXJpYWJsZXMgZW4gOnJvb3QpXHJcbmNvbnN0IFBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFggPSAtMjg7XHJcbmNvbnN0IFBBTlRBTExBX1lfT0ZGU0VUX01PQklMRV9QWCA9IDA7XHJcblxyXG5mdW5jdGlvbiBidWlsZEdvb2dsZUZvbnRzTGluayhmb250czogc3RyaW5nW10pOiBzdHJpbmcge1xyXG4gIGNvbnN0IGZhbWlsaWFzID0gZm9udHNcclxuICAgIC5tYXAoKGYpID0+IGYucmVwbGFjZSgvWydcIl0vZywgXCJcIikuc3BsaXQoXCIsXCIpWzBdLnRyaW0oKSlcclxuICAgIC5maWx0ZXIoKG4pID0+IG4gJiYgIUVYQ0xVREVfRk9OVFMuaGFzKG4pKVxyXG4gICAgLm1hcCgobikgPT4gYGZhbWlseT0ke24ucmVwbGFjZSgvIC9nLCBcIitcIil9YClcclxuICAgIC5qb2luKFwiJlwiKTtcclxuXHJcbiAgaWYgKCFmYW1pbGlhcykgcmV0dXJuIFwiXCI7XHJcblxyXG4gIHJldHVybiBgXHJcbjxsaW5rIHJlbD1cInByZWNvbm5lY3RcIiBocmVmPVwiaHR0cHM6Ly9mb250cy5nc3RhdGljLmNvbVwiIGNyb3Nzb3JpZ2luPlxyXG48bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyPyR7ZmFtaWxpYXN9JmRpc3BsYXk9c3dhcFwiIHJlbD1cInN0eWxlc2hlZXRcIj5gLnRyaW0oKTtcclxufVxyXG5cclxudHlwZSBHZW5lcmFySFRNTE9wY2lvbmVzID0ge1xyXG4gIHNsdWc/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHN0cjogc3RyaW5nID0gXCJcIik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIFN0cmluZyhzdHIpXHJcbiAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXHJcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcclxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZEZvbmRvU3R5bGUoc2VjY2lvbjogYW55KTogc3RyaW5nIHtcclxuICBjb25zdCBmb25kb1ZhbHVlID0gc2VjY2lvbj8uZm9uZG8gfHwgXCJ0cmFuc3BhcmVudFwiO1xyXG4gIGNvbnN0IGVzSW1hZ2VuRm9uZG8gPSBzZWNjaW9uPy5mb25kb1RpcG8gPT09IFwiaW1hZ2VuXCIgJiYgc2VjY2lvbj8uZm9uZG9JbWFnZW47XHJcblxyXG4gIGxldCBlc3RpbG9zRm9uZG8gPSBcIlwiO1xyXG5cclxuICBpZiAoZXNJbWFnZW5Gb25kbykge1xyXG4gICAgbGV0IGltYWdlVXJsID0gc2VjY2lvbi5mb25kb0ltYWdlbjtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGltYWdlVXJsICYmXHJcbiAgICAgIGltYWdlVXJsLmluY2x1ZGVzKFwiZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tXCIpICYmXHJcbiAgICAgICFpbWFnZVVybC5pbmNsdWRlcyhcImFsdD1tZWRpYVwiKVxyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlVXJsID0gaW1hZ2VVcmwgKyAoaW1hZ2VVcmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIikgKyBcImFsdD1tZWRpYVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBiYWNrZ3JvdW5kUG9zaXRpb24gPSBcImNlbnRlciBjZW50ZXJcIjtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHNlY2Npb24uZm9uZG9JbWFnZW5PZmZzZXRYICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgc2VjY2lvbi5mb25kb0ltYWdlbk9mZnNldFkgIT09IHVuZGVmaW5lZFxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IG9mZnNldFggPSBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WCB8fCAwO1xyXG4gICAgICBjb25zdCBvZmZzZXRZID0gc2VjY2lvbi5mb25kb0ltYWdlbk9mZnNldFkgfHwgMDtcclxuXHJcbiAgICAgIGNvbnN0IG9mZnNldFhQZXJjZW50ID0gb2Zmc2V0WCAhPT0gMCA/IGBjYWxjKDUwJSAtICR7LW9mZnNldFh9cHgpYCA6IFwiNTAlXCI7XHJcbiAgICAgIGNvbnN0IG9mZnNldFlQZXJjZW50ID0gb2Zmc2V0WSAhPT0gMCA/IGBjYWxjKDUwJSAtICR7LW9mZnNldFl9cHgpYCA6IFwiNTAlXCI7XHJcblxyXG4gICAgICBiYWNrZ3JvdW5kUG9zaXRpb24gPSBgJHtvZmZzZXRYUGVyY2VudH0gJHtvZmZzZXRZUGVyY2VudH1gO1xyXG4gICAgfVxyXG5cclxuICAgIGVzdGlsb3NGb25kbyA9IGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJyR7aW1hZ2VVcmx9Jyk7IGJhY2tncm91bmQtc2l6ZTogY292ZXI7IGJhY2tncm91bmQtcG9zaXRpb246ICR7YmFja2dyb3VuZFBvc2l0aW9ufTsgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtgO1xyXG4gIH0gZWxzZSBpZiAoXHJcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJodHRwXCIpIHx8XHJcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fFxyXG4gICAgZm9uZG9WYWx1ZS5zdGFydHNXaXRoKFwiYmxvYjpcIilcclxuICApIHtcclxuICAgIGxldCBpbWFnZVVybCA9IGZvbmRvVmFsdWUucmVwbGFjZShcInVybChcIiwgXCJcIikucmVwbGFjZShcIilcIiwgXCJcIik7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBpbWFnZVVybC5pbmNsdWRlcyhcImZpcmViYXNlc3RvcmFnZS5nb29nbGVhcGlzLmNvbVwiKSAmJlxyXG4gICAgICAhaW1hZ2VVcmwuaW5jbHVkZXMoXCJhbHQ9bWVkaWFcIilcclxuICAgICkge1xyXG4gICAgICBpbWFnZVVybCA9IGltYWdlVXJsICsgKGltYWdlVXJsLmluY2x1ZGVzKFwiP1wiKSA/IFwiJlwiIDogXCI/XCIpICsgXCJhbHQ9bWVkaWFcIjtcclxuICAgIH1cclxuXHJcbiAgICBlc3RpbG9zRm9uZG8gPSBgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcke2ltYWdlVXJsfScpOyBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyOyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyOyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O2A7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVzdGlsb3NGb25kbyA9IGBiYWNrZ3JvdW5kOiAke2ZvbmRvVmFsdWV9O2A7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXN0aWxvc0ZvbmRvLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJIVE1MRGVzZGVTZWNjaW9uZXMoXHJcbiAgc2VjY2lvbmVzOiBhbnlbXSxcclxuICBvYmpldG9zOiBhbnlbXSxcclxuICByc3ZwPzogTW9kYWxDb25maWcsXHJcbiAgb3BjaW9uZXM/OiBHZW5lcmFySFRNTE9wY2lvbmVzLFxyXG4gIG9wdHM/OiB7IHNsdWc/OiBzdHJpbmcgfVxyXG4pOiBzdHJpbmcge1xyXG4gIGNvbnN0IHNsdWcgPSBvcGNpb25lcz8uc2x1ZyA/PyBcIlwiO1xyXG4gIGNvbnN0IHNsdWdQdWJsaWNhID0gb3B0cz8uc2x1ZyA/PyBcIlwiO1xyXG5cclxuICBjb25zdCBmdWVudGVzVXNhZGFzID0gW1xyXG4gICAgLi4ubmV3IFNldChcclxuICAgICAgb2JqZXRvc1xyXG4gICAgICAgIC5maWx0ZXIoKG8pID0+IChvLnRpcG8gPT09IFwidGV4dG9cIiB8fCBvLnRpcG8gPT09IFwiY291bnRkb3duXCIpICYmIG8uZm9udEZhbWlseSlcclxuICAgICAgICAubWFwKChvKSA9PiBvLmZvbnRGYW1pbHkpXHJcbiAgICApLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdvb2dsZUZvbnRzTGluayA9IGJ1aWxkR29vZ2xlRm9udHNMaW5rKGZ1ZW50ZXNVc2FkYXMpO1xyXG5cclxuICBjb25zdCBoYXlSU1ZQRW5DYW52YXMgPSBvYmpldG9zPy5zb21lKChvKSA9PiBvLnRpcG8gPT09IFwicnN2cC1ib3RvblwiKTtcclxuICBjb25zdCBib3RvblJTVlAgPSBcIlwiOyAvLyAoc2kgcXVlcsOpcyBhZ3JlZ2FyIHVuIGJvdMOzbiBmaWpvIGZ1ZXJhIGRlbCBjYW52YXMsIGhhY2VsbyBhY8OhKVxyXG4gIGNvbnN0IG1vZGFsUlNWUCA9IGhheVJTVlBFbkNhbnZhcyAmJiByc3ZwPy5lbmFibGVkID8gZ2VuZXJhck1vZGFsUlNWUEhUTUwocnN2cCkgOiBcIlwiO1xyXG5cclxuICBmdW5jdGlvbiBoYXlDb3VudGRvd24ob2JqczogYW55W10pIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9ianMpICYmIG9ianMuc29tZSgobykgPT4gbz8udGlwbyA9PT0gXCJjb3VudGRvd25cIik7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzY3JpcHRDb3VudGRvd24gPSBoYXlDb3VudGRvd24ob2JqZXRvcylcclxuICAgID8gYFxyXG48c2NyaXB0PlxyXG4oZnVuY3Rpb24oKXtcclxuICBmdW5jdGlvbiBwYWQobil7IG49TWF0aC5mbG9vcihNYXRoLmFicyhuKSk7IHJldHVybiBuPDEwID8gXCIwXCIrbiA6IFwiXCIrbjsgfVxyXG4gIGZ1bmN0aW9uIGRpZmZQYXJ0cyh0YXJnZXQpe1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCBtcyA9IE1hdGgubWF4KDAsIHRhcmdldC5nZXRUaW1lKCkgLSBub3cpO1xyXG4gICAgY29uc3QgZCA9IE1hdGguZmxvb3IobXMgLyA4NjQwMDAwMCk7IG1zIC09IGQqODY0MDAwMDA7XHJcbiAgICBjb25zdCBoID0gTWF0aC5mbG9vcihtcyAvIDM2MDAwMDApOyAgbXMgLT0gaCozNjAwMDAwO1xyXG4gICAgY29uc3QgbSA9IE1hdGguZmxvb3IobXMgLyA2MDAwMCk7ICAgIG1zIC09IG0qNjAwMDA7XHJcbiAgICBjb25zdCBzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApO1xyXG4gICAgcmV0dXJuIHsgZCwgaCwgbSwgcyB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiB0aWNrT25lKHJvb3Qpe1xyXG4gICAgY29uc3QgaXNvID0gcm9vdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKTtcclxuICAgIGlmKCFpc28pIHJldHVybjtcclxuICAgIGNvbnN0IHQgPSBuZXcgRGF0ZShpc28pO1xyXG4gICAgaWYoaXNOYU4odC5nZXRUaW1lKCkpKSByZXR1cm47XHJcbiAgICBjb25zdCBwID0gZGlmZlBhcnRzKHQpO1xyXG4gICAgY29uc3QgdmFscyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbChcIi5jZC12YWxcIik7XHJcbiAgICBpZih2YWxzICYmIHZhbHMubGVuZ3RoID49IDQpe1xyXG4gICAgICB2YWxzWzBdLnRleHRDb250ZW50ID0gU3RyaW5nKHAuZCkucGFkU3RhcnQoMixcIjBcIik7XHJcbiAgICAgIHZhbHNbMV0udGV4dENvbnRlbnQgPSBwYWQocC5oKTtcclxuICAgICAgdmFsc1syXS50ZXh0Q29udGVudCA9IHBhZChwLm0pO1xyXG4gICAgICB2YWxzWzNdLnRleHRDb250ZW50ID0gcGFkKHAucyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJvb3QoKXtcclxuICAgIGNvbnN0IHJvb3RzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtY291bnRkb3duXVwiKSk7XHJcbiAgICBpZighcm9vdHMubGVuZ3RoKSByZXR1cm47XHJcbiAgICByb290cy5mb3JFYWNoKHRpY2tPbmUpO1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4gcm9vdHMuZm9yRWFjaCh0aWNrT25lKSwgMTAwMCk7XHJcbiAgfVxyXG4gIGlmKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiKXtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBib290KCk7XHJcbiAgfVxyXG59KSgpO1xyXG48L3NjcmlwdD5cclxuYC50cmltKClcclxuICAgIDogXCJcIjtcclxuXHJcbiAgY29uc3Qgc2VjY2lvbmVzT3JkZW5hZGFzID0gWy4uLihzZWNjaW9uZXMgfHwgW10pXS5zb3J0KFxyXG4gICAgKGEsIGIpID0+IChOdW1iZXIoYT8ub3JkZW4pIHx8IDApIC0gKE51bWJlcihiPy5vcmRlbikgfHwgMClcclxuICApO1xyXG5cclxuXHJcbiAgY29uc3QgaHRtbFNlY2Npb25lcyA9IHNlY2Npb25lc09yZGVuYWRhc1xyXG4gICAgLm1hcCgoc2VjY2lvbikgPT4ge1xyXG4gICAgICBjb25zdCBtb2RvID0gU3RyaW5nKHNlY2Npb24/LmFsdG9Nb2RvIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBjb25zdCBoYmFzZSA9IE51bWJlci5pc0Zpbml0ZShzZWNjaW9uPy5hbHR1cmEpID8gTnVtYmVyKHNlY2Npb24uYWx0dXJhKSA6IDYwMDtcclxuXHJcbiAgICAgIGNvbnN0IG9ianNEZVNlY2Npb24gPSBvYmpldG9zLmZpbHRlcigobykgPT4gby5zZWNjaW9uSWQgPT09IHNlY2Npb24uaWQpO1xyXG5cclxuICAgICAgY29uc3Qgb2Jqc0JsZWVkID0gb2Jqc0RlU2VjY2lvbi5maWx0ZXIoXHJcbiAgICAgICAgKG8pID0+IFN0cmluZyhvPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiZnVsbGJsZWVkXCJcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgb2Jqc0NvbnRlbmlkbyA9IG9ianNEZVNlY2Npb24uZmlsdGVyKFxyXG4gICAgICAgIChvKSA9PiBTdHJpbmcobz8uYW5jbGFqZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpICE9PSBcImZ1bGxibGVlZFwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBmb25kb1N0eWxlID0gYnVpbGRGb25kb1N0eWxlKHNlY2Npb24pO1xyXG5cclxuICAgICAgY29uc3QgaHRtbEJsZWVkID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0JsZWVkLCBzZWNjaW9uZXNPcmRlbmFkYXMpO1xyXG4gICAgICBjb25zdCBodG1sQ29udGVuaWRvID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0NvbnRlbmlkbywgc2VjY2lvbmVzT3JkZW5hZGFzKTtcclxuXHJcblxyXG4gICAgICByZXR1cm4gYFxyXG48c2VjdGlvbiBjbGFzcz1cInNlY1wiIGRhdGEtbW9kbz1cIiR7ZXNjYXBlQXR0cihtb2RvKX1cIiBzdHlsZT1cIi0taGJhc2U6JHtoYmFzZX1cIj5cclxuICA8ZGl2IGNsYXNzPVwic2VjLXpvb21cIj5cclxuICAgIDxkaXYgY2xhc3M9XCJzZWMtYmdcIiBzdHlsZT1cIiR7Zm9uZG9TdHlsZX1cIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJzZWMtYmxlZWRcIj4ke2h0bWxCbGVlZH08L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJzZWMtY29udGVudFwiPiR7aHRtbENvbnRlbmlkb308L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5gLnRyaW0oKTtcclxuICAgIH0pXHJcbiAgICAuam9pbihcIlxcblwiKTtcclxuXHJcbiAgY29uc3Qgc2NyaXB0TW9iaWxlU21hcnQgPSBidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCh7XG4gICAgZW5hYmxlZDogRU5BQkxFX01PQklMRV9TTUFSVF9MQVlPVVQsXG4gICAgbWluR2FwUHg6IDEsXG4gICAgcGFkZGluZ1RvcFB4OiAwLFxuICAgIHBhZGRpbmdCb3R0b21QeDogMixcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogdHJ1ZSxcbiAgICBtaW5QZXJDb2x1bW4yOiAxLFxuICAgIGZpdE1pblNjYWxlOiAwLjg4LFxuICAgIGZpdE1heFNjYWxlOiAxLjE2LFxuICAgIGZpdFRhcmdldFdpZHRoUmF0aW86IDAuOTQsXG4gICAgZml0TWluRmlsbFJhdGlvOiAwLjksXG4gIH0pO1xuXHJcbiAgcmV0dXJuIGBcclxuPCFET0NUWVBFIGh0bWw+XHJcbjxodG1sIGxhbmc9XCJlc1wiJHtzbHVnID8gYCBkYXRhLXNsdWc9XCIke2VzY2FwZUF0dHIoc2x1Zyl9XCJgIDogXCJcIn0+XHJcbjxoZWFkPlxyXG4gIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiIC8+XHJcbiAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIHZpZXdwb3J0LWZpdD1jb3ZlclwiIC8+XHJcbiAgPHRpdGxlPkludml0YWNpw7NuPC90aXRsZT5cclxuICAke2dvb2dsZUZvbnRzTGlua31cclxuICA8c3R5bGU+XHJcbiAgICAqIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyB9XHJcblxyXG4gICAgaHRtbCwgYm9keSB7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICBvdmVyZmxvdy14OiBoaWRkZW47XHJcbiAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBTT0xPIE1PQklMRTogZXZpdGEg4oCcYXV0by1yZXNpemUgLyBmb250IGJvb3N0aW5n4oCdIGRlbCB0ZXh0byAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgaHRtbHtcclxuICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XHJcbiAgICAgICAgdGV4dC1zaXplLWFkanVzdDogMTAwJTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICA6cm9vdHsgLS10ZXh0LXpvb206IDEuMjU7IH0gLyogcHJvYsOhIDEuMTDigJMxLjI1ICovXHJcbiAgICB9XHJcblxyXG4gICAgOnJvb3R7XHJcbiAgICAgIC0tc2FmZS10b3A6IGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtcmlnaHQ6IGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweCk7XHJcbiAgICAgIC0tc2FmZS1ib3R0b206IGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtbGVmdDogZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpO1xyXG4gICAgICAtLWJwLW1vYmlsZTogNzY3cHg7XHJcbiAgICAgIFxyXG5cclxuXHJcbiAgICAgIC8qIEdsb2JhbCBzY2FsZXMgKi9cclxuICAgICAgLS1jb250ZW50LXc6ICR7Q0FOVkFTX0JBU0UuQU5DSE99cHg7XHJcbiAgICAgIC0tc3g6IDE7ICAgLyogY29udGVudFcvODAwICovXHJcbiAgICAgIC0tYng6IDE7ICAgLyogdmlld3BvcnRXLzgwMCAqL1xyXG5cclxuICAgICAgLyogdmggbMOzZ2ljbyBwb3IgZGVmZWN0byAqL1xyXG4gICAgICAtLXZoLXNhZmU6IDEwMHZoO1xyXG4gICAgICAtLXZoLWxvZ2ljYWw6IHZhcigtLXZoLXNhZmUpO1xyXG5cclxuICAgICAgLyog4pyFIE9mZnNldCBTT0xPIHBhcmEgdGV4dG8gZW4gUGFudGFsbGE6IE9OIChkZXNrdG9wIGRlZmF1bHQpICovXHJcbiAgICAgIC0tcGFudGFsbGEteS1vZmZzZXQ6ICR7UEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWH1weDtcclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgTW9iaWxlOiBvZmZzZXQgZGlzdGludG8gU09MTyBwYXJhIHRleHRvIGVuIFBhbnRhbGxhOiBPTiAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgOnJvb3R7XHJcbiAgICAgICAgLS1wYW50YWxsYS15LW9mZnNldDogJHtQQU5UQUxMQV9ZX09GRlNFVF9NT0JJTEVfUFh9cHg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAuaW52eyB3aWR0aDogMTAwJTsgYmFja2dyb3VuZDogd2hpdGU7IH1cclxuXHJcbiAgICAuc2Vje1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHdpZHRoOiAxMDB2dztcclxuICAgICAgbGVmdDogNTAlO1xyXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XHJcbiAgICAgIG92ZXJmbG93OiB2aXNpYmxlOyAvKiBibGVlZCBwdWVkZSBzYWxpcnNlICovXHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFdyYXBwZXIgcXVlIGhhY2Ug4oCcem9vbeKAnSBjZW50cmFkbyAoZXZpdGEgY29ycmltaWVudG8gYSBsYSBkZXJlY2hhKSAqL1xyXG4gICAgLnNlYy16b29te1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBjZW50ZXI7XHJcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tem9vbSwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBQYW50YWxsYSBPTjogcmVjb3J0ZSBwYXJhIHF1ZSBlbCB6b29tIG5vIGRlc2JvcmRlICovXHJcbiAgICAuc2VjW2RhdGEtbW9kbz1cInBhbnRhbGxhXCJde1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICBoZWlnaHQ6IDEwMGR2aDtcclxuICAgICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgICAgcGFkZGluZy10b3A6IHZhcigtLXNhZmUtdG9wKTtcclxuICAgICAgcGFkZGluZy1ib3R0b206IHZhcigtLXNhZmUtYm90dG9tKTtcclxuXHJcbiAgICAgIC8qIGZhbGxiYWNrIENTUyAoSlMgbG8gcGlzYSBlbiBtb2JpbGUgY29uIHB4IHJlYWxlcykgKi9cclxuICAgICAgLS12aC1zYWZlOiBjYWxjKDEwMGR2aCAtIHZhcigtLXNhZmUtdG9wKSAtIHZhcigtLXNhZmUtYm90dG9tKSk7XHJcblxyXG4gICAgICAvKiBlbCB6b29tIGV4dHJhIHZhIHBvciAtLXpvb20gKE5PIHBvciBzZmluYWwpICovXHJcbiAgICAgIC0tem9vbTogMTtcclxuICAgICAgLS1iZ3pvb206IDE7XHJcblxyXG4gICAgICAvKiBmYWN0b3IgZmluYWwgcGFyYSBDT05URU5JRE8gKHNlIHNldGVhIHBvciBKUykgKi9cclxuICAgICAgLS1zZmluYWw6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJmaWpvXCJde1xyXG4gICAgICAvKiBhbHR1cmEgZmlqYSBlc2NhbGFkYSBwb3IgYW5jaG87IEpTIHNldGVhIC0tc2ZpbmFsID0gc3ggKi9cclxuICAgICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNmaW5hbCkgKiB2YXIoLS1oYmFzZSkgKiAxcHgpO1xyXG4gICAgICAtLXpvb206IDE7XHJcbiAgICAgIC0tYmd6b29tOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEZvbmRvICovXHJcbiAgICAuc2VjLWJne1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIGluc2V0OiAwO1xyXG4gICAgICB6LWluZGV4OiAwO1xyXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgRm9uZG8gYWdyYW5kYWJsZSBzb2xvIGVuIHBhbnRhbGxhIChhY29tcGHDsWEgZWwgem9vbSBoZXJvKSAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWJne1xyXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWJnem9vbSwgMSkpO1xyXG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLnNlYy1ibGVlZHtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICBpbnNldDogMDtcclxuICAgICAgei1pbmRleDogMjtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5zZWMtY29udGVudHtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICB6LWluZGV4OiAzO1xyXG4gICAgICB3aWR0aDogdmFyKC0tY29udGVudC13KTtcclxuICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiBlbCBhbmNobyBkZWwg4oCcY29udGVudOKAnSBwdWVkZSBjcmVjZXIgY29uIGxhIGVzY2FsYSB2ZXJ0aWNhbCAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWNvbnRlbnR7XHJcbiAgICAgIHdpZHRoOiB2YXIoLS1jb250ZW50LXctcGFudGFsbGEsIHZhcigtLWNvbnRlbnQtdykpO1xyXG4gICAgfVxyXG5cclxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCl7XHJcbiAgICAgIC5zZWMtY29udGVudHtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNhZmUtbGVmdCk7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2FmZS1yaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAub2JqZXRve1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0by5pcy1pbnRlcmFjdGl2ZXsgcG9pbnRlci1ldmVudHM6IGF1dG87IH1cclxuXHJcbiAgICAuY2QtY2hpcCB7IGJhY2tkcm9wLWZpbHRlcjogc2F0dXJhdGUoMS4xKTsgfVxyXG4gIDwvc3R5bGU+XHJcbjwvaGVhZD5cclxuXHJcbjxib2R5IGRhdGEtc2x1Zz1cIiR7ZXNjYXBlQXR0cihzbHVnUHVibGljYSl9XCI+XHJcbiAgPGRpdiBjbGFzcz1cImludlwiPlxyXG4gICAgJHtodG1sU2VjY2lvbmVzfVxyXG4gIDwvZGl2PlxyXG5cclxuICAke2JvdG9uUlNWUH1cclxuICAke21vZGFsUlNWUH1cclxuXHJcbiAgJHtzY3JpcHRDb3VudGRvd259XHJcblxyXG4gIDxzY3JpcHQ+XHJcbiAgICAoZnVuY3Rpb24oKXtcclxuICAgICAgZnVuY3Rpb24gY2xhbXAobiwgYSwgYil7IHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCBuKSk7IH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGUoKXtcclxuICAgICAgICB2YXIgdncgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIEJBU0VfVyA9IDgwMDsgLy8gPSBDQU5WQVNfQkFTRS5BTkNIT1xyXG5cclxuICAgICAgICAvLyBjb250ZW50VyAoc2luIHZ3LTMyKVxyXG4gICAgICAgIHZhciBjb250ZW50VyA9IE1hdGgubWluKEJBU0VfVywgdncpO1xyXG5cclxuICAgICAgICB2YXIgc3ggPSBjb250ZW50VyAvIEJBU0VfVztcclxuICAgICAgICB2YXIgYnggPSB2dyAvIEJBU0VfVztcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1jb250ZW50LXdcIiwgY29udGVudFcgKyBcInB4XCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tc3hcIiwgU3RyaW5nKHN4KSk7XHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1ieFwiLCBTdHJpbmcoYngpKTtcclxuXHJcbiAgICAgICAgdmFyIHNlY3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VjXCIpKTtcclxuICAgICAgICB2YXIgaXNNb2JpbGUgPSB2dyA8PSA3Njc7XHJcblxyXG4gICAgICAgIC8vIHZpZXdwb3J0IHJlYWwgKG3DoXMgZXN0YWJsZSBlbiBtb2JpbGUpXHJcbiAgICAgICAgdmFyIHZ2ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0O1xyXG4gICAgICAgIHZhciB2aWV3cG9ydEggPSAodnYgJiYgdnYuaGVpZ2h0KSA/IHZ2LmhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gc2FmZSBhcmVhcyAoY3NzIGVudilcclxuICAgICAgICB2YXIgc2FmZVRvcCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCItLXNhZmUtdG9wXCIpKSB8fCAwO1xyXG4gICAgICAgIHZhciBzYWZlQm90dG9tID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tc2FmZS1ib3R0b21cIikpIHx8IDA7XHJcblxyXG4gICAgICAgIC8vIGRpc2XDsW8gYmFzZSBkZWwgbW9kbyBcInBhbnRhbGxhXCIgKDgwMCB4IDUwMClcclxuICAgICAgICB2YXIgREVTSUdOX1cgPSBCQVNFX1c7XHJcbiAgICAgICAgdmFyIERFU0lHTl9IID0gJHtBTFRVUkFfUkVGRVJFTkNJQV9QQU5UQUxMQX07IC8vID0gQUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEFcclxuICAgICAgICB2YXIgZGVzaWduQVIgPSBERVNJR05fSCAvIERFU0lHTl9XOyAvLyAwLjYyNVxyXG4gICAgICAgIHZhciBkZXZpY2VBUiA9IHZpZXdwb3J0SCAvIHZ3O1xyXG5cclxuICAgICAgICAvLyB6b29tIGV4dHJhIChzb2xvIHNpIGVsIGRldmljZSBlcyBtw6FzIHZlcnRpY2FsIHF1ZSBlbCBkaXNlw7FvKVxyXG4gICAgICAgIHZhciB6b29tRXh0cmEgPSAxO1xyXG4gICAgICAgIGlmIChpc01vYmlsZSAmJiBkZXZpY2VBUiA+IGRlc2lnbkFSKXtcclxuICAgICAgICAgIHZhciBrID0gZGV2aWNlQVIgLyBkZXNpZ25BUjtcclxuICAgICAgICAgIHpvb21FeHRyYSA9IGNsYW1wKDEgKyAoayAtIDEpICogMC4xOCwgMSwgMS4zNSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDwn5SnIEFqdXN0ZSBmaW5vOiBjdcOhbnRvIGFjb21wYcOxYSBlbCBmb25kbyBhbCB6b29tIGhlcm8gKDAuLjEuMilcclxuICAgICAgICAvLyAwICAgPT4gZWwgZm9uZG8gTk8gYWdyZWdhIHpvb20gZXh0cmEgcHJvcGlvIChzb2xvIGVsIHpvb20gZGVsIHdyYXBwZXIpXHJcbiAgICAgICAgLy8gMSAgID0+IGNvbXBvcnRhbWllbnRvIGFjdHVhbCAoZm9uZG8gcXVlZGEgem9vbUV4dHJhwrIpXHJcbiAgICAgICAgLy8gMC4zID0+IHJlY29tZW5kYWRvIHBhcmEgZW1wZXphciAoc3V0aWwpXHJcbiAgICAgICAgdmFyIEJHX1pPT01fRkFDVE9SID0gMDtcclxuXHJcbiAgICAgICAgLy8g8J+UpyBBanVzdGUgZmlubzogY3XDoW50byBhY29tcGHDsWEgZWwgQ09OVEVOSURPICh0ZXh0by9vYmpldG9zKSBhbCB6b29tIGhlcm9cclxuICAgICAgICAvLyAwICAgPT4gY29tcG9ydGFtaWVudG8gYWN0dWFsXHJcbiAgICAgICAgLy8gMC4zID0+IHJlY29tZW5kYWRvXHJcbiAgICAgICAgLy8gMSAgID0+IHRleHRvIGVzY2FsYSBpZ3VhbCBxdWUgZWwgaGVybyAobm8gYWNvbnNlamFkbylcclxuICAgICAgICB2YXIgVEVYVF9aT09NX0ZBQ1RPUiA9IDA7XHJcblxyXG5cclxuICAgICAgICBzZWNzLmZvckVhY2goZnVuY3Rpb24oc2VjKXtcclxuICAgICAgICAgIHZhciBtb2RvID0gKHNlYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZG9cIikgfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgLy8gZGVmYXVsdHNcclxuICAgICAgICAgIHZhciB6b29tID0gMTtcclxuICAgICAgICAgIHZhciBiZ3pvb20gPSAxO1xyXG5cclxuICAgICAgICAgIC8vIOKchSBQb3IgZGVmZWN0bywgdGFtYcOxb3MgZXNjYWxhbiBwb3IgYW5jaG8gKGNvbXBvcnRhbWllbnRvIGFjdHVhbClcclxuICAgICAgICAgIHZhciBzZmluYWwgPSBzeDtcclxuXHJcbiAgICAgICAgICAvLyBsaW1waWFyIGN1c3RvbSB3aWR0aCBzaSBubyBhcGxpY2FcclxuICAgICAgICAgIHNlYy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIi0tY29udGVudC13LXBhbnRhbGxhXCIpO1xyXG5cclxuICAgICAgICAgIGlmIChtb2RvID09PSBcInBhbnRhbGxhXCIpe1xyXG4gICAgICAgICAgICAvLyB2aC1zYWZlIHJlYWwgZW4gcHhcclxuICAgICAgICAgICAgdmFyIHZoU2FmZVB4ID0gTWF0aC5tYXgoMCwgdmlld3BvcnRIIC0gc2FmZVRvcCAtIHNhZmVCb3R0b20pO1xyXG4gICAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXZoLXNhZmVcIiwgdmhTYWZlUHggKyBcInB4XCIpO1xyXG5cclxuICAgICAgICAgICAgLy8g8J+UpSBEZXNrdG9wOiBlc2NhbGFyIGVsIGNvbnRlbmlkbyBwb3IgQUxUVVJBICh2aFNhZmUvNTAwKVxyXG4gICAgICAgICAgICAvLyBFc3RvIGFsaW5lYSBlbCBIVE1MIHB1YmxpY2FkbyBjb24gbG8gcXVlIHZlcyBlbiBwcmV2aWV3XHJcbiAgICAgICAgICAgIGlmICghaXNNb2JpbGUpe1xyXG4gICAgICAgICAgICAgIHZhciBzaCA9IHZoU2FmZVB4IC8gREVTSUdOX0g7XHJcbiAgICAgICAgICAgICAgc2ZpbmFsID0gc2g7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHBhcmEgcXVlIGVsIFwiY29udGVudFwiIHF1ZWRlIGNlbnRyYWRvIHkgY29oZXJlbnRlIGNvbiBsYSBudWV2YSBlc2NhbGEgdmVydGljYWxcclxuICAgICAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLWNvbnRlbnQtdy1wYW50YWxsYVwiLCAoREVTSUdOX1cgKiBzaCkgKyBcInB4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgTW9iaWxlOiBtYW50ZW5lbW9zIHR1IGNvbXBvcnRhbWllbnRvIGFjdHVhbCAoem9vbSBoZXJvIHN1YXZlKVxyXG4gICAgICAgICAgICBpZiAoaXNNb2JpbGUpe1xyXG4gICAgICAgICAgICAgIHpvb20gPSB6b29tRXh0cmE7XHJcbiAgICAgICAgICAgICAgYmd6b29tID0gMSArICh6b29tRXh0cmEgLSAxKSAqIEJHX1pPT01fRkFDVE9SO1xyXG5cclxuICAgICAgICAgICAgICAvLyDwn5SlIE5VRVZPOiBlbCBjb250ZW5pZG8gYWNvbXBhw7FhIHBhcmNpYWxtZW50ZSBlbCB6b29tXHJcbiAgICAgICAgICAgICAgc2ZpbmFsID0gc3ggKiAoMSArICh6b29tRXh0cmEgLSAxKSAqIFRFWFRfWk9PTV9GQUNUT1IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1zZmluYWxcIiwgU3RyaW5nKHNmaW5hbCkpO1xyXG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS16b29tXCIsIFN0cmluZyh6b29tKSk7XHJcbiAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLWJnem9vbVwiLCBTdHJpbmcoYmd6b29tKSk7XHJcblxyXG4gICAgICAgICAgLy8g4pyFIFNvbG8gZW4gbW9iaWxlICsgcGFudGFsbGE6IGNvcnJlZ2lyIGVsIFwidmhcIiBxdWUgZGVzcHXDqXMgc2UgZXNjYWxhIGNvbiB6b29tXHJcbiAgICAgICAgICBpZiAoaXNNb2JpbGUgJiYgbW9kbyA9PT0gXCJwYW50YWxsYVwiKSB7XHJcbiAgICAgICAgICAgIC8vIC0tdmgtbG9naWNhbCA9IC0tdmgtc2FmZSAvIC0tem9vbVxyXG4gICAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXZoLWxvZ2ljYWxcIiwgXCJjYWxjKHZhcigtLXZoLXNhZmUpIC8gdmFyKC0tem9vbSkpXCIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVzdG86IHNlIGNvbXBvcnRhIGNvbW8gc2llbXByZVxyXG4gICAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXZoLWxvZ2ljYWxcIiwgXCJ2YXIoLS12aC1zYWZlKVwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcHV0ZSk7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNvbXB1dGUpO1xyXG5cclxuICAgICAgaWYgKHdpbmRvdy52aXN1YWxWaWV3cG9ydCl7XHJcbiAgICAgICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY29tcHV0ZSk7XHJcbiAgICAgICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgY29tcHV0ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZnVuY3Rpb24oKXtcclxuICAgICAgICBzZXRUaW1lb3V0KGNvbXB1dGUsIDUwKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGNvbXB1dGUsIDI1MCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29tcHV0ZSgpO1xyXG4gICAgfSkoKTtcclxuICA8L3NjcmlwdD5cclxuXHJcbiAgICBcclxuXHJcblxyXG4gICAke3NjcmlwdE1vYmlsZVNtYXJ0fVxyXG4gXHJcbjwvYm9keT5cclxuPC9odG1sPlxyXG5gO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJnZW5lcmFySFRNTERlc2RlT2JqZXRvcyIsIkNBTlZBU19CQVNFIiwiZ2VuZXJhck1vZGFsUlNWUEhUTUwiLCJidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCIsIkVOQUJMRV9NT0JJTEVfU01BUlRfTEFZT1VUIiwiRVhDTFVERV9GT05UUyIsIlNldCIsIkFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBIiwiUEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWCIsIlBBTlRBTExBX1lfT0ZGU0VUX01PQklMRV9QWCIsImJ1aWxkR29vZ2xlRm9udHNMaW5rIiwiZm9udHMiLCJmYW1pbGlhcyIsIm1hcCIsImYiLCJyZXBsYWNlIiwic3BsaXQiLCJ0cmltIiwiZmlsdGVyIiwibiIsImhhcyIsImpvaW4iLCJlc2NhcGVBdHRyIiwic3RyIiwiU3RyaW5nIiwiYnVpbGRGb25kb1N0eWxlIiwic2VjY2lvbiIsImZvbmRvVmFsdWUiLCJmb25kbyIsImVzSW1hZ2VuRm9uZG8iLCJmb25kb1RpcG8iLCJmb25kb0ltYWdlbiIsImVzdGlsb3NGb25kbyIsImltYWdlVXJsIiwiaW5jbHVkZXMiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJmb25kb0ltYWdlbk9mZnNldFgiLCJ1bmRlZmluZWQiLCJmb25kb0ltYWdlbk9mZnNldFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm9mZnNldFhQZXJjZW50Iiwib2Zmc2V0WVBlcmNlbnQiLCJzdGFydHNXaXRoIiwiZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcyIsInNlY2Npb25lcyIsIm9iamV0b3MiLCJyc3ZwIiwib3BjaW9uZXMiLCJvcHRzIiwic2x1ZyIsInNsdWdQdWJsaWNhIiwiZnVlbnRlc1VzYWRhcyIsIm8iLCJ0aXBvIiwiZm9udEZhbWlseSIsImdvb2dsZUZvbnRzTGluayIsImhheVJTVlBFbkNhbnZhcyIsInNvbWUiLCJib3RvblJTVlAiLCJtb2RhbFJTVlAiLCJlbmFibGVkIiwiaGF5Q291bnRkb3duIiwib2JqcyIsIkFycmF5IiwiaXNBcnJheSIsInNjcmlwdENvdW50ZG93biIsInNlY2Npb25lc09yZGVuYWRhcyIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm9yZGVuIiwiaHRtbFNlY2Npb25lcyIsIm1vZG8iLCJhbHRvTW9kbyIsInRvTG93ZXJDYXNlIiwiaGJhc2UiLCJpc0Zpbml0ZSIsImFsdHVyYSIsIm9ianNEZVNlY2Npb24iLCJzZWNjaW9uSWQiLCJpZCIsIm9ianNCbGVlZCIsImFuY2xhamUiLCJvYmpzQ29udGVuaWRvIiwiZm9uZG9TdHlsZSIsImh0bWxCbGVlZCIsImh0bWxDb250ZW5pZG8iLCJzY3JpcHRNb2JpbGVTbWFydCIsIm1pbkdhcFB4IiwicGFkZGluZ1RvcFB4IiwicGFkZGluZ0JvdHRvbVB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJtaW5QZXJDb2x1bW4yIiwiZml0TWluU2NhbGUiLCJmaXRNYXhTY2FsZSIsImZpdFRhcmdldFdpZHRoUmF0aW8iLCJmaXRNaW5GaWxsUmF0aW8iLCJBTkNITyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarHTMLDesdeSecciones.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts":
/*!*************************************************!*\
  !*** ./functions/src/utils/generarModalRSVP.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalRSVPHTML: () => (/* binding */ generarModalRSVPHTML)\n/* harmony export */ });\n// functions/src/utils/generarModalRSVP.ts\nfunction generarModalRSVPHTML(cfg) {\n    if (!cfg?.enabled) return \"\";\n    const title = cfg.title ?? \"Confirmar asistencia\";\n    const subtitle = cfg.subtitle ?? \"\";\n    const btnText = cfg.buttonText ?? \"Enviar\";\n    const color = cfg.primaryColor ?? \"#773dbe\";\n    // Nota: el botón que abre el modal debe tener [data-rsvp-open]\n    // (el listener de abajo lo busca)\n    return `\n<div id=\"modal-rsvp\" style=\"\n  position: fixed; inset: 0; display:none;\n  background: rgba(0,0,0,.6); z-index: 9999;\n  align-items: center; justify-content: center;\">\n  <div style=\"\n    background: #fff; width: 90%; max-width: 420px; border-radius: 10px;\n    padding: 20px; font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,.2);\">\n    <div style=\"display:flex; justify-content: space-between; align-items:center;\">\n      <h2 style=\"margin:0; font-size:20px;\">${title}</h2>\n      <button id=\"rsvp-close\" aria-label=\"Cerrar\" style=\"border:none; background:transparent; font-size:18px; cursor:pointer;\">✕</button>\n    </div>\n    ${subtitle ? `<p style=\"margin:8px 0 16px; color:#555;\">${subtitle}</p>` : \"\"}\n\n    <div style=\"display:flex; flex-direction:column; gap:10px;\">\n      <input id=\"rsvp-nombre\" placeholder=\"Tu nombre\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\n      <input id=\"rsvp-mensaje\" placeholder=\"Mensaje (opcional)\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\n    </div>\n\n     <!-- ✅ NUEVO: selector Sí/No con estilo segmentado -->\n    <div style=\"margin-top:12px;\">\n      <label style=\"display:block; font-weight:600; margin-bottom:8px;\">¿Confirmás asistencia?</label>\n      <div id=\"rsvp-confirma\" style=\"\n        display:inline-flex; gap:0; border:1px solid #ddd; border-radius:10px; overflow:hidden;\n        box-shadow: inset 0 1px 0 rgba(0,0,0,0.03);\n      \">\n        <button type=\"button\" data-confirma=\"si\" aria-pressed=\"true\" style=\"\n          padding:10px 14px; border:none; background:${color}; color:#fff; font-weight:600; cursor:pointer;\n        \">Sí, voy</button>\n        <button type=\"button\" data-confirma=\"no\" aria-pressed=\"false\" style=\"\n          padding:10px 14px; border:none; background:#f6f6f6; color:#444; cursor:pointer;\n        \">No puedo</button>\n      </div>\n    </div>\n\n    <div style=\"display:flex; justify-content:flex-end; gap:10px; margin-top:16px;\">\n      <button id=\"rsvp-cancel\" style=\"padding:8px 12px; border-radius:6px; border:1px solid #ddd; background:#f3f3f3; cursor:pointer;\">Cancelar</button>\n      <button id=\"rsvp-send\" style=\"padding:8px 12px; border-radius:6px; border:none; color:#fff; cursor:pointer; background:${color};\">${btnText}</button>\n    </div>\n  </div>\n</div>\n\n<script>\ndocument.addEventListener('DOMContentLoaded', function () {\n\nfunction getSlugDePagina() {\n  // 0) Log de ayuda\n  try { console.log(\"[RSVP] href:\", location.href); } catch (e) {}\n\n  // 1) <html data-slug=\"...\"> (si lo inyectás en el HTML final)\n  const ds = document.documentElement?.dataset?.slug;\n  if (ds) {\n    console.log(\"[RSVP] slug por data-atributo:\", ds);\n    return ds;\n  }\n\n  // 2) ?slug=... en la URL\n  const q = new URLSearchParams(location.search).get(\"slug\");\n  if (q) {\n    console.log(\"[RSVP] slug por querystring:\", q);\n    return q;\n  }\n\n  // 3) /publicadas/<slug>/... en un sitio estático (Hosting/Proxy)\n  const parts = location.pathname.split(\"/\").filter(Boolean);\n  const i = parts.indexOf(\"publicadas\");\n  if (i >= 0 && parts[i + 1]) {\n    console.log(\"[RSVP] slug por pathname directo:\", parts[i + 1]);\n    return parts[i + 1];\n  }\n\n  // 4) URL de Firebase Storage:\n  //    https://firebasestorage.googleapis.com/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media&token=...\n  //    https://<bucket>.firebasestorage.app/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media\n  try {\n    const pathAfterO = location.pathname.split(\"/o/\")[1]; // \"publicadas%2F<slug>%2Findex.html\"\n    if (pathAfterO) {\n      const decoded = decodeURIComponent(pathAfterO);      // \"publicadas/<slug>/index.html\"\n      const segs = decoded.split(\"/\").filter(Boolean);\n      const j = segs.indexOf(\"publicadas\");\n      if (j >= 0 && segs[j + 1]) {\n        console.log(\"[RSVP] slug por URL de Storage:\", segs[j + 1]);\n        return segs[j + 1];\n      }\n    }\n  } catch (e) {\n    console.warn(\"[RSVP] Error parseando URL de Storage:\", e);\n  }\n\n  console.warn(\"[RSVP] No se pudo detectar slug. Fallback: sin-slug\");\n  return \"sin-slug\";\n}\n\n\n  var modal = document.getElementById('modal-rsvp');\n  if (!modal) return;\n\n  function openModal() { \n  modal.style.display = 'flex'; \n  // 🔁 Reset visual y estado cada vez que se abre\n  setConfirmaUI(\"si\", ${JSON.stringify(color)});\n}\n\n  function closeModal() { modal.style.display = 'none'; }\n\n  // Botones internos\n  var closeBtn = document.getElementById('rsvp-close');\n  var cancelBtn = document.getElementById('rsvp-cancel');\n  var sendBtn = document.getElementById('rsvp-send');\n\n  if (closeBtn) closeBtn.addEventListener('click', closeModal);\n  if (cancelBtn) cancelBtn.addEventListener('click', closeModal);\n\n  // Click fuera del cuadro\n  modal.addEventListener('click', function(e) {\n    if (e.target === modal) closeModal();\n  });\n\n  // Abridores: cualquier elemento con data-rsvp-open\ndocument.querySelectorAll('[data-rsvp-open], [data-accion=\"abrir-rsvp\"], .rsvp-boton').forEach(function(el) {\n    el.addEventListener('click', function(e) {\n      e.preventDefault();\n      openModal();\n    });\n  });\n\n\n// Estado interno del selector Sí/No\nvar confirmaValor = \"si\"; // default\n\nfunction setConfirmaUI(valor, color) {\n  var cont = document.getElementById('rsvp-confirma');\n  if (!cont) return;\n  var btnSi = cont.querySelector('[data-confirma=\"si\"]');\n  var btnNo = cont.querySelector('[data-confirma=\"no\"]');\n  confirmaValor = (valor === \"no\") ? \"no\" : \"si\";\n\n  if (btnSi && btnNo) {\n    if (confirmaValor === \"si\") {\n      btnSi.style.background = color;\n      btnSi.style.color = \"#fff\";\n      btnSi.setAttribute(\"aria-pressed\", \"true\");\n\n      btnNo.style.background = \"#f6f6f6\";\n      btnNo.style.color = \"#444\";\n      btnNo.setAttribute(\"aria-pressed\", \"false\");\n    } else {\n      btnNo.style.background = color;\n      btnNo.style.color = \"#fff\";\n      btnNo.setAttribute(\"aria-pressed\", \"true\");\n\n      btnSi.style.background = \"#f6f6f6\";\n      btnSi.style.color = \"#444\";\n      btnSi.setAttribute(\"aria-pressed\", \"false\");\n    }\n  }\n}\n\n// 🔹 Dejar \"Sí\" seleccionado al cargar\nsetConfirmaUI(\"si\", ${JSON.stringify(color)});\n\n// 🔹 Alternar selección al click\nvar confirmaWrap = document.getElementById('rsvp-confirma');\nif (confirmaWrap) {\n  confirmaWrap.addEventListener('click', function(e) {\n    var btn = e.target.closest('[data-confirma]');\n    if (!btn) return;\n    var v = btn.getAttribute('data-confirma');\n    setConfirmaUI(v, ${JSON.stringify(color)});\n    try { console.log(\"[RSVP] cambia confirmaValor =\", v); } catch(_) {}\n  });\n}\n\n\n\n  // ✅ Envío con Firestore + logs\nif (sendBtn) {\n  sendBtn.addEventListener('click', function() {\n    var nombre = (document.getElementById('rsvp-nombre') || {}).value || '';\n    var mensaje = (document.getElementById('rsvp-mensaje') || {}).value || '';\n\n    if (!nombre.trim()) {\n      alert('Por favor ingresá tu nombre.');\n      return;\n    }\n\n    const confirma = (confirmaValor === \"si\"); \n    const slug = getSlugDePagina();\n    console.log(\"[RSVP] Enviando RSVP… slug =\", slug);\n\n    // (opcional) si seguís usando sheetUrl, mantenemos el POST “en paralelo”\n    var sheetUrl = ${JSON.stringify(cfg.sheetUrl || \"\")};\n    if (sheetUrl) {\n      try {\n        fetch(sheetUrl, {\n          method: 'POST',\n          headers: {'Content-Type':'application/json'},\n          body: JSON.stringify({\n            nombre: nombre.trim(),\n            mensaje: mensaje.trim(),\n            slug: slug,\n            ts: Date.now()\n          })\n        }).catch(function(e){ console.warn(\"[RSVP] sheetUrl error:\", e); });\n      } catch (e) {\n        console.warn(\"[RSVP] sheetUrl throw:\", e);\n      }\n    }\n\n    // 🔌 Importar Firebase dinámicamente y guardar en Firestore\n    Promise.all([\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js\"),\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js\"),\n    ])\n    .then(([appMod, fsMod]) => {\n      const { initializeApp } = appMod;\n      const { getFirestore, collection, addDoc, serverTimestamp } = fsMod;\n\n      // ⚙️ Config mínima (apiKey y projectId son suficientes para el cliente)\n      const firebaseConfig = {\n        apiKey: \"AIzaSyALCvU48_HRp26cXpQcTX5S33Adpwfl3z4\",\n        authDomain: \"reservaeldia-7a440.firebaseapp.com\",\n        projectId: \"reservaeldia-7a440\",\n        appId: \"1:860495975406:web:3a49ad0cf55d60313534ff\"\n      };\n\n      const app = initializeApp(firebaseConfig);\n      const db  = getFirestore(app);\n\n      const payload = {\n        nombre: nombre.trim(),\n        mensaje: (mensaje && mensaje.trim()) || null,\n        confirma,\n        createdAt: serverTimestamp(),\n        userAgent: navigator.userAgent.slice(0, 512)\n      };\n\n      console.log(\"[RSVP] Payload keys =\", Object.keys(payload));\n      console.log(\"[RSVP] Payload =\", JSON.stringify(payload));\n\n      return addDoc(collection(db, \"publicadas\", slug, \"rsvps\"), payload);\n    })\n    .then((docRef) => {\n      console.log(\"[RSVP] RSVP guardado con ID:\", docRef.id, \"en /publicadas/\"+slug+\"/rsvps\");\n      alert('¡Gracias por confirmar tu asistencia, ' + nombre + '!');\n      closeModal();\n    })\n    .catch((err) => {\n      console.error(\"[RSVP] Error guardando en Firestore:\", err);\n      alert('Hubo un error al guardar tu confirmación. Probá de nuevo.');\n    });\n  });\n}\n \n  \n\n});\n</script>\n`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsUlNWUC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMENBQTBDO0FBV25DLFNBQVNBLHFCQUFxQkMsR0FBZTtJQUNoRCxJQUFJLENBQUNBLEtBQUtDLFNBQVMsT0FBTztJQUUxQixNQUFNQyxRQUFRRixJQUFJRSxLQUFLLElBQUk7SUFDM0IsTUFBTUMsV0FBV0gsSUFBSUcsUUFBUSxJQUFJO0lBQ2pDLE1BQU1DLFVBQVVKLElBQUlLLFVBQVUsSUFBSTtJQUNsQyxNQUFNQyxRQUFRTixJQUFJTyxZQUFZLElBQUk7SUFFbEMsK0RBQStEO0lBQy9ELGtDQUFrQztJQUNsQyxPQUFPLENBQUM7Ozs7Ozs7Ozs0Q0FTZ0MsRUFBRUwsTUFBTTs7O0lBR2hELEVBQUVDLFdBQVcsQ0FBQywwQ0FBMEMsRUFBRUEsU0FBUyxJQUFJLENBQUMsR0FBRyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7cURBZTdCLEVBQUVHLE1BQU07Ozs7Ozs7Ozs7NkhBVWdFLEVBQUVBLE1BQU0sR0FBRyxFQUFFRixRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBK0Q1SCxFQUFFSSxLQUFLQyxTQUFTLENBQUNILE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTJEMUIsRUFBRUUsS0FBS0MsU0FBUyxDQUFDSCxPQUFPOzs7Ozs7Ozs7cUJBU3ZCLEVBQUVFLEtBQUtDLFNBQVMsQ0FBQ0gsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBdUIxQixFQUFFRSxLQUFLQyxTQUFTLENBQUNULElBQUlVLFFBQVEsSUFBSSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUV4RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vZGFsUlNWUC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL2dlbmVyYXJNb2RhbFJTVlAudHNcclxuXHJcbmV4cG9ydCB0eXBlIFJTVlBDb25maWcgPSB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG4gICAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgICBzdWJ0aXRsZT86IHN0cmluZztcclxuICAgIGJ1dHRvblRleHQ/OiBzdHJpbmc7XHJcbiAgICBwcmltYXJ5Q29sb3I/OiBzdHJpbmc7IC8vIGNvbG9yIGRlbCBib3TDs24vY2FiZWNlcmFcclxuICAgIHNoZWV0VXJsPzogc3RyaW5nOyAgICAgLy8gb3BjaW9uYWwgc2kgdmFzIGEgZW52aWFyIGEgR29vZ2xlIFNoZWV0cyBvIHNpbWlsYXJcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxSU1ZQSFRNTChjZmc6IFJTVlBDb25maWcpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFjZmc/LmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gY2ZnLnRpdGxlID8/IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIjtcclxuICAgIGNvbnN0IHN1YnRpdGxlID0gY2ZnLnN1YnRpdGxlID8/IFwiXCI7XHJcbiAgICBjb25zdCBidG5UZXh0ID0gY2ZnLmJ1dHRvblRleHQgPz8gXCJFbnZpYXJcIjtcclxuICAgIGNvbnN0IGNvbG9yID0gY2ZnLnByaW1hcnlDb2xvciA/PyBcIiM3NzNkYmVcIjtcclxuXHJcbiAgICAvLyBOb3RhOiBlbCBib3TDs24gcXVlIGFicmUgZWwgbW9kYWwgZGViZSB0ZW5lciBbZGF0YS1yc3ZwLW9wZW5dXHJcbiAgICAvLyAoZWwgbGlzdGVuZXIgZGUgYWJham8gbG8gYnVzY2EpXHJcbiAgICByZXR1cm4gYFxyXG48ZGl2IGlkPVwibW9kYWwtcnN2cFwiIHN0eWxlPVwiXHJcbiAgcG9zaXRpb246IGZpeGVkOyBpbnNldDogMDsgZGlzcGxheTpub25lO1xyXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjYpOyB6LWluZGV4OiA5OTk5O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyO1wiPlxyXG4gIDxkaXYgc3R5bGU9XCJcclxuICAgIGJhY2tncm91bmQ6ICNmZmY7IHdpZHRoOiA5MCU7IG1heC13aWR0aDogNDIwcHg7IGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICBwYWRkaW5nOiAyMHB4OyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgYm94LXNoYWRvdzogMCAxMHB4IDMwcHggcmdiYSgwLDAsMCwuMik7XCI+XHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOmNlbnRlcjtcIj5cclxuICAgICAgPGgyIHN0eWxlPVwibWFyZ2luOjA7IGZvbnQtc2l6ZToyMHB4O1wiPiR7dGl0bGV9PC9oMj5cclxuICAgICAgPGJ1dHRvbiBpZD1cInJzdnAtY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2VycmFyXCIgc3R5bGU9XCJib3JkZXI6bm9uZTsgYmFja2dyb3VuZDp0cmFuc3BhcmVudDsgZm9udC1zaXplOjE4cHg7IGN1cnNvcjpwb2ludGVyO1wiPuKclTwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICAke3N1YnRpdGxlID8gYDxwIHN0eWxlPVwibWFyZ2luOjhweCAwIDE2cHg7IGNvbG9yOiM1NTU7XCI+JHtzdWJ0aXRsZX08L3A+YCA6IFwiXCJ9XHJcblxyXG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDtcIj5cclxuICAgICAgPGlucHV0IGlkPVwicnN2cC1ub21icmVcIiBwbGFjZWhvbGRlcj1cIlR1IG5vbWJyZVwiIHN0eWxlPVwicGFkZGluZzoxMHB4OyBib3JkZXI6MXB4IHNvbGlkICNjY2M7IGJvcmRlci1yYWRpdXM6NnB4O1wiIC8+XHJcbiAgICAgIDxpbnB1dCBpZD1cInJzdnAtbWVuc2FqZVwiIHBsYWNlaG9sZGVyPVwiTWVuc2FqZSAob3BjaW9uYWwpXCIgc3R5bGU9XCJwYWRkaW5nOjEwcHg7IGJvcmRlcjoxcHggc29saWQgI2NjYzsgYm9yZGVyLXJhZGl1czo2cHg7XCIgLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgICA8IS0tIOKchSBOVUVWTzogc2VsZWN0b3IgU8OtL05vIGNvbiBlc3RpbG8gc2VnbWVudGFkbyAtLT5cclxuICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tdG9wOjEycHg7XCI+XHJcbiAgICAgIDxsYWJlbCBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IGZvbnQtd2VpZ2h0OjYwMDsgbWFyZ2luLWJvdHRvbTo4cHg7XCI+wr9Db25maXJtw6FzIGFzaXN0ZW5jaWE/PC9sYWJlbD5cclxuICAgICAgPGRpdiBpZD1cInJzdnAtY29uZmlybWFcIiBzdHlsZT1cIlxyXG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWZsZXg7IGdhcDowOyBib3JkZXI6MXB4IHNvbGlkICNkZGQ7IGJvcmRlci1yYWRpdXM6MTBweDsgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgwLDAsMCwwLjAzKTtcclxuICAgICAgXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1jb25maXJtYT1cInNpXCIgYXJpYS1wcmVzc2VkPVwidHJ1ZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6JHtjb2xvcn07IGNvbG9yOiNmZmY7IGZvbnQtd2VpZ2h0OjYwMDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+U8OtLCB2b3k8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWNvbmZpcm1hPVwibm9cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6I2Y2ZjZmNjsgY29sb3I6IzQ0NDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+Tm8gcHVlZG88L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7IGdhcDoxMHB4OyBtYXJnaW4tdG9wOjE2cHg7XCI+XHJcbiAgICAgIDxidXR0b24gaWQ9XCJyc3ZwLWNhbmNlbFwiIHN0eWxlPVwicGFkZGluZzo4cHggMTJweDsgYm9yZGVyLXJhZGl1czo2cHg7IGJvcmRlcjoxcHggc29saWQgI2RkZDsgYmFja2dyb3VuZDojZjNmM2YzOyBjdXJzb3I6cG9pbnRlcjtcIj5DYW5jZWxhcjwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGlkPVwicnN2cC1zZW5kXCIgc3R5bGU9XCJwYWRkaW5nOjhweCAxMnB4OyBib3JkZXItcmFkaXVzOjZweDsgYm9yZGVyOm5vbmU7IGNvbG9yOiNmZmY7IGN1cnNvcjpwb2ludGVyOyBiYWNrZ3JvdW5kOiR7Y29sb3J9O1wiPiR7YnRuVGV4dH08L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5mdW5jdGlvbiBnZXRTbHVnRGVQYWdpbmEoKSB7XHJcbiAgLy8gMCkgTG9nIGRlIGF5dWRhXHJcbiAgdHJ5IHsgY29uc29sZS5sb2coXCJbUlNWUF0gaHJlZjpcIiwgbG9jYXRpb24uaHJlZik7IH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIC8vIDEpIDxodG1sIGRhdGEtc2x1Zz1cIi4uLlwiPiAoc2kgbG8gaW55ZWN0w6FzIGVuIGVsIEhUTUwgZmluYWwpXHJcbiAgY29uc3QgZHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/LmRhdGFzZXQ/LnNsdWc7XHJcbiAgaWYgKGRzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBkYXRhLWF0cmlidXRvOlwiLCBkcyk7XHJcbiAgICByZXR1cm4gZHM7XHJcbiAgfVxyXG5cclxuICAvLyAyKSA/c2x1Zz0uLi4gZW4gbGEgVVJMXHJcbiAgY29uc3QgcSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKS5nZXQoXCJzbHVnXCIpO1xyXG4gIGlmIChxKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBxdWVyeXN0cmluZzpcIiwgcSk7XHJcbiAgICByZXR1cm4gcTtcclxuICB9XHJcblxyXG4gIC8vIDMpIC9wdWJsaWNhZGFzLzxzbHVnPi8uLi4gZW4gdW4gc2l0aW8gZXN0w6F0aWNvIChIb3N0aW5nL1Byb3h5KVxyXG4gIGNvbnN0IHBhcnRzID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcclxuICBjb25zdCBpID0gcGFydHMuaW5kZXhPZihcInB1YmxpY2FkYXNcIik7XHJcbiAgaWYgKGkgPj0gMCAmJiBwYXJ0c1tpICsgMV0pIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIHBhdGhuYW1lIGRpcmVjdG86XCIsIHBhcnRzW2kgKyAxXSk7XHJcbiAgICByZXR1cm4gcGFydHNbaSArIDFdO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgVVJMIGRlIEZpcmViYXNlIFN0b3JhZ2U6XHJcbiAgLy8gICAgaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYSZ0b2tlbj0uLi5cclxuICAvLyAgICBodHRwczovLzxidWNrZXQ+LmZpcmViYXNlc3RvcmFnZS5hcHAvdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXRoQWZ0ZXJPID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvby9cIilbMV07IC8vIFwicHVibGljYWRhcyUyRjxzbHVnPiUyRmluZGV4Lmh0bWxcIlxyXG4gICAgaWYgKHBhdGhBZnRlck8pIHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXRoQWZ0ZXJPKTsgICAgICAvLyBcInB1YmxpY2FkYXMvPHNsdWc+L2luZGV4Lmh0bWxcIlxyXG4gICAgICBjb25zdCBzZWdzID0gZGVjb2RlZC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICBjb25zdCBqID0gc2Vncy5pbmRleE9mKFwicHVibGljYWRhc1wiKTtcclxuICAgICAgaWYgKGogPj0gMCAmJiBzZWdzW2ogKyAxXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIFVSTCBkZSBTdG9yYWdlOlwiLCBzZWdzW2ogKyAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiW1JTVlBdIEVycm9yIHBhcnNlYW5kbyBVUkwgZGUgU3RvcmFnZTpcIiwgZSk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLndhcm4oXCJbUlNWUF0gTm8gc2UgcHVkbyBkZXRlY3RhciBzbHVnLiBGYWxsYmFjazogc2luLXNsdWdcIik7XHJcbiAgcmV0dXJuIFwic2luLXNsdWdcIjtcclxufVxyXG5cclxuXHJcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsLXJzdnAnKTtcclxuICBpZiAoIW1vZGFsKSByZXR1cm47XHJcblxyXG4gIGZ1bmN0aW9uIG9wZW5Nb2RhbCgpIHsgXHJcbiAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgXHJcbiAgLy8g8J+UgSBSZXNldCB2aXN1YWwgeSBlc3RhZG8gY2FkYSB2ZXogcXVlIHNlIGFicmVcclxuICBzZXRDb25maXJtYVVJKFwic2lcIiwgJHtKU09OLnN0cmluZ2lmeShjb2xvcil9KTtcclxufVxyXG5cclxuICBmdW5jdGlvbiBjbG9zZU1vZGFsKCkgeyBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9XHJcblxyXG4gIC8vIEJvdG9uZXMgaW50ZXJub3NcclxuICB2YXIgY2xvc2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jbG9zZScpO1xyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jYW5jZWwnKTtcclxuICB2YXIgc2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLXNlbmQnKTtcclxuXHJcbiAgaWYgKGNsb3NlQnRuKSBjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG4gIGlmIChjYW5jZWxCdG4pIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG5cclxuICAvLyBDbGljayBmdWVyYSBkZWwgY3VhZHJvXHJcbiAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgPT09IG1vZGFsKSBjbG9zZU1vZGFsKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEFicmlkb3JlczogY3VhbHF1aWVyIGVsZW1lbnRvIGNvbiBkYXRhLXJzdnAtb3BlblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yc3ZwLW9wZW5dLCBbZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJdLCAucnN2cC1ib3RvbicpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIG9wZW5Nb2RhbCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG5cclxuLy8gRXN0YWRvIGludGVybm8gZGVsIHNlbGVjdG9yIFPDrS9Ob1xyXG52YXIgY29uZmlybWFWYWxvciA9IFwic2lcIjsgLy8gZGVmYXVsdFxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlybWFVSSh2YWxvciwgY29sb3IpIHtcclxuICB2YXIgY29udCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbiAgaWYgKCFjb250KSByZXR1cm47XHJcbiAgdmFyIGJ0blNpID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cInNpXCJdJyk7XHJcbiAgdmFyIGJ0bk5vID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cIm5vXCJdJyk7XHJcbiAgY29uZmlybWFWYWxvciA9ICh2YWxvciA9PT0gXCJub1wiKSA/IFwibm9cIiA6IFwic2lcIjtcclxuXHJcbiAgaWYgKGJ0blNpICYmIGJ0bk5vKSB7XHJcbiAgICBpZiAoY29uZmlybWFWYWxvciA9PT0gXCJzaVwiKSB7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcjtcclxuICAgICAgYnRuU2kuc3R5bGUuY29sb3IgPSBcIiNmZmZcIjtcclxuICAgICAgYnRuU2kuc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKTtcclxuXHJcbiAgICAgIGJ0bk5vLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgYnRuTm8uc3R5bGUuY29sb3IgPSBcIiM0NDRcIjtcclxuICAgICAgYnRuTm8uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidG5Oby5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3I7XHJcbiAgICAgIGJ0bk5vLnN0eWxlLmNvbG9yID0gXCIjZmZmXCI7XHJcbiAgICAgIGJ0bk5vLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XHJcblxyXG4gICAgICBidG5TaS5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZjZmNmY2XCI7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmNvbG9yID0gXCIjNDQ0XCI7XHJcbiAgICAgIGJ0blNpLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+UuSBEZWphciBcIlPDrVwiIHNlbGVjY2lvbmFkbyBhbCBjYXJnYXJcclxuc2V0Q29uZmlybWFVSShcInNpXCIsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcblxyXG4vLyDwn5S5IEFsdGVybmFyIHNlbGVjY2nDs24gYWwgY2xpY2tcclxudmFyIGNvbmZpcm1hV3JhcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbmlmIChjb25maXJtYVdyYXApIHtcclxuICBjb25maXJtYVdyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgYnRuID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtY29uZmlybWFdJyk7XHJcbiAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG4gICAgdmFyIHYgPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm1hJyk7XHJcbiAgICBzZXRDb25maXJtYVVJKHYsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcbiAgICB0cnkgeyBjb25zb2xlLmxvZyhcIltSU1ZQXSBjYW1iaWEgY29uZmlybWFWYWxvciA9XCIsIHYpOyB9IGNhdGNoKF8pIHt9XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICAvLyDinIUgRW52w61vIGNvbiBGaXJlc3RvcmUgKyBsb2dzXHJcbmlmIChzZW5kQnRuKSB7XHJcbiAgc2VuZEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5vbWJyZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1ub21icmUnKSB8fCB7fSkudmFsdWUgfHwgJyc7XHJcbiAgICB2YXIgbWVuc2FqZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1tZW5zYWplJykgfHwge30pLnZhbHVlIHx8ICcnO1xyXG5cclxuICAgIGlmICghbm9tYnJlLnRyaW0oKSkge1xyXG4gICAgICBhbGVydCgnUG9yIGZhdm9yIGluZ3Jlc8OhIHR1IG5vbWJyZS4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpcm1hID0gKGNvbmZpcm1hVmFsb3IgPT09IFwic2lcIik7IFxyXG4gICAgY29uc3Qgc2x1ZyA9IGdldFNsdWdEZVBhZ2luYSgpO1xyXG4gICAgY29uc29sZS5sb2coXCJbUlNWUF0gRW52aWFuZG8gUlNWUOKApiBzbHVnID1cIiwgc2x1Zyk7XHJcblxyXG4gICAgLy8gKG9wY2lvbmFsKSBzaSBzZWd1w61zIHVzYW5kbyBzaGVldFVybCwgbWFudGVuZW1vcyBlbCBQT1NUIOKAnGVuIHBhcmFsZWxv4oCdXHJcbiAgICB2YXIgc2hlZXRVcmwgPSAke0pTT04uc3RyaW5naWZ5KGNmZy5zaGVldFVybCB8fCBcIlwiKX07XHJcbiAgICBpZiAoc2hlZXRVcmwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmZXRjaChzaGVldFVybCwge1xyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgbm9tYnJlOiBub21icmUudHJpbSgpLFxyXG4gICAgICAgICAgICBtZW5zYWplOiBtZW5zYWplLnRyaW0oKSxcclxuICAgICAgICAgICAgc2x1Zzogc2x1ZyxcclxuICAgICAgICAgICAgdHM6IERhdGUubm93KClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSl7IGNvbnNvbGUud2FybihcIltSU1ZQXSBzaGVldFVybCBlcnJvcjpcIiwgZSk7IH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1JTVlBdIHNoZWV0VXJsIHRocm93OlwiLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIPCflIwgSW1wb3J0YXIgRmlyZWJhc2UgZGluw6FtaWNhbWVudGUgeSBndWFyZGFyIGVuIEZpcmVzdG9yZVxyXG4gICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtYXBwLmpzXCIpLFxyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtZmlyZXN0b3JlLmpzXCIpLFxyXG4gICAgXSlcclxuICAgIC50aGVuKChbYXBwTW9kLCBmc01vZF0pID0+IHtcclxuICAgICAgY29uc3QgeyBpbml0aWFsaXplQXBwIH0gPSBhcHBNb2Q7XHJcbiAgICAgIGNvbnN0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCB9ID0gZnNNb2Q7XHJcblxyXG4gICAgICAvLyDimpnvuI8gQ29uZmlnIG3DrW5pbWEgKGFwaUtleSB5IHByb2plY3RJZCBzb24gc3VmaWNpZW50ZXMgcGFyYSBlbCBjbGllbnRlKVxyXG4gICAgICBjb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcclxuICAgICAgICBhcGlLZXk6IFwiQUl6YVN5QUxDdlU0OF9IUnAyNmNYcFFjVFg1UzMzQWRwd2ZsM3o0XCIsXHJcbiAgICAgICAgYXV0aERvbWFpbjogXCJyZXNlcnZhZWxkaWEtN2E0NDAuZmlyZWJhc2VhcHAuY29tXCIsXHJcbiAgICAgICAgcHJvamVjdElkOiBcInJlc2VydmFlbGRpYS03YTQ0MFwiLFxyXG4gICAgICAgIGFwcElkOiBcIjE6ODYwNDk1OTc1NDA2OndlYjozYTQ5YWQwY2Y1NWQ2MDMxMzUzNGZmXCJcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IGFwcCA9IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpO1xyXG4gICAgICBjb25zdCBkYiAgPSBnZXRGaXJlc3RvcmUoYXBwKTtcclxuXHJcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgbm9tYnJlOiBub21icmUudHJpbSgpLFxyXG4gICAgICAgIG1lbnNhamU6IChtZW5zYWplICYmIG1lbnNhamUudHJpbSgpKSB8fCBudWxsLFxyXG4gICAgICAgIGNvbmZpcm1hLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXHJcbiAgICAgICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LnNsaWNlKDAsIDUxMilcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFBheWxvYWQga2V5cyA9XCIsIE9iamVjdC5rZXlzKHBheWxvYWQpKTtcclxuICAgICAgY29uc29sZS5sb2coXCJbUlNWUF0gUGF5bG9hZCA9XCIsIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcclxuXHJcbiAgICAgIHJldHVybiBhZGREb2MoY29sbGVjdGlvbihkYiwgXCJwdWJsaWNhZGFzXCIsIHNsdWcsIFwicnN2cHNcIiksIHBheWxvYWQpO1xyXG4gICAgfSlcclxuICAgIC50aGVuKChkb2NSZWYpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coXCJbUlNWUF0gUlNWUCBndWFyZGFkbyBjb24gSUQ6XCIsIGRvY1JlZi5pZCwgXCJlbiAvcHVibGljYWRhcy9cIitzbHVnK1wiL3JzdnBzXCIpO1xyXG4gICAgICBhbGVydCgnwqFHcmFjaWFzIHBvciBjb25maXJtYXIgdHUgYXNpc3RlbmNpYSwgJyArIG5vbWJyZSArICchJyk7XHJcbiAgICAgIGNsb3NlTW9kYWwoKTtcclxuICAgIH0pXHJcbiAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiW1JTVlBdIEVycm9yIGd1YXJkYW5kbyBlbiBGaXJlc3RvcmU6XCIsIGVycik7XHJcbiAgICAgIGFsZXJ0KCdIdWJvIHVuIGVycm9yIGFsIGd1YXJkYXIgdHUgY29uZmlybWFjacOzbi4gUHJvYsOhIGRlIG51ZXZvLicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuIFxyXG4gIFxyXG5cclxufSk7XHJcbjwvc2NyaXB0PlxyXG5gO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJnZW5lcmFyTW9kYWxSU1ZQSFRNTCIsImNmZyIsImVuYWJsZWQiLCJ0aXRsZSIsInN1YnRpdGxlIiwiYnRuVGV4dCIsImJ1dHRvblRleHQiLCJjb2xvciIsInByaW1hcnlDb2xvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaGVldFVybCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/config.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/config.ts\nfunction normalizeConfig(opts) {\n    const fitMinScaleRaw = Number.isFinite(opts.fitMinScale) ? Number(opts.fitMinScale) : 0.88;\n    const fitMaxScaleRaw = Number.isFinite(opts.fitMaxScale) ? Number(opts.fitMaxScale) : 1.16;\n    const fitMinScale = Math.max(0.7, Math.min(1, fitMinScaleRaw));\n    const fitMaxScale = Math.max(1, fitMaxScaleRaw);\n    const fitTargetWidthRatioRaw = Number.isFinite(opts.fitTargetWidthRatio) ? Number(opts.fitTargetWidthRatio) : 0.94;\n    const fitTargetWidthRatio = Math.max(0.75, Math.min(0.99, fitTargetWidthRatioRaw));\n    const fitMinFillRatioRaw = Number.isFinite(opts.fitMinFillRatio) ? Number(opts.fitMinFillRatio) : 0.9;\n    const fitMinFillRatio = Math.max(0.6, Math.min(fitTargetWidthRatio, fitMinFillRatioRaw));\n    return {\n        enabled: !!opts.enabled,\n        minGapPx: Number.isFinite(opts.minGapPx) ? Number(opts.minGapPx) : 8,\n        paddingTopPx: Number.isFinite(opts.paddingTopPx) ? Number(opts.paddingTopPx) : 0,\n        paddingBottomPx: Number.isFinite(opts.paddingBottomPx) ? Number(opts.paddingBottomPx) : 12,\n        maxGapPx: Number.isFinite(opts.maxGapPx) ? Number(opts.maxGapPx) : 22,\n        onlyFixedSections: opts.onlyFixedSections !== false,\n        onlyWhenReordered: opts.onlyWhenReordered !== false,\n        rowTolPx: Number.isFinite(opts.rowTolPx) ? Number(opts.rowTolPx) : 28,\n        twoColSpreadRatio: Number.isFinite(opts.twoColSpreadRatio) ? Number(opts.twoColSpreadRatio) : 0.18,\n        minPerColumn2: Number.isFinite(opts.minPerColumn2) ? Number(opts.minPerColumn2) : 2,\n        threeColSpreadRatio: Number.isFinite(opts.threeColSpreadRatio) ? Number(opts.threeColSpreadRatio) : 0.22,\n        minPerColumn3: Number.isFinite(opts.minPerColumn3) ? Number(opts.minPerColumn3) : 2,\n        gapScale: Number.isFinite(opts.gapScale) ? Number(opts.gapScale) : 0.6,\n        fitMinScale,\n        fitMaxScale,\n        fitTargetWidthRatio,\n        fitMinFillRatio\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrREFBa0Q7QUFPM0MsU0FBU0EsZ0JBQWdCQyxJQUE4QjtJQUM1RCxNQUFNQyxpQkFBaUJDLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS0ksV0FBVyxJQUFJRixPQUFPRixLQUFLSSxXQUFXLElBQUk7SUFDdEYsTUFBTUMsaUJBQWlCSCxPQUFPQyxRQUFRLENBQUNILEtBQUtNLFdBQVcsSUFBSUosT0FBT0YsS0FBS00sV0FBVyxJQUFJO0lBQ3RGLE1BQU1GLGNBQWNHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLRSxHQUFHLENBQUMsR0FBR1I7SUFDOUMsTUFBTUssY0FBY0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdIO0lBQ2hDLE1BQU1LLHlCQUF5QlIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLVyxtQkFBbUIsSUFDbkVULE9BQU9GLEtBQUtXLG1CQUFtQixJQUMvQjtJQUNKLE1BQU1BLHNCQUFzQkosS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxNQUFNQztJQUMxRCxNQUFNRSxxQkFBcUJWLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS2EsZUFBZSxJQUMzRFgsT0FBT0YsS0FBS2EsZUFBZSxJQUMzQjtJQUNKLE1BQU1BLGtCQUFrQk4sS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtFLEdBQUcsQ0FBQ0UscUJBQXFCQztJQUVwRSxPQUFPO1FBQ0xFLFNBQVMsQ0FBQyxDQUFDZCxLQUFLYyxPQUFPO1FBRXZCQyxVQUFVYixPQUFPQyxRQUFRLENBQUNILEtBQUtlLFFBQVEsSUFBSWIsT0FBT0YsS0FBS2UsUUFBUSxJQUFJO1FBQ25FQyxjQUFjZCxPQUFPQyxRQUFRLENBQUNILEtBQUtnQixZQUFZLElBQUlkLE9BQU9GLEtBQUtnQixZQUFZLElBQUk7UUFDL0VDLGlCQUFpQmYsT0FBT0MsUUFBUSxDQUFDSCxLQUFLaUIsZUFBZSxJQUFJZixPQUFPRixLQUFLaUIsZUFBZSxJQUFJO1FBQ3hGQyxVQUFVaEIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLa0IsUUFBUSxJQUFJaEIsT0FBT0YsS0FBS2tCLFFBQVEsSUFBSTtRQUVuRUMsbUJBQW1CbkIsS0FBS21CLGlCQUFpQixLQUFLO1FBQzlDQyxtQkFBbUJwQixLQUFLb0IsaUJBQWlCLEtBQUs7UUFFOUNDLFVBQVVuQixPQUFPQyxRQUFRLENBQUNILEtBQUtxQixRQUFRLElBQUluQixPQUFPRixLQUFLcUIsUUFBUSxJQUFJO1FBRW5FQyxtQkFBbUJwQixPQUFPQyxRQUFRLENBQUNILEtBQUtzQixpQkFBaUIsSUFBSXBCLE9BQU9GLEtBQUtzQixpQkFBaUIsSUFBSTtRQUM5RkMsZUFBZXJCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3VCLGFBQWEsSUFBSXJCLE9BQU9GLEtBQUt1QixhQUFhLElBQUk7UUFFbEZDLHFCQUFxQnRCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3dCLG1CQUFtQixJQUFJdEIsT0FBT0YsS0FBS3dCLG1CQUFtQixJQUFJO1FBQ3BHQyxlQUFldkIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLeUIsYUFBYSxJQUFJdkIsT0FBT0YsS0FBS3lCLGFBQWEsSUFBSTtRQUVsRkMsVUFBVXhCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBSzBCLFFBQVEsSUFBSXhCLE9BQU9GLEtBQUswQixRQUFRLElBQUk7UUFDbkV0QjtRQUNBRTtRQUNBSztRQUNBRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2NvbmZpZy50c1xyXG5pbXBvcnQgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9ybWFsaXplZENvbmZpZyA9IFJlcXVpcmVkPE9taXQ8TW9iaWxlU21hcnRMYXlvdXRPcHRpb25zLCBcImVuYWJsZWRcIj4+ICYge1xyXG4gIGVuYWJsZWQ6IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKG9wdHM6IE1vYmlsZVNtYXJ0TGF5b3V0T3B0aW9ucyk6IE5vcm1hbGl6ZWRDb25maWcge1xuICBjb25zdCBmaXRNaW5TY2FsZVJhdyA9IE51bWJlci5pc0Zpbml0ZShvcHRzLmZpdE1pblNjYWxlKSA/IE51bWJlcihvcHRzLmZpdE1pblNjYWxlKSA6IDAuODg7XG4gIGNvbnN0IGZpdE1heFNjYWxlUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0TWF4U2NhbGUpID8gTnVtYmVyKG9wdHMuZml0TWF4U2NhbGUpIDogMS4xNjtcbiAgY29uc3QgZml0TWluU2NhbGUgPSBNYXRoLm1heCgwLjcsIE1hdGgubWluKDEsIGZpdE1pblNjYWxlUmF3KSk7XG4gIGNvbnN0IGZpdE1heFNjYWxlID0gTWF0aC5tYXgoMSwgZml0TWF4U2NhbGVSYXcpO1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0VGFyZ2V0V2lkdGhSYXRpbylcbiAgICA/IE51bWJlcihvcHRzLmZpdFRhcmdldFdpZHRoUmF0aW8pXG4gICAgOiAwLjk0O1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvID0gTWF0aC5tYXgoMC43NSwgTWF0aC5taW4oMC45OSwgZml0VGFyZ2V0V2lkdGhSYXRpb1JhdykpO1xuICBjb25zdCBmaXRNaW5GaWxsUmF0aW9SYXcgPSBOdW1iZXIuaXNGaW5pdGUob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgPyBOdW1iZXIob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgOiAwLjk7XG4gIGNvbnN0IGZpdE1pbkZpbGxSYXRpbyA9IE1hdGgubWF4KDAuNiwgTWF0aC5taW4oZml0VGFyZ2V0V2lkdGhSYXRpbywgZml0TWluRmlsbFJhdGlvUmF3KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiAhIW9wdHMuZW5hYmxlZCxcblxyXG4gICAgbWluR2FwUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pbkdhcFB4KSA/IE51bWJlcihvcHRzLm1pbkdhcFB4KSA6IDgsXHJcbiAgICBwYWRkaW5nVG9wUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnBhZGRpbmdUb3BQeCkgPyBOdW1iZXIob3B0cy5wYWRkaW5nVG9wUHgpIDogMCxcclxuICAgIHBhZGRpbmdCb3R0b21QeDogTnVtYmVyLmlzRmluaXRlKG9wdHMucGFkZGluZ0JvdHRvbVB4KSA/IE51bWJlcihvcHRzLnBhZGRpbmdCb3R0b21QeCkgOiAxMixcclxuICAgIG1heEdhcFB4OiBOdW1iZXIuaXNGaW5pdGUob3B0cy5tYXhHYXBQeCkgPyBOdW1iZXIob3B0cy5tYXhHYXBQeCkgOiAyMixcclxuXHJcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogb3B0cy5vbmx5Rml4ZWRTZWN0aW9ucyAhPT0gZmFsc2UsXHJcbiAgICBvbmx5V2hlblJlb3JkZXJlZDogb3B0cy5vbmx5V2hlblJlb3JkZXJlZCAhPT0gZmFsc2UsXHJcblxyXG4gICAgcm93VG9sUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnJvd1RvbFB4KSA/IE51bWJlcihvcHRzLnJvd1RvbFB4KSA6IDI4LFxyXG5cclxuICAgIHR3b0NvbFNwcmVhZFJhdGlvOiBOdW1iZXIuaXNGaW5pdGUob3B0cy50d29Db2xTcHJlYWRSYXRpbykgPyBOdW1iZXIob3B0cy50d29Db2xTcHJlYWRSYXRpbykgOiAwLjE4LFxyXG4gICAgbWluUGVyQ29sdW1uMjogTnVtYmVyLmlzRmluaXRlKG9wdHMubWluUGVyQ29sdW1uMikgPyBOdW1iZXIob3B0cy5taW5QZXJDb2x1bW4yKSA6IDIsXHJcblxuICAgIHRocmVlQ29sU3ByZWFkUmF0aW86IE51bWJlci5pc0Zpbml0ZShvcHRzLnRocmVlQ29sU3ByZWFkUmF0aW8pID8gTnVtYmVyKG9wdHMudGhyZWVDb2xTcHJlYWRSYXRpbykgOiAwLjIyLFxuICAgIG1pblBlckNvbHVtbjM6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pblBlckNvbHVtbjMpID8gTnVtYmVyKG9wdHMubWluUGVyQ29sdW1uMykgOiAyLFxuXG4gICAgZ2FwU2NhbGU6IE51bWJlci5pc0Zpbml0ZShvcHRzLmdhcFNjYWxlKSA/IE51bWJlcihvcHRzLmdhcFNjYWxlKSA6IDAuNixcbiAgICBmaXRNaW5TY2FsZSxcbiAgICBmaXRNYXhTY2FsZSxcbiAgICBmaXRUYXJnZXRXaWR0aFJhdGlvLFxuICAgIGZpdE1pbkZpbGxSYXRpbyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVDb25maWciLCJvcHRzIiwiZml0TWluU2NhbGVSYXciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGVSYXciLCJmaXRNYXhTY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmaXRUYXJnZXRXaWR0aFJhdGlvUmF3IiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpb1JhdyIsImZpdE1pbkZpbGxSYXRpbyIsImVuYWJsZWQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm1heEdhcFB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJnYXBTY2FsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts":
/*!******************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/dom.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsDomHelpersBlock: () => (/* binding */ jsDomHelpersBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/dom.ts\nfunction jsDomHelpersBlock() {\n    return `\n  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }\n\n  function isMobile(){\n    return (document.documentElement.clientWidth || 0) <= 767;\n  }\n\n  function getObjNodes(sec){\n    if(!sec) return [];\n    var nodes = [];\n    var content = sec.querySelector(\".sec-content\");\n    var bleed = sec.querySelector(\".sec-bleed\");\n\n    if (content) nodes = nodes.concat(Array.from(content.querySelectorAll(\".objeto\")));\n    if (bleed) nodes = nodes.concat(Array.from(bleed.querySelectorAll(\".objeto\")));\n\n    // Fallback: algunos elementos exportados pueden no traer clase \".objeto\"\n    // pero sí estar posicionados como objetos absolutos.\n    function collectAbsoluteCandidates(root){\n      if (!root) return [];\n      return Array.from(root.querySelectorAll(\"*\")).filter(function(el){\n        if (!el) return false;\n        var cs = getComputedStyle(el);\n        var pos = (cs.position || \"\").toLowerCase();\n        if (pos !== \"absolute\") return false;\n\n        var rr = el.getBoundingClientRect();\n        if (!rr || rr.width < 1 || rr.height < 1) return false;\n\n        // Evitar ruido estructural del layout de sección\n        if (el.classList && (\n          el.classList.contains(\"sec\") ||\n          el.classList.contains(\"sec-zoom\") ||\n          el.classList.contains(\"sec-bg\") ||\n          el.classList.contains(\"sec-content\") ||\n          el.classList.contains(\"sec-bleed\")\n        )) return false;\n\n        // Si ya está dentro de un \".objeto\", no lo contamos aparte.\n        var p = el.parentElement;\n        while (p){\n          if (p.classList && p.classList.contains(\"objeto\")) return false;\n          p = p.parentElement;\n        }\n        return true;\n      });\n    }\n\n    nodes = nodes.concat(collectAbsoluteCandidates(content));\n    nodes = nodes.concat(collectAbsoluteCandidates(bleed));\n\n    // Deduplicar preservando orden de aparición.\n    var seen = new Set();\n    return nodes.filter(function(n){\n      if (seen.has(n)) return false;\n      seen.add(n);\n      return true;\n    });\n  }\n\n  function relRect(el, root){\n    var r = el.getBoundingClientRect();\n    var rr = root.getBoundingClientRect();\n    return {\n      top: r.top - rr.top,\n      left: r.left - rr.left,\n      width: r.width,\n      height: r.height\n    };\n  }\n\n  function percentile(sortedArr, p){\n    if (!sortedArr.length) return 0;\n    var idx = Math.floor(sortedArr.length * p);\n    idx = Math.max(0, Math.min(sortedArr.length - 1, idx));\n    return sortedArr[idx];\n  }\n\n  function cx(it){ return it.left + (it.width || 0) / 2; }\n\n  // -------------------------\n  // ✅ CLUSTERS POR SOLAPE\n  // -------------------------\n  function rectsOverlap(a, b, tol){\n    tol = tol || 0;\n    return !(\n      (a.left + a.width) < (b.left + tol) ||\n      (b.left + b.width) < (a.left + tol) ||\n      (a.top + a.height) < (b.top + tol) ||\n      (b.top + b.height) < (a.top + tol)\n    );\n  }\n\n  function horizontalOverlapPx(a, b){\n    var l = Math.max(a.left, b.left);\n    var r = Math.min(a.left + a.width, b.left + b.width);\n    return Math.max(0, r - l);\n  }\n\n  function verticalGapPx(a, b){\n    var topAfter = Math.max(a.top, b.top);\n    var bottomBefore = Math.min(a.top + a.height, b.top + b.height);\n    return topAfter - bottomBefore;\n  }\n\n  function buildOverlapClusters(items){\n    var n = items.length;\n    var parent = new Array(n);\n    for (var i=0;i<n;i++) parent[i] = i;\n\n    function find(x){\n      while(parent[x] !== x){\n        parent[x] = parent[parent[x]];\n        x = parent[x];\n      }\n      return x;\n    }\n\n    function union(a,b){\n      var ra = find(a), rb = find(b);\n      if (ra !== rb) parent[rb] = ra;\n    }\n\n    // tol pequeño para considerar “encimado” aunque sea apenas\n    var TOL = 1;\n    // unión por cercanía vertical dentro de una misma \"columna visual\"\n    var PROX_Y = 34;\n    var MIN_H_OVERLAP_RATIO = 0.35;\n    var MAX_CX_DIST = 42;\n\n    for (var i=0;i<n;i++){\n      for (var j=i+1;j<n;j++){\n        var a = items[i], b = items[j];\n\n    var aIso = (a.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\n    var bIso = (b.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\n\n    // si cualquiera es isolated, no lo unimos con nadie\n    if (aIso || bIso) continue;\n\n    // opcional: cluster-id manual (si querés agrupar solo algunos)\n    var aKey = a.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\n    var bKey = b.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\n    if (aKey && bKey && aKey !== bKey) continue;\n\n    var aIsText = (a.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n    var bIsText = (b.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n    var involvesText = aIsText || bIsText;\n    var cxDist = Math.abs(cx(a) - cx(b));\n\n    if (rectsOverlap(a, b, TOL)) {\n      // Evita pegar columnas distintas por cajas de texto anchas.\n      // Si hay texto, exigimos cercania por eje X del centro.\n      if (!involvesText || cxDist <= MAX_CX_DIST) union(i,j);\n      continue;\n    }\n\n    // Si no se solapan pero están muy cerca en vertical y comparten columna,\n    // también los unimos para mantener bloque (ej: icono + texto debajo).\n    var hov = horizontalOverlapPx(a, b);\n    var minW = Math.max(1, Math.min(a.width || 0, b.width || 0));\n    var hovRatio = hov / minW;\n    // Con texto, usamos criterio más estricto para no cruzar columnas.\n    var sameVisualColumn = involvesText\n      ? (cxDist <= MAX_CX_DIST)\n      : ((hovRatio >= MIN_H_OVERLAP_RATIO) || (cxDist <= MAX_CX_DIST));\n    var vGap = verticalGapPx(a, b);\n    var nearVertical = vGap >= 0 && vGap <= PROX_Y;\n    var bothText = aIsText && bIsText;\n\n    // Evitar \"pegar\" párrafos entre sí solo por cercanía vertical.\n    // La unión por proximidad queda para pares mixtos (texto + no-texto),\n    // manteniendo el caso icono/forma + texto.\n    if (sameVisualColumn && nearVertical && !bothText) union(i,j);\n\n      }\n    }\n\n    var map = {};\n    for (var k=0;k<n;k++){\n      var r = find(k);\n      if (!map[r]) map[r] = [];\n      map[r].push(items[k]);\n    }\n\n    var clusters = [];\n    Object.keys(map).forEach(function(key){\n      var arr = map[key];\n\n      var minTop = Infinity, minLeft = Infinity, maxR = -Infinity, maxB = -Infinity;\n      for (var i=0;i<arr.length;i++){\n        var it = arr[i];\n        minTop = Math.min(minTop, it.top);\n        minLeft = Math.min(minLeft, it.left);\n        maxR = Math.max(maxR, it.left + it.width);\n        maxB = Math.max(maxB, it.top + it.height);\n      }\n\n      // offsets relativos para preservar el solape dentro del cluster\n      for (var i=0;i<arr.length;i++){\n        arr[i]._relTop = arr[i].top - minTop;\n        arr[i]._relLeft = arr[i].left - minLeft;\n      }\n\n      clusters.push({\n        items: arr,\n        top: minTop,\n        left: minLeft,\n        width: maxR - minLeft,\n        height: maxB - minTop,\n        cx: (minLeft + maxR) / 2\n      });\n    });\n\n    // orden estable por top para consistencia\n    clusters.sort(function(a,b){ return a.top - b.top; });\n\n    return clusters;\n  }\n\n  // ✅ “entra” si ningún cluster se sale horizontalmente del contenedor content\n  function clustersFitInMobile(clusters, rootEl){\n    var rootW = rootEl.getBoundingClientRect().width || 0;\n    if (!rootW) return true;\n\n    for (var i=0;i<clusters.length;i++){\n      var c = clusters[i];\n      if (c.left < -1) return false;\n      if ((c.left + c.width) > (rootW + 1)) return false;\n    }\n    return true;\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwrQ0FBK0M7QUFDeEMsU0FBU0E7SUFDZCxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3T1YsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGRvbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2RvbS50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNEb21IZWxwZXJzQmxvY2soKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFxyXG4gIGZ1bmN0aW9uIGNsYW1wKG4sYSxiKXsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsbikpOyB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzTW9iaWxlKCl7XHJcbiAgICByZXR1cm4gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwKSA8PSA3Njc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRPYmpOb2RlcyhzZWMpe1xuICAgIGlmKCFzZWMpIHJldHVybiBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgY29udGVudCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1jb250ZW50XCIpO1xuICAgIHZhciBibGVlZCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1ibGVlZFwiKTtcblxuICAgIGlmIChjb250ZW50KSBub2RlcyA9IG5vZGVzLmNvbmNhdChBcnJheS5mcm9tKGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikpKTtcbiAgICBpZiAoYmxlZWQpIG5vZGVzID0gbm9kZXMuY29uY2F0KEFycmF5LmZyb20oYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikpKTtcblxuICAgIC8vIEZhbGxiYWNrOiBhbGd1bm9zIGVsZW1lbnRvcyBleHBvcnRhZG9zIHB1ZWRlbiBubyB0cmFlciBjbGFzZSBcIi5vYmpldG9cIlxuICAgIC8vIHBlcm8gc8OtIGVzdGFyIHBvc2ljaW9uYWRvcyBjb21vIG9iamV0b3MgYWJzb2x1dG9zLlxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMocm9vdCl7XG4gICAgICBpZiAoIXJvb3QpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3QucXVlcnlTZWxlY3RvckFsbChcIipcIikpLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIGlmICghZWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIHZhciBwb3MgPSAoY3MucG9zaXRpb24gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHBvcyAhPT0gXCJhYnNvbHV0ZVwiKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJyID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghcnIgfHwgcnIud2lkdGggPCAxIHx8IHJyLmhlaWdodCA8IDEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBFdml0YXIgcnVpZG8gZXN0cnVjdHVyYWwgZGVsIGxheW91dCBkZSBzZWNjacOzblxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0ICYmIChcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWNcIikgfHxcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWMtem9vbVwiKSB8fFxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1iZ1wiKSB8fFxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1jb250ZW50XCIpIHx8XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VjLWJsZWVkXCIpXG4gICAgICAgICkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBTaSB5YSBlc3TDoSBkZW50cm8gZGUgdW4gXCIub2JqZXRvXCIsIG5vIGxvIGNvbnRhbW9zIGFwYXJ0ZS5cbiAgICAgICAgdmFyIHAgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB3aGlsZSAocCl7XG4gICAgICAgICAgaWYgKHAuY2xhc3NMaXN0ICYmIHAuY2xhc3NMaXN0LmNvbnRhaW5zKFwib2JqZXRvXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcCA9IHAucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMoY29udGVudCkpO1xuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMoYmxlZWQpKTtcblxuICAgIC8vIERlZHVwbGljYXIgcHJlc2VydmFuZG8gb3JkZW4gZGUgYXBhcmljacOzbi5cbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG4pe1xuICAgICAgaWYgKHNlZW4uaGFzKG4pKSByZXR1cm4gZmFsc2U7XG4gICAgICBzZWVuLmFkZChuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cclxuICBmdW5jdGlvbiByZWxSZWN0KGVsLCByb290KXtcclxuICAgIHZhciByID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgcnIgPSByb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiByLnRvcCAtIHJyLnRvcCxcclxuICAgICAgbGVmdDogci5sZWZ0IC0gcnIubGVmdCxcclxuICAgICAgd2lkdGg6IHIud2lkdGgsXHJcbiAgICAgIGhlaWdodDogci5oZWlnaHRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZXJjZW50aWxlKHNvcnRlZEFyciwgcCl7XHJcbiAgICBpZiAoIXNvcnRlZEFyci5sZW5ndGgpIHJldHVybiAwO1xyXG4gICAgdmFyIGlkeCA9IE1hdGguZmxvb3Ioc29ydGVkQXJyLmxlbmd0aCAqIHApO1xyXG4gICAgaWR4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc29ydGVkQXJyLmxlbmd0aCAtIDEsIGlkeCkpO1xyXG4gICAgcmV0dXJuIHNvcnRlZEFycltpZHhdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3goaXQpeyByZXR1cm4gaXQubGVmdCArIChpdC53aWR0aCB8fCAwKSAvIDI7IH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIOKchSBDTFVTVEVSUyBQT1IgU09MQVBFXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIGZ1bmN0aW9uIHJlY3RzT3ZlcmxhcChhLCBiLCB0b2wpe1xuICAgIHRvbCA9IHRvbCB8fCAwO1xuICAgIHJldHVybiAhKFxuICAgICAgKGEubGVmdCArIGEud2lkdGgpIDwgKGIubGVmdCArIHRvbCkgfHxcbiAgICAgIChiLmxlZnQgKyBiLndpZHRoKSA8IChhLmxlZnQgKyB0b2wpIHx8XHJcbiAgICAgIChhLnRvcCArIGEuaGVpZ2h0KSA8IChiLnRvcCArIHRvbCkgfHxcclxuICAgICAgKGIudG9wICsgYi5oZWlnaHQpIDwgKGEudG9wICsgdG9sKVxyXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhvcml6b250YWxPdmVybGFwUHgoYSwgYil7XG4gICAgdmFyIGwgPSBNYXRoLm1heChhLmxlZnQsIGIubGVmdCk7XG4gICAgdmFyIHIgPSBNYXRoLm1pbihhLmxlZnQgKyBhLndpZHRoLCBiLmxlZnQgKyBiLndpZHRoKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgciAtIGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmVydGljYWxHYXBQeChhLCBiKXtcbiAgICB2YXIgdG9wQWZ0ZXIgPSBNYXRoLm1heChhLnRvcCwgYi50b3ApO1xuICAgIHZhciBib3R0b21CZWZvcmUgPSBNYXRoLm1pbihhLnRvcCArIGEuaGVpZ2h0LCBiLnRvcCArIGIuaGVpZ2h0KTtcbiAgICByZXR1cm4gdG9wQWZ0ZXIgLSBib3R0b21CZWZvcmU7XG4gIH1cblxyXG4gIGZ1bmN0aW9uIGJ1aWxkT3ZlcmxhcENsdXN0ZXJzKGl0ZW1zKXtcclxuICAgIHZhciBuID0gaXRlbXMubGVuZ3RoO1xyXG4gICAgdmFyIHBhcmVudCA9IG5ldyBBcnJheShuKTtcclxuICAgIGZvciAodmFyIGk9MDtpPG47aSsrKSBwYXJlbnRbaV0gPSBpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmQoeCl7XHJcbiAgICAgIHdoaWxlKHBhcmVudFt4XSAhPT0geCl7XHJcbiAgICAgICAgcGFyZW50W3hdID0gcGFyZW50W3BhcmVudFt4XV07XHJcbiAgICAgICAgeCA9IHBhcmVudFt4XTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bmlvbihhLGIpe1xyXG4gICAgICB2YXIgcmEgPSBmaW5kKGEpLCByYiA9IGZpbmQoYik7XHJcbiAgICAgIGlmIChyYSAhPT0gcmIpIHBhcmVudFtyYl0gPSByYTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0b2wgcGVxdWXDsW8gcGFyYSBjb25zaWRlcmFyIOKAnGVuY2ltYWRv4oCdIGF1bnF1ZSBzZWEgYXBlbmFzXG4gICAgdmFyIFRPTCA9IDE7XG4gICAgLy8gdW5pw7NuIHBvciBjZXJjYW7DrWEgdmVydGljYWwgZGVudHJvIGRlIHVuYSBtaXNtYSBcImNvbHVtbmEgdmlzdWFsXCJcbiAgICB2YXIgUFJPWF9ZID0gMzQ7XG4gICAgdmFyIE1JTl9IX09WRVJMQVBfUkFUSU8gPSAwLjM1O1xuICAgIHZhciBNQVhfQ1hfRElTVCA9IDQyO1xuXHJcbiAgICBmb3IgKHZhciBpPTA7aTxuO2krKyl7XG4gICAgICBmb3IgKHZhciBqPWkrMTtqPG47aisrKXtcbiAgICAgICAgdmFyIGEgPSBpdGVtc1tpXSwgYiA9IGl0ZW1zW2pdO1xuXG4gICAgdmFyIGFJc28gPSAoYS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXJcIikgfHwgXCJcIikgPT09IFwiaXNvbGF0ZWRcIjtcbiAgICB2YXIgYklzbyA9IChiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiKSA9PT0gXCJpc29sYXRlZFwiO1xuXHJcbiAgICAvLyBzaSBjdWFscXVpZXJhIGVzIGlzb2xhdGVkLCBubyBsbyB1bmltb3MgY29uIG5hZGllXHJcbiAgICBpZiAoYUlzbyB8fCBiSXNvKSBjb250aW51ZTtcclxuXHJcbiAgICAvLyBvcGNpb25hbDogY2x1c3Rlci1pZCBtYW51YWwgKHNpIHF1ZXLDqXMgYWdydXBhciBzb2xvIGFsZ3Vub3MpXHJcbiAgICB2YXIgYUtleSA9IGEubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyLWlkXCIpIHx8IFwiXCI7XG4gICAgdmFyIGJLZXkgPSBiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3Rlci1pZFwiKSB8fCBcIlwiO1xuICAgIGlmIChhS2V5ICYmIGJLZXkgJiYgYUtleSAhPT0gYktleSkgY29udGludWU7XG5cbiAgICB2YXIgYUlzVGV4dCA9IChhLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgdmFyIGJJc1RleHQgPSAoYi5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xuICAgIHZhciBpbnZvbHZlc1RleHQgPSBhSXNUZXh0IHx8IGJJc1RleHQ7XG4gICAgdmFyIGN4RGlzdCA9IE1hdGguYWJzKGN4KGEpIC0gY3goYikpO1xuXG4gICAgaWYgKHJlY3RzT3ZlcmxhcChhLCBiLCBUT0wpKSB7XG4gICAgICAvLyBFdml0YSBwZWdhciBjb2x1bW5hcyBkaXN0aW50YXMgcG9yIGNhamFzIGRlIHRleHRvIGFuY2hhcy5cbiAgICAgIC8vIFNpIGhheSB0ZXh0bywgZXhpZ2ltb3MgY2VyY2FuaWEgcG9yIGVqZSBYIGRlbCBjZW50cm8uXG4gICAgICBpZiAoIWludm9sdmVzVGV4dCB8fCBjeERpc3QgPD0gTUFYX0NYX0RJU1QpIHVuaW9uKGksaik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBTaSBubyBzZSBzb2xhcGFuIHBlcm8gZXN0w6FuIG11eSBjZXJjYSBlbiB2ZXJ0aWNhbCB5IGNvbXBhcnRlbiBjb2x1bW5hLFxuICAgIC8vIHRhbWJpw6luIGxvcyB1bmltb3MgcGFyYSBtYW50ZW5lciBibG9xdWUgKGVqOiBpY29ubyArIHRleHRvIGRlYmFqbykuXG4gICAgdmFyIGhvdiA9IGhvcml6b250YWxPdmVybGFwUHgoYSwgYik7XG4gICAgdmFyIG1pblcgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihhLndpZHRoIHx8IDAsIGIud2lkdGggfHwgMCkpO1xuICAgIHZhciBob3ZSYXRpbyA9IGhvdiAvIG1pblc7XG4gICAgLy8gQ29uIHRleHRvLCB1c2Ftb3MgY3JpdGVyaW8gbcOhcyBlc3RyaWN0byBwYXJhIG5vIGNydXphciBjb2x1bW5hcy5cbiAgICB2YXIgc2FtZVZpc3VhbENvbHVtbiA9IGludm9sdmVzVGV4dFxuICAgICAgPyAoY3hEaXN0IDw9IE1BWF9DWF9ESVNUKVxuICAgICAgOiAoKGhvdlJhdGlvID49IE1JTl9IX09WRVJMQVBfUkFUSU8pIHx8IChjeERpc3QgPD0gTUFYX0NYX0RJU1QpKTtcbiAgICB2YXIgdkdhcCA9IHZlcnRpY2FsR2FwUHgoYSwgYik7XG4gICAgdmFyIG5lYXJWZXJ0aWNhbCA9IHZHYXAgPj0gMCAmJiB2R2FwIDw9IFBST1hfWTtcbiAgICB2YXIgYm90aFRleHQgPSBhSXNUZXh0ICYmIGJJc1RleHQ7XG5cbiAgICAvLyBFdml0YXIgXCJwZWdhclwiIHDDoXJyYWZvcyBlbnRyZSBzw60gc29sbyBwb3IgY2VyY2Fuw61hIHZlcnRpY2FsLlxuICAgIC8vIExhIHVuacOzbiBwb3IgcHJveGltaWRhZCBxdWVkYSBwYXJhIHBhcmVzIG1peHRvcyAodGV4dG8gKyBuby10ZXh0byksXG4gICAgLy8gbWFudGVuaWVuZG8gZWwgY2FzbyBpY29uby9mb3JtYSArIHRleHRvLlxuICAgIGlmIChzYW1lVmlzdWFsQ29sdW1uICYmIG5lYXJWZXJ0aWNhbCAmJiAhYm90aFRleHQpIHVuaW9uKGksaik7XG5cbiAgICAgIH1cbiAgICB9XG5cclxuICAgIHZhciBtYXAgPSB7fTtcclxuICAgIGZvciAodmFyIGs9MDtrPG47aysrKXtcclxuICAgICAgdmFyIHIgPSBmaW5kKGspO1xyXG4gICAgICBpZiAoIW1hcFtyXSkgbWFwW3JdID0gW107XHJcbiAgICAgIG1hcFtyXS5wdXNoKGl0ZW1zW2tdKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcclxuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xyXG4gICAgICB2YXIgYXJyID0gbWFwW2tleV07XHJcblxyXG4gICAgICB2YXIgbWluVG9wID0gSW5maW5pdHksIG1pbkxlZnQgPSBJbmZpbml0eSwgbWF4UiA9IC1JbmZpbml0eSwgbWF4QiA9IC1JbmZpbml0eTtcclxuICAgICAgZm9yICh2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBpdCA9IGFycltpXTtcclxuICAgICAgICBtaW5Ub3AgPSBNYXRoLm1pbihtaW5Ub3AsIGl0LnRvcCk7XHJcbiAgICAgICAgbWluTGVmdCA9IE1hdGgubWluKG1pbkxlZnQsIGl0LmxlZnQpO1xyXG4gICAgICAgIG1heFIgPSBNYXRoLm1heChtYXhSLCBpdC5sZWZ0ICsgaXQud2lkdGgpO1xyXG4gICAgICAgIG1heEIgPSBNYXRoLm1heChtYXhCLCBpdC50b3AgKyBpdC5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBvZmZzZXRzIHJlbGF0aXZvcyBwYXJhIHByZXNlcnZhciBlbCBzb2xhcGUgZGVudHJvIGRlbCBjbHVzdGVyXHJcbiAgICAgIGZvciAodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICBhcnJbaV0uX3JlbFRvcCA9IGFycltpXS50b3AgLSBtaW5Ub3A7XHJcbiAgICAgICAgYXJyW2ldLl9yZWxMZWZ0ID0gYXJyW2ldLmxlZnQgLSBtaW5MZWZ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjbHVzdGVycy5wdXNoKHtcclxuICAgICAgICBpdGVtczogYXJyLFxyXG4gICAgICAgIHRvcDogbWluVG9wLFxyXG4gICAgICAgIGxlZnQ6IG1pbkxlZnQsXHJcbiAgICAgICAgd2lkdGg6IG1heFIgLSBtaW5MZWZ0LFxyXG4gICAgICAgIGhlaWdodDogbWF4QiAtIG1pblRvcCxcclxuICAgICAgICBjeDogKG1pbkxlZnQgKyBtYXhSKSAvIDJcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBvcmRlbiBlc3RhYmxlIHBvciB0b3AgcGFyYSBjb25zaXN0ZW5jaWFcclxuICAgIGNsdXN0ZXJzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xyXG5cclxuICAgIHJldHVybiBjbHVzdGVycztcclxuICB9XHJcblxyXG4gIC8vIOKchSDigJxlbnRyYeKAnSBzaSBuaW5nw7puIGNsdXN0ZXIgc2Ugc2FsZSBob3Jpem9udGFsbWVudGUgZGVsIGNvbnRlbmVkb3IgY29udGVudFxyXG4gIGZ1bmN0aW9uIGNsdXN0ZXJzRml0SW5Nb2JpbGUoY2x1c3RlcnMsIHJvb3RFbCl7XHJcbiAgICB2YXIgcm9vdFcgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgMDtcclxuICAgIGlmICghcm9vdFcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGZvciAodmFyIGk9MDtpPGNsdXN0ZXJzLmxlbmd0aDtpKyspe1xyXG4gICAgICB2YXIgYyA9IGNsdXN0ZXJzW2ldO1xyXG4gICAgICBpZiAoYy5sZWZ0IDwgLTEpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKChjLmxlZnQgKyBjLndpZHRoKSA+IChyb290VyArIDEpKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc0RvbUhlbHBlcnNCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/fitScale.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsFitScaleBlock: () => (/* binding */ jsFitScaleBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/fitScale.ts\nfunction jsFitScaleBlock() {\n    return `\n  function ensureFitScaleBaseline(el){\n    if (!el) return;\n    if (!el.hasAttribute(\"data-msl-fit-orig-transform\")) {\n      el.setAttribute(\"data-msl-fit-orig-transform\", el.style.transform || \"\");\n    }\n    if (!el.hasAttribute(\"data-msl-fit-orig-origin\")) {\n      el.setAttribute(\"data-msl-fit-orig-origin\", el.style.transformOrigin || \"\");\n    }\n  }\n\n  function restoreFitScaleBaseline(el){\n    if (!el) return;\n    ensureFitScaleBaseline(el);\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\n    var baseOrigin = el.getAttribute(\"data-msl-fit-orig-origin\") || \"\";\n    el.style.transform = baseTransform;\n    if (baseOrigin) el.style.transformOrigin = baseOrigin;\n    else el.style.removeProperty(\"transform-origin\");\n  }\n\n  function applyElementFitScale(el, scale){\n    if (!el) return;\n    ensureFitScaleBaseline(el);\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\n    var next = baseTransform ? (baseTransform + \" scale(\" + scale + \")\") : (\"scale(\" + scale + \")\");\n    el.style.transform = next;\n    el.style.transformOrigin = \"top center\";\n  }\n\n  function resetSectionFitScale(_sec, content, bleed){\n    restoreFitScaleBaseline(content);\n    restoreFitScaleBaseline(bleed);\n  }\n\n  function computeSectionBounds(sec, nodes){\n    if (!sec || !nodes || !nodes.length) return null;\n    var minLeft = Infinity;\n    var minTop = Infinity;\n    var maxRight = -Infinity;\n    var maxBottom = -Infinity;\n    var valid = 0;\n\n    for (var i=0; i<nodes.length; i++){\n      var node = nodes[i];\n      if (!node) continue;\n      var rr = relRect(node, sec);\n      var w = Number(rr.width || 0);\n      var h = Number(rr.height || 0);\n      if (w <= 0.5 && h <= 0.5) continue;\n\n      var l = Number(rr.left || 0);\n      var t = Number(rr.top || 0);\n      var r = l + Math.max(0, w);\n      var b = t + Math.max(0, h);\n\n      if (!isFinite(l) || !isFinite(t) || !isFinite(r) || !isFinite(b)) continue;\n\n      minLeft = Math.min(minLeft, l);\n      minTop = Math.min(minTop, t);\n      maxRight = Math.max(maxRight, r);\n      maxBottom = Math.max(maxBottom, b);\n      valid++;\n    }\n\n    if (!valid || !isFinite(minLeft) || !isFinite(maxRight) || !isFinite(minTop) || !isFinite(maxBottom)) {\n      return null;\n    }\n\n    return {\n      minLeft: minLeft,\n      minTop: minTop,\n      maxRight: maxRight,\n      maxBottom: maxBottom,\n      width: Math.max(0, maxRight - minLeft),\n      height: Math.max(0, maxBottom - minTop),\n      count: valid\n    };\n  }\n\n  function computeFitScale(sec, bounds, secModo, CFG){\n    if (!sec || !bounds) return 1;\n    var secRect = sec.getBoundingClientRect();\n    var secW = Number(secRect.width || 0);\n    var secH = Number(secRect.height || 0);\n    if (secW <= 1) {\n      return {\n        scale: 1,\n        debug: null\n      };\n    }\n\n    var targetCoverage = clamp(Number(CFG.FIT_TARGET_WIDTH_RATIO || 0.94), 0.75, 0.99);\n    var minFillForUpscale = clamp(Number(CFG.FIT_MIN_FILL_RATIO || 0.9), 0.6, targetCoverage);\n    var minScale = clamp(Number(CFG.FIT_MIN_SCALE || 0.88), 0.7, 1);\n    var maxScale = Math.max(1, Number(CFG.FIT_MAX_SCALE || 1.16));\n\n    var contentW = Math.max(1, Number(bounds.width || 0));\n    var coverage = contentW / secW;\n\n    var scale = 1;\n    var debug = {\n      secW: secW,\n      secH: secH,\n      targetCoverage: targetCoverage,\n      minFillForUpscale: minFillForUpscale,\n      minScale: minScale,\n      maxScale: maxScale,\n      coverage: coverage,\n      initialScale: 1,\n      maxScaleByWidth: null,\n      maxScaleByHeight: null,\n      scaleAfterWidthClamp: null,\n      scaleAfterHeightClamp: null,\n      tinyShrinkProtected: false,\n      pantallaDownscaleBlocked: false\n    };\n    if (coverage < minFillForUpscale) {\n      scale = targetCoverage / Math.max(0.01, coverage);\n    }\n    debug.initialScale = scale;\n\n    if (scale >= 1) scale = Math.min(scale, maxScale);\n    else scale = Math.max(scale, minScale);\n\n    // Límite horizontal duro por centro visual.\n    var centerX = secW / 2;\n    var distLeft = Math.max(0, centerX - Number(bounds.minLeft || 0));\n    var distRight = Math.max(0, Number(bounds.maxRight || 0) - centerX);\n    var maxScaleByWidth = Infinity;\n    if (distLeft > 0.5) {\n      maxScaleByWidth = Math.min(maxScaleByWidth, centerX / distLeft);\n    }\n    if (distRight > 0.5) {\n      maxScaleByWidth = Math.min(maxScaleByWidth, (secW - centerX) / distRight);\n    }\n    if (isFinite(maxScaleByWidth) && maxScaleByWidth > 0) {\n      scale = Math.min(scale, maxScaleByWidth);\n      debug.maxScaleByWidth = maxScaleByWidth;\n    }\n    debug.scaleAfterWidthClamp = scale;\n\n    if (secModo === \"pantalla\" && scale < 1 && scale > 0.94) {\n      // Avoid shrinking \"pantalla\" for tiny overflows; preserve visual impact.\n      scale = 1;\n      debug.tinyShrinkProtected = true;\n    }\n\n    // En modo pantalla no dejamos que el contenido se recorte por altura.\n    if (secModo === \"pantalla\" && secH > 1) {\n      var maxBottom = Number(bounds.maxBottom || 0);\n      if (maxBottom > 1) {\n        var maxScaleByHeight = secH / maxBottom;\n        if (isFinite(maxScaleByHeight) && maxScaleByHeight > 0) {\n          scale = Math.min(scale, maxScaleByHeight);\n          debug.maxScaleByHeight = maxScaleByHeight;\n        }\n      }\n    }\n    debug.scaleAfterHeightClamp = scale;\n\n    if (secModo === \"pantalla\" && scale < 1) {\n      // Pantalla sections already have their own viewport-fit logic.\n      // Avoid additional downscale here to keep hero text readable.\n      scale = 1;\n      debug.pantallaDownscaleBlocked = true;\n    }\n\n    if (!isFinite(scale) || scale <= 0) scale = 1;\n    if (Math.abs(scale - 1) < 0.02) scale = 1;\n    return {\n      scale: scale,\n      debug: debug\n    };\n  }\n\n  function applySectionFitScale(sec, content, bleed, nodesAll, secModo, CFG, meta, opts){\n    if (!sec || !content) {\n      return { scale: 1, neededHeight: 0, bounds: null };\n    }\n\n    ensureFitScaleBaseline(content);\n    ensureFitScaleBaseline(bleed);\n    var preserveBottomGap = 0;\n    if (opts && Number.isFinite(opts.preserveBottomGap)) {\n      preserveBottomGap = Math.max(0, Number(opts.preserveBottomGap));\n    }\n\n    var fitNodes = (nodesAll || []).filter(function(node){\n      if (!node) return false;\n      var fitMode = (node.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\n      if (fitMode === \"ignore\") return false;\n      if (node.closest && node.closest(\".sec-bleed\")) return false;\n      return true;\n    });\n\n    var bounds = computeSectionBounds(sec, fitNodes);\n    if (!bounds) {\n      bounds = computeSectionBounds(sec, nodesAll || []);\n    }\n    if (!bounds) {\n      restoreFitScaleBaseline(content);\n      restoreFitScaleBaseline(bleed);\n      sec.setAttribute(\"data-msl-fit-scale\", \"1\");\n      return { scale: 1, neededHeight: 0, bounds: null };\n    }\n\n    var fitResult = computeFitScale(sec, bounds, secModo, CFG);\n    var scale = (fitResult && Number.isFinite(fitResult.scale)) ? fitResult.scale : 1;\n    var fitDebug = fitResult && fitResult.debug ? fitResult.debug : null;\n    applyElementFitScale(content, scale);\n    applyElementFitScale(bleed, scale);\n\n    var neededHeight = 0;\n    if (secModo !== \"pantalla\") {\n      var maxBottomWithGap = Number(bounds.maxBottom || 0) + preserveBottomGap;\n      neededHeight = Math.ceil(maxBottomWithGap * scale + (CFG.PAD_BOT || 0));\n    }\n\n    if (secModo === \"pantalla\") {\n      var secRectNow = sec.getBoundingClientRect();\n      var vv = window.visualViewport;\n      var viewportW = (vv && vv.width) ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 0);\n      var viewportH = (vv && vv.height) ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 0);\n      var ua = navigator.userAgent || \"\";\n      var mobileUA = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);\n      var touchPoints = Number(navigator.maxTouchPoints || 0);\n      var coarsePointer = false;\n      if (window.matchMedia) {\n        try { coarsePointer = window.matchMedia(\"(pointer: coarse)\").matches; } catch(_e) {}\n      }\n      var mobileViewport = viewportW <= 767;\n      var desktopMobilePreview = mobileViewport && !mobileUA;\n\n      var boundsAll = computeSectionBounds(sec, nodesAll || []);\n      var totalNodes = (nodesAll || []).length;\n      var fitNodesCount = fitNodes.length;\n      var textAll = 0;\n      var textFit = 0;\n      var ignoredBleed = 0;\n      var ignoredExplicit = 0;\n      var dominantText = null;\n      var dominantTextH = -1;\n      var elementRows = [];\n\n      for (var ni=0; ni<totalNodes; ni++){\n        var nodeAll = nodesAll[ni];\n        if (!nodeAll) continue;\n\n        var fitModeAll = (nodeAll.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\n        if (fitModeAll === \"ignore\") ignoredExplicit++;\n        if (nodeAll.closest && nodeAll.closest(\".sec-bleed\")) ignoredBleed++;\n\n        var rrNode = relRect(nodeAll, sec);\n        var nodeW = Number(rrNode.width || 0);\n        var nodeH = Number(rrNode.height || 0);\n        var nodeTop = Number(rrNode.top || 0);\n        var nodeBottom = nodeTop + nodeH;\n        var isTextAll = (nodeAll.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n        if (isTextAll) textAll++;\n\n        if (nodeW > 0.5 || nodeH > 0.5) {\n          var kindAll = isTextAll ? \"texto\" : String((nodeAll.tagName || \"\").toLowerCase());\n          elementRows.push({\n            kind: kindAll,\n            width: nodeW,\n            height: nodeH,\n            top: nodeTop,\n            bottom: nodeBottom,\n            area: nodeW * nodeH,\n            textSample: isTextAll\n              ? ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 70)\n              : \"\"\n          });\n        }\n\n        if (!isTextAll) continue;\n        if (nodeH <= dominantTextH) continue;\n        dominantTextH = nodeH;\n        var csTxt = getComputedStyle(nodeAll);\n        dominantText = {\n          top: +nodeTop.toFixed(1),\n          left: +Number(rrNode.left || 0).toFixed(1),\n          width: +nodeW.toFixed(1),\n          height: +nodeH.toFixed(1),\n          bottom: +nodeBottom.toFixed(1),\n          widthSecRatio: secRectNow.width > 1 ? +(nodeW / secRectNow.width).toFixed(3) : null,\n          heightSecRatio: secRectNow.height > 1 ? +(nodeH / secRectNow.height).toFixed(3) : null,\n          widthViewportRatio: viewportW > 1 ? +(nodeW / viewportW).toFixed(3) : null,\n          heightViewportRatio: viewportH > 1 ? +(nodeH / viewportH).toFixed(3) : null,\n          fontSize: csTxt.fontSize || \"\",\n          lineHeight: csTxt.lineHeight || \"\",\n          textAlign: csTxt.textAlign || \"\",\n          transform: (nodeAll.style && nodeAll.style.transform) ? nodeAll.style.transform : \"\",\n          textSample: ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 90)\n        };\n      }\n\n      for (var fi=0; fi<fitNodes.length; fi++){\n        var fitNode = fitNodes[fi];\n        if ((fitNode.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textFit++;\n      }\n\n      var topElements = elementRows\n        .sort(function(a,b){ return (b.area || 0) - (a.area || 0); })\n        .slice(0, 6)\n        .map(function(row){\n          return {\n            kind: row.kind,\n            width: +Number(row.width || 0).toFixed(1),\n            height: +Number(row.height || 0).toFixed(1),\n            widthSecRatio: secRectNow.width > 1 ? +((row.width || 0) / secRectNow.width).toFixed(3) : null,\n            heightSecRatio: secRectNow.height > 1 ? +((row.height || 0) / secRectNow.height).toFixed(3) : null,\n            widthViewportRatio: viewportW > 1 ? +((row.width || 0) / viewportW).toFixed(3) : null,\n            heightViewportRatio: viewportH > 1 ? +((row.height || 0) / viewportH).toFixed(3) : null,\n            topSecRatio: secRectNow.height > 1 ? +((row.top || 0) / secRectNow.height).toFixed(3) : null,\n            bottomSecRatio: secRectNow.height > 1 ? +((row.bottom || 0) / secRectNow.height).toFixed(3) : null,\n            sample: row.textSample || \"\"\n          };\n        });\n\n      var coverageFit = bounds.width / Math.max(1, secRectNow.width || 0);\n      var coverageAll = boundsAll ? (boundsAll.width / Math.max(1, secRectNow.width || 0)) : null;\n\n      var flatLines = [];\n      flatLines.push(\n        \"sec=\" + String(meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1)\n        + \" viewport=\" + (+Number(viewportW || 0).toFixed(1)) + \"x\" + (+Number(viewportH || 0).toFixed(1))\n        + \" sec=\" + (+Number(secRectNow.width || 0).toFixed(1)) + \"x\" + (+Number(secRectNow.height || 0).toFixed(1))\n        + \" mobileViewport=\" + String(mobileViewport)\n        + \" desktopMobilePreview=\" + String(desktopMobilePreview)\n        + \" mobileUA=\" + String(mobileUA)\n        + \" coarsePointer=\" + String(coarsePointer)\n        + \" touchPoints=\" + String(touchPoints)\n      );\n      flatLines.push(\n        \"fit scale=\" + (+Number(scale || 1).toFixed(3))\n        + \" coverageFit=\" + (+coverageFit.toFixed(3))\n        + \" coverageAll=\" + (coverageAll == null ? \"null\" : String(+coverageAll.toFixed(3)))\n        + \" nodes=\" + String(fitNodesCount) + \"/\" + String(totalNodes)\n        + \" ignoredBleed=\" + String(ignoredBleed)\n        + \" ignoredExplicit=\" + String(ignoredExplicit)\n        + \" tinyShrinkProtected=\" + String(!!(fitDebug && fitDebug.tinyShrinkProtected))\n        + \" pantallaDownscaleBlocked=\" + String(!!(fitDebug && fitDebug.pantallaDownscaleBlocked))\n      );\n      if (dominantText) {\n        flatLines.push(\n          \"dominantText hSecRatio=\" + String(dominantText.heightSecRatio)\n          + \" hViewportRatio=\" + String(dominantText.heightViewportRatio)\n          + \" wSecRatio=\" + String(dominantText.widthSecRatio)\n          + \" fontSize=\" + String(dominantText.fontSize || \"\")\n          + \" lineHeight=\" + String(dominantText.lineHeight || \"\")\n          + \" sample='\" + String(dominantText.textSample || \"\") + \"'\"\n        );\n      } else {\n        flatLines.push(\"dominantText none\");\n      }\n      for (var te=0; te<topElements.length; te++){\n        var e = topElements[te];\n        flatLines.push(\n          \"el#\" + String(te + 1)\n          + \" kind=\" + String(e.kind || \"\")\n          + \" wVp=\" + String(e.widthViewportRatio)\n          + \" hVp=\" + String(e.heightViewportRatio)\n          + \" topSec=\" + String(e.topSecRatio)\n          + \" bottomSec=\" + String(e.bottomSecRatio)\n          + (e.sample ? (\" sample='\" + String(e.sample) + \"'\") : \"\")\n        );\n      }\n      mslLog(\"section:fitScale:pantalla:flat\", flatLines.join(\"\\\\n\"));\n\n      mslLog(\"section:fitScale:pantalla\", {\n        secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\n        secW: +Number(secRectNow.width || 0).toFixed(1),\n        secH: +Number(secRectNow.height || 0).toFixed(1),\n        viewport: {\n          width: +Number(viewportW || 0).toFixed(1),\n          height: +Number(viewportH || 0).toFixed(1)\n        },\n        displayContext: {\n          mobileViewport: mobileViewport,\n          desktopMobilePreview: desktopMobilePreview,\n          mobileUA: mobileUA,\n          coarsePointer: coarsePointer,\n          touchPoints: touchPoints\n        },\n        preserveBottomGap: +preserveBottomGap.toFixed(1),\n        totalNodes: totalNodes,\n        fitNodes: fitNodesCount,\n        textNodesAll: textAll,\n        textNodesFit: textFit,\n        ignoredBleed: ignoredBleed,\n        ignoredExplicit: ignoredExplicit,\n        coverageFit: +coverageFit.toFixed(3),\n        coverageAll: coverageAll == null ? null : +coverageAll.toFixed(3),\n        fitBounds: {\n          width: +Number(bounds.width || 0).toFixed(1),\n          height: +Number(bounds.height || 0).toFixed(1),\n          maxBottom: +Number(bounds.maxBottom || 0).toFixed(1)\n        },\n        allBounds: boundsAll ? {\n          width: +Number(boundsAll.width || 0).toFixed(1),\n          height: +Number(boundsAll.height || 0).toFixed(1),\n          maxBottom: +Number(boundsAll.maxBottom || 0).toFixed(1)\n        } : null,\n        fitDebug: fitDebug ? {\n          targetCoverage: +Number(fitDebug.targetCoverage || 0).toFixed(3),\n          minFillForUpscale: +Number(fitDebug.minFillForUpscale || 0).toFixed(3),\n          coverage: +Number(fitDebug.coverage || 0).toFixed(3),\n          initialScale: +Number(fitDebug.initialScale || 0).toFixed(3),\n          maxScaleByWidth: fitDebug.maxScaleByWidth == null ? null : +Number(fitDebug.maxScaleByWidth).toFixed(3),\n          maxScaleByHeight: fitDebug.maxScaleByHeight == null ? null : +Number(fitDebug.maxScaleByHeight).toFixed(3),\n          scaleAfterWidthClamp: fitDebug.scaleAfterWidthClamp == null ? null : +Number(fitDebug.scaleAfterWidthClamp).toFixed(3),\n          scaleAfterHeightClamp: fitDebug.scaleAfterHeightClamp == null ? null : +Number(fitDebug.scaleAfterHeightClamp).toFixed(3),\n          tinyShrinkProtected: !!fitDebug.tinyShrinkProtected,\n          pantallaDownscaleBlocked: !!fitDebug.pantallaDownscaleBlocked\n        } : null,\n        appliedScale: +Number(scale || 1).toFixed(3),\n        dominantText: dominantText,\n        topElements: topElements\n      });\n    }\n\n    sec.setAttribute(\"data-msl-fit-scale\", String(+scale.toFixed(3)));\n    mslLog(\"section:fitScale\", {\n      secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\n      mode: secModo,\n      nodes: bounds.count,\n      coverage: +(bounds.width / Math.max(1, sec.getBoundingClientRect().width || 0)).toFixed(3),\n      boxW: +bounds.width.toFixed(1),\n      boxH: +bounds.height.toFixed(1),\n      scale: +scale.toFixed(3),\n      preserveBottomGap: +preserveBottomGap.toFixed(1),\n      scaledBottomGap: +((preserveBottomGap || 0) * scale).toFixed(1),\n      neededHeight: neededHeight\n    });\n\n    return {\n      scale: scale,\n      neededHeight: neededHeight,\n      bounds: bounds\n    };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyYlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGZpdFNjYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHNcbmV4cG9ydCBmdW5jdGlvbiBqc0ZpdFNjYWxlQmxvY2soKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgZnVuY3Rpb24gZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCl7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctdHJhbnNmb3JtXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIiwgZWwuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLW9yaWdpblwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctb3JpZ2luXCIsIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiB8fCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlRml0U2NhbGVCYXNlbGluZShlbCl7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoZWwpO1xuICAgIHZhciBiYXNlVHJhbnNmb3JtID0gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctdHJhbnNmb3JtXCIpIHx8IFwiXCI7XG4gICAgdmFyIGJhc2VPcmlnaW4gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy1vcmlnaW5cIikgfHwgXCJcIjtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICAgIGlmIChiYXNlT3JpZ2luKSBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBiYXNlT3JpZ2luO1xuICAgIGVsc2UgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2Zvcm0tb3JpZ2luXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlFbGVtZW50Rml0U2NhbGUoZWwsIHNjYWxlKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCk7XG4gICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikgfHwgXCJcIjtcbiAgICB2YXIgbmV4dCA9IGJhc2VUcmFuc2Zvcm0gPyAoYmFzZVRyYW5zZm9ybSArIFwiIHNjYWxlKFwiICsgc2NhbGUgKyBcIilcIikgOiAoXCJzY2FsZShcIiArIHNjYWxlICsgXCIpXCIpO1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IG5leHQ7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFNlY3Rpb25GaXRTY2FsZShfc2VjLCBjb250ZW50LCBibGVlZCl7XG4gICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoY29udGVudCk7XG4gICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlcyl7XG4gICAgaWYgKCFzZWMgfHwgIW5vZGVzIHx8ICFub2Rlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBtaW5MZWZ0ID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblRvcCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhSaWdodCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4Qm90dG9tID0gLUluZmluaXR5O1xuICAgIHZhciB2YWxpZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgICB2YXIgcnIgPSByZWxSZWN0KG5vZGUsIHNlYyk7XG4gICAgICB2YXIgdyA9IE51bWJlcihyci53aWR0aCB8fCAwKTtcbiAgICAgIHZhciBoID0gTnVtYmVyKHJyLmhlaWdodCB8fCAwKTtcbiAgICAgIGlmICh3IDw9IDAuNSAmJiBoIDw9IDAuNSkgY29udGludWU7XG5cbiAgICAgIHZhciBsID0gTnVtYmVyKHJyLmxlZnQgfHwgMCk7XG4gICAgICB2YXIgdCA9IE51bWJlcihyci50b3AgfHwgMCk7XG4gICAgICB2YXIgciA9IGwgKyBNYXRoLm1heCgwLCB3KTtcbiAgICAgIHZhciBiID0gdCArIE1hdGgubWF4KDAsIGgpO1xuXG4gICAgICBpZiAoIWlzRmluaXRlKGwpIHx8ICFpc0Zpbml0ZSh0KSB8fCAhaXNGaW5pdGUocikgfHwgIWlzRmluaXRlKGIpKSBjb250aW51ZTtcblxuICAgICAgbWluTGVmdCA9IE1hdGgubWluKG1pbkxlZnQsIGwpO1xuICAgICAgbWluVG9wID0gTWF0aC5taW4obWluVG9wLCB0KTtcbiAgICAgIG1heFJpZ2h0ID0gTWF0aC5tYXgobWF4UmlnaHQsIHIpO1xuICAgICAgbWF4Qm90dG9tID0gTWF0aC5tYXgobWF4Qm90dG9tLCBiKTtcbiAgICAgIHZhbGlkKys7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCB8fCAhaXNGaW5pdGUobWluTGVmdCkgfHwgIWlzRmluaXRlKG1heFJpZ2h0KSB8fCAhaXNGaW5pdGUobWluVG9wKSB8fCAhaXNGaW5pdGUobWF4Qm90dG9tKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbkxlZnQ6IG1pbkxlZnQsXG4gICAgICBtaW5Ub3A6IG1pblRvcCxcbiAgICAgIG1heFJpZ2h0OiBtYXhSaWdodCxcbiAgICAgIG1heEJvdHRvbTogbWF4Qm90dG9tLFxuICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIG1heFJpZ2h0IC0gbWluTGVmdCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG1heEJvdHRvbSAtIG1pblRvcCksXG4gICAgICBjb3VudDogdmFsaWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUZpdFNjYWxlKHNlYywgYm91bmRzLCBzZWNNb2RvLCBDRkcpe1xuICAgIGlmICghc2VjIHx8ICFib3VuZHMpIHJldHVybiAxO1xuICAgIHZhciBzZWNSZWN0ID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzZWNXID0gTnVtYmVyKHNlY1JlY3Qud2lkdGggfHwgMCk7XG4gICAgdmFyIHNlY0ggPSBOdW1iZXIoc2VjUmVjdC5oZWlnaHQgfHwgMCk7XG4gICAgaWYgKHNlY1cgPD0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGRlYnVnOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRDb3ZlcmFnZSA9IGNsYW1wKE51bWJlcihDRkcuRklUX1RBUkdFVF9XSURUSF9SQVRJTyB8fCAwLjk0KSwgMC43NSwgMC45OSk7XG4gICAgdmFyIG1pbkZpbGxGb3JVcHNjYWxlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfTUlOX0ZJTExfUkFUSU8gfHwgMC45KSwgMC42LCB0YXJnZXRDb3ZlcmFnZSk7XG4gICAgdmFyIG1pblNjYWxlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfTUlOX1NDQUxFIHx8IDAuODgpLCAwLjcsIDEpO1xuICAgIHZhciBtYXhTY2FsZSA9IE1hdGgubWF4KDEsIE51bWJlcihDRkcuRklUX01BWF9TQ0FMRSB8fCAxLjE2KSk7XG5cbiAgICB2YXIgY29udGVudFcgPSBNYXRoLm1heCgxLCBOdW1iZXIoYm91bmRzLndpZHRoIHx8IDApKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBjb250ZW50VyAvIHNlY1c7XG5cbiAgICB2YXIgc2NhbGUgPSAxO1xuICAgIHZhciBkZWJ1ZyA9IHtcbiAgICAgIHNlY1c6IHNlY1csXG4gICAgICBzZWNIOiBzZWNILFxuICAgICAgdGFyZ2V0Q292ZXJhZ2U6IHRhcmdldENvdmVyYWdlLFxuICAgICAgbWluRmlsbEZvclVwc2NhbGU6IG1pbkZpbGxGb3JVcHNjYWxlLFxuICAgICAgbWluU2NhbGU6IG1pblNjYWxlLFxuICAgICAgbWF4U2NhbGU6IG1heFNjYWxlLFxuICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgaW5pdGlhbFNjYWxlOiAxLFxuICAgICAgbWF4U2NhbGVCeVdpZHRoOiBudWxsLFxuICAgICAgbWF4U2NhbGVCeUhlaWdodDogbnVsbCxcbiAgICAgIHNjYWxlQWZ0ZXJXaWR0aENsYW1wOiBudWxsLFxuICAgICAgc2NhbGVBZnRlckhlaWdodENsYW1wOiBudWxsLFxuICAgICAgdGlueVNocmlua1Byb3RlY3RlZDogZmFsc2UsXG4gICAgICBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoY292ZXJhZ2UgPCBtaW5GaWxsRm9yVXBzY2FsZSkge1xuICAgICAgc2NhbGUgPSB0YXJnZXRDb3ZlcmFnZSAvIE1hdGgubWF4KDAuMDEsIGNvdmVyYWdlKTtcbiAgICB9XG4gICAgZGVidWcuaW5pdGlhbFNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAoc2NhbGUgPj0gMSkgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4U2NhbGUpO1xuICAgIGVsc2Ugc2NhbGUgPSBNYXRoLm1heChzY2FsZSwgbWluU2NhbGUpO1xuXG4gICAgLy8gTMOtbWl0ZSBob3Jpem9udGFsIGR1cm8gcG9yIGNlbnRybyB2aXN1YWwuXG4gICAgdmFyIGNlbnRlclggPSBzZWNXIC8gMjtcbiAgICB2YXIgZGlzdExlZnQgPSBNYXRoLm1heCgwLCBjZW50ZXJYIC0gTnVtYmVyKGJvdW5kcy5taW5MZWZ0IHx8IDApKTtcbiAgICB2YXIgZGlzdFJpZ2h0ID0gTWF0aC5tYXgoMCwgTnVtYmVyKGJvdW5kcy5tYXhSaWdodCB8fCAwKSAtIGNlbnRlclgpO1xuICAgIHZhciBtYXhTY2FsZUJ5V2lkdGggPSBJbmZpbml0eTtcbiAgICBpZiAoZGlzdExlZnQgPiAwLjUpIHtcbiAgICAgIG1heFNjYWxlQnlXaWR0aCA9IE1hdGgubWluKG1heFNjYWxlQnlXaWR0aCwgY2VudGVyWCAvIGRpc3RMZWZ0KTtcbiAgICB9XG4gICAgaWYgKGRpc3RSaWdodCA+IDAuNSkge1xuICAgICAgbWF4U2NhbGVCeVdpZHRoID0gTWF0aC5taW4obWF4U2NhbGVCeVdpZHRoLCAoc2VjVyAtIGNlbnRlclgpIC8gZGlzdFJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKG1heFNjYWxlQnlXaWR0aCkgJiYgbWF4U2NhbGVCeVdpZHRoID4gMCkge1xuICAgICAgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4U2NhbGVCeVdpZHRoKTtcbiAgICAgIGRlYnVnLm1heFNjYWxlQnlXaWR0aCA9IG1heFNjYWxlQnlXaWR0aDtcbiAgICB9XG4gICAgZGVidWcuc2NhbGVBZnRlcldpZHRoQ2xhbXAgPSBzY2FsZTtcblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIgJiYgc2NhbGUgPCAxICYmIHNjYWxlID4gMC45NCkge1xuICAgICAgLy8gQXZvaWQgc2hyaW5raW5nIFwicGFudGFsbGFcIiBmb3IgdGlueSBvdmVyZmxvd3M7IHByZXNlcnZlIHZpc3VhbCBpbXBhY3QuXG4gICAgICBzY2FsZSA9IDE7XG4gICAgICBkZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBFbiBtb2RvIHBhbnRhbGxhIG5vIGRlamFtb3MgcXVlIGVsIGNvbnRlbmlkbyBzZSByZWNvcnRlIHBvciBhbHR1cmEuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzZWNIID4gMSkge1xuICAgICAgdmFyIG1heEJvdHRvbSA9IE51bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApO1xuICAgICAgaWYgKG1heEJvdHRvbSA+IDEpIHtcbiAgICAgICAgdmFyIG1heFNjYWxlQnlIZWlnaHQgPSBzZWNIIC8gbWF4Qm90dG9tO1xuICAgICAgICBpZiAoaXNGaW5pdGUobWF4U2NhbGVCeUhlaWdodCkgJiYgbWF4U2NhbGVCeUhlaWdodCA+IDApIHtcbiAgICAgICAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZUJ5SGVpZ2h0KTtcbiAgICAgICAgICBkZWJ1Zy5tYXhTY2FsZUJ5SGVpZ2h0ID0gbWF4U2NhbGVCeUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1Zy5zY2FsZUFmdGVySGVpZ2h0Q2xhbXAgPSBzY2FsZTtcblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIgJiYgc2NhbGUgPCAxKSB7XG4gICAgICAvLyBQYW50YWxsYSBzZWN0aW9ucyBhbHJlYWR5IGhhdmUgdGhlaXIgb3duIHZpZXdwb3J0LWZpdCBsb2dpYy5cbiAgICAgIC8vIEF2b2lkIGFkZGl0aW9uYWwgZG93bnNjYWxlIGhlcmUgdG8ga2VlcCBoZXJvIHRleHQgcmVhZGFibGUuXG4gICAgICBzY2FsZSA9IDE7XG4gICAgICBkZWJ1Zy5wYW50YWxsYURvd25zY2FsZUJsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUoc2NhbGUpIHx8IHNjYWxlIDw9IDApIHNjYWxlID0gMTtcbiAgICBpZiAoTWF0aC5hYnMoc2NhbGUgLSAxKSA8IDAuMDIpIHNjYWxlID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgZGVidWc6IGRlYnVnXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5U2VjdGlvbkZpdFNjYWxlKHNlYywgY29udGVudCwgYmxlZWQsIG5vZGVzQWxsLCBzZWNNb2RvLCBDRkcsIG1ldGEsIG9wdHMpe1xuICAgIGlmICghc2VjIHx8ICFjb250ZW50KSB7XG4gICAgICByZXR1cm4geyBzY2FsZTogMSwgbmVlZGVkSGVpZ2h0OiAwLCBib3VuZHM6IG51bGwgfTtcbiAgICB9XG5cbiAgICBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGNvbnRlbnQpO1xuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICAgIHZhciBwcmVzZXJ2ZUJvdHRvbUdhcCA9IDA7XG4gICAgaWYgKG9wdHMgJiYgTnVtYmVyLmlzRmluaXRlKG9wdHMucHJlc2VydmVCb3R0b21HYXApKSB7XG4gICAgICBwcmVzZXJ2ZUJvdHRvbUdhcCA9IE1hdGgubWF4KDAsIE51bWJlcihvcHRzLnByZXNlcnZlQm90dG9tR2FwKSk7XG4gICAgfVxuXG4gICAgdmFyIGZpdE5vZGVzID0gKG5vZGVzQWxsIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBmaXRNb2RlID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZml0TW9kZSA9PT0gXCJpZ25vcmVcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG5vZGUuY2xvc2VzdCAmJiBub2RlLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBib3VuZHMgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIGZpdE5vZGVzKTtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgYm91bmRzID0gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlc0FsbCB8fCBbXSk7XG4gICAgfVxuICAgIGlmICghYm91bmRzKSB7XG4gICAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShjb250ZW50KTtcbiAgICAgIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGJsZWVkKTtcbiAgICAgIHNlYy5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtc2NhbGVcIiwgXCIxXCIpO1xuICAgICAgcmV0dXJuIHsgc2NhbGU6IDEsIG5lZWRlZEhlaWdodDogMCwgYm91bmRzOiBudWxsIH07XG4gICAgfVxuXG4gICAgdmFyIGZpdFJlc3VsdCA9IGNvbXB1dGVGaXRTY2FsZShzZWMsIGJvdW5kcywgc2VjTW9kbywgQ0ZHKTtcbiAgICB2YXIgc2NhbGUgPSAoZml0UmVzdWx0ICYmIE51bWJlci5pc0Zpbml0ZShmaXRSZXN1bHQuc2NhbGUpKSA/IGZpdFJlc3VsdC5zY2FsZSA6IDE7XG4gICAgdmFyIGZpdERlYnVnID0gZml0UmVzdWx0ICYmIGZpdFJlc3VsdC5kZWJ1ZyA/IGZpdFJlc3VsdC5kZWJ1ZyA6IG51bGw7XG4gICAgYXBwbHlFbGVtZW50Rml0U2NhbGUoY29udGVudCwgc2NhbGUpO1xuICAgIGFwcGx5RWxlbWVudEZpdFNjYWxlKGJsZWVkLCBzY2FsZSk7XG5cbiAgICB2YXIgbmVlZGVkSGVpZ2h0ID0gMDtcbiAgICBpZiAoc2VjTW9kbyAhPT0gXCJwYW50YWxsYVwiKSB7XG4gICAgICB2YXIgbWF4Qm90dG9tV2l0aEdhcCA9IE51bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApICsgcHJlc2VydmVCb3R0b21HYXA7XG4gICAgICBuZWVkZWRIZWlnaHQgPSBNYXRoLmNlaWwobWF4Qm90dG9tV2l0aEdhcCAqIHNjYWxlICsgKENGRy5QQURfQk9UIHx8IDApKTtcbiAgICB9XG5cbiAgICBpZiAoc2VjTW9kbyA9PT0gXCJwYW50YWxsYVwiKSB7XG4gICAgICB2YXIgc2VjUmVjdE5vdyA9IHNlYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB2diA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbiAgICAgIHZhciB2aWV3cG9ydFcgPSAodnYgJiYgdnYud2lkdGgpID8gdnYud2lkdGggOiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDApO1xuICAgICAgdmFyIHZpZXdwb3J0SCA9ICh2diAmJiB2di5oZWlnaHQpID8gdnYuaGVpZ2h0IDogKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDApO1xuICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICAgICAgdmFyIG1vYmlsZVVBID0gL0FuZHJvaWR8aVBob25lfGlQYWR8aVBvZHxNb2JpbGUvaS50ZXN0KHVhKTtcbiAgICAgIHZhciB0b3VjaFBvaW50cyA9IE51bWJlcihuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgMCk7XG4gICAgICB2YXIgY29hcnNlUG9pbnRlciA9IGZhbHNlO1xuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHRyeSB7IGNvYXJzZVBvaW50ZXIgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwb2ludGVyOiBjb2Fyc2UpXCIpLm1hdGNoZXM7IH0gY2F0Y2goX2UpIHt9XG4gICAgICB9XG4gICAgICB2YXIgbW9iaWxlVmlld3BvcnQgPSB2aWV3cG9ydFcgPD0gNzY3O1xuICAgICAgdmFyIGRlc2t0b3BNb2JpbGVQcmV2aWV3ID0gbW9iaWxlVmlld3BvcnQgJiYgIW1vYmlsZVVBO1xuXG4gICAgICB2YXIgYm91bmRzQWxsID0gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlc0FsbCB8fCBbXSk7XG4gICAgICB2YXIgdG90YWxOb2RlcyA9IChub2Rlc0FsbCB8fCBbXSkubGVuZ3RoO1xuICAgICAgdmFyIGZpdE5vZGVzQ291bnQgPSBmaXROb2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgdGV4dEFsbCA9IDA7XG4gICAgICB2YXIgdGV4dEZpdCA9IDA7XG4gICAgICB2YXIgaWdub3JlZEJsZWVkID0gMDtcbiAgICAgIHZhciBpZ25vcmVkRXhwbGljaXQgPSAwO1xuICAgICAgdmFyIGRvbWluYW50VGV4dCA9IG51bGw7XG4gICAgICB2YXIgZG9taW5hbnRUZXh0SCA9IC0xO1xuICAgICAgdmFyIGVsZW1lbnRSb3dzID0gW107XG5cbiAgICAgIGZvciAodmFyIG5pPTA7IG5pPHRvdGFsTm9kZXM7IG5pKyspe1xuICAgICAgICB2YXIgbm9kZUFsbCA9IG5vZGVzQWxsW25pXTtcbiAgICAgICAgaWYgKCFub2RlQWxsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZml0TW9kZUFsbCA9IChub2RlQWxsLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWZpdFwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZml0TW9kZUFsbCA9PT0gXCJpZ25vcmVcIikgaWdub3JlZEV4cGxpY2l0Kys7XG4gICAgICAgIGlmIChub2RlQWxsLmNsb3Nlc3QgJiYgbm9kZUFsbC5jbG9zZXN0KFwiLnNlYy1ibGVlZFwiKSkgaWdub3JlZEJsZWVkKys7XG5cbiAgICAgICAgdmFyIHJyTm9kZSA9IHJlbFJlY3Qobm9kZUFsbCwgc2VjKTtcbiAgICAgICAgdmFyIG5vZGVXID0gTnVtYmVyKHJyTm9kZS53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVIID0gTnVtYmVyKHJyTm9kZS5oZWlnaHQgfHwgMCk7XG4gICAgICAgIHZhciBub2RlVG9wID0gTnVtYmVyKHJyTm9kZS50b3AgfHwgMCk7XG4gICAgICAgIHZhciBub2RlQm90dG9tID0gbm9kZVRvcCArIG5vZGVIO1xuICAgICAgICB2YXIgaXNUZXh0QWxsID0gKG5vZGVBbGwuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgIGlmIChpc1RleHRBbGwpIHRleHRBbGwrKztcblxuICAgICAgICBpZiAobm9kZVcgPiAwLjUgfHwgbm9kZUggPiAwLjUpIHtcbiAgICAgICAgICB2YXIga2luZEFsbCA9IGlzVGV4dEFsbCA/IFwidGV4dG9cIiA6IFN0cmluZygobm9kZUFsbC50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGVsZW1lbnRSb3dzLnB1c2goe1xuICAgICAgICAgICAga2luZDoga2luZEFsbCxcbiAgICAgICAgICAgIHdpZHRoOiBub2RlVyxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZUgsXG4gICAgICAgICAgICB0b3A6IG5vZGVUb3AsXG4gICAgICAgICAgICBib3R0b206IG5vZGVCb3R0b20sXG4gICAgICAgICAgICBhcmVhOiBub2RlVyAqIG5vZGVILFxuICAgICAgICAgICAgdGV4dFNhbXBsZTogaXNUZXh0QWxsXG4gICAgICAgICAgICAgID8gKChub2RlQWxsLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA3MClcbiAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVGV4dEFsbCkgY29udGludWU7XG4gICAgICAgIGlmIChub2RlSCA8PSBkb21pbmFudFRleHRIKSBjb250aW51ZTtcbiAgICAgICAgZG9taW5hbnRUZXh0SCA9IG5vZGVIO1xuICAgICAgICB2YXIgY3NUeHQgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGVBbGwpO1xuICAgICAgICBkb21pbmFudFRleHQgPSB7XG4gICAgICAgICAgdG9wOiArbm9kZVRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGxlZnQ6ICtOdW1iZXIocnJOb2RlLmxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICB3aWR0aDogK25vZGVXLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArbm9kZUgudG9GaXhlZCgxKSxcbiAgICAgICAgICBib3R0b206ICtub2RlQm90dG9tLnRvRml4ZWQoMSksXG4gICAgICAgICAgd2lkdGhTZWNSYXRpbzogc2VjUmVjdE5vdy53aWR0aCA+IDEgPyArKG5vZGVXIC8gc2VjUmVjdE5vdy53aWR0aCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0U2VjUmF0aW86IHNlY1JlY3ROb3cuaGVpZ2h0ID4gMSA/ICsobm9kZUggLyBzZWNSZWN0Tm93LmhlaWdodCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgd2lkdGhWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydFcgPiAxID8gKyhub2RlVyAvIHZpZXdwb3J0VykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0Vmlld3BvcnRSYXRpbzogdmlld3BvcnRIID4gMSA/ICsobm9kZUggLyB2aWV3cG9ydEgpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgIGZvbnRTaXplOiBjc1R4dC5mb250U2l6ZSB8fCBcIlwiLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IGNzVHh0LmxpbmVIZWlnaHQgfHwgXCJcIixcbiAgICAgICAgICB0ZXh0QWxpZ246IGNzVHh0LnRleHRBbGlnbiB8fCBcIlwiLFxuICAgICAgICAgIHRyYW5zZm9ybTogKG5vZGVBbGwuc3R5bGUgJiYgbm9kZUFsbC5zdHlsZS50cmFuc2Zvcm0pID8gbm9kZUFsbC5zdHlsZS50cmFuc2Zvcm0gOiBcIlwiLFxuICAgICAgICAgIHRleHRTYW1wbGU6ICgobm9kZUFsbC50ZXh0Q29udGVudCB8fCBcIlwiKS50cmltKCkpLnJlcGxhY2UoL1xcXFxzKy9nLCBcIiBcIikuc2xpY2UoMCwgOTApXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGZpPTA7IGZpPGZpdE5vZGVzLmxlbmd0aDsgZmkrKyl7XG4gICAgICAgIHZhciBmaXROb2RlID0gZml0Tm9kZXNbZmldO1xuICAgICAgICBpZiAoKGZpdE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHRGaXQrKztcbiAgICAgIH1cblxuICAgICAgdmFyIHRvcEVsZW1lbnRzID0gZWxlbWVudFJvd3NcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIChiLmFyZWEgfHwgMCkgLSAoYS5hcmVhIHx8IDApOyB9KVxuICAgICAgICAuc2xpY2UoMCwgNilcbiAgICAgICAgLm1hcChmdW5jdGlvbihyb3cpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiByb3cua2luZCxcbiAgICAgICAgICAgIHdpZHRoOiArTnVtYmVyKHJvdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKHJvdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHdpZHRoU2VjUmF0aW86IHNlY1JlY3ROb3cud2lkdGggPiAxID8gKygocm93LndpZHRoIHx8IDApIC8gc2VjUmVjdE5vdy53aWR0aCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBoZWlnaHRTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKygocm93LmhlaWdodCB8fCAwKSAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIHdpZHRoVmlld3BvcnRSYXRpbzogdmlld3BvcnRXID4gMSA/ICsoKHJvdy53aWR0aCB8fCAwKSAvIHZpZXdwb3J0VykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBoZWlnaHRWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydEggPiAxID8gKygocm93LmhlaWdodCB8fCAwKSAvIHZpZXdwb3J0SCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICB0b3BTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKygocm93LnRvcCB8fCAwKSAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGJvdHRvbVNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cuYm90dG9tIHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgc2FtcGxlOiByb3cudGV4dFNhbXBsZSB8fCBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHZhciBjb3ZlcmFnZUZpdCA9IGJvdW5kcy53aWR0aCAvIE1hdGgubWF4KDEsIHNlY1JlY3ROb3cud2lkdGggfHwgMCk7XG4gICAgICB2YXIgY292ZXJhZ2VBbGwgPSBib3VuZHNBbGwgPyAoYm91bmRzQWxsLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjUmVjdE5vdy53aWR0aCB8fCAwKSkgOiBudWxsO1xuXG4gICAgICB2YXIgZmxhdExpbmVzID0gW107XG4gICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgXCJzZWM9XCIgKyBTdHJpbmcobWV0YSAmJiBOdW1iZXIuaXNGaW5pdGUobWV0YS5zZWNJbmRleCkgPyBtZXRhLnNlY0luZGV4IDogLTEpXG4gICAgICAgICsgXCIgdmlld3BvcnQ9XCIgKyAoK051bWJlcih2aWV3cG9ydFcgfHwgMCkudG9GaXhlZCgxKSkgKyBcInhcIiArICgrTnVtYmVyKHZpZXdwb3J0SCB8fCAwKS50b0ZpeGVkKDEpKVxuICAgICAgICArIFwiIHNlYz1cIiArICgrTnVtYmVyKHNlY1JlY3ROb3cud2lkdGggfHwgMCkudG9GaXhlZCgxKSkgKyBcInhcIiArICgrTnVtYmVyKHNlY1JlY3ROb3cuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSkpXG4gICAgICAgICsgXCIgbW9iaWxlVmlld3BvcnQ9XCIgKyBTdHJpbmcobW9iaWxlVmlld3BvcnQpXG4gICAgICAgICsgXCIgZGVza3RvcE1vYmlsZVByZXZpZXc9XCIgKyBTdHJpbmcoZGVza3RvcE1vYmlsZVByZXZpZXcpXG4gICAgICAgICsgXCIgbW9iaWxlVUE9XCIgKyBTdHJpbmcobW9iaWxlVUEpXG4gICAgICAgICsgXCIgY29hcnNlUG9pbnRlcj1cIiArIFN0cmluZyhjb2Fyc2VQb2ludGVyKVxuICAgICAgICArIFwiIHRvdWNoUG9pbnRzPVwiICsgU3RyaW5nKHRvdWNoUG9pbnRzKVxuICAgICAgKTtcbiAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICBcImZpdCBzY2FsZT1cIiArICgrTnVtYmVyKHNjYWxlIHx8IDEpLnRvRml4ZWQoMykpXG4gICAgICAgICsgXCIgY292ZXJhZ2VGaXQ9XCIgKyAoK2NvdmVyYWdlRml0LnRvRml4ZWQoMykpXG4gICAgICAgICsgXCIgY292ZXJhZ2VBbGw9XCIgKyAoY292ZXJhZ2VBbGwgPT0gbnVsbCA/IFwibnVsbFwiIDogU3RyaW5nKCtjb3ZlcmFnZUFsbC50b0ZpeGVkKDMpKSlcbiAgICAgICAgKyBcIiBub2Rlcz1cIiArIFN0cmluZyhmaXROb2Rlc0NvdW50KSArIFwiL1wiICsgU3RyaW5nKHRvdGFsTm9kZXMpXG4gICAgICAgICsgXCIgaWdub3JlZEJsZWVkPVwiICsgU3RyaW5nKGlnbm9yZWRCbGVlZClcbiAgICAgICAgKyBcIiBpZ25vcmVkRXhwbGljaXQ9XCIgKyBTdHJpbmcoaWdub3JlZEV4cGxpY2l0KVxuICAgICAgICArIFwiIHRpbnlTaHJpbmtQcm90ZWN0ZWQ9XCIgKyBTdHJpbmcoISEoZml0RGVidWcgJiYgZml0RGVidWcudGlueVNocmlua1Byb3RlY3RlZCkpXG4gICAgICAgICsgXCIgcGFudGFsbGFEb3duc2NhbGVCbG9ja2VkPVwiICsgU3RyaW5nKCEhKGZpdERlYnVnICYmIGZpdERlYnVnLnBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZCkpXG4gICAgICApO1xuICAgICAgaWYgKGRvbWluYW50VGV4dCkge1xuICAgICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgICBcImRvbWluYW50VGV4dCBoU2VjUmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmhlaWdodFNlY1JhdGlvKVxuICAgICAgICAgICsgXCIgaFZpZXdwb3J0UmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmhlaWdodFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiB3U2VjUmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LndpZHRoU2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBmb250U2l6ZT1cIiArIFN0cmluZyhkb21pbmFudFRleHQuZm9udFNpemUgfHwgXCJcIilcbiAgICAgICAgICArIFwiIGxpbmVIZWlnaHQ9XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmxpbmVIZWlnaHQgfHwgXCJcIilcbiAgICAgICAgICArIFwiIHNhbXBsZT0nXCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LnRleHRTYW1wbGUgfHwgXCJcIikgKyBcIidcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdExpbmVzLnB1c2goXCJkb21pbmFudFRleHQgbm9uZVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHRlPTA7IHRlPHRvcEVsZW1lbnRzLmxlbmd0aDsgdGUrKyl7XG4gICAgICAgIHZhciBlID0gdG9wRWxlbWVudHNbdGVdO1xuICAgICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgICBcImVsI1wiICsgU3RyaW5nKHRlICsgMSlcbiAgICAgICAgICArIFwiIGtpbmQ9XCIgKyBTdHJpbmcoZS5raW5kIHx8IFwiXCIpXG4gICAgICAgICAgKyBcIiB3VnA9XCIgKyBTdHJpbmcoZS53aWR0aFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiBoVnA9XCIgKyBTdHJpbmcoZS5oZWlnaHRWaWV3cG9ydFJhdGlvKVxuICAgICAgICAgICsgXCIgdG9wU2VjPVwiICsgU3RyaW5nKGUudG9wU2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBib3R0b21TZWM9XCIgKyBTdHJpbmcoZS5ib3R0b21TZWNSYXRpbylcbiAgICAgICAgICArIChlLnNhbXBsZSA/IChcIiBzYW1wbGU9J1wiICsgU3RyaW5nKGUuc2FtcGxlKSArIFwiJ1wiKSA6IFwiXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmZpdFNjYWxlOnBhbnRhbGxhOmZsYXRcIiwgZmxhdExpbmVzLmpvaW4oXCJcXFxcblwiKSk7XG5cbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGU6cGFudGFsbGFcIiwge1xuICAgICAgICBzZWNJbmRleDogbWV0YSAmJiBOdW1iZXIuaXNGaW5pdGUobWV0YS5zZWNJbmRleCkgPyBtZXRhLnNlY0luZGV4IDogLTEsXG4gICAgICAgIHNlY1c6ICtOdW1iZXIoc2VjUmVjdE5vdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICBzZWNIOiArTnVtYmVyKHNlY1JlY3ROb3cuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIodmlld3BvcnRXIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKHZpZXdwb3J0SCB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXlDb250ZXh0OiB7XG4gICAgICAgICAgbW9iaWxlVmlld3BvcnQ6IG1vYmlsZVZpZXdwb3J0LFxuICAgICAgICAgIGRlc2t0b3BNb2JpbGVQcmV2aWV3OiBkZXNrdG9wTW9iaWxlUHJldmlldyxcbiAgICAgICAgICBtb2JpbGVVQTogbW9iaWxlVUEsXG4gICAgICAgICAgY29hcnNlUG9pbnRlcjogY29hcnNlUG9pbnRlcixcbiAgICAgICAgICB0b3VjaFBvaW50czogdG91Y2hQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtwcmVzZXJ2ZUJvdHRvbUdhcC50b0ZpeGVkKDEpLFxuICAgICAgICB0b3RhbE5vZGVzOiB0b3RhbE5vZGVzLFxuICAgICAgICBmaXROb2RlczogZml0Tm9kZXNDb3VudCxcbiAgICAgICAgdGV4dE5vZGVzQWxsOiB0ZXh0QWxsLFxuICAgICAgICB0ZXh0Tm9kZXNGaXQ6IHRleHRGaXQsXG4gICAgICAgIGlnbm9yZWRCbGVlZDogaWdub3JlZEJsZWVkLFxuICAgICAgICBpZ25vcmVkRXhwbGljaXQ6IGlnbm9yZWRFeHBsaWNpdCxcbiAgICAgICAgY292ZXJhZ2VGaXQ6ICtjb3ZlcmFnZUZpdC50b0ZpeGVkKDMpLFxuICAgICAgICBjb3ZlcmFnZUFsbDogY292ZXJhZ2VBbGwgPT0gbnVsbCA/IG51bGwgOiArY292ZXJhZ2VBbGwudG9GaXhlZCgzKSxcbiAgICAgICAgZml0Qm91bmRzOiB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIoYm91bmRzLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKGJvdW5kcy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBtYXhCb3R0b206ICtOdW1iZXIoYm91bmRzLm1heEJvdHRvbSB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0sXG4gICAgICAgIGFsbEJvdW5kczogYm91bmRzQWxsID8ge1xuICAgICAgICAgIHdpZHRoOiArTnVtYmVyKGJvdW5kc0FsbC53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIGhlaWdodDogK051bWJlcihib3VuZHNBbGwuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgbWF4Qm90dG9tOiArTnVtYmVyKGJvdW5kc0FsbC5tYXhCb3R0b20gfHwgMCkudG9GaXhlZCgxKVxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgZml0RGVidWc6IGZpdERlYnVnID8ge1xuICAgICAgICAgIHRhcmdldENvdmVyYWdlOiArTnVtYmVyKGZpdERlYnVnLnRhcmdldENvdmVyYWdlIHx8IDApLnRvRml4ZWQoMyksXG4gICAgICAgICAgbWluRmlsbEZvclVwc2NhbGU6ICtOdW1iZXIoZml0RGVidWcubWluRmlsbEZvclVwc2NhbGUgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBjb3ZlcmFnZTogK051bWJlcihmaXREZWJ1Zy5jb3ZlcmFnZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIGluaXRpYWxTY2FsZTogK051bWJlcihmaXREZWJ1Zy5pbml0aWFsU2NhbGUgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBtYXhTY2FsZUJ5V2lkdGg6IGZpdERlYnVnLm1heFNjYWxlQnlXaWR0aCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcubWF4U2NhbGVCeVdpZHRoKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIG1heFNjYWxlQnlIZWlnaHQ6IGZpdERlYnVnLm1heFNjYWxlQnlIZWlnaHQgPT0gbnVsbCA/IG51bGwgOiArTnVtYmVyKGZpdERlYnVnLm1heFNjYWxlQnlIZWlnaHQpLnRvRml4ZWQoMyksXG4gICAgICAgICAgc2NhbGVBZnRlcldpZHRoQ2xhbXA6IGZpdERlYnVnLnNjYWxlQWZ0ZXJXaWR0aENsYW1wID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5zY2FsZUFmdGVyV2lkdGhDbGFtcCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBzY2FsZUFmdGVySGVpZ2h0Q2xhbXA6IGZpdERlYnVnLnNjYWxlQWZ0ZXJIZWlnaHRDbGFtcCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcuc2NhbGVBZnRlckhlaWdodENsYW1wKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIHRpbnlTaHJpbmtQcm90ZWN0ZWQ6ICEhZml0RGVidWcudGlueVNocmlua1Byb3RlY3RlZCxcbiAgICAgICAgICBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ6ICEhZml0RGVidWcucGFudGFsbGFEb3duc2NhbGVCbG9ja2VkXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBhcHBsaWVkU2NhbGU6ICtOdW1iZXIoc2NhbGUgfHwgMSkudG9GaXhlZCgzKSxcbiAgICAgICAgZG9taW5hbnRUZXh0OiBkb21pbmFudFRleHQsXG4gICAgICAgIHRvcEVsZW1lbnRzOiB0b3BFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBTdHJpbmcoK3NjYWxlLnRvRml4ZWQoMykpKTtcbiAgICBtc2xMb2coXCJzZWN0aW9uOmZpdFNjYWxlXCIsIHtcbiAgICAgIHNlY0luZGV4OiBtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSxcbiAgICAgIG1vZGU6IHNlY01vZG8sXG4gICAgICBub2RlczogYm91bmRzLmNvdW50LFxuICAgICAgY292ZXJhZ2U6ICsoYm91bmRzLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IDApKS50b0ZpeGVkKDMpLFxuICAgICAgYm94VzogK2JvdW5kcy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgYm94SDogK2JvdW5kcy5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgIHNjYWxlOiArc2NhbGUudG9GaXhlZCgzKSxcbiAgICAgIHByZXNlcnZlQm90dG9tR2FwOiArcHJlc2VydmVCb3R0b21HYXAudG9GaXhlZCgxKSxcbiAgICAgIHNjYWxlZEJvdHRvbUdhcDogKygocHJlc2VydmVCb3R0b21HYXAgfHwgMCkgKiBzY2FsZSkudG9GaXhlZCgxKSxcbiAgICAgIG5lZWRlZEhlaWdodDogbmVlZGVkSGVpZ2h0XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgbmVlZGVkSGVpZ2h0OiBuZWVkZWRIZWlnaHQsXG4gICAgICBib3VuZHM6IGJvdW5kc1xuICAgIH07XG4gIH1cbmAudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbImpzRml0U2NhbGVCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* reexport safe */ _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__.buildScript),\n/* harmony export */   normalizeConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts\");\n/* harmony import */ var _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scriptTemplate */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\");\n// functions/src/utils/mobileSmartLayout/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlEQUFpRDtBQUVOO0FBQ0kiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHNcclxuZXhwb3J0IHR5cGUgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5leHBvcnQgeyBub3JtYWxpemVDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcclxuZXhwb3J0IHsgYnVpbGRTY3JpcHQgfSBmcm9tIFwiLi9zY3JpcHRUZW1wbGF0ZVwiO1xyXG4iXSwibmFtZXMiOlsibm9ybWFsaXplQ29uZmlnIiwiYnVpbGRTY3JpcHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/ordering.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsOrderingBlock: () => (/* binding */ jsOrderingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/ordering.ts\nfunction jsOrderingBlock() {\n    return `\n  /**\n   * Ordena CLUSTERS (no items) para lectura mobile.\n   * Devuelve groups (array de columnas/grupos) y mode.\n   *\n   * - three: [colL, colC, colR]\n   * - two:   [left, right]\n   * - rows:  [out] (fila+left)\n   * - one:   [sortedTop]\n   */\n  function orderClustersForMobile(clusters, rootW, CFG){\n    if (!rootW || rootW <= 0) {\n      var o = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n      return { groups: [o], mode: \"one\" };\n    }\n\n    function clusterHasText(c){\n      if (!c || !c.items || !c.items.length) return false;\n      for (var iTxt=0; iTxt<c.items.length; iTxt++){\n        if ((c.items[iTxt].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return true;\n      }\n      return false;\n    }\n\n    function columnHasText(col){\n      if (!col || !col.length) return false;\n      for (var iCol=0; iCol<col.length; iCol++){\n        if (clusterHasText(col[iCol])) return true;\n      }\n      return false;\n    }\n\n    // Un cluster \"invade\" una frontera si queda partido de forma significativa\n    // entre ambos lados de la linea divisoria.\n    function clusterInvadesDivider(c, dividerX){\n      if (!c) return false;\n      var left = Number(c.left || 0);\n      var width = Math.max(0, Number(c.width || 0));\n      var right = left + width;\n      if (width <= 1) return false;\n      if (right <= dividerX || left >= dividerX) return false;\n\n      var partLeft = dividerX - left;\n      var partRight = right - dividerX;\n      var minPart = Math.min(partLeft, partRight);\n      var minRequired = Math.max(22, width * 0.22);\n      return minPart >= minRequired;\n    }\n\n    function dividerInvasionRatio(list, dividerX){\n      if (!list || !list.length) return 0;\n      var invaded = 0;\n      for (var iInv=0; iInv<list.length; iInv++){\n        if (clusterInvadesDivider(list[iInv], dividerX)) invaded++;\n      }\n      return invaded / Math.max(1, list.length);\n    }\n\n    // -------- 0) Intentar 3 columnas claras --------\n    var t1 = rootW / 3;\n    var t2 = (2 * rootW) / 3;\n\n    var colL = [];\n    var colC = [];\n    var colR = [];\n\n    for (var i=0;i<clusters.length;i++){\n      var c = clusters[i];\n      var x = c.cx;\n      if (x < t1) colL.push(c);\n      else if (x < t2) colC.push(c);\n      else colR.push(c);\n    }\n\n    var looksThree =\n      (colL.length >= CFG.MIN_PER_COL_3 && colC.length >= CFG.MIN_PER_COL_3 && colR.length >= CFG.MIN_PER_COL_3);\n    var textColsThree =\n      (columnHasText(colL) ? 1 : 0) +\n      (columnHasText(colC) ? 1 : 0) +\n      (columnHasText(colR) ? 1 : 0);\n    var hasTextSignalThree = textColsThree >= 2;\n    mslLog(\"order:three:candidates\", {\n      rootW: rootW,\n      total: clusters.length,\n      colL: colL.length,\n      colC: colC.length,\n      colR: colR.length,\n      minPerCol3: CFG.MIN_PER_COL_3,\n      textColsThree: textColsThree,\n      hasTextSignalThree: hasTextSignalThree\n    });\n\n    if (looksThree) {\n      var cxs = [];\n      for (var j=0;j<clusters.length;j++) cxs.push(clusters[j].cx);\n      cxs.sort(function(a,b){ return a-b; });\n      var p20 = percentile(cxs, 0.20);\n      var p80 = percentile(cxs, 0.80);\n      var spread = (p80 - p20);\n      mslLog(\"order:three:spread\", {\n        p20: p20,\n        p80: p80,\n        spread: spread,\n        minSpread: rootW * CFG.THREE_COL_SPREAD_RATIO,\n        pass: spread >= rootW * CFG.THREE_COL_SPREAD_RATIO\n      });\n      if (spread < rootW * CFG.THREE_COL_SPREAD_RATIO) looksThree = false;\n    }\n\n    if (looksThree) {\n      var invadeT1 = dividerInvasionRatio(clusters, t1);\n      var invadeT2 = dividerInvasionRatio(clusters, t2);\n      var invadeThree = Math.max(invadeT1, invadeT2);\n      var invasionLimitThree = hasTextSignalThree ? 0.46 : 0.34;\n      mslLog(\"order:three:invasion\", {\n        t1: +t1.toFixed(1),\n        t2: +t2.toFixed(1),\n        invadeT1: +invadeT1.toFixed(3),\n        invadeT2: +invadeT2.toFixed(3),\n        invadeThree: +invadeThree.toFixed(3),\n        limit: +invasionLimitThree.toFixed(3),\n        hasTextSignalThree: hasTextSignalThree,\n        pass: invadeThree <= invasionLimitThree\n      });\n      if (invadeThree > invasionLimitThree) looksThree = false;\n    }\n\n    if (looksThree) {\n      colL.sort(function(a,b){ return a.top - b.top; });\n      colC.sort(function(a,b){ return a.top - b.top; });\n      colR.sort(function(a,b){ return a.top - b.top; });\n      return { groups: [colL, colC, colR], mode: \"three\" };\n    }\n\n    // -------- 1) Intentar 2 columnas claras --------\n    var mid = rootW / 2;\n    var left = [];\n    var right = [];\n\n    for (var k=0;k<clusters.length;k++){\n      var c2 = clusters[k];\n      if (c2.cx < mid) left.push(c2);\n      else right.push(c2);\n    }\n\n    var looksTwo = (left.length >= CFG.MIN_PER_COL_2 && right.length >= CFG.MIN_PER_COL_2);\n    var hasTextSignalTwo = columnHasText(left) && columnHasText(right);\n    mslLog(\"order:two:candidates\", {\n      rootW: rootW,\n      total: clusters.length,\n      left: left.length,\n      right: right.length,\n      minPerCol2: CFG.MIN_PER_COL_2,\n      hasTextSignalTwo: hasTextSignalTwo\n    });\n\n    // Politica para pares (2 clusters):\n    // - par de columnas reales => mode \"two\"\n    // - resto de casos => mode \"one\" (fitCheck decide si reflowea)\n    if (clusters.length === 2) {\n      var cA = clusters[0];\n      var cB = clusters[1];\n\n      function pairStats(c){\n        var text = 0;\n        var non = 0;\n        var force = 0;\n        for (var q=0; q<c.items.length; q++) {\n          var n = c.items[q].node;\n          if ((n.getAttribute(\"data-mobile-center\") || \"\") === \"force\") force++;\n          if ((n.getAttribute(\"data-debug-texto\") || \"\") === \"1\") text++;\n          else non++;\n        }\n        return { text: text, non: non, force: force };\n      }\n\n      var sA = pairStats(cA);\n      var sB = pairStats(cB);\n\n      var topDelta = Math.abs((cA.top || 0) - (cB.top || 0));\n      var xOverlap = Math.max(0, Math.min((cA.left + cA.width), (cB.left + cB.width)) - Math.max(cA.left, cB.left));\n      var minWPair = Math.max(1, Math.min((cA.width || 0), (cB.width || 0)));\n      var xOverlapRatio = xOverlap / minWPair;\n      var sideBySide = topDelta <= (CFG.ROW_TOL * 1.5) && xOverlapRatio < 0.25;\n      var pairInvasion = dividerInvasionRatio([cA, cB], mid);\n      var pairInvasionLimit = hasTextSignalTwo ? 0.5 : 0.34;\n\n      var anyForceCenter = (sA.force > 0 || sB.force > 0);\n      var bothMixed = (sA.text > 0 && sA.non > 0 && sB.text > 0 && sB.non > 0);\n      // Señal robusta de \"par de columnas\":\n      // - están lado a lado y pasan split left/right\n      // - y además no son simplemente 2 textos sueltos en una fila\n      var hasColumnSignal =\n        (sA.non > 0 || sB.non > 0) ||\n        ((cA.items && cA.items.length > 1) || (cB.items && cB.items.length > 1));\n\n      if (looksTwo && sideBySide && hasColumnSignal && pairInvasion <= pairInvasionLimit) {\n        var leftPair = (cA.cx <= cB.cx) ? [cA] : [cB];\n        var rightPair = (cA.cx <= cB.cx) ? [cB] : [cA];\n        mslLog(\"order:two:pairPolicy\", {\n          mode: \"two\",\n          reason: \"pairColumns\",\n          topDelta: +topDelta.toFixed(1),\n          xOverlapRatio: +xOverlapRatio.toFixed(3),\n          hasColumnSignal: hasColumnSignal,\n          bothMixed: bothMixed,\n          anyForceCenter: anyForceCenter,\n          pairInvasion: +pairInvasion.toFixed(3),\n          pairInvasionLimit: +pairInvasionLimit.toFixed(3),\n          lefts: [+(cA.left || 0).toFixed(1), +(cB.left || 0).toFixed(1)]\n        });\n        return { groups: [leftPair, rightPair], mode: \"two\" };\n      }\n\n      var pair = clusters.slice().sort(function(a,b){\n        if (Math.abs(a.top - b.top) > 0.5) return a.top - b.top;\n        return a.left - b.left;\n      });\n      mslLog(\"order:two:pairPolicy\", {\n        mode: \"one\",\n        reason: anyForceCenter ? \"forceCenterPair\" : \"pairDefault\",\n        topDelta: +topDelta.toFixed(1),\n        xOverlapRatio: +xOverlapRatio.toFixed(3),\n        sideBySide: sideBySide,\n        bothMixed: bothMixed,\n        anyForceCenter: anyForceCenter,\n        pairInvasion: +pairInvasion.toFixed(3),\n        pairInvasionLimit: +pairInvasionLimit.toFixed(3),\n        tops: pair.map(function(c){ return +c.top.toFixed(1); }),\n        lefts: pair.map(function(c){ return +c.left.toFixed(1); })\n      });\n      return { groups: [pair], mode: \"one\" };\n    }\n    if (looksTwo) {\n      var cxs2 = [];\n      for (var m=0;m<clusters.length;m++) cxs2.push(clusters[m].cx);\n      cxs2.sort(function(a,b){ return a-b; });\n      var p25 = percentile(cxs2, 0.25);\n      var p75 = percentile(cxs2, 0.75);\n      var spread2 = (p75 - p25);\n      mslLog(\"order:two:spread\", {\n        p25: p25,\n        p75: p75,\n        spread: spread2,\n        minSpread: rootW * CFG.TWO_COL_SPREAD_RATIO,\n        pass: spread2 >= rootW * CFG.TWO_COL_SPREAD_RATIO\n      });\n      if (spread2 < rootW * CFG.TWO_COL_SPREAD_RATIO) looksTwo = false;\n    }\n\n    if (looksTwo) {\n      var invadeMid = dividerInvasionRatio(clusters, mid);\n      var invasionLimitTwo = hasTextSignalTwo ? 0.48 : 0.34;\n      mslLog(\"order:two:invasion\", {\n        mid: +mid.toFixed(1),\n        invadeMid: +invadeMid.toFixed(3),\n        limit: +invasionLimitTwo.toFixed(3),\n        hasTextSignalTwo: hasTextSignalTwo,\n        pass: invadeMid <= invasionLimitTwo\n      });\n      if (invadeMid > invasionLimitTwo) looksTwo = false;\n    }\n\n    if (looksTwo) {\n      left.sort(function(a,b){ return a.top - b.top; });\n      right.sort(function(a,b){ return a.top - b.top; });\n      return { groups: [left, right], mode: \"two\" };\n    }\n\n    // -------- 2) Guard tardio: una sola columna visual --------\n    // Se evalua despues de two/three para evitar falsos \"one\" cuando hay\n    // dos columnas reales con varios clusters.\n    if (clusters.length >= 2) {\n      var cxsOne = clusters.map(function(c){ return c.cx; }).sort(function(a,b){ return a-b; });\n      var medianCx = percentile(cxsOne, 0.50);\n      var maxDevCx = 0;\n      for (var s=0; s<clusters.length; s++) {\n        var dev = Math.abs((clusters[s].cx || 0) - medianCx);\n        if (dev > maxDevCx) maxDevCx = dev;\n      }\n\n      var singleColMaxDev = rootW * 0.18;\n      var looksOneCol = maxDevCx <= singleColMaxDev;\n      mslLog(\"order:one:candidates\", {\n        rootW: rootW,\n        total: clusters.length,\n        medianCx: +medianCx.toFixed(1),\n        maxDevCx: +maxDevCx.toFixed(1),\n        maxAllowed: +singleColMaxDev.toFixed(1),\n        pass: looksOneCol,\n        stage: \"postTwoThree\"\n      });\n\n      if (looksOneCol) {\n        var oneCol = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n        return { groups: [oneCol], mode: \"one\" };\n      }\n    }\n\n    // -------- 3) Fallback: filas (top) y dentro por left --------\n    var sorted = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n\n    var rows = [];\n    for (var r=0;r<sorted.length;r++){\n      var c3 = sorted[r];\n      var placed = false;\n\n      for (var rr=0; rr<rows.length; rr++){\n        var row = rows[rr];\n        if (Math.abs(c3.top - row.top) <= CFG.ROW_TOL){\n          row.items.push(c3);\n          row.top = (row.top * (row.items.length - 1) + c3.top) / row.items.length;\n          placed = true;\n          break;\n        }\n      }\n\n      if (!placed) rows.push({ top: c3.top, items: [c3] });\n    }\n\n    rows.sort(function(a,b){ return a.top - b.top; });\n    rows.forEach(function(row){\n      row.items.sort(function(a,b){ return a.left - b.left; });\n    });\n\n    function clusterIsText(c){\n      if (!c || !c.items || !c.items.length) return false;\n      for (var i2=0; i2<c.items.length; i2++){\n        if ((c.items[i2].node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\n      }\n      return true;\n    }\n\n    var out = [];\n    var didInterleave = false;\n    // Caso especial: dos filas simetricas (ej. iconos arriba y textos abajo).\n    // Reordenamos por columna: top1,bottom1,top2,bottom2,...\n    if (rows.length === 2 && rows[0].items.length === rows[1].items.length && rows[0].items.length >= 2) {\n      var topRow = rows[0].items.slice();\n      var botRow = rows[1].items.slice();\n      var topHasNonText = topRow.some(function(c){ return !clusterIsText(c); });\n      var botMostlyText = botRow.filter(function(c){ return clusterIsText(c); }).length >= Math.ceil(botRow.length / 2);\n\n      if (topHasNonText && botMostlyText) {\n        var usedBottom = {};\n        for (var tr=0; tr<topRow.length; tr++){\n          var a = topRow[tr];\n          out.push(a);\n\n          var bestIdx = -1;\n          var bestDist = Infinity;\n          for (var br=0; br<botRow.length; br++){\n            if (usedBottom[br]) continue;\n            var b = botRow[br];\n            var d = Math.abs((a.left || 0) - (b.left || 0));\n            if (d < bestDist) {\n              bestDist = d;\n              bestIdx = br;\n            }\n          }\n          if (bestIdx >= 0) {\n            out.push(botRow[bestIdx]);\n            usedBottom[bestIdx] = true;\n          }\n        }\n        for (var br2=0; br2<botRow.length; br2++){\n          if (!usedBottom[br2]) out.push(botRow[br2]);\n        }\n        didInterleave = true;\n      }\n    }\n\n    if (!didInterleave) {\n      rows.forEach(function(row){\n        for (var z=0; z<row.items.length; z++) out.push(row.items[z]);\n      });\n    }\n    mslLog(\"order:rows:fallback\", {\n      rows: rows.map(function(r){\n        return {\n          top: +r.top.toFixed(1),\n          len: r.items.length,\n          lefts: r.items.map(function(it){ return +it.left.toFixed(1); })\n        };\n      }),\n      outLen: out.length,\n      didInterleave: didInterleave\n    });\n\n    return { groups: [out], mode: \"rows\" };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvb3JkZXJpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVZVixDQUFDLENBQUNDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcb3JkZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9vcmRlcmluZy50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNPcmRlcmluZ0Jsb2NrKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBcclxuICAvKipcclxuICAgKiBPcmRlbmEgQ0xVU1RFUlMgKG5vIGl0ZW1zKSBwYXJhIGxlY3R1cmEgbW9iaWxlLlxyXG4gICAqIERldnVlbHZlIGdyb3VwcyAoYXJyYXkgZGUgY29sdW1uYXMvZ3J1cG9zKSB5IG1vZGUuXHJcbiAgICpcclxuICAgKiAtIHRocmVlOiBbY29sTCwgY29sQywgY29sUl1cclxuICAgKiAtIHR3bzogICBbbGVmdCwgcmlnaHRdXHJcbiAgICogLSByb3dzOiAgW291dF0gKGZpbGErbGVmdClcclxuICAgKiAtIG9uZTogICBbc29ydGVkVG9wXVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG9yZGVyQ2x1c3RlcnNGb3JNb2JpbGUoY2x1c3RlcnMsIHJvb3RXLCBDRkcpe1xuICAgIGlmICghcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgdmFyIG8gPSBjbHVzdGVycy5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbb10sIG1vZGU6IFwib25lXCIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbHVzdGVySGFzVGV4dChjKXtcbiAgICAgIGlmICghYyB8fCAhYy5pdGVtcyB8fCAhYy5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGlUeHQ9MDsgaVR4dDxjLml0ZW1zLmxlbmd0aDsgaVR4dCsrKXtcbiAgICAgICAgaWYgKChjLml0ZW1zW2lUeHRdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbkhhc1RleHQoY29sKXtcbiAgICAgIGlmICghY29sIHx8ICFjb2wubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpQ29sPTA7IGlDb2w8Y29sLmxlbmd0aDsgaUNvbCsrKXtcbiAgICAgICAgaWYgKGNsdXN0ZXJIYXNUZXh0KGNvbFtpQ29sXSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVuIGNsdXN0ZXIgXCJpbnZhZGVcIiB1bmEgZnJvbnRlcmEgc2kgcXVlZGEgcGFydGlkbyBkZSBmb3JtYSBzaWduaWZpY2F0aXZhXG4gICAgLy8gZW50cmUgYW1ib3MgbGFkb3MgZGUgbGEgbGluZWEgZGl2aXNvcmlhLlxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJJbnZhZGVzRGl2aWRlcihjLCBkaXZpZGVyWCl7XG4gICAgICBpZiAoIWMpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZWZ0ID0gTnVtYmVyKGMubGVmdCB8fCAwKTtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KDAsIE51bWJlcihjLndpZHRoIHx8IDApKTtcbiAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIGlmICh3aWR0aCA8PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocmlnaHQgPD0gZGl2aWRlclggfHwgbGVmdCA+PSBkaXZpZGVyWCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgcGFydExlZnQgPSBkaXZpZGVyWCAtIGxlZnQ7XG4gICAgICB2YXIgcGFydFJpZ2h0ID0gcmlnaHQgLSBkaXZpZGVyWDtcbiAgICAgIHZhciBtaW5QYXJ0ID0gTWF0aC5taW4ocGFydExlZnQsIHBhcnRSaWdodCk7XG4gICAgICB2YXIgbWluUmVxdWlyZWQgPSBNYXRoLm1heCgyMiwgd2lkdGggKiAwLjIyKTtcbiAgICAgIHJldHVybiBtaW5QYXJ0ID49IG1pblJlcXVpcmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdmlkZXJJbnZhc2lvblJhdGlvKGxpc3QsIGRpdmlkZXJYKXtcbiAgICAgIGlmICghbGlzdCB8fCAhbGlzdC5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgdmFyIGludmFkZWQgPSAwO1xuICAgICAgZm9yICh2YXIgaUludj0wOyBpSW52PGxpc3QubGVuZ3RoOyBpSW52Kyspe1xuICAgICAgICBpZiAoY2x1c3RlckludmFkZXNEaXZpZGVyKGxpc3RbaUludl0sIGRpdmlkZXJYKSkgaW52YWRlZCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludmFkZWQgLyBNYXRoLm1heCgxLCBsaXN0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMCkgSW50ZW50YXIgMyBjb2x1bW5hcyBjbGFyYXMgLS0tLS0tLS1cbiAgICB2YXIgdDEgPSByb290VyAvIDM7XG4gICAgdmFyIHQyID0gKDIgKiByb290VykgLyAzO1xuXHJcbiAgICB2YXIgY29sTCA9IFtdO1xyXG4gICAgdmFyIGNvbEMgPSBbXTtcclxuICAgIHZhciBjb2xSID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaT0wO2k8Y2x1c3RlcnMubGVuZ3RoO2krKyl7XHJcbiAgICAgIHZhciBjID0gY2x1c3RlcnNbaV07XHJcbiAgICAgIHZhciB4ID0gYy5jeDtcclxuICAgICAgaWYgKHggPCB0MSkgY29sTC5wdXNoKGMpO1xyXG4gICAgICBlbHNlIGlmICh4IDwgdDIpIGNvbEMucHVzaChjKTtcclxuICAgICAgZWxzZSBjb2xSLnB1c2goYyk7XHJcbiAgICB9XHJcblxuICAgIHZhciBsb29rc1RocmVlID1cbiAgICAgIChjb2xMLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyAmJiBjb2xDLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyAmJiBjb2xSLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyk7XG4gICAgdmFyIHRleHRDb2xzVGhyZWUgPVxuICAgICAgKGNvbHVtbkhhc1RleHQoY29sTCkgPyAxIDogMCkgK1xuICAgICAgKGNvbHVtbkhhc1RleHQoY29sQykgPyAxIDogMCkgK1xuICAgICAgKGNvbHVtbkhhc1RleHQoY29sUikgPyAxIDogMCk7XG4gICAgdmFyIGhhc1RleHRTaWduYWxUaHJlZSA9IHRleHRDb2xzVGhyZWUgPj0gMjtcbiAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTpjYW5kaWRhdGVzXCIsIHtcbiAgICAgIHJvb3RXOiByb290VyxcbiAgICAgIHRvdGFsOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICBjb2xMOiBjb2xMLmxlbmd0aCxcbiAgICAgIGNvbEM6IGNvbEMubGVuZ3RoLFxuICAgICAgY29sUjogY29sUi5sZW5ndGgsXG4gICAgICBtaW5QZXJDb2wzOiBDRkcuTUlOX1BFUl9DT0xfMyxcbiAgICAgIHRleHRDb2xzVGhyZWU6IHRleHRDb2xzVGhyZWUsXG4gICAgICBoYXNUZXh0U2lnbmFsVGhyZWU6IGhhc1RleHRTaWduYWxUaHJlZVxuICAgIH0pO1xuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIHZhciBjeHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGo9MDtqPGNsdXN0ZXJzLmxlbmd0aDtqKyspIGN4cy5wdXNoKGNsdXN0ZXJzW2pdLmN4KTtcclxuICAgICAgY3hzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XHJcbiAgICAgIHZhciBwMjAgPSBwZXJjZW50aWxlKGN4cywgMC4yMCk7XG4gICAgICB2YXIgcDgwID0gcGVyY2VudGlsZShjeHMsIDAuODApO1xuICAgICAgdmFyIHNwcmVhZCA9IChwODAgLSBwMjApO1xuICAgICAgbXNsTG9nKFwib3JkZXI6dGhyZWU6c3ByZWFkXCIsIHtcbiAgICAgICAgcDIwOiBwMjAsXG4gICAgICAgIHA4MDogcDgwLFxuICAgICAgICBzcHJlYWQ6IHNwcmVhZCxcbiAgICAgICAgbWluU3ByZWFkOiByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPLFxuICAgICAgICBwYXNzOiBzcHJlYWQgPj0gcm9vdFcgKiBDRkcuVEhSRUVfQ09MX1NQUkVBRF9SQVRJT1xuICAgICAgfSk7XG4gICAgICBpZiAoc3ByZWFkIDwgcm9vdFcgKiBDRkcuVEhSRUVfQ09MX1NQUkVBRF9SQVRJTykgbG9va3NUaHJlZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1RocmVlKSB7XG4gICAgICB2YXIgaW52YWRlVDEgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgdDEpO1xuICAgICAgdmFyIGludmFkZVQyID0gZGl2aWRlckludmFzaW9uUmF0aW8oY2x1c3RlcnMsIHQyKTtcbiAgICAgIHZhciBpbnZhZGVUaHJlZSA9IE1hdGgubWF4KGludmFkZVQxLCBpbnZhZGVUMik7XG4gICAgICB2YXIgaW52YXNpb25MaW1pdFRocmVlID0gaGFzVGV4dFNpZ25hbFRocmVlID8gMC40NiA6IDAuMzQ7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTppbnZhc2lvblwiLCB7XG4gICAgICAgIHQxOiArdDEudG9GaXhlZCgxKSxcbiAgICAgICAgdDI6ICt0Mi50b0ZpeGVkKDEpLFxuICAgICAgICBpbnZhZGVUMTogK2ludmFkZVQxLnRvRml4ZWQoMyksXG4gICAgICAgIGludmFkZVQyOiAraW52YWRlVDIudG9GaXhlZCgzKSxcbiAgICAgICAgaW52YWRlVGhyZWU6ICtpbnZhZGVUaHJlZS50b0ZpeGVkKDMpLFxuICAgICAgICBsaW1pdDogK2ludmFzaW9uTGltaXRUaHJlZS50b0ZpeGVkKDMpLFxuICAgICAgICBoYXNUZXh0U2lnbmFsVGhyZWU6IGhhc1RleHRTaWduYWxUaHJlZSxcbiAgICAgICAgcGFzczogaW52YWRlVGhyZWUgPD0gaW52YXNpb25MaW1pdFRocmVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhZGVUaHJlZSA+IGludmFzaW9uTGltaXRUaHJlZSkgbG9va3NUaHJlZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1RocmVlKSB7XG4gICAgICBjb2xMLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgY29sQy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcbiAgICAgIGNvbFIuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcbiAgICAgIHJldHVybiB7IGdyb3VwczogW2NvbEwsIGNvbEMsIGNvbFJdLCBtb2RlOiBcInRocmVlXCIgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLSAxKSBJbnRlbnRhciAyIGNvbHVtbmFzIGNsYXJhcyAtLS0tLS0tLVxuICAgIHZhciBtaWQgPSByb290VyAvIDI7XHJcbiAgICB2YXIgbGVmdCA9IFtdO1xyXG4gICAgdmFyIHJpZ2h0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaz0wO2s8Y2x1c3RlcnMubGVuZ3RoO2srKyl7XG4gICAgICB2YXIgYzIgPSBjbHVzdGVyc1trXTtcbiAgICAgIGlmIChjMi5jeCA8IG1pZCkgbGVmdC5wdXNoKGMyKTtcbiAgICAgIGVsc2UgcmlnaHQucHVzaChjMik7XG4gICAgfVxuXG4gICAgdmFyIGxvb2tzVHdvID0gKGxlZnQubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8yICYmIHJpZ2h0Lmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMik7XG4gICAgdmFyIGhhc1RleHRTaWduYWxUd28gPSBjb2x1bW5IYXNUZXh0KGxlZnQpICYmIGNvbHVtbkhhc1RleHQocmlnaHQpO1xuICAgIG1zbExvZyhcIm9yZGVyOnR3bzpjYW5kaWRhdGVzXCIsIHtcbiAgICAgIHJvb3RXOiByb290VyxcbiAgICAgIHRvdGFsOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICBsZWZ0OiBsZWZ0Lmxlbmd0aCxcbiAgICAgIHJpZ2h0OiByaWdodC5sZW5ndGgsXG4gICAgICBtaW5QZXJDb2wyOiBDRkcuTUlOX1BFUl9DT0xfMixcbiAgICAgIGhhc1RleHRTaWduYWxUd286IGhhc1RleHRTaWduYWxUd29cbiAgICB9KTtcblxuICAgIC8vIFBvbGl0aWNhIHBhcmEgcGFyZXMgKDIgY2x1c3RlcnMpOlxuICAgIC8vIC0gcGFyIGRlIGNvbHVtbmFzIHJlYWxlcyA9PiBtb2RlIFwidHdvXCJcbiAgICAvLyAtIHJlc3RvIGRlIGNhc29zID0+IG1vZGUgXCJvbmVcIiAoZml0Q2hlY2sgZGVjaWRlIHNpIHJlZmxvd2VhKVxyXG4gICAgaWYgKGNsdXN0ZXJzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICB2YXIgY0EgPSBjbHVzdGVyc1swXTtcclxuICAgICAgdmFyIGNCID0gY2x1c3RlcnNbMV07XHJcblxyXG4gICAgICBmdW5jdGlvbiBwYWlyU3RhdHMoYyl7XHJcbiAgICAgICAgdmFyIHRleHQgPSAwO1xyXG4gICAgICAgIHZhciBub24gPSAwO1xyXG4gICAgICAgIHZhciBmb3JjZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgcT0wOyBxPGMuaXRlbXMubGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgIHZhciBuID0gYy5pdGVtc1txXS5ub2RlO1xyXG4gICAgICAgICAgaWYgKChuLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNlbnRlclwiKSB8fCBcIlwiKSA9PT0gXCJmb3JjZVwiKSBmb3JjZSsrO1xyXG4gICAgICAgICAgaWYgKChuLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSB0ZXh0Kys7XHJcbiAgICAgICAgICBlbHNlIG5vbisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0ZXh0OiB0ZXh0LCBub246IG5vbiwgZm9yY2U6IGZvcmNlIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzQSA9IHBhaXJTdGF0cyhjQSk7XHJcbiAgICAgIHZhciBzQiA9IHBhaXJTdGF0cyhjQik7XHJcblxyXG4gICAgICB2YXIgdG9wRGVsdGEgPSBNYXRoLmFicygoY0EudG9wIHx8IDApIC0gKGNCLnRvcCB8fCAwKSk7XG4gICAgICB2YXIgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigoY0EubGVmdCArIGNBLndpZHRoKSwgKGNCLmxlZnQgKyBjQi53aWR0aCkpIC0gTWF0aC5tYXgoY0EubGVmdCwgY0IubGVmdCkpO1xuICAgICAgdmFyIG1pbldQYWlyID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oKGNBLndpZHRoIHx8IDApLCAoY0Iud2lkdGggfHwgMCkpKTtcbiAgICAgIHZhciB4T3ZlcmxhcFJhdGlvID0geE92ZXJsYXAgLyBtaW5XUGFpcjtcbiAgICAgIHZhciBzaWRlQnlTaWRlID0gdG9wRGVsdGEgPD0gKENGRy5ST1dfVE9MICogMS41KSAmJiB4T3ZlcmxhcFJhdGlvIDwgMC4yNTtcbiAgICAgIHZhciBwYWlySW52YXNpb24gPSBkaXZpZGVySW52YXNpb25SYXRpbyhbY0EsIGNCXSwgbWlkKTtcbiAgICAgIHZhciBwYWlySW52YXNpb25MaW1pdCA9IGhhc1RleHRTaWduYWxUd28gPyAwLjUgOiAwLjM0O1xuXG4gICAgICB2YXIgYW55Rm9yY2VDZW50ZXIgPSAoc0EuZm9yY2UgPiAwIHx8IHNCLmZvcmNlID4gMCk7XG4gICAgICB2YXIgYm90aE1peGVkID0gKHNBLnRleHQgPiAwICYmIHNBLm5vbiA+IDAgJiYgc0IudGV4dCA+IDAgJiYgc0Iubm9uID4gMCk7XG4gICAgICAvLyBTZcOxYWwgcm9idXN0YSBkZSBcInBhciBkZSBjb2x1bW5hc1wiOlxuICAgICAgLy8gLSBlc3TDoW4gbGFkbyBhIGxhZG8geSBwYXNhbiBzcGxpdCBsZWZ0L3JpZ2h0XG4gICAgICAvLyAtIHkgYWRlbcOhcyBubyBzb24gc2ltcGxlbWVudGUgMiB0ZXh0b3Mgc3VlbHRvcyBlbiB1bmEgZmlsYVxuICAgICAgdmFyIGhhc0NvbHVtblNpZ25hbCA9XG4gICAgICAgIChzQS5ub24gPiAwIHx8IHNCLm5vbiA+IDApIHx8XG4gICAgICAgICgoY0EuaXRlbXMgJiYgY0EuaXRlbXMubGVuZ3RoID4gMSkgfHwgKGNCLml0ZW1zICYmIGNCLml0ZW1zLmxlbmd0aCA+IDEpKTtcblxuICAgICAgaWYgKGxvb2tzVHdvICYmIHNpZGVCeVNpZGUgJiYgaGFzQ29sdW1uU2lnbmFsICYmIHBhaXJJbnZhc2lvbiA8PSBwYWlySW52YXNpb25MaW1pdCkge1xuICAgICAgICB2YXIgbGVmdFBhaXIgPSAoY0EuY3ggPD0gY0IuY3gpID8gW2NBXSA6IFtjQl07XG4gICAgICAgIHZhciByaWdodFBhaXIgPSAoY0EuY3ggPD0gY0IuY3gpID8gW2NCXSA6IFtjQV07XG4gICAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzpwYWlyUG9saWN5XCIsIHtcbiAgICAgICAgICBtb2RlOiBcInR3b1wiLFxuICAgICAgICAgIHJlYXNvbjogXCJwYWlyQ29sdW1uc1wiLFxuICAgICAgICAgIHRvcERlbHRhOiArdG9wRGVsdGEudG9GaXhlZCgxKSxcbiAgICAgICAgICB4T3ZlcmxhcFJhdGlvOiAreE92ZXJsYXBSYXRpby50b0ZpeGVkKDMpLFxuICAgICAgICAgIGhhc0NvbHVtblNpZ25hbDogaGFzQ29sdW1uU2lnbmFsLFxuICAgICAgICAgIGJvdGhNaXhlZDogYm90aE1peGVkLFxuICAgICAgICAgIGFueUZvcmNlQ2VudGVyOiBhbnlGb3JjZUNlbnRlcixcbiAgICAgICAgICBwYWlySW52YXNpb246ICtwYWlySW52YXNpb24udG9GaXhlZCgzKSxcbiAgICAgICAgICBwYWlySW52YXNpb25MaW1pdDogK3BhaXJJbnZhc2lvbkxpbWl0LnRvRml4ZWQoMyksXG4gICAgICAgICAgbGVmdHM6IFsrKGNBLmxlZnQgfHwgMCkudG9GaXhlZCgxKSwgKyhjQi5sZWZ0IHx8IDApLnRvRml4ZWQoMSldXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBncm91cHM6IFtsZWZ0UGFpciwgcmlnaHRQYWlyXSwgbW9kZTogXCJ0d29cIiB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFpciA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhhLnRvcCAtIGIudG9wKSA+IDAuNSkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgfSk7XHJcbiAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzpwYWlyUG9saWN5XCIsIHtcclxuICAgICAgICBtb2RlOiBcIm9uZVwiLFxyXG4gICAgICAgIHJlYXNvbjogYW55Rm9yY2VDZW50ZXIgPyBcImZvcmNlQ2VudGVyUGFpclwiIDogXCJwYWlyRGVmYXVsdFwiLFxyXG4gICAgICAgIHRvcERlbHRhOiArdG9wRGVsdGEudG9GaXhlZCgxKSxcclxuICAgICAgICB4T3ZlcmxhcFJhdGlvOiAreE92ZXJsYXBSYXRpby50b0ZpeGVkKDMpLFxuICAgICAgICBzaWRlQnlTaWRlOiBzaWRlQnlTaWRlLFxuICAgICAgICBib3RoTWl4ZWQ6IGJvdGhNaXhlZCxcbiAgICAgICAgYW55Rm9yY2VDZW50ZXI6IGFueUZvcmNlQ2VudGVyLFxuICAgICAgICBwYWlySW52YXNpb246ICtwYWlySW52YXNpb24udG9GaXhlZCgzKSxcbiAgICAgICAgcGFpckludmFzaW9uTGltaXQ6ICtwYWlySW52YXNpb25MaW1pdC50b0ZpeGVkKDMpLFxuICAgICAgICB0b3BzOiBwYWlyLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLnRvcC50b0ZpeGVkKDEpOyB9KSxcbiAgICAgICAgbGVmdHM6IHBhaXIubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MubGVmdC50b0ZpeGVkKDEpOyB9KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtwYWlyXSwgbW9kZTogXCJvbmVcIiB9O1xuICAgIH1cclxuICAgIGlmIChsb29rc1R3bykge1xyXG4gICAgICB2YXIgY3hzMiA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBtPTA7bTxjbHVzdGVycy5sZW5ndGg7bSsrKSBjeHMyLnB1c2goY2x1c3RlcnNbbV0uY3gpO1xyXG4gICAgICBjeHMyLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XHJcbiAgICAgIHZhciBwMjUgPSBwZXJjZW50aWxlKGN4czIsIDAuMjUpO1xuICAgICAgdmFyIHA3NSA9IHBlcmNlbnRpbGUoY3hzMiwgMC43NSk7XG4gICAgICB2YXIgc3ByZWFkMiA9IChwNzUgLSBwMjUpO1xuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnNwcmVhZFwiLCB7XG4gICAgICAgIHAyNTogcDI1LFxuICAgICAgICBwNzU6IHA3NSxcbiAgICAgICAgc3ByZWFkOiBzcHJlYWQyLFxuICAgICAgICBtaW5TcHJlYWQ6IHJvb3RXICogQ0ZHLlRXT19DT0xfU1BSRUFEX1JBVElPLFxuICAgICAgICBwYXNzOiBzcHJlYWQyID49IHJvb3RXICogQ0ZHLlRXT19DT0xfU1BSRUFEX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmIChzcHJlYWQyIDwgcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU8pIGxvb2tzVHdvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVHdvKSB7XG4gICAgICB2YXIgaW52YWRlTWlkID0gZGl2aWRlckludmFzaW9uUmF0aW8oY2x1c3RlcnMsIG1pZCk7XG4gICAgICB2YXIgaW52YXNpb25MaW1pdFR3byA9IGhhc1RleHRTaWduYWxUd28gPyAwLjQ4IDogMC4zNDtcbiAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzppbnZhc2lvblwiLCB7XG4gICAgICAgIG1pZDogK21pZC50b0ZpeGVkKDEpLFxuICAgICAgICBpbnZhZGVNaWQ6ICtpbnZhZGVNaWQudG9GaXhlZCgzKSxcbiAgICAgICAgbGltaXQ6ICtpbnZhc2lvbkxpbWl0VHdvLnRvRml4ZWQoMyksXG4gICAgICAgIGhhc1RleHRTaWduYWxUd286IGhhc1RleHRTaWduYWxUd28sXG4gICAgICAgIHBhc3M6IGludmFkZU1pZCA8PSBpbnZhc2lvbkxpbWl0VHdvXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhZGVNaWQgPiBpbnZhc2lvbkxpbWl0VHdvKSBsb29rc1R3byA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1R3bykge1xuICAgICAgbGVmdC5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcbiAgICAgIHJpZ2h0LnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbbGVmdCwgcmlnaHRdLCBtb2RlOiBcInR3b1wiIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMikgR3VhcmQgdGFyZGlvOiB1bmEgc29sYSBjb2x1bW5hIHZpc3VhbCAtLS0tLS0tLVxuICAgIC8vIFNlIGV2YWx1YSBkZXNwdWVzIGRlIHR3by90aHJlZSBwYXJhIGV2aXRhciBmYWxzb3MgXCJvbmVcIiBjdWFuZG8gaGF5XG4gICAgLy8gZG9zIGNvbHVtbmFzIHJlYWxlcyBjb24gdmFyaW9zIGNsdXN0ZXJzLlxuICAgIGlmIChjbHVzdGVycy5sZW5ndGggPj0gMikge1xuICAgICAgdmFyIGN4c09uZSA9IGNsdXN0ZXJzLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuIGMuY3g7IH0pLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XG4gICAgICB2YXIgbWVkaWFuQ3ggPSBwZXJjZW50aWxlKGN4c09uZSwgMC41MCk7XG4gICAgICB2YXIgbWF4RGV2Q3ggPSAwO1xuICAgICAgZm9yICh2YXIgcz0wOyBzPGNsdXN0ZXJzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHZhciBkZXYgPSBNYXRoLmFicygoY2x1c3RlcnNbc10uY3ggfHwgMCkgLSBtZWRpYW5DeCk7XG4gICAgICAgIGlmIChkZXYgPiBtYXhEZXZDeCkgbWF4RGV2Q3ggPSBkZXY7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW5nbGVDb2xNYXhEZXYgPSByb290VyAqIDAuMTg7XG4gICAgICB2YXIgbG9va3NPbmVDb2wgPSBtYXhEZXZDeCA8PSBzaW5nbGVDb2xNYXhEZXY7XG4gICAgICBtc2xMb2coXCJvcmRlcjpvbmU6Y2FuZGlkYXRlc1wiLCB7XG4gICAgICAgIHJvb3RXOiByb290VyxcbiAgICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgbWVkaWFuQ3g6ICttZWRpYW5DeC50b0ZpeGVkKDEpLFxuICAgICAgICBtYXhEZXZDeDogK21heERldkN4LnRvRml4ZWQoMSksXG4gICAgICAgIG1heEFsbG93ZWQ6ICtzaW5nbGVDb2xNYXhEZXYudG9GaXhlZCgxKSxcbiAgICAgICAgcGFzczogbG9va3NPbmVDb2wsXG4gICAgICAgIHN0YWdlOiBcInBvc3RUd29UaHJlZVwiXG4gICAgICB9KTtcblxuICAgICAgaWYgKGxvb2tzT25lQ29sKSB7XG4gICAgICAgIHZhciBvbmVDb2wgPSBjbHVzdGVycy5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgICByZXR1cm4geyBncm91cHM6IFtvbmVDb2xdLCBtb2RlOiBcIm9uZVwiIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMykgRmFsbGJhY2s6IGZpbGFzICh0b3ApIHkgZGVudHJvIHBvciBsZWZ0IC0tLS0tLS0tXG4gICAgdmFyIHNvcnRlZCA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcblxyXG4gICAgdmFyIHJvd3MgPSBbXTtcclxuICAgIGZvciAodmFyIHI9MDtyPHNvcnRlZC5sZW5ndGg7cisrKXtcclxuICAgICAgdmFyIGMzID0gc29ydGVkW3JdO1xyXG4gICAgICB2YXIgcGxhY2VkID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBycj0wOyBycjxyb3dzLmxlbmd0aDsgcnIrKyl7XHJcbiAgICAgICAgdmFyIHJvdyA9IHJvd3NbcnJdO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhjMy50b3AgLSByb3cudG9wKSA8PSBDRkcuUk9XX1RPTCl7XHJcbiAgICAgICAgICByb3cuaXRlbXMucHVzaChjMyk7XHJcbiAgICAgICAgICByb3cudG9wID0gKHJvdy50b3AgKiAocm93Lml0ZW1zLmxlbmd0aCAtIDEpICsgYzMudG9wKSAvIHJvdy5pdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBsYWNlZCkgcm93cy5wdXNoKHsgdG9wOiBjMy50b3AsIGl0ZW1zOiBbYzNdIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJvd3Muc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KXtcclxuICAgICAgcm93Lml0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEubGVmdCAtIGIubGVmdDsgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbHVzdGVySXNUZXh0KGMpe1xuICAgICAgaWYgKCFjIHx8ICFjLml0ZW1zIHx8ICFjLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaTI9MDsgaTI8Yy5pdGVtcy5sZW5ndGg7IGkyKyspe1xuICAgICAgICBpZiAoKGMuaXRlbXNbaTJdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgZGlkSW50ZXJsZWF2ZSA9IGZhbHNlO1xuICAgIC8vIENhc28gZXNwZWNpYWw6IGRvcyBmaWxhcyBzaW1ldHJpY2FzIChlai4gaWNvbm9zIGFycmliYSB5IHRleHRvcyBhYmFqbykuXG4gICAgLy8gUmVvcmRlbmFtb3MgcG9yIGNvbHVtbmE6IHRvcDEsYm90dG9tMSx0b3AyLGJvdHRvbTIsLi4uXG4gICAgaWYgKHJvd3MubGVuZ3RoID09PSAyICYmIHJvd3NbMF0uaXRlbXMubGVuZ3RoID09PSByb3dzWzFdLml0ZW1zLmxlbmd0aCAmJiByb3dzWzBdLml0ZW1zLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgdG9wUm93ID0gcm93c1swXS5pdGVtcy5zbGljZSgpO1xuICAgICAgdmFyIGJvdFJvdyA9IHJvd3NbMV0uaXRlbXMuc2xpY2UoKTtcbiAgICAgIHZhciB0b3BIYXNOb25UZXh0ID0gdG9wUm93LnNvbWUoZnVuY3Rpb24oYyl7IHJldHVybiAhY2x1c3RlcklzVGV4dChjKTsgfSk7XG4gICAgICB2YXIgYm90TW9zdGx5VGV4dCA9IGJvdFJvdy5maWx0ZXIoZnVuY3Rpb24oYyl7IHJldHVybiBjbHVzdGVySXNUZXh0KGMpOyB9KS5sZW5ndGggPj0gTWF0aC5jZWlsKGJvdFJvdy5sZW5ndGggLyAyKTtcblxuICAgICAgaWYgKHRvcEhhc05vblRleHQgJiYgYm90TW9zdGx5VGV4dCkge1xuICAgICAgICB2YXIgdXNlZEJvdHRvbSA9IHt9O1xuICAgICAgICBmb3IgKHZhciB0cj0wOyB0cjx0b3BSb3cubGVuZ3RoOyB0cisrKXtcbiAgICAgICAgICB2YXIgYSA9IHRvcFJvd1t0cl07XG4gICAgICAgICAgb3V0LnB1c2goYSk7XG5cbiAgICAgICAgICB2YXIgYmVzdElkeCA9IC0xO1xuICAgICAgICAgIHZhciBiZXN0RGlzdCA9IEluZmluaXR5O1xuICAgICAgICAgIGZvciAodmFyIGJyPTA7IGJyPGJvdFJvdy5sZW5ndGg7IGJyKyspe1xuICAgICAgICAgICAgaWYgKHVzZWRCb3R0b21bYnJdKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBiID0gYm90Um93W2JyXTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5hYnMoKGEubGVmdCB8fCAwKSAtIChiLmxlZnQgfHwgMCkpO1xuICAgICAgICAgICAgaWYgKGQgPCBiZXN0RGlzdCkge1xuICAgICAgICAgICAgICBiZXN0RGlzdCA9IGQ7XG4gICAgICAgICAgICAgIGJlc3RJZHggPSBicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJlc3RJZHggPj0gMCkge1xuICAgICAgICAgICAgb3V0LnB1c2goYm90Um93W2Jlc3RJZHhdKTtcbiAgICAgICAgICAgIHVzZWRCb3R0b21bYmVzdElkeF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBicjI9MDsgYnIyPGJvdFJvdy5sZW5ndGg7IGJyMisrKXtcbiAgICAgICAgICBpZiAoIXVzZWRCb3R0b21bYnIyXSkgb3V0LnB1c2goYm90Um93W2JyMl0pO1xuICAgICAgICB9XG4gICAgICAgIGRpZEludGVybGVhdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGlkSW50ZXJsZWF2ZSkge1xuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdyl7XG4gICAgICAgIGZvciAodmFyIHo9MDsgejxyb3cuaXRlbXMubGVuZ3RoOyB6KyspIG91dC5wdXNoKHJvdy5pdGVtc1t6XSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbXNsTG9nKFwib3JkZXI6cm93czpmYWxsYmFja1wiLCB7XG4gICAgICByb3dzOiByb3dzLm1hcChmdW5jdGlvbihyKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICtyLnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGxlbjogci5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgbGVmdHM6IHIuaXRlbXMubWFwKGZ1bmN0aW9uKGl0KXsgcmV0dXJuICtpdC5sZWZ0LnRvRml4ZWQoMSk7IH0pXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG91dExlbjogb3V0Lmxlbmd0aCxcbiAgICAgIGRpZEludGVybGVhdmU6IGRpZEludGVybGVhdmVcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGdyb3VwczogW291dF0sIG1vZGU6IFwicm93c1wiIH07XG4gIH1cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzT3JkZXJpbmdCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts":
/*!*****************************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/scriptTemplate.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* binding */ buildScript)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts\");\n/* harmony import */ var _fitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitScale */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts\");\n/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordering */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts\");\n/* harmony import */ var _stacking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacking */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts\");\n// functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n\n\n\n\nfunction buildScript(cfg) {\n    if (!cfg.enabled) return \"\";\n    return `\n<script>\n(function(){\n  var ENABLED = true;\n  function readDebugFlag(name){\n    try {\n      var search = (window.location && window.location.search) ? window.location.search : \"\";\n      var qp = new URLSearchParams(search);\n      var qv = qp.get(name);\n      if (qv === \"1\" || String(qv).toLowerCase() === \"true\") return true;\n    } catch(_e1) {}\n\n    // srcDoc/about:srcdoc no suele tener querystring.\n    try {\n      if (window.parent && window.parent !== window && window.parent.location) {\n        var pSearch = window.parent.location.search || \"\";\n        var pQ = new URLSearchParams(pSearch);\n        var pV = pQ.get(name);\n        if (pV === \"1\" || String(pV).toLowerCase() === \"true\") return true;\n      }\n    } catch(_e2) {}\n\n    try {\n      if (window.top && window.top !== window && window.top.location) {\n        var tSearch = window.top.location.search || \"\";\n        var tQ = new URLSearchParams(tSearch);\n        var tV = tQ.get(name);\n        if (tV === \"1\" || String(tV).toLowerCase() === \"true\") return true;\n      }\n    } catch(_e3) {}\n\n    try {\n      var ls = window.localStorage ? window.localStorage.getItem(name) : null;\n      if (ls === \"1\" || String(ls).toLowerCase() === \"true\") return true;\n    } catch(_e4) {}\n\n    return false;\n  }\n  var MSL_DEBUG = readDebugFlag(\"mslDebug\");\n  var MSL_VERBOSE = readDebugFlag(\"mslVerbose\");\n  function dbg(label, payload){\n    if (!MSL_DEBUG) return;\n    if (arguments.length <= 1) {\n      console.log(\"[MSL] \" + label);\n      return;\n    }\n    if (typeof payload === \"string\") {\n      console.log(\"[MSL] \" + label + \" \" + payload);\n      return;\n    }\n    var pretty = \"\";\n    try {\n      pretty = JSON.stringify(payload, null, 2);\n    } catch(e) {\n      try { pretty = String(payload); } catch(_) { pretty = \"[unserializable]\"; }\n    }\n    console.log(\"[MSL] \" + label + \"\\\\n\" + pretty);\n  }\n  function mslLog(){\n    if (!MSL_DEBUG) return;\n    var args = Array.prototype.slice.call(arguments);\n    if (!args.length) return;\n    var label = String(args[0]);\n    if (!MSL_VERBOSE) {\n      var noisy = {\n        \"section:nodeSources\": 1,\n        \"section:baselineRestore\": 1,\n        \"section:anchorSplit\": 1,\n        \"section:clusters\": 1,\n        \"order:three:candidates\": 1,\n        \"order:three:spread\": 1,\n        \"order:two:candidates\": 1,\n        \"order:two:spread\": 1,\n        \"order:one:candidates\": 1,\n        \"order:rows:fallback\": 1\n      };\n      if (noisy[label]) return;\n    }\n    if (args.length === 1) {\n      dbg(label);\n      return;\n    }\n    if (args.length === 2) {\n      dbg(label, args[1]);\n      return;\n    }\n    dbg(label, args.slice(1));\n  }\n\n  var CFG = {\n    MIN_GAP: ${cfg.minGapPx},\n    MAX_GAP: ${cfg.maxGapPx},\n    GAP_SCALE: ${cfg.gapScale},\n\n    PAD_TOP: ${cfg.paddingTopPx},\n    PAD_BOT: ${cfg.paddingBottomPx},\n\n    ONLY_FIXED: ${cfg.onlyFixedSections ? \"true\" : \"false\"},\n    ONLY_WHEN_REORDERED: ${cfg.onlyWhenReordered ? \"true\" : \"false\"},\n\n    ROW_TOL: ${cfg.rowTolPx},\n\n    TWO_COL_SPREAD_RATIO: ${cfg.twoColSpreadRatio},\n    MIN_PER_COL_2: ${cfg.minPerColumn2},\n\n    THREE_COL_SPREAD_RATIO: ${cfg.threeColSpreadRatio},\n    MIN_PER_COL_3: ${cfg.minPerColumn3},\n\n    FIT_MIN_SCALE: ${cfg.fitMinScale},\n    FIT_MAX_SCALE: ${cfg.fitMaxScale},\n    FIT_TARGET_WIDTH_RATIO: ${cfg.fitTargetWidthRatio},\n    FIT_MIN_FILL_RATIO: ${cfg.fitMinFillRatio}\n  };\n\n  ${(0,_dom__WEBPACK_IMPORTED_MODULE_0__.jsDomHelpersBlock)()}\n\n  ${(0,_ordering__WEBPACK_IMPORTED_MODULE_2__.jsOrderingBlock)()}\n\n  ${(0,_stacking__WEBPACK_IMPORTED_MODULE_3__.jsStackingBlock)()}\n\n  ${(0,_fitScale__WEBPACK_IMPORTED_MODULE_1__.jsFitScaleBlock)()}\n\n  function expandFixedSection(sec, neededHeight){\n    var currentH = sec.getBoundingClientRect().height || 0;\n    if (neededHeight > currentH + 1) {\n      sec.style.height = Math.ceil(neededHeight) + \"px\";\n      return true;\n    }\n    return false;\n  }\n\n  function shouldProcessSection(sec){\n    if(!sec) return false;\n    if(!CFG.ONLY_FIXED) return true;\n    var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n    return modo === \"fijo\";\n  }\n\n  function runOnce(){\n    if(!ENABLED) return;\n    if(!isMobile()) {\n      Array.from(document.querySelectorAll(\".sec\")).forEach(function(sec){\n        var content = sec.querySelector(\".sec-content\");\n        if(!content) return;\n        var bleed = sec.querySelector(\".sec-bleed\");\n        resetSectionFitScale(sec, content, bleed);\n        sec.setAttribute(\"data-msl-fit-scale\", \"1\");\n      });\n      return;\n    }\n\n    var secs = Array.from(document.querySelectorAll(\".sec\"));\n    if(!secs.length) return;\n\n    secs.forEach(function(sec){\n      var secIndex = secs.indexOf(sec);\n      var secModo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n      var allowReflow = shouldProcessSection(sec);\n      mslLog(\"section:start\", { secIndex: secIndex, modo: secModo, allowReflow: allowReflow });\n\n      var content = sec.querySelector(\".sec-content\");\n      if(!content) return;\n      var bleed = sec.querySelector(\".sec-bleed\");\n      resetSectionFitScale(sec, content, bleed);\n      var nodesAll = getObjNodes(sec);\n\n      var reflowElementsDump = [];\n      function buildReflowElementsDump(items, contentWNow){\n        if (!MSL_DEBUG) return;\n        var list = (items || []);\n        var maxItems = 120;\n        var out = [];\n        for (var iDump=0; iDump<list.length && iDump<maxItems; iDump++){\n          var itDump = list[iDump];\n          if (!itDump || !itDump.node) continue;\n          var nDump = itDump.node;\n          var textRaw = ((nDump.textContent || \"\").trim()).replace(/\\s+/g, \" \");\n          var isTextDump = (nDump.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          var clsDump = (nDump.className && typeof nDump.className === \"string\") ? nDump.className : \"\";\n          var rootZone = (nDump.closest && nDump.closest(\".sec-bleed\")) ? \"bleed\" : \"content\";\n          out.push({\n            i: iDump,\n            kind: isTextDump ? \"texto\" : String((nDump.tagName || \"\").toLowerCase()),\n            zone: rootZone,\n            top: +Number(itDump.top || 0).toFixed(1),\n            left: +Number(itDump.left || 0).toFixed(1),\n            w: +Number(itDump.width || 0).toFixed(1),\n            h: +Number(itDump.height || 0).toFixed(1),\n            right: +Number((itDump.left || 0) + (itDump.width || 0)).toFixed(1),\n            bottom: +Number((itDump.top || 0) + (itDump.height || 0)).toFixed(1),\n            cx: +Number((itDump.left || 0) + ((itDump.width || 0) / 2)).toFixed(1),\n            wRatio: contentWNow > 1 ? +Number((itDump.width || 0) / contentWNow).toFixed(3) : null,\n            className: clsDump,\n            mobileLayout: nDump.getAttribute(\"data-mobile-layout\") || \"\",\n            mobileRole: nDump.getAttribute(\"data-mobile-role\") || \"\",\n            mobileCluster: nDump.getAttribute(\"data-mobile-cluster\") || \"\",\n            mobileClusterId: nDump.getAttribute(\"data-mobile-cluster-id\") || \"\",\n            mobileCenter: nDump.getAttribute(\"data-mobile-center\") || \"\",\n            mobileAlign: nDump.getAttribute(\"data-mobile-align\") || \"\",\n            mobileFit: nDump.getAttribute(\"data-mobile-fit\") || \"\",\n            textAlign: (nDump.style && nDump.style.textAlign) ? nDump.style.textAlign : \"\",\n            textSample: isTextDump ? textRaw.slice(0, 90) : \"\"\n          });\n        }\n        reflowElementsDump = out;\n      }\n\n      function logReflowDecision(reason, extra){\n        if (!MSL_DEBUG) return;\n        var payload = {\n          secIndex: secIndex,\n          secModo: secModo,\n          allowReflow: allowReflow,\n          totalNodes: (nodesAll || []).length,\n          reason: String(reason || \"\"),\n          details: extra || {}\n        };\n        mslLog(\"section:reflow:decision\", payload);\n      }\n\n      function finalizeSection(minNeededHeight, preserveBottomGap){\n        var gap = Number.isFinite(preserveBottomGap) ? Math.max(0, Number(preserveBottomGap)) : 0;\n        var fit = applySectionFitScale(\n          sec,\n          content,\n          bleed,\n          nodesAll,\n          secModo,\n          CFG,\n          { secIndex: secIndex },\n          { preserveBottomGap: gap }\n        );\n        var fitNeeded = (fit && Number.isFinite(fit.neededHeight)) ? Number(fit.neededHeight) : 0;\n        var neededHeight = Math.max(Number(minNeededHeight || 0), fitNeeded);\n        mslLog(\"section:heightFinal\", {\n          secIndex: secIndex,\n          mode: secModo,\n          minNeededHeight: +Number(minNeededHeight || 0).toFixed(1),\n          fitNeededHeight: +fitNeeded.toFixed(1),\n          preserveBottomGap: +gap.toFixed(1),\n          finalNeededHeight: +neededHeight.toFixed(1)\n        });\n        if (secModo === \"fijo\" && neededHeight > 0) {\n          expandFixedSection(sec, neededHeight);\n        }\n      }\n\n      if(!nodesAll.length) {\n        logReflowDecision(\"skip:noNodes\", { willApplyReflow: false });\n        finalizeSection(0, 0);\n        return;\n      }\n\n      var debugCounts = {\n        secIndex: secIndex,\n        contentObj: content ? content.querySelectorAll(\".objeto\").length : 0,\n        bleedObj: bleed ? bleed.querySelectorAll(\".objeto\").length : 0,\n        contentAbs: content ? Array.from(content.querySelectorAll(\"*\")).filter(function(el){\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\n        }).length : 0,\n        bleedAbs: bleed ? Array.from(bleed.querySelectorAll(\"*\")).filter(function(el){\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\n        }).length : 0\n      };\n      mslLog(\"section:nodeSources\", debugCounts);\n\n      if (MSL_VERBOSE) {\n        mslLog(\"section:nodesAll:raw\", {\n          secIndex: secIndex,\n          total: nodesAll.length,\n          nodes: nodesAll.map(function(n, i){\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\n            var parentCls = (n.parentElement && n.parentElement.className && typeof n.parentElement.className === \"string\")\n              ? n.parentElement.className\n              : \"\";\n            return {\n              i: i,\n              tag: (n.tagName || \"\").toLowerCase(),\n              cls: cls,\n              parentCls: parentCls,\n              top: n.style ? n.style.top : \"\",\n              left: n.style ? n.style.left : \"\",\n              pos: n.style ? n.style.position : \"\",\n              text: ((n.textContent || \"\").trim()).slice(0, 40)\n            };\n          })\n        });\n        try {\n          var flat = nodesAll.map(function(n, i){\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\n            var txt = ((n.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 60);\n            return \"#\" + i\n              + \" tag=\" + String((n.tagName || \"\").toLowerCase())\n              + \" cls=\" + cls\n              + \" pos=\" + (n.style ? n.style.position : \"\")\n              + \" top=\" + (n.style ? n.style.top : \"\")\n              + \" left=\" + (n.style ? n.style.left : \"\")\n              + \" text=\" + txt;\n          });\n          mslLog(\"section:nodesAll:flat\", \"sec=\" + secIndex + \" total=\" + nodesAll.length + \" :: \" + flat.join(\" | \"));\n        } catch(e) {}\n      }\n      var restoredCount = 0;\n      nodesAll.forEach(function(node){\n        var hasOrigTop = node.hasAttribute(\"data-msl-orig-top\");\n        var hasOrigLeft = node.hasAttribute(\"data-msl-orig-left\");\n        var hasOrigTransform = node.hasAttribute(\"data-msl-orig-transform\");\n        if (!hasOrigTop) node.setAttribute(\"data-msl-orig-top\", node.style.top || \"\");\n        if (!hasOrigLeft) node.setAttribute(\"data-msl-orig-left\", node.style.left || \"\");\n        if (!hasOrigTransform) node.setAttribute(\"data-msl-orig-transform\", node.style.transform || \"\");\n\n        var origTop = node.getAttribute(\"data-msl-orig-top\");\n        var origLeft = node.getAttribute(\"data-msl-orig-left\");\n        var origTransform = node.getAttribute(\"data-msl-orig-transform\");\n\n        if (origTop != null && node.style.top !== origTop) {\n          node.style.top = origTop;\n          restoredCount++;\n        }\n        if (origLeft != null && node.style.left !== origLeft) {\n          node.style.left = origLeft;\n          restoredCount++;\n        }\n        if (origTransform != null && node.style.transform !== origTransform) {\n          node.style.transform = origTransform;\n          restoredCount++;\n        }\n        node.style.right = \"auto\";\n        node.style.marginLeft = \"0px\";\n      });\n      mslLog(\"section:baselineRestore\", { secIndex: secIndex, nodes: nodesAll.length, restored: restoredCount });\n\n      // Rect del content (métricas reales)\n      var contentRect = content.getBoundingClientRect();\n      var contentW = contentRect.width || 0;\n      var secCurrentH = sec.getBoundingClientRect().height || 0;\n      var baseHeightAttr = \"data-msl-base-height\";\n      if (!sec.hasAttribute(baseHeightAttr)) {\n        sec.setAttribute(baseHeightAttr, String(secCurrentH));\n      }\n      var baseSecHeight = parseFloat(sec.getAttribute(baseHeightAttr) || \"\");\n      if (!isFinite(baseSecHeight) || baseSecHeight <= 0) baseSecHeight = secCurrentH;\n\n      // items (rects) en coordenadas del content (TODOS)\n      var itemsAll = nodesAll.map(function(node){\n        var rc = relRect(node, content);\n        return {\n          node: node,\n          top: rc.top,\n          left: rc.left,\n          height: rc.height,\n          width: rc.width\n        };\n      });\n      buildReflowElementsDump(itemsAll, contentW);\n      mslLog(\"section:reflow:elements\", {\n        secIndex: secIndex,\n        secModo: secModo,\n        contentW: +Number(contentW || 0).toFixed(1),\n        total: reflowElementsDump.length,\n        elements: reflowElementsDump\n      });\n      if (MSL_VERBOSE) {\n        mslLog(\"section:itemsAll\", {\n          secIndex: secIndex,\n          total: itemsAll.length,\n          items: itemsAll.map(function(it, idx){\n            return {\n              i: idx,\n              kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\n              top: +it.top.toFixed(1),\n              left: +it.left.toFixed(1),\n              w: +it.width.toFixed(1),\n              h: +it.height.toFixed(1),\n              textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\n            };\n          })\n        });\n      }\n\n      // Preservar el \"aire\" inferior original de la seccion tras el reflow.\n      var maxOriginalBottom = 0;\n      for (var ib=0; ib<itemsAll.length; ib++){\n        var itb = itemsAll[ib];\n        var btm = (itb.top || 0) + (itb.height || 0);\n        if (btm > maxOriginalBottom) maxOriginalBottom = btm;\n      }\n      var baseBottomGap = Math.max(0, baseSecHeight - maxOriginalBottom);\n\n      // Si todo mide 0 (fonts no listas), reintentamos luego\n      var anyValidAll = itemsAll.some(function(it){ return it.height > 0.5; });\n      if(!anyValidAll) {\n        logReflowDecision(\"skip:invalidRects\", {\n          willApplyReflow: false,\n          allHeightsTiny: true\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      if (!allowReflow || nodesAll.length < 2) {\n        logReflowDecision(\"skip:notEligible\", {\n          willApplyReflow: false,\n          allowReflow: allowReflow,\n          totalNodes: nodesAll.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      function detectHeroLikeCentralText(items, rootW){\n        var out = {\n          isHero: false,\n          reason: \"\",\n          textCount: 0,\n          textColumnCount: 0,\n          textColumns: [],\n          singleTextColumn: false,\n          maxTextWidthRatio: null,\n          widthRatio: null,\n          centerDelta: null,\n          centerTol: null,\n          centeredByAlign: false,\n          centeredByGeometry: false,\n          decorNear: 0,\n          decorLeft: 0,\n          decorRight: 0,\n          decorInvadingTextColumn: 0\n        };\n        if (!items || !items.length || !rootW || rootW <= 0) {\n          out.reason = \"noItemsOrWidth\";\n          return out;\n        }\n\n        var textItems = items.filter(function(it){\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\n          var tw = Number(it.width || 0);\n          var th = Number(it.height || 0);\n          return tw > 2 && th > 2;\n        });\n        out.textCount = textItems.length;\n        if (!textItems.length) {\n          out.reason = \"noText\";\n          return out;\n        }\n\n        var explicitHero = false;\n        for (var eh=0; eh<textItems.length; eh++){\n          var roleEh = (textItems[eh].node.getAttribute(\"data-mobile-role\") || \"\").toLowerCase();\n          if (roleEh === \"hero\") {\n            explicitHero = true;\n            break;\n          }\n        }\n\n        var colTol = Math.max(18, rootW * 0.14);\n        var textCols = [];\n        for (var tc=0; tc<textItems.length; tc++){\n          var txt = textItems[tc];\n          var txtCx = Number(txt.left || 0) + Number(txt.width || 0) / 2;\n          var attached = false;\n          for (var cc=0; cc<textCols.length; cc++){\n            if (Math.abs(txtCx - textCols[cc].cx) <= colTol) {\n              var nCol = textCols[cc].count + 1;\n              textCols[cc].cx = ((textCols[cc].cx * textCols[cc].count) + txtCx) / nCol;\n              textCols[cc].count = nCol;\n              textCols[cc].minLeft = Math.min(textCols[cc].minLeft, Number(txt.left || 0));\n              textCols[cc].maxRight = Math.max(textCols[cc].maxRight, Number(txt.left || 0) + Number(txt.width || 0));\n              textCols[cc].minTop = Math.min(textCols[cc].minTop, Number(txt.top || 0));\n              textCols[cc].maxBottom = Math.max(textCols[cc].maxBottom, Number(txt.top || 0) + Number(txt.height || 0));\n              attached = true;\n              break;\n            }\n          }\n          if (!attached) {\n            textCols.push({\n              cx: txtCx,\n              count: 1,\n              minLeft: Number(txt.left || 0),\n              maxRight: Number(txt.left || 0) + Number(txt.width || 0),\n              minTop: Number(txt.top || 0),\n              maxBottom: Number(txt.top || 0) + Number(txt.height || 0)\n            });\n          }\n        }\n        textCols.sort(function(a,b){ return a.cx - b.cx; });\n        out.textColumnCount = textCols.length;\n        out.singleTextColumn = textCols.length === 1;\n        out.textColumns = textCols.map(function(col){\n          return {\n            cx: +Number(col.cx || 0).toFixed(1),\n            count: col.count,\n            left: +Number(col.minLeft || 0).toFixed(1),\n            right: +Number(col.maxRight || 0).toFixed(1),\n            top: +Number(col.minTop || 0).toFixed(1),\n            bottom: +Number(col.maxBottom || 0).toFixed(1)\n          };\n        });\n        if (!out.singleTextColumn) {\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"multiTextColumns\";\n          out.isHero = explicitHero;\n          return out;\n        }\n\n        var centerX = rootW / 2;\n        var textCol = textCols[0];\n        var textCenterX = Number(textCol.cx || centerX);\n        var centerDelta = Math.abs(textCenterX - centerX);\n        var centerTol = Math.max(18, rootW * 0.12);\n        out.centerDelta = +centerDelta.toFixed(1);\n        out.centerTol = +centerTol.toFixed(1);\n\n        var centeredAlignCount = 0;\n        var maxTextWidthRatio = 0;\n        var textTop = Infinity;\n        var textBottom = -Infinity;\n        for (var tix=0; tix<textItems.length; tix++){\n          var t = textItems[tix];\n          var ta = (t.node && t.node.style && t.node.style.textAlign)\n            ? String(t.node.style.textAlign).toLowerCase()\n            : \"\";\n          if (ta === \"center\") centeredAlignCount++;\n          var wRatio = Number(t.width || 0) / Math.max(1, rootW);\n          if (wRatio > maxTextWidthRatio) maxTextWidthRatio = wRatio;\n          textTop = Math.min(textTop, Number(t.top || 0));\n          textBottom = Math.max(textBottom, Number(t.top || 0) + Number(t.height || 0));\n        }\n        out.maxTextWidthRatio = +maxTextWidthRatio.toFixed(3);\n        out.widthRatio = out.maxTextWidthRatio;\n        out.centeredByAlign = centeredAlignCount >= Math.max(1, Math.ceil(textItems.length * 0.5));\n        out.centeredByGeometry = centerDelta <= centerTol;\n        if (!out.centeredByAlign && !out.centeredByGeometry) {\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"singleTextColumnNotCentered\";\n          out.isHero = explicitHero;\n          return out;\n        }\n\n        // Evita marcar como hero textos sueltos muy chicos.\n        if (textItems.length < 2 && maxTextWidthRatio < 0.28 && !explicitHero) {\n          out.reason = \"textTooSmall\";\n          return out;\n        }\n\n        if (!isFinite(textTop) || !isFinite(textBottom) || textBottom <= textTop) {\n          textTop = 0;\n          textBottom = 0;\n        }\n        var nearTop = textTop - Math.max(28, (textBottom - textTop) * 0.2);\n        var nearBottom = textBottom + Math.max(36, (textBottom - textTop) * 0.35);\n        var invadePad = Math.max(24, rootW * 0.17);\n        var invadeLeft = textCenterX - invadePad;\n        var invadeRight = textCenterX + invadePad;\n\n        var decorNear = 0;\n        var decorLeft = 0;\n        var decorRight = 0;\n        var decorInvading = 0;\n\n        for (var iHero=0; iHero<items.length; iHero++){\n          var it = items[iHero];\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") continue;\n\n          var w = Number(it.width || 0);\n          var h = Number(it.height || 0);\n          if (w < 8 || h < 8) continue;\n\n          var top = Number(it.top || 0);\n          var bottom = top + h;\n          var inBand = !(bottom < nearTop || top > nearBottom);\n          if (!inBand) continue;\n\n          decorNear++;\n          var cx = Number(it.left || 0) + w / 2;\n          if (cx < textCenterX - 8) decorLeft++;\n          else if (cx > textCenterX + 8) decorRight++;\n\n          var left = Number(it.left || 0);\n          var right = left + w;\n          if (right > invadeLeft && left < invadeRight) decorInvading++;\n        }\n\n        out.decorNear = decorNear;\n        out.decorLeft = decorLeft;\n        out.decorRight = decorRight;\n        out.decorInvadingTextColumn = decorInvading;\n\n        var decorAround = (decorLeft > 0 && decorRight > 0) || decorNear >= 3;\n        var centeredSingleTextColumn = out.singleTextColumn && (out.centeredByAlign || out.centeredByGeometry);\n        out.isHero = explicitHero || centeredSingleTextColumn;\n        out.reason = out.isHero\n          ? (\n            explicitHero\n              ? \"explicitHeroRole\"\n              : (decorInvading > 0\n                ? \"singleCenteredTextColumnDecorInvades\"\n                : (decorAround\n                  ? \"singleCenteredTextColumnWithDecor\"\n                  : \"singleCenteredTextColumn\"))\n          )\n          : \"noHeroSignal\";\n        return out;\n      }\n\n      function detectInlinePairNoReflow(flowItems, allItems, rootW, CFG){\n        var out = {\n          skip: false,\n          reason: \"\",\n          totalFlow: flowItems ? flowItems.length : 0,\n          totalAll: allItems ? allItems.length : 0,\n          rowDelta: null,\n          rowTol: null,\n          pairSpan: null,\n          pairSpanRatio: null,\n          fitsTogether: false,\n          bothSmall: false,\n          smallWLimit: null,\n          smallHLimit: null,\n          widths: [],\n          heights: []\n        };\n        if (!flowItems || flowItems.length !== 2 || !allItems || allItems.length !== 2 || !rootW || rootW <= 0) {\n          out.reason = \"notExactPair\";\n          return out;\n        }\n\n        var a = flowItems[0];\n        var b = flowItems[1];\n        var aW = Math.max(0, Number(a.width || 0));\n        var bW = Math.max(0, Number(b.width || 0));\n        var aH = Math.max(0, Number(a.height || 0));\n        var bH = Math.max(0, Number(b.height || 0));\n        out.widths = [+aW.toFixed(1), +bW.toFixed(1)];\n        out.heights = [+aH.toFixed(1), +bH.toFixed(1)];\n\n        if (aW < 2 || bW < 2 || aH < 2 || bH < 2) {\n          out.reason = \"invalidSizes\";\n          return out;\n        }\n\n        var rowTol = Math.max(12, Number((CFG && CFG.ROW_TOL) || 28) * 1.2);\n        var rowDelta = Math.abs(Number(a.top || 0) - Number(b.top || 0));\n        out.rowTol = +rowTol.toFixed(1);\n        out.rowDelta = +rowDelta.toFixed(1);\n        if (rowDelta > rowTol) {\n          out.reason = \"notInlineRow\";\n          return out;\n        }\n\n        var smallWLimit = Math.max(74, rootW * 0.42);\n        var smallHLimit = Math.max(34, rootW * 0.2);\n        out.smallWLimit = +smallWLimit.toFixed(1);\n        out.smallHLimit = +smallHLimit.toFixed(1);\n        var bothSmall =\n          aW <= smallWLimit &&\n          bW <= smallWLimit &&\n          aH <= smallHLimit &&\n          bH <= smallHLimit;\n        out.bothSmall = bothSmall;\n        if (!bothSmall) {\n          out.reason = \"pairNotSmall\";\n          return out;\n        }\n\n        var pairLeft = Math.min(Number(a.left || 0), Number(b.left || 0));\n        var pairRight = Math.max(Number(a.left || 0) + aW, Number(b.left || 0) + bW);\n        var pairSpan = Math.max(0, pairRight - pairLeft);\n        var fitsTogether = pairSpan <= (rootW + 1);\n        out.pairSpan = +pairSpan.toFixed(1);\n        out.pairSpanRatio = +(pairSpan / Math.max(1, rootW)).toFixed(3);\n        out.fitsTogether = fitsTogether;\n\n        if (fitsTogether) {\n          out.skip = true;\n          out.reason = \"smallInlinePairFits\";\n          return out;\n        }\n\n        out.reason = \"smallInlinePairOverflow\";\n        return out;\n      }\n\n      function enforceInlinePairGap(flowItems, rootEl, rootW){\n        var out = {\n          applied: false,\n          reason: \"\",\n          minGap: 6,\n          gapBefore: null,\n          gapAfter: null,\n          need: null,\n          moveLeft: 0,\n          moveRight: 0,\n          overflowBefore: false,\n          overflowAfter: false\n        };\n        if (!flowItems || flowItems.length !== 2 || !rootEl || !rootW || rootW <= 0) {\n          out.reason = \"notExactPair\";\n          return out;\n        }\n\n        var a = flowItems[0];\n        var b = flowItems[1];\n        if (!a || !b || !a.node || !b.node) {\n          out.reason = \"missingNodes\";\n          return out;\n        }\n\n        var leftItem = Number(a.left || 0) <= Number(b.left || 0) ? a : b;\n        var rightItem = (leftItem === a) ? b : a;\n\n        var rrL = relRect(leftItem.node, rootEl);\n        var rrR = relRect(rightItem.node, rootEl);\n        var lLeft = Number(rrL.left || 0);\n        var lW = Number(rrL.width || 0);\n        var rLeft = Number(rrR.left || 0);\n        var rW = Number(rrR.width || 0);\n        if (!isFinite(lLeft) || !isFinite(lW) || !isFinite(rLeft) || !isFinite(rW)) {\n          out.reason = \"invalidRects\";\n          return out;\n        }\n\n        var gapBefore = rLeft - (lLeft + lW);\n        out.gapBefore = +gapBefore.toFixed(2);\n        out.overflowBefore = (lLeft < -0.5) || ((rLeft + rW) > (rootW + 0.5));\n\n        var need = Math.max(0, out.minGap - gapBefore);\n        out.need = +need.toFixed(2);\n        if (need <= 0.25) {\n          out.reason = \"alreadySpaced\";\n          out.gapAfter = out.gapBefore;\n          out.overflowAfter = out.overflowBefore;\n          return out;\n        }\n\n        var availRight = Math.max(0, rootW - (rLeft + rW));\n        var availLeft = Math.max(0, lLeft);\n        var moveRight = Math.min(availRight, need);\n        var remaining = Math.max(0, need - moveRight);\n        var moveLeft = Math.min(availLeft, remaining);\n\n        if (moveRight <= 0.01 && moveLeft <= 0.01) {\n          out.reason = \"noRoomToAdjust\";\n          return out;\n        }\n\n        if (moveRight > 0.01) {\n          rightItem.node.style.left = (Number(rightItem.left || 0) + moveRight) + \"px\";\n          rightItem.node.style.right = \"auto\";\n          rightItem.node.style.marginLeft = \"0px\";\n        }\n        if (moveLeft > 0.01) {\n          leftItem.node.style.left = (Number(leftItem.left || 0) - moveLeft) + \"px\";\n          leftItem.node.style.right = \"auto\";\n          leftItem.node.style.marginLeft = \"0px\";\n        }\n\n        var rrL2 = relRect(leftItem.node, rootEl);\n        var rrR2 = relRect(rightItem.node, rootEl);\n        var lLeft2 = Number(rrL2.left || 0);\n        var lW2 = Number(rrL2.width || 0);\n        var rLeft2 = Number(rrR2.left || 0);\n        var rW2 = Number(rrR2.width || 0);\n        var gapAfter = rLeft2 - (lLeft2 + lW2);\n\n        out.moveRight = +moveRight.toFixed(2);\n        out.moveLeft = +moveLeft.toFixed(2);\n        out.gapAfter = isFinite(gapAfter) ? +gapAfter.toFixed(2) : null;\n        out.overflowAfter = (lLeft2 < -0.5) || ((rLeft2 + rW2) > (rootW + 0.5));\n        out.applied = (moveRight > 0.01 || moveLeft > 0.01);\n        out.reason = out.applied ? \"applied\" : \"noChange\";\n        if (isFinite(gapAfter) && gapAfter < -0.2) out.reason = \"appliedButStillOverlap\";\n        return out;\n      }\n\n      // ✅ Determinar qué nodos son \"ANCHOR\" (no se reflowean)\n      // Regla: texto centrado + casi full-width => título/hero, no mover.\n      function isAnchorNode(it){\n        var node = it.node;\n\n        // opt-out explícito\n        var keepLayout = (node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n        if (keepLayout) return true;\n\n        // anchor explícito (si lo usás)\n        var role = (node.getAttribute(\"data-mobile-role\") || \"\");\n        if (role === \"anchor\") return true;\n\n        // heurística para textos\n        var isText = (node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n        if (!isText) return false;\n\n        var ta = (node.style && node.style.textAlign) ? String(node.style.textAlign).toLowerCase() : \"\";\n        if (ta !== \"center\") return false;\n\n        // solo si realmente ocupa casi todo el ancho usable\n        // (esto evita romper textos centrados dentro de columnas)\n        if (contentW > 0 && it.width >= contentW * 0.78) return true;\n\n        return false;\n      }\n\n      // ✅ Flow = todo lo que NO es anchor\n      var itemsFlow = itemsAll.filter(function(it){ return !isAnchorNode(it); });\n      var itemsAnchor = itemsAll.filter(function(it){ return isAnchorNode(it); });\n      mslLog(\"section:anchorSplit\", {\n        secIndex: secIndex,\n        anchors: itemsAnchor.length,\n        flow: itemsFlow.length,\n        anchorsDetail: itemsAnchor.map(function(it){\n          return {\n            kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\n            top: +it.top.toFixed(1),\n            left: +it.left.toFixed(1),\n            w: +it.width.toFixed(1),\n            h: +it.height.toFixed(1),\n            textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\n          };\n        })\n      });\n\n      // Si no hay suficientes elementos reflowables, no hacemos nada\n      if(itemsFlow.length < 2) {\n        logReflowDecision(\"skip:flowTooSmall\", {\n          willApplyReflow: false,\n          flowCount: itemsFlow.length,\n          anchorCount: itemsAnchor.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      // ✅ Para que \"altura necesaria\" no quede corta,\n      // medimos el bottom máximo de anchors (en coords del content)\n      var maxAnchorBottom = 0;\n      itemsAll.forEach(function(it){\n        if (!isAnchorNode(it)) return;\n        var b = (it.top || 0) + (it.height || 0);\n        if (b > maxAnchorBottom) maxAnchorBottom = b;\n      });\n\n      // ✅ 1) agrupar por solape → clusters (SOLO FLOW)\n      var clusters = buildOverlapClusters(itemsFlow);\n      mslLog(\"section:clusters\", {\n        secIndex: secIndex,\n        count: clusters.length,\n        clusters: clusters.map(function(c, idx){\n          return {\n            i: idx,\n            top: +c.top.toFixed(1),\n            left: +c.left.toFixed(1),\n            w: +c.width.toFixed(1),\n            h: +c.height.toFixed(1),\n            cx: +c.cx.toFixed(1),\n            items: c.items.length\n          };\n        })\n      });\n\n      // ✅ 2) Detectar columnas/rows (SOLO FLOW)\n      var rootW = contentW || 0;\n      var ord = orderClustersForMobile(clusters, rootW, CFG);\n      var groups = ord.groups;\n      var mode = ord.mode;\n      mslLog(\"section:ordering\", {\n        secIndex: secIndex,\n        mode: mode,\n        rootW: rootW,\n        groups: groups.map(function(grp, gi){\n          return {\n            g: gi,\n            count: grp.length,\n            tops: grp.map(function(c){ return +c.top.toFixed(1); }),\n            lefts: grp.map(function(c){ return +c.left.toFixed(1); })\n          };\n        })\n      });\n\n      var heroSignal = detectHeroLikeCentralText(itemsAll, rootW);\n      mslLog(\"section:heroCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        isHero: heroSignal.isHero,\n        reason: heroSignal.reason,\n        textCount: heroSignal.textCount,\n        textColumnCount: heroSignal.textColumnCount,\n        singleTextColumn: heroSignal.singleTextColumn,\n        textColumns: heroSignal.textColumns,\n        maxTextWidthRatio: heroSignal.maxTextWidthRatio,\n        widthRatio: heroSignal.widthRatio,\n        centerDelta: heroSignal.centerDelta,\n        centerTol: heroSignal.centerTol,\n        centeredByAlign: heroSignal.centeredByAlign,\n        centeredByGeometry: heroSignal.centeredByGeometry,\n        decorNear: heroSignal.decorNear,\n        decorLeft: heroSignal.decorLeft,\n        decorRight: heroSignal.decorRight,\n        decorInvadingTextColumn: heroSignal.decorInvadingTextColumn\n      });\n      if (heroSignal.isHero) {\n        logReflowDecision(\"skip:heroCentralText\", {\n          willApplyReflow: false,\n          mode: mode,\n          heroReason: heroSignal.reason,\n          hero: heroSignal\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      var inlinePairSignal = detectInlinePairNoReflow(itemsFlow, itemsAll, rootW, CFG);\n      mslLog(\"section:inlinePairCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        skip: inlinePairSignal.skip,\n        reason: inlinePairSignal.reason,\n        totalFlow: inlinePairSignal.totalFlow,\n        totalAll: inlinePairSignal.totalAll,\n        rowDelta: inlinePairSignal.rowDelta,\n        rowTol: inlinePairSignal.rowTol,\n        widths: inlinePairSignal.widths,\n        heights: inlinePairSignal.heights,\n        bothSmall: inlinePairSignal.bothSmall,\n        smallWLimit: inlinePairSignal.smallWLimit,\n        smallHLimit: inlinePairSignal.smallHLimit,\n        pairSpan: inlinePairSignal.pairSpan,\n        pairSpanRatio: inlinePairSignal.pairSpanRatio,\n        fitsTogether: inlinePairSignal.fitsTogether\n      });\n      if (inlinePairSignal.skip) {\n        var inlinePairAdjust = enforceInlinePairGap(itemsFlow, content, rootW);\n        mslLog(\"section:inlinePairAdjust\", {\n          secIndex: secIndex,\n          mode: mode,\n          adjust: inlinePairAdjust\n        });\n        logReflowDecision(\"skip:smallInlinePairFits\", {\n          willApplyReflow: false,\n          mode: mode,\n          inlinePair: inlinePairSignal,\n          inlinePairAdjust: inlinePairAdjust\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      // ✅ 3) Gate \"mejor de ambos mundos\":\n      // - Si es \"one\" (layout ya natural) Y además entra, NO hacemos reflow.\n      // - En cualquier otro caso (two/three/rows), hacemos reflow para lectura mobile,\n      //   incluso aunque \"entre\".\n      var fits = clustersFitInMobile(clusters, content);\n      mslLog(\"section:fitCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        fits: fits,\n        willSkip: (mode === \"one\" && fits)\n      });\n      if (mode === \"one\" && fits) {\n        logReflowDecision(\"skip:modeOneFits\", {\n          willApplyReflow: false,\n          mode: mode,\n          fits: fits,\n          clusters: clusters.length,\n          flowCount: itemsFlow.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      logReflowDecision(\"apply:modeRequiresReflow\", {\n        willApplyReflow: true,\n        mode: mode,\n        fits: fits,\n        clusters: clusters.length,\n        flowCount: itemsFlow.length,\n        anchorCount: itemsAnchor.length,\n        groupSizes: groups.map(function(grp){ return grp.length; })\n      });\n\n      // ✅ 4) Reflow solo sobre FLOW (preserva solapes dentro de cada cluster)\n      var res = applyClusterStack(groups, content, CFG, mode);\n      mslLog(\"section:applyResult\", {\n        secIndex: secIndex,\n        changed: !!(res && res.changed),\n        neededHeight: res ? res.neededHeight : null,\n        maxAnchorBottom: +maxAnchorBottom.toFixed(1),\n        baseBottomGap: +baseBottomGap.toFixed(1)\n      });\n      logReflowDecision(\"postApply\", {\n        willApplyReflow: true,\n        changed: !!(res && res.changed),\n        neededHeight: res ? +Number(res.neededHeight || 0).toFixed(1) : null,\n        mode: mode\n      });\n\n      var neededAfterReflow = 0;\n      if (res && res.changed) {\n        // Evitar que la sección quede chica si hay anchors más abajo\n        var needed = Number(res.neededHeight || 0);\n        if (Number(maxAnchorBottom) > 0) {\n          // sumamos padding bottom para que no quede pegado\n          var anchorNeeded = Math.ceil(maxAnchorBottom + (CFG.PAD_BOT || 0));\n          if (anchorNeeded > needed) needed = anchorNeeded;\n        }\n        if (baseBottomGap > 0) {\n          needed = Math.ceil(needed + baseBottomGap);\n        }\n        if (needed > 0) neededAfterReflow = needed;\n      }\n      finalizeSection(neededAfterReflow, baseBottomGap);\n    });\n  }\n\n  function boot(){\n    mslLog(\"boot\", { cfg: CFG });\n    runOnce();\n    setTimeout(runOnce, 150);\n    setTimeout(runOnce, 600);\n    setTimeout(runOnce, 1800);\n\n    if(document.fonts && document.fonts.ready){\n      document.fonts.ready.then(function(){ runOnce(); }).catch(function(){});\n    }\n  }\n\n  window.addEventListener(\"load\", boot);\n  window.addEventListener(\"resize\", runOnce);\n\n  if(window.visualViewport){\n    window.visualViewport.addEventListener(\"resize\", runOnce);\n    window.visualViewport.addEventListener(\"scroll\", runOnce);\n  }\n\n  if(document.readyState !== \"loading\") boot();\n  else document.addEventListener(\"DOMContentLoaded\", boot);\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFFaEI7QUFDRztBQUNBO0FBQ0E7QUFFdEMsU0FBU0ksWUFBWUMsR0FBcUI7SUFDL0MsSUFBSSxDQUFDQSxJQUFJQyxPQUFPLEVBQUUsT0FBTztJQUV6QixPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQTBGRyxFQUFFRCxJQUFJRSxRQUFRLENBQUM7YUFDZixFQUFFRixJQUFJRyxRQUFRLENBQUM7ZUFDYixFQUFFSCxJQUFJSSxRQUFRLENBQUM7O2FBRWpCLEVBQUVKLElBQUlLLFlBQVksQ0FBQzthQUNuQixFQUFFTCxJQUFJTSxlQUFlLENBQUM7O2dCQUVuQixFQUFFTixJQUFJTyxpQkFBaUIsR0FBRyxTQUFTLFFBQVE7eUJBQ2xDLEVBQUVQLElBQUlRLGlCQUFpQixHQUFHLFNBQVMsUUFBUTs7YUFFdkQsRUFBRVIsSUFBSVMsUUFBUSxDQUFDOzswQkFFRixFQUFFVCxJQUFJVSxpQkFBaUIsQ0FBQzttQkFDL0IsRUFBRVYsSUFBSVcsYUFBYSxDQUFDOzs0QkFFWCxFQUFFWCxJQUFJWSxtQkFBbUIsQ0FBQzttQkFDbkMsRUFBRVosSUFBSWEsYUFBYSxDQUFDOzttQkFFcEIsRUFBRWIsSUFBSWMsV0FBVyxDQUFDO21CQUNsQixFQUFFZCxJQUFJZSxXQUFXLENBQUM7NEJBQ1QsRUFBRWYsSUFBSWdCLG1CQUFtQixDQUFDO3dCQUM5QixFQUFFaEIsSUFBSWlCLGVBQWUsQ0FBQzs7O0VBRzVDLEVBQUV0Qix1REFBaUJBLEdBQUc7O0VBRXRCLEVBQUVFLDBEQUFlQSxHQUFHOztFQUVwQixFQUFFQywwREFBZUEsR0FBRzs7RUFFcEIsRUFBRUYsMERBQWVBLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW01QnRCLENBQUMsQ0FBQ3NCLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcc2NyaXB0VGVtcGxhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9zY3JpcHRUZW1wbGF0ZS50c1xyXG5pbXBvcnQgeyBOb3JtYWxpemVkQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgeyBqc0RvbUhlbHBlcnNCbG9jayB9IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHsganNGaXRTY2FsZUJsb2NrIH0gZnJvbSBcIi4vZml0U2NhbGVcIjtcbmltcG9ydCB7IGpzT3JkZXJpbmdCbG9jayB9IGZyb20gXCIuL29yZGVyaW5nXCI7XG5pbXBvcnQgeyBqc1N0YWNraW5nQmxvY2sgfSBmcm9tIFwiLi9zdGFja2luZ1wiO1xuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNjcmlwdChjZmc6IE5vcm1hbGl6ZWRDb25maWcpOiBzdHJpbmcge1xyXG4gIGlmICghY2ZnLmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICByZXR1cm4gYFxuPHNjcmlwdD5cbihmdW5jdGlvbigpe1xuICB2YXIgRU5BQkxFRCA9IHRydWU7XG4gIGZ1bmN0aW9uIHJlYWREZWJ1Z0ZsYWcobmFtZSl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzZWFyY2ggPSAod2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpID8gd2luZG93LmxvY2F0aW9uLnNlYXJjaCA6IFwiXCI7XG4gICAgICB2YXIgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCk7XG4gICAgICB2YXIgcXYgPSBxcC5nZXQobmFtZSk7XG4gICAgICBpZiAocXYgPT09IFwiMVwiIHx8IFN0cmluZyhxdikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goX2UxKSB7fVxuXG4gICAgLy8gc3JjRG9jL2Fib3V0OnNyY2RvYyBubyBzdWVsZSB0ZW5lciBxdWVyeXN0cmluZy5cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5wYXJlbnQgJiYgd2luZG93LnBhcmVudCAhPT0gd2luZG93ICYmIHdpbmRvdy5wYXJlbnQubG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHBTZWFyY2ggPSB3aW5kb3cucGFyZW50LmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiO1xuICAgICAgICB2YXIgcFEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBTZWFyY2gpO1xuICAgICAgICB2YXIgcFYgPSBwUS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChwViA9PT0gXCIxXCIgfHwgU3RyaW5nKHBWKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIikgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChfZTIpIHt9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy50b3AgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICYmIHdpbmRvdy50b3AubG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHRTZWFyY2ggPSB3aW5kb3cudG9wLmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiO1xuICAgICAgICB2YXIgdFEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRTZWFyY2gpO1xuICAgICAgICB2YXIgdFYgPSB0US5nZXQobmFtZSk7XG4gICAgICAgIGlmICh0ViA9PT0gXCIxXCIgfHwgU3RyaW5nKHRWKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIikgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChfZTMpIHt9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxzID0gd2luZG93LmxvY2FsU3RvcmFnZSA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKSA6IG51bGw7XG4gICAgICBpZiAobHMgPT09IFwiMVwiIHx8IFN0cmluZyhscykudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goX2U0KSB7fVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBNU0xfREVCVUcgPSByZWFkRGVidWdGbGFnKFwibXNsRGVidWdcIik7XG4gIHZhciBNU0xfVkVSQk9TRSA9IHJlYWREZWJ1Z0ZsYWcoXCJtc2xWZXJib3NlXCIpO1xuICBmdW5jdGlvbiBkYmcobGFiZWwsIHBheWxvYWQpe1xuICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltNU0xdIFwiICsgbGFiZWwgKyBcIiBcIiArIHBheWxvYWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldHR5ID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgcHJldHR5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgbnVsbCwgMik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0cnkgeyBwcmV0dHkgPSBTdHJpbmcocGF5bG9hZCk7IH0gY2F0Y2goXykgeyBwcmV0dHkgPSBcIlt1bnNlcmlhbGl6YWJsZV1cIjsgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIltNU0xdIFwiICsgbGFiZWwgKyBcIlxcXFxuXCIgKyBwcmV0dHkpO1xuICB9XG4gIGZ1bmN0aW9uIG1zbExvZygpe1xuICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgbGFiZWwgPSBTdHJpbmcoYXJnc1swXSk7XG4gICAgaWYgKCFNU0xfVkVSQk9TRSkge1xuICAgICAgdmFyIG5vaXN5ID0ge1xuICAgICAgICBcInNlY3Rpb246bm9kZVNvdXJjZXNcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmJhc2VsaW5lUmVzdG9yZVwiOiAxLFxuICAgICAgICBcInNlY3Rpb246YW5jaG9yU3BsaXRcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmNsdXN0ZXJzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6dGhyZWU6Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnRocmVlOnNwcmVhZFwiOiAxLFxuICAgICAgICBcIm9yZGVyOnR3bzpjYW5kaWRhdGVzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6dHdvOnNwcmVhZFwiOiAxLFxuICAgICAgICBcIm9yZGVyOm9uZTpjYW5kaWRhdGVzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6cm93czpmYWxsYmFja1wiOiAxXG4gICAgICB9O1xuICAgICAgaWYgKG5vaXN5W2xhYmVsXSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRiZyhsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgZGJnKGxhYmVsLCBhcmdzWzFdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGJnKGxhYmVsLCBhcmdzLnNsaWNlKDEpKTtcbiAgfVxuXHJcbiAgdmFyIENGRyA9IHtcclxuICAgIE1JTl9HQVA6ICR7Y2ZnLm1pbkdhcFB4fSxcclxuICAgIE1BWF9HQVA6ICR7Y2ZnLm1heEdhcFB4fSxcclxuICAgIEdBUF9TQ0FMRTogJHtjZmcuZ2FwU2NhbGV9LFxyXG5cclxuICAgIFBBRF9UT1A6ICR7Y2ZnLnBhZGRpbmdUb3BQeH0sXHJcbiAgICBQQURfQk9UOiAke2NmZy5wYWRkaW5nQm90dG9tUHh9LFxyXG5cclxuICAgIE9OTFlfRklYRUQ6ICR7Y2ZnLm9ubHlGaXhlZFNlY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9LFxyXG4gICAgT05MWV9XSEVOX1JFT1JERVJFRDogJHtjZmcub25seVdoZW5SZW9yZGVyZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIn0sXHJcblxyXG4gICAgUk9XX1RPTDogJHtjZmcucm93VG9sUHh9LFxyXG5cclxuICAgIFRXT19DT0xfU1BSRUFEX1JBVElPOiAke2NmZy50d29Db2xTcHJlYWRSYXRpb30sXHJcbiAgICBNSU5fUEVSX0NPTF8yOiAke2NmZy5taW5QZXJDb2x1bW4yfSxcclxuXHJcbiAgICBUSFJFRV9DT0xfU1BSRUFEX1JBVElPOiAke2NmZy50aHJlZUNvbFNwcmVhZFJhdGlvfSxcbiAgICBNSU5fUEVSX0NPTF8zOiAke2NmZy5taW5QZXJDb2x1bW4zfSxcblxuICAgIEZJVF9NSU5fU0NBTEU6ICR7Y2ZnLmZpdE1pblNjYWxlfSxcbiAgICBGSVRfTUFYX1NDQUxFOiAke2NmZy5maXRNYXhTY2FsZX0sXG4gICAgRklUX1RBUkdFVF9XSURUSF9SQVRJTzogJHtjZmcuZml0VGFyZ2V0V2lkdGhSYXRpb30sXG4gICAgRklUX01JTl9GSUxMX1JBVElPOiAke2NmZy5maXRNaW5GaWxsUmF0aW99XG4gIH07XG5cclxuICAke2pzRG9tSGVscGVyc0Jsb2NrKCl9XHJcblxyXG4gICR7anNPcmRlcmluZ0Jsb2NrKCl9XHJcblxyXG4gICR7anNTdGFja2luZ0Jsb2NrKCl9XG5cbiAgJHtqc0ZpdFNjYWxlQmxvY2soKX1cblxyXG4gIGZ1bmN0aW9uIGV4cGFuZEZpeGVkU2VjdGlvbihzZWMsIG5lZWRlZEhlaWdodCl7XHJcbiAgICB2YXIgY3VycmVudEggPSBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IDA7XHJcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEggKyAxKSB7XHJcbiAgICAgIHNlYy5zdHlsZS5oZWlnaHQgPSBNYXRoLmNlaWwobmVlZGVkSGVpZ2h0KSArIFwicHhcIjtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzaG91bGRQcm9jZXNzU2VjdGlvbihzZWMpe1xyXG4gICAgaWYoIXNlYykgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYoIUNGRy5PTkxZX0ZJWEVEKSByZXR1cm4gdHJ1ZTtcclxuICAgIHZhciBtb2RvID0gKHNlYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZG9cIikgfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gbW9kbyA9PT0gXCJmaWpvXCI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBydW5PbmNlKCl7XG4gICAgaWYoIUVOQUJMRUQpIHJldHVybjtcbiAgICBpZighaXNNb2JpbGUoKSkge1xuICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSkuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgICB2YXIgY29udGVudCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1jb250ZW50XCIpO1xuICAgICAgICBpZighY29udGVudCkgcmV0dXJuO1xuICAgICAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XG4gICAgICAgIHJlc2V0U2VjdGlvbkZpdFNjYWxlKHNlYywgY29udGVudCwgYmxlZWQpO1xuICAgICAgICBzZWMuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LXNjYWxlXCIsIFwiMVwiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxyXG4gICAgdmFyIHNlY3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VjXCIpKTtcclxuICAgIGlmKCFzZWNzLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgIHNlY3MuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgdmFyIHNlY0luZGV4ID0gc2Vjcy5pbmRleE9mKHNlYyk7XG4gICAgICB2YXIgc2VjTW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGFsbG93UmVmbG93ID0gc2hvdWxkUHJvY2Vzc1NlY3Rpb24oc2VjKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246c3RhcnRcIiwgeyBzZWNJbmRleDogc2VjSW5kZXgsIG1vZG86IHNlY01vZG8sIGFsbG93UmVmbG93OiBhbGxvd1JlZmxvdyB9KTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtY29udGVudFwiKTtcbiAgICAgIGlmKCFjb250ZW50KSByZXR1cm47XG4gICAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XG4gICAgICByZXNldFNlY3Rpb25GaXRTY2FsZShzZWMsIGNvbnRlbnQsIGJsZWVkKTtcbiAgICAgIHZhciBub2Rlc0FsbCA9IGdldE9iak5vZGVzKHNlYyk7XG5cbiAgICAgIHZhciByZWZsb3dFbGVtZW50c0R1bXAgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGJ1aWxkUmVmbG93RWxlbWVudHNEdW1wKGl0ZW1zLCBjb250ZW50V05vdyl7XG4gICAgICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgICAgIHZhciBsaXN0ID0gKGl0ZW1zIHx8IFtdKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gMTIwO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAodmFyIGlEdW1wPTA7IGlEdW1wPGxpc3QubGVuZ3RoICYmIGlEdW1wPG1heEl0ZW1zOyBpRHVtcCsrKXtcbiAgICAgICAgICB2YXIgaXREdW1wID0gbGlzdFtpRHVtcF07XG4gICAgICAgICAgaWYgKCFpdER1bXAgfHwgIWl0RHVtcC5ub2RlKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgbkR1bXAgPSBpdER1bXAubm9kZTtcbiAgICAgICAgICB2YXIgdGV4dFJhdyA9ICgobkR1bXAudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgICAgICB2YXIgaXNUZXh0RHVtcCA9IChuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgICB2YXIgY2xzRHVtcCA9IChuRHVtcC5jbGFzc05hbWUgJiYgdHlwZW9mIG5EdW1wLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikgPyBuRHVtcC5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgIHZhciByb290Wm9uZSA9IChuRHVtcC5jbG9zZXN0ICYmIG5EdW1wLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSA/IFwiYmxlZWRcIiA6IFwiY29udGVudFwiO1xuICAgICAgICAgIG91dC5wdXNoKHtcbiAgICAgICAgICAgIGk6IGlEdW1wLFxuICAgICAgICAgICAga2luZDogaXNUZXh0RHVtcCA/IFwidGV4dG9cIiA6IFN0cmluZygobkR1bXAudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIHpvbmU6IHJvb3Rab25lLFxuICAgICAgICAgICAgdG9wOiArTnVtYmVyKGl0RHVtcC50b3AgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtOdW1iZXIoaXREdW1wLmxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtOdW1iZXIoaXREdW1wLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiArTnVtYmVyKGl0RHVtcC5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHJpZ2h0OiArTnVtYmVyKChpdER1bXAubGVmdCB8fCAwKSArIChpdER1bXAud2lkdGggfHwgMCkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBib3R0b206ICtOdW1iZXIoKGl0RHVtcC50b3AgfHwgMCkgKyAoaXREdW1wLmhlaWdodCB8fCAwKSkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGN4OiArTnVtYmVyKChpdER1bXAubGVmdCB8fCAwKSArICgoaXREdW1wLndpZHRoIHx8IDApIC8gMikpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3UmF0aW86IGNvbnRlbnRXTm93ID4gMSA/ICtOdW1iZXIoKGl0RHVtcC53aWR0aCB8fCAwKSAvIGNvbnRlbnRXTm93KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzRHVtcCxcbiAgICAgICAgICAgIG1vYmlsZUxheW91dDogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVSb2xlOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDbHVzdGVyOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDbHVzdGVySWQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXItaWRcIikgfHwgXCJcIixcbiAgICAgICAgICAgIG1vYmlsZUNlbnRlcjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVBbGlnbjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIixcbiAgICAgICAgICAgIG1vYmlsZUZpdDogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IChuRHVtcC5zdHlsZSAmJiBuRHVtcC5zdHlsZS50ZXh0QWxpZ24pID8gbkR1bXAuc3R5bGUudGV4dEFsaWduIDogXCJcIixcbiAgICAgICAgICAgIHRleHRTYW1wbGU6IGlzVGV4dER1bXAgPyB0ZXh0UmF3LnNsaWNlKDAsIDkwKSA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZWZsb3dFbGVtZW50c0R1bXAgPSBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvZ1JlZmxvd0RlY2lzaW9uKHJlYXNvbiwgZXh0cmEpe1xuICAgICAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgc2VjTW9kbzogc2VjTW9kbyxcbiAgICAgICAgICBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3csXG4gICAgICAgICAgdG90YWxOb2RlczogKG5vZGVzQWxsIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgICAgcmVhc29uOiBTdHJpbmcocmVhc29uIHx8IFwiXCIpLFxuICAgICAgICAgIGRldGFpbHM6IGV4dHJhIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246cmVmbG93OmRlY2lzaW9uXCIsIHBheWxvYWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNlY3Rpb24obWluTmVlZGVkSGVpZ2h0LCBwcmVzZXJ2ZUJvdHRvbUdhcCl7XG4gICAgICAgIHZhciBnYXAgPSBOdW1iZXIuaXNGaW5pdGUocHJlc2VydmVCb3R0b21HYXApID8gTWF0aC5tYXgoMCwgTnVtYmVyKHByZXNlcnZlQm90dG9tR2FwKSkgOiAwO1xuICAgICAgICB2YXIgZml0ID0gYXBwbHlTZWN0aW9uRml0U2NhbGUoXG4gICAgICAgICAgc2VjLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgYmxlZWQsXG4gICAgICAgICAgbm9kZXNBbGwsXG4gICAgICAgICAgc2VjTW9kbyxcbiAgICAgICAgICBDRkcsXG4gICAgICAgICAgeyBzZWNJbmRleDogc2VjSW5kZXggfSxcbiAgICAgICAgICB7IHByZXNlcnZlQm90dG9tR2FwOiBnYXAgfVxuICAgICAgICApO1xuICAgICAgICB2YXIgZml0TmVlZGVkID0gKGZpdCAmJiBOdW1iZXIuaXNGaW5pdGUoZml0Lm5lZWRlZEhlaWdodCkpID8gTnVtYmVyKGZpdC5uZWVkZWRIZWlnaHQpIDogMDtcbiAgICAgICAgdmFyIG5lZWRlZEhlaWdodCA9IE1hdGgubWF4KE51bWJlcihtaW5OZWVkZWRIZWlnaHQgfHwgMCksIGZpdE5lZWRlZCk7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246aGVpZ2h0RmluYWxcIiwge1xuICAgICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgICBtb2RlOiBzZWNNb2RvLFxuICAgICAgICAgIG1pbk5lZWRlZEhlaWdodDogK051bWJlcihtaW5OZWVkZWRIZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBmaXROZWVkZWRIZWlnaHQ6ICtmaXROZWVkZWQudG9GaXhlZCgxKSxcbiAgICAgICAgICBwcmVzZXJ2ZUJvdHRvbUdhcDogK2dhcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGZpbmFsTmVlZGVkSGVpZ2h0OiArbmVlZGVkSGVpZ2h0LnRvRml4ZWQoMSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWNNb2RvID09PSBcImZpam9cIiAmJiBuZWVkZWRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgZXhwYW5kRml4ZWRTZWN0aW9uKHNlYywgbmVlZGVkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZighbm9kZXNBbGwubGVuZ3RoKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpub05vZGVzXCIsIHsgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWJ1Z0NvdW50cyA9IHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjb250ZW50T2JqOiBjb250ZW50ID8gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKS5sZW5ndGggOiAwLFxuICAgICAgICBibGVlZE9iajogYmxlZWQgPyBibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKS5sZW5ndGggOiAwLFxuICAgICAgICBjb250ZW50QWJzOiBjb250ZW50ID8gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5maWx0ZXIoZnVuY3Rpb24oZWwpe1xuICAgICAgICAgIHJldHVybiAhIShlbCAmJiBlbC5zdHlsZSAmJiAoZWwuc3R5bGUucG9zaXRpb24gfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJhYnNvbHV0ZVwiICYmIGVsLnN0eWxlLnRvcCAmJiBlbC5zdHlsZS5sZWZ0KTtcbiAgICAgICAgfSkubGVuZ3RoIDogMCxcbiAgICAgICAgYmxlZWRBYnM6IGJsZWVkID8gQXJyYXkuZnJvbShibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYWJzb2x1dGVcIiAmJiBlbC5zdHlsZS50b3AgJiYgZWwuc3R5bGUubGVmdCk7XG4gICAgICAgIH0pLmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVTb3VyY2VzXCIsIGRlYnVnQ291bnRzKTtcblxuICAgICAgaWYgKE1TTF9WRVJCT1NFKSB7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246bm9kZXNBbGw6cmF3XCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgdG90YWw6IG5vZGVzQWxsLmxlbmd0aCxcbiAgICAgICAgICBub2Rlczogbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG4sIGkpe1xuICAgICAgICAgICAgdmFyIGNscyA9IChuLmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbi5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhcmVudENscyA9IChuLnBhcmVudEVsZW1lbnQgJiYgbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgPyBuLnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIHRhZzogKG4udGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICBjbHM6IGNscyxcbiAgICAgICAgICAgICAgcGFyZW50Q2xzOiBwYXJlbnRDbHMsXG4gICAgICAgICAgICAgIHRvcDogbi5zdHlsZSA/IG4uc3R5bGUudG9wIDogXCJcIixcbiAgICAgICAgICAgICAgbGVmdDogbi5zdHlsZSA/IG4uc3R5bGUubGVmdCA6IFwiXCIsXG4gICAgICAgICAgICAgIHBvczogbi5zdHlsZSA/IG4uc3R5bGUucG9zaXRpb24gOiBcIlwiLFxuICAgICAgICAgICAgICB0ZXh0OiAoKG4udGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5zbGljZSgwLCA0MClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGZsYXQgPSBub2Rlc0FsbC5tYXAoZnVuY3Rpb24obiwgaSl7XG4gICAgICAgICAgICB2YXIgY2xzID0gKG4uY2xhc3NOYW1lICYmIHR5cGVvZiBuLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikgPyBuLmNsYXNzTmFtZSA6IFwiXCI7XG4gICAgICAgICAgICB2YXIgdHh0ID0gKChuLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA2MCk7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBpXG4gICAgICAgICAgICAgICsgXCIgdGFnPVwiICsgU3RyaW5nKChuLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgKyBcIiBjbHM9XCIgKyBjbHNcbiAgICAgICAgICAgICAgKyBcIiBwb3M9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUucG9zaXRpb24gOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIHRvcD1cIiArIChuLnN0eWxlID8gbi5zdHlsZS50b3AgOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIGxlZnQ9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUubGVmdCA6IFwiXCIpXG4gICAgICAgICAgICAgICsgXCIgdGV4dD1cIiArIHR4dDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVzQWxsOmZsYXRcIiwgXCJzZWM9XCIgKyBzZWNJbmRleCArIFwiIHRvdGFsPVwiICsgbm9kZXNBbGwubGVuZ3RoICsgXCIgOjogXCIgKyBmbGF0LmpvaW4oXCIgfCBcIikpO1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdG9yZWRDb3VudCA9IDA7XG4gICAgICBub2Rlc0FsbC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICB2YXIgaGFzT3JpZ1RvcCA9IG5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIik7XG4gICAgICAgIHZhciBoYXNPcmlnTGVmdCA9IG5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIpO1xuICAgICAgICB2YXIgaGFzT3JpZ1RyYW5zZm9ybSA9IG5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10cmFuc2Zvcm1cIik7XG4gICAgICAgIGlmICghaGFzT3JpZ1RvcCkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRvcFwiLCBub2RlLnN0eWxlLnRvcCB8fCBcIlwiKTtcbiAgICAgICAgaWYgKCFoYXNPcmlnTGVmdCkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLWxlZnRcIiwgbm9kZS5zdHlsZS5sZWZ0IHx8IFwiXCIpO1xuICAgICAgICBpZiAoIWhhc09yaWdUcmFuc2Zvcm0pIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10cmFuc2Zvcm1cIiwgbm9kZS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIik7XG5cbiAgICAgICAgdmFyIG9yaWdUb3AgPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIpO1xuICAgICAgICB2YXIgb3JpZ0xlZnQgPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctbGVmdFwiKTtcbiAgICAgICAgdmFyIG9yaWdUcmFuc2Zvcm0gPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIpO1xuXG4gICAgICAgIGlmIChvcmlnVG9wICE9IG51bGwgJiYgbm9kZS5zdHlsZS50b3AgIT09IG9yaWdUb3ApIHtcbiAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IG9yaWdUb3A7XG4gICAgICAgICAgcmVzdG9yZWRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnTGVmdCAhPSBudWxsICYmIG5vZGUuc3R5bGUubGVmdCAhPT0gb3JpZ0xlZnQpIHtcbiAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBvcmlnTGVmdDtcbiAgICAgICAgICByZXN0b3JlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdUcmFuc2Zvcm0gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRyYW5zZm9ybSAhPT0gb3JpZ1RyYW5zZm9ybSkge1xuICAgICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gb3JpZ1RyYW5zZm9ybTtcbiAgICAgICAgICByZXN0b3JlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgfSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmJhc2VsaW5lUmVzdG9yZVwiLCB7IHNlY0luZGV4OiBzZWNJbmRleCwgbm9kZXM6IG5vZGVzQWxsLmxlbmd0aCwgcmVzdG9yZWQ6IHJlc3RvcmVkQ291bnQgfSk7XG5cbiAgICAgIC8vIFJlY3QgZGVsIGNvbnRlbnQgKG3DqXRyaWNhcyByZWFsZXMpXG4gICAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNvbnRlbnRXID0gY29udGVudFJlY3Qud2lkdGggfHwgMDtcbiAgICAgIHZhciBzZWNDdXJyZW50SCA9IHNlYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgMDtcbiAgICAgIHZhciBiYXNlSGVpZ2h0QXR0ciA9IFwiZGF0YS1tc2wtYmFzZS1oZWlnaHRcIjtcbiAgICAgIGlmICghc2VjLmhhc0F0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0cikpIHtcbiAgICAgICAgc2VjLnNldEF0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0ciwgU3RyaW5nKHNlY0N1cnJlbnRIKSk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVNlY0hlaWdodCA9IHBhcnNlRmxvYXQoc2VjLmdldEF0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0cikgfHwgXCJcIik7XG4gICAgICBpZiAoIWlzRmluaXRlKGJhc2VTZWNIZWlnaHQpIHx8IGJhc2VTZWNIZWlnaHQgPD0gMCkgYmFzZVNlY0hlaWdodCA9IHNlY0N1cnJlbnRIO1xuXHJcbiAgICAgIC8vIGl0ZW1zIChyZWN0cykgZW4gY29vcmRlbmFkYXMgZGVsIGNvbnRlbnQgKFRPRE9TKVxyXG4gICAgICB2YXIgaXRlbXNBbGwgPSBub2Rlc0FsbC5tYXAoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIHZhciByYyA9IHJlbFJlY3Qobm9kZSwgY29udGVudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICB0b3A6IHJjLnRvcCxcbiAgICAgICAgICBsZWZ0OiByYy5sZWZ0LFxyXG4gICAgICAgICAgaGVpZ2h0OiByYy5oZWlnaHQsXHJcbiAgICAgICAgICB3aWR0aDogcmMud2lkdGhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgYnVpbGRSZWZsb3dFbGVtZW50c0R1bXAoaXRlbXNBbGwsIGNvbnRlbnRXKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246cmVmbG93OmVsZW1lbnRzXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBzZWNNb2RvOiBzZWNNb2RvLFxuICAgICAgICBjb250ZW50VzogK051bWJlcihjb250ZW50VyB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICB0b3RhbDogcmVmbG93RWxlbWVudHNEdW1wLmxlbmd0aCxcbiAgICAgICAgZWxlbWVudHM6IHJlZmxvd0VsZW1lbnRzRHVtcFxuICAgICAgfSk7XG4gICAgICBpZiAoTVNMX1ZFUkJPU0UpIHtcbiAgICAgICAgbXNsTG9nKFwic2VjdGlvbjppdGVtc0FsbFwiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHRvdGFsOiBpdGVtc0FsbC5sZW5ndGgsXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zQWxsLm1hcChmdW5jdGlvbihpdCwgaWR4KXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGk6IGlkeCxcbiAgICAgICAgICAgICAga2luZDogKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIgPyBcInRleHRvXCIgOiAoaXQubm9kZS50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIHRvcDogK2l0LnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBsZWZ0OiAraXQubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICB3OiAraXQud2lkdGgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgaDogK2l0LmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICB0ZXh0QWxpZ246IChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSA/IGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduIDogXCJcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlc2VydmFyIGVsIFwiYWlyZVwiIGluZmVyaW9yIG9yaWdpbmFsIGRlIGxhIHNlY2Npb24gdHJhcyBlbCByZWZsb3cuXG4gICAgICB2YXIgbWF4T3JpZ2luYWxCb3R0b20gPSAwO1xuICAgICAgZm9yICh2YXIgaWI9MDsgaWI8aXRlbXNBbGwubGVuZ3RoOyBpYisrKXtcbiAgICAgICAgdmFyIGl0YiA9IGl0ZW1zQWxsW2liXTtcbiAgICAgICAgdmFyIGJ0bSA9IChpdGIudG9wIHx8IDApICsgKGl0Yi5oZWlnaHQgfHwgMCk7XG4gICAgICAgIGlmIChidG0gPiBtYXhPcmlnaW5hbEJvdHRvbSkgbWF4T3JpZ2luYWxCb3R0b20gPSBidG07XG4gICAgICB9XG4gICAgICB2YXIgYmFzZUJvdHRvbUdhcCA9IE1hdGgubWF4KDAsIGJhc2VTZWNIZWlnaHQgLSBtYXhPcmlnaW5hbEJvdHRvbSk7XG5cbiAgICAgIC8vIFNpIHRvZG8gbWlkZSAwIChmb250cyBubyBsaXN0YXMpLCByZWludGVudGFtb3MgbHVlZ29cbiAgICAgIHZhciBhbnlWYWxpZEFsbCA9IGl0ZW1zQWxsLnNvbWUoZnVuY3Rpb24oaXQpeyByZXR1cm4gaXQuaGVpZ2h0ID4gMC41OyB9KTtcbiAgICAgIGlmKCFhbnlWYWxpZEFsbCkge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6aW52YWxpZFJlY3RzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGFsbEhlaWdodHNUaW55OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbGxvd1JlZmxvdyB8fCBub2Rlc0FsbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpub3RFbGlnaWJsZVwiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3csXG4gICAgICAgICAgdG90YWxOb2Rlczogbm9kZXNBbGwubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0SGVyb0xpa2VDZW50cmFsVGV4dChpdGVtcywgcm9vdFcpe1xuICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgIGlzSGVybzogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIHRleHRDb3VudDogMCxcbiAgICAgICAgICB0ZXh0Q29sdW1uQ291bnQ6IDAsXG4gICAgICAgICAgdGV4dENvbHVtbnM6IFtdLFxuICAgICAgICAgIHNpbmdsZVRleHRDb2x1bW46IGZhbHNlLFxuICAgICAgICAgIG1heFRleHRXaWR0aFJhdGlvOiBudWxsLFxuICAgICAgICAgIHdpZHRoUmF0aW86IG51bGwsXG4gICAgICAgICAgY2VudGVyRGVsdGE6IG51bGwsXG4gICAgICAgICAgY2VudGVyVG9sOiBudWxsLFxuICAgICAgICAgIGNlbnRlcmVkQnlBbGlnbjogZmFsc2UsXG4gICAgICAgICAgY2VudGVyZWRCeUdlb21ldHJ5OiBmYWxzZSxcbiAgICAgICAgICBkZWNvck5lYXI6IDAsXG4gICAgICAgICAgZGVjb3JMZWZ0OiAwLFxuICAgICAgICAgIGRlY29yUmlnaHQ6IDAsXG4gICAgICAgICAgZGVjb3JJbnZhZGluZ1RleHRDb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9JdGVtc09yV2lkdGhcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICAgICAgaWYgKChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgIT09IFwiMVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgdmFyIHR3ID0gTnVtYmVyKGl0LndpZHRoIHx8IDApO1xuICAgICAgICAgIHZhciB0aCA9IE51bWJlcihpdC5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgcmV0dXJuIHR3ID4gMiAmJiB0aCA+IDI7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXQudGV4dENvdW50ID0gdGV4dEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0ZXh0SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9UZXh0XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBsaWNpdEhlcm8gPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZWg9MDsgZWg8dGV4dEl0ZW1zLmxlbmd0aDsgZWgrKyl7XG4gICAgICAgICAgdmFyIHJvbGVFaCA9ICh0ZXh0SXRlbXNbZWhdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChyb2xlRWggPT09IFwiaGVyb1wiKSB7XG4gICAgICAgICAgICBleHBsaWNpdEhlcm8gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbFRvbCA9IE1hdGgubWF4KDE4LCByb290VyAqIDAuMTQpO1xuICAgICAgICB2YXIgdGV4dENvbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdGM9MDsgdGM8dGV4dEl0ZW1zLmxlbmd0aDsgdGMrKyl7XG4gICAgICAgICAgdmFyIHR4dCA9IHRleHRJdGVtc1t0Y107XG4gICAgICAgICAgdmFyIHR4dEN4ID0gTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgdmFyIGF0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgY2M9MDsgY2M8dGV4dENvbHMubGVuZ3RoOyBjYysrKXtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0eHRDeCAtIHRleHRDb2xzW2NjXS5jeCkgPD0gY29sVG9sKSB7XG4gICAgICAgICAgICAgIHZhciBuQ29sID0gdGV4dENvbHNbY2NdLmNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLmN4ID0gKCh0ZXh0Q29sc1tjY10uY3ggKiB0ZXh0Q29sc1tjY10uY291bnQpICsgdHh0Q3gpIC8gbkNvbDtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLmNvdW50ID0gbkNvbDtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1pbkxlZnQgPSBNYXRoLm1pbih0ZXh0Q29sc1tjY10ubWluTGVmdCwgTnVtYmVyKHR4dC5sZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1heFJpZ2h0ID0gTWF0aC5tYXgodGV4dENvbHNbY2NdLm1heFJpZ2h0LCBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1pblRvcCA9IE1hdGgubWluKHRleHRDb2xzW2NjXS5taW5Ub3AsIE51bWJlcih0eHQudG9wIHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1heEJvdHRvbSA9IE1hdGgubWF4KHRleHRDb2xzW2NjXS5tYXhCb3R0b20sIE51bWJlcih0eHQudG9wIHx8IDApICsgTnVtYmVyKHR4dC5oZWlnaHQgfHwgMCkpO1xuICAgICAgICAgICAgICBhdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0ZXh0Q29scy5wdXNoKHtcbiAgICAgICAgICAgICAgY3g6IHR4dEN4LFxuICAgICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgICAgbWluTGVmdDogTnVtYmVyKHR4dC5sZWZ0IHx8IDApLFxuICAgICAgICAgICAgICBtYXhSaWdodDogTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSxcbiAgICAgICAgICAgICAgbWluVG9wOiBOdW1iZXIodHh0LnRvcCB8fCAwKSxcbiAgICAgICAgICAgICAgbWF4Qm90dG9tOiBOdW1iZXIodHh0LnRvcCB8fCAwKSArIE51bWJlcih0eHQuaGVpZ2h0IHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGV4dENvbHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5jeCAtIGIuY3g7IH0pO1xuICAgICAgICBvdXQudGV4dENvbHVtbkNvdW50ID0gdGV4dENvbHMubGVuZ3RoO1xuICAgICAgICBvdXQuc2luZ2xlVGV4dENvbHVtbiA9IHRleHRDb2xzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgb3V0LnRleHRDb2x1bW5zID0gdGV4dENvbHMubWFwKGZ1bmN0aW9uKGNvbCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiArTnVtYmVyKGNvbC5jeCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgY291bnQ6IGNvbC5jb3VudCxcbiAgICAgICAgICAgIGxlZnQ6ICtOdW1iZXIoY29sLm1pbkxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHJpZ2h0OiArTnVtYmVyKGNvbC5tYXhSaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdG9wOiArTnVtYmVyKGNvbC5taW5Ub3AgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGJvdHRvbTogK051bWJlcihjb2wubWF4Qm90dG9tIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvdXQuc2luZ2xlVGV4dENvbHVtbikge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBleHBsaWNpdEhlcm8gPyBcImV4cGxpY2l0SGVyb1JvbGVcIiA6IFwibXVsdGlUZXh0Q29sdW1uc1wiO1xuICAgICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm87XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZW50ZXJYID0gcm9vdFcgLyAyO1xuICAgICAgICB2YXIgdGV4dENvbCA9IHRleHRDb2xzWzBdO1xuICAgICAgICB2YXIgdGV4dENlbnRlclggPSBOdW1iZXIodGV4dENvbC5jeCB8fCBjZW50ZXJYKTtcbiAgICAgICAgdmFyIGNlbnRlckRlbHRhID0gTWF0aC5hYnModGV4dENlbnRlclggLSBjZW50ZXJYKTtcbiAgICAgICAgdmFyIGNlbnRlclRvbCA9IE1hdGgubWF4KDE4LCByb290VyAqIDAuMTIpO1xuICAgICAgICBvdXQuY2VudGVyRGVsdGEgPSArY2VudGVyRGVsdGEudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LmNlbnRlclRvbCA9ICtjZW50ZXJUb2wudG9GaXhlZCgxKTtcblxuICAgICAgICB2YXIgY2VudGVyZWRBbGlnbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIG1heFRleHRXaWR0aFJhdGlvID0gMDtcbiAgICAgICAgdmFyIHRleHRUb3AgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHRleHRCb3R0b20gPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIHRpeD0wOyB0aXg8dGV4dEl0ZW1zLmxlbmd0aDsgdGl4Kyspe1xuICAgICAgICAgIHZhciB0ID0gdGV4dEl0ZW1zW3RpeF07XG4gICAgICAgICAgdmFyIHRhID0gKHQubm9kZSAmJiB0Lm5vZGUuc3R5bGUgJiYgdC5ub2RlLnN0eWxlLnRleHRBbGlnbilcbiAgICAgICAgICAgID8gU3RyaW5nKHQubm9kZS5zdHlsZS50ZXh0QWxpZ24pLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICBpZiAodGEgPT09IFwiY2VudGVyXCIpIGNlbnRlcmVkQWxpZ25Db3VudCsrO1xuICAgICAgICAgIHZhciB3UmF0aW8gPSBOdW1iZXIodC53aWR0aCB8fCAwKSAvIE1hdGgubWF4KDEsIHJvb3RXKTtcbiAgICAgICAgICBpZiAod1JhdGlvID4gbWF4VGV4dFdpZHRoUmF0aW8pIG1heFRleHRXaWR0aFJhdGlvID0gd1JhdGlvO1xuICAgICAgICAgIHRleHRUb3AgPSBNYXRoLm1pbih0ZXh0VG9wLCBOdW1iZXIodC50b3AgfHwgMCkpO1xuICAgICAgICAgIHRleHRCb3R0b20gPSBNYXRoLm1heCh0ZXh0Qm90dG9tLCBOdW1iZXIodC50b3AgfHwgMCkgKyBOdW1iZXIodC5oZWlnaHQgfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIG91dC5tYXhUZXh0V2lkdGhSYXRpbyA9ICttYXhUZXh0V2lkdGhSYXRpby50b0ZpeGVkKDMpO1xuICAgICAgICBvdXQud2lkdGhSYXRpbyA9IG91dC5tYXhUZXh0V2lkdGhSYXRpbztcbiAgICAgICAgb3V0LmNlbnRlcmVkQnlBbGlnbiA9IGNlbnRlcmVkQWxpZ25Db3VudCA+PSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGV4dEl0ZW1zLmxlbmd0aCAqIDAuNSkpO1xuICAgICAgICBvdXQuY2VudGVyZWRCeUdlb21ldHJ5ID0gY2VudGVyRGVsdGEgPD0gY2VudGVyVG9sO1xuICAgICAgICBpZiAoIW91dC5jZW50ZXJlZEJ5QWxpZ24gJiYgIW91dC5jZW50ZXJlZEJ5R2VvbWV0cnkpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gZXhwbGljaXRIZXJvID8gXCJleHBsaWNpdEhlcm9Sb2xlXCIgOiBcInNpbmdsZVRleHRDb2x1bW5Ob3RDZW50ZXJlZFwiO1xuICAgICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm87XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2aXRhIG1hcmNhciBjb21vIGhlcm8gdGV4dG9zIHN1ZWx0b3MgbXV5IGNoaWNvcy5cbiAgICAgICAgaWYgKHRleHRJdGVtcy5sZW5ndGggPCAyICYmIG1heFRleHRXaWR0aFJhdGlvIDwgMC4yOCAmJiAhZXhwbGljaXRIZXJvKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwidGV4dFRvb1NtYWxsXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNGaW5pdGUodGV4dFRvcCkgfHwgIWlzRmluaXRlKHRleHRCb3R0b20pIHx8IHRleHRCb3R0b20gPD0gdGV4dFRvcCkge1xuICAgICAgICAgIHRleHRUb3AgPSAwO1xuICAgICAgICAgIHRleHRCb3R0b20gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyVG9wID0gdGV4dFRvcCAtIE1hdGgubWF4KDI4LCAodGV4dEJvdHRvbSAtIHRleHRUb3ApICogMC4yKTtcbiAgICAgICAgdmFyIG5lYXJCb3R0b20gPSB0ZXh0Qm90dG9tICsgTWF0aC5tYXgoMzYsICh0ZXh0Qm90dG9tIC0gdGV4dFRvcCkgKiAwLjM1KTtcbiAgICAgICAgdmFyIGludmFkZVBhZCA9IE1hdGgubWF4KDI0LCByb290VyAqIDAuMTcpO1xuICAgICAgICB2YXIgaW52YWRlTGVmdCA9IHRleHRDZW50ZXJYIC0gaW52YWRlUGFkO1xuICAgICAgICB2YXIgaW52YWRlUmlnaHQgPSB0ZXh0Q2VudGVyWCArIGludmFkZVBhZDtcblxuICAgICAgICB2YXIgZGVjb3JOZWFyID0gMDtcbiAgICAgICAgdmFyIGRlY29yTGVmdCA9IDA7XG4gICAgICAgIHZhciBkZWNvclJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGRlY29ySW52YWRpbmcgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlIZXJvPTA7IGlIZXJvPGl0ZW1zLmxlbmd0aDsgaUhlcm8rKyl7XG4gICAgICAgICAgdmFyIGl0ID0gaXRlbXNbaUhlcm9dO1xuICAgICAgICAgIGlmICgoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgY29udGludWU7XG5cbiAgICAgICAgICB2YXIgdyA9IE51bWJlcihpdC53aWR0aCB8fCAwKTtcbiAgICAgICAgICB2YXIgaCA9IE51bWJlcihpdC5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgaWYgKHcgPCA4IHx8IGggPCA4KSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciB0b3AgPSBOdW1iZXIoaXQudG9wIHx8IDApO1xuICAgICAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoO1xuICAgICAgICAgIHZhciBpbkJhbmQgPSAhKGJvdHRvbSA8IG5lYXJUb3AgfHwgdG9wID4gbmVhckJvdHRvbSk7XG4gICAgICAgICAgaWYgKCFpbkJhbmQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZGVjb3JOZWFyKys7XG4gICAgICAgICAgdmFyIGN4ID0gTnVtYmVyKGl0LmxlZnQgfHwgMCkgKyB3IC8gMjtcbiAgICAgICAgICBpZiAoY3ggPCB0ZXh0Q2VudGVyWCAtIDgpIGRlY29yTGVmdCsrO1xuICAgICAgICAgIGVsc2UgaWYgKGN4ID4gdGV4dENlbnRlclggKyA4KSBkZWNvclJpZ2h0Kys7XG5cbiAgICAgICAgICB2YXIgbGVmdCA9IE51bWJlcihpdC5sZWZ0IHx8IDApO1xuICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3O1xuICAgICAgICAgIGlmIChyaWdodCA+IGludmFkZUxlZnQgJiYgbGVmdCA8IGludmFkZVJpZ2h0KSBkZWNvckludmFkaW5nKys7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQuZGVjb3JOZWFyID0gZGVjb3JOZWFyO1xuICAgICAgICBvdXQuZGVjb3JMZWZ0ID0gZGVjb3JMZWZ0O1xuICAgICAgICBvdXQuZGVjb3JSaWdodCA9IGRlY29yUmlnaHQ7XG4gICAgICAgIG91dC5kZWNvckludmFkaW5nVGV4dENvbHVtbiA9IGRlY29ySW52YWRpbmc7XG5cbiAgICAgICAgdmFyIGRlY29yQXJvdW5kID0gKGRlY29yTGVmdCA+IDAgJiYgZGVjb3JSaWdodCA+IDApIHx8IGRlY29yTmVhciA+PSAzO1xuICAgICAgICB2YXIgY2VudGVyZWRTaW5nbGVUZXh0Q29sdW1uID0gb3V0LnNpbmdsZVRleHRDb2x1bW4gJiYgKG91dC5jZW50ZXJlZEJ5QWxpZ24gfHwgb3V0LmNlbnRlcmVkQnlHZW9tZXRyeSk7XG4gICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm8gfHwgY2VudGVyZWRTaW5nbGVUZXh0Q29sdW1uO1xuICAgICAgICBvdXQucmVhc29uID0gb3V0LmlzSGVyb1xuICAgICAgICAgID8gKFxuICAgICAgICAgICAgZXhwbGljaXRIZXJvXG4gICAgICAgICAgICAgID8gXCJleHBsaWNpdEhlcm9Sb2xlXCJcbiAgICAgICAgICAgICAgOiAoZGVjb3JJbnZhZGluZyA+IDBcbiAgICAgICAgICAgICAgICA/IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uRGVjb3JJbnZhZGVzXCJcbiAgICAgICAgICAgICAgICA6IChkZWNvckFyb3VuZFxuICAgICAgICAgICAgICAgICAgPyBcInNpbmdsZUNlbnRlcmVkVGV4dENvbHVtbldpdGhEZWNvclwiXG4gICAgICAgICAgICAgICAgICA6IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uXCIpKVxuICAgICAgICAgIClcbiAgICAgICAgICA6IFwibm9IZXJvU2lnbmFsXCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGVjdElubGluZVBhaXJOb1JlZmxvdyhmbG93SXRlbXMsIGFsbEl0ZW1zLCByb290VywgQ0ZHKXtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICBza2lwOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgdG90YWxGbG93OiBmbG93SXRlbXMgPyBmbG93SXRlbXMubGVuZ3RoIDogMCxcbiAgICAgICAgICB0b3RhbEFsbDogYWxsSXRlbXMgPyBhbGxJdGVtcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJvd0RlbHRhOiBudWxsLFxuICAgICAgICAgIHJvd1RvbDogbnVsbCxcbiAgICAgICAgICBwYWlyU3BhbjogbnVsbCxcbiAgICAgICAgICBwYWlyU3BhblJhdGlvOiBudWxsLFxuICAgICAgICAgIGZpdHNUb2dldGhlcjogZmFsc2UsXG4gICAgICAgICAgYm90aFNtYWxsOiBmYWxzZSxcbiAgICAgICAgICBzbWFsbFdMaW1pdDogbnVsbCxcbiAgICAgICAgICBzbWFsbEhMaW1pdDogbnVsbCxcbiAgICAgICAgICB3aWR0aHM6IFtdLFxuICAgICAgICAgIGhlaWdodHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZmxvd0l0ZW1zIHx8IGZsb3dJdGVtcy5sZW5ndGggIT09IDIgfHwgIWFsbEl0ZW1zIHx8IGFsbEl0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vdEV4YWN0UGFpclwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGZsb3dJdGVtc1swXTtcbiAgICAgICAgdmFyIGIgPSBmbG93SXRlbXNbMV07XG4gICAgICAgIHZhciBhVyA9IE1hdGgubWF4KDAsIE51bWJlcihhLndpZHRoIHx8IDApKTtcbiAgICAgICAgdmFyIGJXID0gTWF0aC5tYXgoMCwgTnVtYmVyKGIud2lkdGggfHwgMCkpO1xuICAgICAgICB2YXIgYUggPSBNYXRoLm1heCgwLCBOdW1iZXIoYS5oZWlnaHQgfHwgMCkpO1xuICAgICAgICB2YXIgYkggPSBNYXRoLm1heCgwLCBOdW1iZXIoYi5oZWlnaHQgfHwgMCkpO1xuICAgICAgICBvdXQud2lkdGhzID0gWythVy50b0ZpeGVkKDEpLCArYlcudG9GaXhlZCgxKV07XG4gICAgICAgIG91dC5oZWlnaHRzID0gWythSC50b0ZpeGVkKDEpLCArYkgudG9GaXhlZCgxKV07XG5cbiAgICAgICAgaWYgKGFXIDwgMiB8fCBiVyA8IDIgfHwgYUggPCAyIHx8IGJIIDwgMikge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcImludmFsaWRTaXplc1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93VG9sID0gTWF0aC5tYXgoMTIsIE51bWJlcigoQ0ZHICYmIENGRy5ST1dfVE9MKSB8fCAyOCkgKiAxLjIpO1xuICAgICAgICB2YXIgcm93RGVsdGEgPSBNYXRoLmFicyhOdW1iZXIoYS50b3AgfHwgMCkgLSBOdW1iZXIoYi50b3AgfHwgMCkpO1xuICAgICAgICBvdXQucm93VG9sID0gK3Jvd1RvbC50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQucm93RGVsdGEgPSArcm93RGVsdGEudG9GaXhlZCgxKTtcbiAgICAgICAgaWYgKHJvd0RlbHRhID4gcm93VG9sKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90SW5saW5lUm93XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzbWFsbFdMaW1pdCA9IE1hdGgubWF4KDc0LCByb290VyAqIDAuNDIpO1xuICAgICAgICB2YXIgc21hbGxITGltaXQgPSBNYXRoLm1heCgzNCwgcm9vdFcgKiAwLjIpO1xuICAgICAgICBvdXQuc21hbGxXTGltaXQgPSArc21hbGxXTGltaXQudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LnNtYWxsSExpbWl0ID0gK3NtYWxsSExpbWl0LnRvRml4ZWQoMSk7XG4gICAgICAgIHZhciBib3RoU21hbGwgPVxuICAgICAgICAgIGFXIDw9IHNtYWxsV0xpbWl0ICYmXG4gICAgICAgICAgYlcgPD0gc21hbGxXTGltaXQgJiZcbiAgICAgICAgICBhSCA8PSBzbWFsbEhMaW1pdCAmJlxuICAgICAgICAgIGJIIDw9IHNtYWxsSExpbWl0O1xuICAgICAgICBvdXQuYm90aFNtYWxsID0gYm90aFNtYWxsO1xuICAgICAgICBpZiAoIWJvdGhTbWFsbCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcInBhaXJOb3RTbWFsbFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFpckxlZnQgPSBNYXRoLm1pbihOdW1iZXIoYS5sZWZ0IHx8IDApLCBOdW1iZXIoYi5sZWZ0IHx8IDApKTtcbiAgICAgICAgdmFyIHBhaXJSaWdodCA9IE1hdGgubWF4KE51bWJlcihhLmxlZnQgfHwgMCkgKyBhVywgTnVtYmVyKGIubGVmdCB8fCAwKSArIGJXKTtcbiAgICAgICAgdmFyIHBhaXJTcGFuID0gTWF0aC5tYXgoMCwgcGFpclJpZ2h0IC0gcGFpckxlZnQpO1xuICAgICAgICB2YXIgZml0c1RvZ2V0aGVyID0gcGFpclNwYW4gPD0gKHJvb3RXICsgMSk7XG4gICAgICAgIG91dC5wYWlyU3BhbiA9ICtwYWlyU3Bhbi50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQucGFpclNwYW5SYXRpbyA9ICsocGFpclNwYW4gLyBNYXRoLm1heCgxLCByb290VykpLnRvRml4ZWQoMyk7XG4gICAgICAgIG91dC5maXRzVG9nZXRoZXIgPSBmaXRzVG9nZXRoZXI7XG5cbiAgICAgICAgaWYgKGZpdHNUb2dldGhlcikge1xuICAgICAgICAgIG91dC5za2lwID0gdHJ1ZTtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJzbWFsbElubGluZVBhaXJGaXRzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5yZWFzb24gPSBcInNtYWxsSW5saW5lUGFpck92ZXJmbG93XCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuZm9yY2VJbmxpbmVQYWlyR2FwKGZsb3dJdGVtcywgcm9vdEVsLCByb290Vyl7XG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgYXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIG1pbkdhcDogNixcbiAgICAgICAgICBnYXBCZWZvcmU6IG51bGwsXG4gICAgICAgICAgZ2FwQWZ0ZXI6IG51bGwsXG4gICAgICAgICAgbmVlZDogbnVsbCxcbiAgICAgICAgICBtb3ZlTGVmdDogMCxcbiAgICAgICAgICBtb3ZlUmlnaHQ6IDAsXG4gICAgICAgICAgb3ZlcmZsb3dCZWZvcmU6IGZhbHNlLFxuICAgICAgICAgIG92ZXJmbG93QWZ0ZXI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZmxvd0l0ZW1zIHx8IGZsb3dJdGVtcy5sZW5ndGggIT09IDIgfHwgIXJvb3RFbCB8fCAhcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vdEV4YWN0UGFpclwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGZsb3dJdGVtc1swXTtcbiAgICAgICAgdmFyIGIgPSBmbG93SXRlbXNbMV07XG4gICAgICAgIGlmICghYSB8fCAhYiB8fCAhYS5ub2RlIHx8ICFiLm5vZGUpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJtaXNzaW5nTm9kZXNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnRJdGVtID0gTnVtYmVyKGEubGVmdCB8fCAwKSA8PSBOdW1iZXIoYi5sZWZ0IHx8IDApID8gYSA6IGI7XG4gICAgICAgIHZhciByaWdodEl0ZW0gPSAobGVmdEl0ZW0gPT09IGEpID8gYiA6IGE7XG5cbiAgICAgICAgdmFyIHJyTCA9IHJlbFJlY3QobGVmdEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIHJyUiA9IHJlbFJlY3QocmlnaHRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciBsTGVmdCA9IE51bWJlcihyckwubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIGxXID0gTnVtYmVyKHJyTC53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIHJMZWZ0ID0gTnVtYmVyKHJyUi5sZWZ0IHx8IDApO1xuICAgICAgICB2YXIgclcgPSBOdW1iZXIocnJSLndpZHRoIHx8IDApO1xuICAgICAgICBpZiAoIWlzRmluaXRlKGxMZWZ0KSB8fCAhaXNGaW5pdGUobFcpIHx8ICFpc0Zpbml0ZShyTGVmdCkgfHwgIWlzRmluaXRlKHJXKSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcImludmFsaWRSZWN0c1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2FwQmVmb3JlID0gckxlZnQgLSAobExlZnQgKyBsVyk7XG4gICAgICAgIG91dC5nYXBCZWZvcmUgPSArZ2FwQmVmb3JlLnRvRml4ZWQoMik7XG4gICAgICAgIG91dC5vdmVyZmxvd0JlZm9yZSA9IChsTGVmdCA8IC0wLjUpIHx8ICgockxlZnQgKyByVykgPiAocm9vdFcgKyAwLjUpKTtcblxuICAgICAgICB2YXIgbmVlZCA9IE1hdGgubWF4KDAsIG91dC5taW5HYXAgLSBnYXBCZWZvcmUpO1xuICAgICAgICBvdXQubmVlZCA9ICtuZWVkLnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChuZWVkIDw9IDAuMjUpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJhbHJlYWR5U3BhY2VkXCI7XG4gICAgICAgICAgb3V0LmdhcEFmdGVyID0gb3V0LmdhcEJlZm9yZTtcbiAgICAgICAgICBvdXQub3ZlcmZsb3dBZnRlciA9IG91dC5vdmVyZmxvd0JlZm9yZTtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF2YWlsUmlnaHQgPSBNYXRoLm1heCgwLCByb290VyAtIChyTGVmdCArIHJXKSk7XG4gICAgICAgIHZhciBhdmFpbExlZnQgPSBNYXRoLm1heCgwLCBsTGVmdCk7XG4gICAgICAgIHZhciBtb3ZlUmlnaHQgPSBNYXRoLm1pbihhdmFpbFJpZ2h0LCBuZWVkKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIG5lZWQgLSBtb3ZlUmlnaHQpO1xuICAgICAgICB2YXIgbW92ZUxlZnQgPSBNYXRoLm1pbihhdmFpbExlZnQsIHJlbWFpbmluZyk7XG5cbiAgICAgICAgaWYgKG1vdmVSaWdodCA8PSAwLjAxICYmIG1vdmVMZWZ0IDw9IDAuMDEpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub1Jvb21Ub0FkanVzdFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW92ZVJpZ2h0ID4gMC4wMSkge1xuICAgICAgICAgIHJpZ2h0SXRlbS5ub2RlLnN0eWxlLmxlZnQgPSAoTnVtYmVyKHJpZ2h0SXRlbS5sZWZ0IHx8IDApICsgbW92ZVJpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHJpZ2h0SXRlbS5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlTGVmdCA+IDAuMDEpIHtcbiAgICAgICAgICBsZWZ0SXRlbS5ub2RlLnN0eWxlLmxlZnQgPSAoTnVtYmVyKGxlZnRJdGVtLmxlZnQgfHwgMCkgLSBtb3ZlTGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgbGVmdEl0ZW0ubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnJMMiA9IHJlbFJlY3QobGVmdEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIHJyUjIgPSByZWxSZWN0KHJpZ2h0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgbExlZnQyID0gTnVtYmVyKHJyTDIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIGxXMiA9IE51bWJlcihyckwyLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgckxlZnQyID0gTnVtYmVyKHJyUjIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIHJXMiA9IE51bWJlcihyclIyLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgZ2FwQWZ0ZXIgPSByTGVmdDIgLSAobExlZnQyICsgbFcyKTtcblxuICAgICAgICBvdXQubW92ZVJpZ2h0ID0gK21vdmVSaWdodC50b0ZpeGVkKDIpO1xuICAgICAgICBvdXQubW92ZUxlZnQgPSArbW92ZUxlZnQudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0LmdhcEFmdGVyID0gaXNGaW5pdGUoZ2FwQWZ0ZXIpID8gK2dhcEFmdGVyLnRvRml4ZWQoMikgOiBudWxsO1xuICAgICAgICBvdXQub3ZlcmZsb3dBZnRlciA9IChsTGVmdDIgPCAtMC41KSB8fCAoKHJMZWZ0MiArIHJXMikgPiAocm9vdFcgKyAwLjUpKTtcbiAgICAgICAgb3V0LmFwcGxpZWQgPSAobW92ZVJpZ2h0ID4gMC4wMSB8fCBtb3ZlTGVmdCA+IDAuMDEpO1xuICAgICAgICBvdXQucmVhc29uID0gb3V0LmFwcGxpZWQgPyBcImFwcGxpZWRcIiA6IFwibm9DaGFuZ2VcIjtcbiAgICAgICAgaWYgKGlzRmluaXRlKGdhcEFmdGVyKSAmJiBnYXBBZnRlciA8IC0wLjIpIG91dC5yZWFzb24gPSBcImFwcGxpZWRCdXRTdGlsbE92ZXJsYXBcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgLy8g4pyFIERldGVybWluYXIgcXXDqSBub2RvcyBzb24gXCJBTkNIT1JcIiAobm8gc2UgcmVmbG93ZWFuKVxuICAgICAgLy8gUmVnbGE6IHRleHRvIGNlbnRyYWRvICsgY2FzaSBmdWxsLXdpZHRoID0+IHTDrXR1bG8vaGVybywgbm8gbW92ZXIuXG4gICAgICBmdW5jdGlvbiBpc0FuY2hvck5vZGUoaXQpe1xuICAgICAgICB2YXIgbm9kZSA9IGl0Lm5vZGU7XHJcblxyXG4gICAgICAgIC8vIG9wdC1vdXQgZXhwbMOtY2l0b1xyXG4gICAgICAgIHZhciBrZWVwTGF5b3V0ID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICBpZiAoa2VlcExheW91dCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIGFuY2hvciBleHBsw61jaXRvIChzaSBsbyB1c8OhcylcclxuICAgICAgICB2YXIgcm9sZSA9IChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLXJvbGVcIikgfHwgXCJcIik7XHJcbiAgICAgICAgaWYgKHJvbGUgPT09IFwiYW5jaG9yXCIpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBoZXVyw61zdGljYSBwYXJhIHRleHRvc1xyXG4gICAgICAgIHZhciBpc1RleHQgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICBpZiAoIWlzVGV4dCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgdGEgPSAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlLnRleHRBbGlnbikgPyBTdHJpbmcobm9kZS5zdHlsZS50ZXh0QWxpZ24pLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xyXG4gICAgICAgIGlmICh0YSAhPT0gXCJjZW50ZXJcIikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBzb2xvIHNpIHJlYWxtZW50ZSBvY3VwYSBjYXNpIHRvZG8gZWwgYW5jaG8gdXNhYmxlXHJcbiAgICAgICAgLy8gKGVzdG8gZXZpdGEgcm9tcGVyIHRleHRvcyBjZW50cmFkb3MgZGVudHJvIGRlIGNvbHVtbmFzKVxyXG4gICAgICAgIGlmIChjb250ZW50VyA+IDAgJiYgaXQud2lkdGggPj0gY29udGVudFcgKiAwLjc4KSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyDinIUgRmxvdyA9IHRvZG8gbG8gcXVlIE5PIGVzIGFuY2hvclxuICAgICAgdmFyIGl0ZW1zRmxvdyA9IGl0ZW1zQWxsLmZpbHRlcihmdW5jdGlvbihpdCl7IHJldHVybiAhaXNBbmNob3JOb2RlKGl0KTsgfSk7XG4gICAgICB2YXIgaXRlbXNBbmNob3IgPSBpdGVtc0FsbC5maWx0ZXIoZnVuY3Rpb24oaXQpeyByZXR1cm4gaXNBbmNob3JOb2RlKGl0KTsgfSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmFuY2hvclNwbGl0XCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBhbmNob3JzOiBpdGVtc0FuY2hvci5sZW5ndGgsXG4gICAgICAgIGZsb3c6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgIGFuY2hvcnNEZXRhaWw6IGl0ZW1zQW5jaG9yLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiID8gXCJ0ZXh0b1wiIDogKGl0Lm5vZGUudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgdG9wOiAraXQudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiAraXQubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdzogK2l0LndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiAraXQuaGVpZ2h0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICB0ZXh0QWxpZ246IChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSA/IGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduIDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxyXG4gICAgICAvLyBTaSBubyBoYXkgc3VmaWNpZW50ZXMgZWxlbWVudG9zIHJlZmxvd2FibGVzLCBubyBoYWNlbW9zIG5hZGFcbiAgICAgIGlmKGl0ZW1zRmxvdy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpmbG93VG9vU21hbGxcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgZmxvd0NvdW50OiBpdGVtc0Zsb3cubGVuZ3RoLFxuICAgICAgICAgIGFuY2hvckNvdW50OiBpdGVtc0FuY2hvci5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXHJcbiAgICAgIC8vIOKchSBQYXJhIHF1ZSBcImFsdHVyYSBuZWNlc2FyaWFcIiBubyBxdWVkZSBjb3J0YSxcclxuICAgICAgLy8gbWVkaW1vcyBlbCBib3R0b20gbcOheGltbyBkZSBhbmNob3JzIChlbiBjb29yZHMgZGVsIGNvbnRlbnQpXHJcbiAgICAgIHZhciBtYXhBbmNob3JCb3R0b20gPSAwO1xyXG4gICAgICBpdGVtc0FsbC5mb3JFYWNoKGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICBpZiAoIWlzQW5jaG9yTm9kZShpdCkpIHJldHVybjtcclxuICAgICAgICB2YXIgYiA9IChpdC50b3AgfHwgMCkgKyAoaXQuaGVpZ2h0IHx8IDApO1xyXG4gICAgICAgIGlmIChiID4gbWF4QW5jaG9yQm90dG9tKSBtYXhBbmNob3JCb3R0b20gPSBiO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIOKchSAxKSBhZ3J1cGFyIHBvciBzb2xhcGUg4oaSIGNsdXN0ZXJzIChTT0xPIEZMT1cpXG4gICAgICB2YXIgY2x1c3RlcnMgPSBidWlsZE92ZXJsYXBDbHVzdGVycyhpdGVtc0Zsb3cpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpjbHVzdGVyc1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgY291bnQ6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJzLm1hcChmdW5jdGlvbihjLCBpZHgpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpOiBpZHgsXG4gICAgICAgICAgICB0b3A6ICtjLnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgbGVmdDogK2MubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdzogK2Mud2lkdGgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGg6ICtjLmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgY3g6ICtjLmN4LnRvRml4ZWQoMSksXG4gICAgICAgICAgICBpdGVtczogYy5pdGVtcy5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIOKchSAyKSBEZXRlY3RhciBjb2x1bW5hcy9yb3dzIChTT0xPIEZMT1cpXG4gICAgICB2YXIgcm9vdFcgPSBjb250ZW50VyB8fCAwO1xuICAgICAgdmFyIG9yZCA9IG9yZGVyQ2x1c3RlcnNGb3JNb2JpbGUoY2x1c3RlcnMsIHJvb3RXLCBDRkcpO1xuICAgICAgdmFyIGdyb3VwcyA9IG9yZC5ncm91cHM7XG4gICAgICB2YXIgbW9kZSA9IG9yZC5tb2RlO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpvcmRlcmluZ1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgICBncm91cHM6IGdyb3Vwcy5tYXAoZnVuY3Rpb24oZ3JwLCBnaSl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGc6IGdpLFxuICAgICAgICAgICAgY291bnQ6IGdycC5sZW5ndGgsXG4gICAgICAgICAgICB0b3BzOiBncnAubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MudG9wLnRvRml4ZWQoMSk7IH0pLFxuICAgICAgICAgICAgbGVmdHM6IGdycC5tYXAoZnVuY3Rpb24oYyl7IHJldHVybiArYy5sZWZ0LnRvRml4ZWQoMSk7IH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaGVyb1NpZ25hbCA9IGRldGVjdEhlcm9MaWtlQ2VudHJhbFRleHQoaXRlbXNBbGwsIHJvb3RXKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246aGVyb0NoZWNrXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBpc0hlcm86IGhlcm9TaWduYWwuaXNIZXJvLFxuICAgICAgICByZWFzb246IGhlcm9TaWduYWwucmVhc29uLFxuICAgICAgICB0ZXh0Q291bnQ6IGhlcm9TaWduYWwudGV4dENvdW50LFxuICAgICAgICB0ZXh0Q29sdW1uQ291bnQ6IGhlcm9TaWduYWwudGV4dENvbHVtbkNvdW50LFxuICAgICAgICBzaW5nbGVUZXh0Q29sdW1uOiBoZXJvU2lnbmFsLnNpbmdsZVRleHRDb2x1bW4sXG4gICAgICAgIHRleHRDb2x1bW5zOiBoZXJvU2lnbmFsLnRleHRDb2x1bW5zLFxuICAgICAgICBtYXhUZXh0V2lkdGhSYXRpbzogaGVyb1NpZ25hbC5tYXhUZXh0V2lkdGhSYXRpbyxcbiAgICAgICAgd2lkdGhSYXRpbzogaGVyb1NpZ25hbC53aWR0aFJhdGlvLFxuICAgICAgICBjZW50ZXJEZWx0YTogaGVyb1NpZ25hbC5jZW50ZXJEZWx0YSxcbiAgICAgICAgY2VudGVyVG9sOiBoZXJvU2lnbmFsLmNlbnRlclRvbCxcbiAgICAgICAgY2VudGVyZWRCeUFsaWduOiBoZXJvU2lnbmFsLmNlbnRlcmVkQnlBbGlnbixcbiAgICAgICAgY2VudGVyZWRCeUdlb21ldHJ5OiBoZXJvU2lnbmFsLmNlbnRlcmVkQnlHZW9tZXRyeSxcbiAgICAgICAgZGVjb3JOZWFyOiBoZXJvU2lnbmFsLmRlY29yTmVhcixcbiAgICAgICAgZGVjb3JMZWZ0OiBoZXJvU2lnbmFsLmRlY29yTGVmdCxcbiAgICAgICAgZGVjb3JSaWdodDogaGVyb1NpZ25hbC5kZWNvclJpZ2h0LFxuICAgICAgICBkZWNvckludmFkaW5nVGV4dENvbHVtbjogaGVyb1NpZ25hbC5kZWNvckludmFkaW5nVGV4dENvbHVtblxuICAgICAgfSk7XG4gICAgICBpZiAoaGVyb1NpZ25hbC5pc0hlcm8pIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOmhlcm9DZW50cmFsVGV4dFwiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGhlcm9SZWFzb246IGhlcm9TaWduYWwucmVhc29uLFxuICAgICAgICAgIGhlcm86IGhlcm9TaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5saW5lUGFpclNpZ25hbCA9IGRldGVjdElubGluZVBhaXJOb1JlZmxvdyhpdGVtc0Zsb3csIGl0ZW1zQWxsLCByb290VywgQ0ZHKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246aW5saW5lUGFpckNoZWNrXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBza2lwOiBpbmxpbmVQYWlyU2lnbmFsLnNraXAsXG4gICAgICAgIHJlYXNvbjogaW5saW5lUGFpclNpZ25hbC5yZWFzb24sXG4gICAgICAgIHRvdGFsRmxvdzogaW5saW5lUGFpclNpZ25hbC50b3RhbEZsb3csXG4gICAgICAgIHRvdGFsQWxsOiBpbmxpbmVQYWlyU2lnbmFsLnRvdGFsQWxsLFxuICAgICAgICByb3dEZWx0YTogaW5saW5lUGFpclNpZ25hbC5yb3dEZWx0YSxcbiAgICAgICAgcm93VG9sOiBpbmxpbmVQYWlyU2lnbmFsLnJvd1RvbCxcbiAgICAgICAgd2lkdGhzOiBpbmxpbmVQYWlyU2lnbmFsLndpZHRocyxcbiAgICAgICAgaGVpZ2h0czogaW5saW5lUGFpclNpZ25hbC5oZWlnaHRzLFxuICAgICAgICBib3RoU21hbGw6IGlubGluZVBhaXJTaWduYWwuYm90aFNtYWxsLFxuICAgICAgICBzbWFsbFdMaW1pdDogaW5saW5lUGFpclNpZ25hbC5zbWFsbFdMaW1pdCxcbiAgICAgICAgc21hbGxITGltaXQ6IGlubGluZVBhaXJTaWduYWwuc21hbGxITGltaXQsXG4gICAgICAgIHBhaXJTcGFuOiBpbmxpbmVQYWlyU2lnbmFsLnBhaXJTcGFuLFxuICAgICAgICBwYWlyU3BhblJhdGlvOiBpbmxpbmVQYWlyU2lnbmFsLnBhaXJTcGFuUmF0aW8sXG4gICAgICAgIGZpdHNUb2dldGhlcjogaW5saW5lUGFpclNpZ25hbC5maXRzVG9nZXRoZXJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlubGluZVBhaXJTaWduYWwuc2tpcCkge1xuICAgICAgICB2YXIgaW5saW5lUGFpckFkanVzdCA9IGVuZm9yY2VJbmxpbmVQYWlyR2FwKGl0ZW1zRmxvdywgY29udGVudCwgcm9vdFcpO1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOmlubGluZVBhaXJBZGp1c3RcIiwge1xuICAgICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGFkanVzdDogaW5saW5lUGFpckFkanVzdFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOnNtYWxsSW5saW5lUGFpckZpdHNcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBpbmxpbmVQYWlyOiBpbmxpbmVQYWlyU2lnbmFsLFxuICAgICAgICAgIGlubGluZVBhaXJBZGp1c3Q6IGlubGluZVBhaXJBZGp1c3RcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyDinIUgMykgR2F0ZSBcIm1lam9yIGRlIGFtYm9zIG11bmRvc1wiOlxuICAgICAgLy8gLSBTaSBlcyBcIm9uZVwiIChsYXlvdXQgeWEgbmF0dXJhbCkgWSBhZGVtw6FzIGVudHJhLCBOTyBoYWNlbW9zIHJlZmxvdy5cbiAgICAgIC8vIC0gRW4gY3VhbHF1aWVyIG90cm8gY2FzbyAodHdvL3RocmVlL3Jvd3MpLCBoYWNlbW9zIHJlZmxvdyBwYXJhIGxlY3R1cmEgbW9iaWxlLFxuICAgICAgLy8gICBpbmNsdXNvIGF1bnF1ZSBcImVudHJlXCIuXHJcbiAgICAgIHZhciBmaXRzID0gY2x1c3RlcnNGaXRJbk1vYmlsZShjbHVzdGVycywgY29udGVudCk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmZpdENoZWNrXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBmaXRzOiBmaXRzLFxuICAgICAgICB3aWxsU2tpcDogKG1vZGUgPT09IFwib25lXCIgJiYgZml0cylcbiAgICAgIH0pO1xuICAgICAgaWYgKG1vZGUgPT09IFwib25lXCIgJiYgZml0cykge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6bW9kZU9uZUZpdHNcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBmaXRzOiBmaXRzLFxuICAgICAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgICAgZmxvd0NvdW50OiBpdGVtc0Zsb3cubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJhcHBseTptb2RlUmVxdWlyZXNSZWZsb3dcIiwge1xuICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IHRydWUsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGZpdHM6IGZpdHMsXG4gICAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aCxcbiAgICAgICAgYW5jaG9yQ291bnQ6IGl0ZW1zQW5jaG9yLmxlbmd0aCxcbiAgICAgICAgZ3JvdXBTaXplczogZ3JvdXBzLm1hcChmdW5jdGlvbihncnApeyByZXR1cm4gZ3JwLmxlbmd0aDsgfSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyDinIUgNCkgUmVmbG93IHNvbG8gc29icmUgRkxPVyAocHJlc2VydmEgc29sYXBlcyBkZW50cm8gZGUgY2FkYSBjbHVzdGVyKVxuICAgICAgdmFyIHJlcyA9IGFwcGx5Q2x1c3RlclN0YWNrKGdyb3VwcywgY29udGVudCwgQ0ZHLCBtb2RlKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246YXBwbHlSZXN1bHRcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIGNoYW5nZWQ6ICEhKHJlcyAmJiByZXMuY2hhbmdlZCksXG4gICAgICAgIG5lZWRlZEhlaWdodDogcmVzID8gcmVzLm5lZWRlZEhlaWdodCA6IG51bGwsXG4gICAgICAgIG1heEFuY2hvckJvdHRvbTogK21heEFuY2hvckJvdHRvbS50b0ZpeGVkKDEpLFxuICAgICAgICBiYXNlQm90dG9tR2FwOiArYmFzZUJvdHRvbUdhcC50b0ZpeGVkKDEpXG4gICAgICB9KTtcbiAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwicG9zdEFwcGx5XCIsIHtcbiAgICAgICAgd2lsbEFwcGx5UmVmbG93OiB0cnVlLFxuICAgICAgICBjaGFuZ2VkOiAhIShyZXMgJiYgcmVzLmNoYW5nZWQpLFxuICAgICAgICBuZWVkZWRIZWlnaHQ6IHJlcyA/ICtOdW1iZXIocmVzLm5lZWRlZEhlaWdodCB8fCAwKS50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBuZWVkZWRBZnRlclJlZmxvdyA9IDA7XG4gICAgICBpZiAocmVzICYmIHJlcy5jaGFuZ2VkKSB7XG4gICAgICAgIC8vIEV2aXRhciBxdWUgbGEgc2VjY2nDs24gcXVlZGUgY2hpY2Egc2kgaGF5IGFuY2hvcnMgbcOhcyBhYmFqb1xuICAgICAgICB2YXIgbmVlZGVkID0gTnVtYmVyKHJlcy5uZWVkZWRIZWlnaHQgfHwgMCk7XG4gICAgICAgIGlmIChOdW1iZXIobWF4QW5jaG9yQm90dG9tKSA+IDApIHtcbiAgICAgICAgICAvLyBzdW1hbW9zIHBhZGRpbmcgYm90dG9tIHBhcmEgcXVlIG5vIHF1ZWRlIHBlZ2Fkb1xuICAgICAgICAgIHZhciBhbmNob3JOZWVkZWQgPSBNYXRoLmNlaWwobWF4QW5jaG9yQm90dG9tICsgKENGRy5QQURfQk9UIHx8IDApKTtcbiAgICAgICAgICBpZiAoYW5jaG9yTmVlZGVkID4gbmVlZGVkKSBuZWVkZWQgPSBhbmNob3JOZWVkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VCb3R0b21HYXAgPiAwKSB7XG4gICAgICAgICAgbmVlZGVkID0gTWF0aC5jZWlsKG5lZWRlZCArIGJhc2VCb3R0b21HYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkZWQgPiAwKSBuZWVkZWRBZnRlclJlZmxvdyA9IG5lZWRlZDtcbiAgICAgIH1cbiAgICAgIGZpbmFsaXplU2VjdGlvbihuZWVkZWRBZnRlclJlZmxvdywgYmFzZUJvdHRvbUdhcCk7XG4gICAgfSk7XG4gIH1cblxyXG4gIGZ1bmN0aW9uIGJvb3QoKXtcbiAgICBtc2xMb2coXCJib290XCIsIHsgY2ZnOiBDRkcgfSk7XG4gICAgcnVuT25jZSgpO1xuICAgIHNldFRpbWVvdXQocnVuT25jZSwgMTUwKTtcclxuICAgIHNldFRpbWVvdXQocnVuT25jZSwgNjAwKTtcclxuICAgIHNldFRpbWVvdXQocnVuT25jZSwgMTgwMCk7XHJcblxyXG4gICAgaWYoZG9jdW1lbnQuZm9udHMgJiYgZG9jdW1lbnQuZm9udHMucmVhZHkpe1xyXG4gICAgICBkb2N1bWVudC5mb250cy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7IHJ1bk9uY2UoKTsgfSkuY2F0Y2goZnVuY3Rpb24oKXt9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBib290KTtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBydW5PbmNlKTtcclxuXHJcbiAgaWYod2luZG93LnZpc3VhbFZpZXdwb3J0KXtcclxuICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJ1bk9uY2UpO1xyXG4gICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgcnVuT25jZSk7XHJcbiAgfVxyXG5cclxuICBpZihkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikgYm9vdCgpO1xyXG4gIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgYm9vdCk7XHJcbn0pKCk7XHJcbjwvc2NyaXB0PlxyXG5gLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsianNEb21IZWxwZXJzQmxvY2siLCJqc0ZpdFNjYWxlQmxvY2siLCJqc09yZGVyaW5nQmxvY2siLCJqc1N0YWNraW5nQmxvY2siLCJidWlsZFNjcmlwdCIsImNmZyIsImVuYWJsZWQiLCJtaW5HYXBQeCIsIm1heEdhcFB4IiwiZ2FwU2NhbGUiLCJwYWRkaW5nVG9wUHgiLCJwYWRkaW5nQm90dG9tUHgiLCJvbmx5Rml4ZWRTZWN0aW9ucyIsIm9ubHlXaGVuUmVvcmRlcmVkIiwicm93VG9sUHgiLCJ0d29Db2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjIiLCJ0aHJlZUNvbFNwcmVhZFJhdGlvIiwibWluUGVyQ29sdW1uMyIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGUiLCJmaXRUYXJnZXRXaWR0aFJhdGlvIiwiZml0TWluRmlsbFJhdGlvIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/stacking.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsStackingBlock: () => (/* binding */ jsStackingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/stacking.ts\nfunction jsStackingBlock() {\n    return `\n  // Centro real del área usable (compensa padding safe-left/right)\n  function computeCenterX(rootEl){\n    var rootRect = rootEl.getBoundingClientRect();\n    var rootW = rootRect.width || 0;\n\n    var cs = getComputedStyle(rootEl);\n    var padL = parseFloat(cs.paddingLeft) || 0;\n    var padR = parseFloat(cs.paddingRight) || 0;\n\n    var usableW = Math.max(0, rootW - padL - padR);\n    var centerX = padL + usableW / 2; // centro del área usable\n\n    return { rootW: rootW, usableW: usableW, centerX: centerX, padL: padL, padR: padR };\n  }\n\n  function clamp(n, a, b){\n    if (!isFinite(n)) return a;\n    return Math.max(a, Math.min(b, n));\n  }\n\n  /**\n   * Apila CLUSTERS por groups (columnas/filas) y:\n   * - mueve cada cluster como bloque\n   * - preserva solape/posiciones relativas dentro del cluster\n   * - centra el cluster como bloque en el eje X (sin transform)\n   *\n   * Devuelve changed + neededHeight (para expandir sección)\n   */\n  function applyClusterStack(groups, rootEl, CFG, mode){\n    var info = computeCenterX(rootEl);\n    var centerX = info.centerX;\n    mslLog(\"stack:start\", {\n      groupCount: groups.length,\n      groupSizes: groups.map(function(g){ return g.length; }),\n      centerX: +centerX.toFixed(1),\n      usableW: +info.usableW.toFixed(1)\n    });\n\n    var changed = false;\n    var isMultiColLayout = (mode === \"two\" || mode === \"three\");\n\n    // En multi-columna: cada columna apilada se centra por su propio bbox.\n    // Así, el centro de cada columna coincide con el centro de pantalla.\n\n    // --- Anchor global: dónde estaba “el bloque” originalmente ---\n    var firstGroup = groups[0] || [];\n    var anchor = Infinity;\n    for (var i=0;i<firstGroup.length;i++){\n      anchor = Math.min(anchor, firstGroup[i].top);\n    }\n    if (!isFinite(anchor)) anchor = CFG.PAD_TOP;\n    anchor = Math.max(CFG.PAD_TOP, anchor);\n\n    // Cursor global: dónde termina el contenido apilado hasta ahora\n    var globalCursor = anchor;\n\n    // Separación entre columnas apiladas (izq, centro, der)\n    var GROUP_GAP = 14;\n\n    for (var g=0; g<groups.length; g++){\n      var col = groups[g] || [];\n      if (!col.length) continue;\n      var colReferenceCenterX = NaN;\n      var colSourceReferenceCenterX = NaN;\n\n      // Métricas por grupo solo para debug.\n      var groupMinLeft = Infinity;\n      var groupMaxRight = -Infinity;\n      if (isMultiColLayout){\n        for (var gg=0; gg<col.length; gg++){\n          groupMinLeft = Math.min(groupMinLeft, col[gg].left);\n          groupMaxRight = Math.max(groupMaxRight, col[gg].left + col[gg].width);\n        }\n      }\n      var groupWidth = isMultiColLayout ? Math.max(0, groupMaxRight - groupMinLeft) : 0;\n      var groupBaseLeft = isMultiColLayout ? (centerX - groupWidth / 2) : 0;\n\n      // Offset vertical original de esta columna respecto del anchor\n      var colMinTop = Infinity;\n      for (var k=0;k<col.length;k++){\n        colMinTop = Math.min(colMinTop, col[k].top);\n      }\n      if (!isFinite(colMinTop)) colMinTop = anchor;\n\n      var colOffset = colMinTop - anchor;\n      var colStart = globalCursor + (g === 0 ? 0 : GROUP_GAP) + Math.max(0, colOffset);\n      mslLog(\"stack:group:start\", {\n        g: g,\n        colSize: col.length,\n        colMinTop: +colMinTop.toFixed(1),\n        colOffset: +colOffset.toFixed(1),\n        colStart: +colStart.toFixed(1),\n        globalCursor: +globalCursor.toFixed(1),\n        mode: mode,\n        groupMinLeft: isMultiColLayout ? +groupMinLeft.toFixed(1) : null,\n        groupWidth: isMultiColLayout ? +groupWidth.toFixed(1) : null,\n        groupBaseLeft: isMultiColLayout ? +groupBaseLeft.toFixed(1) : null\n      });\n\n      // Cursor local de esta columna\n      var colCursor = colStart;\n\n      for (var j=0; j<col.length; j++){\n        var c = col[j];\n\n        // Top del cluster en el flujo mobile\n        var clusterTop;\n\n        if (j === 0) {\n          clusterTop = colCursor;\n        } else {\n          var prevC = col[j-1];\n          var prevBottom = (clusterTopPrev + prevC.height);\n\n          // ✅ Gap original entre clusters (canvas)\n          var prevBottomOrig = (prevC.top + prevC.height);\n          var gapOrig = c.top - prevBottomOrig;\n          if (!isFinite(gapOrig)) gapOrig = 0;\n\n          var overlapInSource = gapOrig < 0;\n          if ((mode === \"two\" || mode === \"three\") && overlapInSource) {\n            // Si en el original este cluster cae dentro del anterior, respetamos\n            // su top relativo para no mandarlo al final de la columna.\n            var relTopInCol = c.top - colMinTop;\n            if (!isFinite(relTopInCol)) relTopInCol = 0;\n            clusterTop = colStart + Math.max(0, relTopInCol);\n          } else {\n            // ✅ Gap “mobile-friendly”: escalado + clamp\n            var gapWanted = clamp(gapOrig * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\n\n            // ✅ Anti-solape definitivo:\n            //   el próximo cluster SIEMPRE empieza después del bottom real del anterior + gapWanted\n            clusterTop = prevBottom + gapWanted;\n\n            // En multi-columna nunca avanzamos hacia arriba respecto al flujo ya consumido.\n            if ((mode === \"two\" || mode === \"three\") && clusterTop < colCursor) {\n              clusterTop = colCursor;\n            }\n          }\n        }\n\n        // Guardamos para el próximo loop\n        var clusterTopPrev = clusterTop;\n\n        // ¿centrar este cluster?\n        var forceCenter = false;\n        var hasTextInCluster = false;\n        var hasNonTextInCluster = false;\n        for (var t=0; t<c.items.length; t++){\n          var isTextT = (c.items[t].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          if (isTextT) hasTextInCluster = true;\n          else hasNonTextInCluster = true;\n          if ((c.items[t].node.getAttribute(\"data-mobile-center\") || \"\") === \"force\") {\n            forceCenter = true;\n          }\n        }\n\n        // one/rows: centro por cluster (comportamiento original)\n        // two/three: apilar cada columna en la misma referencia X,\n        // preservando offsets internos de esa columna.\n        var keepCenter = forceCenter ? true : (c.width < (info.usableW * 0.95));\n        var clusterLeft = keepCenter ? (centerX - c.width / 2) : c.left;\n        var isTextOnlyCluster = hasTextInCluster && !hasNonTextInCluster;\n        var shouldCenterTextWithinCluster = false;\n        if (isMultiColLayout) {\n          // Modo lectura mobile multi-col:\n          // usar una misma referencia X para toda la columna apilada y\n          // preservar el offset horizontal original de cada cluster.\n          // Esto mantiene alineado texto/forma cuando la columna se parte\n          // en varios clusters.\n          var relClusterLeft = (c.left || 0) - (groupMinLeft || 0);\n          clusterLeft = groupBaseLeft + relClusterLeft;\n\n          // Permite forzar centrado por cluster si el nodo lo pide.\n          if (forceCenter) clusterLeft = centerX - c.width / 2;\n\n          // Si esta columna tiene un cluster con forma (o mixto), usamos su\n          // centro como referencia para alinear clusters solo-texto debajo.\n          var clusterRefCenterX = NaN;\n          if (hasNonTextInCluster) {\n            // Referencia basada en items no-texto (forma/icono), no en todo el\n            // cluster, para que textos largos no desplacen el centro de columna.\n            var ntMinRel = Infinity;\n            var ntMaxRel = -Infinity;\n            for (var nti=0; nti<c.items.length; nti++){\n              var ntIt = c.items[nti];\n              var ntIsText = (ntIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              if (ntIsText) continue;\n              ntMinRel = Math.min(ntMinRel, (ntIt._relLeft || 0));\n              ntMaxRel = Math.max(ntMaxRel, (ntIt._relLeft || 0) + (ntIt.width || 0));\n            }\n            var sourceClusterRefCenterX = NaN;\n            if (isFinite(ntMinRel) && isFinite(ntMaxRel) && ntMaxRel > ntMinRel) {\n              clusterRefCenterX = clusterLeft + ((ntMinRel + ntMaxRel) / 2);\n              sourceClusterRefCenterX = (c.left || 0) + ((ntMinRel + ntMaxRel) / 2);\n            } else {\n              clusterRefCenterX = clusterLeft + c.width / 2;\n              sourceClusterRefCenterX = (c.left || 0) + c.width / 2;\n            }\n\n            colReferenceCenterX = clusterRefCenterX;\n            colSourceReferenceCenterX = sourceClusterRefCenterX;\n          }\n\n          if (isTextOnlyCluster && isFinite(colReferenceCenterX)) {\n            var maxSnapDelta = Math.min(120, info.usableW * 0.35);\n            var sourceClusterCenterX = (c.left || 0) + c.width / 2;\n            var sourceDriftX = isFinite(colSourceReferenceCenterX)\n              ? (sourceClusterCenterX - colSourceReferenceCenterX)\n              : NaN;\n            if (isFinite(sourceDriftX) && Math.abs(sourceDriftX) <= maxSnapDelta) {\n              clusterLeft = (colReferenceCenterX + sourceDriftX) - c.width / 2;\n            }\n            // Para labels cortos, centrar el contenido textual dentro del box.\n            shouldCenterTextWithinCluster = c.width <= (info.usableW * 0.65);\n          }\n        }\n        mslLog(\"stack:cluster\", {\n          g: g,\n          j: j,\n          origTop: +c.top.toFixed(1),\n          origLeft: +c.left.toFixed(1),\n          newTop: +clusterTop.toFixed(1),\n          newLeft: +clusterLeft.toFixed(1),\n          h: +c.height.toFixed(1),\n          w: +c.width.toFixed(1),\n          forceCenter: forceCenter,\n          keepCenter: keepCenter,\n          items: c.items.length,\n          colReferenceCenterX: (typeof colReferenceCenterX === \"number\" && isFinite(colReferenceCenterX)) ? +colReferenceCenterX.toFixed(1) : null,\n          isTextOnlyCluster: isTextOnlyCluster,\n          centerShortText: shouldCenterTextWithinCluster\n        });\n\n        var textCount = 0;\n        for (var tc=0; tc<c.items.length; tc++){\n          if ((c.items[tc].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textCount++;\n        }\n        var linearizeCluster = (mode === \"rows\" && c.items.length > 1 && textCount >= 2);\n        var clusterBottomUsed = clusterTop + c.height;\n\n        // Caso especial: en rows, si el cluster agrupa varios textos, lo\n        // convertimos a flujo vertical centrado para evitar texto lado a lado.\n        if (linearizeCluster){\n          var allItems = c.items.slice();\n          var nonText = allItems.filter(function(itx){\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\";\n          }).sort(function(a,b){\n            if (a.top !== b.top) return a.top - b.top;\n            return a.left - b.left;\n          });\n          var texts = allItems.filter(function(itx){\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          }).sort(function(a,b){\n            if (a.top !== b.top) return a.top - b.top;\n            return a.left - b.left;\n          });\n\n          // Orden semántico de lectura:\n          // no-texto + texto más cercano (debajo y por eje X), luego remanentes.\n          var ordered = [];\n          var usedText = {};\n\n          for (var nt=0; nt<nonText.length; nt++){\n            var ntItem = nonText[nt];\n            ordered.push(ntItem);\n\n            var ntCx = (ntItem.left || 0) + (ntItem.width || 0) / 2;\n            var ntBottom = (ntItem.top || 0) + (ntItem.height || 0);\n            var bestIdxTxt = -1;\n            var bestScore = Infinity;\n\n            for (var tx=0; tx<texts.length; tx++){\n              if (usedText[tx]) continue;\n              var tItem = texts[tx];\n              var tCx = (tItem.left || 0) + (tItem.width || 0) / 2;\n              var vGapTxt = (tItem.top || 0) - ntBottom; // preferir texto debajo\n              var hDistTxt = Math.abs(tCx - ntCx);\n              var penaltyAbove = vGapTxt < -2 ? 10000 : 0;\n              var score = penaltyAbove + Math.abs(vGapTxt) * 2 + hDistTxt;\n              if (score < bestScore){\n                bestScore = score;\n                bestIdxTxt = tx;\n              }\n            }\n\n            if (bestIdxTxt >= 0){\n              ordered.push(texts[bestIdxTxt]);\n              usedText[bestIdxTxt] = true;\n            }\n          }\n\n          // Textos no emparejados\n          for (var tx2=0; tx2<texts.length; tx2++){\n            if (!usedText[tx2]) ordered.push(texts[tx2]);\n          }\n\n          // Si no hubo no-texto, fallback simple por top/left\n          if (!ordered.length) {\n            ordered = allItems.sort(function(a,b){\n              if (a.top !== b.top) return a.top - b.top;\n              return a.left - b.left;\n            });\n          }\n\n          var localCursor = clusterTop;\n          var prevIt = null;\n          var prevTopApplied = clusterTop;\n          var EXTRA_COL_BREAK_GAP = 8;\n\n          for (var li=0; li<ordered.length; li++){\n            var lit = ordered[li];\n\n            var keepLayoutLin = (lit.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n            if (keepLayoutLin) continue;\n\n            var newTopLin = localCursor;\n            if (prevIt){\n              var gapOrigLin = lit.top - (prevIt.top + prevIt.height);\n              if (!isFinite(gapOrigLin)) gapOrigLin = 0;\n              var gapWantedLin = clamp(gapOrigLin * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\n              var prevIsTextLin = (prevIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              var currIsTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              // Al pasar de \"texto final de columna\" a \"nuevo no-texto\" agregamos aire.\n              if (prevIsTextLin && !currIsTextLin) gapWantedLin += EXTRA_COL_BREAK_GAP;\n              newTopLin = prevTopApplied + prevIt.height + gapWantedLin;\n            }\n\n            var newLeftLin = centerX - (lit.width || 0) / 2;\n            var keepAlignLin = (lit.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\n            if (keepAlignLin) newLeftLin = lit.left;\n\n            if (Math.abs(newTopLin - lit.top) > 0.5 || Math.abs(newLeftLin - lit.left) > 0.5) changed = true;\n\n            // En rows linealizado, forzamos centrado visual real de texto.\n            var isTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n            if (isTextLin && !keepAlignLin) {\n              lit.node.style.textAlign = \"center\";\n              lit.node.style.transformOrigin = \"top center\";\n              lit.node.style.setProperty(\"--text-zoom\", \"1\");\n              var tfLin = lit.node.style.transform || \"\";\n              if (tfLin.indexOf(\"translateX(\") !== -1) {\n                lit.node.style.transform = tfLin.replace(/translateX\\([^)]*\\)/, \"translateX(0px)\");\n              }\n            }\n\n            lit.node.style.top = newTopLin + \"px\";\n            lit.node.style.left = newLeftLin + \"px\";\n            lit.node.style.right = \"auto\";\n            lit.node.style.marginLeft = \"0px\";\n\n            prevIt = lit;\n            prevTopApplied = newTopLin;\n            localCursor = newTopLin + (lit.height || 0);\n            if (localCursor > clusterBottomUsed) clusterBottomUsed = localCursor;\n          }\n\n          colCursor = Math.max(colCursor, clusterBottomUsed);\n          continue;\n        }\n\n        // Aplicar a cada item preservando offsets relativos (solape intacto)\n        for (var ii=0; ii<c.items.length; ii++){\n          var it = c.items[ii];\n\n          // Opt-out total del layout (decoraciones, etc.)\n          var keepLayout = (it.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n          if (keepLayout) continue;\n\n          var newTop = clusterTop + (it._relTop || 0);\n          var newLeft = clusterLeft + (it._relLeft || 0);\n\n          // Opt-out de centrado (mantener left original del item)\n          var keepAlign = (it.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\n          if (keepAlign) newLeft = it.left;\n\n          // En multi-col, neutralizamos SIEMPRE translateX(...) de textos\n          // para que la posición left calculada sea la referencia visual real.\n          var isTextNode = (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          var isShortTextBox = false;\n          var shouldRecenterTextItem = false;\n          var centerByAlign = false;\n          var targetTextCenterX = NaN;\n          if (isTextNode && isMultiColLayout) {\n            var tf = it.node.style.transform || \"\";\n            if (tf.indexOf(\"translateX(\") !== -1) {\n              it.node.style.transform = tf.replace(/translateX\\([^)]*\\)/, \"translateX(0px)\");\n            }\n            isShortTextBox = (it.width || 0) <= (info.usableW * 0.5) && (it.height || 0) <= 42;\n            var taCurrent = ((it.node.style && it.node.style.textAlign) || \"\").toLowerCase();\n            centerByAlign = taCurrent === \"center\";\n            var shouldCenterVisualText =\n              (shouldCenterTextWithinCluster || isShortTextBox || centerByAlign) &&\n              !keepAlign;\n            shouldRecenterTextItem =\n              shouldCenterVisualText &&\n              isFinite(colReferenceCenterX);\n            if (shouldRecenterTextItem) {\n              var prevLeftTxt = newLeft;\n              var sourceItemCenterX = (it.left || 0) + (it.width || 0) / 2;\n              var sourceDriftItemX = isFinite(colSourceReferenceCenterX)\n                ? (sourceItemCenterX - colSourceReferenceCenterX)\n                : NaN;\n              var targetCenterX = colReferenceCenterX;\n              if (isFinite(sourceDriftItemX)) {\n                targetCenterX += sourceDriftItemX;\n              }\n              targetTextCenterX = targetCenterX;\n              newLeft = targetCenterX - (it.width || 0) / 2;\n              if (Math.abs(newLeft - prevLeftTxt) > 0.5) {\n                mslLog(\"stack:item:textRecenter\", {\n                  g: g,\n                  j: j,\n                  ii: ii,\n                  prevLeft: +prevLeftTxt.toFixed(1),\n                  newLeft: +newLeft.toFixed(1),\n                  itemW: +(it.width || 0).toFixed(1),\n                  refCenterX: +colReferenceCenterX.toFixed(1),\n                  sourceRefCenterX: (typeof colSourceReferenceCenterX === \"number\" && isFinite(colSourceReferenceCenterX)) ? +colSourceReferenceCenterX.toFixed(1) : null,\n                  sourceDriftX: isFinite(sourceDriftItemX) ? +sourceDriftItemX.toFixed(1) : null,\n                  shortBox: isShortTextBox,\n                  centerByAlign: centerByAlign\n                });\n              }\n            }\n            if (shouldCenterVisualText) {\n              it.node.style.textAlign = \"center\";\n              it.node.style.transformOrigin = \"top center\";\n              // Evita encogimiento horizontal heredado que desplaza el centro visual.\n              it.node.style.setProperty(\"--text-zoom\", \"1\");\n            }\n          }\n\n          it.node.style.top = newTop + \"px\";\n          it.node.style.left = newLeft + \"px\";\n          it.node.style.right = \"auto\";\n          it.node.style.marginLeft = \"0px\";\n\n          // Corrección final por posición renderizada real del texto\n          // (fuentes/transform pueden introducir desvíos visuales sub-píxel).\n          if (isTextNode && isMultiColLayout && shouldRecenterTextItem) {\n            var rrTxt = relRect(it.node, rootEl);\n            var renderedCenterX = (rrTxt.left || 0) + (rrTxt.width || 0) / 2;\n            var targetRenderCenterX = isFinite(targetTextCenterX) ? targetTextCenterX : colReferenceCenterX;\n            var renderDelta = renderedCenterX - targetRenderCenterX;\n            if (isFinite(renderDelta) && Math.abs(renderDelta) > 0.6) {\n              var correctedLeft = newLeft - renderDelta;\n              if (isFinite(correctedLeft)) {\n                mslLog(\"stack:item:textRenderAdjust\", {\n                  g: g,\n                  j: j,\n                  ii: ii,\n                  prevLeft: +newLeft.toFixed(1),\n                  correctedLeft: +correctedLeft.toFixed(1),\n                  renderedCenterX: +renderedCenterX.toFixed(1),\n                  refCenterX: +targetRenderCenterX.toFixed(1),\n                  delta: +renderDelta.toFixed(2)\n                });\n                newLeft = correctedLeft;\n                it.node.style.left = newLeft + \"px\";\n              }\n            }\n          }\n\n          if (Math.abs(newTop - it.top) > 0.5 || Math.abs(newLeft - it.left) > 0.5) changed = true;\n\n          var itemBottom = newTop + (it.height || 0);\n          if (itemBottom > clusterBottomUsed) clusterBottomUsed = itemBottom;\n        }\n\n        // Avanza el cursor local al final del cluster\n        colCursor = Math.max(colCursor, clusterBottomUsed);\n      }\n\n      // Al terminar la columna, el cursor global baja hasta donde llegó esta columna\n      globalCursor = Math.max(globalCursor, colCursor);\n    }\n\n    var needed = globalCursor + CFG.PAD_BOT;\n    mslLog(\"stack:end\", {\n      changed: changed,\n      neededHeight: +needed.toFixed(1),\n      finalCursor: +globalCursor.toFixed(1)\n    });\n    return { changed: changed, neededHeight: needed };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVlVixDQUFDLENBQUNDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcc3RhY2tpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9zdGFja2luZy50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNTdGFja2luZ0Jsb2NrKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBcclxuICAvLyBDZW50cm8gcmVhbCBkZWwgw6FyZWEgdXNhYmxlIChjb21wZW5zYSBwYWRkaW5nIHNhZmUtbGVmdC9yaWdodClcclxuICBmdW5jdGlvbiBjb21wdXRlQ2VudGVyWChyb290RWwpe1xyXG4gICAgdmFyIHJvb3RSZWN0ID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJvb3RXID0gcm9vdFJlY3Qud2lkdGggfHwgMDtcclxuXHJcbiAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbCk7XHJcbiAgICB2YXIgcGFkTCA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ0xlZnQpIHx8IDA7XHJcbiAgICB2YXIgcGFkUiA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSB8fCAwO1xyXG5cclxuICAgIHZhciB1c2FibGVXID0gTWF0aC5tYXgoMCwgcm9vdFcgLSBwYWRMIC0gcGFkUik7XHJcbiAgICB2YXIgY2VudGVyWCA9IHBhZEwgKyB1c2FibGVXIC8gMjsgLy8gY2VudHJvIGRlbCDDoXJlYSB1c2FibGVcclxuXHJcbiAgICByZXR1cm4geyByb290Vzogcm9vdFcsIHVzYWJsZVc6IHVzYWJsZVcsIGNlbnRlclg6IGNlbnRlclgsIHBhZEw6IHBhZEwsIHBhZFI6IHBhZFIgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsYW1wKG4sIGEsIGIpe1xyXG4gICAgaWYgKCFpc0Zpbml0ZShuKSkgcmV0dXJuIGE7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgbikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBpbGEgQ0xVU1RFUlMgcG9yIGdyb3VwcyAoY29sdW1uYXMvZmlsYXMpIHk6XHJcbiAgICogLSBtdWV2ZSBjYWRhIGNsdXN0ZXIgY29tbyBibG9xdWVcclxuICAgKiAtIHByZXNlcnZhIHNvbGFwZS9wb3NpY2lvbmVzIHJlbGF0aXZhcyBkZW50cm8gZGVsIGNsdXN0ZXJcclxuICAgKiAtIGNlbnRyYSBlbCBjbHVzdGVyIGNvbW8gYmxvcXVlIGVuIGVsIGVqZSBYIChzaW4gdHJhbnNmb3JtKVxyXG4gICAqXHJcbiAgICogRGV2dWVsdmUgY2hhbmdlZCArIG5lZWRlZEhlaWdodCAocGFyYSBleHBhbmRpciBzZWNjacOzbilcclxuICAgKi9cclxuICBmdW5jdGlvbiBhcHBseUNsdXN0ZXJTdGFjayhncm91cHMsIHJvb3RFbCwgQ0ZHLCBtb2RlKXtcclxuICAgIHZhciBpbmZvID0gY29tcHV0ZUNlbnRlclgocm9vdEVsKTtcclxuICAgIHZhciBjZW50ZXJYID0gaW5mby5jZW50ZXJYO1xyXG4gICAgbXNsTG9nKFwic3RhY2s6c3RhcnRcIiwge1xyXG4gICAgICBncm91cENvdW50OiBncm91cHMubGVuZ3RoLFxyXG4gICAgICBncm91cFNpemVzOiBncm91cHMubWFwKGZ1bmN0aW9uKGcpeyByZXR1cm4gZy5sZW5ndGg7IH0pLFxyXG4gICAgICBjZW50ZXJYOiArY2VudGVyWC50b0ZpeGVkKDEpLFxyXG4gICAgICB1c2FibGVXOiAraW5mby51c2FibGVXLnRvRml4ZWQoMSlcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgaXNNdWx0aUNvbExheW91dCA9IChtb2RlID09PSBcInR3b1wiIHx8IG1vZGUgPT09IFwidGhyZWVcIik7XHJcblxyXG4gICAgLy8gRW4gbXVsdGktY29sdW1uYTogY2FkYSBjb2x1bW5hIGFwaWxhZGEgc2UgY2VudHJhIHBvciBzdSBwcm9waW8gYmJveC5cbiAgICAvLyBBc8OtLCBlbCBjZW50cm8gZGUgY2FkYSBjb2x1bW5hIGNvaW5jaWRlIGNvbiBlbCBjZW50cm8gZGUgcGFudGFsbGEuXG5cclxuICAgIC8vIC0tLSBBbmNob3IgZ2xvYmFsOiBkw7NuZGUgZXN0YWJhIOKAnGVsIGJsb3F1ZeKAnSBvcmlnaW5hbG1lbnRlIC0tLVxyXG4gICAgdmFyIGZpcnN0R3JvdXAgPSBncm91cHNbMF0gfHwgW107XHJcbiAgICB2YXIgYW5jaG9yID0gSW5maW5pdHk7XHJcbiAgICBmb3IgKHZhciBpPTA7aTxmaXJzdEdyb3VwLmxlbmd0aDtpKyspe1xyXG4gICAgICBhbmNob3IgPSBNYXRoLm1pbihhbmNob3IsIGZpcnN0R3JvdXBbaV0udG9wKTtcclxuICAgIH1cclxuICAgIGlmICghaXNGaW5pdGUoYW5jaG9yKSkgYW5jaG9yID0gQ0ZHLlBBRF9UT1A7XHJcbiAgICBhbmNob3IgPSBNYXRoLm1heChDRkcuUEFEX1RPUCwgYW5jaG9yKTtcclxuXHJcbiAgICAvLyBDdXJzb3IgZ2xvYmFsOiBkw7NuZGUgdGVybWluYSBlbCBjb250ZW5pZG8gYXBpbGFkbyBoYXN0YSBhaG9yYVxyXG4gICAgdmFyIGdsb2JhbEN1cnNvciA9IGFuY2hvcjtcclxuXHJcbiAgICAvLyBTZXBhcmFjacOzbiBlbnRyZSBjb2x1bW5hcyBhcGlsYWRhcyAoaXpxLCBjZW50cm8sIGRlcilcclxuICAgIHZhciBHUk9VUF9HQVAgPSAxNDtcclxuXHJcbiAgICBmb3IgKHZhciBnPTA7IGc8Z3JvdXBzLmxlbmd0aDsgZysrKXtcbiAgICAgIHZhciBjb2wgPSBncm91cHNbZ10gfHwgW107XG4gICAgICBpZiAoIWNvbC5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgdmFyIGNvbFJlZmVyZW5jZUNlbnRlclggPSBOYU47XG4gICAgICB2YXIgY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCA9IE5hTjtcblxyXG4gICAgICAvLyBNw6l0cmljYXMgcG9yIGdydXBvIHNvbG8gcGFyYSBkZWJ1Zy5cclxuICAgICAgdmFyIGdyb3VwTWluTGVmdCA9IEluZmluaXR5O1xyXG4gICAgICB2YXIgZ3JvdXBNYXhSaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpe1xyXG4gICAgICAgIGZvciAodmFyIGdnPTA7IGdnPGNvbC5sZW5ndGg7IGdnKyspe1xyXG4gICAgICAgICAgZ3JvdXBNaW5MZWZ0ID0gTWF0aC5taW4oZ3JvdXBNaW5MZWZ0LCBjb2xbZ2ddLmxlZnQpO1xyXG4gICAgICAgICAgZ3JvdXBNYXhSaWdodCA9IE1hdGgubWF4KGdyb3VwTWF4UmlnaHQsIGNvbFtnZ10ubGVmdCArIGNvbFtnZ10ud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgZ3JvdXBXaWR0aCA9IGlzTXVsdGlDb2xMYXlvdXQgPyBNYXRoLm1heCgwLCBncm91cE1heFJpZ2h0IC0gZ3JvdXBNaW5MZWZ0KSA6IDA7XHJcbiAgICAgIHZhciBncm91cEJhc2VMZWZ0ID0gaXNNdWx0aUNvbExheW91dCA/IChjZW50ZXJYIC0gZ3JvdXBXaWR0aCAvIDIpIDogMDtcclxuXHJcbiAgICAgIC8vIE9mZnNldCB2ZXJ0aWNhbCBvcmlnaW5hbCBkZSBlc3RhIGNvbHVtbmEgcmVzcGVjdG8gZGVsIGFuY2hvclxyXG4gICAgICB2YXIgY29sTWluVG9wID0gSW5maW5pdHk7XHJcbiAgICAgIGZvciAodmFyIGs9MDtrPGNvbC5sZW5ndGg7aysrKXtcclxuICAgICAgICBjb2xNaW5Ub3AgPSBNYXRoLm1pbihjb2xNaW5Ub3AsIGNvbFtrXS50b3ApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNGaW5pdGUoY29sTWluVG9wKSkgY29sTWluVG9wID0gYW5jaG9yO1xyXG5cclxuICAgICAgdmFyIGNvbE9mZnNldCA9IGNvbE1pblRvcCAtIGFuY2hvcjtcclxuICAgICAgdmFyIGNvbFN0YXJ0ID0gZ2xvYmFsQ3Vyc29yICsgKGcgPT09IDAgPyAwIDogR1JPVVBfR0FQKSArIE1hdGgubWF4KDAsIGNvbE9mZnNldCk7XHJcbiAgICAgIG1zbExvZyhcInN0YWNrOmdyb3VwOnN0YXJ0XCIsIHtcclxuICAgICAgICBnOiBnLFxyXG4gICAgICAgIGNvbFNpemU6IGNvbC5sZW5ndGgsXHJcbiAgICAgICAgY29sTWluVG9wOiArY29sTWluVG9wLnRvRml4ZWQoMSksXHJcbiAgICAgICAgY29sT2Zmc2V0OiArY29sT2Zmc2V0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgY29sU3RhcnQ6ICtjb2xTdGFydC50b0ZpeGVkKDEpLFxuICAgICAgICBnbG9iYWxDdXJzb3I6ICtnbG9iYWxDdXJzb3IudG9GaXhlZCgxKSxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZ3JvdXBNaW5MZWZ0OiBpc011bHRpQ29sTGF5b3V0ID8gK2dyb3VwTWluTGVmdC50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgZ3JvdXBXaWR0aDogaXNNdWx0aUNvbExheW91dCA/ICtncm91cFdpZHRoLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICBncm91cEJhc2VMZWZ0OiBpc011bHRpQ29sTGF5b3V0ID8gK2dyb3VwQmFzZUxlZnQudG9GaXhlZCgxKSA6IG51bGxcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQ3Vyc29yIGxvY2FsIGRlIGVzdGEgY29sdW1uYVxyXG4gICAgICB2YXIgY29sQ3Vyc29yID0gY29sU3RhcnQ7XHJcblxyXG4gICAgICBmb3IgKHZhciBqPTA7IGo8Y29sLmxlbmd0aDsgaisrKXtcclxuICAgICAgICB2YXIgYyA9IGNvbFtqXTtcclxuXHJcbiAgICAgICAgLy8gVG9wIGRlbCBjbHVzdGVyIGVuIGVsIGZsdWpvIG1vYmlsZVxyXG4gICAgICAgIHZhciBjbHVzdGVyVG9wO1xyXG5cclxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xDdXJzb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZDID0gY29sW2otMV07XG4gICAgICAgICAgdmFyIHByZXZCb3R0b20gPSAoY2x1c3RlclRvcFByZXYgKyBwcmV2Qy5oZWlnaHQpO1xuXG4gICAgICAgICAgLy8g4pyFIEdhcCBvcmlnaW5hbCBlbnRyZSBjbHVzdGVycyAoY2FudmFzKVxuICAgICAgICAgIHZhciBwcmV2Qm90dG9tT3JpZyA9IChwcmV2Qy50b3AgKyBwcmV2Qy5oZWlnaHQpO1xuICAgICAgICAgIHZhciBnYXBPcmlnID0gYy50b3AgLSBwcmV2Qm90dG9tT3JpZztcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGdhcE9yaWcpKSBnYXBPcmlnID0gMDtcblxuICAgICAgICAgIHZhciBvdmVybGFwSW5Tb3VyY2UgPSBnYXBPcmlnIDwgMDtcbiAgICAgICAgICBpZiAoKG1vZGUgPT09IFwidHdvXCIgfHwgbW9kZSA9PT0gXCJ0aHJlZVwiKSAmJiBvdmVybGFwSW5Tb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIFNpIGVuIGVsIG9yaWdpbmFsIGVzdGUgY2x1c3RlciBjYWUgZGVudHJvIGRlbCBhbnRlcmlvciwgcmVzcGV0YW1vc1xuICAgICAgICAgICAgLy8gc3UgdG9wIHJlbGF0aXZvIHBhcmEgbm8gbWFuZGFybG8gYWwgZmluYWwgZGUgbGEgY29sdW1uYS5cbiAgICAgICAgICAgIHZhciByZWxUb3BJbkNvbCA9IGMudG9wIC0gY29sTWluVG9wO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShyZWxUb3BJbkNvbCkpIHJlbFRvcEluQ29sID0gMDtcbiAgICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xTdGFydCArIE1hdGgubWF4KDAsIHJlbFRvcEluQ29sKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g4pyFIEdhcCDigJxtb2JpbGUtZnJpZW5kbHnigJ06IGVzY2FsYWRvICsgY2xhbXBcbiAgICAgICAgICAgIHZhciBnYXBXYW50ZWQgPSBjbGFtcChnYXBPcmlnICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XG5cbiAgICAgICAgICAgIC8vIOKchSBBbnRpLXNvbGFwZSBkZWZpbml0aXZvOlxuICAgICAgICAgICAgLy8gICBlbCBwcsOzeGltbyBjbHVzdGVyIFNJRU1QUkUgZW1waWV6YSBkZXNwdcOpcyBkZWwgYm90dG9tIHJlYWwgZGVsIGFudGVyaW9yICsgZ2FwV2FudGVkXG4gICAgICAgICAgICBjbHVzdGVyVG9wID0gcHJldkJvdHRvbSArIGdhcFdhbnRlZDtcblxuICAgICAgICAgICAgLy8gRW4gbXVsdGktY29sdW1uYSBudW5jYSBhdmFuemFtb3MgaGFjaWEgYXJyaWJhIHJlc3BlY3RvIGFsIGZsdWpvIHlhIGNvbnN1bWlkby5cbiAgICAgICAgICAgIGlmICgobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpICYmIGNsdXN0ZXJUb3AgPCBjb2xDdXJzb3IpIHtcbiAgICAgICAgICAgICAgY2x1c3RlclRvcCA9IGNvbEN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxyXG4gICAgICAgIC8vIEd1YXJkYW1vcyBwYXJhIGVsIHByw7N4aW1vIGxvb3BcclxuICAgICAgICB2YXIgY2x1c3RlclRvcFByZXYgPSBjbHVzdGVyVG9wO1xyXG5cclxuICAgICAgICAvLyDCv2NlbnRyYXIgZXN0ZSBjbHVzdGVyP1xuICAgICAgICB2YXIgZm9yY2VDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc1RleHRJbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc05vblRleHRJbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgdD0wOyB0PGMuaXRlbXMubGVuZ3RoOyB0Kyspe1xuICAgICAgICAgIHZhciBpc1RleHRUID0gKGMuaXRlbXNbdF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgICBpZiAoaXNUZXh0VCkgaGFzVGV4dEluQ2x1c3RlciA9IHRydWU7XG4gICAgICAgICAgZWxzZSBoYXNOb25UZXh0SW5DbHVzdGVyID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoKGMuaXRlbXNbdF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jZW50ZXJcIikgfHwgXCJcIikgPT09IFwiZm9yY2VcIikge1xuICAgICAgICAgICAgZm9yY2VDZW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXHJcbiAgICAgICAgLy8gb25lL3Jvd3M6IGNlbnRybyBwb3IgY2x1c3RlciAoY29tcG9ydGFtaWVudG8gb3JpZ2luYWwpXHJcbiAgICAgICAgLy8gdHdvL3RocmVlOiBhcGlsYXIgY2FkYSBjb2x1bW5hIGVuIGxhIG1pc21hIHJlZmVyZW5jaWEgWCxcclxuICAgICAgICAvLyBwcmVzZXJ2YW5kbyBvZmZzZXRzIGludGVybm9zIGRlIGVzYSBjb2x1bW5hLlxyXG4gICAgICAgIHZhciBrZWVwQ2VudGVyID0gZm9yY2VDZW50ZXIgPyB0cnVlIDogKGMud2lkdGggPCAoaW5mby51c2FibGVXICogMC45NSkpO1xuICAgICAgICB2YXIgY2x1c3RlckxlZnQgPSBrZWVwQ2VudGVyID8gKGNlbnRlclggLSBjLndpZHRoIC8gMikgOiBjLmxlZnQ7XG4gICAgICAgIHZhciBpc1RleHRPbmx5Q2x1c3RlciA9IGhhc1RleHRJbkNsdXN0ZXIgJiYgIWhhc05vblRleHRJbkNsdXN0ZXI7XG4gICAgICAgIHZhciBzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlciA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNNdWx0aUNvbExheW91dCkge1xuICAgICAgICAgIC8vIE1vZG8gbGVjdHVyYSBtb2JpbGUgbXVsdGktY29sOlxuICAgICAgICAgIC8vIHVzYXIgdW5hIG1pc21hIHJlZmVyZW5jaWEgWCBwYXJhIHRvZGEgbGEgY29sdW1uYSBhcGlsYWRhIHlcbiAgICAgICAgICAvLyBwcmVzZXJ2YXIgZWwgb2Zmc2V0IGhvcml6b250YWwgb3JpZ2luYWwgZGUgY2FkYSBjbHVzdGVyLlxuICAgICAgICAgIC8vIEVzdG8gbWFudGllbmUgYWxpbmVhZG8gdGV4dG8vZm9ybWEgY3VhbmRvIGxhIGNvbHVtbmEgc2UgcGFydGVcbiAgICAgICAgICAvLyBlbiB2YXJpb3MgY2x1c3RlcnMuXG4gICAgICAgICAgdmFyIHJlbENsdXN0ZXJMZWZ0ID0gKGMubGVmdCB8fCAwKSAtIChncm91cE1pbkxlZnQgfHwgMCk7XG4gICAgICAgICAgY2x1c3RlckxlZnQgPSBncm91cEJhc2VMZWZ0ICsgcmVsQ2x1c3RlckxlZnQ7XG5cbiAgICAgICAgICAvLyBQZXJtaXRlIGZvcnphciBjZW50cmFkbyBwb3IgY2x1c3RlciBzaSBlbCBub2RvIGxvIHBpZGUuXG4gICAgICAgICAgaWYgKGZvcmNlQ2VudGVyKSBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcblxuICAgICAgICAgIC8vIFNpIGVzdGEgY29sdW1uYSB0aWVuZSB1biBjbHVzdGVyIGNvbiBmb3JtYSAobyBtaXh0byksIHVzYW1vcyBzdVxuICAgICAgICAgIC8vIGNlbnRybyBjb21vIHJlZmVyZW5jaWEgcGFyYSBhbGluZWFyIGNsdXN0ZXJzIHNvbG8tdGV4dG8gZGViYWpvLlxuICAgICAgICAgIHZhciBjbHVzdGVyUmVmQ2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaGFzTm9uVGV4dEluQ2x1c3Rlcikge1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNpYSBiYXNhZGEgZW4gaXRlbXMgbm8tdGV4dG8gKGZvcm1hL2ljb25vKSwgbm8gZW4gdG9kbyBlbFxuICAgICAgICAgICAgLy8gY2x1c3RlciwgcGFyYSBxdWUgdGV4dG9zIGxhcmdvcyBubyBkZXNwbGFjZW4gZWwgY2VudHJvIGRlIGNvbHVtbmEuXG4gICAgICAgICAgICB2YXIgbnRNaW5SZWwgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBudE1heFJlbCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIG50aT0wOyBudGk8Yy5pdGVtcy5sZW5ndGg7IG50aSsrKXtcbiAgICAgICAgICAgICAgdmFyIG50SXQgPSBjLml0ZW1zW250aV07XG4gICAgICAgICAgICAgIHZhciBudElzVGV4dCA9IChudEl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgICAgIGlmIChudElzVGV4dCkgY29udGludWU7XG4gICAgICAgICAgICAgIG50TWluUmVsID0gTWF0aC5taW4obnRNaW5SZWwsIChudEl0Ll9yZWxMZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgbnRNYXhSZWwgPSBNYXRoLm1heChudE1heFJlbCwgKG50SXQuX3JlbExlZnQgfHwgMCkgKyAobnRJdC53aWR0aCB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUobnRNaW5SZWwpICYmIGlzRmluaXRlKG50TWF4UmVsKSAmJiBudE1heFJlbCA+IG50TWluUmVsKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyAoKG50TWluUmVsICsgbnRNYXhSZWwpIC8gMik7XG4gICAgICAgICAgICAgIHNvdXJjZUNsdXN0ZXJSZWZDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArICgobnRNaW5SZWwgKyBudE1heFJlbCkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyBjLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclggPSBjbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICAgIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPSBzb3VyY2VDbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUZXh0T25seUNsdXN0ZXIgJiYgaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpIHtcbiAgICAgICAgICAgIHZhciBtYXhTbmFwRGVsdGEgPSBNYXRoLm1pbigxMjAsIGluZm8udXNhYmxlVyAqIDAuMzUpO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUNsdXN0ZXJDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0WCA9IGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXG4gICAgICAgICAgICAgID8gKHNvdXJjZUNsdXN0ZXJDZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgOiBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRYKSAmJiBNYXRoLmFicyhzb3VyY2VEcmlmdFgpIDw9IG1heFNuYXBEZWx0YSkge1xuICAgICAgICAgICAgICBjbHVzdGVyTGVmdCA9IChjb2xSZWZlcmVuY2VDZW50ZXJYICsgc291cmNlRHJpZnRYKSAtIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyYSBsYWJlbHMgY29ydG9zLCBjZW50cmFyIGVsIGNvbnRlbmlkbyB0ZXh0dWFsIGRlbnRybyBkZWwgYm94LlxuICAgICAgICAgICAgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBjLndpZHRoIDw9IChpbmZvLnVzYWJsZVcgKiAwLjY1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXNsTG9nKFwic3RhY2s6Y2x1c3RlclwiLCB7XG4gICAgICAgICAgZzogZyxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIG9yaWdUb3A6ICtjLnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIG9yaWdMZWZ0OiArYy5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgbmV3VG9wOiArY2x1c3RlclRvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgbmV3TGVmdDogK2NsdXN0ZXJMZWZ0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcclxuICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgZm9yY2VDZW50ZXI6IGZvcmNlQ2VudGVyLFxuICAgICAgICAgIGtlZXBDZW50ZXI6IGtlZXBDZW50ZXIsXG4gICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclg6ICh0eXBlb2YgY29sUmVmZXJlbmNlQ2VudGVyWCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShjb2xSZWZlcmVuY2VDZW50ZXJYKSkgPyArY29sUmVmZXJlbmNlQ2VudGVyWC50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgICBpc1RleHRPbmx5Q2x1c3RlcjogaXNUZXh0T25seUNsdXN0ZXIsXG4gICAgICAgICAgY2VudGVyU2hvcnRUZXh0OiBzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlclxuICAgICAgICB9KTtcblxyXG4gICAgICAgIHZhciB0ZXh0Q291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIHRjPTA7IHRjPGMuaXRlbXMubGVuZ3RoOyB0YysrKXtcclxuICAgICAgICAgIGlmICgoYy5pdGVtc1t0Y10ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgdGV4dENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaW5lYXJpemVDbHVzdGVyID0gKG1vZGUgPT09IFwicm93c1wiICYmIGMuaXRlbXMubGVuZ3RoID4gMSAmJiB0ZXh0Q291bnQgPj0gMik7XHJcbiAgICAgICAgdmFyIGNsdXN0ZXJCb3R0b21Vc2VkID0gY2x1c3RlclRvcCArIGMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDYXNvIGVzcGVjaWFsOiBlbiByb3dzLCBzaSBlbCBjbHVzdGVyIGFncnVwYSB2YXJpb3MgdGV4dG9zLCBsb1xyXG4gICAgICAgIC8vIGNvbnZlcnRpbW9zIGEgZmx1am8gdmVydGljYWwgY2VudHJhZG8gcGFyYSBldml0YXIgdGV4dG8gbGFkbyBhIGxhZG8uXHJcbiAgICAgICAgaWYgKGxpbmVhcml6ZUNsdXN0ZXIpe1xyXG4gICAgICAgICAgdmFyIGFsbEl0ZW1zID0gYy5pdGVtcy5zbGljZSgpO1xyXG4gICAgICAgICAgdmFyIG5vblRleHQgPSBhbGxJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXR4KXtcclxuICAgICAgICAgICAgcmV0dXJuIChpdHgubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpICE9PSBcIjFcIjtcclxuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgaWYgKGEudG9wICE9PSBiLnRvcCkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHZhciB0ZXh0cyA9IGFsbEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdHgpe1xyXG4gICAgICAgICAgICByZXR1cm4gKGl0eC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIE9yZGVuIHNlbcOhbnRpY28gZGUgbGVjdHVyYTpcclxuICAgICAgICAgIC8vIG5vLXRleHRvICsgdGV4dG8gbcOhcyBjZXJjYW5vIChkZWJham8geSBwb3IgZWplIFgpLCBsdWVnbyByZW1hbmVudGVzLlxyXG4gICAgICAgICAgdmFyIG9yZGVyZWQgPSBbXTtcclxuICAgICAgICAgIHZhciB1c2VkVGV4dCA9IHt9O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIG50PTA7IG50PG5vblRleHQubGVuZ3RoOyBudCsrKXtcclxuICAgICAgICAgICAgdmFyIG50SXRlbSA9IG5vblRleHRbbnRdO1xyXG4gICAgICAgICAgICBvcmRlcmVkLnB1c2gobnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBudEN4ID0gKG50SXRlbS5sZWZ0IHx8IDApICsgKG50SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBudEJvdHRvbSA9IChudEl0ZW0udG9wIHx8IDApICsgKG50SXRlbS5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIHZhciBiZXN0SWR4VHh0ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBiZXN0U2NvcmUgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHR4PTA7IHR4PHRleHRzLmxlbmd0aDsgdHgrKyl7XHJcbiAgICAgICAgICAgICAgaWYgKHVzZWRUZXh0W3R4XSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgdmFyIHRJdGVtID0gdGV4dHNbdHhdO1xyXG4gICAgICAgICAgICAgIHZhciB0Q3ggPSAodEl0ZW0ubGVmdCB8fCAwKSArICh0SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHZHYXBUeHQgPSAodEl0ZW0udG9wIHx8IDApIC0gbnRCb3R0b207IC8vIHByZWZlcmlyIHRleHRvIGRlYmFqb1xyXG4gICAgICAgICAgICAgIHZhciBoRGlzdFR4dCA9IE1hdGguYWJzKHRDeCAtIG50Q3gpO1xyXG4gICAgICAgICAgICAgIHZhciBwZW5hbHR5QWJvdmUgPSB2R2FwVHh0IDwgLTIgPyAxMDAwMCA6IDA7XHJcbiAgICAgICAgICAgICAgdmFyIHNjb3JlID0gcGVuYWx0eUFib3ZlICsgTWF0aC5hYnModkdhcFR4dCkgKiAyICsgaERpc3RUeHQ7XHJcbiAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKXtcclxuICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICAgICAgYmVzdElkeFR4dCA9IHR4O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJlc3RJZHhUeHQgPj0gMCl7XHJcbiAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKHRleHRzW2Jlc3RJZHhUeHRdKTtcclxuICAgICAgICAgICAgICB1c2VkVGV4dFtiZXN0SWR4VHh0XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBUZXh0b3Mgbm8gZW1wYXJlamFkb3NcclxuICAgICAgICAgIGZvciAodmFyIHR4Mj0wOyB0eDI8dGV4dHMubGVuZ3RoOyB0eDIrKyl7XHJcbiAgICAgICAgICAgIGlmICghdXNlZFRleHRbdHgyXSkgb3JkZXJlZC5wdXNoKHRleHRzW3R4Ml0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNpIG5vIGh1Ym8gbm8tdGV4dG8sIGZhbGxiYWNrIHNpbXBsZSBwb3IgdG9wL2xlZnRcclxuICAgICAgICAgIGlmICghb3JkZXJlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgb3JkZXJlZCA9IGFsbEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgbG9jYWxDdXJzb3IgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIHByZXZJdCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgcHJldlRvcEFwcGxpZWQgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIEVYVFJBX0NPTF9CUkVBS19HQVAgPSA4O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGxpPTA7IGxpPG9yZGVyZWQubGVuZ3RoOyBsaSsrKXtcclxuICAgICAgICAgICAgdmFyIGxpdCA9IG9yZGVyZWRbbGldO1xyXG5cclxuICAgICAgICAgICAgdmFyIGtlZXBMYXlvdXRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgICAgaWYgKGtlZXBMYXlvdXRMaW4pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1RvcExpbiA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgICBpZiAocHJldkl0KXtcclxuICAgICAgICAgICAgICB2YXIgZ2FwT3JpZ0xpbiA9IGxpdC50b3AgLSAocHJldkl0LnRvcCArIHByZXZJdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZ2FwT3JpZ0xpbikpIGdhcE9yaWdMaW4gPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBnYXBXYW50ZWRMaW4gPSBjbGFtcChnYXBPcmlnTGluICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XHJcbiAgICAgICAgICAgICAgdmFyIHByZXZJc1RleHRMaW4gPSAocHJldkl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgdmFyIGN1cnJJc1RleHRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgLy8gQWwgcGFzYXIgZGUgXCJ0ZXh0byBmaW5hbCBkZSBjb2x1bW5hXCIgYSBcIm51ZXZvIG5vLXRleHRvXCIgYWdyZWdhbW9zIGFpcmUuXHJcbiAgICAgICAgICAgICAgaWYgKHByZXZJc1RleHRMaW4gJiYgIWN1cnJJc1RleHRMaW4pIGdhcFdhbnRlZExpbiArPSBFWFRSQV9DT0xfQlJFQUtfR0FQO1xyXG4gICAgICAgICAgICAgIG5ld1RvcExpbiA9IHByZXZUb3BBcHBsaWVkICsgcHJldkl0LmhlaWdodCArIGdhcFdhbnRlZExpbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ld0xlZnRMaW4gPSBjZW50ZXJYIC0gKGxpdC53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBrZWVwQWxpZ25MaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIikgPT09IFwia2VlcFwiO1xyXG4gICAgICAgICAgICBpZiAoa2VlcEFsaWduTGluKSBuZXdMZWZ0TGluID0gbGl0LmxlZnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3VG9wTGluIC0gbGl0LnRvcCkgPiAwLjUgfHwgTWF0aC5hYnMobmV3TGVmdExpbiAtIGxpdC5sZWZ0KSA+IDAuNSkgY2hhbmdlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBFbiByb3dzIGxpbmVhbGl6YWRvLCBmb3J6YW1vcyBjZW50cmFkbyB2aXN1YWwgcmVhbCBkZSB0ZXh0by5cclxuICAgICAgICAgICAgdmFyIGlzVGV4dExpbiA9IChsaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgICAgaWYgKGlzVGV4dExpbiAmJiAha2VlcEFsaWduTGluKSB7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgICB2YXIgdGZMaW4gPSBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIjtcclxuICAgICAgICAgICAgICBpZiAodGZMaW4uaW5kZXhPZihcInRyYW5zbGF0ZVgoXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gdGZMaW4ucmVwbGFjZSgvdHJhbnNsYXRlWFxcKFteKV0qXFwpLywgXCJ0cmFuc2xhdGVYKDBweClcIik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50b3AgPSBuZXdUb3BMaW4gKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLmxlZnQgPSBuZXdMZWZ0TGluICsgXCJweFwiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcclxuXHJcbiAgICAgICAgICAgIHByZXZJdCA9IGxpdDtcclxuICAgICAgICAgICAgcHJldlRvcEFwcGxpZWQgPSBuZXdUb3BMaW47XHJcbiAgICAgICAgICAgIGxvY2FsQ3Vyc29yID0gbmV3VG9wTGluICsgKGxpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEN1cnNvciA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcGxpY2FyIGEgY2FkYSBpdGVtIHByZXNlcnZhbmRvIG9mZnNldHMgcmVsYXRpdm9zIChzb2xhcGUgaW50YWN0bylcclxuICAgICAgICBmb3IgKHZhciBpaT0wOyBpaTxjLml0ZW1zLmxlbmd0aDsgaWkrKyl7XHJcbiAgICAgICAgICB2YXIgaXQgPSBjLml0ZW1zW2lpXTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IHRvdGFsIGRlbCBsYXlvdXQgKGRlY29yYWNpb25lcywgZXRjLilcclxuICAgICAgICAgIHZhciBrZWVwTGF5b3V0ID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgIGlmIChrZWVwTGF5b3V0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICB2YXIgbmV3VG9wID0gY2x1c3RlclRvcCArIChpdC5fcmVsVG9wIHx8IDApO1xyXG4gICAgICAgICAgdmFyIG5ld0xlZnQgPSBjbHVzdGVyTGVmdCArIChpdC5fcmVsTGVmdCB8fCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IGRlIGNlbnRyYWRvIChtYW50ZW5lciBsZWZ0IG9yaWdpbmFsIGRlbCBpdGVtKVxuICAgICAgICAgIHZhciBrZWVwQWxpZ24gPSAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1hbGlnblwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBBbGlnbikgbmV3TGVmdCA9IGl0LmxlZnQ7XG5cbiAgICAgICAgICAvLyBFbiBtdWx0aS1jb2wsIG5ldXRyYWxpemFtb3MgU0lFTVBSRSB0cmFuc2xhdGVYKC4uLikgZGUgdGV4dG9zXG4gICAgICAgICAgLy8gcGFyYSBxdWUgbGEgcG9zaWNpw7NuIGxlZnQgY2FsY3VsYWRhIHNlYSBsYSByZWZlcmVuY2lhIHZpc3VhbCByZWFsLlxuICAgICAgICAgIHZhciBpc1RleHROb2RlID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGlzU2hvcnRUZXh0Qm94ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNob3VsZFJlY2VudGVyVGV4dEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2VudGVyQnlBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0YXJnZXRUZXh0Q2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZSAmJiBpc011bHRpQ29sTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgdGYgPSBpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRmLmluZGV4T2YoXCJ0cmFuc2xhdGVYKFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0Zi5yZXBsYWNlKC90cmFuc2xhdGVYXFwoW14pXSpcXCkvLCBcInRyYW5zbGF0ZVgoMHB4KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzU2hvcnRUZXh0Qm94ID0gKGl0LndpZHRoIHx8IDApIDw9IChpbmZvLnVzYWJsZVcgKiAwLjUpICYmIChpdC5oZWlnaHQgfHwgMCkgPD0gNDI7XG4gICAgICAgICAgICB2YXIgdGFDdXJyZW50ID0gKChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2VudGVyQnlBbGlnbiA9IHRhQ3VycmVudCA9PT0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIHZhciBzaG91bGRDZW50ZXJWaXN1YWxUZXh0ID1cbiAgICAgICAgICAgICAgKHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyIHx8IGlzU2hvcnRUZXh0Qm94IHx8IGNlbnRlckJ5QWxpZ24pICYmXG4gICAgICAgICAgICAgICFrZWVwQWxpZ247XG4gICAgICAgICAgICBzaG91bGRSZWNlbnRlclRleHRJdGVtID1cbiAgICAgICAgICAgICAgc2hvdWxkQ2VudGVyVmlzdWFsVGV4dCAmJlxuICAgICAgICAgICAgICBpc0Zpbml0ZShjb2xSZWZlcmVuY2VDZW50ZXJYKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2TGVmdFR4dCA9IG5ld0xlZnQ7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VJdGVtQ2VudGVyWCA9IChpdC5sZWZ0IHx8IDApICsgKGl0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0SXRlbVggPSBpc0Zpbml0ZShjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYKVxuICAgICAgICAgICAgICAgID8gKHNvdXJjZUl0ZW1DZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgICA6IE5hTjtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldENlbnRlclggPSBjb2xSZWZlcmVuY2VDZW50ZXJYO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRJdGVtWCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXJYICs9IHNvdXJjZURyaWZ0SXRlbVg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0VGV4dENlbnRlclggPSB0YXJnZXRDZW50ZXJYO1xuICAgICAgICAgICAgICBuZXdMZWZ0ID0gdGFyZ2V0Q2VudGVyWCAtIChpdC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdMZWZ0IC0gcHJldkxlZnRUeHQpID4gMC41KSB7XG4gICAgICAgICAgICAgICAgbXNsTG9nKFwic3RhY2s6aXRlbTp0ZXh0UmVjZW50ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgZzogZyxcbiAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICBpaTogaWksXG4gICAgICAgICAgICAgICAgICBwcmV2TGVmdDogK3ByZXZMZWZ0VHh0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICBuZXdMZWZ0OiArbmV3TGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgaXRlbVc6ICsoaXQud2lkdGggfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIHJlZkNlbnRlclg6ICtjb2xSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICBzb3VyY2VSZWZDZW50ZXJYOiAodHlwZW9mIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCkpID8gK2NvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VEcmlmdFg6IGlzRmluaXRlKHNvdXJjZURyaWZ0SXRlbVgpID8gK3NvdXJjZURyaWZ0SXRlbVgudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzaG9ydEJveDogaXNTaG9ydFRleHRCb3gsXG4gICAgICAgICAgICAgICAgICBjZW50ZXJCeUFsaWduOiBjZW50ZXJCeUFsaWduXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRDZW50ZXJWaXN1YWxUZXh0KSB7XG4gICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcbiAgICAgICAgICAgICAgLy8gRXZpdGEgZW5jb2dpbWllbnRvIGhvcml6b250YWwgaGVyZWRhZG8gcXVlIGRlc3BsYXphIGVsIGNlbnRybyB2aXN1YWwuXG4gICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRleHQtem9vbVwiLCBcIjFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXQubm9kZS5zdHlsZS50b3AgPSBuZXdUb3AgKyBcInB4XCI7XG4gICAgICAgICAgaXQubm9kZS5zdHlsZS5sZWZ0ID0gbmV3TGVmdCArIFwicHhcIjtcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgaXQubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcblxuICAgICAgICAgIC8vIENvcnJlY2Npw7NuIGZpbmFsIHBvciBwb3NpY2nDs24gcmVuZGVyaXphZGEgcmVhbCBkZWwgdGV4dG9cbiAgICAgICAgICAvLyAoZnVlbnRlcy90cmFuc2Zvcm0gcHVlZGVuIGludHJvZHVjaXIgZGVzdsOtb3MgdmlzdWFsZXMgc3ViLXDDrXhlbCkuXG4gICAgICAgICAgaWYgKGlzVGV4dE5vZGUgJiYgaXNNdWx0aUNvbExheW91dCAmJiBzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICB2YXIgcnJUeHQgPSByZWxSZWN0KGl0Lm5vZGUsIHJvb3RFbCk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRDZW50ZXJYID0gKHJyVHh0LmxlZnQgfHwgMCkgKyAocnJUeHQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgdmFyIHRhcmdldFJlbmRlckNlbnRlclggPSBpc0Zpbml0ZSh0YXJnZXRUZXh0Q2VudGVyWCkgPyB0YXJnZXRUZXh0Q2VudGVyWCA6IGNvbFJlZmVyZW5jZUNlbnRlclg7XG4gICAgICAgICAgICB2YXIgcmVuZGVyRGVsdGEgPSByZW5kZXJlZENlbnRlclggLSB0YXJnZXRSZW5kZXJDZW50ZXJYO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKHJlbmRlckRlbHRhKSAmJiBNYXRoLmFicyhyZW5kZXJEZWx0YSkgPiAwLjYpIHtcbiAgICAgICAgICAgICAgdmFyIGNvcnJlY3RlZExlZnQgPSBuZXdMZWZ0IC0gcmVuZGVyRGVsdGE7XG4gICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb3JyZWN0ZWRMZWZ0KSkge1xuICAgICAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOml0ZW06dGV4dFJlbmRlckFkanVzdFwiLCB7XG4gICAgICAgICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICAgIGlpOiBpaSxcbiAgICAgICAgICAgICAgICAgIHByZXZMZWZ0OiArbmV3TGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgY29ycmVjdGVkTGVmdDogK2NvcnJlY3RlZExlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2VudGVyWDogK3JlbmRlcmVkQ2VudGVyWC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgcmVmQ2VudGVyWDogK3RhcmdldFJlbmRlckNlbnRlclgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiArcmVuZGVyRGVsdGEudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld0xlZnQgPSBjb3JyZWN0ZWRMZWZ0O1xuICAgICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IG5ld0xlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3VG9wIC0gaXQudG9wKSA+IDAuNSB8fCBNYXRoLmFicyhuZXdMZWZ0IC0gaXQubGVmdCkgPiAwLjUpIGNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGl0ZW1Cb3R0b20gPSBuZXdUb3AgKyAoaXQuaGVpZ2h0IHx8IDApO1xuICAgICAgICAgIGlmIChpdGVtQm90dG9tID4gY2x1c3RlckJvdHRvbVVzZWQpIGNsdXN0ZXJCb3R0b21Vc2VkID0gaXRlbUJvdHRvbTtcbiAgICAgICAgfVxuXHJcbiAgICAgICAgLy8gQXZhbnphIGVsIGN1cnNvciBsb2NhbCBhbCBmaW5hbCBkZWwgY2x1c3RlclxyXG4gICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbCB0ZXJtaW5hciBsYSBjb2x1bW5hLCBlbCBjdXJzb3IgZ2xvYmFsIGJhamEgaGFzdGEgZG9uZGUgbGxlZ8OzIGVzdGEgY29sdW1uYVxyXG4gICAgICBnbG9iYWxDdXJzb3IgPSBNYXRoLm1heChnbG9iYWxDdXJzb3IsIGNvbEN1cnNvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5lZWRlZCA9IGdsb2JhbEN1cnNvciArIENGRy5QQURfQk9UO1xyXG4gICAgbXNsTG9nKFwic3RhY2s6ZW5kXCIsIHtcclxuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcclxuICAgICAgbmVlZGVkSGVpZ2h0OiArbmVlZGVkLnRvRml4ZWQoMSksXHJcbiAgICAgIGZpbmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSlcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgY2hhbmdlZDogY2hhbmdlZCwgbmVlZGVkSGVpZ2h0OiBuZWVkZWQgfTtcclxuICB9XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc1N0YWNraW5nQmxvY2siLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartSectionLayout.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMobileSmartSectionLayoutScript: () => (/* binding */ buildMobileSmartSectionLayoutScript)\n/* harmony export */ });\n/* harmony import */ var _mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobileSmartLayout */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts\");\n// functions/src/utils/mobileSmartSectionLayout.ts\n\nfunction buildMobileSmartSectionLayoutScript(opts) {\n    const cfg = (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)(opts);\n    return (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.buildScript)(cfg);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBRWlCO0FBRTVELFNBQVNFLG9DQUFvQ0MsSUFBOEI7SUFDaEYsTUFBTUMsTUFBTUosbUVBQWVBLENBQUNHO0lBQzVCLE9BQU9GLCtEQUFXQSxDQUFDRztBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHNcclxuaW1wb3J0IHsgTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zIH0gZnJvbSBcIi4vbW9iaWxlU21hcnRMYXlvdXRcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplQ29uZmlnLCBidWlsZFNjcmlwdCB9IGZyb20gXCIuL21vYmlsZVNtYXJ0TGF5b3V0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQob3B0czogTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBjZmcgPSBub3JtYWxpemVDb25maWcob3B0cyk7XHJcbiAgcmV0dXJuIGJ1aWxkU2NyaXB0KGNmZyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUNvbmZpZyIsImJ1aWxkU2NyaXB0IiwiYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQiLCJvcHRzIiwiY2ZnIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts\n");

/***/ })

};
;