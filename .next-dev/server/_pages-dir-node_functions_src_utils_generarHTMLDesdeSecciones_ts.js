"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_functions_src_utils_generarHTMLDesdeSecciones_ts";
exports.ids = ["_pages-dir-node_functions_src_utils_generarHTMLDesdeSecciones_ts"];
exports.modules = {

/***/ "(pages-dir-node)/./functions/src/models/lineConstants.ts":
/*!***********************************************!*\
  !*** ./functions/src/models/lineConstants.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LINE_CONSTANTS: () => (/* binding */ LINE_CONSTANTS)\n/* harmony export */ });\n// functions/src/models/lineConstants.ts\n// Mismas constantes para el backend (TypeScript)\nconst LINE_CONSTANTS = {\n    STROKE_WIDTH: 2,\n    HIT_STROKE_WIDTH: 15,\n    DEFAULT_LENGTH: 100,\n    DEFAULT_COLOR: \"#000000\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvbW9kZWxzL2xpbmVDb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDMUMsTUFBTUEsaUJBQWlCO0lBQzVCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0FBQ2pCLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFxtb2RlbHNcXGxpbmVDb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy9tb2RlbHMvbGluZUNvbnN0YW50cy50c1xyXG4vLyBNaXNtYXMgY29uc3RhbnRlcyBwYXJhIGVsIGJhY2tlbmQgKFR5cGVTY3JpcHQpXHJcbmV4cG9ydCBjb25zdCBMSU5FX0NPTlNUQU5UUyA9IHtcclxuICBTVFJPS0VfV0lEVEg6IDIsXHJcbiAgSElUX1NUUk9LRV9XSURUSDogMTUsXHJcbiAgREVGQVVMVF9MRU5HVEg6IDEwMCxcclxuICBERUZBVUxUX0NPTE9SOiBcIiMwMDAwMDBcIlxyXG59OyJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsIlNUUk9LRV9XSURUSCIsIkhJVF9TVFJPS0VfV0lEVEgiLCJERUZBVUxUX0xFTkdUSCIsIkRFRkFVTFRfQ09MT1IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/models/lineConstants.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeObjetos.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   generarHTMLDesdeObjetos: () => (/* binding */ generarHTMLDesdeObjetos)\n/* harmony export */ });\n/* harmony import */ var _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/lineConstants */ \"(pages-dir-node)/./functions/src/models/lineConstants.ts\");\n\n// ✅ Escapar strings para meterlos en atributos/HTML\nfunction escHTML(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction escapeAttr(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nconst MOTION_EFFECT_VALUES = new Set([\n    \"none\",\n    \"reveal\",\n    \"draw\",\n    \"zoom\",\n    \"hover\",\n    \"pulse\"\n]);\nfunction sanitizeMotionEffect(value) {\n    const normalized = String(value || \"\").trim().toLowerCase();\n    return MOTION_EFFECT_VALUES.has(normalized) ? normalized : \"none\";\n}\nfunction normalizeRoleValue(value) {\n    return String(value || \"\").trim().toLowerCase();\n}\nfunction mapObjToDataType(obj) {\n    const tipo = normalizeRoleValue(obj?.tipo);\n    const figura = normalizeRoleValue(obj?.figura);\n    if (tipo === \"texto\" || tipo === \"text\") return \"text\";\n    if (tipo === \"imagen\" || tipo === \"image\") return \"image\";\n    if (tipo === \"icono\" || tipo === \"icono-svg\" || tipo === \"icon\") return \"icon\";\n    if (tipo === \"galeria\" || tipo === \"gallery\") return \"gallery\";\n    if (tipo === \"countdown\") return \"countdown\";\n    if (tipo === \"rsvp-boton\" || tipo === \"rsvp\") return \"rsvp\";\n    if (tipo === \"button\" || tipo === \"boton\") return \"button\";\n    if (tipo === \"line\" || tipo === \"divider\") return \"divider\";\n    if (tipo === \"forma\" && figura === \"line\") return \"divider\";\n    if (tipo === \"forma\") return \"shape\";\n    return \"unknown\";\n}\nfunction inferDataRole(obj) {\n    const explicitRole = normalizeRoleValue(obj?.role || obj?.rol);\n    if (explicitRole) return explicitRole;\n    const type = mapObjToDataType(obj);\n    if (type === \"text\") {\n        const fontSize = Number(obj?.fontSize);\n        if (Number.isFinite(fontSize) && fontSize >= 30) return \"title\";\n        if (Number.isFinite(fontSize) && fontSize >= 22) return \"subtitle\";\n        return \"body\";\n    }\n    if (type === \"divider\") return \"divider\";\n    if (type === \"image\") return \"image\";\n    if (type === \"icon\") return \"icon\";\n    if (type === \"gallery\") return \"gallery\";\n    if (type === \"countdown\") return \"countdown\";\n    if (type === \"rsvp\" || type === \"button\") return \"cta\";\n    if (type === \"shape\") return \"decorative\";\n    return \"content\";\n}\nfunction buildMotionDataAttrs(obj) {\n    const dataType = escapeAttr(mapObjToDataType(obj));\n    const dataRole = escapeAttr(inferDataRole(obj));\n    const dataMotion = escapeAttr(sanitizeMotionEffect(obj?.motionEffect));\n    return `data-type=\"${dataType}\" data-role=\"${dataRole}\" data-motion=\"${dataMotion}\"`;\n}\nfunction appendMotionDataAttrs(htmlElemento, obj) {\n    if (!htmlElemento || typeof htmlElemento !== \"string\") return htmlElemento;\n    const attrs = buildMotionDataAttrs(obj);\n    return htmlElemento.replace(/(<(?:div|img|svg)\\b[^>]*\\bclass=\"[^\"]*\\bobjeto\\b[^\"]*\")/i, `$1 ${attrs}`);\n}\nfunction getLinkProps(obj) {\n    const raw = obj?.enlace;\n    if (!raw) return null;\n    if (typeof raw === \"string\") {\n        const href = escapeAttr(raw);\n        if (!href) return null;\n        return {\n            href,\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n        };\n    }\n    const href = escapeAttr(raw.href || \"\");\n    if (!href) return null;\n    const target = escapeAttr(raw.target || \"_blank\");\n    const rel = escapeAttr(raw.rel || \"noopener noreferrer\");\n    return {\n        href,\n        target,\n        rel\n    };\n}\nfunction envolverSiEnlace(htmlElemento, obj) {\n    const htmlConData = appendMotionDataAttrs(htmlElemento, obj);\n    if (obj?.tipo === \"rsvp-boton\") return htmlConData;\n    const link = getLinkProps(obj);\n    if (!link) return htmlConData;\n    return `<a href=\"${link.href}\" target=\"${link.target}\" rel=\"${link.rel}\" style=\"text-decoration:none;color:inherit;display:contents\">${htmlConData}</a>`;\n}\nfunction escapeHTML(texto = \"\") {\n    return texto.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction generarHTMLDesdeObjetos(objetos, _secciones) {\n    const altoModoPorSeccion = new Map((_secciones || []).map((s)=>[\n            s.id,\n            String(s.altoModo || \"fijo\").toLowerCase()\n        ]));\n    function esSeccionPantalla(obj) {\n        const modo = altoModoPorSeccion.get(obj?.seccionId) || \"fijo\";\n        return modo === \"pantalla\";\n    }\n    function isFullBleed(obj) {\n        return String(obj?.anclaje || \"\").toLowerCase() === \"fullbleed\";\n    }\n    /**\r\n   * ✅ Escala uniforme del CONTENIDO:\r\n   * - pantalla: var(--sfinal) (fit si hace falta)\r\n   * - fijo: var(--sx)\r\n   */ function sContenidoVar(obj) {\n        return esSeccionPantalla(obj) ? \"var(--sfinal)\" : \"var(--sx)\";\n    }\n    /**\r\n   * ✅ X scale:\r\n   * - fullBleed: var(--bx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sX(obj) {\n        return isFullBleed(obj) ? \"var(--bx)\" : sContenidoVar(obj);\n    }\n    /**\r\n   * ✅ Y scale:\r\n   * - fullBleed: var(--sx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sY(obj) {\n        return isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n    }\n    function pxX(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return `calc(${sX(obj)} * ${n}px)`;\n    }\n    function pxY(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return `calc(${sY(obj)} * ${n}px)`;\n    }\n    // ===========================\n    // ✅ PANTALLA: top por porcentaje\n    // ===========================\n    const ALTURA_EDITOR_PANTALLA = 500;\n    // ✅ Offsets en secciones Pantalla: ON\n    // ⚠️ IMPORTANTE: este archivo SOLO genera objetos.\n    // El valor DESKTOP/MOBILE real se controla vía CSS global con:\n    //   :root { --pantalla-y-offset: Xpx }\n    //   @media (max-width: 640px) { :root { --pantalla-y-offset: Ypx } }\n    //\n    // Acá dejamos fallback (desktop) por si la variable CSS no existe.\n    const PANTALLA_Y_OFFSET_DESKTOP_PX = -28;\n    function clamp01(n) {\n        const x = Number(n);\n        if (!Number.isFinite(x)) return null;\n        return Math.max(0, Math.min(1, x));\n    }\n    function getYPxEditor(obj) {\n        // ✅ En Pantalla ON: yNorm es la fuente de verdad (0..1)\n        const yn = clamp01(obj?.yNorm);\n        if (yn != null) return yn * ALTURA_EDITOR_PANTALLA;\n        // fallback: si no hay yNorm, usamos y como \"editor px\"\n        const yPx = Number(obj?.y);\n        if (Number.isFinite(yPx)) return yPx;\n        return 0;\n    }\n    function topPantallaCSS(obj, ynRaw) {\n        const yn = clamp01(ynRaw) ?? 0;\n        const ynCompactado = `calc(0.5 + ((${yn}) - 0.5) * (1 - var(--pantalla-y-compact, 0)))`;\n        return `calc(\n  (var(--vh-logical) * ${ynCompactado})\n  + (${sContenidoVar(obj)} * var(--pantalla-y-offset, ${PANTALLA_Y_OFFSET_DESKTOP_PX}px))\n)`;\n    }\n    /**\n   * ✅ topCSS:\n   * - Pantalla ON: usa var(--vh-logical) * yn\n   * - Texto en Pantalla ON: suma offset (CSS var) escalado por sContenidoVar\n   * - Fijo: pxY(obj, y)\n   */ function topCSS(obj) {\n        if (esSeccionPantalla(obj)) {\n            const yPxEditor = getYPxEditor(obj);\n            const yn = clamp01(yPxEditor / ALTURA_EDITOR_PANTALLA) ?? 0;\n            return topPantallaCSS(obj, yn);\n        }\n        const y = Number(obj?.y || 0);\n        return pxY(obj, y);\n    }\n    /**\r\n   * ✅ Variante para cuando ya tenés yPx (en \"px editor\")\r\n   */ function topCSSFromYPx(obj, yPx) {\n        if (esSeccionPantalla(obj)) {\n            const yn = clamp01(yPx / ALTURA_EDITOR_PANTALLA) ?? 0;\n            return topPantallaCSS(obj, yn);\n        }\n        return pxY(obj, yPx);\n    }\n    function stylePosBase(obj) {\n        const x = Number(obj?.x || 0);\n        const rot = obj?.rotation ?? 0;\n        const scaleX = obj?.scaleX ?? 1;\n        const scaleY = obj?.scaleY ?? 1;\n        const zIndex = Number.isFinite(obj?.zIndex) ? obj.zIndex : undefined;\n        return `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSS(obj)};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: top left;\n${zIndex !== undefined ? `z-index:${zIndex};` : \"\"}\npointer-events: auto;\n`.trim();\n    }\n    function styleSize(obj, w, h) {\n        const ww = Number.isFinite(w) ? w : undefined;\n        const hh = Number.isFinite(h) ? h : undefined;\n        const parts = [];\n        if (ww !== undefined) parts.push(`width: ${pxX(obj, ww)};`);\n        if (hh !== undefined) parts.push(`height: ${pxY(obj, hh)};`);\n        return parts.join(\"\\n\");\n    }\n    function renderIconoSvgNuevoInline(obj) {\n        const viewBox = obj.viewBox || \"0 0 24 24\";\n        const color = obj.color || \"#000\";\n        const paths = Array.isArray(obj.paths) ? obj.paths : [];\n        if (!paths.length) return \"\";\n        const w = Number.isFinite(obj?.width) ? obj.width : 24;\n        const h = Number.isFinite(obj?.height) ? obj.height : 24;\n        const rot = obj?.rotation ?? 0;\n        const scaleX = obj?.scaleX ?? 1;\n        const scaleY = obj?.scaleY ?? 1;\n        const x = Number(obj?.x || 0);\n        const yPx = getYPxEditor(obj);\n        const pathsHtml = paths.map((p)=>p?.d ? `<path d=\"${escHTML(p.d)}\" fill=\"${escHTML(color)}\"></path>` : \"\").join(\"\");\n        const style = `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSSFromYPx(obj, yPx)};\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: top left;\npointer-events: auto;\n`.trim();\n        return `<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${escHTML(viewBox)}\" style=\"${style}\">${pathsHtml}</svg>`;\n    }\n    return objetos.map((obj)=>{\n        const tipo = obj?.tipo;\n        // ---------------- TEXTO ----------------\n        if (tipo === \"texto\") {\n            const align = String(obj.align || obj.textAlign || \"left\").toLowerCase();\n            const color = obj.colorTexto || obj.color || obj.fill || \"#000\";\n            const baseLineHeight = typeof obj.lineHeight === \"number\" && obj.lineHeight > 0 ? obj.lineHeight : 1.2;\n            const lineHeightFinal = baseLineHeight * 0.92;\n            const safeTexto = escHTML(obj.texto || \"\");\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const fs = Number.isFinite(obj?.fontSize) ? obj.fontSize : 24;\n            // ⚠️ texto fullBleed NO hace fit => escala con var(--sx)\n            const sFont = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const rot = obj?.rotation ?? 0;\n            const scaleX = obj?.scaleX ?? 1;\n            const scaleY = obj?.scaleY ?? 1;\n            const origin = align === \"center\" ? \"top center\" : align === \"right\" ? \"top right\" : \"top left\";\n            const style = `\n${baseStyle}\n/* ✅ mantener geometría estable y escalar tipografía por font-size (no por transform). */\ntransform-origin: ${origin};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\n${w !== undefined ? `width: ${pxX(obj, w)};` : \"\"}\nfont-size: calc(${sFont} * ${fs}px * var(--text-zoom, 1));\nfont-family: ${obj.fontFamily || \"sans-serif\"};\nfont-weight: ${obj.fontWeight || \"normal\"};\nfont-style: ${obj.fontStyle || \"normal\"};\ntext-decoration: ${obj.textDecoration || \"none\"};\ncolor: ${color};\ntext-align: ${align};\nwhite-space: pre-wrap;\nline-height: ${lineHeightFinal};\npadding: 0;\nmargin: 0;\nbox-sizing: content-box;\n${obj.stroke && obj.strokeWidth > 0 ? `-webkit-text-stroke: ${obj.strokeWidth}px ${obj.stroke};` : \"\"}\n${obj.shadowColor ? `text-shadow: ${obj.shadowOffsetX || 0}px ${obj.shadowOffsetY || 0}px ${obj.shadowBlur || 0}px ${obj.shadowColor};` : \"text-shadow: none;\"}\n`.trim();\n            return envolverSiEnlace(`<div class=\"objeto\" data-debug-texto=\"1\" style=\"${style}\">${safeTexto}</div>`, obj);\n        }\n        // ---------------- IMAGEN ----------------\n        if (tipo === \"imagen\") {\n            const src = obj.src || obj.url || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const style = `\n${baseStyle}\n${styleSize(obj, w, h)}\nobject-fit: contain;\ndisplay: block;\n`.trim();\n            return envolverSiEnlace(`<img class=\"objeto\" src=\"${escapeAttr(src)}\" style=\"${style}\" />`, obj);\n        }\n        // ---------------- ICONO (nuevo) ----------------\n        if (tipo === \"icono\") {\n            if (obj.formato === \"svg\") {\n                const svgHtml = renderIconoSvgNuevoInline(obj);\n                if (!svgHtml) return \"\";\n                return envolverSiEnlace(svgHtml, obj);\n            }\n            const src = obj.url || obj.src || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const style = `\n${baseStyle}\n${styleSize(obj, w, h)}\nobject-fit: contain;\ndisplay: block;\n`.trim();\n            return envolverSiEnlace(`<img class=\"objeto\" src=\"${escapeAttr(src)}\" style=\"${style}\" />`, obj);\n        }\n        // ---------------- ICONO LEGACY (icono-svg) ----------------\n        if (tipo === \"icono-svg\" && obj.d) {\n            const vb = obj.viewBox || \"0 0 100 100\";\n            const fill = obj.color || \"#000\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : 100;\n            const h = Number.isFinite(obj?.height) ? obj.height : 100;\n            const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nfill: ${escapeAttr(fill)};\n`.trim();\n            const svg = `<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${escapeAttr(vb)}\" style=\"${style}\"><path d=\"${escHTML(obj.d)}\" /></svg>`;\n            return envolverSiEnlace(svg, obj);\n        }\n        // ---------------- COUNTDOWN ----------------\n        if (tipo === \"countdown\") {\n            const targetISO = obj.targetISO || obj.fechaObjetivo || obj.fechaISO || \"\";\n            const textColor = obj.colorTexto ?? obj.color ?? \"#111\";\n            const fontFamily = obj.fontFamily || \"Inter, system-ui, sans-serif\";\n            const preset = obj.presetId || obj.layout || \"pills\";\n            const isMinimal = String(preset).toLowerCase().includes(\"minimal\");\n            // ✅ ancho/alto del objeto (si existen)\n            const wObj = Number.isFinite(obj?.width) ? Number(obj.width) : null;\n            const hObj = Number.isFinite(obj?.height) ? Number(obj.height) : null;\n            // ✅ gap: si viene de Konva, respetarlo\n            const gap = Number.isFinite(obj.gap) ? Number(obj.gap) : Number.isFinite(obj.spacing) ? Number(obj.spacing) : 8;\n            // ✅ Si tu Konva guarda chipWidth / paddingX, respetalos\n            // chipWidth: ancho interno del texto (sin padding)\n            const chipWidthProp = Number.isFinite(obj.chipWidth) ? Number(obj.chipWidth) : null;\n            const paddingXProp = Number.isFinite(obj.paddingX) ? Number(obj.paddingX) : null;\n            // ✅ Derivación raíz (cuando no hay props)\n            const n = 4;\n            // chipWTotal: ancho total de cada chip (incluye padding)\n            let chipWTotal = 56; // fallback razonable\n            if (wObj && wObj > 0) {\n                chipWTotal = Math.max(40, (wObj - gap * (n - 1)) / n);\n            }\n            // paddingX derivado del chipWTotal (si no vino)\n            const paddingX = paddingXProp ?? Math.max(6, Math.round(chipWTotal * 0.18)); // ~18%\n            const paddingY = Math.max(5, Math.round(paddingX * 0.65));\n            // chipWidth (texto) derivado si no vino\n            const chipWidth = chipWidthProp ?? Math.max(10, Math.round(chipWTotal - paddingX * 2));\n            // ✅ font sizes: si vienen, respetar; si no, derivar desde chipWTotal\n            const valueSize = Number.isFinite(obj.fontSize) ? Number(obj.fontSize) : Math.max(14, Math.round(chipWTotal * 0.34));\n            const labelSize = Number.isFinite(obj.labelSize) ? Number(obj.labelSize) : Math.max(9, Math.round(valueSize * 0.62));\n            const labelColor = obj.labelColor ?? \"#6b7280\";\n            const fontWeight = Number.isFinite(obj.fontWeight) ? obj.fontWeight : 700;\n            const letterSpacing = Number.isFinite(obj.letterSpacing) ? obj.letterSpacing : 0;\n            // ✅ estilos de chip\n            const containerBgFinal = \"transparent\";\n            const chipBgFinal = isMinimal ? \"transparent\" : obj.chipBackground ?? obj.boxBg ?? \"rgba(255,255,255,.75)\";\n            const chipBorderColorFinal = isMinimal ? \"transparent\" : obj.chipBorder ?? obj.boxBorder ?? \"rgba(0,0,0,.08)\";\n            const containerRadius = Number.isFinite(obj.boxRadius) ? obj.boxRadius : Number.isFinite(obj.radius) ? obj.radius : 10;\n            const chipRadiusFinal = Number.isFinite(obj.chipRadius) ? obj.chipRadius : containerRadius;\n            const baseStyle = stylePosBase(obj);\n            // ✅ Escala correcta (respeta pantalla y bleed)\n            const sChip = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const containerStyle = `\n${baseStyle}\n${wObj ? `width: ${pxX(obj, wObj)};` : \"\"}\n${hObj ? `height: ${pxY(obj, hObj)};` : \"\"}\ndisplay: flex;\nalign-items: center;\njustify-content: center;\ngap: calc(${sChip} * ${gap}px);\nfont-family: ${fontFamily};\ncolor: ${textColor};\nbackground: ${containerBgFinal};\nborder-radius: calc(${sChip} * ${containerRadius}px);\nletter-spacing: calc(${sChip} * ${letterSpacing}px);\n`.trim();\n            const chipStyle = `\nwidth: calc(${sChip} * ${Math.round(chipWTotal)}px);\npadding: calc(${sChip} * ${paddingY}px) calc(${sChip} * ${paddingX}px);\nborder: ${isMinimal ? \"0\" : `calc(${sChip} * 1px) solid ${chipBorderColorFinal}`};\nborder-radius: calc(${sChip} * ${chipRadiusFinal}px);\ndisplay: flex;\nflex-direction: column;\nalign-items: center;\njustify-content: center;\nbackground: ${chipBgFinal};\nbox-sizing: border-box;\n`.trim();\n            const valueStyle = `\nfont-weight: ${fontWeight};\nfont-size: calc(${sChip} * ${valueSize}px);\nline-height: 1;\n`.trim();\n            const labelStyle = `\nfont-size: calc(${sChip} * ${labelSize}px);\ncolor: ${labelColor};\nline-height: 1.05;\n`.trim();\n            const showLabels = obj.showLabels !== false;\n            const labels = obj.labels ?? {\n                dias: \"Días\",\n                horas: \"Horas\",\n                min: \"Min\",\n                seg: \"Seg\"\n            };\n            const htmlCountdown = `\n<div class=\"objeto\"\n  data-mobile-cluster=\"isolated\"\n  data-mobile-center=\"force\"\n  data-countdown\n  data-target=\"${escapeAttr(targetISO)}\"\n  data-preset=\"${escapeAttr(preset)}\" style=\"${containerStyle}\">\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.dias)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.horas)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.min)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.seg)}</span>` : \"\"}\n  </div>\n</div>\n`.trim();\n            return appendMotionDataAttrs(htmlCountdown, obj);\n        }\n        // ---------------- GALERÍA ----------------\n        if (tipo === \"galeria\") {\n            const rows = Math.max(1, parseInt(obj.rows || 1, 10));\n            const cols = Math.max(1, parseInt(obj.cols || 1, 10));\n            const gapPx = Math.max(0, parseInt(obj.gap || 0, 10));\n            const radiusPx = Math.max(0, parseInt(obj.radius || 0, 10));\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const sGrid = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const styleContenedor = `\n${baseStyle}\n${styleSize(obj, w, h)}\ndisplay: grid;\ngrid-template-columns: repeat(${cols}, 1fr);\ngrid-template-rows: repeat(${rows}, 1fr);\ngap: calc(${sGrid} * ${gapPx}px);\nbox-sizing: border-box;\n`.trim();\n            const total = rows * cols;\n            const cells = Array.from({\n                length: total\n            }, (_, i)=>{\n                const c = obj.cells && obj.cells[i] || {};\n                return {\n                    mediaUrl: c.mediaUrl || \"\",\n                    fit: c.fit === \"contain\" ? \"contain\" : \"cover\",\n                    bg: c.bg || \"#f3f4f6\"\n                };\n            });\n            const htmlCeldas = cells.map((cell, idx)=>{\n                const safeSrc = escapeAttr(cell.mediaUrl || \"\");\n                const celdaStyle = `\nposition: relative;\nwidth: 100%;\nheight: 100%;\noverflow: hidden;\nborder-radius: calc(${sGrid} * ${radiusPx}px);\nbackground: ${cell.bg};\n`.trim();\n                if (!safeSrc) {\n                    return `<div class=\"galeria-celda\" data-index=\"${idx}\" style=\"${celdaStyle}\"></div>`;\n                }\n                return `\n<div class=\"galeria-celda galeria-celda--clickable\"\n     data-index=\"${idx}\"\n     data-gallery-image=\"1\"\n     role=\"button\"\n     tabindex=\"0\"\n     aria-label=\"Ver imagen en pantalla completa\"\n     style=\"${celdaStyle}\">\n  <img src=\"${safeSrc}\" alt=\"\" loading=\"lazy\" decoding=\"async\"\n       style=\"width:100%;height:100%;object-fit:${cell.fit};display:block;\" />\n</div>\n`.trim();\n            }).join(\"\");\n            const htmlGaleria = `<div class=\"objeto galeria\" style=\"${styleContenedor}\">${htmlCeldas}</div>`;\n            return envolverSiEnlace(htmlGaleria, obj);\n        }\n        // ---------------- RSVP BOTÓN ----------------\n        if (tipo === \"rsvp-boton\") {\n            const texto = escapeHTML(obj.texto || \"Confirmar asistencia\");\n            const w = Number.isFinite(obj?.ancho) ? obj.ancho : 200;\n            const h = Number.isFinite(obj?.alto) ? obj.alto : 50;\n            const color = obj.color || \"#773dbe\";\n            const colorTexto = obj.colorTexto || \"#ffffff\";\n            const fontSize = Number.isFinite(obj?.fontSize) ? obj.fontSize : 18;\n            const fontFamily = obj.fontFamily || \"sans-serif\";\n            const fontWeight = obj.fontWeight || \"bold\";\n            const fontStyle = obj.fontStyle || \"normal\";\n            const textDecoration = obj.textDecoration || \"none\";\n            const align = obj.align || \"center\";\n            const baseStyle = stylePosBase(obj);\n            // RSVP (contenido): si está en pantalla, fittea (sContenidoVar)\n            const sBtn = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nbackground-color: ${color};\ncolor: ${colorTexto};\nfont-size: calc(${sBtn} * ${fontSize}px);\nfont-family: ${fontFamily};\nfont-weight: ${fontWeight};\nfont-style: ${fontStyle};\ntext-decoration: ${textDecoration};\ntext-align: ${align};\ndisplay: flex;\nalign-items: center;\njustify-content: center;\nborder-radius: calc(${sBtn} * 8px);\ncursor: pointer;\n`.trim();\n            const htmlRsvp = `\n<div class=\"objeto is-interactive rsvp-boton\"\n  id=\"abrirModalRSVP\"\n  data-accion=\"abrir-rsvp\"\n  data-rsvp-open\n  role=\"button\"\n  tabindex=\"0\"\n  aria-label=\"Confirmar asistencia\"\n  style=\"${style}\">\n  ${texto}\n</div>\n`.trim();\n            return appendMotionDataAttrs(htmlRsvp, obj);\n        }\n        // ---------------- FORMAS ----------------\n        if (tipo === \"forma\") {\n            const fill = obj.color || \"#000\";\n            const figura = obj.figura;\n            if (figura === \"rect\") {\n                const w = Number.isFinite(obj?.width) ? obj.width : 100;\n                const h = Number.isFinite(obj?.height) ? obj.height : 100;\n                const cornerRadius = obj.cornerRadius || 0;\n                const fontSize = obj.fontSize || 24;\n                const fontFamily = obj.fontFamily || \"sans-serif\";\n                const fontWeight = obj.fontWeight || \"normal\";\n                const fontStyle = obj.fontStyle || \"normal\";\n                const textDecoration = obj.textDecoration || \"none\";\n                const align = obj.align || \"center\";\n                const colorTexto = obj.colorTexto || \"#000000\";\n                const texto = escHTML(obj.texto || \"\");\n                const baseStyle = stylePosBase(obj);\n                const sRectText = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n                const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nbackground: ${fill};\nborder-radius: calc(${sRectText} * ${cornerRadius}px);\ndisplay: flex;\nalign-items: center;\njustify-content: ${align === \"left\" ? \"flex-start\" : align === \"right\" ? \"flex-end\" : \"center\"};\ntext-align: ${align};\npadding: calc(${sRectText} * 4px);\nbox-sizing: border-box;\n`.trim();\n                const inner = `\n<div style=\"\n  width: 100%;\n  font-size: calc(${sRectText} * ${fontSize}px);\n  font-family: ${fontFamily};\n  font-weight: ${fontWeight};\n  font-style: ${fontStyle};\n  text-decoration: ${textDecoration};\n  color: ${colorTexto};\n  line-height: 1.2;\n  white-space: pre-wrap;\n  word-break: break-word;\n\">${texto}</div>\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${style}\">${inner}</div>`, obj);\n            }\n            if (figura === \"circle\") {\n                const radius = Number.isFinite(obj?.radius) ? obj.radius : 50;\n                const diameter = radius * 2;\n                const x = Number(obj?.x || 0) - radius;\n                const yPxCenter = getYPxEditor(obj);\n                const yPxTopLeft = yPxCenter - radius;\n                const rot = obj?.rotation ?? 0;\n                const scaleX = obj?.scaleX ?? 1;\n                const scaleY = obj?.scaleY ?? 1;\n                const style = `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSSFromYPx(obj, yPxTopLeft)};\nwidth: ${pxX(obj, diameter)};\nheight: ${pxY(obj, diameter)};\nborder-radius: 50%;\nbackground: ${fill};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: center center;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${style}\"></div>`, obj);\n            }\n            if (figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH,\n                    0\n                ];\n                const x1 = parseFloat(points[0]) || 0;\n                const y1 = parseFloat(points[1]) || 0;\n                const x2 = parseFloat(points[2]) || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH;\n                const y2 = parseFloat(points[3]) || 0;\n                const strokeWidth = obj.strokeWidth || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.STROKE_WIDTH;\n                const deltaX = x2 - x1;\n                const deltaY = y2 - y1;\n                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n                const startX = Number(obj?.x || 0) + x1;\n                const baseY = getYPxEditor(obj);\n                const startY = baseY + y1;\n                const totalRotation = angle + (obj.rotation || 0);\n                const scaleX = obj?.scaleX ?? 1;\n                const scaleY = obj?.scaleY ?? 1;\n                // alto de línea: usamos escala Y del objeto (contenido: sfinal/sx, bleed: sx)\n                const lineH = `calc(${sY(obj)} * ${strokeWidth}px)`;\n                const style = `\nposition: absolute;\nleft: ${pxX(obj, startX)};\ntop: ${topCSSFromYPx(obj, startY)};\nwidth: ${pxX(obj, length)};\nheight: ${lineH};\nbackground: ${fill};\ntransform: rotate(${totalRotation}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: 0 50%;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto linea\" style=\"${style}\"></div>`, obj);\n            }\n            if (figura === \"triangle\") {\n                const radius = obj.radius || 60;\n                const sin60 = Math.sqrt(3) / 2;\n                const cos60 = 0.5;\n                const triangleWidth = 2 * radius * sin60;\n                const triangleHeight = radius * (1 + cos60);\n                const centroidOffsetY = triangleHeight / 3;\n                const baseY = getYPxEditor(obj);\n                const topContainerPx = baseY - (triangleHeight - centroidOffsetY);\n                const leftContainer = Number(obj?.x || 0) - triangleWidth / 2;\n                const baseStyle = `\nposition: absolute;\nleft: ${pxX(obj, leftContainer)};\ntop: ${topCSSFromYPx(obj, topContainerPx)};\nwidth: ${pxX(obj, triangleWidth)};\nheight: ${pxY(obj, triangleHeight)};\nbackground: ${fill};\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%);\ntransform: rotate(${obj.rotation ?? 0}deg) scale(${obj.scaleX ?? 1}, ${obj.scaleY ?? 1});\ntransform-origin: center center;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${baseStyle}\"></div>`, obj);\n            }\n            return \"\";\n        }\n        return \"\";\n    }).join(\"\\n\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBRXpELG9EQUFvRDtBQUNwRCxTQUFTQyxRQUFRQyxNQUFXLEVBQUU7SUFDNUIsT0FBT0MsT0FBT0QsS0FDWEUsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxTQUFTQyxXQUFXSCxNQUFjLEVBQUU7SUFDbEMsT0FBT0MsT0FBT0QsS0FDWEUsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxNQUFNRSx1QkFBdUIsSUFBSUMsSUFBSTtJQUFDO0lBQVE7SUFBVTtJQUFRO0lBQVE7SUFBUztDQUFRO0FBRXpGLFNBQVNDLHFCQUFxQkMsS0FBVTtJQUN0QyxNQUFNQyxhQUFhUCxPQUFPTSxTQUFTLElBQUlFLElBQUksR0FBR0MsV0FBVztJQUN6RCxPQUFPTixxQkFBcUJPLEdBQUcsQ0FBQ0gsY0FBY0EsYUFBYTtBQUM3RDtBQUVBLFNBQVNJLG1CQUFtQkwsS0FBVTtJQUNwQyxPQUFPTixPQUFPTSxTQUFTLElBQUlFLElBQUksR0FBR0MsV0FBVztBQUMvQztBQUVBLFNBQVNHLGlCQUFpQkMsR0FBUTtJQUNoQyxNQUFNQyxPQUFPSCxtQkFBbUJFLEtBQUtDO0lBQ3JDLE1BQU1DLFNBQVNKLG1CQUFtQkUsS0FBS0U7SUFFdkMsSUFBSUQsU0FBUyxXQUFXQSxTQUFTLFFBQVEsT0FBTztJQUNoRCxJQUFJQSxTQUFTLFlBQVlBLFNBQVMsU0FBUyxPQUFPO0lBQ2xELElBQUlBLFNBQVMsV0FBV0EsU0FBUyxlQUFlQSxTQUFTLFFBQVEsT0FBTztJQUN4RSxJ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ckwsSUFBSWhELEtBQUtrTyxlQUFlO1FBQ3pCLEVBQUUvSyxJQUFJbkQsS0FBS21PLGdCQUFnQjtZQUN2QixFQUFFOUgsS0FBSzs7a0JBRUQsRUFBRXJHLElBQUl3RSxRQUFRLElBQUksRUFBRSxXQUFXLEVBQUV4RSxJQUFJeUUsTUFBTSxJQUFJLEVBQUUsRUFBRSxFQUFFekUsSUFBSTBFLE1BQU0sSUFBSSxFQUFFOzs7QUFHdkYsQ0FBQyxDQUFDL0UsSUFBSTtnQkFFSSxPQUFPOEIsaUJBQWlCLENBQUMsMkJBQTJCLEVBQUVpRixVQUFVLFFBQVEsQ0FBQyxFQUFFMUc7WUFDN0U7WUFFQSxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1QsR0FDQ29GLElBQUksQ0FBQztBQUNWIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXGdlbmVyYXJIVE1MRGVzZGVPYmpldG9zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExJTkVfQ09OU1RBTlRTIH0gZnJvbSBcIi4uL21vZGVscy9saW5lQ29uc3RhbnRzXCI7XHJcblxyXG4vLyDinIUgRXNjYXBhciBzdHJpbmdzIHBhcmEgbWV0ZXJsb3MgZW4gYXRyaWJ1dG9zL0hUTUxcclxuZnVuY3Rpb24gZXNjSFRNTChzdHI6IGFueSA9IFwiXCIpOiBzdHJpbmcge1xyXG4gIHJldHVybiBTdHJpbmcoc3RyKVxyXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcclxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxyXG4gICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVzY2FwZUF0dHIoc3RyOiBzdHJpbmcgPSBcIlwiKTogc3RyaW5nIHtcbiAgcmV0dXJuIFN0cmluZyhzdHIpXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbn1cblxuY29uc3QgTU9USU9OX0VGRkVDVF9WQUxVRVMgPSBuZXcgU2V0KFtcIm5vbmVcIiwgXCJyZXZlYWxcIiwgXCJkcmF3XCIsIFwiem9vbVwiLCBcImhvdmVyXCIsIFwicHVsc2VcIl0pO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZU1vdGlvbkVmZmVjdCh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IFN0cmluZyh2YWx1ZSB8fCBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIE1PVElPTl9FRkZFQ1RfVkFMVUVTLmhhcyhub3JtYWxpemVkKSA/IG5vcm1hbGl6ZWQgOiBcIm5vbmVcIjtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUm9sZVZhbHVlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gU3RyaW5nKHZhbHVlIHx8IFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBtYXBPYmpUb0RhdGFUeXBlKG9iajogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgdGlwbyA9IG5vcm1hbGl6ZVJvbGVWYWx1ZShvYmo/LnRpcG8pO1xuICBjb25zdCBmaWd1cmEgPSBub3JtYWxpemVSb2xlVmFsdWUob2JqPy5maWd1cmEpO1xuXG4gIGlmICh0aXBvID09PSBcInRleHRvXCIgfHwgdGlwbyA9PT0gXCJ0ZXh0XCIpIHJldHVybiBcInRleHRcIjtcbiAgaWYgKHRpcG8gPT09IFwiaW1hZ2VuXCIgfHwgdGlwbyA9PT0gXCJpbWFnZVwiKSByZXR1cm4gXCJpbWFnZVwiO1xuICBpZiAodGlwbyA9PT0gXCJpY29ub1wiIHx8IHRpcG8gPT09IFwiaWNvbm8tc3ZnXCIgfHwgdGlwbyA9PT0gXCJpY29uXCIpIHJldHVybiBcImljb25cIjtcbiAgaWYgKHRpcG8gPT09IFwiZ2FsZXJpYVwiIHx8IHRpcG8gPT09IFwiZ2FsbGVyeVwiKSByZXR1cm4gXCJnYWxsZXJ5XCI7XG4gIGlmICh0aXBvID09PSBcImNvdW50ZG93blwiKSByZXR1cm4gXCJjb3VudGRvd25cIjtcbiAgaWYgKHRpcG8gPT09IFwicnN2cC1ib3RvblwiIHx8IHRpcG8gPT09IFwicnN2cFwiKSByZXR1cm4gXCJyc3ZwXCI7XG4gIGlmICh0aXBvID09PSBcImJ1dHRvblwiIHx8IHRpcG8gPT09IFwiYm90b25cIikgcmV0dXJuIFwiYnV0dG9uXCI7XG4gIGlmICh0aXBvID09PSBcImxpbmVcIiB8fCB0aXBvID09PSBcImRpdmlkZXJcIikgcmV0dXJuIFwiZGl2aWRlclwiO1xuICBpZiAodGlwbyA9PT0gXCJmb3JtYVwiICYmIGZpZ3VyYSA9PT0gXCJsaW5lXCIpIHJldHVybiBcImRpdmlkZXJcIjtcbiAgaWYgKHRpcG8gPT09IFwiZm9ybWFcIikgcmV0dXJuIFwic2hhcGVcIjtcblxuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5cbmZ1bmN0aW9uIGluZmVyRGF0YVJvbGUob2JqOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBleHBsaWNpdFJvbGUgPSBub3JtYWxpemVSb2xlVmFsdWUob2JqPy5yb2xlIHx8IG9iaj8ucm9sKTtcbiAgaWYgKGV4cGxpY2l0Um9sZSkgcmV0dXJuIGV4cGxpY2l0Um9sZTtcblxuICBjb25zdCB0eXBlID0gbWFwT2JqVG9EYXRhVHlwZShvYmopO1xuICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IE51bWJlcihvYmo/LmZvbnRTaXplKTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZvbnRTaXplKSAmJiBmb250U2l6ZSA+PSAzMCkgcmV0dXJuIFwidGl0bGVcIjtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZvbnRTaXplKSAmJiBmb250U2l6ZSA+PSAyMikgcmV0dXJuIFwic3VidGl0bGVcIjtcbiAgICByZXR1cm4gXCJib2R5XCI7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gXCJkaXZpZGVyXCIpIHJldHVybiBcImRpdmlkZXJcIjtcbiAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikgcmV0dXJuIFwiaW1hZ2VcIjtcbiAgaWYgKHR5cGUgPT09IFwiaWNvblwiKSByZXR1cm4gXCJpY29uXCI7XG4gIGlmICh0eXBlID09PSBcImdhbGxlcnlcIikgcmV0dXJuIFwiZ2FsbGVyeVwiO1xuICBpZiAodHlwZSA9PT0gXCJjb3VudGRvd25cIikgcmV0dXJuIFwiY291bnRkb3duXCI7XG4gIGlmICh0eXBlID09PSBcInJzdnBcIiB8fCB0eXBlID09PSBcImJ1dHRvblwiKSByZXR1cm4gXCJjdGFcIjtcbiAgaWYgKHR5cGUgPT09IFwic2hhcGVcIikgcmV0dXJuIFwiZGVjb3JhdGl2ZVwiO1xuXG4gIHJldHVybiBcImNvbnRlbnRcIjtcbn1cblxuZnVuY3Rpb24gYnVpbGRNb3Rpb25EYXRhQXR0cnMob2JqOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBkYXRhVHlwZSA9IGVzY2FwZUF0dHIobWFwT2JqVG9EYXRhVHlwZShvYmopKTtcbiAgY29uc3QgZGF0YVJvbGUgPSBlc2NhcGVBdHRyKGluZmVyRGF0YVJvbGUob2JqKSk7XG4gIGNvbnN0IGRhdGFNb3Rpb24gPSBlc2NhcGVBdHRyKHNhbml0aXplTW90aW9uRWZmZWN0KG9iaj8ubW90aW9uRWZmZWN0KSk7XG4gIHJldHVybiBgZGF0YS10eXBlPVwiJHtkYXRhVHlwZX1cIiBkYXRhLXJvbGU9XCIke2RhdGFSb2xlfVwiIGRhdGEtbW90aW9uPVwiJHtkYXRhTW90aW9ufVwiYDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kTW90aW9uRGF0YUF0dHJzKGh0bWxFbGVtZW50bzogc3RyaW5nLCBvYmo6IGFueSk6IHN0cmluZyB7XG4gIGlmICghaHRtbEVsZW1lbnRvIHx8IHR5cGVvZiBodG1sRWxlbWVudG8gIT09IFwic3RyaW5nXCIpIHJldHVybiBodG1sRWxlbWVudG87XG5cbiAgY29uc3QgYXR0cnMgPSBidWlsZE1vdGlvbkRhdGFBdHRycyhvYmopO1xuICByZXR1cm4gaHRtbEVsZW1lbnRvLnJlcGxhY2UoXG4gICAgLyg8KD86ZGl2fGltZ3xzdmcpXFxiW14+XSpcXGJjbGFzcz1cIlteXCJdKlxcYm9iamV0b1xcYlteXCJdKlwiKS9pLFxuICAgIGAkMSAke2F0dHJzfWBcbiAgKTtcbn1cblxyXG5mdW5jdGlvbiBnZXRMaW5rUHJvcHMob2JqOiBhbnkpIHtcclxuICBjb25zdCByYXcgPSBvYmo/LmVubGFjZTtcclxuICBpZiAoIXJhdykgcmV0dXJuIG51bGw7XHJcblxyXG4gIGlmICh0eXBlb2YgcmF3ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBjb25zdCBocmVmID0gZXNjYXBlQXR0cihyYXcpO1xyXG4gICAgaWYgKCFocmVmKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB7IGhyZWYsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaHJlZiA9IGVzY2FwZUF0dHIocmF3LmhyZWYgfHwgXCJcIik7XHJcbiAgaWYgKCFocmVmKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgY29uc3QgdGFyZ2V0ID0gZXNjYXBlQXR0cihyYXcudGFyZ2V0IHx8IFwiX2JsYW5rXCIpO1xyXG4gIGNvbnN0IHJlbCA9IGVzY2FwZUF0dHIocmF3LnJlbCB8fCBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIik7XHJcbiAgcmV0dXJuIHsgaHJlZiwgdGFyZ2V0LCByZWwgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW52b2x2ZXJTaUVubGFjZShodG1sRWxlbWVudG86IHN0cmluZywgb2JqOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBodG1sQ29uRGF0YSA9IGFwcGVuZE1vdGlvbkRhdGFBdHRycyhodG1sRWxlbWVudG8sIG9iaik7XG4gIGlmIChvYmo/LnRpcG8gPT09IFwicnN2cC1ib3RvblwiKSByZXR1cm4gaHRtbENvbkRhdGE7XG5cbiAgY29uc3QgbGluayA9IGdldExpbmtQcm9wcyhvYmopO1xuICBpZiAoIWxpbmspIHJldHVybiBodG1sQ29uRGF0YTtcblxuICByZXR1cm4gYDxhIGhyZWY9XCIke2xpbmsuaHJlZn1cIiB0YXJnZXQ9XCIke2xpbmsudGFyZ2V0fVwiIHJlbD1cIiR7bGluay5yZWx9XCIgc3R5bGU9XCJ0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjppbmhlcml0O2Rpc3BsYXk6Y29udGVudHNcIj4ke2h0bWxDb25EYXRhfTwvYT5gO1xufVxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVIVE1MKHRleHRvOiBzdHJpbmcgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gdGV4dG9cclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcclxuICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2JqZXRvczogYW55W10sIF9zZWNjaW9uZXM6IGFueVtdKTogc3RyaW5nIHtcclxuICBjb25zdCBhbHRvTW9kb1BvclNlY2Npb24gPSBuZXcgTWFwKFxyXG4gICAgKF9zZWNjaW9uZXMgfHwgW10pLm1hcCgoczogYW55KSA9PiBbcy5pZCwgU3RyaW5nKHMuYWx0b01vZG8gfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCldKVxyXG4gICk7XHJcblxyXG4gIGZ1bmN0aW9uIGVzU2VjY2lvblBhbnRhbGxhKG9iajogYW55KTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBtb2RvID0gYWx0b01vZG9Qb3JTZWNjaW9uLmdldChvYmo/LnNlY2Npb25JZCkgfHwgXCJmaWpvXCI7XHJcbiAgICByZXR1cm4gbW9kbyA9PT0gXCJwYW50YWxsYVwiO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNGdWxsQmxlZWQob2JqOiBhbnkpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBTdHJpbmcob2JqPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiZnVsbGJsZWVkXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgRXNjYWxhIHVuaWZvcm1lIGRlbCBDT05URU5JRE86XHJcbiAgICogLSBwYW50YWxsYTogdmFyKC0tc2ZpbmFsKSAoZml0IHNpIGhhY2UgZmFsdGEpXHJcbiAgICogLSBmaWpvOiB2YXIoLS1zeClcclxuICAgKi9cclxuICBmdW5jdGlvbiBzQ29udGVuaWRvVmFyKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgIHJldHVybiBlc1NlY2Npb25QYW50YWxsYShvYmopID8gXCJ2YXIoLS1zZmluYWwpXCIgOiBcInZhcigtLXN4KVwiO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog4pyFIFggc2NhbGU6XHJcbiAgICogLSBmdWxsQmxlZWQ6IHZhcigtLWJ4KSAoTk8gZml0KVxyXG4gICAqIC0gY29udGVuaWRvOiBzQ29udGVuaWRvVmFyIChmaXQgc2kgcGFudGFsbGEpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc1gob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLWJ4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog4pyFIFkgc2NhbGU6XHJcbiAgICogLSBmdWxsQmxlZWQ6IHZhcigtLXN4KSAoTk8gZml0KVxyXG4gICAqIC0gY29udGVuaWRvOiBzQ29udGVuaWRvVmFyIChmaXQgc2kgcGFudGFsbGEpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc1kob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHhYKG9iajogYW55LCBweDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG4gPSBOdW1iZXIuaXNGaW5pdGUocHgpID8gcHggOiAwO1xyXG4gICAgcmV0dXJuIGBjYWxjKCR7c1gob2JqKX0gKiAke259cHgpYDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB4WShvYmo6IGFueSwgcHg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCBuID0gTnVtYmVyLmlzRmluaXRlKHB4KSA/IHB4IDogMDtcclxuICAgIHJldHVybiBgY2FsYygke3NZKG9iail9ICogJHtufXB4KWA7XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyDinIUgUEFOVEFMTEE6IHRvcCBwb3IgcG9yY2VudGFqZVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIGNvbnN0IEFMVFVSQV9FRElUT1JfUEFOVEFMTEEgPSA1MDA7XHJcblxyXG4gIC8vIOKchSBPZmZzZXRzIGVuIHNlY2Npb25lcyBQYW50YWxsYTogT05cclxuICAvLyDimqDvuI8gSU1QT1JUQU5URTogZXN0ZSBhcmNoaXZvIFNPTE8gZ2VuZXJhIG9iamV0b3MuXHJcbiAgLy8gRWwgdmFsb3IgREVTS1RPUC9NT0JJTEUgcmVhbCBzZSBjb250cm9sYSB2w61hIENTUyBnbG9iYWwgY29uOlxyXG4gIC8vICAgOnJvb3QgeyAtLXBhbnRhbGxhLXktb2Zmc2V0OiBYcHggfVxyXG4gIC8vICAgQG1lZGlhIChtYXgtd2lkdGg6IDY0MHB4KSB7IDpyb290IHsgLS1wYW50YWxsYS15LW9mZnNldDogWXB4IH0gfVxyXG4gIC8vXHJcbiAgLy8gQWPDoSBkZWphbW9zIGZhbGxiYWNrIChkZXNrdG9wKSBwb3Igc2kgbGEgdmFyaWFibGUgQ1NTIG5vIGV4aXN0ZS5cclxuICBjb25zdCBQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYID0gLTI4O1xyXG5cclxuICBmdW5jdGlvbiBjbGFtcDAxKG46IGFueSk6IG51bWJlciB8IG51bGwge1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihuKTtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRZUHhFZGl0b3Iob2JqOiBhbnkpOiBudW1iZXIge1xuICAgIC8vIOKchSBFbiBQYW50YWxsYSBPTjogeU5vcm0gZXMgbGEgZnVlbnRlIGRlIHZlcmRhZCAoMC4uMSlcclxuICAgIGNvbnN0IHluID0gY2xhbXAwMShvYmo/LnlOb3JtKTtcclxuICAgIGlmICh5biAhPSBudWxsKSByZXR1cm4geW4gKiBBTFRVUkFfRURJVE9SX1BBTlRBTExBO1xyXG5cclxuICAgIC8vIGZhbGxiYWNrOiBzaSBubyBoYXkgeU5vcm0sIHVzYW1vcyB5IGNvbW8gXCJlZGl0b3IgcHhcIlxyXG4gICAgY29uc3QgeVB4ID0gTnVtYmVyKG9iaj8ueSk7XHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHlQeCkpIHJldHVybiB5UHg7XHJcblxyXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiB0b3BQYW50YWxsYUNTUyhvYmo6IGFueSwgeW5SYXc6IGFueSk6IHN0cmluZyB7XG4gICAgY29uc3QgeW4gPSBjbGFtcDAxKHluUmF3KSA/PyAwO1xuICAgIGNvbnN0IHluQ29tcGFjdGFkbyA9IGBjYWxjKDAuNSArICgoJHt5bn0pIC0gMC41KSAqICgxIC0gdmFyKC0tcGFudGFsbGEteS1jb21wYWN0LCAwKSkpYDtcbiAgICByZXR1cm4gYGNhbGMoXG4gICh2YXIoLS12aC1sb2dpY2FsKSAqICR7eW5Db21wYWN0YWRvfSlcbiAgKyAoJHtzQ29udGVuaWRvVmFyKG9iail9ICogdmFyKC0tcGFudGFsbGEteS1vZmZzZXQsICR7UEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWH1weCkpXG4pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiDinIUgdG9wQ1NTOlxuICAgKiAtIFBhbnRhbGxhIE9OOiB1c2EgdmFyKC0tdmgtbG9naWNhbCkgKiB5blxuICAgKiAtIFRleHRvIGVuIFBhbnRhbGxhIE9OOiBzdW1hIG9mZnNldCAoQ1NTIHZhcikgZXNjYWxhZG8gcG9yIHNDb250ZW5pZG9WYXJcbiAgICogLSBGaWpvOiBweFkob2JqLCB5KVxuICAgKi9cclxuICBmdW5jdGlvbiB0b3BDU1Mob2JqOiBhbnkpOiBzdHJpbmcge1xuICAgIGlmIChlc1NlY2Npb25QYW50YWxsYShvYmopKSB7XG4gICAgICBjb25zdCB5UHhFZGl0b3IgPSBnZXRZUHhFZGl0b3Iob2JqKTtcbiAgICAgIGNvbnN0IHluID0gY2xhbXAwMSh5UHhFZGl0b3IgLyBBTFRVUkFfRURJVE9SX1BBTlRBTExBKSA/PyAwO1xuICAgICAgcmV0dXJuIHRvcFBhbnRhbGxhQ1NTKG9iaiwgeW4pO1xuICAgIH1cblxuICAgIGNvbnN0IHkgPSBOdW1iZXIob2JqPy55IHx8IDApO1xuICAgIHJldHVybiBweFkob2JqLCB5KTtcbiAgfVxuXHJcbiAgLyoqXHJcbiAgICog4pyFIFZhcmlhbnRlIHBhcmEgY3VhbmRvIHlhIHRlbsOpcyB5UHggKGVuIFwicHggZWRpdG9yXCIpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdG9wQ1NTRnJvbVlQeChvYmo6IGFueSwgeVB4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmIChlc1NlY2Npb25QYW50YWxsYShvYmopKSB7XG4gICAgICBjb25zdCB5biA9IGNsYW1wMDEoeVB4IC8gQUxUVVJBX0VESVRPUl9QQU5UQUxMQSkgPz8gMDtcbiAgICAgIHJldHVybiB0b3BQYW50YWxsYUNTUyhvYmosIHluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHhZKG9iaiwgeVB4KTtcbiAgfVxuXHJcbiAgZnVuY3Rpb24gc3R5bGVQb3NCYXNlKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHggPSBOdW1iZXIob2JqPy54IHx8IDApO1xyXG5cclxuICAgIGNvbnN0IHJvdCA9IG9iaj8ucm90YXRpb24gPz8gMDtcclxuICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgIGNvbnN0IHpJbmRleCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LnpJbmRleCkgPyBvYmouekluZGV4IDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHJldHVybiBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCB4KX07XHJcbnRvcDogJHt0b3BDU1Mob2JqKX07XHJcbnRyYW5zZm9ybTogcm90YXRlKCR7cm90fWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcclxuJHt6SW5kZXggIT09IHVuZGVmaW5lZCA/IGB6LWluZGV4OiR7ekluZGV4fTtgIDogXCJcIn1cclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3R5bGVTaXplKG9iajogYW55LCB3PzogbnVtYmVyLCBoPzogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHd3ID0gTnVtYmVyLmlzRmluaXRlKHcpID8gKHcgYXMgbnVtYmVyKSA6IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGhoID0gTnVtYmVyLmlzRmluaXRlKGgpID8gKGggYXMgbnVtYmVyKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBbXTtcclxuICAgIGlmICh3dyAhPT0gdW5kZWZpbmVkKSBwYXJ0cy5wdXNoKGB3aWR0aDogJHtweFgob2JqLCB3dyl9O2ApO1xyXG4gICAgaWYgKGhoICE9PSB1bmRlZmluZWQpIHBhcnRzLnB1c2goYGhlaWdodDogJHtweFkob2JqLCBoaCl9O2ApO1xyXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcXG5cIik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW5kZXJJY29ub1N2Z051ZXZvSW5saW5lKG9iajogYW55KSB7XHJcbiAgICBjb25zdCB2aWV3Qm94ID0gb2JqLnZpZXdCb3ggfHwgXCIwIDAgMjQgMjRcIjtcclxuICAgIGNvbnN0IGNvbG9yID0gb2JqLmNvbG9yIHx8IFwiIzAwMFwiO1xyXG4gICAgY29uc3QgcGF0aHMgPSBBcnJheS5pc0FycmF5KG9iai5wYXRocykgPyBvYmoucGF0aHMgOiBbXTtcclxuICAgIGlmICghcGF0aHMubGVuZ3RoKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogMjQ7XHJcbiAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiAyNDtcclxuXHJcbiAgICBjb25zdCByb3QgPSBvYmo/LnJvdGF0aW9uID8/IDA7XHJcbiAgICBjb25zdCBzY2FsZVggPSBvYmo/LnNjYWxlWCA/PyAxO1xyXG4gICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICBjb25zdCB4ID0gTnVtYmVyKG9iaj8ueCB8fCAwKTtcclxuICAgIGNvbnN0IHlQeCA9IGdldFlQeEVkaXRvcihvYmopO1xyXG5cclxuICAgIGNvbnN0IHBhdGhzSHRtbCA9IHBhdGhzXHJcbiAgICAgIC5tYXAoKHA6IGFueSkgPT4gKHA/LmQgPyBgPHBhdGggZD1cIiR7ZXNjSFRNTChwLmQpfVwiIGZpbGw9XCIke2VzY0hUTUwoY29sb3IpfVwiPjwvcGF0aD5gIDogXCJcIikpXHJcbiAgICAgIC5qb2luKFwiXCIpO1xyXG5cclxuICAgIGNvbnN0IHN0eWxlID0gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgeCl9O1xyXG50b3A6ICR7dG9wQ1NTRnJvbVlQeChvYmosIHlQeCl9O1xyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbnRyYW5zZm9ybTogcm90YXRlKCR7cm90fWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgIHJldHVybiBgPHN2ZyBjbGFzcz1cIm9iamV0b1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiJHtlc2NIVE1MKFxyXG4gICAgICB2aWV3Qm94XHJcbiAgICApfVwiIHN0eWxlPVwiJHtzdHlsZX1cIj4ke3BhdGhzSHRtbH08L3N2Zz5gO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iamV0b3NcclxuICAgIC5tYXAoKG9iaikgPT4ge1xyXG4gICAgICBjb25zdCB0aXBvID0gb2JqPy50aXBvO1xyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBURVhUTyAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcInRleHRvXCIpIHtcclxuICAgICAgICBjb25zdCBhbGlnbiA9IFN0cmluZyhvYmouYWxpZ24gfHwgb2JqLnRleHRBbGlnbiB8fCBcImxlZnRcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IG9iai5jb2xvclRleHRvIHx8IG9iai5jb2xvciB8fCBvYmouZmlsbCB8fCBcIiMwMDBcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZUxpbmVIZWlnaHQgPVxyXG4gICAgICAgICAgdHlwZW9mIG9iai5saW5lSGVpZ2h0ID09PSBcIm51bWJlclwiICYmIG9iai5saW5lSGVpZ2h0ID4gMCA/IG9iai5saW5lSGVpZ2h0IDogMS4yO1xyXG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHRGaW5hbCA9IGJhc2VMaW5lSGVpZ2h0ICogMC45MjtcclxuXHJcbiAgICAgICAgY29uc3Qgc2FmZVRleHRvID0gZXNjSFRNTChvYmoudGV4dG8gfHwgXCJcIik7XHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcblxyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgZnMgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5mb250U2l6ZSkgPyBvYmouZm9udFNpemUgOiAyNDtcclxuXHJcbiAgICAgICAgLy8g4pqg77iPIHRleHRvIGZ1bGxCbGVlZCBOTyBoYWNlIGZpdCA9PiBlc2NhbGEgY29uIHZhcigtLXN4KVxyXG4gICAgICAgIGNvbnN0IHNGb250ID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdCA9IG9iaj8ucm90YXRpb24gPz8gMDtcclxuICAgICAgICBjb25zdCBzY2FsZVggPSBvYmo/LnNjYWxlWCA/PyAxO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9XHJcbiAgICAgICAgICBhbGlnbiA9PT0gXCJjZW50ZXJcIiA/IFwidG9wIGNlbnRlclwiIDpcclxuICAgICAgICAgICAgKGFsaWduID09PSBcInJpZ2h0XCIgPyBcInRvcCByaWdodFwiIDogXCJ0b3AgbGVmdFwiKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXG4ke2Jhc2VTdHlsZX1cbi8qIOKchSBtYW50ZW5lciBnZW9tZXRyw61hIGVzdGFibGUgeSBlc2NhbGFyIHRpcG9ncmFmw61hIHBvciBmb250LXNpemUgKG5vIHBvciB0cmFuc2Zvcm0pLiAqL1xudHJhbnNmb3JtLW9yaWdpbjogJHtvcmlnaW59O1xudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XG4ke3cgIT09IHVuZGVmaW5lZCA/IGB3aWR0aDogJHtweFgob2JqLCB3KX07YCA6IFwiXCJ9XG5mb250LXNpemU6IGNhbGMoJHtzRm9udH0gKiAke2ZzfXB4ICogdmFyKC0tdGV4dC16b29tLCAxKSk7XG5mb250LWZhbWlseTogJHtvYmouZm9udEZhbWlseSB8fCBcInNhbnMtc2VyaWZcIn07XG5mb250LXdlaWdodDogJHtvYmouZm9udFdlaWdodCB8fCBcIm5vcm1hbFwifTtcbmZvbnQtc3R5bGU6ICR7b2JqLmZvbnRTdHlsZSB8fCBcIm5vcm1hbFwifTtcbnRleHQtZGVjb3JhdGlvbjogJHtvYmoudGV4dERlY29yYXRpb24gfHwgXCJub25lXCJ9O1xyXG5jb2xvcjogJHtjb2xvcn07XHJcbnRleHQtYWxpZ246ICR7YWxpZ259O1xyXG53aGl0ZS1zcGFjZTogcHJlLXdyYXA7XHJcbmxpbmUtaGVpZ2h0OiAke2xpbmVIZWlnaHRGaW5hbH07XHJcbnBhZGRpbmc6IDA7XHJcbm1hcmdpbjogMDtcclxuYm94LXNpemluZzogY29udGVudC1ib3g7XHJcbiR7b2JqLnN0cm9rZSAmJiBvYmouc3Ryb2tlV2lkdGggPiAwXHJcbiAgICAgICAgICAgID8gYC13ZWJraXQtdGV4dC1zdHJva2U6ICR7b2JqLnN0cm9rZVdpZHRofXB4ICR7b2JqLnN0cm9rZX07YFxyXG4gICAgICAgICAgICA6IFwiXCJcclxuICAgICAgICAgIH1cclxuJHtvYmouc2hhZG93Q29sb3JcclxuICAgICAgICAgICAgPyBgdGV4dC1zaGFkb3c6ICR7b2JqLnNoYWRvd09mZnNldFggfHwgMH1weCAke29iai5zaGFkb3dPZmZzZXRZIHx8IDB9cHggJHtvYmouc2hhZG93Qmx1ciB8fCAwfXB4ICR7b2JqLnNoYWRvd0NvbG9yfTtgXHJcbiAgICAgICAgICAgIDogXCJ0ZXh0LXNoYWRvdzogbm9uZTtcIlxyXG4gICAgICAgICAgfVxyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoXHJcbiAgICAgICAgICBgPGRpdiBjbGFzcz1cIm9iamV0b1wiIGRhdGEtZGVidWctdGV4dG89XCIxXCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7c2FmZVRleHRvfTwvZGl2PmAsXHJcbiAgICAgICAgICBvYmpcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBJTUFHRU4gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJpbWFnZW5cIikge1xyXG4gICAgICAgIGNvbnN0IHNyYyA9IG9iai5zcmMgfHwgb2JqLnVybCB8fCBcIlwiO1xyXG4gICAgICAgIGlmICghc3JjKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHtzdHlsZVNpemUob2JqLCB3LCBoKX1cclxub2JqZWN0LWZpdDogY29udGFpbjtcclxuZGlzcGxheTogYmxvY2s7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGltZyBjbGFzcz1cIm9iamV0b1wiIHNyYz1cIiR7ZXNjYXBlQXR0cihzcmMpfVwiIHN0eWxlPVwiJHtzdHlsZX1cIiAvPmAsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gSUNPTk8gKG51ZXZvKSAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImljb25vXCIpIHtcclxuICAgICAgICBpZiAob2JqLmZvcm1hdG8gPT09IFwic3ZnXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHN2Z0h0bWwgPSByZW5kZXJJY29ub1N2Z051ZXZvSW5saW5lKG9iaik7XHJcbiAgICAgICAgICBpZiAoIXN2Z0h0bWwpIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2Uoc3ZnSHRtbCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNyYyA9IG9iai51cmwgfHwgb2JqLnNyYyB8fCBcIlwiO1xyXG4gICAgICAgIGlmICghc3JjKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHtzdHlsZVNpemUob2JqLCB3LCBoKX1cclxub2JqZWN0LWZpdDogY29udGFpbjtcclxuZGlzcGxheTogYmxvY2s7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGltZyBjbGFzcz1cIm9iamV0b1wiIHNyYz1cIiR7ZXNjYXBlQXR0cihzcmMpfVwiIHN0eWxlPVwiJHtzdHlsZX1cIiAvPmAsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gSUNPTk8gTEVHQUNZIChpY29uby1zdmcpIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiaWNvbm8tc3ZnXCIgJiYgb2JqLmQpIHtcclxuICAgICAgICBjb25zdCB2YiA9IG9iai52aWV3Qm94IHx8IFwiMCAwIDEwMCAxMDBcIjtcclxuICAgICAgICBjb25zdCBmaWxsID0gb2JqLmNvbG9yIHx8IFwiIzAwMFwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogMTAwO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IDEwMDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbmZpbGw6ICR7ZXNjYXBlQXR0cihmaWxsKX07XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBgPHN2ZyBjbGFzcz1cIm9iamV0b1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiJHtlc2NhcGVBdHRyKFxyXG4gICAgICAgICAgdmJcclxuICAgICAgICApfVwiIHN0eWxlPVwiJHtzdHlsZX1cIj48cGF0aCBkPVwiJHtlc2NIVE1MKG9iai5kKX1cIiAvPjwvc3ZnPmA7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKHN2Zywgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBDT1VOVERPV04gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElTTyA9IG9iai50YXJnZXRJU08gfHwgb2JqLmZlY2hhT2JqZXRpdm8gfHwgb2JqLmZlY2hhSVNPIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHRDb2xvciA9IG9iai5jb2xvclRleHRvID8/IG9iai5jb2xvciA/PyBcIiMxMTFcIjtcclxuICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHkgfHwgXCJJbnRlciwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXNldCA9IG9iai5wcmVzZXRJZCB8fCBvYmoubGF5b3V0IHx8IFwicGlsbHNcIjtcclxuICAgICAgICBjb25zdCBpc01pbmltYWwgPSBTdHJpbmcocHJlc2V0KS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibWluaW1hbFwiKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIGFuY2hvL2FsdG8gZGVsIG9iamV0byAoc2kgZXhpc3RlbilcclxuICAgICAgICBjb25zdCB3T2JqID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gTnVtYmVyKG9iai53aWR0aCkgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGhPYmogPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gTnVtYmVyKG9iai5oZWlnaHQpIDogbnVsbDtcclxuXHJcbiAgICAgICAgLy8g4pyFIGdhcDogc2kgdmllbmUgZGUgS29udmEsIHJlc3BldGFybG9cclxuICAgICAgICBjb25zdCBnYXAgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmdhcClcclxuICAgICAgICAgID8gTnVtYmVyKG9iai5nYXApXHJcbiAgICAgICAgICA6IE51bWJlci5pc0Zpbml0ZShvYmouc3BhY2luZylcclxuICAgICAgICAgICAgPyBOdW1iZXIob2JqLnNwYWNpbmcpXHJcbiAgICAgICAgICAgIDogODtcclxuXHJcbiAgICAgICAgLy8g4pyFIFNpIHR1IEtvbnZhIGd1YXJkYSBjaGlwV2lkdGggLyBwYWRkaW5nWCwgcmVzcGV0YWxvc1xyXG4gICAgICAgIC8vIGNoaXBXaWR0aDogYW5jaG8gaW50ZXJubyBkZWwgdGV4dG8gKHNpbiBwYWRkaW5nKVxyXG4gICAgICAgIGNvbnN0IGNoaXBXaWR0aFByb3AgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmNoaXBXaWR0aCkgPyBOdW1iZXIob2JqLmNoaXBXaWR0aCkgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IHBhZGRpbmdYUHJvcCA9IE51bWJlci5pc0Zpbml0ZShvYmoucGFkZGluZ1gpID8gTnVtYmVyKG9iai5wYWRkaW5nWCkgOiBudWxsO1xyXG5cclxuICAgICAgICAvLyDinIUgRGVyaXZhY2nDs24gcmHDrXogKGN1YW5kbyBubyBoYXkgcHJvcHMpXHJcbiAgICAgICAgY29uc3QgbiA9IDQ7XHJcblxyXG4gICAgICAgIC8vIGNoaXBXVG90YWw6IGFuY2hvIHRvdGFsIGRlIGNhZGEgY2hpcCAoaW5jbHV5ZSBwYWRkaW5nKVxyXG4gICAgICAgIGxldCBjaGlwV1RvdGFsID0gNTY7IC8vIGZhbGxiYWNrIHJhem9uYWJsZVxyXG4gICAgICAgIGlmICh3T2JqICYmIHdPYmogPiAwKSB7XHJcbiAgICAgICAgICBjaGlwV1RvdGFsID0gTWF0aC5tYXgoNDAsICh3T2JqIC0gZ2FwICogKG4gLSAxKSkgLyBuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBhZGRpbmdYIGRlcml2YWRvIGRlbCBjaGlwV1RvdGFsIChzaSBubyB2aW5vKVxyXG4gICAgICAgIGNvbnN0IHBhZGRpbmdYID0gcGFkZGluZ1hQcm9wID8/IE1hdGgubWF4KDYsIE1hdGgucm91bmQoY2hpcFdUb3RhbCAqIDAuMTgpKTsgLy8gfjE4JVxyXG4gICAgICAgIGNvbnN0IHBhZGRpbmdZID0gTWF0aC5tYXgoNSwgTWF0aC5yb3VuZChwYWRkaW5nWCAqIDAuNjUpKTtcclxuXHJcbiAgICAgICAgLy8gY2hpcFdpZHRoICh0ZXh0bykgZGVyaXZhZG8gc2kgbm8gdmlub1xyXG4gICAgICAgIGNvbnN0IGNoaXBXaWR0aCA9IGNoaXBXaWR0aFByb3AgPz8gTWF0aC5tYXgoMTAsIE1hdGgucm91bmQoY2hpcFdUb3RhbCAtIHBhZGRpbmdYICogMikpO1xyXG5cclxuICAgICAgICAvLyDinIUgZm9udCBzaXplczogc2kgdmllbmVuLCByZXNwZXRhcjsgc2kgbm8sIGRlcml2YXIgZGVzZGUgY2hpcFdUb3RhbFxyXG4gICAgICAgIGNvbnN0IHZhbHVlU2l6ZSA9XHJcbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2JqLmZvbnRTaXplKSA/IE51bWJlcihvYmouZm9udFNpemUpIDogTWF0aC5tYXgoMTQsIE1hdGgucm91bmQoY2hpcFdUb3RhbCAqIDAuMzQpKTtcclxuICAgICAgICBjb25zdCBsYWJlbFNpemUgPVxyXG4gICAgICAgICAgTnVtYmVyLmlzRmluaXRlKG9iai5sYWJlbFNpemUpID8gTnVtYmVyKG9iai5sYWJlbFNpemUpIDogTWF0aC5tYXgoOSwgTWF0aC5yb3VuZCh2YWx1ZVNpemUgKiAwLjYyKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsQ29sb3IgPSBvYmoubGFiZWxDb2xvciA/PyBcIiM2YjcyODBcIjtcclxuICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKG9iai5mb250V2VpZ2h0KSA/IG9iai5mb250V2VpZ2h0IDogNzAwO1xyXG4gICAgICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmxldHRlclNwYWNpbmcpID8gb2JqLmxldHRlclNwYWNpbmcgOiAwO1xyXG5cclxuICAgICAgICAvLyDinIUgZXN0aWxvcyBkZSBjaGlwXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyQmdGaW5hbCA9IFwidHJhbnNwYXJlbnRcIjtcclxuICAgICAgICBjb25zdCBjaGlwQmdGaW5hbCA9IGlzTWluaW1hbCA/IFwidHJhbnNwYXJlbnRcIiA6IG9iai5jaGlwQmFja2dyb3VuZCA/PyBvYmouYm94QmcgPz8gXCJyZ2JhKDI1NSwyNTUsMjU1LC43NSlcIjtcclxuICAgICAgICBjb25zdCBjaGlwQm9yZGVyQ29sb3JGaW5hbCA9IGlzTWluaW1hbCA/IFwidHJhbnNwYXJlbnRcIiA6IG9iai5jaGlwQm9yZGVyID8/IG9iai5ib3hCb3JkZXIgPz8gXCJyZ2JhKDAsMCwwLC4wOClcIjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKG9iai5ib3hSYWRpdXMpXHJcbiAgICAgICAgICA/IG9iai5ib3hSYWRpdXNcclxuICAgICAgICAgIDogTnVtYmVyLmlzRmluaXRlKG9iai5yYWRpdXMpXHJcbiAgICAgICAgICAgID8gb2JqLnJhZGl1c1xyXG4gICAgICAgICAgICA6IDEwO1xyXG5cclxuICAgICAgICBjb25zdCBjaGlwUmFkaXVzRmluYWwgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmNoaXBSYWRpdXMpID8gb2JqLmNoaXBSYWRpdXMgOiBjb250YWluZXJSYWRpdXM7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG5cclxuICAgICAgICAvLyDinIUgRXNjYWxhIGNvcnJlY3RhIChyZXNwZXRhIHBhbnRhbGxhIHkgYmxlZWQpXHJcbiAgICAgICAgY29uc3Qgc0NoaXAgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3dPYmogPyBgd2lkdGg6ICR7cHhYKG9iaiwgd09iail9O2AgOiBcIlwifVxyXG4ke2hPYmogPyBgaGVpZ2h0OiAke3B4WShvYmosIGhPYmopfTtgIDogXCJcIn1cclxuZGlzcGxheTogZmxleDtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbmdhcDogY2FsYygke3NDaGlwfSAqICR7Z2FwfXB4KTtcclxuZm9udC1mYW1pbHk6ICR7Zm9udEZhbWlseX07XHJcbmNvbG9yOiAke3RleHRDb2xvcn07XHJcbmJhY2tncm91bmQ6ICR7Y29udGFpbmVyQmdGaW5hbH07XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzQ2hpcH0gKiAke2NvbnRhaW5lclJhZGl1c31weCk7XHJcbmxldHRlci1zcGFjaW5nOiBjYWxjKCR7c0NoaXB9ICogJHtsZXR0ZXJTcGFjaW5nfXB4KTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNoaXBTdHlsZSA9IGBcclxud2lkdGg6IGNhbGMoJHtzQ2hpcH0gKiAke01hdGgucm91bmQoY2hpcFdUb3RhbCl9cHgpO1xyXG5wYWRkaW5nOiBjYWxjKCR7c0NoaXB9ICogJHtwYWRkaW5nWX1weCkgY2FsYygke3NDaGlwfSAqICR7cGFkZGluZ1h9cHgpO1xyXG5ib3JkZXI6ICR7aXNNaW5pbWFsID8gXCIwXCIgOiBgY2FsYygke3NDaGlwfSAqIDFweCkgc29saWQgJHtjaGlwQm9yZGVyQ29sb3JGaW5hbH1gfTtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NDaGlwfSAqICR7Y2hpcFJhZGl1c0ZpbmFsfXB4KTtcclxuZGlzcGxheTogZmxleDtcclxuZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbmJhY2tncm91bmQ6ICR7Y2hpcEJnRmluYWx9O1xyXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFsdWVTdHlsZSA9IGBcclxuZm9udC13ZWlnaHQ6ICR7Zm9udFdlaWdodH07XHJcbmZvbnQtc2l6ZTogY2FsYygke3NDaGlwfSAqICR7dmFsdWVTaXplfXB4KTtcclxubGluZS1oZWlnaHQ6IDE7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFN0eWxlID0gYFxyXG5mb250LXNpemU6IGNhbGMoJHtzQ2hpcH0gKiAke2xhYmVsU2l6ZX1weCk7XHJcbmNvbG9yOiAke2xhYmVsQ29sb3J9O1xyXG5saW5lLWhlaWdodDogMS4wNTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3dMYWJlbHMgPSBvYmouc2hvd0xhYmVscyAhPT0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gb2JqLmxhYmVscyA/PyB7IGRpYXM6IFwiRMOtYXNcIiwgaG9yYXM6IFwiSG9yYXNcIiwgbWluOiBcIk1pblwiLCBzZWc6IFwiU2VnXCIgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaHRtbENvdW50ZG93biA9IGBcbjxkaXYgY2xhc3M9XCJvYmpldG9cIlxuICBkYXRhLW1vYmlsZS1jbHVzdGVyPVwiaXNvbGF0ZWRcIlxuICBkYXRhLW1vYmlsZS1jZW50ZXI9XCJmb3JjZVwiXG4gIGRhdGEtY291bnRkb3duXHJcbiAgZGF0YS10YXJnZXQ9XCIke2VzY2FwZUF0dHIodGFyZ2V0SVNPKX1cIlxyXG4gIGRhdGEtcHJlc2V0PVwiJHtlc2NhcGVBdHRyKFxyXG4gICAgICAgICAgcHJlc2V0XHJcbiAgICAgICAgKX1cIiBzdHlsZT1cIiR7Y29udGFpbmVyU3R5bGV9XCI+XHJcbiAgPGRpdiBjbGFzcz1cImNkLWNoaXBcIiBzdHlsZT1cIiR7Y2hpcFN0eWxlfVwiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJjZC12YWxcIiBzdHlsZT1cIiR7dmFsdWVTdHlsZX1cIj4wMDwvc3Bhbj5cclxuICAgICR7c2hvd0xhYmVscyA/IGA8c3BhbiBjbGFzcz1cImNkLWxhYlwiIHN0eWxlPVwiJHtsYWJlbFN0eWxlfVwiPiR7ZXNjYXBlQXR0cihsYWJlbHMuZGlhcyl9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLmhvcmFzKX08L3NwYW4+YCA6IFwiXCJ9XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImNkLWNoaXBcIiBzdHlsZT1cIiR7Y2hpcFN0eWxlfVwiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJjZC12YWxcIiBzdHlsZT1cIiR7dmFsdWVTdHlsZX1cIj4wMDwvc3Bhbj5cclxuICAgICR7c2hvd0xhYmVscyA/IGA8c3BhbiBjbGFzcz1cImNkLWxhYlwiIHN0eWxlPVwiJHtsYWJlbFN0eWxlfVwiPiR7ZXNjYXBlQXR0cihsYWJlbHMubWluKX08L3NwYW4+YCA6IFwiXCJ9XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImNkLWNoaXBcIiBzdHlsZT1cIiR7Y2hpcFN0eWxlfVwiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJjZC12YWxcIiBzdHlsZT1cIiR7dmFsdWVTdHlsZX1cIj4wMDwvc3Bhbj5cclxuICAgICR7c2hvd0xhYmVscyA/IGA8c3BhbiBjbGFzcz1cImNkLWxhYlwiIHN0eWxlPVwiJHtsYWJlbFN0eWxlfVwiPiR7ZXNjYXBlQXR0cihsYWJlbHMuc2VnKX08L3NwYW4+YCA6IFwiXCJ9XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxuYC50cmltKCk7XG4gICAgICAgIHJldHVybiBhcHBlbmRNb3Rpb25EYXRhQXR0cnMoaHRtbENvdW50ZG93biwgb2JqKTtcbiAgICAgIH1cblxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBHQUxFUsONQSAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImdhbGVyaWFcIikge1xyXG4gICAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLm1heCgxLCBwYXJzZUludChvYmoucm93cyB8fCAxLCAxMCkpO1xyXG4gICAgICAgIGNvbnN0IGNvbHMgPSBNYXRoLm1heCgxLCBwYXJzZUludChvYmouY29scyB8fCAxLCAxMCkpO1xyXG4gICAgICAgIGNvbnN0IGdhcFB4ID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQob2JqLmdhcCB8fCAwLCAxMCkpO1xyXG4gICAgICAgIGNvbnN0IHJhZGl1c1B4ID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQob2JqLnJhZGl1cyB8fCAwLCAxMCkpO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgc0dyaWQgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGVDb250ZW5lZG9yID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHtzdHlsZVNpemUob2JqLCB3LCBoKX1cclxuZGlzcGxheTogZ3JpZDtcclxuZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoJHtjb2xzfSwgMWZyKTtcclxuZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoJHtyb3dzfSwgMWZyKTtcclxuZ2FwOiBjYWxjKCR7c0dyaWR9ICogJHtnYXBQeH1weCk7XHJcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCB0b3RhbCA9IHJvd3MgKiBjb2xzO1xyXG4gICAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdG90YWwgfSwgKF8sIGkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGMgPSAob2JqLmNlbGxzICYmIG9iai5jZWxsc1tpXSkgfHwge307XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtZWRpYVVybDogYy5tZWRpYVVybCB8fCBcIlwiLFxyXG4gICAgICAgICAgICBmaXQ6IGMuZml0ID09PSBcImNvbnRhaW5cIiA/IFwiY29udGFpblwiIDogXCJjb3ZlclwiLFxyXG4gICAgICAgICAgICBiZzogYy5iZyB8fCBcIiNmM2Y0ZjZcIixcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWxDZWxkYXMgPSBjZWxsc1xyXG4gICAgICAgICAgLm1hcCgoY2VsbCwgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhZmVTcmMgPSBlc2NhcGVBdHRyKGNlbGwubWVkaWFVcmwgfHwgXCJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGRhU3R5bGUgPSBgXHJcbnBvc2l0aW9uOiByZWxhdGl2ZTtcclxud2lkdGg6IDEwMCU7XHJcbmhlaWdodDogMTAwJTtcclxub3ZlcmZsb3c6IGhpZGRlbjtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NHcmlkfSAqICR7cmFkaXVzUHh9cHgpO1xyXG5iYWNrZ3JvdW5kOiAke2NlbGwuYmd9O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2FmZVNyYykge1xuICAgICAgICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJnYWxlcmlhLWNlbGRhXCIgZGF0YS1pbmRleD1cIiR7aWR4fVwiIHN0eWxlPVwiJHtjZWxkYVN0eWxlfVwiPjwvZGl2PmA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBgXG48ZGl2IGNsYXNzPVwiZ2FsZXJpYS1jZWxkYSBnYWxlcmlhLWNlbGRhLS1jbGlja2FibGVcIlxuICAgICBkYXRhLWluZGV4PVwiJHtpZHh9XCJcbiAgICAgZGF0YS1nYWxsZXJ5LWltYWdlPVwiMVwiXG4gICAgIHJvbGU9XCJidXR0b25cIlxuICAgICB0YWJpbmRleD1cIjBcIlxuICAgICBhcmlhLWxhYmVsPVwiVmVyIGltYWdlbiBlbiBwYW50YWxsYSBjb21wbGV0YVwiXG4gICAgIHN0eWxlPVwiJHtjZWxkYVN0eWxlfVwiPlxuICA8aW1nIHNyYz1cIiR7c2FmZVNyY31cIiBhbHQ9XCJcIiBsb2FkaW5nPVwibGF6eVwiIGRlY29kaW5nPVwiYXN5bmNcIlxuICAgICAgIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvYmplY3QtZml0OiR7Y2VsbC5maXR9O2Rpc3BsYXk6YmxvY2s7XCIgLz5cbjwvZGl2PlxuYC50cmltKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuam9pbihcIlwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaHRtbEdhbGVyaWEgPSBgPGRpdiBjbGFzcz1cIm9iamV0byBnYWxlcmlhXCIgc3R5bGU9XCIke3N0eWxlQ29udGVuZWRvcn1cIj4ke2h0bWxDZWxkYXN9PC9kaXY+YDtcclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShodG1sR2FsZXJpYSwgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBSU1ZQIEJPVMOTTiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcInJzdnAtYm90b25cIikge1xyXG4gICAgICAgIGNvbnN0IHRleHRvID0gZXNjYXBlSFRNTChvYmoudGV4dG8gfHwgXCJDb25maXJtYXIgYXNpc3RlbmNpYVwiKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uYW5jaG8pID8gb2JqLmFuY2hvIDogMjAwO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5hbHRvKSA/IG9iai5hbHRvIDogNTA7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gb2JqLmNvbG9yIHx8IFwiIzc3M2RiZVwiO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yVGV4dG8gPSBvYmouY29sb3JUZXh0byB8fCBcIiNmZmZmZmZcIjtcclxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmZvbnRTaXplKSA/IG9iai5mb250U2l6ZSA6IDE4O1xyXG4gICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseSB8fCBcInNhbnMtc2VyaWZcIjtcclxuICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gb2JqLmZvbnRXZWlnaHQgfHwgXCJib2xkXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFN0eWxlID0gb2JqLmZvbnRTdHlsZSB8fCBcIm5vcm1hbFwiO1xyXG4gICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9uID0gb2JqLnRleHREZWNvcmF0aW9uIHx8IFwibm9uZVwiO1xyXG4gICAgICAgIGNvbnN0IGFsaWduID0gb2JqLmFsaWduIHx8IFwiY2VudGVyXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG5cclxuICAgICAgICAvLyBSU1ZQIChjb250ZW5pZG8pOiBzaSBlc3TDoSBlbiBwYW50YWxsYSwgZml0dGVhIChzQ29udGVuaWRvVmFyKVxyXG4gICAgICAgIGNvbnN0IHNCdG4gPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbmJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9O1xyXG5jb2xvcjogJHtjb2xvclRleHRvfTtcclxuZm9udC1zaXplOiBjYWxjKCR7c0J0bn0gKiAke2ZvbnRTaXplfXB4KTtcclxuZm9udC1mYW1pbHk6ICR7Zm9udEZhbWlseX07XHJcbmZvbnQtd2VpZ2h0OiAke2ZvbnRXZWlnaHR9O1xyXG5mb250LXN0eWxlOiAke2ZvbnRTdHlsZX07XHJcbnRleHQtZGVjb3JhdGlvbjogJHt0ZXh0RGVjb3JhdGlvbn07XHJcbnRleHQtYWxpZ246ICR7YWxpZ259O1xyXG5kaXNwbGF5OiBmbGV4O1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NCdG59ICogOHB4KTtcclxuY3Vyc29yOiBwb2ludGVyO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgaHRtbFJzdnAgPSBgXG48ZGl2IGNsYXNzPVwib2JqZXRvIGlzLWludGVyYWN0aXZlIHJzdnAtYm90b25cIlxuICBpZD1cImFicmlyTW9kYWxSU1ZQXCJcbiAgZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJcbiAgZGF0YS1yc3ZwLW9wZW5cclxuICByb2xlPVwiYnV0dG9uXCJcclxuICB0YWJpbmRleD1cIjBcIlxyXG4gIGFyaWEtbGFiZWw9XCJDb25maXJtYXIgYXNpc3RlbmNpYVwiXHJcbiAgc3R5bGU9XCIke3N0eWxlfVwiPlxyXG4gICR7dGV4dG99XG48L2Rpdj5cbmAudHJpbSgpO1xuICAgICAgICByZXR1cm4gYXBwZW5kTW90aW9uRGF0YUF0dHJzKGh0bWxSc3ZwLCBvYmopO1xuICAgICAgfVxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gRk9STUFTIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiZm9ybWFcIikge1xyXG4gICAgICAgIGNvbnN0IGZpbGwgPSBvYmouY29sb3IgfHwgXCIjMDAwXCI7XHJcbiAgICAgICAgY29uc3QgZmlndXJhID0gb2JqLmZpZ3VyYTtcclxuXHJcbiAgICAgICAgaWYgKGZpZ3VyYSA9PT0gXCJyZWN0XCIpIHtcclxuICAgICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiAxMDA7XHJcbiAgICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiAxMDA7XHJcbiAgICAgICAgICBjb25zdCBjb3JuZXJSYWRpdXMgPSBvYmouY29ybmVyUmFkaXVzIHx8IDA7XHJcblxyXG4gICAgICAgICAgY29uc3QgZm9udFNpemUgPSBvYmouZm9udFNpemUgfHwgMjQ7XHJcbiAgICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHkgfHwgXCJzYW5zLXNlcmlmXCI7XHJcbiAgICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gb2JqLmZvbnRXZWlnaHQgfHwgXCJub3JtYWxcIjtcclxuICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IG9iai5mb250U3R5bGUgfHwgXCJub3JtYWxcIjtcclxuICAgICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9uID0gb2JqLnRleHREZWNvcmF0aW9uIHx8IFwibm9uZVwiO1xyXG4gICAgICAgICAgY29uc3QgYWxpZ24gPSBvYmouYWxpZ24gfHwgXCJjZW50ZXJcIjtcclxuICAgICAgICAgIGNvbnN0IGNvbG9yVGV4dG8gPSBvYmouY29sb3JUZXh0byB8fCBcIiMwMDAwMDBcIjtcclxuICAgICAgICAgIGNvbnN0IHRleHRvID0gZXNjSFRNTChvYmoudGV4dG8gfHwgXCJcIik7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgICBjb25zdCBzUmVjdFRleHQgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NSZWN0VGV4dH0gKiAke2Nvcm5lclJhZGl1c31weCk7XHJcbmRpc3BsYXk6IGZsZXg7XHJcbmFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbmp1c3RpZnktY29udGVudDogJHthbGlnbiA9PT0gXCJsZWZ0XCIgPyBcImZsZXgtc3RhcnRcIiA6IGFsaWduID09PSBcInJpZ2h0XCIgPyBcImZsZXgtZW5kXCIgOiBcImNlbnRlclwiXHJcbiAgICAgICAgICAgIH07XHJcbnRleHQtYWxpZ246ICR7YWxpZ259O1xyXG5wYWRkaW5nOiBjYWxjKCR7c1JlY3RUZXh0fSAqIDRweCk7XHJcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGlubmVyID0gYFxyXG48ZGl2IHN0eWxlPVwiXHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgZm9udC1zaXplOiBjYWxjKCR7c1JlY3RUZXh0fSAqICR7Zm9udFNpemV9cHgpO1xyXG4gIGZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xyXG4gIGZvbnQtd2VpZ2h0OiAke2ZvbnRXZWlnaHR9O1xyXG4gIGZvbnQtc3R5bGU6ICR7Zm9udFN0eWxlfTtcclxuICB0ZXh0LWRlY29yYXRpb246ICR7dGV4dERlY29yYXRpb259O1xyXG4gIGNvbG9yOiAke2NvbG9yVGV4dG99O1xyXG4gIGxpbmUtaGVpZ2h0OiAxLjI7XHJcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xyXG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XHJcblwiPiR7dGV4dG99PC9kaXY+XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7aW5uZXJ9PC9kaXY+YCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwiY2lyY2xlXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LnJhZGl1cykgPyBvYmoucmFkaXVzIDogNTA7XHJcbiAgICAgICAgICBjb25zdCBkaWFtZXRlciA9IHJhZGl1cyAqIDI7XHJcblxyXG4gICAgICAgICAgY29uc3QgeCA9IE51bWJlcihvYmo/LnggfHwgMCkgLSByYWRpdXM7XHJcbiAgICAgICAgICBjb25zdCB5UHhDZW50ZXIgPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHlQeFRvcExlZnQgPSB5UHhDZW50ZXIgLSByYWRpdXM7XHJcblxyXG4gICAgICAgICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCB4KX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgeVB4VG9wTGVmdCl9O1xyXG53aWR0aDogJHtweFgob2JqLCBkaWFtZXRlcil9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgZGlhbWV0ZXIpfTtcclxuYm9yZGVyLXJhZGl1czogNTAlO1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgc3R5bGU9XCIke3N0eWxlfVwiPjwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcImxpbmVcIikge1xyXG4gICAgICAgICAgY29uc3QgcG9pbnRzID0gb2JqLnBvaW50cyB8fCBbMCwgMCwgTElORV9DT05TVEFOVFMuREVGQVVMVF9MRU5HVEgsIDBdO1xyXG4gICAgICAgICAgY29uc3QgeDEgPSBwYXJzZUZsb2F0KHBvaW50c1swXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHkxID0gcGFyc2VGbG9hdChwb2ludHNbMV0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCB4MiA9IHBhcnNlRmxvYXQocG9pbnRzWzJdKSB8fCBMSU5FX0NPTlNUQU5UUy5ERUZBVUxUX0xFTkdUSDtcclxuICAgICAgICAgIGNvbnN0IHkyID0gcGFyc2VGbG9hdChwb2ludHNbM10pIHx8IDA7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvYmouc3Ryb2tlV2lkdGggfHwgTElORV9DT05TVEFOVFMuU1RST0tFX1dJRFRIO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHgyIC0geDE7XHJcbiAgICAgICAgICBjb25zdCBkZWx0YVkgPSB5MiAtIHkxO1xyXG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XHJcbiAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpICogKDE4MCAvIE1hdGguUEkpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IE51bWJlcihvYmo/LnggfHwgMCkgKyB4MTtcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlWSA9IGdldFlQeEVkaXRvcihvYmopO1xyXG4gICAgICAgICAgY29uc3Qgc3RhcnRZID0gYmFzZVkgKyB5MTtcclxuXHJcbiAgICAgICAgICBjb25zdCB0b3RhbFJvdGF0aW9uID0gYW5nbGUgKyAob2JqLnJvdGF0aW9uIHx8IDApO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgICAgICAgLy8gYWx0byBkZSBsw61uZWE6IHVzYW1vcyBlc2NhbGEgWSBkZWwgb2JqZXRvIChjb250ZW5pZG86IHNmaW5hbC9zeCwgYmxlZWQ6IHN4KVxyXG4gICAgICAgICAgY29uc3QgbGluZUggPSBgY2FsYygke3NZKG9iail9ICogJHtzdHJva2VXaWR0aH1weClgO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgc3RhcnRYKX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgc3RhcnRZKX07XHJcbndpZHRoOiAke3B4WChvYmosIGxlbmd0aCl9O1xyXG5oZWlnaHQ6ICR7bGluZUh9O1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3RvdGFsUm90YXRpb259ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IDAgNTAlO1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxkaXYgY2xhc3M9XCJvYmpldG8gbGluZWFcIiBzdHlsZT1cIiR7c3R5bGV9XCI+PC9kaXY+YCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwidHJpYW5nbGVcIikge1xyXG4gICAgICAgICAgY29uc3QgcmFkaXVzID0gb2JqLnJhZGl1cyB8fCA2MDtcclxuXHJcbiAgICAgICAgICBjb25zdCBzaW42MCA9IE1hdGguc3FydCgzKSAvIDI7XHJcbiAgICAgICAgICBjb25zdCBjb3M2MCA9IDAuNTtcclxuXHJcbiAgICAgICAgICBjb25zdCB0cmlhbmdsZVdpZHRoID0gMiAqIHJhZGl1cyAqIHNpbjYwO1xyXG4gICAgICAgICAgY29uc3QgdHJpYW5nbGVIZWlnaHQgPSByYWRpdXMgKiAoMSArIGNvczYwKTtcclxuICAgICAgICAgIGNvbnN0IGNlbnRyb2lkT2Zmc2V0WSA9IHRyaWFuZ2xlSGVpZ2h0IC8gMztcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlWSA9IGdldFlQeEVkaXRvcihvYmopO1xyXG4gICAgICAgICAgY29uc3QgdG9wQ29udGFpbmVyUHggPSBiYXNlWSAtICh0cmlhbmdsZUhlaWdodCAtIGNlbnRyb2lkT2Zmc2V0WSk7XHJcbiAgICAgICAgICBjb25zdCBsZWZ0Q29udGFpbmVyID0gTnVtYmVyKG9iaj8ueCB8fCAwKSAtIHRyaWFuZ2xlV2lkdGggLyAyO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIGxlZnRDb250YWluZXIpfTtcclxudG9wOiAke3RvcENTU0Zyb21ZUHgob2JqLCB0b3BDb250YWluZXJQeCl9O1xyXG53aWR0aDogJHtweFgob2JqLCB0cmlhbmdsZVdpZHRoKX07XHJcbmhlaWdodDogJHtweFkob2JqLCB0cmlhbmdsZUhlaWdodCl9O1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG5jbGlwLXBhdGg6IHBvbHlnb24oNTAlIDAlLCAwJSAxMDAlLCAxMDAlIDEwMCUpO1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke29iai5yb3RhdGlvbiA/PyAwfWRlZykgc2NhbGUoJHtvYmouc2NhbGVYID8/IDF9LCAke29iai5zY2FsZVkgPz8gMX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxkaXYgY2xhc3M9XCJvYmpldG9cIiBzdHlsZT1cIiR7YmFzZVN0eWxlfVwiPjwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9KVxyXG4gICAgLmpvaW4oXCJcXG5cIik7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkxJTkVfQ09OU1RBTlRTIiwiZXNjSFRNTCIsInN0ciIsIlN0cmluZyIsInJlcGxhY2UiLCJlc2NhcGVBdHRyIiwiTU9USU9OX0VGRkVDVF9WQUxVRVMiLCJTZXQiLCJzYW5pdGl6ZU1vdGlvbkVmZmVjdCIsInZhbHVlIiwibm9ybWFsaXplZCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImhhcyIsIm5vcm1hbGl6ZVJvbGVWYWx1ZSIsIm1hcE9ialRvRGF0YVR5cGUiLCJvYmoiLCJ0aXBvIiwiZmlndXJhIiwiaW5mZXJEYXRhUm9sZSIsImV4cGxpY2l0Um9sZSIsInJvbGUiLCJyb2wiLCJ0eXBlIiwiZm9udFNpemUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImJ1aWxkTW90aW9uRGF0YUF0dHJzIiwiZGF0YVR5cGUiLCJkYXRhUm9sZSIsImRhdGFNb3Rpb24iLCJtb3Rpb25FZmZlY3QiLCJhcHBlbmRNb3Rpb25EYXRhQXR0cnMiLCJodG1sRWxlbWVudG8iLCJhdHRycyIsImdldExpbmtQcm9wcyIsInJhdyIsImVubGFjZSIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJlbnZvbHZlclNpRW5sYWNlIiwiaHRtbENvbkRhdGEiLCJsaW5rIiwiZXNjYXBlSFRNTCIsInRleHRvIiwiZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MiLCJvYmpldG9zIiwiX3NlY2Npb25lcyIsImFsdG9Nb2RvUG9yU2VjY2lvbiIsIk1hcCIsIm1hcCIsInMiLCJpZCIsImFsdG9Nb2RvIiwiZXNTZWNjaW9uUGFudGFsbGEiLCJtb2RvIiwiZ2V0Iiwic2VjY2lvbklkIiwiaXNGdWxsQmxlZWQiLCJhbmNsYWplIiwic0NvbnRlbmlkb1ZhciIsInNYIiwic1kiLCJweFgiLCJweCIsIm4iLCJweFkiLCJBTFRVUkFfRURJVE9SX1BBTlRBTExBIiwiUEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWCIsImNsYW1wMDEiLCJ4IiwiTWF0aCIsIm1heCIsIm1pbiIsImdldFlQeEVkaXRvciIsInluIiwieU5vcm0iLCJ5UHgiLCJ5IiwidG9wUGFudGFsbGFDU1MiLCJ5blJhdyIsInluQ29tcGFjdGFkbyIsInRvcENTUyIsInlQeEVkaXRvciIsInRvcENTU0Zyb21ZUHgiLCJzdHlsZVBvc0Jhc2UiLCJyb3QiLCJyb3RhdGlvbiIsInNjYWxlWCIsInNjYWxlWSIsInpJbmRleCIsInVuZGVmaW5lZCIsInN0eWxlU2l6ZSIsInciLCJoIiwid3ciLCJoaCIsInBhcnRzIiwicHVzaCIsImpvaW4iLCJyZW5kZXJJY29ub1N2Z051ZXZvSW5saW5lIiwidmlld0JveCIsImNvbG9yIiwicGF0aHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ3aWR0aCIsImhlaWdodCIsInBhdGhzSHRtbCIsInAiLCJkIiwic3R5bGUiLCJhbGlnbiIsInRleHRBbGlnbiIsImNvbG9yVGV4dG8iLCJmaWxsIiwiYmFzZUxpbmVIZWlnaHQiLCJsaW5lSGVpZ2h0IiwibGluZUhlaWdodEZpbmFsIiwic2FmZVRleHRvIiwiYmFzZVN0eWxlIiwiZnMiLCJzRm9udCIsIm9yaWdpbiIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwidGV4dERlY29yYXRpb24iLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInNoYWRvd0NvbG9yIiwic2hhZG93T2Zmc2V0WCIsInNoYWRvd09mZnNldFkiLCJzaGFkb3dCbHVyIiwic3JjIiwidXJsIiwiZm9ybWF0byIsInN2Z0h0bWwiLCJ2YiIsInN2ZyIsInRhcmdldElTTyIsImZlY2hhT2JqZXRpdm8iLCJmZWNoYUlTTyIsInRleHRDb2xvciIsInByZXNldCIsInByZXNldElkIiwibGF5b3V0IiwiaXNNaW5pbWFsIiwiaW5jbHVkZXMiLCJ3T2JqIiwiaE9iaiIsImdhcCIsInNwYWNpbmciLCJjaGlwV2lkdGhQcm9wIiwiY2hpcFdpZHRoIiwicGFkZGluZ1hQcm9wIiwicGFkZGluZ1giLCJjaGlwV1RvdGFsIiwicm91bmQiLCJwYWRkaW5nWSIsInZhbHVlU2l6ZSIsImxhYmVsU2l6ZSIsImxhYmVsQ29sb3IiLCJsZXR0ZXJTcGFjaW5nIiwiY29udGFpbmVyQmdGaW5hbCIsImNoaXBCZ0ZpbmFsIiwiY2hpcEJhY2tncm91bmQiLCJib3hCZyIsImNoaXBCb3JkZXJDb2xvckZpbmFsIiwiY2hpcEJvcmRlciIsImJveEJvcmRlciIsImNvbnRhaW5lclJhZGl1cyIsImJveFJhZGl1cyIsInJhZGl1cyIsImNoaXBSYWRpdXNGaW5hbCIsImNoaXBSYWRpdXMiLCJzQ2hpcCIsImNvbnRhaW5lclN0eWxlIiwiY2hpcFN0eWxlIiwidmFsdWVTdHlsZSIsImxhYmVsU3R5bGUiLCJzaG93TGFiZWxzIiwibGFiZWxzIiwiZGlhcyIsImhvcmFzIiwic2VnIiwiaHRtbENvdW50ZG93biIsInJvd3MiLCJwYXJzZUludCIsImNvbHMiLCJnYXBQeCIsInJhZGl1c1B4Iiwic0dyaWQiLCJzdHlsZUNvbnRlbmVkb3IiLCJ0b3RhbCIsImNlbGxzIiwiZnJvbSIsIl8iLCJpIiwiYyIsIm1lZGlhVXJsIiwiZml0IiwiYmciLCJodG1sQ2VsZGFzIiwiY2VsbCIsImlkeCIsInNhZmVTcmMiLCJjZWxkYVN0eWxlIiwiaHRtbEdhbGVyaWEiLCJhbmNobyIsImFsdG8iLCJzQnRuIiwiaHRtbFJzdnAiLCJjb3JuZXJSYWRpdXMiLCJzUmVjdFRleHQiLCJpbm5lciIsImRpYW1ldGVyIiwieVB4Q2VudGVyIiwieVB4VG9wTGVmdCIsInBvaW50cyIsIkRFRkFVTFRfTEVOR1RIIiwieDEiLCJwYXJzZUZsb2F0IiwieTEiLCJ4MiIsInkyIiwiU1RST0tFX1dJRFRIIiwiZGVsdGFYIiwiZGVsdGFZIiwic3FydCIsImFuZ2xlIiwiYXRhbjIiLCJQSSIsInN0YXJ0WCIsImJhc2VZIiwic3RhcnRZIiwidG90YWxSb3RhdGlvbiIsImxpbmVIIiwic2luNjAiLCJjb3M2MCIsInRyaWFuZ2xlV2lkdGgiLCJ0cmlhbmdsZUhlaWdodCIsImNlbnRyb2lkT2Zmc2V0WSIsInRvcENvbnRhaW5lclB4IiwibGVmdENvbnRhaW5lciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarHTMLDesdeSecciones.ts":
/*!**********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeSecciones.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarHTMLDesdeSecciones: () => (/* binding */ generarHTMLDesdeSecciones)\n/* harmony export */ });\n/* harmony import */ var _generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generarHTMLDesdeObjetos */ \"(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts\");\n/* harmony import */ var _models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/dimensionesBase */ \"(pages-dir-node)/./functions/src/models/dimensionesBase.ts\");\n/* harmony import */ var _generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generarModalRSVP */ \"(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts\");\n/* harmony import */ var _generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generarModalGaleria */ \"(pages-dir-node)/./functions/src/utils/generarModalGaleria.ts\");\n/* harmony import */ var _mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mobileSmartSectionLayout */ \"(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts\");\n/* harmony import */ var _generarMotionEffectsRuntime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generarMotionEffectsRuntime */ \"(pages-dir-node)/./functions/src/utils/generarMotionEffectsRuntime.ts\");\n/* harmony import */ var _generarInvitationLoaderRuntime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./generarInvitationLoaderRuntime */ \"(pages-dir-node)/./functions/src/utils/generarInvitationLoaderRuntime.ts\");\n\n\n\n\n\n\n\nconst ENABLE_MOBILE_SMART_LAYOUT = true; // ✅ empezamos apagado\nconst EXCLUDE_FONTS = new Set([\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\",\n    \"Arial\",\n    \"Helvetica\",\n    \"Times\",\n    \"Times New Roman\",\n    \"Georgia\",\n    \"Courier New\"\n]);\nconst ALTURA_REFERENCIA_PANTALLA = 500;\n// ✅ Offsets SOLO para texto en secciones Pantalla: ON\n// - Desktop: aplica cuando vw > 767px\n// - Mobile: aplica cuando vw <= 767px\n// (Estos valores se vuelcan a CSS variables en :root)\nconst PANTALLA_Y_OFFSET_DESKTOP_PX = -28;\nconst PANTALLA_Y_OFFSET_MOBILE_PX = 0;\nfunction buildGoogleFontsLink(fonts) {\n    const familias = fonts.map((f)=>f.replace(/['\"]/g, \"\").split(\",\")[0].trim()).filter((n)=>n && !EXCLUDE_FONTS.has(n)).map((n)=>`family=${n.replace(/ /g, \"+\")}`).join(\"&\");\n    if (!familias) return \"\";\n    return `\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?${familias}&display=swap\" rel=\"stylesheet\">`.trim();\n}\nfunction escapeAttr(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction buildFondoStyle(seccion) {\n    const fondoValue = seccion?.fondo || \"transparent\";\n    const esImagenFondo = seccion?.fondoTipo === \"imagen\" && seccion?.fondoImagen;\n    let estilosFondo = \"\";\n    if (esImagenFondo) {\n        let imageUrl = seccion.fondoImagen;\n        if (imageUrl && imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        let backgroundPosition = \"center center\";\n        if (seccion.fondoImagenOffsetX !== undefined || seccion.fondoImagenOffsetY !== undefined) {\n            const offsetX = seccion.fondoImagenOffsetX || 0;\n            const offsetY = seccion.fondoImagenOffsetY || 0;\n            const offsetXPercent = offsetX !== 0 ? `calc(50% - ${-offsetX}px)` : \"50%\";\n            const offsetYPercent = offsetY !== 0 ? `calc(50% - ${-offsetY}px)` : \"50%\";\n            backgroundPosition = `${offsetXPercent} ${offsetYPercent}`;\n        }\n        estilosFondo = `background-image: url('${imageUrl}'); background-size: cover; background-position: ${backgroundPosition}; background-repeat: no-repeat;`;\n    } else if (fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\")) {\n        let imageUrl = fondoValue.replace(\"url(\", \"\").replace(\")\", \"\");\n        if (imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        estilosFondo = `background-image: url('${imageUrl}'); background-size: cover; background-position: center center; background-repeat: no-repeat;`;\n    } else {\n        estilosFondo = `background: ${fondoValue};`;\n    }\n    return estilosFondo.replace(/\\s+/g, \" \").trim();\n}\nfunction generarHTMLDesdeSecciones(secciones, objetos, rsvp, opciones, opts) {\n    const slug = opciones?.slug ?? \"\";\n    const slugPublica = opts?.slug ?? \"\";\n    const fuentesUsadas = [\n        ...new Set(objetos.filter((o)=>(o.tipo === \"texto\" || o.tipo === \"countdown\") && o.fontFamily).map((o)=>o.fontFamily))\n    ];\n    const googleFontsLink = buildGoogleFontsLink(fuentesUsadas);\n    const hayRSVPEnCanvas = objetos?.some((o)=>o.tipo === \"rsvp-boton\");\n    const botonRSVP = \"\"; // (si querés agregar un botón fijo fuera del canvas, hacelo acá)\n    const modalRSVP = hayRSVPEnCanvas && rsvp?.enabled ? (0,_generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__.generarModalRSVPHTML)(rsvp) : \"\";\n    const modalGaleria = (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.hayGaleriaConImagenes)(objetos) ? (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.generarModalGaleriaHTML)() : \"\";\n    const invitationLoaderRuntime = (0,_generarInvitationLoaderRuntime__WEBPACK_IMPORTED_MODULE_6__.generarInvitationLoaderRuntimeHTML)();\n    const motionEffectsRuntime = (0,_generarMotionEffectsRuntime__WEBPACK_IMPORTED_MODULE_5__.generarMotionEffectsRuntimeHTML)();\n    function hayCountdown(objs) {\n        return Array.isArray(objs) && objs.some((o)=>o?.tipo === \"countdown\");\n    }\n    const scriptCountdown = hayCountdown(objetos) ? `\n<script>\n(function(){\n  function pad(n){ n=Math.floor(Math.abs(n)); return n<10 ? \"0\"+n : \"\"+n; }\n  function diffParts(target){\n    const now = Date.now();\n    let ms = Math.max(0, target.getTime() - now);\n    const d = Math.floor(ms / 86400000); ms -= d*86400000;\n    const h = Math.floor(ms / 3600000);  ms -= h*3600000;\n    const m = Math.floor(ms / 60000);    ms -= m*60000;\n    const s = Math.floor(ms / 1000);\n    return { d, h, m, s };\n  }\n  function tickOne(root){\n    const iso = root.getAttribute(\"data-target\");\n    if(!iso) return;\n    const t = new Date(iso);\n    if(isNaN(t.getTime())) return;\n    const p = diffParts(t);\n    const vals = root.querySelectorAll(\".cd-val\");\n    if(vals && vals.length >= 4){\n      vals[0].textContent = String(p.d).padStart(2,\"0\");\n      vals[1].textContent = pad(p.h);\n      vals[2].textContent = pad(p.m);\n      vals[3].textContent = pad(p.s);\n    }\n  }\n  function boot(){\n    const roots = Array.from(document.querySelectorAll(\"[data-countdown]\"));\n    if(!roots.length) return;\n    roots.forEach(tickOne);\n    setInterval(() => roots.forEach(tickOne), 1000);\n  }\n  if(document.readyState === \"loading\"){\n    document.addEventListener(\"DOMContentLoaded\", boot);\n  } else {\n    boot();\n  }\n})();\n</script>\n`.trim() : \"\";\n    const seccionesOrdenadas = [\n        ...secciones || []\n    ].sort((a, b)=>(Number(a?.orden) || 0) - (Number(b?.orden) || 0));\n    const htmlSecciones = seccionesOrdenadas.map((seccion)=>{\n        const modo = String(seccion?.altoModo || \"fijo\").toLowerCase();\n        const hbase = Number.isFinite(seccion?.altura) ? Number(seccion.altura) : 600;\n        const objsDeSeccion = objetos.filter((o)=>o.seccionId === seccion.id);\n        const objsBleed = objsDeSeccion.filter((o)=>String(o?.anclaje || \"\").toLowerCase() === \"fullbleed\");\n        const objsContenido = objsDeSeccion.filter((o)=>String(o?.anclaje || \"\").toLowerCase() !== \"fullbleed\");\n        const fondoStyle = buildFondoStyle(seccion);\n        const htmlBleed = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsBleed, seccionesOrdenadas);\n        const htmlContenido = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsContenido, seccionesOrdenadas);\n        return `\n<section class=\"sec\" data-modo=\"${escapeAttr(modo)}\" style=\"--hbase:${hbase}\">\n  <div class=\"sec-zoom\">\n    <div class=\"sec-bg\" style=\"${fondoStyle}\"></div>\n    <div class=\"sec-bleed\">${htmlBleed}</div>\n    <div class=\"sec-content\">${htmlContenido}</div>\n  </div>\n</section>\n`.trim();\n    }).join(\"\\n\");\n    const scriptMobileSmart = (0,_mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__.buildMobileSmartSectionLayoutScript)({\n        enabled: ENABLE_MOBILE_SMART_LAYOUT,\n        minGapPx: 1,\n        paddingTopPx: 0,\n        paddingBottomPx: 2,\n        onlyFixedSections: true,\n        minPerColumn2: 1,\n        fitMinScale: 0.88,\n        fitMaxScale: 1.16,\n        fitTargetWidthRatio: 0.94,\n        fitMinFillRatio: 0.9\n    });\n    return `\n<!DOCTYPE html>\n<html lang=\"es\"${slug ? ` data-slug=\"${escapeAttr(slug)}\"` : \"\"}>\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\" />\n  <title>Invitación</title>\n  ${googleFontsLink}\n  <style>\n    * { box-sizing: border-box; margin: 0; padding: 0; }\n\n    html, body {\n      width: 100%;\n      height: 100%;\n      background: white;\n      overflow-x: hidden;\n      font-family: sans-serif;\n    }\n\n    /* ✅ SOLO MOBILE: evita “auto-resize / font boosting” del texto */\n    @media (max-width: 767px){\n      html{\n        -webkit-text-size-adjust: 100%;\n        text-size-adjust: 100%;\n      }\n      \n        :root{ --text-zoom: 1; }\n    }\n\n    :root{\n      --safe-top: env(safe-area-inset-top, 0px);\n      --safe-right: env(safe-area-inset-right, 0px);\n      --safe-bottom: env(safe-area-inset-bottom, 0px);\n      --safe-left: env(safe-area-inset-left, 0px);\n      --bp-mobile: 767px;\n      \n\n\n      /* Global scales */\n      --content-w: ${_models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__.CANVAS_BASE.ANCHO}px;\n      --sx: 1;   /* contentW/800 */\n      --bx: 1;   /* viewportW/800 */\n\n      /* vh lógico por defecto */\n      --vh-safe: 100vh;\n      --vh-logical: var(--vh-safe);\n      --pantalla-y-compact: 0;\n\n      /* ✅ Offset SOLO para texto en Pantalla: ON (desktop default) */\n      --pantalla-y-offset: ${PANTALLA_Y_OFFSET_DESKTOP_PX}px;\n    }\n\n    /* ✅ Mobile: offset distinto SOLO para texto en Pantalla: ON */\n    @media (max-width: 767px){\n      :root{\n        --pantalla-y-offset: ${PANTALLA_Y_OFFSET_MOBILE_PX}px;\n      }\n    }\n\n    .inv{ width: 100%; background: white; }\n\n    .sec{\n      position: relative;\n      width: 100vw;\n      left: 50%;\n      transform: translateX(-50%);\n      overflow: visible; /* bleed puede salirse */\n    }\n\n    /* ✅ Wrapper que hace “zoom” centrado (evita corrimiento a la derecha) */\n    .sec-zoom{\n      position: relative;\n      width: 100%;\n      height: 100%;\n      transform-origin: top center;\n      transform: scale(var(--zoom, 1));\n    }\n\n    /* ✅ Pantalla ON: recorte para que el zoom no desborde */\n    .sec[data-modo=\"pantalla\"]{\n      overflow: hidden;\n      height: 100dvh;\n      height: 100vh;\n      padding-top: var(--safe-top);\n      padding-bottom: var(--safe-bottom);\n\n      /* fallback CSS (JS lo pisa en mobile con px reales) */\n      --vh-safe: calc(100dvh - var(--safe-top) - var(--safe-bottom));\n\n      /* el zoom extra va por --zoom (NO por sfinal) */\n      --zoom: 1;\n      --bgzoom: 1;\n\n      /* factor final para CONTENIDO (se setea por JS) */\n      --sfinal: 1;\n    }\n\n    .sec[data-modo=\"fijo\"]{\n      /* altura fija escalada por ancho; JS setea --sfinal = sx */\n      height: calc(var(--sfinal) * var(--hbase) * 1px);\n      --zoom: 1;\n      --bgzoom: 1;\n    }\n\n    /* Fondo */\n    .sec-bg{\n      position: absolute;\n      inset: 0;\n      z-index: 0;\n      pointer-events: none;\n    }\n\n    /* ✅ Fondo agrandable solo en pantalla (acompaña el zoom hero) */\n    .sec[data-modo=\"pantalla\"] .sec-bg{\n      transform: scale(var(--bgzoom, 1));\n      transform-origin: center;\n    }\n\n    .sec-bleed{\n      position: absolute;\n      inset: 0;\n      z-index: 2;\n      overflow: visible;\n      pointer-events: none;\n    }\n\n    .sec-content{\n      position: relative;\n      z-index: 3;\n      width: var(--content-w);\n      margin: 0 auto;\n      height: 100%;\n      pointer-events: none;\n    }\n\n    /* ✅ Pantalla ON: el ancho del “content” puede crecer con la escala vertical */\n    .sec[data-modo=\"pantalla\"] .sec-content{\n      width: var(--content-w-pantalla, var(--content-w));\n    }\n\n    @media (max-width: 767px){\n      .sec-content{\n        width: 100%;\n        margin: 0;\n        box-sizing: border-box;\n        padding-left: var(--safe-left);\n        padding-right: var(--safe-right);\n      }\n    }\n\n    .objeto{\n      position: absolute;\n      transform-origin: top left;\n      overflow: visible;\n      pointer-events: auto;\n    }\n\n    .objeto[data-debug-texto=\"1\"]{\n      -webkit-font-smoothing: antialiased;\n      text-rendering: optimizeLegibility;\n    }\n\n    .objeto.is-interactive{ pointer-events: auto; }\n\n    .cd-chip { backdrop-filter: saturate(1.1); }\n  </style>\n</head>\n\n<body data-loader-ready=\"0\" data-slug=\"${escapeAttr(slugPublica)}\">\n  ${invitationLoaderRuntime}\n  <div class=\"inv\">\n    ${htmlSecciones}\n  </div>\n\n  ${botonRSVP}\n  ${modalRSVP}\n  ${modalGaleria}\n  ${motionEffectsRuntime}\n\n  ${scriptCountdown}\n\n  <script>\n    (function(){\n      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }\n\n      function compute(){\n        var vw = document.documentElement.clientWidth;\n        var BASE_W = 800; // = CANVAS_BASE.ANCHO\n\n        // contentW (sin vw-32)\n        var contentW = Math.min(BASE_W, vw);\n\n        var sx = contentW / BASE_W;\n        var bx = vw / BASE_W;\n\n        document.documentElement.style.setProperty(\"--content-w\", contentW + \"px\");\n        document.documentElement.style.setProperty(\"--sx\", String(sx));\n        document.documentElement.style.setProperty(\"--bx\", String(bx));\n\n        var secs = Array.from(document.querySelectorAll(\".sec\"));\n        var isMobile = vw <= 767;\n\n        // viewport real (más estable en mobile)\n        var vv = window.visualViewport;\n        var viewportH = (vv && vv.height) ? vv.height : window.innerHeight;\n\n        // safe areas (css env)\n        var safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-top\")) || 0;\n        var safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-bottom\")) || 0;\n\n        // diseño base del modo \"pantalla\" (800 x 500)\n        var DESIGN_W = BASE_W;\n        var DESIGN_H = ${ALTURA_REFERENCIA_PANTALLA}; // = ALTURA_REFERENCIA_PANTALLA\n        var designAR = DESIGN_H / DESIGN_W; // 0.625\n        var deviceAR = viewportH / vw;\n\n        // zoom extra (solo si el device es más vertical que el diseño)\n        var zoomExtra = 1;\n        if (isMobile && deviceAR > designAR){\n          var k = deviceAR / designAR;\n          zoomExtra = clamp(1 + (k - 1) * 0.18, 1, 1.35);\n        }\n\n        // 🔧 Ajuste fino: cuánto acompaña el fondo al zoom hero (0..1.2)\n        // 0   => el fondo NO agrega zoom extra propio (solo el zoom del wrapper)\n        // 1   => comportamiento actual (fondo queda zoomExtra²)\n        // 0.3 => recomendado para empezar (sutil)\n        var BG_ZOOM_FACTOR = 0;\n\n        // 🔧 Ajuste fino: cuánto acompaña el CONTENIDO (texto/objetos) al zoom hero\n        // 0   => comportamiento actual\n        // 0.3 => recomendado\n        // 1   => texto escala igual que el hero (no aconsejado)\n        var TEXT_ZOOM_FACTOR = 0;\n\n\n        secs.forEach(function(sec){\n          var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n\n          // defaults\n          var zoom = 1;\n          var bgzoom = 1;\n\n          // ✅ Por defecto, tamaños escalan por ancho (comportamiento actual)\n          var sfinal = sx;\n          var pantallaYCompact = 0;\n\n          // limpiar custom width si no aplica\n          sec.style.removeProperty(\"--content-w-pantalla\");\n\n          if (modo === \"pantalla\"){\n            // vh-safe real en px\n            var vhSafePx = Math.max(0, viewportH - safeTop - safeBottom);\n            sec.style.setProperty(\"--vh-safe\", vhSafePx + \"px\");\n\n            // 🔥 Desktop: escalar el contenido por ALTURA (vhSafe/500)\n            // Esto alinea el HTML publicado con lo que ves en preview\n            if (!isMobile){\n              var sh = vhSafePx / DESIGN_H;\n              sfinal = sh;\n\n              // para que el \"content\" quede centrado y coherente con la nueva escala vertical\n              sec.style.setProperty(\"--content-w-pantalla\", (DESIGN_W * sh) + \"px\");\n            }\n\n            // ✅ Mobile: mantenemos tu comportamiento actual (zoom hero suave)\n            if (isMobile){\n              zoom = zoomExtra;\n              bgzoom = 1 + (zoomExtra - 1) * BG_ZOOM_FACTOR;\n\n              // 🔥 NUEVO: el contenido acompaña parcialmente el zoom\n              sfinal = sx * (1 + (zoomExtra - 1) * TEXT_ZOOM_FACTOR);\n\n              // ✅ Mobile pantalla: compacta distancia vertical para preservar la esencia\n              // del diseño en dispositivos muy altos, manteniendo y=0.5 centrado.\n              var vhLogicalPx = vhSafePx / Math.max(0.01, zoom || 1);\n              var logicalAR = vhLogicalPx / Math.max(1, vw);\n              var stretchRatio = (logicalAR / Math.max(0.01, designAR)) - 1;\n              pantallaYCompact = clamp(stretchRatio * 0.12, 0, 0.45);\n            }\n          }\n\n          sec.style.setProperty(\"--sfinal\", String(sfinal));\n          sec.style.setProperty(\"--zoom\", String(zoom));\n          sec.style.setProperty(\"--bgzoom\", String(bgzoom));\n\n          // ✅ Solo en mobile + pantalla: corregir el \"vh\" que después se escala con zoom\n          if (isMobile && modo === \"pantalla\") {\n            // --vh-logical = --vh-safe / --zoom\n            sec.style.setProperty(\"--vh-logical\", \"calc(var(--vh-safe) / var(--zoom))\");\n          } else {\n            // resto: se comporta como siempre\n            sec.style.setProperty(\"--vh-logical\", \"var(--vh-safe)\");\n          }\n          sec.style.setProperty(\"--pantalla-y-compact\", String(pantallaYCompact));\n        });\n\n\n      }\n\n      window.addEventListener(\"load\", compute);\n      window.addEventListener(\"resize\", compute);\n\n      if (window.visualViewport){\n        window.visualViewport.addEventListener(\"resize\", compute);\n        window.visualViewport.addEventListener(\"scroll\", compute);\n      }\n\n      window.addEventListener(\"orientationchange\", function(){\n        setTimeout(compute, 50);\n        setTimeout(compute, 250);\n      });\n\n      compute();\n    })();\n  </script>\n\n    \n\n\n   ${scriptMobileSmart}\n \n</body>\n</html>\n`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvRTtBQUNaO0FBQ2tDO0FBQ0g7QUFDTjtBQUNEO0FBQ007QUFFdEYsTUFBTVEsNkJBQTZCLE1BQU0sc0JBQXNCO0FBRS9ELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJO0lBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsNkJBQTZCO0FBRW5DLHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxNQUFNQywrQkFBK0IsQ0FBQztBQUN0QyxNQUFNQyw4QkFBOEI7QUFFcEMsU0FBU0MscUJBQXFCQyxLQUFlO0lBQzNDLE1BQU1DLFdBQVdELE1BQ2RFLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxPQUFPLENBQUMsU0FBUyxJQUFJQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxJQUNwREMsTUFBTSxDQUFDLENBQUNDLElBQU1BLEtBQUssQ0FBQ2QsY0FBY2UsR0FBRyxDQUFDRCxJQUN0Q04sR0FBRyxDQUFDLENBQUNNLElBQU0sQ0FBQyxPQUFPLEVBQUVBLEVBQUVKLE9BQU8sQ0FBQyxNQUFNLE1BQU0sRUFDM0NNLElBQUksQ0FBQztJQUVSLElBQUksQ0FBQ1QsVUFBVSxPQUFPO0lBRXRCLE9BQU8sQ0FBQzs7OENBRW9DLEVBQUVBLFNBQVMsZ0NBQWdDLENBQUMsQ0FBQ0ssSUFBSTtBQUMvRjtBQU1BLFNBQVNLLFdBQVdDLE1BQWMsRUFBRTtJQUNsQyxPQUFPQyxPQUFPRCxLQUNYUixPQUFPLENBQUMsTUFBTSxTQUNkQSxPQUFPLENBQUMsTUFBTSxVQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTTtBQUNuQjtBQUVBLFNB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QWtCOzs7O0FBSXZCLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxnZW5lcmFySFRNTERlc2RlU2VjY2lvbmVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdlbmVyYXJIVE1MRGVzZGVPYmpldG9zIH0gZnJvbSBcIi4vZ2VuZXJhckhUTUxEZXNkZU9iamV0b3NcIjtcclxuaW1wb3J0IHsgQ0FOVkFTX0JBU0UgfSBmcm9tIFwiLi4vbW9kZWxzL2RpbWVuc2lvbmVzQmFzZVwiO1xyXG5pbXBvcnQgeyBnZW5lcmFyTW9kYWxSU1ZQSFRNTCwgdHlwZSBSU1ZQQ29uZmlnIGFzIE1vZGFsQ29uZmlnIH0gZnJvbSBcIi4vZ2VuZXJhck1vZGFsUlNWUFwiO1xyXG5pbXBvcnQgeyBnZW5lcmFyTW9kYWxHYWxlcmlhSFRNTCwgaGF5R2FsZXJpYUNvbkltYWdlbmVzIH0gZnJvbSBcIi4vZ2VuZXJhck1vZGFsR2FsZXJpYVwiO1xyXG5pbXBvcnQgeyBidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCB9IGZyb20gXCIuL21vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFwiO1xyXG5pbXBvcnQgeyBnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWVIVE1MIH0gZnJvbSBcIi4vZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lXCI7XHJcbmltcG9ydCB7IGdlbmVyYXJJbnZpdGF0aW9uTG9hZGVyUnVudGltZUhUTUwgfSBmcm9tIFwiLi9nZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVcIjtcclxuXHJcbmNvbnN0IEVOQUJMRV9NT0JJTEVfU01BUlRfTEFZT1VUID0gdHJ1ZTsgLy8g4pyFIGVtcGV6YW1vcyBhcGFnYWRvXHJcblxyXG5jb25zdCBFWENMVURFX0ZPTlRTID0gbmV3IFNldChbXHJcbiAgXCJzZXJpZlwiLFxyXG4gIFwic2Fucy1zZXJpZlwiLFxyXG4gIFwibW9ub3NwYWNlXCIsXHJcbiAgXCJjdXJzaXZlXCIsXHJcbiAgXCJmYW50YXN5XCIsXHJcbiAgXCJzeXN0ZW0tdWlcIixcclxuICBcIkFyaWFsXCIsXHJcbiAgXCJIZWx2ZXRpY2FcIixcclxuICBcIlRpbWVzXCIsXHJcbiAgXCJUaW1lcyBOZXcgUm9tYW5cIixcclxuICBcIkdlb3JnaWFcIixcclxuICBcIkNvdXJpZXIgTmV3XCIsXHJcbl0pO1xyXG5cclxuY29uc3QgQUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEEgPSA1MDA7XHJcblxyXG4vLyDinIUgT2Zmc2V0cyBTT0xPIHBhcmEgdGV4dG8gZW4gc2VjY2lvbmVzIFBhbnRhbGxhOiBPTlxyXG4vLyAtIERlc2t0b3A6IGFwbGljYSBjdWFuZG8gdncgPiA3NjdweFxyXG4vLyAtIE1vYmlsZTogYXBsaWNhIGN1YW5kbyB2dyA8PSA3NjdweFxyXG4vLyAoRXN0b3MgdmFsb3JlcyBzZSB2dWVsY2FuIGEgQ1NTIHZhcmlhYmxlcyBlbiA6cm9vdClcclxuY29uc3QgUEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWCA9IC0yODtcclxuY29uc3QgUEFOVEFMTEFfWV9PRkZTRVRfTU9CSUxFX1BYID0gMDtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlRm9udHNMaW5rKGZvbnRzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgY29uc3QgZmFtaWxpYXMgPSBmb250c1xyXG4gICAgLm1hcCgoZikgPT4gZi5yZXBsYWNlKC9bJ1wiXS9nLCBcIlwiKS5zcGxpdChcIixcIilbMF0udHJpbSgpKVxyXG4gICAgLmZpbHRlcigobikgPT4gbiAmJiAhRVhDTFVERV9GT05UUy5oYXMobikpXHJcbiAgICAubWFwKChuKSA9PiBgZmFtaWx5PSR7bi5yZXBsYWNlKC8gL2csIFwiK1wiKX1gKVxyXG4gICAgLmpvaW4oXCImXCIpO1xyXG5cclxuICBpZiAoIWZhbWlsaWFzKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgcmV0dXJuIGBcclxuPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tXCIgY3Jvc3NvcmlnaW4+XHJcbjxsaW5rIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/JHtmYW1pbGlhc30mZGlzcGxheT1zd2FwXCIgcmVsPVwic3R5bGVzaGVldFwiPmAudHJpbSgpO1xyXG59XHJcblxyXG50eXBlIEdlbmVyYXJIVE1MT3BjaW9uZXMgPSB7XHJcbiAgc2x1Zz86IHN0cmluZztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGVzY2FwZUF0dHIoc3RyOiBzdHJpbmcgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gU3RyaW5nKHN0cilcclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkRm9uZG9TdHlsZShzZWNjaW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGZvbmRvVmFsdWUgPSBzZWNjaW9uPy5mb25kbyB8fCBcInRyYW5zcGFyZW50XCI7XHJcbiAgY29uc3QgZXNJbWFnZW5Gb25kbyA9IHNlY2Npb24/LmZvbmRvVGlwbyA9PT0gXCJpbWFnZW5cIiAmJiBzZWNjaW9uPy5mb25kb0ltYWdlbjtcclxuXHJcbiAgbGV0IGVzdGlsb3NGb25kbyA9IFwiXCI7XHJcblxyXG4gIGlmIChlc0ltYWdlbkZvbmRvKSB7XHJcbiAgICBsZXQgaW1hZ2VVcmwgPSBzZWNjaW9uLmZvbmRvSW1hZ2VuO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgaW1hZ2VVcmwgJiZcclxuICAgICAgaW1hZ2VVcmwuaW5jbHVkZXMoXCJmaXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb21cIikgJiZcclxuICAgICAgIWltYWdlVXJsLmluY2x1ZGVzKFwiYWx0PW1lZGlhXCIpXHJcbiAgICApIHtcclxuICAgICAgaW1hZ2VVcmwgPSBpbWFnZVVybCArIChpbWFnZVVybC5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiKSArIFwiYWx0PW1lZGlhXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGJhY2tncm91bmRQb3NpdGlvbiA9IFwiY2VudGVyIGNlbnRlclwiO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgc2VjY2lvbi5mb25kb0ltYWdlbk9mZnNldFggIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WSAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IHNlY2Npb24uZm9uZG9JbWFnZW5PZmZzZXRYIHx8IDA7XHJcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WSB8fCAwO1xyXG5cclxuICAgICAgY29uc3Qgb2Zmc2V0WFBlcmNlbnQgPSBvZmZzZXRYICE9PSAwID8gYGNhbGMoNTAlIC0gJHstb2Zmc2V0WH1weClgIDogXCI1MCVcIjtcclxuICAgICAgY29uc3Qgb2Zmc2V0WVBlcmNlbnQgPSBvZmZzZXRZICE9PSAwID8gYGNhbGMoNTAlIC0gJHstb2Zmc2V0WX1weClgIDogXCI1MCVcIjtcclxuXHJcbiAgICAgIGJhY2tncm91bmRQb3NpdGlvbiA9IGAke29mZnNldFhQZXJjZW50fSAke29mZnNldFlQZXJjZW50fWA7XHJcbiAgICB9XHJcblxyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgnJHtpbWFnZVVybH0nKTsgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjsgYmFja2dyb3VuZC1wb3NpdGlvbjogJHtiYWNrZ3JvdW5kUG9zaXRpb259OyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O2A7XHJcbiAgfSBlbHNlIGlmIChcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImh0dHBcIikgfHxcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImRhdGE6XCIpIHx8XHJcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJibG9iOlwiKVxyXG4gICkge1xyXG4gICAgbGV0IGltYWdlVXJsID0gZm9uZG9WYWx1ZS5yZXBsYWNlKFwidXJsKFwiLCBcIlwiKS5yZXBsYWNlKFwiKVwiLCBcIlwiKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGltYWdlVXJsLmluY2x1ZGVzKFwiZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tXCIpICYmXHJcbiAgICAgICFpbWFnZVVybC5pbmNsdWRlcyhcImFsdD1tZWRpYVwiKVxyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlVXJsID0gaW1hZ2VVcmwgKyAoaW1hZ2VVcmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIikgKyBcImFsdD1tZWRpYVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGVzdGlsb3NGb25kbyA9IGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJyR7aW1hZ2VVcmx9Jyk7IGJhY2tncm91bmQtc2l6ZTogY292ZXI7IGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7YDtcclxuICB9IGVsc2Uge1xyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQ6ICR7Zm9uZG9WYWx1ZX07YDtcclxuICB9XHJcblxyXG4gIHJldHVybiBlc3RpbG9zRm9uZG8ucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikudHJpbSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcyhcclxuICBzZWNjaW9uZXM6IGFueVtdLFxyXG4gIG9iamV0b3M6IGFueVtdLFxyXG4gIHJzdnA/OiBNb2RhbENvbmZpZyxcclxuICBvcGNpb25lcz86IEdlbmVyYXJIVE1MT3BjaW9uZXMsXHJcbiAgb3B0cz86IHsgc2x1Zz86IHN0cmluZyB9XHJcbik6IHN0cmluZyB7XHJcbiAgY29uc3Qgc2x1ZyA9IG9wY2lvbmVzPy5zbHVnID8/IFwiXCI7XHJcbiAgY29uc3Qgc2x1Z1B1YmxpY2EgPSBvcHRzPy5zbHVnID8/IFwiXCI7XHJcblxyXG4gIGNvbnN0IGZ1ZW50ZXNVc2FkYXMgPSBbXHJcbiAgICAuLi5uZXcgU2V0KFxyXG4gICAgICBvYmpldG9zXHJcbiAgICAgICAgLmZpbHRlcigobykgPT4gKG8udGlwbyA9PT0gXCJ0ZXh0b1wiIHx8IG8udGlwbyA9PT0gXCJjb3VudGRvd25cIikgJiYgby5mb250RmFtaWx5KVxyXG4gICAgICAgIC5tYXAoKG8pID0+IG8uZm9udEZhbWlseSlcclxuICAgICksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ29vZ2xlRm9udHNMaW5rID0gYnVpbGRHb29nbGVGb250c0xpbmsoZnVlbnRlc1VzYWRhcyk7XHJcblxyXG4gIGNvbnN0IGhheVJTVlBFbkNhbnZhcyA9IG9iamV0b3M/LnNvbWUoKG8pID0+IG8udGlwbyA9PT0gXCJyc3ZwLWJvdG9uXCIpO1xyXG4gIGNvbnN0IGJvdG9uUlNWUCA9IFwiXCI7IC8vIChzaSBxdWVyw6lzIGFncmVnYXIgdW4gYm90w7NuIGZpam8gZnVlcmEgZGVsIGNhbnZhcywgaGFjZWxvIGFjw6EpXHJcbiAgY29uc3QgbW9kYWxSU1ZQID0gaGF5UlNWUEVuQ2FudmFzICYmIHJzdnA/LmVuYWJsZWQgPyBnZW5lcmFyTW9kYWxSU1ZQSFRNTChyc3ZwKSA6IFwiXCI7XHJcbiAgY29uc3QgbW9kYWxHYWxlcmlhID0gaGF5R2FsZXJpYUNvbkltYWdlbmVzKG9iamV0b3MpID8gZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwoKSA6IFwiXCI7XHJcbiAgY29uc3QgaW52aXRhdGlvbkxvYWRlclJ1bnRpbWUgPSBnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MKCk7XHJcbiAgY29uc3QgbW90aW9uRWZmZWN0c1J1bnRpbWUgPSBnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWVIVE1MKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGhheUNvdW50ZG93bihvYmpzOiBhbnlbXSkge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqcykgJiYgb2Jqcy5zb21lKChvKSA9PiBvPy50aXBvID09PSBcImNvdW50ZG93blwiKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNjcmlwdENvdW50ZG93biA9IGhheUNvdW50ZG93bihvYmpldG9zKVxyXG4gICAgPyBgXHJcbjxzY3JpcHQ+XHJcbihmdW5jdGlvbigpe1xyXG4gIGZ1bmN0aW9uIHBhZChuKXsgbj1NYXRoLmZsb29yKE1hdGguYWJzKG4pKTsgcmV0dXJuIG48MTAgPyBcIjBcIituIDogXCJcIituOyB9XHJcbiAgZnVuY3Rpb24gZGlmZlBhcnRzKHRhcmdldCl7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgbGV0IG1zID0gTWF0aC5tYXgoMCwgdGFyZ2V0LmdldFRpbWUoKSAtIG5vdyk7XHJcbiAgICBjb25zdCBkID0gTWF0aC5mbG9vcihtcyAvIDg2NDAwMDAwKTsgbXMgLT0gZCo4NjQwMDAwMDtcclxuICAgIGNvbnN0IGggPSBNYXRoLmZsb29yKG1zIC8gMzYwMDAwMCk7ICBtcyAtPSBoKjM2MDAwMDA7XHJcbiAgICBjb25zdCBtID0gTWF0aC5mbG9vcihtcyAvIDYwMDAwKTsgICAgbXMgLT0gbSo2MDAwMDtcclxuICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKG1zIC8gMTAwMCk7XHJcbiAgICByZXR1cm4geyBkLCBoLCBtLCBzIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRpY2tPbmUocm9vdCl7XHJcbiAgICBjb25zdCBpc28gPSByb290LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpO1xyXG4gICAgaWYoIWlzbykgcmV0dXJuO1xyXG4gICAgY29uc3QgdCA9IG5ldyBEYXRlKGlzbyk7XHJcbiAgICBpZihpc05hTih0LmdldFRpbWUoKSkpIHJldHVybjtcclxuICAgIGNvbnN0IHAgPSBkaWZmUGFydHModCk7XHJcbiAgICBjb25zdCB2YWxzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNkLXZhbFwiKTtcclxuICAgIGlmKHZhbHMgJiYgdmFscy5sZW5ndGggPj0gNCl7XHJcbiAgICAgIHZhbHNbMF0udGV4dENvbnRlbnQgPSBTdHJpbmcocC5kKS5wYWRTdGFydCgyLFwiMFwiKTtcclxuICAgICAgdmFsc1sxXS50ZXh0Q29udGVudCA9IHBhZChwLmgpO1xyXG4gICAgICB2YWxzWzJdLnRleHRDb250ZW50ID0gcGFkKHAubSk7XHJcbiAgICAgIHZhbHNbM10udGV4dENvbnRlbnQgPSBwYWQocC5zKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gYm9vdCgpe1xyXG4gICAgY29uc3Qgcm9vdHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jb3VudGRvd25dXCIpKTtcclxuICAgIGlmKCFyb290cy5sZW5ndGgpIHJldHVybjtcclxuICAgIHJvb3RzLmZvckVhY2godGlja09uZSk7XHJcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiByb290cy5mb3JFYWNoKHRpY2tPbmUpLCAxMDAwKTtcclxuICB9XHJcbiAgaWYoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpe1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgYm9vdCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGJvb3QoKTtcclxuICB9XHJcbn0pKCk7XHJcbjwvc2NyaXB0PlxyXG5gLnRyaW0oKVxyXG4gICAgOiBcIlwiO1xyXG5cclxuICBjb25zdCBzZWNjaW9uZXNPcmRlbmFkYXMgPSBbLi4uKHNlY2Npb25lcyB8fCBbXSldLnNvcnQoXHJcbiAgICAoYSwgYikgPT4gKE51bWJlcihhPy5vcmRlbikgfHwgMCkgLSAoTnVtYmVyKGI/Lm9yZGVuKSB8fCAwKVxyXG4gICk7XHJcblxyXG5cclxuICBjb25zdCBodG1sU2VjY2lvbmVzID0gc2VjY2lvbmVzT3JkZW5hZGFzXHJcbiAgICAubWFwKChzZWNjaW9uKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vZG8gPSBTdHJpbmcoc2VjY2lvbj8uYWx0b01vZG8gfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGNvbnN0IGhiYXNlID0gTnVtYmVyLmlzRmluaXRlKHNlY2Npb24/LmFsdHVyYSkgPyBOdW1iZXIoc2VjY2lvbi5hbHR1cmEpIDogNjAwO1xyXG5cclxuICAgICAgY29uc3Qgb2Jqc0RlU2VjY2lvbiA9IG9iamV0b3MuZmlsdGVyKChvKSA9PiBvLnNlY2Npb25JZCA9PT0gc2VjY2lvbi5pZCk7XHJcblxyXG4gICAgICBjb25zdCBvYmpzQmxlZWQgPSBvYmpzRGVTZWNjaW9uLmZpbHRlcihcclxuICAgICAgICAobykgPT4gU3RyaW5nKG8/LmFuY2xhamUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJmdWxsYmxlZWRcIlxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBvYmpzQ29udGVuaWRvID0gb2Jqc0RlU2VjY2lvbi5maWx0ZXIoXHJcbiAgICAgICAgKG8pID0+IFN0cmluZyhvPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgIT09IFwiZnVsbGJsZWVkXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGZvbmRvU3R5bGUgPSBidWlsZEZvbmRvU3R5bGUoc2VjY2lvbik7XHJcblxyXG4gICAgICBjb25zdCBodG1sQmxlZWQgPSBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyhvYmpzQmxlZWQsIHNlY2Npb25lc09yZGVuYWRhcyk7XHJcbiAgICAgIGNvbnN0IGh0bWxDb250ZW5pZG8gPSBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyhvYmpzQ29udGVuaWRvLCBzZWNjaW9uZXNPcmRlbmFkYXMpO1xyXG5cclxuXHJcbiAgICAgIHJldHVybiBgXHJcbjxzZWN0aW9uIGNsYXNzPVwic2VjXCIgZGF0YS1tb2RvPVwiJHtlc2NhcGVBdHRyKG1vZG8pfVwiIHN0eWxlPVwiLS1oYmFzZToke2hiYXNlfVwiPlxyXG4gIDxkaXYgY2xhc3M9XCJzZWMtem9vbVwiPlxyXG4gICAgPGRpdiBjbGFzcz1cInNlYy1iZ1wiIHN0eWxlPVwiJHtmb25kb1N0eWxlfVwiPjwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cInNlYy1ibGVlZFwiPiR7aHRtbEJsZWVkfTwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cInNlYy1jb250ZW50XCI+JHtodG1sQ29udGVuaWRvfTwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L3NlY3Rpb24+XHJcbmAudHJpbSgpO1xyXG4gICAgfSlcclxuICAgIC5qb2luKFwiXFxuXCIpO1xyXG5cclxuICBjb25zdCBzY3JpcHRNb2JpbGVTbWFydCA9IGJ1aWxkTW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0U2NyaXB0KHtcclxuICAgIGVuYWJsZWQ6IEVOQUJMRV9NT0JJTEVfU01BUlRfTEFZT1VULFxyXG4gICAgbWluR2FwUHg6IDEsXHJcbiAgICBwYWRkaW5nVG9wUHg6IDAsXHJcbiAgICBwYWRkaW5nQm90dG9tUHg6IDIsXHJcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogdHJ1ZSxcclxuICAgIG1pblBlckNvbHVtbjI6IDEsXHJcbiAgICBmaXRNaW5TY2FsZTogMC44OCxcclxuICAgIGZpdE1heFNjYWxlOiAxLjE2LFxyXG4gICAgZml0VGFyZ2V0V2lkdGhSYXRpbzogMC45NCxcclxuICAgIGZpdE1pbkZpbGxSYXRpbzogMC45LFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gYFxyXG48IURPQ1RZUEUgaHRtbD5cclxuPGh0bWwgbGFuZz1cImVzXCIke3NsdWcgPyBgIGRhdGEtc2x1Zz1cIiR7ZXNjYXBlQXR0cihzbHVnKX1cImAgOiBcIlwifT5cclxuPGhlYWQ+XHJcbiAgPG1ldGEgY2hhcnNldD1cIlVURi04XCIgLz5cclxuICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCwgdmlld3BvcnQtZml0PWNvdmVyXCIgLz5cclxuICA8dGl0bGU+SW52aXRhY2nDs248L3RpdGxlPlxyXG4gICR7Z29vZ2xlRm9udHNMaW5rfVxyXG4gIDxzdHlsZT5cclxuICAgICogeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IH1cclxuXHJcbiAgICBodG1sLCBib2R5IHtcclxuICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcclxuICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFNPTE8gTU9CSUxFOiBldml0YSDigJxhdXRvLXJlc2l6ZSAvIGZvbnQgYm9vc3RpbmfigJ0gZGVsIHRleHRvICovXHJcbiAgICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpe1xyXG4gICAgICBodG1se1xyXG4gICAgICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcclxuICAgICAgICB0ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgIDpyb290eyAtLXRleHQtem9vbTogMTsgfVxuICAgIH1cclxuXHJcbiAgICA6cm9vdHtcclxuICAgICAgLS1zYWZlLXRvcDogZW52KHNhZmUtYXJlYS1pbnNldC10b3AsIDBweCk7XHJcbiAgICAgIC0tc2FmZS1yaWdodDogZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KTtcclxuICAgICAgLS1zYWZlLWJvdHRvbTogZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20sIDBweCk7XHJcbiAgICAgIC0tc2FmZS1sZWZ0OiBlbnYoc2FmZS1hcmVhLWluc2V0LWxlZnQsIDBweCk7XHJcbiAgICAgIC0tYnAtbW9iaWxlOiA3NjdweDtcclxuICAgICAgXHJcblxyXG5cclxuICAgICAgLyogR2xvYmFsIHNjYWxlcyAqL1xyXG4gICAgICAtLWNvbnRlbnQtdzogJHtDQU5WQVNfQkFTRS5BTkNIT31weDtcclxuICAgICAgLS1zeDogMTsgICAvKiBjb250ZW50Vy84MDAgKi9cclxuICAgICAgLS1ieDogMTsgICAvKiB2aWV3cG9ydFcvODAwICovXHJcblxyXG4gICAgICAvKiB2aCBsw7NnaWNvIHBvciBkZWZlY3RvICovXHJcbiAgICAgIC0tdmgtc2FmZTogMTAwdmg7XHJcbiAgICAgIC0tdmgtbG9naWNhbDogdmFyKC0tdmgtc2FmZSk7XHJcbiAgICAgIC0tcGFudGFsbGEteS1jb21wYWN0OiAwO1xyXG5cclxuICAgICAgLyog4pyFIE9mZnNldCBTT0xPIHBhcmEgdGV4dG8gZW4gUGFudGFsbGE6IE9OIChkZXNrdG9wIGRlZmF1bHQpICovXHJcbiAgICAgIC0tcGFudGFsbGEteS1vZmZzZXQ6ICR7UEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWH1weDtcclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgTW9iaWxlOiBvZmZzZXQgZGlzdGludG8gU09MTyBwYXJhIHRleHRvIGVuIFBhbnRhbGxhOiBPTiAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgOnJvb3R7XHJcbiAgICAgICAgLS1wYW50YWxsYS15LW9mZnNldDogJHtQQU5UQUxMQV9ZX09GRlNFVF9NT0JJTEVfUFh9cHg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAuaW52eyB3aWR0aDogMTAwJTsgYmFja2dyb3VuZDogd2hpdGU7IH1cclxuXHJcbiAgICAuc2Vje1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHdpZHRoOiAxMDB2dztcclxuICAgICAgbGVmdDogNTAlO1xyXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XHJcbiAgICAgIG92ZXJmbG93OiB2aXNpYmxlOyAvKiBibGVlZCBwdWVkZSBzYWxpcnNlICovXHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFdyYXBwZXIgcXVlIGhhY2Ug4oCcem9vbeKAnSBjZW50cmFkbyAoZXZpdGEgY29ycmltaWVudG8gYSBsYSBkZXJlY2hhKSAqL1xyXG4gICAgLnNlYy16b29te1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBjZW50ZXI7XHJcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tem9vbSwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBQYW50YWxsYSBPTjogcmVjb3J0ZSBwYXJhIHF1ZSBlbCB6b29tIG5vIGRlc2JvcmRlICovXHJcbiAgICAuc2VjW2RhdGEtbW9kbz1cInBhbnRhbGxhXCJde1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICBoZWlnaHQ6IDEwMGR2aDtcclxuICAgICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgICAgcGFkZGluZy10b3A6IHZhcigtLXNhZmUtdG9wKTtcclxuICAgICAgcGFkZGluZy1ib3R0b206IHZhcigtLXNhZmUtYm90dG9tKTtcclxuXHJcbiAgICAgIC8qIGZhbGxiYWNrIENTUyAoSlMgbG8gcGlzYSBlbiBtb2JpbGUgY29uIHB4IHJlYWxlcykgKi9cclxuICAgICAgLS12aC1zYWZlOiBjYWxjKDEwMGR2aCAtIHZhcigtLXNhZmUtdG9wKSAtIHZhcigtLXNhZmUtYm90dG9tKSk7XHJcblxyXG4gICAgICAvKiBlbCB6b29tIGV4dHJhIHZhIHBvciAtLXpvb20gKE5PIHBvciBzZmluYWwpICovXHJcbiAgICAgIC0tem9vbTogMTtcclxuICAgICAgLS1iZ3pvb206IDE7XHJcblxyXG4gICAgICAvKiBmYWN0b3IgZmluYWwgcGFyYSBDT05URU5JRE8gKHNlIHNldGVhIHBvciBKUykgKi9cclxuICAgICAgLS1zZmluYWw6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJmaWpvXCJde1xyXG4gICAgICAvKiBhbHR1cmEgZmlqYSBlc2NhbGFkYSBwb3IgYW5jaG87IEpTIHNldGVhIC0tc2ZpbmFsID0gc3ggKi9cclxuICAgICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNmaW5hbCkgKiB2YXIoLS1oYmFzZSkgKiAxcHgpO1xyXG4gICAgICAtLXpvb206IDE7XHJcbiAgICAgIC0tYmd6b29tOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEZvbmRvICovXHJcbiAgICAuc2VjLWJne1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIGluc2V0OiAwO1xyXG4gICAgICB6LWluZGV4OiAwO1xyXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgRm9uZG8gYWdyYW5kYWJsZSBzb2xvIGVuIHBhbnRhbGxhIChhY29tcGHDsWEgZWwgem9vbSBoZXJvKSAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWJne1xyXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWJnem9vbSwgMSkpO1xyXG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLnNlYy1ibGVlZHtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICBpbnNldDogMDtcclxuICAgICAgei1pbmRleDogMjtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5zZWMtY29udGVudHtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICB6LWluZGV4OiAzO1xyXG4gICAgICB3aWR0aDogdmFyKC0tY29udGVudC13KTtcclxuICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiBlbCBhbmNobyBkZWwg4oCcY29udGVudOKAnSBwdWVkZSBjcmVjZXIgY29uIGxhIGVzY2FsYSB2ZXJ0aWNhbCAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWNvbnRlbnR7XHJcbiAgICAgIHdpZHRoOiB2YXIoLS1jb250ZW50LXctcGFudGFsbGEsIHZhcigtLWNvbnRlbnQtdykpO1xyXG4gICAgfVxyXG5cclxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCl7XHJcbiAgICAgIC5zZWMtY29udGVudHtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNhZmUtbGVmdCk7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2FmZS1yaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAub2JqZXRve1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0b1tkYXRhLWRlYnVnLXRleHRvPVwiMVwiXXtcclxuICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XHJcbiAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0by5pcy1pbnRlcmFjdGl2ZXsgcG9pbnRlci1ldmVudHM6IGF1dG87IH1cclxuXHJcbiAgICAuY2QtY2hpcCB7IGJhY2tkcm9wLWZpbHRlcjogc2F0dXJhdGUoMS4xKTsgfVxyXG4gIDwvc3R5bGU+XHJcbjwvaGVhZD5cclxuXHJcbjxib2R5IGRhdGEtbG9hZGVyLXJlYWR5PVwiMFwiIGRhdGEtc2x1Zz1cIiR7ZXNjYXBlQXR0cihzbHVnUHVibGljYSl9XCI+XHJcbiAgJHtpbnZpdGF0aW9uTG9hZGVyUnVudGltZX1cclxuICA8ZGl2IGNsYXNzPVwiaW52XCI+XHJcbiAgICAke2h0bWxTZWNjaW9uZXN9XHJcbiAgPC9kaXY+XHJcblxyXG4gICR7Ym90b25SU1ZQfVxyXG4gICR7bW9kYWxSU1ZQfVxyXG4gICR7bW9kYWxHYWxlcmlhfVxyXG4gICR7bW90aW9uRWZmZWN0c1J1bnRpbWV9XHJcblxyXG4gICR7c2NyaXB0Q291bnRkb3dufVxyXG5cclxuICA8c2NyaXB0PlxyXG4gICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZ1bmN0aW9uIGNsYW1wKG4sIGEsIGIpeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgbikpOyB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wdXRlKCl7XHJcbiAgICAgICAgdmFyIHZ3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBCQVNFX1cgPSA4MDA7IC8vID0gQ0FOVkFTX0JBU0UuQU5DSE9cclxuXHJcbiAgICAgICAgLy8gY29udGVudFcgKHNpbiB2dy0zMilcclxuICAgICAgICB2YXIgY29udGVudFcgPSBNYXRoLm1pbihCQVNFX1csIHZ3KTtcclxuXHJcbiAgICAgICAgdmFyIHN4ID0gY29udGVudFcgLyBCQVNFX1c7XHJcbiAgICAgICAgdmFyIGJ4ID0gdncgLyBCQVNFX1c7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tY29udGVudC13XCIsIGNvbnRlbnRXICsgXCJweFwiKTtcclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXN4XCIsIFN0cmluZyhzeCkpO1xyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYnhcIiwgU3RyaW5nKGJ4KSk7XHJcblxyXG4gICAgICAgIHZhciBzZWNzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSk7XHJcbiAgICAgICAgdmFyIGlzTW9iaWxlID0gdncgPD0gNzY3O1xyXG5cclxuICAgICAgICAvLyB2aWV3cG9ydCByZWFsIChtw6FzIGVzdGFibGUgZW4gbW9iaWxlKVxyXG4gICAgICAgIHZhciB2diA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcclxuICAgICAgICB2YXIgdmlld3BvcnRIID0gKHZ2ICYmIHZ2LmhlaWdodCkgPyB2di5oZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHNhZmUgYXJlYXMgKGNzcyBlbnYpXHJcbiAgICAgICAgdmFyIHNhZmVUb3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zYWZlLXRvcFwiKSkgfHwgMDtcclxuICAgICAgICB2YXIgc2FmZUJvdHRvbSA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCItLXNhZmUtYm90dG9tXCIpKSB8fCAwO1xyXG5cclxuICAgICAgICAvLyBkaXNlw7FvIGJhc2UgZGVsIG1vZG8gXCJwYW50YWxsYVwiICg4MDAgeCA1MDApXHJcbiAgICAgICAgdmFyIERFU0lHTl9XID0gQkFTRV9XO1xyXG4gICAgICAgIHZhciBERVNJR05fSCA9ICR7QUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEF9OyAvLyA9IEFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBXHJcbiAgICAgICAgdmFyIGRlc2lnbkFSID0gREVTSUdOX0ggLyBERVNJR05fVzsgLy8gMC42MjVcclxuICAgICAgICB2YXIgZGV2aWNlQVIgPSB2aWV3cG9ydEggLyB2dztcclxuXHJcbiAgICAgICAgLy8gem9vbSBleHRyYSAoc29sbyBzaSBlbCBkZXZpY2UgZXMgbcOhcyB2ZXJ0aWNhbCBxdWUgZWwgZGlzZcOxbylcclxuICAgICAgICB2YXIgem9vbUV4dHJhID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGUgJiYgZGV2aWNlQVIgPiBkZXNpZ25BUil7XHJcbiAgICAgICAgICB2YXIgayA9IGRldmljZUFSIC8gZGVzaWduQVI7XHJcbiAgICAgICAgICB6b29tRXh0cmEgPSBjbGFtcCgxICsgKGsgLSAxKSAqIDAuMTgsIDEsIDEuMzUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g8J+UpyBBanVzdGUgZmlubzogY3XDoW50byBhY29tcGHDsWEgZWwgZm9uZG8gYWwgem9vbSBoZXJvICgwLi4xLjIpXHJcbiAgICAgICAgLy8gMCAgID0+IGVsIGZvbmRvIE5PIGFncmVnYSB6b29tIGV4dHJhIHByb3BpbyAoc29sbyBlbCB6b29tIGRlbCB3cmFwcGVyKVxyXG4gICAgICAgIC8vIDEgICA9PiBjb21wb3J0YW1pZW50byBhY3R1YWwgKGZvbmRvIHF1ZWRhIHpvb21FeHRyYcKyKVxyXG4gICAgICAgIC8vIDAuMyA9PiByZWNvbWVuZGFkbyBwYXJhIGVtcGV6YXIgKHN1dGlsKVxyXG4gICAgICAgIHZhciBCR19aT09NX0ZBQ1RPUiA9IDA7XHJcblxyXG4gICAgICAgIC8vIPCflKcgQWp1c3RlIGZpbm86IGN1w6FudG8gYWNvbXBhw7FhIGVsIENPTlRFTklETyAodGV4dG8vb2JqZXRvcykgYWwgem9vbSBoZXJvXHJcbiAgICAgICAgLy8gMCAgID0+IGNvbXBvcnRhbWllbnRvIGFjdHVhbFxyXG4gICAgICAgIC8vIDAuMyA9PiByZWNvbWVuZGFkb1xyXG4gICAgICAgIC8vIDEgICA9PiB0ZXh0byBlc2NhbGEgaWd1YWwgcXVlIGVsIGhlcm8gKG5vIGFjb25zZWphZG8pXHJcbiAgICAgICAgdmFyIFRFWFRfWk9PTV9GQUNUT1IgPSAwO1xyXG5cclxuXHJcbiAgICAgICAgc2Vjcy5mb3JFYWNoKGZ1bmN0aW9uKHNlYyl7XHJcbiAgICAgICAgICB2YXIgbW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgIC8vIGRlZmF1bHRzXHJcbiAgICAgICAgICB2YXIgem9vbSA9IDE7XHJcbiAgICAgICAgICB2YXIgYmd6b29tID0gMTtcclxuXHJcbiAgICAgICAgICAvLyDinIUgUG9yIGRlZmVjdG8sIHRhbWHDsW9zIGVzY2FsYW4gcG9yIGFuY2hvIChjb21wb3J0YW1pZW50byBhY3R1YWwpXHJcbiAgICAgICAgICB2YXIgc2ZpbmFsID0gc3g7XHJcbiAgICAgICAgICB2YXIgcGFudGFsbGFZQ29tcGFjdCA9IDA7XHJcblxyXG4gICAgICAgICAgLy8gbGltcGlhciBjdXN0b20gd2lkdGggc2kgbm8gYXBsaWNhXHJcbiAgICAgICAgICBzZWMuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLWNvbnRlbnQtdy1wYW50YWxsYVwiKTtcclxuXHJcbiAgICAgICAgICBpZiAobW9kbyA9PT0gXCJwYW50YWxsYVwiKXtcclxuICAgICAgICAgICAgLy8gdmgtc2FmZSByZWFsIGVuIHB4XHJcbiAgICAgICAgICAgIHZhciB2aFNhZmVQeCA9IE1hdGgubWF4KDAsIHZpZXdwb3J0SCAtIHNhZmVUb3AgLSBzYWZlQm90dG9tKTtcclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1zYWZlXCIsIHZoU2FmZVB4ICsgXCJweFwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIPCflKUgRGVza3RvcDogZXNjYWxhciBlbCBjb250ZW5pZG8gcG9yIEFMVFVSQSAodmhTYWZlLzUwMClcclxuICAgICAgICAgICAgLy8gRXN0byBhbGluZWEgZWwgSFRNTCBwdWJsaWNhZG8gY29uIGxvIHF1ZSB2ZXMgZW4gcHJldmlld1xyXG4gICAgICAgICAgICBpZiAoIWlzTW9iaWxlKXtcclxuICAgICAgICAgICAgICB2YXIgc2ggPSB2aFNhZmVQeCAvIERFU0lHTl9IO1xyXG4gICAgICAgICAgICAgIHNmaW5hbCA9IHNoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwYXJhIHF1ZSBlbCBcImNvbnRlbnRcIiBxdWVkZSBjZW50cmFkbyB5IGNvaGVyZW50ZSBjb24gbGEgbnVldmEgZXNjYWxhIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1jb250ZW50LXctcGFudGFsbGFcIiwgKERFU0lHTl9XICogc2gpICsgXCJweFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIE1vYmlsZTogbWFudGVuZW1vcyB0dSBjb21wb3J0YW1pZW50byBhY3R1YWwgKHpvb20gaGVybyBzdWF2ZSlcclxuICAgICAgICAgICAgaWYgKGlzTW9iaWxlKXtcclxuICAgICAgICAgICAgICB6b29tID0gem9vbUV4dHJhO1xyXG4gICAgICAgICAgICAgIGJnem9vbSA9IDEgKyAoem9vbUV4dHJhIC0gMSkgKiBCR19aT09NX0ZBQ1RPUjtcclxuXHJcbiAgICAgICAgICAgICAgLy8g8J+UpSBOVUVWTzogZWwgY29udGVuaWRvIGFjb21wYcOxYSBwYXJjaWFsbWVudGUgZWwgem9vbVxyXG4gICAgICAgICAgICAgIHNmaW5hbCA9IHN4ICogKDEgKyAoem9vbUV4dHJhIC0gMSkgKiBURVhUX1pPT01fRkFDVE9SKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8g4pyFIE1vYmlsZSBwYW50YWxsYTogY29tcGFjdGEgZGlzdGFuY2lhIHZlcnRpY2FsIHBhcmEgcHJlc2VydmFyIGxhIGVzZW5jaWFcclxuICAgICAgICAgICAgICAvLyBkZWwgZGlzZcOxbyBlbiBkaXNwb3NpdGl2b3MgbXV5IGFsdG9zLCBtYW50ZW5pZW5kbyB5PTAuNSBjZW50cmFkby5cclxuICAgICAgICAgICAgICB2YXIgdmhMb2dpY2FsUHggPSB2aFNhZmVQeCAvIE1hdGgubWF4KDAuMDEsIHpvb20gfHwgMSk7XHJcbiAgICAgICAgICAgICAgdmFyIGxvZ2ljYWxBUiA9IHZoTG9naWNhbFB4IC8gTWF0aC5tYXgoMSwgdncpO1xyXG4gICAgICAgICAgICAgIHZhciBzdHJldGNoUmF0aW8gPSAobG9naWNhbEFSIC8gTWF0aC5tYXgoMC4wMSwgZGVzaWduQVIpKSAtIDE7XHJcbiAgICAgICAgICAgICAgcGFudGFsbGFZQ29tcGFjdCA9IGNsYW1wKHN0cmV0Y2hSYXRpbyAqIDAuMTIsIDAsIDAuNDUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1zZmluYWxcIiwgU3RyaW5nKHNmaW5hbCkpO1xyXG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS16b29tXCIsIFN0cmluZyh6b29tKSk7XHJcbiAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLWJnem9vbVwiLCBTdHJpbmcoYmd6b29tKSk7XHJcblxyXG4gICAgICAgICAgLy8g4pyFIFNvbG8gZW4gbW9iaWxlICsgcGFudGFsbGE6IGNvcnJlZ2lyIGVsIFwidmhcIiBxdWUgZGVzcHXDqXMgc2UgZXNjYWxhIGNvbiB6b29tXHJcbiAgICAgICAgICBpZiAoaXNNb2JpbGUgJiYgbW9kbyA9PT0gXCJwYW50YWxsYVwiKSB7XHJcbiAgICAgICAgICAgIC8vIC0tdmgtbG9naWNhbCA9IC0tdmgtc2FmZSAvIC0tem9vbVxyXG4gICAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXZoLWxvZ2ljYWxcIiwgXCJjYWxjKHZhcigtLXZoLXNhZmUpIC8gdmFyKC0tem9vbSkpXCIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVzdG86IHNlIGNvbXBvcnRhIGNvbW8gc2llbXByZVxyXG4gICAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXZoLWxvZ2ljYWxcIiwgXCJ2YXIoLS12aC1zYWZlKVwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcGFudGFsbGEteS1jb21wYWN0XCIsIFN0cmluZyhwYW50YWxsYVlDb21wYWN0KSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXB1dGUpO1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjb21wdXRlKTtcclxuXHJcbiAgICAgIGlmICh3aW5kb3cudmlzdWFsVmlld3BvcnQpe1xyXG4gICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNvbXB1dGUpO1xyXG4gICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGNvbXB1dGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgc2V0VGltZW91dChjb21wdXRlLCA1MCk7XHJcbiAgICAgICAgc2V0VGltZW91dChjb21wdXRlLCAyNTApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbXB1dGUoKTtcclxuICAgIH0pKCk7XHJcbiAgPC9zY3JpcHQ+XHJcblxyXG4gICAgXHJcblxyXG5cclxuICAgJHtzY3JpcHRNb2JpbGVTbWFydH1cclxuIFxyXG48L2JvZHk+XHJcbjwvaHRtbD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MiLCJDQU5WQVNfQkFTRSIsImdlbmVyYXJNb2RhbFJTVlBIVE1MIiwiZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwiLCJoYXlHYWxlcmlhQ29uSW1hZ2VuZXMiLCJidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCIsImdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwiLCJnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIiwiRU5BQkxFX01PQklMRV9TTUFSVF9MQVlPVVQiLCJFWENMVURFX0ZPTlRTIiwiU2V0IiwiQUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEEiLCJQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYIiwiUEFOVEFMTEFfWV9PRkZTRVRfTU9CSUxFX1BYIiwiYnVpbGRHb29nbGVGb250c0xpbmsiLCJmb250cyIsImZhbWlsaWFzIiwibWFwIiwiZiIsInJlcGxhY2UiLCJzcGxpdCIsInRyaW0iLCJmaWx0ZXIiLCJuIiwiaGFzIiwiam9pbiIsImVzY2FwZUF0dHIiLCJzdHIiLCJTdHJpbmciLCJidWlsZEZvbmRvU3R5bGUiLCJzZWNjaW9uIiwiZm9uZG9WYWx1ZSIsImZvbmRvIiwiZXNJbWFnZW5Gb25kbyIsImZvbmRvVGlwbyIsImZvbmRvSW1hZ2VuIiwiZXN0aWxvc0ZvbmRvIiwiaW1hZ2VVcmwiLCJpbmNsdWRlcyIsImJhY2tncm91bmRQb3NpdGlvbiIsImZvbmRvSW1hZ2VuT2Zmc2V0WCIsInVuZGVmaW5lZCIsImZvbmRvSW1hZ2VuT2Zmc2V0WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwib2Zmc2V0WFBlcmNlbnQiLCJvZmZzZXRZUGVyY2VudCIsInN0YXJ0c1dpdGgiLCJnZW5lcmFySFRNTERlc2RlU2VjY2lvbmVzIiwic2VjY2lvbmVzIiwib2JqZXRvcyIsInJzdnAiLCJvcGNpb25lcyIsIm9wdHMiLCJzbHVnIiwic2x1Z1B1YmxpY2EiLCJmdWVudGVzVXNhZGFzIiwibyIsInRpcG8iLCJmb250RmFtaWx5IiwiZ29vZ2xlRm9udHNMaW5rIiwiaGF5UlNWUEVuQ2FudmFzIiwic29tZSIsImJvdG9uUlNWUCIsIm1vZGFsUlNWUCIsImVuYWJsZWQiLCJtb2RhbEdhbGVyaWEiLCJpbnZpdGF0aW9uTG9hZGVyUnVudGltZSIsIm1vdGlvbkVmZmVjdHNSdW50aW1lIiwiaGF5Q291bnRkb3duIiwib2JqcyIsIkFycmF5IiwiaXNBcnJheSIsInNjcmlwdENvdW50ZG93biIsInNlY2Npb25lc09yZGVuYWRhcyIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm9yZGVuIiwiaHRtbFNlY2Npb25lcyIsIm1vZG8iLCJhbHRvTW9kbyIsInRvTG93ZXJDYXNlIiwiaGJhc2UiLCJpc0Zpbml0ZSIsImFsdHVyYSIsIm9ianNEZVNlY2Npb24iLCJzZWNjaW9uSWQiLCJpZCIsIm9ianNCbGVlZCIsImFuY2xhamUiLCJvYmpzQ29udGVuaWRvIiwiZm9uZG9TdHlsZSIsImh0bWxCbGVlZCIsImh0bWxDb250ZW5pZG8iLCJzY3JpcHRNb2JpbGVTbWFydCIsIm1pbkdhcFB4IiwicGFkZGluZ1RvcFB4IiwicGFkZGluZ0JvdHRvbVB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJtaW5QZXJDb2x1bW4yIiwiZml0TWluU2NhbGUiLCJmaXRNYXhTY2FsZSIsImZpdFRhcmdldFdpZHRoUmF0aW8iLCJmaXRNaW5GaWxsUmF0aW8iLCJBTkNITyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarHTMLDesdeSecciones.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarInvitationLoaderRuntime.ts":
/*!***************************************************************!*\
  !*** ./functions/src/utils/generarInvitationLoaderRuntime.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarInvitationLoaderRuntimeHTML: () => (/* binding */ generarInvitationLoaderRuntimeHTML)\n/* harmony export */ });\nfunction generarInvitationLoaderRuntimeHTML() {\n    return `\n<style>\n  body[data-loader-ready=\"0\"] {\n    overflow: hidden;\n  }\n\n  body[data-loader-ready=\"0\"] .inv {\n    opacity: 0;\n  }\n\n  body[data-loader-ready=\"1\"] .inv {\n    opacity: 1;\n    transition: opacity 360ms ease;\n  }\n\n  .inv-loader {\n    position: fixed;\n    inset: 0;\n    z-index: 9999;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 18px;\n    background:\n      radial-gradient(120% 90% at 80% 20%, rgba(255, 223, 236, 0.42) 0%, rgba(255, 223, 236, 0) 62%),\n      radial-gradient(120% 90% at 14% 82%, rgba(239, 208, 255, 0.34) 0%, rgba(239, 208, 255, 0) 66%),\n      linear-gradient(180deg, #fffafc 0%, #fff 100%);\n    transition: opacity 420ms ease, visibility 420ms ease;\n  }\n\n  .inv-loader--exit {\n    opacity: 0;\n    visibility: hidden;\n    pointer-events: none;\n  }\n\n  .inv-loader__stage {\n    position: relative;\n    width: 112px;\n    height: 112px;\n    display: grid;\n    place-items: center;\n  }\n\n  .inv-loader__halo {\n    position: absolute;\n    inset: 10px;\n    border-radius: 999px;\n    background: radial-gradient(circle, rgba(255, 255, 255, 0.98) 0%, rgba(249, 206, 224, 0.74) 56%, rgba(244, 175, 204, 0.28) 100%);\n    box-shadow:\n      0 12px 30px rgba(230, 123, 168, 0.24),\n      inset 0 0 0 1px rgba(255, 255, 255, 0.64);\n    animation: invLoaderHalo 2.3s ease-in-out infinite;\n  }\n\n  .inv-loader__ring {\n    position: absolute;\n    inset: 0;\n    border-radius: 999px;\n    border: 2px solid rgba(221, 126, 165, 0.2);\n    border-top-color: rgba(211, 70, 130, 0.84);\n    border-right-color: rgba(233, 145, 179, 0.58);\n    animation: invLoaderSpin 1.15s linear infinite;\n  }\n\n  .inv-loader__heart {\n    width: 34px;\n    height: 34px;\n    display: block;\n    animation: invLoaderBeat 1.4s ease-in-out infinite;\n  }\n\n  .inv-loader__heart-svg {\n    width: 100%;\n    height: 100%;\n    display: block;\n  }\n\n  .inv-loader__heart-path {\n    fill: none;\n    stroke: #cf4f89;\n    stroke-width: 2.15;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    filter: drop-shadow(0 3px 8px rgba(216, 61, 124, 0.18));\n  }\n\n  .inv-loader__label {\n    margin: 0;\n    font-family: \"Playfair Display\", Georgia, serif;\n    font-size: 16px;\n    letter-spacing: 0.2px;\n    color: #6d2a53;\n    text-align: center;\n  }\n\n  @keyframes invLoaderSpin {\n    to {\n      transform: rotate(360deg);\n    }\n  }\n\n  @keyframes invLoaderHalo {\n    0%, 100% {\n      transform: scale(0.98);\n      opacity: 0.86;\n    }\n    50% {\n      transform: scale(1.02);\n      opacity: 1;\n    }\n  }\n\n  @keyframes invLoaderBeat {\n    0%, 100% {\n      transform: rotate(-45deg) scale(1);\n    }\n    42% {\n      transform: rotate(-45deg) scale(1.12);\n    }\n    64% {\n      transform: rotate(-45deg) scale(0.98);\n    }\n  }\n\n  @media (max-width: 767px) {\n    .inv-loader__stage {\n      width: 96px;\n      height: 96px;\n    }\n\n    .inv-loader__heart {\n      width: 30px;\n      height: 30px;\n    }\n\n    .inv-loader__label {\n      font-size: 14px;\n    }\n  }\n\n  @media (prefers-reduced-motion: reduce) {\n    .inv-loader__halo,\n    .inv-loader__ring,\n    .inv-loader__heart {\n      animation: none !important;\n    }\n  }\n</style>\n\n<div id=\"inv-loader\" class=\"inv-loader\" role=\"status\" aria-live=\"polite\" aria-label=\"Cargando invitacion\">\n  <div class=\"inv-loader__stage\">\n    <span class=\"inv-loader__halo\" aria-hidden=\"true\"></span>\n    <span class=\"inv-loader__ring\" aria-hidden=\"true\"></span>\n    <span class=\"inv-loader__heart\" aria-hidden=\"true\">\n      <svg class=\"inv-loader__heart-svg\" viewBox=\"0 0 24 24\" aria-hidden=\"true\" focusable=\"false\">\n        <path\n          class=\"inv-loader__heart-path\"\n          d=\"M12 20.2c-.2 0-.4-.1-.5-.2C8.5 17.4 3 13.3 3 8.5 3 5.8 5.1 3.8 7.7 3.8c1.6 0 3.1.8 4.1 2.2 1-1.4 2.5-2.2 4.1-2.2C18.5 3.8 20.6 5.8 20.6 8.5c0 4.8-5.5 8.9-8.5 11.5-.1.1-.3.2-.5.2z\"\n        />\n      </svg>\n    </span>\n  </div>\n  <p class=\"inv-loader__label\">Preparando invitacion...</p>\n</div>\n\n<script>\n(function(){\n  var RUNTIME_READY_EVENT = \"invitation-runtime-ready\";\n  var RUNTIME_FAIL_EVENT = \"invitation-runtime-failed\";\n  var LOADER_HIDDEN_EVENT = \"invitation-loader-hidden\";\n  var MAX_WAIT_MS = 10000;\n  var closed = false;\n\n  function dispatchLoaderEvent(name){\n    try {\n      window.dispatchEvent(new CustomEvent(name));\n    } catch (_error) {\n      // noop\n    }\n  }\n\n  function closeLoader(){\n    if (closed) return;\n    closed = true;\n\n    if (document.body) {\n      document.body.setAttribute(\"data-loader-ready\", \"1\");\n    }\n\n    var loader = document.getElementById(\"inv-loader\");\n    if (!loader) return;\n\n    loader.classList.add(\"inv-loader--exit\");\n    window.setTimeout(function(){\n      if (loader.parentNode) {\n        loader.parentNode.removeChild(loader);\n      }\n      dispatchLoaderEvent(LOADER_HIDDEN_EVENT);\n    }, 520);\n  }\n\n  function armEvents(){\n    if (document.body) {\n      document.body.setAttribute(\"data-loader-ready\", \"0\");\n    }\n\n    window.addEventListener(RUNTIME_READY_EVENT, closeLoader, { once: true });\n    window.addEventListener(RUNTIME_FAIL_EVENT, closeLoader, { once: true });\n\n    window.setTimeout(closeLoader, MAX_WAIT_MS);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", armEvents, { once: true });\n  } else {\n    armEvents();\n  }\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2TlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG48c3R5bGU+XG4gIGJvZHlbZGF0YS1sb2FkZXItcmVhZHk9XCIwXCJdIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICB9XG5cbiAgYm9keVtkYXRhLWxvYWRlci1yZWFkeT1cIjBcIl0gLmludiB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuXG4gIGJvZHlbZGF0YS1sb2FkZXItcmVhZHk9XCIxXCJdIC5pbnYge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAzNjBtcyBlYXNlO1xuICB9XG5cbiAgLmludi1sb2FkZXIge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBpbnNldDogMDtcbiAgICB6LWluZGV4OiA5OTk5O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogMThweDtcbiAgICBiYWNrZ3JvdW5kOlxuICAgICAgcmFkaWFsLWdyYWRpZW50KDEyMCUgOTAlIGF0IDgwJSAyMCUsIHJnYmEoMjU1LCAyMjMsIDIzNiwgMC40MikgMCUsIHJnYmEoMjU1LCAyMjMsIDIzNiwgMCkgNjIlKSxcbiAgICAgIHJhZGlhbC1ncmFkaWVudCgxMjAlIDkwJSBhdCAxNCUgODIlLCByZ2JhKDIzOSwgMjA4LCAyNTUsIDAuMzQpIDAlLCByZ2JhKDIzOSwgMjA4LCAyNTUsIDApIDY2JSksXG4gICAgICBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCAjZmZmYWZjIDAlLCAjZmZmIDEwMCUpO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgNDIwbXMgZWFzZSwgdmlzaWJpbGl0eSA0MjBtcyBlYXNlO1xuICB9XG5cbiAgLmludi1sb2FkZXItLWV4aXQge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX3N0YWdlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDExMnB4O1xuICAgIGhlaWdodDogMTEycHg7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBwbGFjZS1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2hhbG8ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBpbnNldDogMTBweDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcbiAgICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTgpIDAlLCByZ2JhKDI0OSwgMjA2LCAyMjQsIDAuNzQpIDU2JSwgcmdiYSgyNDQsIDE3NSwgMjA0LCAwLjI4KSAxMDAlKTtcbiAgICBib3gtc2hhZG93OlxuICAgICAgMCAxMnB4IDMwcHggcmdiYSgyMzAsIDEyMywgMTY4LCAwLjI0KSxcbiAgICAgIGluc2V0IDAgMCAwIDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNjQpO1xuICAgIGFuaW1hdGlvbjogaW52TG9hZGVySGFsbyAyLjNzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX3Jpbmcge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBpbnNldDogMDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcbiAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDIyMSwgMTI2LCAxNjUsIDAuMik7XG4gICAgYm9yZGVyLXRvcC1jb2xvcjogcmdiYSgyMTEsIDcwLCAxMzAsIDAuODQpO1xuICAgIGJvcmRlci1yaWdodC1jb2xvcjogcmdiYSgyMzMsIDE0NSwgMTc5LCAwLjU4KTtcbiAgICBhbmltYXRpb246IGludkxvYWRlclNwaW4gMS4xNXMgbGluZWFyIGluZmluaXRlO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2hlYXJ0IHtcbiAgICB3aWR0aDogMzRweDtcbiAgICBoZWlnaHQ6IDM0cHg7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgYW5pbWF0aW9uOiBpbnZMb2FkZXJCZWF0IDEuNHMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gIH1cblxuICAuaW52LWxvYWRlcl9faGVhcnQtc3ZnIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cblxuICAuaW52LWxvYWRlcl9faGVhcnQtcGF0aCB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNjZjRmODk7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjE1O1xuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xuICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMCAzcHggOHB4IHJnYmEoMjE2LCA2MSwgMTI0LCAwLjE4KSk7XG4gIH1cblxuICAuaW52LWxvYWRlcl9fbGFiZWwge1xuICAgIG1hcmdpbjogMDtcbiAgICBmb250LWZhbWlseTogXCJQbGF5ZmFpciBEaXNwbGF5XCIsIEdlb3JnaWEsIHNlcmlmO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsZXR0ZXItc3BhY2luZzogMC4ycHg7XG4gICAgY29sb3I6ICM2ZDJhNTM7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG5cbiAgQGtleWZyYW1lcyBpbnZMb2FkZXJTcGluIHtcbiAgICB0byB7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgaW52TG9hZGVySGFsbyB7XG4gICAgMCUsIDEwMCUge1xuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk4KTtcbiAgICAgIG9wYWNpdHk6IDAuODY7XG4gICAgfVxuICAgIDUwJSB7XG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDIpO1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIGludkxvYWRlckJlYXQge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZykgc2NhbGUoMSk7XG4gICAgfVxuICAgIDQyJSB7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpIHNjYWxlKDEuMTIpO1xuICAgIH1cbiAgICA2NCUge1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKSBzY2FsZSgwLjk4KTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICAuaW52LWxvYWRlcl9fc3RhZ2Uge1xuICAgICAgd2lkdGg6IDk2cHg7XG4gICAgICBoZWlnaHQ6IDk2cHg7XG4gICAgfVxuXG4gICAgLmludi1sb2FkZXJfX2hlYXJ0IHtcbiAgICAgIHdpZHRoOiAzMHB4O1xuICAgICAgaGVpZ2h0OiAzMHB4O1xuICAgIH1cblxuICAgIC5pbnYtbG9hZGVyX19sYWJlbCB7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpIHtcbiAgICAuaW52LWxvYWRlcl9faGFsbyxcbiAgICAuaW52LWxvYWRlcl9fcmluZyxcbiAgICAuaW52LWxvYWRlcl9faGVhcnQge1xuICAgICAgYW5pbWF0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2IGlkPVwiaW52LWxvYWRlclwiIGNsYXNzPVwiaW52LWxvYWRlclwiIHJvbGU9XCJzdGF0dXNcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIiBhcmlhLWxhYmVsPVwiQ2FyZ2FuZG8gaW52aXRhY2lvblwiPlxuICA8ZGl2IGNsYXNzPVwiaW52LWxvYWRlcl9fc3RhZ2VcIj5cbiAgICA8c3BhbiBjbGFzcz1cImludi1sb2FkZXJfX2hhbG9cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJpbnYtbG9hZGVyX19yaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaW52LWxvYWRlcl9faGVhcnRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgIDxzdmcgY2xhc3M9XCJpbnYtbG9hZGVyX19oZWFydC1zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzcz1cImludi1sb2FkZXJfX2hlYXJ0LXBhdGhcIlxuICAgICAgICAgIGQ9XCJNMTIgMjAuMmMtLjIgMC0uNC0uMS0uNS0uMkM4LjUgMTcuNCAzIDEzLjMgMyA4LjUgMyA1LjggNS4xIDMuOCA3LjcgMy44YzEuNiAwIDMuMS44IDQuMSAyLjIgMS0xLjQgMi41LTIuMiA0LjEtMi4yQzE4LjUgMy44IDIwLjYgNS44IDIwLjYgOC41YzAgNC44LTUuNSA4LjktOC41IDExLjUtLjEuMS0uMy4yLS41LjJ6XCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvc3Bhbj5cbiAgPC9kaXY+XG4gIDxwIGNsYXNzPVwiaW52LWxvYWRlcl9fbGFiZWxcIj5QcmVwYXJhbmRvIGludml0YWNpb24uLi48L3A+XG48L2Rpdj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpe1xuICB2YXIgUlVOVElNRV9SRUFEWV9FVkVOVCA9IFwiaW52aXRhdGlvbi1ydW50aW1lLXJlYWR5XCI7XG4gIHZhciBSVU5USU1FX0ZBSUxfRVZFTlQgPSBcImludml0YXRpb24tcnVudGltZS1mYWlsZWRcIjtcbiAgdmFyIExPQURFUl9ISURERU5fRVZFTlQgPSBcImludml0YXRpb24tbG9hZGVyLWhpZGRlblwiO1xuICB2YXIgTUFYX1dBSVRfTVMgPSAxMDAwMDtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoTG9hZGVyRXZlbnQobmFtZSl7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lKSk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAvLyBub29wXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VMb2FkZXIoKXtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgY2xvc2VkID0gdHJ1ZTtcblxuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShcImRhdGEtbG9hZGVyLXJlYWR5XCIsIFwiMVwiKTtcbiAgICB9XG5cbiAgICB2YXIgbG9hZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnYtbG9hZGVyXCIpO1xuICAgIGlmICghbG9hZGVyKSByZXR1cm47XG5cbiAgICBsb2FkZXIuY2xhc3NMaXN0LmFkZChcImludi1sb2FkZXItLWV4aXRcIik7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChsb2FkZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBsb2FkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2hMb2FkZXJFdmVudChMT0FERVJfSElEREVOX0VWRU5UKTtcbiAgICB9LCA1MjApO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJtRXZlbnRzKCl7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKFwiZGF0YS1sb2FkZXItcmVhZHlcIiwgXCIwXCIpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJVTlRJTUVfUkVBRFlfRVZFTlQsIGNsb3NlTG9hZGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUlVOVElNRV9GQUlMX0VWRU5ULCBjbG9zZUxvYWRlciwgeyBvbmNlOiB0cnVlIH0pO1xuXG4gICAgd2luZG93LnNldFRpbWVvdXQoY2xvc2VMb2FkZXIsIE1BWF9XQUlUX01TKTtcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGFybUV2ZW50cywgeyBvbmNlOiB0cnVlIH0pO1xuICB9IGVsc2Uge1xuICAgIGFybUV2ZW50cygpO1xuICB9XG59KSgpO1xuPC9zY3JpcHQ+XG5gLnRyaW0oKTtcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarInvitationLoaderRuntime.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarModalGaleria.ts":
/*!****************************************************!*\
  !*** ./functions/src/utils/generarModalGaleria.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalGaleriaHTML: () => (/* binding */ generarModalGaleriaHTML),\n/* harmony export */   hayGaleriaConImagenes: () => (/* binding */ hayGaleriaConImagenes)\n/* harmony export */ });\nfunction hayGaleriaConImagenes(objetos = []) {\n    return objetos.some((obj)=>{\n        if (obj?.tipo !== \"galeria\" || !Array.isArray(obj?.cells)) return false;\n        return obj.cells.some((cell)=>typeof cell?.mediaUrl === \"string\" && cell.mediaUrl.trim().length > 0);\n    });\n}\nfunction generarModalGaleriaHTML() {\n    return `\n<style>\n  .objeto.galeria .galeria-celda--clickable {\n    cursor: zoom-in;\n  }\n\n  .objeto.galeria .galeria-celda--clickable:focus-visible {\n    outline: 2px solid rgba(255, 255, 255, 0.95);\n    outline-offset: -2px;\n  }\n\n  .gallery-lightbox {\n    position: fixed;\n    inset: 0;\n    z-index: 11000;\n    opacity: 0;\n    visibility: hidden;\n    pointer-events: none;\n    transition: opacity 0.32s ease, visibility 0.32s ease;\n  }\n\n  .gallery-lightbox.is-open {\n    opacity: 1;\n    visibility: visible;\n    pointer-events: auto;\n  }\n\n  .gallery-lightbox__backdrop {\n    position: absolute;\n    inset: 0;\n    background:\n      radial-gradient(circle at 50% 10%, rgba(66, 66, 75, 0.35), transparent 48%),\n      rgba(7, 8, 11, 0.96);\n    backdrop-filter: blur(8px);\n  }\n\n  .gallery-lightbox__stage {\n    position: relative;\n    z-index: 1;\n    width: min(1320px, 100vw);\n    height: min(94vh, 920px);\n    margin: 0 auto;\n    padding: clamp(24px, 4vw, 44px) clamp(56px, 8vw, 120px);\n    display: grid;\n    grid-template-columns: minmax(0, 1fr) minmax(0, 1.65fr) minmax(0, 1fr);\n    align-items: center;\n    gap: clamp(10px, 2.2vw, 28px);\n  }\n\n  .gallery-lightbox__slot {\n    width: 100%;\n    height: min(84vh, 780px);\n    background: rgba(255, 255, 255, 0.05);\n    border: 1px solid rgba(255, 255, 255, 0.16);\n    border-radius: 20px;\n    overflow: hidden;\n    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.36);\n    transition: opacity 0.26s ease, transform 0.26s ease, filter 0.26s ease;\n  }\n\n  .gallery-lightbox__slot img {\n    width: 100%;\n    height: 100%;\n    display: block;\n    object-fit: contain;\n  }\n\n  .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\n    opacity: 0.52;\n    transform: translateX(10%) scale(0.9);\n    filter: saturate(0.72);\n  }\n\n  .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\n    opacity: 1;\n    transform: scale(1);\n    filter: none;\n  }\n\n  .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\n    opacity: 0.52;\n    transform: translateX(-10%) scale(0.9);\n    filter: saturate(0.72);\n  }\n\n  .gallery-lightbox__slot.is-empty {\n    opacity: 0;\n    transform: scale(0.85);\n    pointer-events: none;\n  }\n\n  .gallery-lightbox__nav,\n  .gallery-lightbox__close {\n    position: absolute;\n    z-index: 2;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    border-radius: 9999px;\n    background: rgba(15, 16, 22, 0.62);\n    color: #fff;\n    cursor: pointer;\n    transition: background 0.2s ease, transform 0.2s ease;\n    backdrop-filter: blur(4px);\n  }\n\n  .gallery-lightbox__nav:hover,\n  .gallery-lightbox__close:hover {\n    background: rgba(22, 25, 34, 0.9);\n    transform: translateY(-1px);\n  }\n\n  .gallery-lightbox__nav {\n    top: 50%;\n    transform: translateY(-50%);\n    width: 52px;\n    height: 52px;\n    font-size: 28px;\n    line-height: 1;\n  }\n\n  .gallery-lightbox__nav--prev {\n    left: clamp(10px, 2vw, 32px);\n  }\n\n  .gallery-lightbox__nav--next {\n    right: clamp(10px, 2vw, 32px);\n  }\n\n  .gallery-lightbox__nav:disabled {\n    opacity: 0.35;\n    cursor: default;\n  }\n\n  .gallery-lightbox__close {\n    top: clamp(14px, 2.5vh, 26px);\n    right: clamp(14px, 2vw, 28px);\n    width: 44px;\n    height: 44px;\n    font-size: 24px;\n    line-height: 1;\n  }\n\n  .gallery-lightbox__counter {\n    position: absolute;\n    z-index: 2;\n    bottom: clamp(12px, 2vh, 24px);\n    left: 50%;\n    transform: translateX(-50%);\n    color: rgba(255, 255, 255, 0.9);\n    background: rgba(14, 16, 24, 0.55);\n    border: 1px solid rgba(255, 255, 255, 0.18);\n    padding: 8px 14px;\n    border-radius: 9999px;\n    font-size: 14px;\n    font-weight: 600;\n    letter-spacing: 0.03em;\n  }\n\n  @media (max-width: 900px) {\n    .gallery-lightbox__stage {\n      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.8fr) minmax(0, 0.9fr);\n      padding: 64px 12px 66px;\n      height: 100dvh;\n      height: 100vh;\n      gap: 12px;\n    }\n\n    .gallery-lightbox__slot {\n      height: min(76vh, 700px);\n      border-radius: 16px;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\n      opacity: 0.34;\n      transform: translateX(22%) scale(0.84);\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\n      opacity: 0.34;\n      transform: translateX(-22%) scale(0.84);\n    }\n  }\n\n  @media (max-width: 640px) {\n    .gallery-lightbox__stage {\n      width: 100vw;\n      max-width: 100vw;\n      height: 100dvh;\n      height: 100vh;\n      grid-template-columns: minmax(0, 1fr);\n      padding:\n        calc(env(safe-area-inset-top, 0px) + 8px)\n        calc(env(safe-area-inset-right, 0px) + 4px)\n        calc(env(safe-area-inset-bottom, 0px) + 50px)\n        calc(env(safe-area-inset-left, 0px) + 4px);\n      gap: 0;\n      align-items: stretch;\n    }\n\n    .gallery-lightbox__slot {\n      height: 100%;\n      border-radius: 12px;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"],\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\n      display: none;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\n      background: transparent;\n      border: none;\n      border-radius: 0;\n      box-shadow: none;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] img {\n      width: 100%;\n      height: 100%;\n      object-fit: contain;\n    }\n\n    .gallery-lightbox__nav {\n      width: 42px;\n      height: 42px;\n      font-size: 24px;\n    }\n\n    .gallery-lightbox__nav--prev {\n      left: calc(env(safe-area-inset-left, 0px) + 6px);\n    }\n\n    .gallery-lightbox__nav--next {\n      right: calc(env(safe-area-inset-right, 0px) + 6px);\n    }\n\n    .gallery-lightbox__close {\n      top: calc(env(safe-area-inset-top, 0px) + 10px);\n      right: calc(env(safe-area-inset-right, 0px) + 10px);\n    }\n\n    .gallery-lightbox__counter {\n      bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);\n    }\n  }\n</style>\n\n<div id=\"gallery-lightbox\" class=\"gallery-lightbox\" aria-hidden=\"true\" role=\"dialog\" aria-modal=\"true\">\n  <div class=\"gallery-lightbox__backdrop\" data-gallery-close></div>\n\n  <button type=\"button\" class=\"gallery-lightbox__close\" data-gallery-close aria-label=\"Cerrar galeria\">\n    &#10005;\n  </button>\n\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--prev\" data-gallery-prev aria-label=\"Imagen anterior\">\n    &#8249;\n  </button>\n\n  <div class=\"gallery-lightbox__stage\">\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"prev\">\n      <img alt=\"\" />\n    </figure>\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"current\">\n      <img alt=\"\" />\n    </figure>\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"next\">\n      <img alt=\"\" />\n    </figure>\n  </div>\n\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--next\" data-gallery-next aria-label=\"Imagen siguiente\">\n    &#8250;\n  </button>\n\n  <div class=\"gallery-lightbox__counter\" data-gallery-counter>1 / 1</div>\n</div>\n\n<script>\n(function(){\n  function clampIndex(index, total){\n    if (!total) return 0;\n    var normalized = index % total;\n    return normalized < 0 ? normalized + total : normalized;\n  }\n\n  function boot(){\n    var modal = document.getElementById(\"gallery-lightbox\");\n    if (!modal) return;\n\n    var closeEls = Array.from(modal.querySelectorAll(\"[data-gallery-close]\"));\n    var prevBtn = modal.querySelector(\"[data-gallery-prev]\");\n    var nextBtn = modal.querySelector(\"[data-gallery-next]\");\n    var counter = modal.querySelector(\"[data-gallery-counter]\");\n\n    var prevSlot = modal.querySelector('[data-gallery-slot=\"prev\"]');\n    var currentSlot = modal.querySelector('[data-gallery-slot=\"current\"]');\n    var nextSlot = modal.querySelector('[data-gallery-slot=\"next\"]');\n\n    var prevImg = prevSlot ? prevSlot.querySelector(\"img\") : null;\n    var currentImg = currentSlot ? currentSlot.querySelector(\"img\") : null;\n    var nextImg = nextSlot ? nextSlot.querySelector(\"img\") : null;\n    var stage = modal.querySelector(\".gallery-lightbox__stage\");\n\n    var state = {\n      images: [],\n      index: 0,\n      isOpen: false,\n      originalOverflow: \"\"\n    };\n\n    function setSlotImage(imgNode, src, altText){\n      if (!imgNode) return;\n      if (!src) {\n        imgNode.removeAttribute(\"src\");\n        imgNode.alt = \"\";\n        return;\n      }\n      if (imgNode.getAttribute(\"src\") !== src) {\n        imgNode.setAttribute(\"src\", src);\n      }\n      imgNode.alt = altText || \"\";\n    }\n\n    function refresh(){\n      var total = state.images.length;\n      if (!total) return;\n\n      state.index = clampIndex(state.index, total);\n      var currentIndex = state.index;\n      var hasNeighbors = total > 1;\n\n      var prevIndex = clampIndex(currentIndex - 1, total);\n      var nextIndex = clampIndex(currentIndex + 1, total);\n\n      setSlotImage(currentImg, state.images[currentIndex], \"Imagen \" + (currentIndex + 1));\n      setSlotImage(\n        prevImg,\n        hasNeighbors ? state.images[prevIndex] : \"\",\n        hasNeighbors ? \"Imagen anterior\" : \"\"\n      );\n      setSlotImage(\n        nextImg,\n        hasNeighbors ? state.images[nextIndex] : \"\",\n        hasNeighbors ? \"Imagen siguiente\" : \"\"\n      );\n\n      if (prevSlot) prevSlot.classList.toggle(\"is-empty\", !hasNeighbors);\n      if (nextSlot) nextSlot.classList.toggle(\"is-empty\", !hasNeighbors);\n\n      if (counter) counter.textContent = (currentIndex + 1) + \" / \" + total;\n      if (prevBtn) prevBtn.disabled = !hasNeighbors;\n      if (nextBtn) nextBtn.disabled = !hasNeighbors;\n    }\n\n    function open(images, startIndex){\n      if (!Array.isArray(images) || !images.length) return;\n      state.images = images.slice();\n      state.index = clampIndex(Number(startIndex) || 0, state.images.length);\n      state.isOpen = true;\n\n      state.originalOverflow = document.body.style.overflow || \"\";\n      document.body.style.overflow = \"hidden\";\n\n      modal.setAttribute(\"aria-hidden\", \"false\");\n      modal.classList.add(\"is-open\");\n      refresh();\n\n      if (closeEls[0] && typeof closeEls[0].focus === \"function\") {\n        closeEls[0].focus();\n      }\n    }\n\n    function close(){\n      if (!state.isOpen) return;\n      state.isOpen = false;\n      modal.classList.remove(\"is-open\");\n      modal.setAttribute(\"aria-hidden\", \"true\");\n      document.body.style.overflow = state.originalOverflow;\n    }\n\n    function navigate(step){\n      if (!state.isOpen || state.images.length < 2) return;\n      state.index = clampIndex(state.index + step, state.images.length);\n      refresh();\n    }\n\n    closeEls.forEach(function(el){\n      el.addEventListener(\"click\", function(ev){\n        ev.preventDefault();\n        close();\n      });\n    });\n\n    if (prevBtn) {\n      prevBtn.addEventListener(\"click\", function(ev){\n        ev.preventDefault();\n        navigate(-1);\n      });\n    }\n\n    if (nextBtn) {\n      nextBtn.addEventListener(\"click\", function(ev){\n        ev.preventDefault();\n        navigate(1);\n      });\n    }\n\n    document.addEventListener(\"keydown\", function(ev){\n      if (!state.isOpen) return;\n      if (ev.key === \"Escape\") {\n        ev.preventDefault();\n        close();\n        return;\n      }\n      if (ev.key === \"ArrowLeft\") {\n        ev.preventDefault();\n        navigate(-1);\n        return;\n      }\n      if (ev.key === \"ArrowRight\") {\n        ev.preventDefault();\n        navigate(1);\n      }\n    });\n\n    if (stage) {\n      var startX = 0;\n      var startY = 0;\n      var pointerDown = false;\n\n      stage.addEventListener(\"touchstart\", function(ev){\n        if (!ev.touches || !ev.touches.length) return;\n        pointerDown = true;\n        startX = ev.touches[0].clientX;\n        startY = ev.touches[0].clientY;\n      }, { passive: true });\n\n      stage.addEventListener(\"touchend\", function(ev){\n        if (!pointerDown || !ev.changedTouches || !ev.changedTouches.length) return;\n        pointerDown = false;\n        var endX = ev.changedTouches[0].clientX;\n        var endY = ev.changedTouches[0].clientY;\n        var dx = endX - startX;\n        var dy = endY - startY;\n\n        if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {\n          navigate(dx > 0 ? -1 : 1);\n        }\n      }, { passive: true });\n    }\n\n    var galleries = Array.from(document.querySelectorAll(\".objeto.galeria\"));\n    galleries.forEach(function(gallery){\n      var cells = Array.from(\n        gallery.querySelectorAll('.galeria-celda[data-gallery-image=\"1\"]')\n      );\n      if (!cells.length) return;\n\n      var images = cells\n        .map(function(cell){\n          var img = cell.querySelector(\"img\");\n          if (!img) return \"\";\n          return (img.getAttribute(\"src\") || \"\").trim();\n        })\n        .filter(Boolean);\n\n      if (!images.length) return;\n\n      gallery.addEventListener(\"click\", function(ev){\n        var target = ev.target;\n        if (!(target instanceof Element)) return;\n\n        var cell = target.closest('.galeria-celda[data-gallery-image=\"1\"]');\n        if (!cell || !gallery.contains(cell)) return;\n\n        var index = cells.indexOf(cell);\n        if (index < 0) return;\n\n        ev.preventDefault();\n        ev.stopPropagation();\n        open(images, index);\n      });\n\n      gallery.addEventListener(\"keydown\", function(ev){\n        if (ev.key !== \"Enter\" && ev.key !== \" \") return;\n        var target = ev.target;\n        if (!(target instanceof Element)) return;\n\n        var cell = target.closest('.galeria-celda[data-gallery-image=\"1\"]');\n        if (!cell || !gallery.contains(cell)) return;\n\n        var index = cells.indexOf(cell);\n        if (index < 0) return;\n\n        ev.preventDefault();\n        open(images, index);\n      });\n    });\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", boot);\n  } else {\n    boot();\n  }\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsR2FsZXJpYS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQVNPLFNBQVNBLHNCQUFzQkMsVUFBaUIsRUFBRTtJQUN2RCxPQUFPQSxRQUFRQyxJQUFJLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsS0FBS0MsU0FBUyxhQUFhLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0gsS0FBS0ksUUFBUSxPQUFPO1FBQ2xFLE9BQU9KLElBQUlJLEtBQUssQ0FBQ0wsSUFBSSxDQUNuQixDQUFDTSxPQUFTLE9BQU9BLE1BQU1DLGFBQWEsWUFBWUQsS0FBS0MsUUFBUSxDQUFDQyxJQUFJLEdBQUdDLE1BQU0sR0FBRztJQUVsRjtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMGZWLENBQUMsQ0FBQ0YsSUFBSTtBQUNOIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXGdlbmVyYXJNb2RhbEdhbGVyaWEudHMiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBHYWxlcmlhQ2VsbCA9IHtcbiAgbWVkaWFVcmw/OiBzdHJpbmcgfCBudWxsO1xufTtcblxudHlwZSBPYmpldG9HYWxlcmlhID0ge1xuICB0aXBvPzogc3RyaW5nO1xuICBjZWxscz86IEdhbGVyaWFDZWxsW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaGF5R2FsZXJpYUNvbkltYWdlbmVzKG9iamV0b3M6IGFueVtdID0gW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIG9iamV0b3Muc29tZSgob2JqOiBPYmpldG9HYWxlcmlhKSA9PiB7XG4gICAgaWYgKG9iaj8udGlwbyAhPT0gXCJnYWxlcmlhXCIgfHwgIUFycmF5LmlzQXJyYXkob2JqPy5jZWxscykpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb2JqLmNlbGxzLnNvbWUoXG4gICAgICAoY2VsbCkgPT4gdHlwZW9mIGNlbGw/Lm1lZGlhVXJsID09PSBcInN0cmluZ1wiICYmIGNlbGwubWVkaWFVcmwudHJpbSgpLmxlbmd0aCA+IDBcbiAgICApO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJNb2RhbEdhbGVyaWFIVE1MKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG48c3R5bGU+XG4gIC5vYmpldG8uZ2FsZXJpYSAuZ2FsZXJpYS1jZWxkYS0tY2xpY2thYmxlIHtcbiAgICBjdXJzb3I6IHpvb20taW47XG4gIH1cblxuICAub2JqZXRvLmdhbGVyaWEgLmdhbGVyaWEtY2VsZGEtLWNsaWNrYWJsZTpmb2N1cy12aXNpYmxlIHtcbiAgICBvdXRsaW5lOiAycHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KTtcbiAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgaW5zZXQ6IDA7XG4gICAgei1pbmRleDogMTEwMDA7XG4gICAgb3BhY2l0eTogMDtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjMycyBlYXNlLCB2aXNpYmlsaXR5IDAuMzJzIGVhc2U7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveC5pcy1vcGVuIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fYmFja2Ryb3Age1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBpbnNldDogMDtcbiAgICBiYWNrZ3JvdW5kOlxuICAgICAgcmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCA1MCUgMTAlLCByZ2JhKDY2LCA2NiwgNzUsIDAuMzUpLCB0cmFuc3BhcmVudCA0OCUpLFxuICAgICAgcmdiYSg3LCA4LCAxMSwgMC45Nik7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2Uge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB6LWluZGV4OiAxO1xuICAgIHdpZHRoOiBtaW4oMTMyMHB4LCAxMDB2dyk7XG4gICAgaGVpZ2h0OiBtaW4oOTR2aCwgOTIwcHgpO1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICAgIHBhZGRpbmc6IGNsYW1wKDI0cHgsIDR2dywgNDRweCkgY2xhbXAoNTZweCwgOHZ3LCAxMjBweCk7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IG1pbm1heCgwLCAxZnIpIG1pbm1heCgwLCAxLjY1ZnIpIG1pbm1heCgwLCAxZnIpO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiBjbGFtcCgxMHB4LCAyLjJ2dywgMjhweCk7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBtaW4oODR2aCwgNzgwcHgpO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE2KTtcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNoYWRvdzogMCAyNHB4IDYwcHggcmdiYSgwLCAwLCAwLCAwLjM2KTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjZzIGVhc2UsIHRyYW5zZm9ybSAwLjI2cyBlYXNlLCBmaWx0ZXIgMC4yNnMgZWFzZTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90IGltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cInByZXZcIl0ge1xuICAgIG9wYWNpdHk6IDAuNTI7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwJSkgc2NhbGUoMC45KTtcbiAgICBmaWx0ZXI6IHNhdHVyYXRlKDAuNzIpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJjdXJyZW50XCJdIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgZmlsdGVyOiBub25lO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJuZXh0XCJdIHtcbiAgICBvcGFjaXR5OiAwLjUyO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAlKSBzY2FsZSgwLjkpO1xuICAgIGZpbHRlcjogc2F0dXJhdGUoMC43Mik7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdC5pcy1lbXB0eSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODUpO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdixcbiAgLmdhbGxlcnktbGlnaHRib3hfX2Nsb3NlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMjtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMTUsIDE2LCAyMiwgMC42Mik7XG4gICAgY29sb3I6ICNmZmY7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4ycyBlYXNlLCB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig0cHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdjpob3ZlcixcbiAgLmdhbGxlcnktbGlnaHRib3hfX2Nsb3NlOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIyLCAyNSwgMzQsIDAuOSk7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xcHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdiB7XG4gICAgdG9wOiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIHdpZHRoOiA1MnB4O1xuICAgIGhlaWdodDogNTJweDtcbiAgICBmb250LXNpemU6IDI4cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fbmF2LS1wcmV2IHtcbiAgICBsZWZ0OiBjbGFtcCgxMHB4LCAydncsIDMycHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tbmV4dCB7XG4gICAgcmlnaHQ6IGNsYW1wKDEwcHgsIDJ2dywgMzJweCk7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fbmF2OmRpc2FibGVkIHtcbiAgICBvcGFjaXR5OiAwLjM1O1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZSB7XG4gICAgdG9wOiBjbGFtcCgxNHB4LCAyLjV2aCwgMjZweCk7XG4gICAgcmlnaHQ6IGNsYW1wKDE0cHgsIDJ2dywgMjhweCk7XG4gICAgd2lkdGg6IDQ0cHg7XG4gICAgaGVpZ2h0OiA0NHB4O1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jb3VudGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMjtcbiAgICBib3R0b206IGNsYW1wKDEycHgsIDJ2aCwgMjRweCk7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMTQsIDE2LCAyNCwgMC41NSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE4KTtcbiAgICBwYWRkaW5nOiA4cHggMTRweDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgbGV0dGVyLXNwYWNpbmc6IDAuMDNlbTtcbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA5MDBweCkge1xuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zdGFnZSB7XG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IG1pbm1heCgwLCAwLjlmcikgbWlubWF4KDAsIDEuOGZyKSBtaW5tYXgoMCwgMC45ZnIpO1xuICAgICAgcGFkZGluZzogNjRweCAxMnB4IDY2cHg7XG4gICAgICBoZWlnaHQ6IDEwMGR2aDtcbiAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICBnYXA6IDEycHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3Qge1xuICAgICAgaGVpZ2h0OiBtaW4oNzZ2aCwgNzAwcHgpO1xuICAgICAgYm9yZGVyLXJhZGl1czogMTZweDtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cInByZXZcIl0ge1xuICAgICAgb3BhY2l0eTogMC4zNDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMiUpIHNjYWxlKDAuODQpO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiXSB7XG4gICAgICBvcGFjaXR5OiAwLjM0O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMiUpIHNjYWxlKDAuODQpO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA2NDBweCkge1xuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zdGFnZSB7XG4gICAgICB3aWR0aDogMTAwdnc7XG4gICAgICBtYXgtd2lkdGg6IDEwMHZ3O1xuICAgICAgaGVpZ2h0OiAxMDBkdmg7XG4gICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMCwgMWZyKTtcbiAgICAgIHBhZGRpbmc6XG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC10b3AsIDBweCkgKyA4cHgpXG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KSArIDRweClcbiAgICAgICAgY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSwgMHB4KSArIDUwcHgpXG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpICsgNHB4KTtcbiAgICAgIGdhcDogMDtcbiAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90IHtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdLFxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiXSB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXSB7XG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICBib3gtc2hhZG93OiBub25lO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXSBpbWcge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYge1xuICAgICAgd2lkdGg6IDQycHg7XG4gICAgICBoZWlnaHQ6IDQycHg7XG4gICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tcHJldiB7XG4gICAgICBsZWZ0OiBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCwgMHB4KSArIDZweCk7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tbmV4dCB7XG4gICAgICByaWdodDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0LCAwcHgpICsgNnB4KTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fY2xvc2Uge1xuICAgICAgdG9wOiBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpICsgMTBweCk7XG4gICAgICByaWdodDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0LCAwcHgpICsgMTBweCk7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX2NvdW50ZXIge1xuICAgICAgYm90dG9tOiBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpICsgOHB4KTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgaWQ9XCJnYWxsZXJ5LWxpZ2h0Ym94XCIgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImRpYWxvZ1wiIGFyaWEtbW9kYWw9XCJ0cnVlXCI+XG4gIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19iYWNrZHJvcFwiIGRhdGEtZ2FsbGVyeS1jbG9zZT48L2Rpdj5cblxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX2Nsb3NlXCIgZGF0YS1nYWxsZXJ5LWNsb3NlIGFyaWEtbGFiZWw9XCJDZXJyYXIgZ2FsZXJpYVwiPlxuICAgICYjMTAwMDU7XG4gIDwvYnV0dG9uPlxuXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fbmF2IGdhbGxlcnktbGlnaHRib3hfX25hdi0tcHJldlwiIGRhdGEtZ2FsbGVyeS1wcmV2IGFyaWEtbGFiZWw9XCJJbWFnZW4gYW50ZXJpb3JcIj5cbiAgICAmIzgyNDk7XG4gIDwvYnV0dG9uPlxuXG4gIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19zdGFnZVwiPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19zbG90XCIgZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCI+XG4gICAgICA8aW1nIGFsdD1cIlwiIC8+XG4gICAgPC9maWd1cmU+XG4gICAgPGZpZ3VyZSBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX3Nsb3RcIiBkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIj5cbiAgICAgIDxpbWcgYWx0PVwiXCIgLz5cbiAgICA8L2ZpZ3VyZT5cbiAgICA8ZmlndXJlIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fc2xvdFwiIGRhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiPlxuICAgICAgPGltZyBhbHQ9XCJcIiAvPlxuICAgIDwvZmlndXJlPlxuICA8L2Rpdj5cblxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX25hdiBnYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLW5leHRcIiBkYXRhLWdhbGxlcnktbmV4dCBhcmlhLWxhYmVsPVwiSW1hZ2VuIHNpZ3VpZW50ZVwiPlxuICAgICYjODI1MDtcbiAgPC9idXR0b24+XG5cbiAgPGRpdiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX2NvdW50ZXJcIiBkYXRhLWdhbGxlcnktY291bnRlcj4xIC8gMTwvZGl2PlxuPC9kaXY+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gY2xhbXBJbmRleChpbmRleCwgdG90YWwpe1xuICAgIGlmICghdG90YWwpIHJldHVybiAwO1xuICAgIHZhciBub3JtYWxpemVkID0gaW5kZXggJSB0b3RhbDtcbiAgICByZXR1cm4gbm9ybWFsaXplZCA8IDAgPyBub3JtYWxpemVkICsgdG90YWwgOiBub3JtYWxpemVkO1xuICB9XG5cbiAgZnVuY3Rpb24gYm9vdCgpe1xuICAgIHZhciBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FsbGVyeS1saWdodGJveFwiKTtcbiAgICBpZiAoIW1vZGFsKSByZXR1cm47XG5cbiAgICB2YXIgY2xvc2VFbHMgPSBBcnJheS5mcm9tKG1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1nYWxsZXJ5LWNsb3NlXVwiKSk7XG4gICAgdmFyIHByZXZCdG4gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZ2FsbGVyeS1wcmV2XVwiKTtcbiAgICB2YXIgbmV4dEJ0biA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1nYWxsZXJ5LW5leHRdXCIpO1xuICAgIHZhciBjb3VudGVyID0gbW9kYWwucXVlcnlTZWxlY3RvcihcIltkYXRhLWdhbGxlcnktY291bnRlcl1cIik7XG5cbiAgICB2YXIgcHJldlNsb3QgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdJyk7XG4gICAgdmFyIGN1cnJlbnRTbG90ID0gbW9kYWwucXVlcnlTZWxlY3RvcignW2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXScpO1xuICAgIHZhciBuZXh0U2xvdCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIl0nKTtcblxuICAgIHZhciBwcmV2SW1nID0gcHJldlNsb3QgPyBwcmV2U2xvdC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpIDogbnVsbDtcbiAgICB2YXIgY3VycmVudEltZyA9IGN1cnJlbnRTbG90ID8gY3VycmVudFNsb3QucXVlcnlTZWxlY3RvcihcImltZ1wiKSA6IG51bGw7XG4gICAgdmFyIG5leHRJbWcgPSBuZXh0U2xvdCA/IG5leHRTbG90LnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIikgOiBudWxsO1xuICAgIHZhciBzdGFnZSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCIuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2VcIik7XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBpbWFnZXM6IFtdLFxuICAgICAgaW5kZXg6IDAsXG4gICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgb3JpZ2luYWxPdmVyZmxvdzogXCJcIlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRTbG90SW1hZ2UoaW1nTm9kZSwgc3JjLCBhbHRUZXh0KXtcbiAgICAgIGlmICghaW1nTm9kZSkgcmV0dXJuO1xuICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgaW1nTm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgIGltZ05vZGUuYWx0ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGltZ05vZGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpICE9PSBzcmMpIHtcbiAgICAgICAgaW1nTm9kZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTtcbiAgICAgIH1cbiAgICAgIGltZ05vZGUuYWx0ID0gYWx0VGV4dCB8fCBcIlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2goKXtcbiAgICAgIHZhciB0b3RhbCA9IHN0YXRlLmltYWdlcy5sZW5ndGg7XG4gICAgICBpZiAoIXRvdGFsKSByZXR1cm47XG5cbiAgICAgIHN0YXRlLmluZGV4ID0gY2xhbXBJbmRleChzdGF0ZS5pbmRleCwgdG90YWwpO1xuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgdmFyIGhhc05laWdoYm9ycyA9IHRvdGFsID4gMTtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGNsYW1wSW5kZXgoY3VycmVudEluZGV4IC0gMSwgdG90YWwpO1xuICAgICAgdmFyIG5leHRJbmRleCA9IGNsYW1wSW5kZXgoY3VycmVudEluZGV4ICsgMSwgdG90YWwpO1xuXG4gICAgICBzZXRTbG90SW1hZ2UoY3VycmVudEltZywgc3RhdGUuaW1hZ2VzW2N1cnJlbnRJbmRleF0sIFwiSW1hZ2VuIFwiICsgKGN1cnJlbnRJbmRleCArIDEpKTtcbiAgICAgIHNldFNsb3RJbWFnZShcbiAgICAgICAgcHJldkltZyxcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gc3RhdGUuaW1hZ2VzW3ByZXZJbmRleF0gOiBcIlwiLFxuICAgICAgICBoYXNOZWlnaGJvcnMgPyBcIkltYWdlbiBhbnRlcmlvclwiIDogXCJcIlxuICAgICAgKTtcbiAgICAgIHNldFNsb3RJbWFnZShcbiAgICAgICAgbmV4dEltZyxcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gc3RhdGUuaW1hZ2VzW25leHRJbmRleF0gOiBcIlwiLFxuICAgICAgICBoYXNOZWlnaGJvcnMgPyBcIkltYWdlbiBzaWd1aWVudGVcIiA6IFwiXCJcbiAgICAgICk7XG5cbiAgICAgIGlmIChwcmV2U2xvdCkgcHJldlNsb3QuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWVtcHR5XCIsICFoYXNOZWlnaGJvcnMpO1xuICAgICAgaWYgKG5leHRTbG90KSBuZXh0U2xvdC5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtZW1wdHlcIiwgIWhhc05laWdoYm9ycyk7XG5cbiAgICAgIGlmIChjb3VudGVyKSBjb3VudGVyLnRleHRDb250ZW50ID0gKGN1cnJlbnRJbmRleCArIDEpICsgXCIgLyBcIiArIHRvdGFsO1xuICAgICAgaWYgKHByZXZCdG4pIHByZXZCdG4uZGlzYWJsZWQgPSAhaGFzTmVpZ2hib3JzO1xuICAgICAgaWYgKG5leHRCdG4pIG5leHRCdG4uZGlzYWJsZWQgPSAhaGFzTmVpZ2hib3JzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wZW4oaW1hZ2VzLCBzdGFydEluZGV4KXtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbWFnZXMpIHx8ICFpbWFnZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICBzdGF0ZS5pbWFnZXMgPSBpbWFnZXMuc2xpY2UoKTtcbiAgICAgIHN0YXRlLmluZGV4ID0gY2xhbXBJbmRleChOdW1iZXIoc3RhcnRJbmRleCkgfHwgMCwgc3RhdGUuaW1hZ2VzLmxlbmd0aCk7XG4gICAgICBzdGF0ZS5pc09wZW4gPSB0cnVlO1xuXG4gICAgICBzdGF0ZS5vcmlnaW5hbE92ZXJmbG93ID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyB8fCBcIlwiO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cbiAgICAgIG1vZGFsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIik7XG4gICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKFwiaXMtb3BlblwiKTtcbiAgICAgIHJlZnJlc2goKTtcblxuICAgICAgaWYgKGNsb3NlRWxzWzBdICYmIHR5cGVvZiBjbG9zZUVsc1swXS5mb2N1cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNsb3NlRWxzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICAgIGlmICghc3RhdGUuaXNPcGVuKSByZXR1cm47XG4gICAgICBzdGF0ZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIG1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1vcGVuXCIpO1xuICAgICAgbW9kYWwuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHN0YXRlLm9yaWdpbmFsT3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmF2aWdhdGUoc3RlcCl7XG4gICAgICBpZiAoIXN0YXRlLmlzT3BlbiB8fCBzdGF0ZS5pbWFnZXMubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgc3RhdGUuaW5kZXggPSBjbGFtcEluZGV4KHN0YXRlLmluZGV4ICsgc3RlcCwgc3RhdGUuaW1hZ2VzLmxlbmd0aCk7XG4gICAgICByZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgY2xvc2VFbHMuZm9yRWFjaChmdW5jdGlvbihlbCl7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJldkJ0bikge1xuICAgICAgcHJldkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBuYXZpZ2F0ZSgtMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEJ0bikge1xuICAgICAgbmV4dEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBuYXZpZ2F0ZSgxKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgIGlmICghc3RhdGUuaXNPcGVuKSByZXR1cm47XG4gICAgICBpZiAoZXYua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldi5rZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoLTEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXYua2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBuYXZpZ2F0ZSgxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzdGFnZSkge1xuICAgICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgICB2YXIgc3RhcnRZID0gMDtcbiAgICAgIHZhciBwb2ludGVyRG93biA9IGZhbHNlO1xuXG4gICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihldil7XG4gICAgICAgIGlmICghZXYudG91Y2hlcyB8fCAhZXYudG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcG9pbnRlckRvd24gPSB0cnVlO1xuICAgICAgICBzdGFydFggPSBldi50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHN0YXJ0WSA9IGV2LnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAgICAgc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgaWYgKCFwb2ludGVyRG93biB8fCAhZXYuY2hhbmdlZFRvdWNoZXMgfHwgIWV2LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBwb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICB2YXIgZW5kWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHZhciBlbmRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgdmFyIGR4ID0gZW5kWCAtIHN0YXJ0WDtcbiAgICAgICAgdmFyIGR5ID0gZW5kWSAtIHN0YXJ0WTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID4gNDAgJiYgTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICAgICAgbmF2aWdhdGUoZHggPiAwID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHZhciBnYWxsZXJpZXMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIub2JqZXRvLmdhbGVyaWFcIikpO1xuICAgIGdhbGxlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGdhbGxlcnkpe1xuICAgICAgdmFyIGNlbGxzID0gQXJyYXkuZnJvbShcbiAgICAgICAgZ2FsbGVyeS5xdWVyeVNlbGVjdG9yQWxsKCcuZ2FsZXJpYS1jZWxkYVtkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJdJylcbiAgICAgICk7XG4gICAgICBpZiAoIWNlbGxzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICB2YXIgaW1hZ2VzID0gY2VsbHNcbiAgICAgICAgLm1hcChmdW5jdGlvbihjZWxsKXtcbiAgICAgICAgICB2YXIgaW1nID0gY2VsbC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpO1xuICAgICAgICAgIGlmICghaW1nKSByZXR1cm4gXCJcIjtcbiAgICAgICAgICByZXR1cm4gKGltZy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCJcIikudHJpbSgpO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICBpZiAoIWltYWdlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgZ2FsbGVyeS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjZWxsID0gdGFyZ2V0LmNsb3Nlc3QoJy5nYWxlcmlhLWNlbGRhW2RhdGEtZ2FsbGVyeS1pbWFnZT1cIjFcIl0nKTtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFnYWxsZXJ5LmNvbnRhaW5zKGNlbGwpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGluZGV4ID0gY2VsbHMuaW5kZXhPZihjZWxsKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBvcGVuKGltYWdlcywgaW5kZXgpO1xuICAgICAgfSk7XG5cbiAgICAgIGdhbGxlcnkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBpZiAoZXYua2V5ICE9PSBcIkVudGVyXCIgJiYgZXYua2V5ICE9PSBcIiBcIikgcmV0dXJuO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjZWxsID0gdGFyZ2V0LmNsb3Nlc3QoJy5nYWxlcmlhLWNlbGRhW2RhdGEtZ2FsbGVyeS1pbWFnZT1cIjFcIl0nKTtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFnYWxsZXJ5LmNvbnRhaW5zKGNlbGwpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGluZGV4ID0gY2VsbHMuaW5kZXhPZihjZWxsKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9wZW4oaW1hZ2VzLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGJvb3QoKTtcbiAgfVxufSkoKTtcbjwvc2NyaXB0PlxuYC50cmltKCk7XG59XG4iXSwibmFtZXMiOlsiaGF5R2FsZXJpYUNvbkltYWdlbmVzIiwib2JqZXRvcyIsInNvbWUiLCJvYmoiLCJ0aXBvIiwiQXJyYXkiLCJpc0FycmF5IiwiY2VsbHMiLCJjZWxsIiwibWVkaWFVcmwiLCJ0cmltIiwibGVuZ3RoIiwiZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarModalGaleria.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts":
/*!*************************************************!*\
  !*** ./functions/src/utils/generarModalRSVP.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalRSVPHTML: () => (/* binding */ generarModalRSVPHTML)\n/* harmony export */ });\n// functions/src/utils/generarModalRSVP.ts\nfunction generarModalRSVPHTML(cfg) {\n    if (!cfg?.enabled) return \"\";\n    const title = cfg.title ?? \"Confirmar asistencia\";\n    const subtitle = cfg.subtitle ?? \"\";\n    const btnText = cfg.buttonText ?? \"Enviar\";\n    const color = cfg.primaryColor ?? \"#773dbe\";\n    // Nota: el botón que abre el modal debe tener [data-rsvp-open]\n    // (el listener de abajo lo busca)\n    return `\n<div id=\"modal-rsvp\" style=\"\n  position: fixed; inset: 0; display:none;\n  background: rgba(0,0,0,.6); z-index: 9999;\n  align-items: center; justify-content: center;\">\n  <div style=\"\n    background: #fff; width: 90%; max-width: 420px; border-radius: 10px;\n    padding: 20px; font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,.2);\">\n    <div style=\"display:flex; justify-content: space-between; align-items:center;\">\n      <h2 style=\"margin:0; font-size:20px;\">${title}</h2>\n      <button id=\"rsvp-close\" aria-label=\"Cerrar\" style=\"border:none; background:transparent; font-size:18px; cursor:pointer;\">✕</button>\n    </div>\n    ${subtitle ? `<p style=\"margin:8px 0 16px; color:#555;\">${subtitle}</p>` : \"\"}\n\n    <div style=\"display:flex; flex-direction:column; gap:10px;\">\n      <input id=\"rsvp-nombre\" placeholder=\"Tu nombre\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\n      <input id=\"rsvp-mensaje\" placeholder=\"Mensaje (opcional)\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\n    </div>\n\n     <!-- ✅ NUEVO: selector Sí/No con estilo segmentado -->\n    <div style=\"margin-top:12px;\">\n      <label style=\"display:block; font-weight:600; margin-bottom:8px;\">¿Confirmás asistencia?</label>\n      <div id=\"rsvp-confirma\" style=\"\n        display:inline-flex; gap:0; border:1px solid #ddd; border-radius:10px; overflow:hidden;\n        box-shadow: inset 0 1px 0 rgba(0,0,0,0.03);\n      \">\n        <button type=\"button\" data-confirma=\"si\" aria-pressed=\"true\" style=\"\n          padding:10px 14px; border:none; background:${color}; color:#fff; font-weight:600; cursor:pointer;\n        \">Sí, voy</button>\n        <button type=\"button\" data-confirma=\"no\" aria-pressed=\"false\" style=\"\n          padding:10px 14px; border:none; background:#f6f6f6; color:#444; cursor:pointer;\n        \">No puedo</button>\n      </div>\n    </div>\n\n    <div style=\"display:flex; justify-content:flex-end; gap:10px; margin-top:16px;\">\n      <button id=\"rsvp-cancel\" style=\"padding:8px 12px; border-radius:6px; border:1px solid #ddd; background:#f3f3f3; cursor:pointer;\">Cancelar</button>\n      <button id=\"rsvp-send\" style=\"padding:8px 12px; border-radius:6px; border:none; color:#fff; cursor:pointer; background:${color};\">${btnText}</button>\n    </div>\n  </div>\n</div>\n\n<script>\ndocument.addEventListener('DOMContentLoaded', function () {\n\nfunction getSlugDePagina() {\n  // 0) Log de ayuda\n  try { console.log(\"[RSVP] href:\", location.href); } catch (e) {}\n\n  // 1) <html data-slug=\"...\"> (si lo inyectás en el HTML final)\n  const ds = document.documentElement?.dataset?.slug;\n  if (ds) {\n    console.log(\"[RSVP] slug por data-atributo:\", ds);\n    return ds;\n  }\n\n  // 2) ?slug=... en la URL\n  const q = new URLSearchParams(location.search).get(\"slug\");\n  if (q) {\n    console.log(\"[RSVP] slug por querystring:\", q);\n    return q;\n  }\n\n  // 3) /publicadas/<slug>/... en un sitio estático (Hosting/Proxy)\n  const parts = location.pathname.split(\"/\").filter(Boolean);\n  const i = parts.indexOf(\"publicadas\");\n  if (i >= 0 && parts[i + 1]) {\n    console.log(\"[RSVP] slug por pathname directo:\", parts[i + 1]);\n    return parts[i + 1];\n  }\n\n  // 4) URL de Firebase Storage:\n  //    https://firebasestorage.googleapis.com/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media&token=...\n  //    https://<bucket>.firebasestorage.app/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media\n  try {\n    const pathAfterO = location.pathname.split(\"/o/\")[1]; // \"publicadas%2F<slug>%2Findex.html\"\n    if (pathAfterO) {\n      const decoded = decodeURIComponent(pathAfterO);      // \"publicadas/<slug>/index.html\"\n      const segs = decoded.split(\"/\").filter(Boolean);\n      const j = segs.indexOf(\"publicadas\");\n      if (j >= 0 && segs[j + 1]) {\n        console.log(\"[RSVP] slug por URL de Storage:\", segs[j + 1]);\n        return segs[j + 1];\n      }\n    }\n  } catch (e) {\n    console.warn(\"[RSVP] Error parseando URL de Storage:\", e);\n  }\n\n  console.warn(\"[RSVP] No se pudo detectar slug. Fallback: sin-slug\");\n  return \"sin-slug\";\n}\n\n\n  var modal = document.getElementById('modal-rsvp');\n  if (!modal) return;\n\n  function openModal() { \n  modal.style.display = 'flex'; \n  // 🔁 Reset visual y estado cada vez que se abre\n  setConfirmaUI(\"si\", ${JSON.stringify(color)});\n}\n\n  function closeModal() { modal.style.display = 'none'; }\n\n  // Botones internos\n  var closeBtn = document.getElementById('rsvp-close');\n  var cancelBtn = document.getElementById('rsvp-cancel');\n  var sendBtn = document.getElementById('rsvp-send');\n\n  if (closeBtn) closeBtn.addEventListener('click', closeModal);\n  if (cancelBtn) cancelBtn.addEventListener('click', closeModal);\n\n  // Click fuera del cuadro\n  modal.addEventListener('click', function(e) {\n    if (e.target === modal) closeModal();\n  });\n\n  // Abridores: cualquier elemento con data-rsvp-open\ndocument.querySelectorAll('[data-rsvp-open], [data-accion=\"abrir-rsvp\"], .rsvp-boton').forEach(function(el) {\n    el.addEventListener('click', function(e) {\n      e.preventDefault();\n      openModal();\n    });\n  });\n\n\n// Estado interno del selector Sí/No\nvar confirmaValor = \"si\"; // default\n\nfunction setConfirmaUI(valor, color) {\n  var cont = document.getElementById('rsvp-confirma');\n  if (!cont) return;\n  var btnSi = cont.querySelector('[data-confirma=\"si\"]');\n  var btnNo = cont.querySelector('[data-confirma=\"no\"]');\n  confirmaValor = (valor === \"no\") ? \"no\" : \"si\";\n\n  if (btnSi && btnNo) {\n    if (confirmaValor === \"si\") {\n      btnSi.style.background = color;\n      btnSi.style.color = \"#fff\";\n      btnSi.setAttribute(\"aria-pressed\", \"true\");\n\n      btnNo.style.background = \"#f6f6f6\";\n      btnNo.style.color = \"#444\";\n      btnNo.setAttribute(\"aria-pressed\", \"false\");\n    } else {\n      btnNo.style.background = color;\n      btnNo.style.color = \"#fff\";\n      btnNo.setAttribute(\"aria-pressed\", \"true\");\n\n      btnSi.style.background = \"#f6f6f6\";\n      btnSi.style.color = \"#444\";\n      btnSi.setAttribute(\"aria-pressed\", \"false\");\n    }\n  }\n}\n\n// 🔹 Dejar \"Sí\" seleccionado al cargar\nsetConfirmaUI(\"si\", ${JSON.stringify(color)});\n\n// 🔹 Alternar selección al click\nvar confirmaWrap = document.getElementById('rsvp-confirma');\nif (confirmaWrap) {\n  confirmaWrap.addEventListener('click', function(e) {\n    var btn = e.target.closest('[data-confirma]');\n    if (!btn) return;\n    var v = btn.getAttribute('data-confirma');\n    setConfirmaUI(v, ${JSON.stringify(color)});\n    try { console.log(\"[RSVP] cambia confirmaValor =\", v); } catch(_) {}\n  });\n}\n\n\n\n  // ✅ Envío con Firestore + logs\nif (sendBtn) {\n  sendBtn.addEventListener('click', function() {\n    var nombre = (document.getElementById('rsvp-nombre') || {}).value || '';\n    var mensaje = (document.getElementById('rsvp-mensaje') || {}).value || '';\n\n    if (!nombre.trim()) {\n      alert('Por favor ingresá tu nombre.');\n      return;\n    }\n\n    const confirma = (confirmaValor === \"si\"); \n    const slug = getSlugDePagina();\n    console.log(\"[RSVP] Enviando RSVP… slug =\", slug);\n\n    // (opcional) si seguís usando sheetUrl, mantenemos el POST “en paralelo”\n    var sheetUrl = ${JSON.stringify(cfg.sheetUrl || \"\")};\n    if (sheetUrl) {\n      try {\n        fetch(sheetUrl, {\n          method: 'POST',\n          headers: {'Content-Type':'application/json'},\n          body: JSON.stringify({\n            nombre: nombre.trim(),\n            mensaje: mensaje.trim(),\n            slug: slug,\n            ts: Date.now()\n          })\n        }).catch(function(e){ console.warn(\"[RSVP] sheetUrl error:\", e); });\n      } catch (e) {\n        console.warn(\"[RSVP] sheetUrl throw:\", e);\n      }\n    }\n\n    // 🔌 Importar Firebase dinámicamente y guardar en Firestore\n    Promise.all([\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js\"),\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js\"),\n    ])\n    .then(([appMod, fsMod]) => {\n      const { initializeApp } = appMod;\n      const { getFirestore, collection, addDoc, serverTimestamp } = fsMod;\n\n      // ⚙️ Config mínima (apiKey y projectId son suficientes para el cliente)\n      const firebaseConfig = {\n        apiKey: \"AIzaSyALCvU48_HRp26cXpQcTX5S33Adpwfl3z4\",\n        authDomain: \"reservaeldia.com.ar\",\n        projectId: \"reservaeldia-7a440\",\n        appId: \"1:860495975406:web:3a49ad0cf55d60313534ff\"\n      };\n\n      const app = initializeApp(firebaseConfig);\n      const db  = getFirestore(app);\n\n      const payload = {\n        nombre: nombre.trim(),\n        mensaje: (mensaje && mensaje.trim()) || null,\n        confirma,\n        createdAt: serverTimestamp(),\n        userAgent: navigator.userAgent.slice(0, 512)\n      };\n\n      console.log(\"[RSVP] Payload keys =\", Object.keys(payload));\n      console.log(\"[RSVP] Payload =\", JSON.stringify(payload));\n\n      return addDoc(collection(db, \"publicadas\", slug, \"rsvps\"), payload);\n    })\n    .then((docRef) => {\n      console.log(\"[RSVP] RSVP guardado con ID:\", docRef.id, \"en /publicadas/\"+slug+\"/rsvps\");\n      alert('¡Gracias por confirmar tu asistencia, ' + nombre + '!');\n      closeModal();\n    })\n    .catch((err) => {\n      console.error(\"[RSVP] Error guardando en Firestore:\", err);\n      alert('Hubo un error al guardar tu confirmación. Probá de nuevo.');\n    });\n  });\n}\n \n  \n\n});\n</script>\n`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsUlNWUC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMENBQTBDO0FBV25DLFNBQVNBLHFCQUFxQkMsR0FBZTtJQUNoRCxJQUFJLENBQUNBLEtBQUtDLFNBQVMsT0FBTztJQUUxQixNQUFNQyxRQUFRRixJQUFJRSxLQUFLLElBQUk7SUFDM0IsTUFBTUMsV0FBV0gsSUFBSUcsUUFBUSxJQUFJO0lBQ2pDLE1BQU1DLFVBQVVKLElBQUlLLFVBQVUsSUFBSTtJQUNsQyxNQUFNQyxRQUFRTixJQUFJTyxZQUFZLElBQUk7SUFFbEMsK0RBQStEO0lBQy9ELGtDQUFrQztJQUNsQyxPQUFPLENBQUM7Ozs7Ozs7Ozs0Q0FTZ0MsRUFBRUwsTUFBTTs7O0lBR2hELEVBQUVDLFdBQVcsQ0FBQywwQ0FBMEMsRUFBRUEsU0FBUyxJQUFJLENBQUMsR0FBRyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7cURBZTdCLEVBQUVHLE1BQU07Ozs7Ozs7Ozs7NkhBVWdFLEVBQUVBLE1BQU0sR0FBRyxFQUFFRixRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBK0Q1SCxFQUFFSSxLQUFLQyxTQUFTLENBQUNILE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTJEMUIsRUFBRUUsS0FBS0MsU0FBUyxDQUFDSCxPQUFPOzs7Ozs7Ozs7cUJBU3ZCLEVBQUVFLEtBQUtDLFNBQVMsQ0FBQ0gsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBdUIxQixFQUFFRSxLQUFLQyxTQUFTLENBQUNULElBQUlVLFFBQVEsSUFBSSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUV4RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vZGFsUlNWUC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL2dlbmVyYXJNb2RhbFJTVlAudHNcclxuXHJcbmV4cG9ydCB0eXBlIFJTVlBDb25maWcgPSB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG4gICAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgICBzdWJ0aXRsZT86IHN0cmluZztcclxuICAgIGJ1dHRvblRleHQ/OiBzdHJpbmc7XHJcbiAgICBwcmltYXJ5Q29sb3I/OiBzdHJpbmc7IC8vIGNvbG9yIGRlbCBib3TDs24vY2FiZWNlcmFcclxuICAgIHNoZWV0VXJsPzogc3RyaW5nOyAgICAgLy8gb3BjaW9uYWwgc2kgdmFzIGEgZW52aWFyIGEgR29vZ2xlIFNoZWV0cyBvIHNpbWlsYXJcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxSU1ZQSFRNTChjZmc6IFJTVlBDb25maWcpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFjZmc/LmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gY2ZnLnRpdGxlID8/IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIjtcclxuICAgIGNvbnN0IHN1YnRpdGxlID0gY2ZnLnN1YnRpdGxlID8/IFwiXCI7XHJcbiAgICBjb25zdCBidG5UZXh0ID0gY2ZnLmJ1dHRvblRleHQgPz8gXCJFbnZpYXJcIjtcclxuICAgIGNvbnN0IGNvbG9yID0gY2ZnLnByaW1hcnlDb2xvciA/PyBcIiM3NzNkYmVcIjtcclxuXHJcbiAgICAvLyBOb3RhOiBlbCBib3TDs24gcXVlIGFicmUgZWwgbW9kYWwgZGViZSB0ZW5lciBbZGF0YS1yc3ZwLW9wZW5dXHJcbiAgICAvLyAoZWwgbGlzdGVuZXIgZGUgYWJham8gbG8gYnVzY2EpXHJcbiAgICByZXR1cm4gYFxyXG48ZGl2IGlkPVwibW9kYWwtcnN2cFwiIHN0eWxlPVwiXHJcbiAgcG9zaXRpb246IGZpeGVkOyBpbnNldDogMDsgZGlzcGxheTpub25lO1xyXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjYpOyB6LWluZGV4OiA5OTk5O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyO1wiPlxyXG4gIDxkaXYgc3R5bGU9XCJcclxuICAgIGJhY2tncm91bmQ6ICNmZmY7IHdpZHRoOiA5MCU7IG1heC13aWR0aDogNDIwcHg7IGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICBwYWRkaW5nOiAyMHB4OyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgYm94LXNoYWRvdzogMCAxMHB4IDMwcHggcmdiYSgwLDAsMCwuMik7XCI+XHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOmNlbnRlcjtcIj5cclxuICAgICAgPGgyIHN0eWxlPVwibWFyZ2luOjA7IGZvbnQtc2l6ZToyMHB4O1wiPiR7dGl0bGV9PC9oMj5cclxuICAgICAgPGJ1dHRvbiBpZD1cInJzdnAtY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2VycmFyXCIgc3R5bGU9XCJib3JkZXI6bm9uZTsgYmFja2dyb3VuZDp0cmFuc3BhcmVudDsgZm9udC1zaXplOjE4cHg7IGN1cnNvcjpwb2ludGVyO1wiPuKclTwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICAke3N1YnRpdGxlID8gYDxwIHN0eWxlPVwibWFyZ2luOjhweCAwIDE2cHg7IGNvbG9yOiM1NTU7XCI+JHtzdWJ0aXRsZX08L3A+YCA6IFwiXCJ9XHJcblxyXG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDtcIj5cclxuICAgICAgPGlucHV0IGlkPVwicnN2cC1ub21icmVcIiBwbGFjZWhvbGRlcj1cIlR1IG5vbWJyZVwiIHN0eWxlPVwicGFkZGluZzoxMHB4OyBib3JkZXI6MXB4IHNvbGlkICNjY2M7IGJvcmRlci1yYWRpdXM6NnB4O1wiIC8+XHJcbiAgICAgIDxpbnB1dCBpZD1cInJzdnAtbWVuc2FqZVwiIHBsYWNlaG9sZGVyPVwiTWVuc2FqZSAob3BjaW9uYWwpXCIgc3R5bGU9XCJwYWRkaW5nOjEwcHg7IGJvcmRlcjoxcHggc29saWQgI2NjYzsgYm9yZGVyLXJhZGl1czo2cHg7XCIgLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgICA8IS0tIOKchSBOVUVWTzogc2VsZWN0b3IgU8OtL05vIGNvbiBlc3RpbG8gc2VnbWVudGFkbyAtLT5cclxuICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tdG9wOjEycHg7XCI+XHJcbiAgICAgIDxsYWJlbCBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IGZvbnQtd2VpZ2h0OjYwMDsgbWFyZ2luLWJvdHRvbTo4cHg7XCI+wr9Db25maXJtw6FzIGFzaXN0ZW5jaWE/PC9sYWJlbD5cclxuICAgICAgPGRpdiBpZD1cInJzdnAtY29uZmlybWFcIiBzdHlsZT1cIlxyXG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWZsZXg7IGdhcDowOyBib3JkZXI6MXB4IHNvbGlkICNkZGQ7IGJvcmRlci1yYWRpdXM6MTBweDsgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgwLDAsMCwwLjAzKTtcclxuICAgICAgXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1jb25maXJtYT1cInNpXCIgYXJpYS1wcmVzc2VkPVwidHJ1ZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6JHtjb2xvcn07IGNvbG9yOiNmZmY7IGZvbnQtd2VpZ2h0OjYwMDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+U8OtLCB2b3k8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWNvbmZpcm1hPVwibm9cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6I2Y2ZjZmNjsgY29sb3I6IzQ0NDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+Tm8gcHVlZG88L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7IGdhcDoxMHB4OyBtYXJnaW4tdG9wOjE2cHg7XCI+XHJcbiAgICAgIDxidXR0b24gaWQ9XCJyc3ZwLWNhbmNlbFwiIHN0eWxlPVwicGFkZGluZzo4cHggMTJweDsgYm9yZGVyLXJhZGl1czo2cHg7IGJvcmRlcjoxcHggc29saWQgI2RkZDsgYmFja2dyb3VuZDojZjNmM2YzOyBjdXJzb3I6cG9pbnRlcjtcIj5DYW5jZWxhcjwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGlkPVwicnN2cC1zZW5kXCIgc3R5bGU9XCJwYWRkaW5nOjhweCAxMnB4OyBib3JkZXItcmFkaXVzOjZweDsgYm9yZGVyOm5vbmU7IGNvbG9yOiNmZmY7IGN1cnNvcjpwb2ludGVyOyBiYWNrZ3JvdW5kOiR7Y29sb3J9O1wiPiR7YnRuVGV4dH08L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5mdW5jdGlvbiBnZXRTbHVnRGVQYWdpbmEoKSB7XHJcbiAgLy8gMCkgTG9nIGRlIGF5dWRhXHJcbiAgdHJ5IHsgY29uc29sZS5sb2coXCJbUlNWUF0gaHJlZjpcIiwgbG9jYXRpb24uaHJlZik7IH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIC8vIDEpIDxodG1sIGRhdGEtc2x1Zz1cIi4uLlwiPiAoc2kgbG8gaW55ZWN0w6FzIGVuIGVsIEhUTUwgZmluYWwpXHJcbiAgY29uc3QgZHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/LmRhdGFzZXQ/LnNsdWc7XHJcbiAgaWYgKGRzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBkYXRhLWF0cmlidXRvOlwiLCBkcyk7XHJcbiAgICByZXR1cm4gZHM7XHJcbiAgfVxyXG5cclxuICAvLyAyKSA/c2x1Zz0uLi4gZW4gbGEgVVJMXHJcbiAgY29uc3QgcSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKS5nZXQoXCJzbHVnXCIpO1xyXG4gIGlmIChxKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBxdWVyeXN0cmluZzpcIiwgcSk7XHJcbiAgICByZXR1cm4gcTtcclxuICB9XHJcblxyXG4gIC8vIDMpIC9wdWJsaWNhZGFzLzxzbHVnPi8uLi4gZW4gdW4gc2l0aW8gZXN0w6F0aWNvIChIb3N0aW5nL1Byb3h5KVxyXG4gIGNvbnN0IHBhcnRzID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcclxuICBjb25zdCBpID0gcGFydHMuaW5kZXhPZihcInB1YmxpY2FkYXNcIik7XHJcbiAgaWYgKGkgPj0gMCAmJiBwYXJ0c1tpICsgMV0pIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIHBhdGhuYW1lIGRpcmVjdG86XCIsIHBhcnRzW2kgKyAxXSk7XHJcbiAgICByZXR1cm4gcGFydHNbaSArIDFdO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgVVJMIGRlIEZpcmViYXNlIFN0b3JhZ2U6XHJcbiAgLy8gICAgaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYSZ0b2tlbj0uLi5cclxuICAvLyAgICBodHRwczovLzxidWNrZXQ+LmZpcmViYXNlc3RvcmFnZS5hcHAvdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXRoQWZ0ZXJPID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvby9cIilbMV07IC8vIFwicHVibGljYWRhcyUyRjxzbHVnPiUyRmluZGV4Lmh0bWxcIlxyXG4gICAgaWYgKHBhdGhBZnRlck8pIHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXRoQWZ0ZXJPKTsgICAgICAvLyBcInB1YmxpY2FkYXMvPHNsdWc+L2luZGV4Lmh0bWxcIlxyXG4gICAgICBjb25zdCBzZWdzID0gZGVjb2RlZC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICBjb25zdCBqID0gc2Vncy5pbmRleE9mKFwicHVibGljYWRhc1wiKTtcclxuICAgICAgaWYgKGogPj0gMCAmJiBzZWdzW2ogKyAxXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIFVSTCBkZSBTdG9yYWdlOlwiLCBzZWdzW2ogKyAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiW1JTVlBdIEVycm9yIHBhcnNlYW5kbyBVUkwgZGUgU3RvcmFnZTpcIiwgZSk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLndhcm4oXCJbUlNWUF0gTm8gc2UgcHVkbyBkZXRlY3RhciBzbHVnLiBGYWxsYmFjazogc2luLXNsdWdcIik7XHJcbiAgcmV0dXJuIFwic2luLXNsdWdcIjtcclxufVxyXG5cclxuXHJcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsLXJzdnAnKTtcclxuICBpZiAoIW1vZGFsKSByZXR1cm47XHJcblxyXG4gIGZ1bmN0aW9uIG9wZW5Nb2RhbCgpIHsgXHJcbiAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgXHJcbiAgLy8g8J+UgSBSZXNldCB2aXN1YWwgeSBlc3RhZG8gY2FkYSB2ZXogcXVlIHNlIGFicmVcclxuICBzZXRDb25maXJtYVVJKFwic2lcIiwgJHtKU09OLnN0cmluZ2lmeShjb2xvcil9KTtcclxufVxyXG5cclxuICBmdW5jdGlvbiBjbG9zZU1vZGFsKCkgeyBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9XHJcblxyXG4gIC8vIEJvdG9uZXMgaW50ZXJub3NcclxuICB2YXIgY2xvc2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jbG9zZScpO1xyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jYW5jZWwnKTtcclxuICB2YXIgc2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLXNlbmQnKTtcclxuXHJcbiAgaWYgKGNsb3NlQnRuKSBjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG4gIGlmIChjYW5jZWxCdG4pIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG5cclxuICAvLyBDbGljayBmdWVyYSBkZWwgY3VhZHJvXHJcbiAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgPT09IG1vZGFsKSBjbG9zZU1vZGFsKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEFicmlkb3JlczogY3VhbHF1aWVyIGVsZW1lbnRvIGNvbiBkYXRhLXJzdnAtb3BlblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yc3ZwLW9wZW5dLCBbZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJdLCAucnN2cC1ib3RvbicpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIG9wZW5Nb2RhbCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG5cclxuLy8gRXN0YWRvIGludGVybm8gZGVsIHNlbGVjdG9yIFPDrS9Ob1xyXG52YXIgY29uZmlybWFWYWxvciA9IFwic2lcIjsgLy8gZGVmYXVsdFxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlybWFVSSh2YWxvciwgY29sb3IpIHtcclxuICB2YXIgY29udCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbiAgaWYgKCFjb250KSByZXR1cm47XHJcbiAgdmFyIGJ0blNpID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cInNpXCJdJyk7XHJcbiAgdmFyIGJ0bk5vID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cIm5vXCJdJyk7XHJcbiAgY29uZmlybWFWYWxvciA9ICh2YWxvciA9PT0gXCJub1wiKSA/IFwibm9cIiA6IFwic2lcIjtcclxuXHJcbiAgaWYgKGJ0blNpICYmIGJ0bk5vKSB7XHJcbiAgICBpZiAoY29uZmlybWFWYWxvciA9PT0gXCJzaVwiKSB7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcjtcclxuICAgICAgYnRuU2kuc3R5bGUuY29sb3IgPSBcIiNmZmZcIjtcclxuICAgICAgYnRuU2kuc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKTtcclxuXHJcbiAgICAgIGJ0bk5vLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgYnRuTm8uc3R5bGUuY29sb3IgPSBcIiM0NDRcIjtcclxuICAgICAgYnRuTm8uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidG5Oby5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3I7XHJcbiAgICAgIGJ0bk5vLnN0eWxlLmNvbG9yID0gXCIjZmZmXCI7XHJcbiAgICAgIGJ0bk5vLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XHJcblxyXG4gICAgICBidG5TaS5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZjZmNmY2XCI7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmNvbG9yID0gXCIjNDQ0XCI7XHJcbiAgICAgIGJ0blNpLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+UuSBEZWphciBcIlPDrVwiIHNlbGVjY2lvbmFkbyBhbCBjYXJnYXJcclxuc2V0Q29uZmlybWFVSShcInNpXCIsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcblxyXG4vLyDwn5S5IEFsdGVybmFyIHNlbGVjY2nDs24gYWwgY2xpY2tcclxudmFyIGNvbmZpcm1hV3JhcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbmlmIChjb25maXJtYVdyYXApIHtcclxuICBjb25maXJtYVdyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgYnRuID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtY29uZmlybWFdJyk7XHJcbiAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG4gICAgdmFyIHYgPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm1hJyk7XHJcbiAgICBzZXRDb25maXJtYVVJKHYsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcbiAgICB0cnkgeyBjb25zb2xlLmxvZyhcIltSU1ZQXSBjYW1iaWEgY29uZmlybWFWYWxvciA9XCIsIHYpOyB9IGNhdGNoKF8pIHt9XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICAvLyDinIUgRW52w61vIGNvbiBGaXJlc3RvcmUgKyBsb2dzXHJcbmlmIChzZW5kQnRuKSB7XHJcbiAgc2VuZEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5vbWJyZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1ub21icmUnKSB8fCB7fSkudmFsdWUgfHwgJyc7XHJcbiAgICB2YXIgbWVuc2FqZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1tZW5zYWplJykgfHwge30pLnZhbHVlIHx8ICcnO1xyXG5cclxuICAgIGlmICghbm9tYnJlLnRyaW0oKSkge1xyXG4gICAgICBhbGVydCgnUG9yIGZhdm9yIGluZ3Jlc8OhIHR1IG5vbWJyZS4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpcm1hID0gKGNvbmZpcm1hVmFsb3IgPT09IFwic2lcIik7IFxyXG4gICAgY29uc3Qgc2x1ZyA9IGdldFNsdWdEZVBhZ2luYSgpO1xyXG4gICAgY29uc29sZS5sb2coXCJbUlNWUF0gRW52aWFuZG8gUlNWUOKApiBzbHVnID1cIiwgc2x1Zyk7XHJcblxyXG4gICAgLy8gKG9wY2lvbmFsKSBzaSBzZWd1w61zIHVzYW5kbyBzaGVldFVybCwgbWFudGVuZW1vcyBlbCBQT1NUIOKAnGVuIHBhcmFsZWxv4oCdXHJcbiAgICB2YXIgc2hlZXRVcmwgPSAke0pTT04uc3RyaW5naWZ5KGNmZy5zaGVldFVybCB8fCBcIlwiKX07XHJcbiAgICBpZiAoc2hlZXRVcmwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmZXRjaChzaGVldFVybCwge1xyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgbm9tYnJlOiBub21icmUudHJpbSgpLFxyXG4gICAgICAgICAgICBtZW5zYWplOiBtZW5zYWplLnRyaW0oKSxcclxuICAgICAgICAgICAgc2x1Zzogc2x1ZyxcclxuICAgICAgICAgICAgdHM6IERhdGUubm93KClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSl7IGNvbnNvbGUud2FybihcIltSU1ZQXSBzaGVldFVybCBlcnJvcjpcIiwgZSk7IH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1JTVlBdIHNoZWV0VXJsIHRocm93OlwiLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIPCflIwgSW1wb3J0YXIgRmlyZWJhc2UgZGluw6FtaWNhbWVudGUgeSBndWFyZGFyIGVuIEZpcmVzdG9yZVxyXG4gICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtYXBwLmpzXCIpLFxyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtZmlyZXN0b3JlLmpzXCIpLFxyXG4gICAgXSlcclxuICAgIC50aGVuKChbYXBwTW9kLCBmc01vZF0pID0+IHtcclxuICAgICAgY29uc3QgeyBpbml0aWFsaXplQXBwIH0gPSBhcHBNb2Q7XHJcbiAgICAgIGNvbnN0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCB9ID0gZnNNb2Q7XHJcblxyXG4gICAgICAvLyDimpnvuI8gQ29uZmlnIG3DrW5pbWEgKGFwaUtleSB5IHByb2plY3RJZCBzb24gc3VmaWNpZW50ZXMgcGFyYSBlbCBjbGllbnRlKVxuICAgICAgY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gICAgICAgIGFwaUtleTogXCJBSXphU3lBTEN2VTQ4X0hScDI2Y1hwUWNUWDVTMzNBZHB3ZmwzejRcIixcbiAgICAgICAgYXV0aERvbWFpbjogXCJyZXNlcnZhZWxkaWEuY29tLmFyXCIsXG4gICAgICAgIHByb2plY3RJZDogXCJyZXNlcnZhZWxkaWEtN2E0NDBcIixcbiAgICAgICAgYXBwSWQ6IFwiMTo4NjA0OTU5NzU0MDY6d2ViOjNhNDlhZDBjZjU1ZDYwMzEzNTM0ZmZcIlxuICAgICAgfTtcblxyXG4gICAgICBjb25zdCBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcclxuICAgICAgY29uc3QgZGIgID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgIG5vbWJyZTogbm9tYnJlLnRyaW0oKSxcclxuICAgICAgICBtZW5zYWplOiAobWVuc2FqZSAmJiBtZW5zYWplLnRyaW0oKSkgfHwgbnVsbCxcclxuICAgICAgICBjb25maXJtYSxcclxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudC5zbGljZSgwLCA1MTIpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBQYXlsb2FkIGtleXMgPVwiLCBPYmplY3Qua2V5cyhwYXlsb2FkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFBheWxvYWQgPVwiLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcblxyXG4gICAgICByZXR1cm4gYWRkRG9jKGNvbGxlY3Rpb24oZGIsIFwicHVibGljYWRhc1wiLCBzbHVnLCBcInJzdnBzXCIpLCBwYXlsb2FkKTtcclxuICAgIH0pXHJcbiAgICAudGhlbigoZG9jUmVmKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFJTVlAgZ3VhcmRhZG8gY29uIElEOlwiLCBkb2NSZWYuaWQsIFwiZW4gL3B1YmxpY2FkYXMvXCIrc2x1ZytcIi9yc3Zwc1wiKTtcclxuICAgICAgYWxlcnQoJ8KhR3JhY2lhcyBwb3IgY29uZmlybWFyIHR1IGFzaXN0ZW5jaWEsICcgKyBub21icmUgKyAnIScpO1xyXG4gICAgICBjbG9zZU1vZGFsKCk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltSU1ZQXSBFcnJvciBndWFyZGFuZG8gZW4gRmlyZXN0b3JlOlwiLCBlcnIpO1xyXG4gICAgICBhbGVydCgnSHVibyB1biBlcnJvciBhbCBndWFyZGFyIHR1IGNvbmZpcm1hY2nDs24uIFByb2LDoSBkZSBudWV2by4nKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbiBcclxuICBcclxuXHJcbn0pO1xyXG48L3NjcmlwdD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhck1vZGFsUlNWUEhUTUwiLCJjZmciLCJlbmFibGVkIiwidGl0bGUiLCJzdWJ0aXRsZSIsImJ0blRleHQiLCJidXR0b25UZXh0IiwiY29sb3IiLCJwcmltYXJ5Q29sb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hlZXRVcmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarMotionEffectsRuntime.ts":
/*!************************************************************!*\
  !*** ./functions/src/utils/generarMotionEffectsRuntime.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarMotionEffectsRuntimeHTML: () => (/* binding */ generarMotionEffectsRuntimeHTML)\n/* harmony export */ });\nfunction generarMotionEffectsRuntimeHTML() {\n    return `\n<style>\n  .mefx-preparing .mefx-reveal-init,\n  .mefx-preparing .mefx-zoom-init,\n  .mefx-preparing .mefx-draw-init,\n  .mefx-preparing .mefx-stagger-item {\n    transition: none !important;\n  }\n\n  .mefx-reveal-init {\n    opacity: 0;\n    translate: 0 14px;\n    will-change: opacity, translate;\n    transition:\n      opacity 640ms cubic-bezier(0.22, 1, 0.36, 1),\n      translate 640ms cubic-bezier(0.22, 1, 0.36, 1);\n  }\n\n  .mefx-reveal-on {\n    opacity: 1;\n    translate: 0 0;\n  }\n\n  .mefx-zoom-init {\n    opacity: 0;\n    scale: 0.98;\n    transform-origin: center center;\n    will-change: opacity, scale;\n    transition:\n      opacity 620ms cubic-bezier(0.22, 1, 0.36, 1),\n      scale 760ms cubic-bezier(0.22, 1, 0.36, 1);\n  }\n\n  .mefx-zoom-on {\n    opacity: 1;\n    scale: 1;\n  }\n\n  .mefx-draw-init {\n    opacity: 0.95;\n    scale: 0 1;\n    transform-origin: left center;\n    will-change: scale;\n    transition:\n      opacity 520ms ease,\n      scale 800ms cubic-bezier(0.2, 0.8, 0.2, 1);\n  }\n\n  .mefx-draw-on {\n    opacity: 1;\n    scale: 1 1;\n  }\n\n  .mefx-hover {\n    cursor: pointer;\n    transform-origin: center center;\n    will-change: scale, opacity;\n    transition:\n      scale 230ms ease,\n      opacity 230ms ease;\n  }\n\n  .mefx-hover:hover {\n    scale: 1.01;\n  }\n\n  .mefx-hover:active {\n    scale: 0.99;\n  }\n\n  .mefx-hover:focus-visible {\n    outline: 2px solid rgba(119, 61, 190, 0.34);\n    outline-offset: 2px;\n  }\n\n  @keyframes mefxPulse {\n    0%, 100% {\n      opacity: 1;\n      filter: none;\n    }\n    50% {\n      opacity: 0.9;\n      filter: saturate(1.03);\n    }\n  }\n\n  @keyframes mefxPulseCountdownChip {\n    0%, 100% {\n      transform: translateY(0) scale(1);\n      box-shadow: 0 0 0 rgba(17, 24, 39, 0);\n    }\n    50% {\n      transform: translateY(-1px) scale(1.018);\n      box-shadow: 0 8px 16px rgba(17, 24, 39, 0.14);\n    }\n  }\n\n  .mefx-pulse {\n    animation: mefxPulse 2.6s ease-in-out infinite;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip {\n    animation: mefxPulseCountdownChip 2.6s ease-in-out infinite;\n    transform-origin: center center;\n    will-change: transform, box-shadow;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(1) {\n    animation-delay: 0ms;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(2) {\n    animation-delay: 90ms;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(3) {\n    animation-delay: 180ms;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(4) {\n    animation-delay: 270ms;\n  }\n\n  .mefx-stagger-item {\n    opacity: 0;\n    translate: 0 10px;\n    will-change: translate, opacity;\n    transition:\n      opacity 620ms cubic-bezier(0.22, 1, 0.36, 1),\n      translate 620ms cubic-bezier(0.22, 1, 0.36, 1);\n    transition-delay: var(--mefx-stagger-delay, 0ms);\n  }\n\n  .mefx-stagger-item.mefx-stagger-on {\n    opacity: 1;\n    translate: 0 0;\n  }\n\n  @keyframes mefxRevealMobileIn {\n    from {\n      opacity: 0;\n      translate: 0 10px;\n    }\n    to {\n      opacity: 1;\n      translate: 0 0;\n    }\n  }\n\n  @keyframes mefxZoomMobileIn {\n    from {\n      opacity: 0;\n      scale: 0.99;\n    }\n    to {\n      opacity: 1;\n      scale: 1;\n    }\n  }\n\n  @keyframes mefxDrawMobileIn {\n    from {\n      opacity: 0.95;\n      scale: 0 1;\n    }\n    to {\n      opacity: 1;\n      scale: 1 1;\n    }\n  }\n\n  @media (max-width: 767px) {\n    .mefx-reveal-init {\n      translate: 0 10px;\n      transition-duration: 540ms;\n    }\n\n    .mefx-zoom-init {\n      scale: 0.99;\n      transition-duration: 580ms;\n    }\n\n    .mefx-draw-init {\n      transition-duration: 640ms;\n    }\n\n    .mefx-stagger-item {\n      transition-duration: 540ms;\n    }\n\n    /* Fallback robusto mobile: cuando se agrega \"on\", forzamos keyframes */\n    .mefx-reveal-on {\n      animation: mefxRevealMobileIn 540ms cubic-bezier(0.22, 1, 0.36, 1) both;\n    }\n\n    .mefx-zoom-on {\n      animation: mefxZoomMobileIn 580ms cubic-bezier(0.22, 1, 0.36, 1) both;\n    }\n\n    .mefx-draw-on {\n      animation: mefxDrawMobileIn 640ms cubic-bezier(0.2, 0.8, 0.2, 1) both;\n    }\n\n    .mefx-stagger-item.mefx-stagger-on {\n      animation: mefxRevealMobileIn 540ms cubic-bezier(0.22, 1, 0.36, 1) both;\n      animation-delay: var(--mefx-stagger-delay, 0ms);\n    }\n  }\n\n  @media (prefers-reduced-motion: reduce) {\n    .mefx-reveal-init,\n    .mefx-zoom-init,\n    .mefx-draw-init,\n    .mefx-stagger-item {\n      opacity: 1 !important;\n      translate: 0 0 !important;\n      scale: 1 !important;\n      transition: none !important;\n    }\n\n    .mefx-pulse {\n      animation: none !important;\n    }\n\n    .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip {\n      animation: none !important;\n      transform: none !important;\n      box-shadow: none !important;\n    }\n  }\n</style>\n\n<script>\n(function(){\n  var VALID_EFFECTS = { none: 1, reveal: 1, draw: 1, zoom: 1, hover: 1, pulse: 1 };\n  var OBSERVED_EFFECTS = { reveal: 1, draw: 1, zoom: 1 };\n  var STAGGER_SELECTOR = \".galeria-celda\";\n  var PREPARING_CLASS = \"mefx-preparing\";\n  var RUNTIME_READY_EVENT = \"invitation-runtime-ready\";\n  var RUNTIME_FAIL_EVENT = \"invitation-runtime-failed\";\n  var LOADER_HIDDEN_EVENT = \"invitation-loader-hidden\";\n  var LOADER_WAIT_TIMEOUT_MS = 2400;\n  var READY_TIMEOUT_MS = 2600;\n  var FONTS_TIMEOUT_MS = 1200;\n  var bootStarted = false;\n\n  function normalizeEffect(value){\n    var normalized = String(value || \"\").trim().toLowerCase();\n    return VALID_EFFECTS[normalized] ? normalized : \"none\";\n  }\n\n  function normalizeType(value){\n    return String(value || \"\").trim().toLowerCase();\n  }\n\n  function setPreparingState(active){\n    if (!document.body || !document.body.classList) return;\n    if (active) {\n      document.body.classList.add(PREPARING_CLASS);\n      return;\n    }\n    document.body.classList.remove(PREPARING_CLASS);\n  }\n\n  function dispatchRuntimeEvent(name, detail){\n    try {\n      window.dispatchEvent(new CustomEvent(name, { detail: detail || {} }));\n    } catch (_error) {\n      // noop\n    }\n  }\n\n  function isReducedMotion(){\n    try {\n      return !!(window.matchMedia && window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches);\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  function waitForWindowLoad(maxWaitMs){\n    return new Promise(function(resolve){\n      if (document.readyState === \"complete\") {\n        resolve();\n        return;\n      }\n\n      var finished = false;\n      var onLoad = function(){\n        if (finished) return;\n        finished = true;\n        resolve();\n      };\n\n      window.addEventListener(\"load\", onLoad, { once: true });\n      window.setTimeout(function(){\n        if (finished) return;\n        finished = true;\n        resolve();\n      }, maxWaitMs);\n    });\n  }\n\n  function waitForFonts(maxWaitMs){\n    if (!document.fonts || !document.fonts.ready) {\n      return Promise.resolve();\n    }\n\n    return Promise.race([\n      document.fonts.ready.catch(function(){ return null; }),\n      new Promise(function(resolve){\n        window.setTimeout(resolve, maxWaitMs);\n      })\n    ]).then(function(){ return null; });\n  }\n\n  function waitForRuntimeReady(){\n    return Promise.all([\n      waitForWindowLoad(READY_TIMEOUT_MS),\n      waitForFonts(FONTS_TIMEOUT_MS)\n    ]).then(function(){ return null; });\n  }\n\n  function extractFirstUrl(value){\n    var raw = String(value || \"\");\n    if (!raw || raw === \"none\") return \"\";\n    var match = raw.match(/url\\((['\"]?)(.*?)\\\\1\\)/i);\n    if (!match || !match[2]) return \"\";\n    return match[2].trim();\n  }\n\n  function getFirstSectionBackgroundUrl(){\n    var firstSection = document.querySelector(\".sec\");\n    if (!firstSection) return \"\";\n    var bgNode = firstSection.querySelector(\".sec-bg\");\n    if (!bgNode) return \"\";\n\n    var inlineUrl = extractFirstUrl(bgNode.getAttribute(\"style\"));\n    if (inlineUrl) return inlineUrl;\n\n    try {\n      var computedUrl = extractFirstUrl(window.getComputedStyle(bgNode).backgroundImage);\n      return computedUrl;\n    } catch (_error) {\n      return \"\";\n    }\n  }\n\n  function loadImage(url){\n    return new Promise(function(resolve){\n      if (!url) {\n        resolve(true);\n        return;\n      }\n\n      var img = new Image();\n      img.decoding = \"async\";\n      img.loading = \"eager\";\n\n      img.onload = function(){\n        resolve(true);\n      };\n\n      img.onerror = function(){\n        resolve(false);\n      };\n\n      img.src = url;\n\n      if (img.complete && img.naturalWidth > 0) {\n        resolve(true);\n      }\n    });\n  }\n\n  function waitForFirstSectionBackground(){\n    var backgroundUrl = getFirstSectionBackgroundUrl();\n    return loadImage(backgroundUrl);\n  }\n\n  function waitForLoaderHidden(){\n    return new Promise(function(resolve){\n      var loaderNode = document.getElementById(\"inv-loader\");\n      if (!loaderNode) {\n        resolve();\n        return;\n      }\n\n      var finished = false;\n      function done(){\n        if (finished) return;\n        finished = true;\n        resolve();\n      }\n\n      window.addEventListener(LOADER_HIDDEN_EVENT, done, { once: true });\n      window.setTimeout(done, LOADER_WAIT_TIMEOUT_MS);\n    });\n  }\n\n  function prepareGalleryStagger(element){\n    var cells = Array.from(element.querySelectorAll(STAGGER_SELECTOR));\n    if (!cells.length) return [];\n\n    cells.forEach(function(cell, index){\n      var delayMs = Math.min(index, 11) * 70;\n      cell.style.setProperty(\"--mefx-stagger-delay\", delayMs + \"ms\");\n      cell.classList.add(\"mefx-stagger-item\");\n    });\n\n    return cells;\n  }\n\n  function prepareElement(element){\n    var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\n    var type = normalizeType(element.getAttribute(\"data-type\"));\n    element.setAttribute(\"data-motion\", effect);\n\n    if (effect === \"hover\") {\n      element.classList.add(\"mefx-hover\");\n    }\n\n    if (effect === \"pulse\" && (type === \"countdown\" || type === \"rsvp\")) {\n      element.classList.add(\"mefx-pulse\");\n    }\n\n    if (effect === \"reveal\") element.classList.add(\"mefx-reveal-init\");\n    if (effect === \"zoom\") element.classList.add(\"mefx-zoom-init\");\n    if (effect === \"draw\") element.classList.add(\"mefx-draw-init\");\n\n    if (type === \"gallery\" && effect === \"reveal\") {\n      prepareGalleryStagger(element);\n    }\n  }\n\n  function activateElement(element){\n    var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\n    var type = normalizeType(element.getAttribute(\"data-type\"));\n\n    if (effect === \"reveal\") element.classList.add(\"mefx-reveal-on\");\n    if (effect === \"zoom\") element.classList.add(\"mefx-zoom-on\");\n    if (effect === \"draw\") element.classList.add(\"mefx-draw-on\");\n\n    if (type === \"gallery\" && effect === \"reveal\") {\n      var staggerItems = Array.from(element.querySelectorAll(STAGGER_SELECTOR + \".mefx-stagger-item\"));\n      staggerItems.forEach(function(cell){\n        cell.classList.add(\"mefx-stagger-on\");\n      });\n    }\n  }\n\n  function boot(elements){\n    var list = Array.isArray(elements) ? elements : [];\n    if (!list.length) {\n      list = Array.from(document.querySelectorAll(\".objeto[data-motion]\"));\n    }\n\n    var elementsToAnimate = list;\n    if (!elementsToAnimate.length) return;\n\n    var reducedMotion = isReducedMotion();\n    if (reducedMotion || typeof IntersectionObserver === \"undefined\") {\n      setPreparingState(false);\n      elementsToAnimate.forEach(activateElement);\n      return;\n    }\n\n    // En mobile algunos navegadores colapsan \"quitar preparing + activar on\" en el mismo layout.\n    // Damos un frame para reactivar transiciones antes de observar/activar.\n    setPreparingState(false);\n    requestAnimationFrame(function(){\n      var queuedById = Object.create(null);\n      var queuedElements = [];\n      var activationReady = false;\n\n      function enqueueActivation(element){\n        if (!element || !element.getAttribute) return;\n        var key = element.getAttribute(\"data-motion-id\") || element.id || \"\";\n        if (!key) key = \"idx-\" + queuedElements.length;\n        if (queuedById[key]) return;\n        queuedById[key] = true;\n        queuedElements.push(element);\n      }\n\n      function activateOrQueue(element){\n        if (activationReady) {\n          activateElement(element);\n          return;\n        }\n        enqueueActivation(element);\n      }\n\n      var observer = new IntersectionObserver(\n        function(entries){\n          entries.forEach(function(entry){\n            if (!entry.isIntersecting) return;\n            activateOrQueue(entry.target);\n            observer.unobserve(entry.target);\n          });\n        },\n        {\n          root: null,\n          threshold: 0.16,\n          rootMargin: \"0px 0px -8% 0px\"\n        }\n      );\n\n      elementsToAnimate.forEach(function(element){\n        var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\n        if (OBSERVED_EFFECTS[effect]) {\n          observer.observe(element);\n          return;\n        }\n        activateOrQueue(element);\n      });\n\n      requestAnimationFrame(function(){\n        requestAnimationFrame(function(){\n          activationReady = true;\n          queuedElements.forEach(activateElement);\n          queuedElements = [];\n        });\n      });\n    });\n  }\n\n  function prepareAllElements(){\n    var elements = Array.from(document.querySelectorAll(\".objeto[data-motion]\"));\n    if (!elements.length) return;\n\n    setPreparingState(true);\n    elements.forEach(prepareElement);\n    return elements;\n  }\n\n  function startBoot(){\n    if (bootStarted) return;\n    bootStarted = true;\n\n    waitForRuntimeReady().then(function(){\n      waitForFirstSectionBackground().then(function(backgroundReady){\n        if (!backgroundReady) {\n          dispatchRuntimeEvent(RUNTIME_FAIL_EVENT, { reason: \"first-background-failed\" });\n          return;\n        }\n\n        var preparedElements = prepareAllElements() || [];\n        dispatchRuntimeEvent(RUNTIME_READY_EVENT, { source: \"motion-effects-runtime\" });\n        waitForLoaderHidden().then(function(){\n          requestAnimationFrame(function(){\n            requestAnimationFrame(function(){\n              boot(preparedElements);\n            });\n          });\n        });\n      });\n    });\n  }\n\n  startBoot();\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtqQlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWVIVE1MKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG48c3R5bGU+XG4gIC5tZWZ4LXByZXBhcmluZyAubWVmeC1yZXZlYWwtaW5pdCxcbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LXpvb20taW5pdCxcbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LWRyYXctaW5pdCxcbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICB9XG5cbiAgLm1lZngtcmV2ZWFsLWluaXQge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdHJhbnNsYXRlOiAwIDE0cHg7XG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHksIHRyYW5zbGF0ZTtcbiAgICB0cmFuc2l0aW9uOlxuICAgICAgb3BhY2l0eSA2NDBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSksXG4gICAgICB0cmFuc2xhdGUgNjQwbXMgY3ViaWMtYmV6aWVyKDAuMjIsIDEsIDAuMzYsIDEpO1xuICB9XG5cbiAgLm1lZngtcmV2ZWFsLW9uIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zbGF0ZTogMCAwO1xuICB9XG5cbiAgLm1lZngtem9vbS1pbml0IHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHNjYWxlOiAwLjk4O1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHksIHNjYWxlO1xuICAgIHRyYW5zaXRpb246XG4gICAgICBvcGFjaXR5IDYyMG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSxcbiAgICAgIHNjYWxlIDc2MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKTtcbiAgfVxuXG4gIC5tZWZ4LXpvb20tb24ge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgc2NhbGU6IDE7XG4gIH1cblxuICAubWVmeC1kcmF3LWluaXQge1xuICAgIG9wYWNpdHk6IDAuOTU7XG4gICAgc2NhbGU6IDAgMTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGNlbnRlcjtcbiAgICB3aWxsLWNoYW5nZTogc2NhbGU7XG4gICAgdHJhbnNpdGlvbjpcbiAgICAgIG9wYWNpdHkgNTIwbXMgZWFzZSxcbiAgICAgIHNjYWxlIDgwMG1zIGN1YmljLWJlemllcigwLjIsIDAuOCwgMC4yLCAxKTtcbiAgfVxuXG4gIC5tZWZ4LWRyYXctb24ge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgc2NhbGU6IDEgMTtcbiAgfVxuXG4gIC5tZWZ4LWhvdmVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcbiAgICB3aWxsLWNoYW5nZTogc2NhbGUsIG9wYWNpdHk7XG4gICAgdHJhbnNpdGlvbjpcbiAgICAgIHNjYWxlIDIzMG1zIGVhc2UsXG4gICAgICBvcGFjaXR5IDIzMG1zIGVhc2U7XG4gIH1cblxuICAubWVmeC1ob3Zlcjpob3ZlciB7XG4gICAgc2NhbGU6IDEuMDE7XG4gIH1cblxuICAubWVmeC1ob3ZlcjphY3RpdmUge1xuICAgIHNjYWxlOiAwLjk5O1xuICB9XG5cbiAgLm1lZngtaG92ZXI6Zm9jdXMtdmlzaWJsZSB7XG4gICAgb3V0bGluZTogMnB4IHNvbGlkIHJnYmEoMTE5LCA2MSwgMTkwLCAwLjM0KTtcbiAgICBvdXRsaW5lLW9mZnNldDogMnB4O1xuICB9XG5cbiAgQGtleWZyYW1lcyBtZWZ4UHVsc2Uge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICBmaWx0ZXI6IG5vbmU7XG4gICAgfVxuICAgIDUwJSB7XG4gICAgICBvcGFjaXR5OiAwLjk7XG4gICAgICBmaWx0ZXI6IHNhdHVyYXRlKDEuMDMpO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeFB1bHNlQ291bnRkb3duQ2hpcCB7XG4gICAgMCUsIDEwMCUge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApIHNjYWxlKDEpO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDAgcmdiYSgxNywgMjQsIDM5LCAwKTtcbiAgICB9XG4gICAgNTAlIHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KSBzY2FsZSgxLjAxOCk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAxNnB4IHJnYmEoMTcsIDI0LCAzOSwgMC4xNCk7XG4gICAgfVxuICB9XG5cbiAgLm1lZngtcHVsc2Uge1xuICAgIGFuaW1hdGlvbjogbWVmeFB1bHNlIDIuNnMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwIHtcbiAgICBhbmltYXRpb246IG1lZnhQdWxzZUNvdW50ZG93bkNoaXAgMi42cyBlYXNlLWluLW91dCBpbmZpbml0ZTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm0sIGJveC1zaGFkb3c7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCgxKSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAwbXM7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCgyKSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiA5MG1zO1xuICB9XG5cbiAgLm9iamV0b1tkYXRhLXR5cGU9XCJjb3VudGRvd25cIl0ubWVmeC1wdWxzZSAuY2QtY2hpcDpudGgtY2hpbGQoMykge1xuICAgIGFuaW1hdGlvbi1kZWxheTogMTgwbXM7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCg0KSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAyNzBtcztcbiAgfVxuXG4gIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2xhdGU6IDAgMTBweDtcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNsYXRlLCBvcGFjaXR5O1xuICAgIHRyYW5zaXRpb246XG4gICAgICBvcGFjaXR5IDYyMG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSxcbiAgICAgIHRyYW5zbGF0ZSA2MjBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSk7XG4gICAgdHJhbnNpdGlvbi1kZWxheTogdmFyKC0tbWVmeC1zdGFnZ2VyLWRlbGF5LCAwbXMpO1xuICB9XG5cbiAgLm1lZngtc3RhZ2dlci1pdGVtLm1lZngtc3RhZ2dlci1vbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2xhdGU6IDAgMDtcbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeFJldmVhbE1vYmlsZUluIHtcbiAgICBmcm9tIHtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB0cmFuc2xhdGU6IDAgMTBweDtcbiAgICB9XG4gICAgdG8ge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIHRyYW5zbGF0ZTogMCAwO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeFpvb21Nb2JpbGVJbiB7XG4gICAgZnJvbSB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgICAgc2NhbGU6IDAuOTk7XG4gICAgfVxuICAgIHRvIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICBzY2FsZTogMTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIG1lZnhEcmF3TW9iaWxlSW4ge1xuICAgIGZyb20ge1xuICAgICAgb3BhY2l0eTogMC45NTtcbiAgICAgIHNjYWxlOiAwIDE7XG4gICAgfVxuICAgIHRvIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICBzY2FsZTogMSAxO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkge1xuICAgIC5tZWZ4LXJldmVhbC1pbml0IHtcbiAgICAgIHRyYW5zbGF0ZTogMCAxMHB4O1xuICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNTQwbXM7XG4gICAgfVxuXG4gICAgLm1lZngtem9vbS1pbml0IHtcbiAgICAgIHNjYWxlOiAwLjk5O1xuICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNTgwbXM7XG4gICAgfVxuXG4gICAgLm1lZngtZHJhdy1pbml0IHtcbiAgICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDY0MG1zO1xuICAgIH1cblxuICAgIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiA1NDBtcztcbiAgICB9XG5cbiAgICAvKiBGYWxsYmFjayByb2J1c3RvIG1vYmlsZTogY3VhbmRvIHNlIGFncmVnYSBcIm9uXCIsIGZvcnphbW9zIGtleWZyYW1lcyAqL1xuICAgIC5tZWZ4LXJldmVhbC1vbiB7XG4gICAgICBhbmltYXRpb246IG1lZnhSZXZlYWxNb2JpbGVJbiA1NDBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSkgYm90aDtcbiAgICB9XG5cbiAgICAubWVmeC16b29tLW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeFpvb21Nb2JpbGVJbiA1ODBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSkgYm90aDtcbiAgICB9XG5cbiAgICAubWVmeC1kcmF3LW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeERyYXdNb2JpbGVJbiA2NDBtcyBjdWJpYy1iZXppZXIoMC4yLCAwLjgsIDAuMiwgMSkgYm90aDtcbiAgICB9XG5cbiAgICAubWVmeC1zdGFnZ2VyLWl0ZW0ubWVmeC1zdGFnZ2VyLW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeFJldmVhbE1vYmlsZUluIDU0MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSBib3RoO1xuICAgICAgYW5pbWF0aW9uLWRlbGF5OiB2YXIoLS1tZWZ4LXN0YWdnZXItZGVsYXksIDBtcyk7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpIHtcbiAgICAubWVmeC1yZXZlYWwtaW5pdCxcbiAgICAubWVmeC16b29tLWluaXQsXG4gICAgLm1lZngtZHJhdy1pbml0LFxuICAgIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICB0cmFuc2xhdGU6IDAgMCAhaW1wb3J0YW50O1xuICAgICAgc2NhbGU6IDEgIWltcG9ydGFudDtcbiAgICAgIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAubWVmeC1wdWxzZSB7XG4gICAgICBhbmltYXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwIHtcbiAgICAgIGFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCl7XG4gIHZhciBWQUxJRF9FRkZFQ1RTID0geyBub25lOiAxLCByZXZlYWw6IDEsIGRyYXc6IDEsIHpvb206IDEsIGhvdmVyOiAxLCBwdWxzZTogMSB9O1xuICB2YXIgT0JTRVJWRURfRUZGRUNUUyA9IHsgcmV2ZWFsOiAxLCBkcmF3OiAxLCB6b29tOiAxIH07XG4gIHZhciBTVEFHR0VSX1NFTEVDVE9SID0gXCIuZ2FsZXJpYS1jZWxkYVwiO1xuICB2YXIgUFJFUEFSSU5HX0NMQVNTID0gXCJtZWZ4LXByZXBhcmluZ1wiO1xuICB2YXIgUlVOVElNRV9SRUFEWV9FVkVOVCA9IFwiaW52aXRhdGlvbi1ydW50aW1lLXJlYWR5XCI7XG4gIHZhciBSVU5USU1FX0ZBSUxfRVZFTlQgPSBcImludml0YXRpb24tcnVudGltZS1mYWlsZWRcIjtcbiAgdmFyIExPQURFUl9ISURERU5fRVZFTlQgPSBcImludml0YXRpb24tbG9hZGVyLWhpZGRlblwiO1xuICB2YXIgTE9BREVSX1dBSVRfVElNRU9VVF9NUyA9IDI0MDA7XG4gIHZhciBSRUFEWV9USU1FT1VUX01TID0gMjYwMDtcbiAgdmFyIEZPTlRTX1RJTUVPVVRfTVMgPSAxMjAwO1xuICB2YXIgYm9vdFN0YXJ0ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVFZmZlY3QodmFsdWUpe1xuICAgIHZhciBub3JtYWxpemVkID0gU3RyaW5nKHZhbHVlIHx8IFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBWQUxJRF9FRkZFQ1RTW25vcm1hbGl6ZWRdID8gbm9ybWFsaXplZCA6IFwibm9uZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVHlwZSh2YWx1ZSl7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSB8fCBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByZXBhcmluZ1N0YXRlKGFjdGl2ZSl7XG4gICAgaWYgKCFkb2N1bWVudC5ib2R5IHx8ICFkb2N1bWVudC5ib2R5LmNsYXNzTGlzdCkgcmV0dXJuO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChQUkVQQVJJTkdfQ0xBU1MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoUFJFUEFSSU5HX0NMQVNTKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoUnVudGltZUV2ZW50KG5hbWUsIGRldGFpbCl7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCB7IGRldGFpbDogZGV0YWlsIHx8IHt9IH0pKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZHVjZWRNb3Rpb24oKXtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhKHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvcldpbmRvd0xvYWQobWF4V2FpdE1zKXtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSl7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCBtYXhXYWl0TXMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvckZvbnRzKG1heFdhaXRNcyl7XG4gICAgaWYgKCFkb2N1bWVudC5mb250cyB8fCAhZG9jdW1lbnQuZm9udHMucmVhZHkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIGRvY3VtZW50LmZvbnRzLnJlYWR5LmNhdGNoKGZ1bmN0aW9uKCl7IHJldHVybiBudWxsOyB9KSxcbiAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCBtYXhXYWl0TXMpO1xuICAgICAgfSlcbiAgICBdKS50aGVuKGZ1bmN0aW9uKCl7IHJldHVybiBudWxsOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JSdW50aW1lUmVhZHkoKXtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgd2FpdEZvcldpbmRvd0xvYWQoUkVBRFlfVElNRU9VVF9NUyksXG4gICAgICB3YWl0Rm9yRm9udHMoRk9OVFNfVElNRU9VVF9NUylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKCl7IHJldHVybiBudWxsOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RGaXJzdFVybCh2YWx1ZSl7XG4gICAgdmFyIHJhdyA9IFN0cmluZyh2YWx1ZSB8fCBcIlwiKTtcbiAgICBpZiAoIXJhdyB8fCByYXcgPT09IFwibm9uZVwiKSByZXR1cm4gXCJcIjtcbiAgICB2YXIgbWF0Y2ggPSByYXcubWF0Y2goL3VybFxcKChbJ1wiXT8pKC4qPylcXFxcMVxcKS9pKTtcbiAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaFsyXSkgcmV0dXJuIFwiXCI7XG4gICAgcmV0dXJuIG1hdGNoWzJdLnRyaW0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0U2VjdGlvbkJhY2tncm91bmRVcmwoKXtcbiAgICB2YXIgZmlyc3RTZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zZWNcIik7XG4gICAgaWYgKCFmaXJzdFNlY3Rpb24pIHJldHVybiBcIlwiO1xuICAgIHZhciBiZ05vZGUgPSBmaXJzdFNlY3Rpb24ucXVlcnlTZWxlY3RvcihcIi5zZWMtYmdcIik7XG4gICAgaWYgKCFiZ05vZGUpIHJldHVybiBcIlwiO1xuXG4gICAgdmFyIGlubGluZVVybCA9IGV4dHJhY3RGaXJzdFVybChiZ05vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpO1xuICAgIGlmIChpbmxpbmVVcmwpIHJldHVybiBpbmxpbmVVcmw7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGNvbXB1dGVkVXJsID0gZXh0cmFjdEZpcnN0VXJsKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJnTm9kZSkuYmFja2dyb3VuZEltYWdlKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVybDtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpe1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKXtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLmRlY29kaW5nID0gXCJhc3luY1wiO1xuICAgICAgaW1nLmxvYWRpbmcgPSBcImVhZ2VyXCI7XG5cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH07XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG5cbiAgICAgIGlmIChpbWcuY29tcGxldGUgJiYgaW1nLm5hdHVyYWxXaWR0aCA+IDApIHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JGaXJzdFNlY3Rpb25CYWNrZ3JvdW5kKCl7XG4gICAgdmFyIGJhY2tncm91bmRVcmwgPSBnZXRGaXJzdFNlY3Rpb25CYWNrZ3JvdW5kVXJsKCk7XG4gICAgcmV0dXJuIGxvYWRJbWFnZShiYWNrZ3JvdW5kVXJsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JMb2FkZXJIaWRkZW4oKXtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSl7XG4gICAgICB2YXIgbG9hZGVyTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW52LWxvYWRlclwiKTtcbiAgICAgIGlmICghbG9hZGVyTm9kZSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBkb25lKCl7XG4gICAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoTE9BREVSX0hJRERFTl9FVkVOVCwgZG9uZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZG9uZSwgTE9BREVSX1dBSVRfVElNRU9VVF9NUyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlR2FsbGVyeVN0YWdnZXIoZWxlbWVudCl7XG4gICAgdmFyIGNlbGxzID0gQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU1RBR0dFUl9TRUxFQ1RPUikpO1xuICAgIGlmICghY2VsbHMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGluZGV4KXtcbiAgICAgIHZhciBkZWxheU1zID0gTWF0aC5taW4oaW5kZXgsIDExKSAqIDcwO1xuICAgICAgY2VsbC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbWVmeC1zdGFnZ2VyLWRlbGF5XCIsIGRlbGF5TXMgKyBcIm1zXCIpO1xuICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKFwibWVmeC1zdGFnZ2VyLWl0ZW1cIik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2VsbHM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlRWxlbWVudChlbGVtZW50KXtcbiAgICB2YXIgZWZmZWN0ID0gbm9ybWFsaXplRWZmZWN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb25cIikpO1xuICAgIHZhciB0eXBlID0gbm9ybWFsaXplVHlwZShlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1vdGlvblwiLCBlZmZlY3QpO1xuXG4gICAgaWYgKGVmZmVjdCA9PT0gXCJob3ZlclwiKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LWhvdmVyXCIpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3QgPT09IFwicHVsc2VcIiAmJiAodHlwZSA9PT0gXCJjb3VudGRvd25cIiB8fCB0eXBlID09PSBcInJzdnBcIikpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtcHVsc2VcIik7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdCA9PT0gXCJyZXZlYWxcIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC1yZXZlYWwtaW5pdFwiKTtcbiAgICBpZiAoZWZmZWN0ID09PSBcInpvb21cIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC16b29tLWluaXRcIik7XG4gICAgaWYgKGVmZmVjdCA9PT0gXCJkcmF3XCIpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtZHJhdy1pbml0XCIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZ2FsbGVyeVwiICYmIGVmZmVjdCA9PT0gXCJyZXZlYWxcIikge1xuICAgICAgcHJlcGFyZUdhbGxlcnlTdGFnZ2VyKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlRWxlbWVudChlbGVtZW50KXtcbiAgICB2YXIgZWZmZWN0ID0gbm9ybWFsaXplRWZmZWN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb25cIikpO1xuICAgIHZhciB0eXBlID0gbm9ybWFsaXplVHlwZShlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSk7XG5cbiAgICBpZiAoZWZmZWN0ID09PSBcInJldmVhbFwiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXJldmVhbC1vblwiKTtcbiAgICBpZiAoZWZmZWN0ID09PSBcInpvb21cIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC16b29tLW9uXCIpO1xuICAgIGlmIChlZmZlY3QgPT09IFwiZHJhd1wiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LWRyYXctb25cIik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJnYWxsZXJ5XCIgJiYgZWZmZWN0ID09PSBcInJldmVhbFwiKSB7XG4gICAgICB2YXIgc3RhZ2dlckl0ZW1zID0gQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU1RBR0dFUl9TRUxFQ1RPUiArIFwiLm1lZngtc3RhZ2dlci1pdGVtXCIpKTtcbiAgICAgIHN0YWdnZXJJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpe1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXN0YWdnZXItb25cIik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBib290KGVsZW1lbnRzKXtcbiAgICB2YXIgbGlzdCA9IEFycmF5LmlzQXJyYXkoZWxlbWVudHMpID8gZWxlbWVudHMgOiBbXTtcbiAgICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgICBsaXN0ID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1tkYXRhLW1vdGlvbl1cIikpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50c1RvQW5pbWF0ZSA9IGxpc3Q7XG4gICAgaWYgKCFlbGVtZW50c1RvQW5pbWF0ZS5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciByZWR1Y2VkTW90aW9uID0gaXNSZWR1Y2VkTW90aW9uKCk7XG4gICAgaWYgKHJlZHVjZWRNb3Rpb24gfHwgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBzZXRQcmVwYXJpbmdTdGF0ZShmYWxzZSk7XG4gICAgICBlbGVtZW50c1RvQW5pbWF0ZS5mb3JFYWNoKGFjdGl2YXRlRWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRW4gbW9iaWxlIGFsZ3Vub3MgbmF2ZWdhZG9yZXMgY29sYXBzYW4gXCJxdWl0YXIgcHJlcGFyaW5nICsgYWN0aXZhciBvblwiIGVuIGVsIG1pc21vIGxheW91dC5cbiAgICAvLyBEYW1vcyB1biBmcmFtZSBwYXJhIHJlYWN0aXZhciB0cmFuc2ljaW9uZXMgYW50ZXMgZGUgb2JzZXJ2YXIvYWN0aXZhci5cbiAgICBzZXRQcmVwYXJpbmdTdGF0ZShmYWxzZSk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcXVldWVkQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcXVldWVkRWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBhY3RpdmF0aW9uUmVhZHkgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gZW5xdWV1ZUFjdGl2YXRpb24oZWxlbWVudCl7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHJldHVybjtcbiAgICAgICAgdmFyIGtleSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb24taWRcIikgfHwgZWxlbWVudC5pZCB8fCBcIlwiO1xuICAgICAgICBpZiAoIWtleSkga2V5ID0gXCJpZHgtXCIgKyBxdWV1ZWRFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChxdWV1ZWRCeUlkW2tleV0pIHJldHVybjtcbiAgICAgICAgcXVldWVkQnlJZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgcXVldWVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWN0aXZhdGVPclF1ZXVlKGVsZW1lbnQpe1xuICAgICAgICBpZiAoYWN0aXZhdGlvblJlYWR5KSB7XG4gICAgICAgICAgYWN0aXZhdGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlQWN0aXZhdGlvbihlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICBmdW5jdGlvbihlbnRyaWVzKXtcbiAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpe1xuICAgICAgICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgYWN0aXZhdGVPclF1ZXVlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3Q6IG51bGwsXG4gICAgICAgICAgdGhyZXNob2xkOiAwLjE2LFxuICAgICAgICAgIHJvb3RNYXJnaW46IFwiMHB4IDBweCAtOCUgMHB4XCJcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgZWxlbWVudHNUb0FuaW1hdGUuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KXtcbiAgICAgICAgdmFyIGVmZmVjdCA9IG5vcm1hbGl6ZUVmZmVjdChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbW90aW9uXCIpKTtcbiAgICAgICAgaWYgKE9CU0VSVkVEX0VGRkVDVFNbZWZmZWN0XSkge1xuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2YXRlT3JRdWV1ZShlbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgYWN0aXZhdGlvblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICBxdWV1ZWRFbGVtZW50cy5mb3JFYWNoKGFjdGl2YXRlRWxlbWVudCk7XG4gICAgICAgICAgcXVldWVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVBbGxFbGVtZW50cygpe1xuICAgIHZhciBlbGVtZW50cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9bZGF0YS1tb3Rpb25dXCIpKTtcbiAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgc2V0UHJlcGFyaW5nU3RhdGUodHJ1ZSk7XG4gICAgZWxlbWVudHMuZm9yRWFjaChwcmVwYXJlRWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRCb290KCl7XG4gICAgaWYgKGJvb3RTdGFydGVkKSByZXR1cm47XG4gICAgYm9vdFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgd2FpdEZvclJ1bnRpbWVSZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgIHdhaXRGb3JGaXJzdFNlY3Rpb25CYWNrZ3JvdW5kKCkudGhlbihmdW5jdGlvbihiYWNrZ3JvdW5kUmVhZHkpe1xuICAgICAgICBpZiAoIWJhY2tncm91bmRSZWFkeSkge1xuICAgICAgICAgIGRpc3BhdGNoUnVudGltZUV2ZW50KFJVTlRJTUVfRkFJTF9FVkVOVCwgeyByZWFzb246IFwiZmlyc3QtYmFja2dyb3VuZC1mYWlsZWRcIiB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlcGFyZWRFbGVtZW50cyA9IHByZXBhcmVBbGxFbGVtZW50cygpIHx8IFtdO1xuICAgICAgICBkaXNwYXRjaFJ1bnRpbWVFdmVudChSVU5USU1FX1JFQURZX0VWRU5ULCB7IHNvdXJjZTogXCJtb3Rpb24tZWZmZWN0cy1ydW50aW1lXCIgfSk7XG4gICAgICAgIHdhaXRGb3JMb2FkZXJIaWRkZW4oKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgYm9vdChwcmVwYXJlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhcnRCb290KCk7XG59KSgpO1xuPC9zY3JpcHQ+XG5gLnRyaW0oKTtcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWVIVE1MIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarMotionEffectsRuntime.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/config.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/config.ts\nfunction normalizeConfig(opts) {\n    const fitMinScaleRaw = Number.isFinite(opts.fitMinScale) ? Number(opts.fitMinScale) : 0.88;\n    const fitMaxScaleRaw = Number.isFinite(opts.fitMaxScale) ? Number(opts.fitMaxScale) : 1.16;\n    const fitMinScale = Math.max(0.7, Math.min(1, fitMinScaleRaw));\n    const fitMaxScale = Math.max(1, fitMaxScaleRaw);\n    const fitTargetWidthRatioRaw = Number.isFinite(opts.fitTargetWidthRatio) ? Number(opts.fitTargetWidthRatio) : 0.94;\n    const fitTargetWidthRatio = Math.max(0.75, Math.min(0.99, fitTargetWidthRatioRaw));\n    const fitMinFillRatioRaw = Number.isFinite(opts.fitMinFillRatio) ? Number(opts.fitMinFillRatio) : 0.9;\n    const fitMinFillRatio = Math.max(0.6, Math.min(fitTargetWidthRatio, fitMinFillRatioRaw));\n    return {\n        enabled: !!opts.enabled,\n        minGapPx: Number.isFinite(opts.minGapPx) ? Number(opts.minGapPx) : 8,\n        paddingTopPx: Number.isFinite(opts.paddingTopPx) ? Number(opts.paddingTopPx) : 0,\n        paddingBottomPx: Number.isFinite(opts.paddingBottomPx) ? Number(opts.paddingBottomPx) : 12,\n        maxGapPx: Number.isFinite(opts.maxGapPx) ? Number(opts.maxGapPx) : 22,\n        onlyFixedSections: opts.onlyFixedSections !== false,\n        onlyWhenReordered: opts.onlyWhenReordered !== false,\n        rowTolPx: Number.isFinite(opts.rowTolPx) ? Number(opts.rowTolPx) : 28,\n        twoColSpreadRatio: Number.isFinite(opts.twoColSpreadRatio) ? Number(opts.twoColSpreadRatio) : 0.18,\n        minPerColumn2: Number.isFinite(opts.minPerColumn2) ? Number(opts.minPerColumn2) : 2,\n        threeColSpreadRatio: Number.isFinite(opts.threeColSpreadRatio) ? Number(opts.threeColSpreadRatio) : 0.22,\n        minPerColumn3: Number.isFinite(opts.minPerColumn3) ? Number(opts.minPerColumn3) : 2,\n        gapScale: Number.isFinite(opts.gapScale) ? Number(opts.gapScale) : 0.6,\n        fitMinScale,\n        fitMaxScale,\n        fitTargetWidthRatio,\n        fitMinFillRatio\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrREFBa0Q7QUFPM0MsU0FBU0EsZ0JBQWdCQyxJQUE4QjtJQUM1RCxNQUFNQyxpQkFBaUJDLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS0ksV0FBVyxJQUFJRixPQUFPRixLQUFLSSxXQUFXLElBQUk7SUFDdEYsTUFBTUMsaUJBQWlCSCxPQUFPQyxRQUFRLENBQUNILEtBQUtNLFdBQVcsSUFBSUosT0FBT0YsS0FBS00sV0FBVyxJQUFJO0lBQ3RGLE1BQU1GLGNBQWNHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLRSxHQUFHLENBQUMsR0FBR1I7SUFDOUMsTUFBTUssY0FBY0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdIO0lBQ2hDLE1BQU1LLHlCQUF5QlIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLVyxtQkFBbUIsSUFDbkVULE9BQU9GLEtBQUtXLG1CQUFtQixJQUMvQjtJQUNKLE1BQU1BLHNCQUFzQkosS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxNQUFNQztJQUMxRCxNQUFNRSxxQkFBcUJWLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS2EsZUFBZSxJQUMzRFgsT0FBT0YsS0FBS2EsZUFBZSxJQUMzQjtJQUNKLE1BQU1BLGtCQUFrQk4sS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtFLEdBQUcsQ0FBQ0UscUJBQXFCQztJQUVwRSxPQUFPO1FBQ0xFLFNBQVMsQ0FBQyxDQUFDZCxLQUFLYyxPQUFPO1FBRXZCQyxVQUFVYixPQUFPQyxRQUFRLENBQUNILEtBQUtlLFFBQVEsSUFBSWIsT0FBT0YsS0FBS2UsUUFBUSxJQUFJO1FBQ25FQyxjQUFjZCxPQUFPQyxRQUFRLENBQUNILEtBQUtnQixZQUFZLElBQUlkLE9BQU9GLEtBQUtnQixZQUFZLElBQUk7UUFDL0VDLGlCQUFpQmYsT0FBT0MsUUFBUSxDQUFDSCxLQUFLaUIsZUFBZSxJQUFJZixPQUFPRixLQUFLaUIsZUFBZSxJQUFJO1FBQ3hGQyxVQUFVaEIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLa0IsUUFBUSxJQUFJaEIsT0FBT0YsS0FBS2tCLFFBQVEsSUFBSTtRQUVuRUMsbUJBQW1CbkIsS0FBS21CLGlCQUFpQixLQUFLO1FBQzlDQyxtQkFBbUJwQixLQUFLb0IsaUJBQWlCLEtBQUs7UUFFOUNDLFVBQVVuQixPQUFPQyxRQUFRLENBQUNILEtBQUtxQixRQUFRLElBQUluQixPQUFPRixLQUFLcUIsUUFBUSxJQUFJO1FBRW5FQyxtQkFBbUJwQixPQUFPQyxRQUFRLENBQUNILEtBQUtzQixpQkFBaUIsSUFBSXBCLE9BQU9GLEtBQUtzQixpQkFBaUIsSUFBSTtRQUM5RkMsZUFBZXJCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3VCLGFBQWEsSUFBSXJCLE9BQU9GLEtBQUt1QixhQUFhLElBQUk7UUFFbEZDLHFCQUFxQnRCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3dCLG1CQUFtQixJQUFJdEIsT0FBT0YsS0FBS3dCLG1CQUFtQixJQUFJO1FBQ3BHQyxlQUFldkIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLeUIsYUFBYSxJQUFJdkIsT0FBT0YsS0FBS3lCLGFBQWEsSUFBSTtRQUVsRkMsVUFBVXhCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBSzBCLFFBQVEsSUFBSXhCLE9BQU9GLEtBQUswQixRQUFRLElBQUk7UUFDbkV0QjtRQUNBRTtRQUNBSztRQUNBRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2NvbmZpZy50c1xyXG5pbXBvcnQgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9ybWFsaXplZENvbmZpZyA9IFJlcXVpcmVkPE9taXQ8TW9iaWxlU21hcnRMYXlvdXRPcHRpb25zLCBcImVuYWJsZWRcIj4+ICYge1xyXG4gIGVuYWJsZWQ6IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKG9wdHM6IE1vYmlsZVNtYXJ0TGF5b3V0T3B0aW9ucyk6IE5vcm1hbGl6ZWRDb25maWcge1xuICBjb25zdCBmaXRNaW5TY2FsZVJhdyA9IE51bWJlci5pc0Zpbml0ZShvcHRzLmZpdE1pblNjYWxlKSA/IE51bWJlcihvcHRzLmZpdE1pblNjYWxlKSA6IDAuODg7XG4gIGNvbnN0IGZpdE1heFNjYWxlUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0TWF4U2NhbGUpID8gTnVtYmVyKG9wdHMuZml0TWF4U2NhbGUpIDogMS4xNjtcbiAgY29uc3QgZml0TWluU2NhbGUgPSBNYXRoLm1heCgwLjcsIE1hdGgubWluKDEsIGZpdE1pblNjYWxlUmF3KSk7XG4gIGNvbnN0IGZpdE1heFNjYWxlID0gTWF0aC5tYXgoMSwgZml0TWF4U2NhbGVSYXcpO1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0VGFyZ2V0V2lkdGhSYXRpbylcbiAgICA/IE51bWJlcihvcHRzLmZpdFRhcmdldFdpZHRoUmF0aW8pXG4gICAgOiAwLjk0O1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvID0gTWF0aC5tYXgoMC43NSwgTWF0aC5taW4oMC45OSwgZml0VGFyZ2V0V2lkdGhSYXRpb1JhdykpO1xuICBjb25zdCBmaXRNaW5GaWxsUmF0aW9SYXcgPSBOdW1iZXIuaXNGaW5pdGUob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgPyBOdW1iZXIob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgOiAwLjk7XG4gIGNvbnN0IGZpdE1pbkZpbGxSYXRpbyA9IE1hdGgubWF4KDAuNiwgTWF0aC5taW4oZml0VGFyZ2V0V2lkdGhSYXRpbywgZml0TWluRmlsbFJhdGlvUmF3KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiAhIW9wdHMuZW5hYmxlZCxcblxyXG4gICAgbWluR2FwUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pbkdhcFB4KSA/IE51bWJlcihvcHRzLm1pbkdhcFB4KSA6IDgsXHJcbiAgICBwYWRkaW5nVG9wUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnBhZGRpbmdUb3BQeCkgPyBOdW1iZXIob3B0cy5wYWRkaW5nVG9wUHgpIDogMCxcclxuICAgIHBhZGRpbmdCb3R0b21QeDogTnVtYmVyLmlzRmluaXRlKG9wdHMucGFkZGluZ0JvdHRvbVB4KSA/IE51bWJlcihvcHRzLnBhZGRpbmdCb3R0b21QeCkgOiAxMixcclxuICAgIG1heEdhcFB4OiBOdW1iZXIuaXNGaW5pdGUob3B0cy5tYXhHYXBQeCkgPyBOdW1iZXIob3B0cy5tYXhHYXBQeCkgOiAyMixcclxuXHJcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogb3B0cy5vbmx5Rml4ZWRTZWN0aW9ucyAhPT0gZmFsc2UsXHJcbiAgICBvbmx5V2hlblJlb3JkZXJlZDogb3B0cy5vbmx5V2hlblJlb3JkZXJlZCAhPT0gZmFsc2UsXHJcblxyXG4gICAgcm93VG9sUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnJvd1RvbFB4KSA/IE51bWJlcihvcHRzLnJvd1RvbFB4KSA6IDI4LFxyXG5cclxuICAgIHR3b0NvbFNwcmVhZFJhdGlvOiBOdW1iZXIuaXNGaW5pdGUob3B0cy50d29Db2xTcHJlYWRSYXRpbykgPyBOdW1iZXIob3B0cy50d29Db2xTcHJlYWRSYXRpbykgOiAwLjE4LFxyXG4gICAgbWluUGVyQ29sdW1uMjogTnVtYmVyLmlzRmluaXRlKG9wdHMubWluUGVyQ29sdW1uMikgPyBOdW1iZXIob3B0cy5taW5QZXJDb2x1bW4yKSA6IDIsXHJcblxuICAgIHRocmVlQ29sU3ByZWFkUmF0aW86IE51bWJlci5pc0Zpbml0ZShvcHRzLnRocmVlQ29sU3ByZWFkUmF0aW8pID8gTnVtYmVyKG9wdHMudGhyZWVDb2xTcHJlYWRSYXRpbykgOiAwLjIyLFxuICAgIG1pblBlckNvbHVtbjM6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pblBlckNvbHVtbjMpID8gTnVtYmVyKG9wdHMubWluUGVyQ29sdW1uMykgOiAyLFxuXG4gICAgZ2FwU2NhbGU6IE51bWJlci5pc0Zpbml0ZShvcHRzLmdhcFNjYWxlKSA/IE51bWJlcihvcHRzLmdhcFNjYWxlKSA6IDAuNixcbiAgICBmaXRNaW5TY2FsZSxcbiAgICBmaXRNYXhTY2FsZSxcbiAgICBmaXRUYXJnZXRXaWR0aFJhdGlvLFxuICAgIGZpdE1pbkZpbGxSYXRpbyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVDb25maWciLCJvcHRzIiwiZml0TWluU2NhbGVSYXciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGVSYXciLCJmaXRNYXhTY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmaXRUYXJnZXRXaWR0aFJhdGlvUmF3IiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpb1JhdyIsImZpdE1pbkZpbGxSYXRpbyIsImVuYWJsZWQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm1heEdhcFB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJnYXBTY2FsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts":
/*!******************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/dom.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsDomHelpersBlock: () => (/* binding */ jsDomHelpersBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/dom.ts\nfunction jsDomHelpersBlock() {\n    return `\n  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }\n\n  function isMobile(){\n    return (document.documentElement.clientWidth || 0) <= 767;\n  }\n\n  function getObjNodes(sec){\n    if(!sec) return [];\n    var nodes = [];\n    var content = sec.querySelector(\".sec-content\");\n    var bleed = sec.querySelector(\".sec-bleed\");\n\n    if (content) nodes = nodes.concat(Array.from(content.querySelectorAll(\".objeto\")));\n    if (bleed) nodes = nodes.concat(Array.from(bleed.querySelectorAll(\".objeto\")));\n\n    // Fallback: algunos elementos exportados pueden no traer clase \".objeto\"\n    // pero sí estar posicionados como objetos absolutos.\n    function collectAbsoluteCandidates(root){\n      if (!root) return [];\n      return Array.from(root.querySelectorAll(\"*\")).filter(function(el){\n        if (!el) return false;\n        var cs = getComputedStyle(el);\n        var pos = (cs.position || \"\").toLowerCase();\n        if (pos !== \"absolute\") return false;\n\n        var rr = el.getBoundingClientRect();\n        if (!rr || rr.width < 1 || rr.height < 1) return false;\n\n        // Evitar ruido estructural del layout de sección\n        if (el.classList && (\n          el.classList.contains(\"sec\") ||\n          el.classList.contains(\"sec-zoom\") ||\n          el.classList.contains(\"sec-bg\") ||\n          el.classList.contains(\"sec-content\") ||\n          el.classList.contains(\"sec-bleed\")\n        )) return false;\n\n        // Si ya está dentro de un \".objeto\", no lo contamos aparte.\n        var p = el.parentElement;\n        while (p){\n          if (p.classList && p.classList.contains(\"objeto\")) return false;\n          p = p.parentElement;\n        }\n        return true;\n      });\n    }\n\n    nodes = nodes.concat(collectAbsoluteCandidates(content));\n    nodes = nodes.concat(collectAbsoluteCandidates(bleed));\n\n    // Deduplicar preservando orden de aparición.\n    var seen = new Set();\n    return nodes.filter(function(n){\n      if (seen.has(n)) return false;\n      seen.add(n);\n      return true;\n    });\n  }\n\n  function relRect(el, root){\n    var r = el.getBoundingClientRect();\n    var rr = root.getBoundingClientRect();\n    return {\n      top: r.top - rr.top,\n      left: r.left - rr.left,\n      width: r.width,\n      height: r.height\n    };\n  }\n\n  function percentile(sortedArr, p){\n    if (!sortedArr.length) return 0;\n    var idx = Math.floor(sortedArr.length * p);\n    idx = Math.max(0, Math.min(sortedArr.length - 1, idx));\n    return sortedArr[idx];\n  }\n\n  function cx(it){ return it.left + (it.width || 0) / 2; }\n\n  // -------------------------\n  // ✅ CLUSTERS POR SOLAPE\n  // -------------------------\n  function rectsOverlap(a, b, tol){\n    tol = tol || 0;\n    return !(\n      (a.left + a.width) < (b.left + tol) ||\n      (b.left + b.width) < (a.left + tol) ||\n      (a.top + a.height) < (b.top + tol) ||\n      (b.top + b.height) < (a.top + tol)\n    );\n  }\n\n  function horizontalOverlapPx(a, b){\n    var l = Math.max(a.left, b.left);\n    var r = Math.min(a.left + a.width, b.left + b.width);\n    return Math.max(0, r - l);\n  }\n\n  function verticalGapPx(a, b){\n    var topAfter = Math.max(a.top, b.top);\n    var bottomBefore = Math.min(a.top + a.height, b.top + b.height);\n    return topAfter - bottomBefore;\n  }\n\n  function buildOverlapClusters(items){\n    var n = items.length;\n    var parent = new Array(n);\n    for (var i=0;i<n;i++) parent[i] = i;\n\n    function find(x){\n      while(parent[x] !== x){\n        parent[x] = parent[parent[x]];\n        x = parent[x];\n      }\n      return x;\n    }\n\n    function union(a,b){\n      var ra = find(a), rb = find(b);\n      if (ra !== rb) parent[rb] = ra;\n    }\n\n    // tol pequeño para considerar “encimado” aunque sea apenas\n    var TOL = 1;\n    // unión por cercanía vertical dentro de una misma \"columna visual\"\n    var PROX_Y = 34;\n    var MIN_H_OVERLAP_RATIO = 0.35;\n    var MAX_CX_DIST = 42;\n\n    for (var i=0;i<n;i++){\n      for (var j=i+1;j<n;j++){\n        var a = items[i], b = items[j];\n\n    var aIso = (a.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\n    var bIso = (b.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\n\n    // si cualquiera es isolated, no lo unimos con nadie\n    if (aIso || bIso) continue;\n\n    // opcional: cluster-id manual (si querés agrupar solo algunos)\n    var aKey = a.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\n    var bKey = b.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\n    if (aKey && bKey && aKey !== bKey) continue;\n\n    var aIsText = (a.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n    var bIsText = (b.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n    var involvesText = aIsText || bIsText;\n    var cxDist = Math.abs(cx(a) - cx(b));\n\n    if (rectsOverlap(a, b, TOL)) {\n      // Evita pegar columnas distintas por cajas de texto anchas.\n      // Si hay texto, exigimos cercania por eje X del centro.\n      if (!involvesText || cxDist <= MAX_CX_DIST) union(i,j);\n      continue;\n    }\n\n    // Si no se solapan pero están muy cerca en vertical y comparten columna,\n    // también los unimos para mantener bloque (ej: icono + texto debajo).\n    var hov = horizontalOverlapPx(a, b);\n    var minW = Math.max(1, Math.min(a.width || 0, b.width || 0));\n    var hovRatio = hov / minW;\n    // Con texto, usamos criterio más estricto para no cruzar columnas.\n    var sameVisualColumn = involvesText\n      ? (cxDist <= MAX_CX_DIST)\n      : ((hovRatio >= MIN_H_OVERLAP_RATIO) || (cxDist <= MAX_CX_DIST));\n    var vGap = verticalGapPx(a, b);\n    var nearVertical = vGap >= 0 && vGap <= PROX_Y;\n    var bothText = aIsText && bIsText;\n\n    // Evitar \"pegar\" párrafos entre sí solo por cercanía vertical.\n    // La unión por proximidad queda para pares mixtos (texto + no-texto),\n    // manteniendo el caso icono/forma + texto.\n    if (sameVisualColumn && nearVertical && !bothText) union(i,j);\n\n      }\n    }\n\n    var map = {};\n    for (var k=0;k<n;k++){\n      var r = find(k);\n      if (!map[r]) map[r] = [];\n      map[r].push(items[k]);\n    }\n\n    var clusters = [];\n    Object.keys(map).forEach(function(key){\n      var arr = map[key];\n\n      var minTop = Infinity, minLeft = Infinity, maxR = -Infinity, maxB = -Infinity;\n      for (var i=0;i<arr.length;i++){\n        var it = arr[i];\n        minTop = Math.min(minTop, it.top);\n        minLeft = Math.min(minLeft, it.left);\n        maxR = Math.max(maxR, it.left + it.width);\n        maxB = Math.max(maxB, it.top + it.height);\n      }\n\n      // offsets relativos para preservar el solape dentro del cluster\n      for (var i=0;i<arr.length;i++){\n        arr[i]._relTop = arr[i].top - minTop;\n        arr[i]._relLeft = arr[i].left - minLeft;\n      }\n\n      clusters.push({\n        items: arr,\n        top: minTop,\n        left: minLeft,\n        width: maxR - minLeft,\n        height: maxB - minTop,\n        cx: (minLeft + maxR) / 2\n      });\n    });\n\n    // orden estable por top para consistencia\n    clusters.sort(function(a,b){ return a.top - b.top; });\n\n    return clusters;\n  }\n\n  // ✅ “entra” si ningún cluster se sale horizontalmente del contenedor content\n  function clustersFitInMobile(clusters, rootEl){\n    var rootW = rootEl.getBoundingClientRect().width || 0;\n    if (!rootW) return true;\n\n    for (var i=0;i<clusters.length;i++){\n      var c = clusters[i];\n      if (c.left < -1) return false;\n      if ((c.left + c.width) > (rootW + 1)) return false;\n    }\n    return true;\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwrQ0FBK0M7QUFDeEMsU0FBU0E7SUFDZCxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3T1YsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGRvbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2RvbS50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNEb21IZWxwZXJzQmxvY2soKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFxyXG4gIGZ1bmN0aW9uIGNsYW1wKG4sYSxiKXsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsbikpOyB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzTW9iaWxlKCl7XHJcbiAgICByZXR1cm4gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwKSA8PSA3Njc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRPYmpOb2RlcyhzZWMpe1xuICAgIGlmKCFzZWMpIHJldHVybiBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgY29udGVudCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1jb250ZW50XCIpO1xuICAgIHZhciBibGVlZCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1ibGVlZFwiKTtcblxuICAgIGlmIChjb250ZW50KSBub2RlcyA9IG5vZGVzLmNvbmNhdChBcnJheS5mcm9tKGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikpKTtcbiAgICBpZiAoYmxlZWQpIG5vZGVzID0gbm9kZXMuY29uY2F0KEFycmF5LmZyb20oYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikpKTtcblxuICAgIC8vIEZhbGxiYWNrOiBhbGd1bm9zIGVsZW1lbnRvcyBleHBvcnRhZG9zIHB1ZWRlbiBubyB0cmFlciBjbGFzZSBcIi5vYmpldG9cIlxuICAgIC8vIHBlcm8gc8OtIGVzdGFyIHBvc2ljaW9uYWRvcyBjb21vIG9iamV0b3MgYWJzb2x1dG9zLlxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMocm9vdCl7XG4gICAgICBpZiAoIXJvb3QpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3QucXVlcnlTZWxlY3RvckFsbChcIipcIikpLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIGlmICghZWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIHZhciBwb3MgPSAoY3MucG9zaXRpb24gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHBvcyAhPT0gXCJhYnNvbHV0ZVwiKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJyID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghcnIgfHwgcnIud2lkdGggPCAxIHx8IHJyLmhlaWdodCA8IDEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBFdml0YXIgcnVpZG8gZXN0cnVjdHVyYWwgZGVsIGxheW91dCBkZSBzZWNjacOzblxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0ICYmIChcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWNcIikgfHxcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWMtem9vbVwiKSB8fFxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1iZ1wiKSB8fFxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1jb250ZW50XCIpIHx8XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VjLWJsZWVkXCIpXG4gICAgICAgICkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBTaSB5YSBlc3TDoSBkZW50cm8gZGUgdW4gXCIub2JqZXRvXCIsIG5vIGxvIGNvbnRhbW9zIGFwYXJ0ZS5cbiAgICAgICAgdmFyIHAgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB3aGlsZSAocCl7XG4gICAgICAgICAgaWYgKHAuY2xhc3NMaXN0ICYmIHAuY2xhc3NMaXN0LmNvbnRhaW5zKFwib2JqZXRvXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcCA9IHAucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMoY29udGVudCkpO1xuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMoYmxlZWQpKTtcblxuICAgIC8vIERlZHVwbGljYXIgcHJlc2VydmFuZG8gb3JkZW4gZGUgYXBhcmljacOzbi5cbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG4pe1xuICAgICAgaWYgKHNlZW4uaGFzKG4pKSByZXR1cm4gZmFsc2U7XG4gICAgICBzZWVuLmFkZChuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cclxuICBmdW5jdGlvbiByZWxSZWN0KGVsLCByb290KXtcclxuICAgIHZhciByID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgcnIgPSByb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiByLnRvcCAtIHJyLnRvcCxcclxuICAgICAgbGVmdDogci5sZWZ0IC0gcnIubGVmdCxcclxuICAgICAgd2lkdGg6IHIud2lkdGgsXHJcbiAgICAgIGhlaWdodDogci5oZWlnaHRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZXJjZW50aWxlKHNvcnRlZEFyciwgcCl7XHJcbiAgICBpZiAoIXNvcnRlZEFyci5sZW5ndGgpIHJldHVybiAwO1xyXG4gICAgdmFyIGlkeCA9IE1hdGguZmxvb3Ioc29ydGVkQXJyLmxlbmd0aCAqIHApO1xyXG4gICAgaWR4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc29ydGVkQXJyLmxlbmd0aCAtIDEsIGlkeCkpO1xyXG4gICAgcmV0dXJuIHNvcnRlZEFycltpZHhdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3goaXQpeyByZXR1cm4gaXQubGVmdCArIChpdC53aWR0aCB8fCAwKSAvIDI7IH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIOKchSBDTFVTVEVSUyBQT1IgU09MQVBFXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIGZ1bmN0aW9uIHJlY3RzT3ZlcmxhcChhLCBiLCB0b2wpe1xuICAgIHRvbCA9IHRvbCB8fCAwO1xuICAgIHJldHVybiAhKFxuICAgICAgKGEubGVmdCArIGEud2lkdGgpIDwgKGIubGVmdCArIHRvbCkgfHxcbiAgICAgIChiLmxlZnQgKyBiLndpZHRoKSA8IChhLmxlZnQgKyB0b2wpIHx8XHJcbiAgICAgIChhLnRvcCArIGEuaGVpZ2h0KSA8IChiLnRvcCArIHRvbCkgfHxcclxuICAgICAgKGIudG9wICsgYi5oZWlnaHQpIDwgKGEudG9wICsgdG9sKVxyXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhvcml6b250YWxPdmVybGFwUHgoYSwgYil7XG4gICAgdmFyIGwgPSBNYXRoLm1heChhLmxlZnQsIGIubGVmdCk7XG4gICAgdmFyIHIgPSBNYXRoLm1pbihhLmxlZnQgKyBhLndpZHRoLCBiLmxlZnQgKyBiLndpZHRoKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgciAtIGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmVydGljYWxHYXBQeChhLCBiKXtcbiAgICB2YXIgdG9wQWZ0ZXIgPSBNYXRoLm1heChhLnRvcCwgYi50b3ApO1xuICAgIHZhciBib3R0b21CZWZvcmUgPSBNYXRoLm1pbihhLnRvcCArIGEuaGVpZ2h0LCBiLnRvcCArIGIuaGVpZ2h0KTtcbiAgICByZXR1cm4gdG9wQWZ0ZXIgLSBib3R0b21CZWZvcmU7XG4gIH1cblxyXG4gIGZ1bmN0aW9uIGJ1aWxkT3ZlcmxhcENsdXN0ZXJzKGl0ZW1zKXtcclxuICAgIHZhciBuID0gaXRlbXMubGVuZ3RoO1xyXG4gICAgdmFyIHBhcmVudCA9IG5ldyBBcnJheShuKTtcclxuICAgIGZvciAodmFyIGk9MDtpPG47aSsrKSBwYXJlbnRbaV0gPSBpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmQoeCl7XHJcbiAgICAgIHdoaWxlKHBhcmVudFt4XSAhPT0geCl7XHJcbiAgICAgICAgcGFyZW50W3hdID0gcGFyZW50W3BhcmVudFt4XV07XHJcbiAgICAgICAgeCA9IHBhcmVudFt4XTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bmlvbihhLGIpe1xyXG4gICAgICB2YXIgcmEgPSBmaW5kKGEpLCByYiA9IGZpbmQoYik7XHJcbiAgICAgIGlmIChyYSAhPT0gcmIpIHBhcmVudFtyYl0gPSByYTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0b2wgcGVxdWXDsW8gcGFyYSBjb25zaWRlcmFyIOKAnGVuY2ltYWRv4oCdIGF1bnF1ZSBzZWEgYXBlbmFzXG4gICAgdmFyIFRPTCA9IDE7XG4gICAgLy8gdW5pw7NuIHBvciBjZXJjYW7DrWEgdmVydGljYWwgZGVudHJvIGRlIHVuYSBtaXNtYSBcImNvbHVtbmEgdmlzdWFsXCJcbiAgICB2YXIgUFJPWF9ZID0gMzQ7XG4gICAgdmFyIE1JTl9IX09WRVJMQVBfUkFUSU8gPSAwLjM1O1xuICAgIHZhciBNQVhfQ1hfRElTVCA9IDQyO1xuXHJcbiAgICBmb3IgKHZhciBpPTA7aTxuO2krKyl7XG4gICAgICBmb3IgKHZhciBqPWkrMTtqPG47aisrKXtcbiAgICAgICAgdmFyIGEgPSBpdGVtc1tpXSwgYiA9IGl0ZW1zW2pdO1xuXG4gICAgdmFyIGFJc28gPSAoYS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXJcIikgfHwgXCJcIikgPT09IFwiaXNvbGF0ZWRcIjtcbiAgICB2YXIgYklzbyA9IChiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiKSA9PT0gXCJpc29sYXRlZFwiO1xuXHJcbiAgICAvLyBzaSBjdWFscXVpZXJhIGVzIGlzb2xhdGVkLCBubyBsbyB1bmltb3MgY29uIG5hZGllXHJcbiAgICBpZiAoYUlzbyB8fCBiSXNvKSBjb250aW51ZTtcclxuXHJcbiAgICAvLyBvcGNpb25hbDogY2x1c3Rlci1pZCBtYW51YWwgKHNpIHF1ZXLDqXMgYWdydXBhciBzb2xvIGFsZ3Vub3MpXHJcbiAgICB2YXIgYUtleSA9IGEubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyLWlkXCIpIHx8IFwiXCI7XG4gICAgdmFyIGJLZXkgPSBiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3Rlci1pZFwiKSB8fCBcIlwiO1xuICAgIGlmIChhS2V5ICYmIGJLZXkgJiYgYUtleSAhPT0gYktleSkgY29udGludWU7XG5cbiAgICB2YXIgYUlzVGV4dCA9IChhLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgdmFyIGJJc1RleHQgPSAoYi5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xuICAgIHZhciBpbnZvbHZlc1RleHQgPSBhSXNUZXh0IHx8IGJJc1RleHQ7XG4gICAgdmFyIGN4RGlzdCA9IE1hdGguYWJzKGN4KGEpIC0gY3goYikpO1xuXG4gICAgaWYgKHJlY3RzT3ZlcmxhcChhLCBiLCBUT0wpKSB7XG4gICAgICAvLyBFdml0YSBwZWdhciBjb2x1bW5hcyBkaXN0aW50YXMgcG9yIGNhamFzIGRlIHRleHRvIGFuY2hhcy5cbiAgICAgIC8vIFNpIGhheSB0ZXh0bywgZXhpZ2ltb3MgY2VyY2FuaWEgcG9yIGVqZSBYIGRlbCBjZW50cm8uXG4gICAgICBpZiAoIWludm9sdmVzVGV4dCB8fCBjeERpc3QgPD0gTUFYX0NYX0RJU1QpIHVuaW9uKGksaik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBTaSBubyBzZSBzb2xhcGFuIHBlcm8gZXN0w6FuIG11eSBjZXJjYSBlbiB2ZXJ0aWNhbCB5IGNvbXBhcnRlbiBjb2x1bW5hLFxuICAgIC8vIHRhbWJpw6luIGxvcyB1bmltb3MgcGFyYSBtYW50ZW5lciBibG9xdWUgKGVqOiBpY29ubyArIHRleHRvIGRlYmFqbykuXG4gICAgdmFyIGhvdiA9IGhvcml6b250YWxPdmVybGFwUHgoYSwgYik7XG4gICAgdmFyIG1pblcgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihhLndpZHRoIHx8IDAsIGIud2lkdGggfHwgMCkpO1xuICAgIHZhciBob3ZSYXRpbyA9IGhvdiAvIG1pblc7XG4gICAgLy8gQ29uIHRleHRvLCB1c2Ftb3MgY3JpdGVyaW8gbcOhcyBlc3RyaWN0byBwYXJhIG5vIGNydXphciBjb2x1bW5hcy5cbiAgICB2YXIgc2FtZVZpc3VhbENvbHVtbiA9IGludm9sdmVzVGV4dFxuICAgICAgPyAoY3hEaXN0IDw9IE1BWF9DWF9ESVNUKVxuICAgICAgOiAoKGhvdlJhdGlvID49IE1JTl9IX09WRVJMQVBfUkFUSU8pIHx8IChjeERpc3QgPD0gTUFYX0NYX0RJU1QpKTtcbiAgICB2YXIgdkdhcCA9IHZlcnRpY2FsR2FwUHgoYSwgYik7XG4gICAgdmFyIG5lYXJWZXJ0aWNhbCA9IHZHYXAgPj0gMCAmJiB2R2FwIDw9IFBST1hfWTtcbiAgICB2YXIgYm90aFRleHQgPSBhSXNUZXh0ICYmIGJJc1RleHQ7XG5cbiAgICAvLyBFdml0YXIgXCJwZWdhclwiIHDDoXJyYWZvcyBlbnRyZSBzw60gc29sbyBwb3IgY2VyY2Fuw61hIHZlcnRpY2FsLlxuICAgIC8vIExhIHVuacOzbiBwb3IgcHJveGltaWRhZCBxdWVkYSBwYXJhIHBhcmVzIG1peHRvcyAodGV4dG8gKyBuby10ZXh0byksXG4gICAgLy8gbWFudGVuaWVuZG8gZWwgY2FzbyBpY29uby9mb3JtYSArIHRleHRvLlxuICAgIGlmIChzYW1lVmlzdWFsQ29sdW1uICYmIG5lYXJWZXJ0aWNhbCAmJiAhYm90aFRleHQpIHVuaW9uKGksaik7XG5cbiAgICAgIH1cbiAgICB9XG5cclxuICAgIHZhciBtYXAgPSB7fTtcclxuICAgIGZvciAodmFyIGs9MDtrPG47aysrKXtcclxuICAgICAgdmFyIHIgPSBmaW5kKGspO1xyXG4gICAgICBpZiAoIW1hcFtyXSkgbWFwW3JdID0gW107XHJcbiAgICAgIG1hcFtyXS5wdXNoKGl0ZW1zW2tdKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcclxuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xyXG4gICAgICB2YXIgYXJyID0gbWFwW2tleV07XHJcblxyXG4gICAgICB2YXIgbWluVG9wID0gSW5maW5pdHksIG1pbkxlZnQgPSBJbmZpbml0eSwgbWF4UiA9IC1JbmZpbml0eSwgbWF4QiA9IC1JbmZpbml0eTtcclxuICAgICAgZm9yICh2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIHZhciBpdCA9IGFycltpXTtcclxuICAgICAgICBtaW5Ub3AgPSBNYXRoLm1pbihtaW5Ub3AsIGl0LnRvcCk7XHJcbiAgICAgICAgbWluTGVmdCA9IE1hdGgubWluKG1pbkxlZnQsIGl0LmxlZnQpO1xyXG4gICAgICAgIG1heFIgPSBNYXRoLm1heChtYXhSLCBpdC5sZWZ0ICsgaXQud2lkdGgpO1xyXG4gICAgICAgIG1heEIgPSBNYXRoLm1heChtYXhCLCBpdC50b3AgKyBpdC5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBvZmZzZXRzIHJlbGF0aXZvcyBwYXJhIHByZXNlcnZhciBlbCBzb2xhcGUgZGVudHJvIGRlbCBjbHVzdGVyXHJcbiAgICAgIGZvciAodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICBhcnJbaV0uX3JlbFRvcCA9IGFycltpXS50b3AgLSBtaW5Ub3A7XHJcbiAgICAgICAgYXJyW2ldLl9yZWxMZWZ0ID0gYXJyW2ldLmxlZnQgLSBtaW5MZWZ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjbHVzdGVycy5wdXNoKHtcclxuICAgICAgICBpdGVtczogYXJyLFxyXG4gICAgICAgIHRvcDogbWluVG9wLFxyXG4gICAgICAgIGxlZnQ6IG1pbkxlZnQsXHJcbiAgICAgICAgd2lkdGg6IG1heFIgLSBtaW5MZWZ0LFxyXG4gICAgICAgIGhlaWdodDogbWF4QiAtIG1pblRvcCxcclxuICAgICAgICBjeDogKG1pbkxlZnQgKyBtYXhSKSAvIDJcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBvcmRlbiBlc3RhYmxlIHBvciB0b3AgcGFyYSBjb25zaXN0ZW5jaWFcclxuICAgIGNsdXN0ZXJzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xyXG5cclxuICAgIHJldHVybiBjbHVzdGVycztcclxuICB9XHJcblxyXG4gIC8vIOKchSDigJxlbnRyYeKAnSBzaSBuaW5nw7puIGNsdXN0ZXIgc2Ugc2FsZSBob3Jpem9udGFsbWVudGUgZGVsIGNvbnRlbmVkb3IgY29udGVudFxyXG4gIGZ1bmN0aW9uIGNsdXN0ZXJzRml0SW5Nb2JpbGUoY2x1c3RlcnMsIHJvb3RFbCl7XHJcbiAgICB2YXIgcm9vdFcgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgMDtcclxuICAgIGlmICghcm9vdFcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGZvciAodmFyIGk9MDtpPGNsdXN0ZXJzLmxlbmd0aDtpKyspe1xyXG4gICAgICB2YXIgYyA9IGNsdXN0ZXJzW2ldO1xyXG4gICAgICBpZiAoYy5sZWZ0IDwgLTEpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKChjLmxlZnQgKyBjLndpZHRoKSA+IChyb290VyArIDEpKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc0RvbUhlbHBlcnNCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/fitScale.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsFitScaleBlock: () => (/* binding */ jsFitScaleBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/fitScale.ts\nfunction jsFitScaleBlock() {\n    return `\n  function ensureFitScaleBaseline(el){\n    if (!el) return;\n    if (!el.hasAttribute(\"data-msl-fit-orig-transform\")) {\n      el.setAttribute(\"data-msl-fit-orig-transform\", el.style.transform || \"\");\n    }\n    if (!el.hasAttribute(\"data-msl-fit-orig-origin\")) {\n      el.setAttribute(\"data-msl-fit-orig-origin\", el.style.transformOrigin || \"\");\n    }\n  }\n\n  function restoreFitScaleBaseline(el){\n    if (!el) return;\n    ensureFitScaleBaseline(el);\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\n    var baseOrigin = el.getAttribute(\"data-msl-fit-orig-origin\") || \"\";\n    el.style.transform = baseTransform;\n    if (baseOrigin) el.style.transformOrigin = baseOrigin;\n    else el.style.removeProperty(\"transform-origin\");\n  }\n\n  function applyElementFitScale(el, scale){\n    if (!el) return;\n    ensureFitScaleBaseline(el);\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\n    var next = baseTransform ? (baseTransform + \" scale(\" + scale + \")\") : (\"scale(\" + scale + \")\");\n    el.style.transform = next;\n    el.style.transformOrigin = \"top center\";\n  }\n\n  function resetSectionFitScale(_sec, content, bleed){\n    restoreFitScaleBaseline(content);\n    restoreFitScaleBaseline(bleed);\n  }\n\n  function computeSectionBounds(sec, nodes){\n    if (!sec || !nodes || !nodes.length) return null;\n    var minLeft = Infinity;\n    var minTop = Infinity;\n    var maxRight = -Infinity;\n    var maxBottom = -Infinity;\n    var valid = 0;\n\n    for (var i=0; i<nodes.length; i++){\n      var node = nodes[i];\n      if (!node) continue;\n      var rr = relRect(node, sec);\n      var w = Number(rr.width || 0);\n      var h = Number(rr.height || 0);\n      if (w <= 0.5 && h <= 0.5) continue;\n\n      var l = Number(rr.left || 0);\n      var t = Number(rr.top || 0);\n      var r = l + Math.max(0, w);\n      var b = t + Math.max(0, h);\n\n      if (!isFinite(l) || !isFinite(t) || !isFinite(r) || !isFinite(b)) continue;\n\n      minLeft = Math.min(minLeft, l);\n      minTop = Math.min(minTop, t);\n      maxRight = Math.max(maxRight, r);\n      maxBottom = Math.max(maxBottom, b);\n      valid++;\n    }\n\n    if (!valid || !isFinite(minLeft) || !isFinite(maxRight) || !isFinite(minTop) || !isFinite(maxBottom)) {\n      return null;\n    }\n\n    return {\n      minLeft: minLeft,\n      minTop: minTop,\n      maxRight: maxRight,\n      maxBottom: maxBottom,\n      width: Math.max(0, maxRight - minLeft),\n      height: Math.max(0, maxBottom - minTop),\n      count: valid\n    };\n  }\n\n  function computeFitScale(sec, bounds, secModo, CFG){\n    if (!sec || !bounds) return 1;\n    var secRect = sec.getBoundingClientRect();\n    var secW = Number(secRect.width || 0);\n    var secH = Number(secRect.height || 0);\n    if (secW <= 1) {\n      return {\n        scale: 1,\n        debug: null\n      };\n    }\n\n    var targetCoverage = clamp(Number(CFG.FIT_TARGET_WIDTH_RATIO || 0.94), 0.75, 0.99);\n    var minFillForUpscale = clamp(Number(CFG.FIT_MIN_FILL_RATIO || 0.9), 0.6, targetCoverage);\n    var minScale = clamp(Number(CFG.FIT_MIN_SCALE || 0.88), 0.7, 1);\n    var maxScale = Math.max(1, Number(CFG.FIT_MAX_SCALE || 1.16));\n\n    var contentW = Math.max(1, Number(bounds.width || 0));\n    var coverage = contentW / secW;\n\n    var scale = 1;\n    var debug = {\n      secW: secW,\n      secH: secH,\n      targetCoverage: targetCoverage,\n      minFillForUpscale: minFillForUpscale,\n      minScale: minScale,\n      maxScale: maxScale,\n      coverage: coverage,\n      initialScale: 1,\n      maxScaleByWidth: null,\n      maxScaleByHeight: null,\n      scaleAfterWidthClamp: null,\n      scaleAfterHeightClamp: null,\n      tinyShrinkProtected: false,\n      pantallaDownscaleBlocked: false\n    };\n    if (coverage < minFillForUpscale) {\n      scale = targetCoverage / Math.max(0.01, coverage);\n    }\n    debug.initialScale = scale;\n\n    if (scale >= 1) scale = Math.min(scale, maxScale);\n    else scale = Math.max(scale, minScale);\n\n    // Límite horizontal duro por centro visual.\n    var centerX = secW / 2;\n    var distLeft = Math.max(0, centerX - Number(bounds.minLeft || 0));\n    var distRight = Math.max(0, Number(bounds.maxRight || 0) - centerX);\n    var maxScaleByWidth = Infinity;\n    if (distLeft > 0.5) {\n      maxScaleByWidth = Math.min(maxScaleByWidth, centerX / distLeft);\n    }\n    if (distRight > 0.5) {\n      maxScaleByWidth = Math.min(maxScaleByWidth, (secW - centerX) / distRight);\n    }\n    if (isFinite(maxScaleByWidth) && maxScaleByWidth > 0) {\n      scale = Math.min(scale, maxScaleByWidth);\n      debug.maxScaleByWidth = maxScaleByWidth;\n    }\n    debug.scaleAfterWidthClamp = scale;\n\n    if (secModo === \"pantalla\" && scale < 1 && scale > 0.94) {\n      // Avoid shrinking \"pantalla\" for tiny overflows; preserve visual impact.\n      scale = 1;\n      debug.tinyShrinkProtected = true;\n    }\n\n    // En modo pantalla no dejamos que el contenido se recorte por altura.\n    if (secModo === \"pantalla\" && secH > 1) {\n      var maxBottom = Number(bounds.maxBottom || 0);\n      if (maxBottom > 1) {\n        var maxScaleByHeight = secH / maxBottom;\n        if (isFinite(maxScaleByHeight) && maxScaleByHeight > 0) {\n          scale = Math.min(scale, maxScaleByHeight);\n          debug.maxScaleByHeight = maxScaleByHeight;\n        }\n      }\n    }\n    debug.scaleAfterHeightClamp = scale;\n\n    if (secModo === \"pantalla\" && scale < 1) {\n      // Pantalla sections already have their own viewport-fit logic.\n      // Avoid additional downscale here to keep hero text readable.\n      scale = 1;\n      debug.pantallaDownscaleBlocked = true;\n    }\n\n    if (!isFinite(scale) || scale <= 0) scale = 1;\n    if (Math.abs(scale - 1) < 0.02) scale = 1;\n    return {\n      scale: scale,\n      debug: debug\n    };\n  }\n\n  function applySectionFitScale(sec, content, bleed, nodesAll, secModo, CFG, meta, opts){\n    if (!sec || !content) {\n      return { scale: 1, neededHeight: 0, bounds: null };\n    }\n\n    ensureFitScaleBaseline(content);\n    ensureFitScaleBaseline(bleed);\n    var preserveBottomGap = 0;\n    if (opts && Number.isFinite(opts.preserveBottomGap)) {\n      preserveBottomGap = Math.max(0, Number(opts.preserveBottomGap));\n    }\n\n    var fitNodes = (nodesAll || []).filter(function(node){\n      if (!node) return false;\n      var fitMode = (node.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\n      if (fitMode === \"ignore\") return false;\n      if (node.closest && node.closest(\".sec-bleed\")) return false;\n      return true;\n    });\n\n    var bounds = computeSectionBounds(sec, fitNodes);\n    if (!bounds) {\n      bounds = computeSectionBounds(sec, nodesAll || []);\n    }\n    if (!bounds) {\n      restoreFitScaleBaseline(content);\n      restoreFitScaleBaseline(bleed);\n      sec.setAttribute(\"data-msl-fit-scale\", \"1\");\n      return { scale: 1, neededHeight: 0, bounds: null };\n    }\n\n    var fitResult = computeFitScale(sec, bounds, secModo, CFG);\n    var scale = (fitResult && Number.isFinite(fitResult.scale)) ? fitResult.scale : 1;\n    var fitDebug = fitResult && fitResult.debug ? fitResult.debug : null;\n    applyElementFitScale(content, scale);\n    applyElementFitScale(bleed, scale);\n\n    var neededHeight = 0;\n    if (secModo !== \"pantalla\") {\n      var maxBottomWithGap = Number(bounds.maxBottom || 0) + preserveBottomGap;\n      neededHeight = Math.ceil(maxBottomWithGap * scale + (CFG.PAD_BOT || 0));\n    }\n\n    if (secModo === \"pantalla\") {\n      var secRectNow = sec.getBoundingClientRect();\n      var vv = window.visualViewport;\n      var viewportW = (vv && vv.width) ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 0);\n      var viewportH = (vv && vv.height) ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 0);\n      var ua = navigator.userAgent || \"\";\n      var mobileUA = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);\n      var touchPoints = Number(navigator.maxTouchPoints || 0);\n      var coarsePointer = false;\n      if (window.matchMedia) {\n        try { coarsePointer = window.matchMedia(\"(pointer: coarse)\").matches; } catch(_e) {}\n      }\n      var mobileViewport = viewportW <= 767;\n      var desktopMobilePreview = mobileViewport && !mobileUA;\n\n      var boundsAll = computeSectionBounds(sec, nodesAll || []);\n      var totalNodes = (nodesAll || []).length;\n      var fitNodesCount = fitNodes.length;\n      var textAll = 0;\n      var textFit = 0;\n      var ignoredBleed = 0;\n      var ignoredExplicit = 0;\n      var dominantText = null;\n      var dominantTextH = -1;\n      var elementRows = [];\n\n      for (var ni=0; ni<totalNodes; ni++){\n        var nodeAll = nodesAll[ni];\n        if (!nodeAll) continue;\n\n        var fitModeAll = (nodeAll.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\n        if (fitModeAll === \"ignore\") ignoredExplicit++;\n        if (nodeAll.closest && nodeAll.closest(\".sec-bleed\")) ignoredBleed++;\n\n        var rrNode = relRect(nodeAll, sec);\n        var nodeW = Number(rrNode.width || 0);\n        var nodeH = Number(rrNode.height || 0);\n        var nodeTop = Number(rrNode.top || 0);\n        var nodeBottom = nodeTop + nodeH;\n        var isTextAll = (nodeAll.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n        if (isTextAll) textAll++;\n\n        if (nodeW > 0.5 || nodeH > 0.5) {\n          var kindAll = isTextAll ? \"texto\" : String((nodeAll.tagName || \"\").toLowerCase());\n          elementRows.push({\n            kind: kindAll,\n            width: nodeW,\n            height: nodeH,\n            top: nodeTop,\n            bottom: nodeBottom,\n            area: nodeW * nodeH,\n            textSample: isTextAll\n              ? ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 70)\n              : \"\"\n          });\n        }\n\n        if (!isTextAll) continue;\n        if (nodeH <= dominantTextH) continue;\n        dominantTextH = nodeH;\n        var csTxt = getComputedStyle(nodeAll);\n        dominantText = {\n          top: +nodeTop.toFixed(1),\n          left: +Number(rrNode.left || 0).toFixed(1),\n          width: +nodeW.toFixed(1),\n          height: +nodeH.toFixed(1),\n          bottom: +nodeBottom.toFixed(1),\n          widthSecRatio: secRectNow.width > 1 ? +(nodeW / secRectNow.width).toFixed(3) : null,\n          heightSecRatio: secRectNow.height > 1 ? +(nodeH / secRectNow.height).toFixed(3) : null,\n          widthViewportRatio: viewportW > 1 ? +(nodeW / viewportW).toFixed(3) : null,\n          heightViewportRatio: viewportH > 1 ? +(nodeH / viewportH).toFixed(3) : null,\n          fontSize: csTxt.fontSize || \"\",\n          lineHeight: csTxt.lineHeight || \"\",\n          textAlign: csTxt.textAlign || \"\",\n          transform: (nodeAll.style && nodeAll.style.transform) ? nodeAll.style.transform : \"\",\n          textSample: ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 90)\n        };\n      }\n\n      for (var fi=0; fi<fitNodes.length; fi++){\n        var fitNode = fitNodes[fi];\n        if ((fitNode.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textFit++;\n      }\n\n      var topElements = elementRows\n        .sort(function(a,b){ return (b.area || 0) - (a.area || 0); })\n        .slice(0, 6)\n        .map(function(row){\n          return {\n            kind: row.kind,\n            width: +Number(row.width || 0).toFixed(1),\n            height: +Number(row.height || 0).toFixed(1),\n            widthSecRatio: secRectNow.width > 1 ? +((row.width || 0) / secRectNow.width).toFixed(3) : null,\n            heightSecRatio: secRectNow.height > 1 ? +((row.height || 0) / secRectNow.height).toFixed(3) : null,\n            widthViewportRatio: viewportW > 1 ? +((row.width || 0) / viewportW).toFixed(3) : null,\n            heightViewportRatio: viewportH > 1 ? +((row.height || 0) / viewportH).toFixed(3) : null,\n            topSecRatio: secRectNow.height > 1 ? +((row.top || 0) / secRectNow.height).toFixed(3) : null,\n            bottomSecRatio: secRectNow.height > 1 ? +((row.bottom || 0) / secRectNow.height).toFixed(3) : null,\n            sample: row.textSample || \"\"\n          };\n        });\n\n      var coverageFit = bounds.width / Math.max(1, secRectNow.width || 0);\n      var coverageAll = boundsAll ? (boundsAll.width / Math.max(1, secRectNow.width || 0)) : null;\n\n      var flatLines = [];\n      flatLines.push(\n        \"sec=\" + String(meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1)\n        + \" viewport=\" + (+Number(viewportW || 0).toFixed(1)) + \"x\" + (+Number(viewportH || 0).toFixed(1))\n        + \" sec=\" + (+Number(secRectNow.width || 0).toFixed(1)) + \"x\" + (+Number(secRectNow.height || 0).toFixed(1))\n        + \" mobileViewport=\" + String(mobileViewport)\n        + \" desktopMobilePreview=\" + String(desktopMobilePreview)\n        + \" mobileUA=\" + String(mobileUA)\n        + \" coarsePointer=\" + String(coarsePointer)\n        + \" touchPoints=\" + String(touchPoints)\n      );\n      flatLines.push(\n        \"fit scale=\" + (+Number(scale || 1).toFixed(3))\n        + \" coverageFit=\" + (+coverageFit.toFixed(3))\n        + \" coverageAll=\" + (coverageAll == null ? \"null\" : String(+coverageAll.toFixed(3)))\n        + \" nodes=\" + String(fitNodesCount) + \"/\" + String(totalNodes)\n        + \" ignoredBleed=\" + String(ignoredBleed)\n        + \" ignoredExplicit=\" + String(ignoredExplicit)\n        + \" tinyShrinkProtected=\" + String(!!(fitDebug && fitDebug.tinyShrinkProtected))\n        + \" pantallaDownscaleBlocked=\" + String(!!(fitDebug && fitDebug.pantallaDownscaleBlocked))\n      );\n      if (dominantText) {\n        flatLines.push(\n          \"dominantText hSecRatio=\" + String(dominantText.heightSecRatio)\n          + \" hViewportRatio=\" + String(dominantText.heightViewportRatio)\n          + \" wSecRatio=\" + String(dominantText.widthSecRatio)\n          + \" fontSize=\" + String(dominantText.fontSize || \"\")\n          + \" lineHeight=\" + String(dominantText.lineHeight || \"\")\n          + \" sample='\" + String(dominantText.textSample || \"\") + \"'\"\n        );\n      } else {\n        flatLines.push(\"dominantText none\");\n      }\n      for (var te=0; te<topElements.length; te++){\n        var e = topElements[te];\n        flatLines.push(\n          \"el#\" + String(te + 1)\n          + \" kind=\" + String(e.kind || \"\")\n          + \" wVp=\" + String(e.widthViewportRatio)\n          + \" hVp=\" + String(e.heightViewportRatio)\n          + \" topSec=\" + String(e.topSecRatio)\n          + \" bottomSec=\" + String(e.bottomSecRatio)\n          + (e.sample ? (\" sample='\" + String(e.sample) + \"'\") : \"\")\n        );\n      }\n      mslLog(\"section:fitScale:pantalla:flat\", flatLines.join(\"\\\\n\"));\n\n      mslLog(\"section:fitScale:pantalla\", {\n        secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\n        secW: +Number(secRectNow.width || 0).toFixed(1),\n        secH: +Number(secRectNow.height || 0).toFixed(1),\n        viewport: {\n          width: +Number(viewportW || 0).toFixed(1),\n          height: +Number(viewportH || 0).toFixed(1)\n        },\n        displayContext: {\n          mobileViewport: mobileViewport,\n          desktopMobilePreview: desktopMobilePreview,\n          mobileUA: mobileUA,\n          coarsePointer: coarsePointer,\n          touchPoints: touchPoints\n        },\n        preserveBottomGap: +preserveBottomGap.toFixed(1),\n        totalNodes: totalNodes,\n        fitNodes: fitNodesCount,\n        textNodesAll: textAll,\n        textNodesFit: textFit,\n        ignoredBleed: ignoredBleed,\n        ignoredExplicit: ignoredExplicit,\n        coverageFit: +coverageFit.toFixed(3),\n        coverageAll: coverageAll == null ? null : +coverageAll.toFixed(3),\n        fitBounds: {\n          width: +Number(bounds.width || 0).toFixed(1),\n          height: +Number(bounds.height || 0).toFixed(1),\n          maxBottom: +Number(bounds.maxBottom || 0).toFixed(1)\n        },\n        allBounds: boundsAll ? {\n          width: +Number(boundsAll.width || 0).toFixed(1),\n          height: +Number(boundsAll.height || 0).toFixed(1),\n          maxBottom: +Number(boundsAll.maxBottom || 0).toFixed(1)\n        } : null,\n        fitDebug: fitDebug ? {\n          targetCoverage: +Number(fitDebug.targetCoverage || 0).toFixed(3),\n          minFillForUpscale: +Number(fitDebug.minFillForUpscale || 0).toFixed(3),\n          coverage: +Number(fitDebug.coverage || 0).toFixed(3),\n          initialScale: +Number(fitDebug.initialScale || 0).toFixed(3),\n          maxScaleByWidth: fitDebug.maxScaleByWidth == null ? null : +Number(fitDebug.maxScaleByWidth).toFixed(3),\n          maxScaleByHeight: fitDebug.maxScaleByHeight == null ? null : +Number(fitDebug.maxScaleByHeight).toFixed(3),\n          scaleAfterWidthClamp: fitDebug.scaleAfterWidthClamp == null ? null : +Number(fitDebug.scaleAfterWidthClamp).toFixed(3),\n          scaleAfterHeightClamp: fitDebug.scaleAfterHeightClamp == null ? null : +Number(fitDebug.scaleAfterHeightClamp).toFixed(3),\n          tinyShrinkProtected: !!fitDebug.tinyShrinkProtected,\n          pantallaDownscaleBlocked: !!fitDebug.pantallaDownscaleBlocked\n        } : null,\n        appliedScale: +Number(scale || 1).toFixed(3),\n        dominantText: dominantText,\n        topElements: topElements\n      });\n    }\n\n    sec.setAttribute(\"data-msl-fit-scale\", String(+scale.toFixed(3)));\n    mslLog(\"section:fitScale\", {\n      secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\n      mode: secModo,\n      nodes: bounds.count,\n      coverage: +(bounds.width / Math.max(1, sec.getBoundingClientRect().width || 0)).toFixed(3),\n      boxW: +bounds.width.toFixed(1),\n      boxH: +bounds.height.toFixed(1),\n      scale: +scale.toFixed(3),\n      preserveBottomGap: +preserveBottomGap.toFixed(1),\n      scaledBottomGap: +((preserveBottomGap || 0) * scale).toFixed(1),\n      neededHeight: neededHeight\n    });\n\n    return {\n      scale: scale,\n      neededHeight: neededHeight,\n      bounds: bounds\n    };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyYlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGZpdFNjYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHNcbmV4cG9ydCBmdW5jdGlvbiBqc0ZpdFNjYWxlQmxvY2soKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgZnVuY3Rpb24gZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCl7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctdHJhbnNmb3JtXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIiwgZWwuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLW9yaWdpblwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctb3JpZ2luXCIsIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiB8fCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlRml0U2NhbGVCYXNlbGluZShlbCl7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoZWwpO1xuICAgIHZhciBiYXNlVHJhbnNmb3JtID0gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctdHJhbnNmb3JtXCIpIHx8IFwiXCI7XG4gICAgdmFyIGJhc2VPcmlnaW4gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy1vcmlnaW5cIikgfHwgXCJcIjtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICAgIGlmIChiYXNlT3JpZ2luKSBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBiYXNlT3JpZ2luO1xuICAgIGVsc2UgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2Zvcm0tb3JpZ2luXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlFbGVtZW50Rml0U2NhbGUoZWwsIHNjYWxlKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCk7XG4gICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikgfHwgXCJcIjtcbiAgICB2YXIgbmV4dCA9IGJhc2VUcmFuc2Zvcm0gPyAoYmFzZVRyYW5zZm9ybSArIFwiIHNjYWxlKFwiICsgc2NhbGUgKyBcIilcIikgOiAoXCJzY2FsZShcIiArIHNjYWxlICsgXCIpXCIpO1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IG5leHQ7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFNlY3Rpb25GaXRTY2FsZShfc2VjLCBjb250ZW50LCBibGVlZCl7XG4gICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoY29udGVudCk7XG4gICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlcyl7XG4gICAgaWYgKCFzZWMgfHwgIW5vZGVzIHx8ICFub2Rlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBtaW5MZWZ0ID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblRvcCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhSaWdodCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4Qm90dG9tID0gLUluZmluaXR5O1xuICAgIHZhciB2YWxpZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgICB2YXIgcnIgPSByZWxSZWN0KG5vZGUsIHNlYyk7XG4gICAgICB2YXIgdyA9IE51bWJlcihyci53aWR0aCB8fCAwKTtcbiAgICAgIHZhciBoID0gTnVtYmVyKHJyLmhlaWdodCB8fCAwKTtcbiAgICAgIGlmICh3IDw9IDAuNSAmJiBoIDw9IDAuNSkgY29udGludWU7XG5cbiAgICAgIHZhciBsID0gTnVtYmVyKHJyLmxlZnQgfHwgMCk7XG4gICAgICB2YXIgdCA9IE51bWJlcihyci50b3AgfHwgMCk7XG4gICAgICB2YXIgciA9IGwgKyBNYXRoLm1heCgwLCB3KTtcbiAgICAgIHZhciBiID0gdCArIE1hdGgubWF4KDAsIGgpO1xuXG4gICAgICBpZiAoIWlzRmluaXRlKGwpIHx8ICFpc0Zpbml0ZSh0KSB8fCAhaXNGaW5pdGUocikgfHwgIWlzRmluaXRlKGIpKSBjb250aW51ZTtcblxuICAgICAgbWluTGVmdCA9IE1hdGgubWluKG1pbkxlZnQsIGwpO1xuICAgICAgbWluVG9wID0gTWF0aC5taW4obWluVG9wLCB0KTtcbiAgICAgIG1heFJpZ2h0ID0gTWF0aC5tYXgobWF4UmlnaHQsIHIpO1xuICAgICAgbWF4Qm90dG9tID0gTWF0aC5tYXgobWF4Qm90dG9tLCBiKTtcbiAgICAgIHZhbGlkKys7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCB8fCAhaXNGaW5pdGUobWluTGVmdCkgfHwgIWlzRmluaXRlKG1heFJpZ2h0KSB8fCAhaXNGaW5pdGUobWluVG9wKSB8fCAhaXNGaW5pdGUobWF4Qm90dG9tKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbkxlZnQ6IG1pbkxlZnQsXG4gICAgICBtaW5Ub3A6IG1pblRvcCxcbiAgICAgIG1heFJpZ2h0OiBtYXhSaWdodCxcbiAgICAgIG1heEJvdHRvbTogbWF4Qm90dG9tLFxuICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIG1heFJpZ2h0IC0gbWluTGVmdCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG1heEJvdHRvbSAtIG1pblRvcCksXG4gICAgICBjb3VudDogdmFsaWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUZpdFNjYWxlKHNlYywgYm91bmRzLCBzZWNNb2RvLCBDRkcpe1xuICAgIGlmICghc2VjIHx8ICFib3VuZHMpIHJldHVybiAxO1xuICAgIHZhciBzZWNSZWN0ID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzZWNXID0gTnVtYmVyKHNlY1JlY3Qud2lkdGggfHwgMCk7XG4gICAgdmFyIHNlY0ggPSBOdW1iZXIoc2VjUmVjdC5oZWlnaHQgfHwgMCk7XG4gICAgaWYgKHNlY1cgPD0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGRlYnVnOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRDb3ZlcmFnZSA9IGNsYW1wKE51bWJlcihDRkcuRklUX1RBUkdFVF9XSURUSF9SQVRJTyB8fCAwLjk0KSwgMC43NSwgMC45OSk7XG4gICAgdmFyIG1pbkZpbGxGb3JVcHNjYWxlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfTUlOX0ZJTExfUkFUSU8gfHwgMC45KSwgMC42LCB0YXJnZXRDb3ZlcmFnZSk7XG4gICAgdmFyIG1pblNjYWxlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfTUlOX1NDQUxFIHx8IDAuODgpLCAwLjcsIDEpO1xuICAgIHZhciBtYXhTY2FsZSA9IE1hdGgubWF4KDEsIE51bWJlcihDRkcuRklUX01BWF9TQ0FMRSB8fCAxLjE2KSk7XG5cbiAgICB2YXIgY29udGVudFcgPSBNYXRoLm1heCgxLCBOdW1iZXIoYm91bmRzLndpZHRoIHx8IDApKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBjb250ZW50VyAvIHNlY1c7XG5cbiAgICB2YXIgc2NhbGUgPSAxO1xuICAgIHZhciBkZWJ1ZyA9IHtcbiAgICAgIHNlY1c6IHNlY1csXG4gICAgICBzZWNIOiBzZWNILFxuICAgICAgdGFyZ2V0Q292ZXJhZ2U6IHRhcmdldENvdmVyYWdlLFxuICAgICAgbWluRmlsbEZvclVwc2NhbGU6IG1pbkZpbGxGb3JVcHNjYWxlLFxuICAgICAgbWluU2NhbGU6IG1pblNjYWxlLFxuICAgICAgbWF4U2NhbGU6IG1heFNjYWxlLFxuICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgaW5pdGlhbFNjYWxlOiAxLFxuICAgICAgbWF4U2NhbGVCeVdpZHRoOiBudWxsLFxuICAgICAgbWF4U2NhbGVCeUhlaWdodDogbnVsbCxcbiAgICAgIHNjYWxlQWZ0ZXJXaWR0aENsYW1wOiBudWxsLFxuICAgICAgc2NhbGVBZnRlckhlaWdodENsYW1wOiBudWxsLFxuICAgICAgdGlueVNocmlua1Byb3RlY3RlZDogZmFsc2UsXG4gICAgICBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoY292ZXJhZ2UgPCBtaW5GaWxsRm9yVXBzY2FsZSkge1xuICAgICAgc2NhbGUgPSB0YXJnZXRDb3ZlcmFnZSAvIE1hdGgubWF4KDAuMDEsIGNvdmVyYWdlKTtcbiAgICB9XG4gICAgZGVidWcuaW5pdGlhbFNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAoc2NhbGUgPj0gMSkgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4U2NhbGUpO1xuICAgIGVsc2Ugc2NhbGUgPSBNYXRoLm1heChzY2FsZSwgbWluU2NhbGUpO1xuXG4gICAgLy8gTMOtbWl0ZSBob3Jpem9udGFsIGR1cm8gcG9yIGNlbnRybyB2aXN1YWwuXG4gICAgdmFyIGNlbnRlclggPSBzZWNXIC8gMjtcbiAgICB2YXIgZGlzdExlZnQgPSBNYXRoLm1heCgwLCBjZW50ZXJYIC0gTnVtYmVyKGJvdW5kcy5taW5MZWZ0IHx8IDApKTtcbiAgICB2YXIgZGlzdFJpZ2h0ID0gTWF0aC5tYXgoMCwgTnVtYmVyKGJvdW5kcy5tYXhSaWdodCB8fCAwKSAtIGNlbnRlclgpO1xuICAgIHZhciBtYXhTY2FsZUJ5V2lkdGggPSBJbmZpbml0eTtcbiAgICBpZiAoZGlzdExlZnQgPiAwLjUpIHtcbiAgICAgIG1heFNjYWxlQnlXaWR0aCA9IE1hdGgubWluKG1heFNjYWxlQnlXaWR0aCwgY2VudGVyWCAvIGRpc3RMZWZ0KTtcbiAgICB9XG4gICAgaWYgKGRpc3RSaWdodCA+IDAuNSkge1xuICAgICAgbWF4U2NhbGVCeVdpZHRoID0gTWF0aC5taW4obWF4U2NhbGVCeVdpZHRoLCAoc2VjVyAtIGNlbnRlclgpIC8gZGlzdFJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKG1heFNjYWxlQnlXaWR0aCkgJiYgbWF4U2NhbGVCeVdpZHRoID4gMCkge1xuICAgICAgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4U2NhbGVCeVdpZHRoKTtcbiAgICAgIGRlYnVnLm1heFNjYWxlQnlXaWR0aCA9IG1heFNjYWxlQnlXaWR0aDtcbiAgICB9XG4gICAgZGVidWcuc2NhbGVBZnRlcldpZHRoQ2xhbXAgPSBzY2FsZTtcblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIgJiYgc2NhbGUgPCAxICYmIHNjYWxlID4gMC45NCkge1xuICAgICAgLy8gQXZvaWQgc2hyaW5raW5nIFwicGFudGFsbGFcIiBmb3IgdGlueSBvdmVyZmxvd3M7IHByZXNlcnZlIHZpc3VhbCBpbXBhY3QuXG4gICAgICBzY2FsZSA9IDE7XG4gICAgICBkZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBFbiBtb2RvIHBhbnRhbGxhIG5vIGRlamFtb3MgcXVlIGVsIGNvbnRlbmlkbyBzZSByZWNvcnRlIHBvciBhbHR1cmEuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzZWNIID4gMSkge1xuICAgICAgdmFyIG1heEJvdHRvbSA9IE51bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApO1xuICAgICAgaWYgKG1heEJvdHRvbSA+IDEpIHtcbiAgICAgICAgdmFyIG1heFNjYWxlQnlIZWlnaHQgPSBzZWNIIC8gbWF4Qm90dG9tO1xuICAgICAgICBpZiAoaXNGaW5pdGUobWF4U2NhbGVCeUhlaWdodCkgJiYgbWF4U2NhbGVCeUhlaWdodCA+IDApIHtcbiAgICAgICAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZUJ5SGVpZ2h0KTtcbiAgICAgICAgICBkZWJ1Zy5tYXhTY2FsZUJ5SGVpZ2h0ID0gbWF4U2NhbGVCeUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1Zy5zY2FsZUFmdGVySGVpZ2h0Q2xhbXAgPSBzY2FsZTtcblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIgJiYgc2NhbGUgPCAxKSB7XG4gICAgICAvLyBQYW50YWxsYSBzZWN0aW9ucyBhbHJlYWR5IGhhdmUgdGhlaXIgb3duIHZpZXdwb3J0LWZpdCBsb2dpYy5cbiAgICAgIC8vIEF2b2lkIGFkZGl0aW9uYWwgZG93bnNjYWxlIGhlcmUgdG8ga2VlcCBoZXJvIHRleHQgcmVhZGFibGUuXG4gICAgICBzY2FsZSA9IDE7XG4gICAgICBkZWJ1Zy5wYW50YWxsYURvd25zY2FsZUJsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUoc2NhbGUpIHx8IHNjYWxlIDw9IDApIHNjYWxlID0gMTtcbiAgICBpZiAoTWF0aC5hYnMoc2NhbGUgLSAxKSA8IDAuMDIpIHNjYWxlID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgZGVidWc6IGRlYnVnXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5U2VjdGlvbkZpdFNjYWxlKHNlYywgY29udGVudCwgYmxlZWQsIG5vZGVzQWxsLCBzZWNNb2RvLCBDRkcsIG1ldGEsIG9wdHMpe1xuICAgIGlmICghc2VjIHx8ICFjb250ZW50KSB7XG4gICAgICByZXR1cm4geyBzY2FsZTogMSwgbmVlZGVkSGVpZ2h0OiAwLCBib3VuZHM6IG51bGwgfTtcbiAgICB9XG5cbiAgICBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGNvbnRlbnQpO1xuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICAgIHZhciBwcmVzZXJ2ZUJvdHRvbUdhcCA9IDA7XG4gICAgaWYgKG9wdHMgJiYgTnVtYmVyLmlzRmluaXRlKG9wdHMucHJlc2VydmVCb3R0b21HYXApKSB7XG4gICAgICBwcmVzZXJ2ZUJvdHRvbUdhcCA9IE1hdGgubWF4KDAsIE51bWJlcihvcHRzLnByZXNlcnZlQm90dG9tR2FwKSk7XG4gICAgfVxuXG4gICAgdmFyIGZpdE5vZGVzID0gKG5vZGVzQWxsIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBmaXRNb2RlID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZml0TW9kZSA9PT0gXCJpZ25vcmVcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG5vZGUuY2xvc2VzdCAmJiBub2RlLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBib3VuZHMgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIGZpdE5vZGVzKTtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgYm91bmRzID0gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlc0FsbCB8fCBbXSk7XG4gICAgfVxuICAgIGlmICghYm91bmRzKSB7XG4gICAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShjb250ZW50KTtcbiAgICAgIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGJsZWVkKTtcbiAgICAgIHNlYy5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtc2NhbGVcIiwgXCIxXCIpO1xuICAgICAgcmV0dXJuIHsgc2NhbGU6IDEsIG5lZWRlZEhlaWdodDogMCwgYm91bmRzOiBudWxsIH07XG4gICAgfVxuXG4gICAgdmFyIGZpdFJlc3VsdCA9IGNvbXB1dGVGaXRTY2FsZShzZWMsIGJvdW5kcywgc2VjTW9kbywgQ0ZHKTtcbiAgICB2YXIgc2NhbGUgPSAoZml0UmVzdWx0ICYmIE51bWJlci5pc0Zpbml0ZShmaXRSZXN1bHQuc2NhbGUpKSA/IGZpdFJlc3VsdC5zY2FsZSA6IDE7XG4gICAgdmFyIGZpdERlYnVnID0gZml0UmVzdWx0ICYmIGZpdFJlc3VsdC5kZWJ1ZyA/IGZpdFJlc3VsdC5kZWJ1ZyA6IG51bGw7XG4gICAgYXBwbHlFbGVtZW50Rml0U2NhbGUoY29udGVudCwgc2NhbGUpO1xuICAgIGFwcGx5RWxlbWVudEZpdFNjYWxlKGJsZWVkLCBzY2FsZSk7XG5cbiAgICB2YXIgbmVlZGVkSGVpZ2h0ID0gMDtcbiAgICBpZiAoc2VjTW9kbyAhPT0gXCJwYW50YWxsYVwiKSB7XG4gICAgICB2YXIgbWF4Qm90dG9tV2l0aEdhcCA9IE51bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApICsgcHJlc2VydmVCb3R0b21HYXA7XG4gICAgICBuZWVkZWRIZWlnaHQgPSBNYXRoLmNlaWwobWF4Qm90dG9tV2l0aEdhcCAqIHNjYWxlICsgKENGRy5QQURfQk9UIHx8IDApKTtcbiAgICB9XG5cbiAgICBpZiAoc2VjTW9kbyA9PT0gXCJwYW50YWxsYVwiKSB7XG4gICAgICB2YXIgc2VjUmVjdE5vdyA9IHNlYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB2diA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbiAgICAgIHZhciB2aWV3cG9ydFcgPSAodnYgJiYgdnYud2lkdGgpID8gdnYud2lkdGggOiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDApO1xuICAgICAgdmFyIHZpZXdwb3J0SCA9ICh2diAmJiB2di5oZWlnaHQpID8gdnYuaGVpZ2h0IDogKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDApO1xuICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICAgICAgdmFyIG1vYmlsZVVBID0gL0FuZHJvaWR8aVBob25lfGlQYWR8aVBvZHxNb2JpbGUvaS50ZXN0KHVhKTtcbiAgICAgIHZhciB0b3VjaFBvaW50cyA9IE51bWJlcihuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgMCk7XG4gICAgICB2YXIgY29hcnNlUG9pbnRlciA9IGZhbHNlO1xuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHRyeSB7IGNvYXJzZVBvaW50ZXIgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwb2ludGVyOiBjb2Fyc2UpXCIpLm1hdGNoZXM7IH0gY2F0Y2goX2UpIHt9XG4gICAgICB9XG4gICAgICB2YXIgbW9iaWxlVmlld3BvcnQgPSB2aWV3cG9ydFcgPD0gNzY3O1xuICAgICAgdmFyIGRlc2t0b3BNb2JpbGVQcmV2aWV3ID0gbW9iaWxlVmlld3BvcnQgJiYgIW1vYmlsZVVBO1xuXG4gICAgICB2YXIgYm91bmRzQWxsID0gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlc0FsbCB8fCBbXSk7XG4gICAgICB2YXIgdG90YWxOb2RlcyA9IChub2Rlc0FsbCB8fCBbXSkubGVuZ3RoO1xuICAgICAgdmFyIGZpdE5vZGVzQ291bnQgPSBmaXROb2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgdGV4dEFsbCA9IDA7XG4gICAgICB2YXIgdGV4dEZpdCA9IDA7XG4gICAgICB2YXIgaWdub3JlZEJsZWVkID0gMDtcbiAgICAgIHZhciBpZ25vcmVkRXhwbGljaXQgPSAwO1xuICAgICAgdmFyIGRvbWluYW50VGV4dCA9IG51bGw7XG4gICAgICB2YXIgZG9taW5hbnRUZXh0SCA9IC0xO1xuICAgICAgdmFyIGVsZW1lbnRSb3dzID0gW107XG5cbiAgICAgIGZvciAodmFyIG5pPTA7IG5pPHRvdGFsTm9kZXM7IG5pKyspe1xuICAgICAgICB2YXIgbm9kZUFsbCA9IG5vZGVzQWxsW25pXTtcbiAgICAgICAgaWYgKCFub2RlQWxsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZml0TW9kZUFsbCA9IChub2RlQWxsLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWZpdFwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZml0TW9kZUFsbCA9PT0gXCJpZ25vcmVcIikgaWdub3JlZEV4cGxpY2l0Kys7XG4gICAgICAgIGlmIChub2RlQWxsLmNsb3Nlc3QgJiYgbm9kZUFsbC5jbG9zZXN0KFwiLnNlYy1ibGVlZFwiKSkgaWdub3JlZEJsZWVkKys7XG5cbiAgICAgICAgdmFyIHJyTm9kZSA9IHJlbFJlY3Qobm9kZUFsbCwgc2VjKTtcbiAgICAgICAgdmFyIG5vZGVXID0gTnVtYmVyKHJyTm9kZS53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVIID0gTnVtYmVyKHJyTm9kZS5oZWlnaHQgfHwgMCk7XG4gICAgICAgIHZhciBub2RlVG9wID0gTnVtYmVyKHJyTm9kZS50b3AgfHwgMCk7XG4gICAgICAgIHZhciBub2RlQm90dG9tID0gbm9kZVRvcCArIG5vZGVIO1xuICAgICAgICB2YXIgaXNUZXh0QWxsID0gKG5vZGVBbGwuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgIGlmIChpc1RleHRBbGwpIHRleHRBbGwrKztcblxuICAgICAgICBpZiAobm9kZVcgPiAwLjUgfHwgbm9kZUggPiAwLjUpIHtcbiAgICAgICAgICB2YXIga2luZEFsbCA9IGlzVGV4dEFsbCA/IFwidGV4dG9cIiA6IFN0cmluZygobm9kZUFsbC50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGVsZW1lbnRSb3dzLnB1c2goe1xuICAgICAgICAgICAga2luZDoga2luZEFsbCxcbiAgICAgICAgICAgIHdpZHRoOiBub2RlVyxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZUgsXG4gICAgICAgICAgICB0b3A6IG5vZGVUb3AsXG4gICAgICAgICAgICBib3R0b206IG5vZGVCb3R0b20sXG4gICAgICAgICAgICBhcmVhOiBub2RlVyAqIG5vZGVILFxuICAgICAgICAgICAgdGV4dFNhbXBsZTogaXNUZXh0QWxsXG4gICAgICAgICAgICAgID8gKChub2RlQWxsLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA3MClcbiAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVGV4dEFsbCkgY29udGludWU7XG4gICAgICAgIGlmIChub2RlSCA8PSBkb21pbmFudFRleHRIKSBjb250aW51ZTtcbiAgICAgICAgZG9taW5hbnRUZXh0SCA9IG5vZGVIO1xuICAgICAgICB2YXIgY3NUeHQgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGVBbGwpO1xuICAgICAgICBkb21pbmFudFRleHQgPSB7XG4gICAgICAgICAgdG9wOiArbm9kZVRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGxlZnQ6ICtOdW1iZXIocnJOb2RlLmxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICB3aWR0aDogK25vZGVXLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArbm9kZUgudG9GaXhlZCgxKSxcbiAgICAgICAgICBib3R0b206ICtub2RlQm90dG9tLnRvRml4ZWQoMSksXG4gICAgICAgICAgd2lkdGhTZWNSYXRpbzogc2VjUmVjdE5vdy53aWR0aCA+IDEgPyArKG5vZGVXIC8gc2VjUmVjdE5vdy53aWR0aCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0U2VjUmF0aW86IHNlY1JlY3ROb3cuaGVpZ2h0ID4gMSA/ICsobm9kZUggLyBzZWNSZWN0Tm93LmhlaWdodCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgd2lkdGhWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydFcgPiAxID8gKyhub2RlVyAvIHZpZXdwb3J0VykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0Vmlld3BvcnRSYXRpbzogdmlld3BvcnRIID4gMSA/ICsobm9kZUggLyB2aWV3cG9ydEgpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgIGZvbnRTaXplOiBjc1R4dC5mb250U2l6ZSB8fCBcIlwiLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IGNzVHh0LmxpbmVIZWlnaHQgfHwgXCJcIixcbiAgICAgICAgICB0ZXh0QWxpZ246IGNzVHh0LnRleHRBbGlnbiB8fCBcIlwiLFxuICAgICAgICAgIHRyYW5zZm9ybTogKG5vZGVBbGwuc3R5bGUgJiYgbm9kZUFsbC5zdHlsZS50cmFuc2Zvcm0pID8gbm9kZUFsbC5zdHlsZS50cmFuc2Zvcm0gOiBcIlwiLFxuICAgICAgICAgIHRleHRTYW1wbGU6ICgobm9kZUFsbC50ZXh0Q29udGVudCB8fCBcIlwiKS50cmltKCkpLnJlcGxhY2UoL1xcXFxzKy9nLCBcIiBcIikuc2xpY2UoMCwgOTApXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGZpPTA7IGZpPGZpdE5vZGVzLmxlbmd0aDsgZmkrKyl7XG4gICAgICAgIHZhciBmaXROb2RlID0gZml0Tm9kZXNbZmldO1xuICAgICAgICBpZiAoKGZpdE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHRGaXQrKztcbiAgICAgIH1cblxuICAgICAgdmFyIHRvcEVsZW1lbnRzID0gZWxlbWVudFJvd3NcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIChiLmFyZWEgfHwgMCkgLSAoYS5hcmVhIHx8IDApOyB9KVxuICAgICAgICAuc2xpY2UoMCwgNilcbiAgICAgICAgLm1hcChmdW5jdGlvbihyb3cpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiByb3cua2luZCxcbiAgICAgICAgICAgIHdpZHRoOiArTnVtYmVyKHJvdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKHJvdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHdpZHRoU2VjUmF0aW86IHNlY1JlY3ROb3cud2lkdGggPiAxID8gKygocm93LndpZHRoIHx8IDApIC8gc2VjUmVjdE5vdy53aWR0aCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBoZWlnaHRTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKygocm93LmhlaWdodCB8fCAwKSAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIHdpZHRoVmlld3BvcnRSYXRpbzogdmlld3BvcnRXID4gMSA/ICsoKHJvdy53aWR0aCB8fCAwKSAvIHZpZXdwb3J0VykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBoZWlnaHRWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydEggPiAxID8gKygocm93LmhlaWdodCB8fCAwKSAvIHZpZXdwb3J0SCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICB0b3BTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKygocm93LnRvcCB8fCAwKSAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGJvdHRvbVNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cuYm90dG9tIHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgc2FtcGxlOiByb3cudGV4dFNhbXBsZSB8fCBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHZhciBjb3ZlcmFnZUZpdCA9IGJvdW5kcy53aWR0aCAvIE1hdGgubWF4KDEsIHNlY1JlY3ROb3cud2lkdGggfHwgMCk7XG4gICAgICB2YXIgY292ZXJhZ2VBbGwgPSBib3VuZHNBbGwgPyAoYm91bmRzQWxsLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjUmVjdE5vdy53aWR0aCB8fCAwKSkgOiBudWxsO1xuXG4gICAgICB2YXIgZmxhdExpbmVzID0gW107XG4gICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgXCJzZWM9XCIgKyBTdHJpbmcobWV0YSAmJiBOdW1iZXIuaXNGaW5pdGUobWV0YS5zZWNJbmRleCkgPyBtZXRhLnNlY0luZGV4IDogLTEpXG4gICAgICAgICsgXCIgdmlld3BvcnQ9XCIgKyAoK051bWJlcih2aWV3cG9ydFcgfHwgMCkudG9GaXhlZCgxKSkgKyBcInhcIiArICgrTnVtYmVyKHZpZXdwb3J0SCB8fCAwKS50b0ZpeGVkKDEpKVxuICAgICAgICArIFwiIHNlYz1cIiArICgrTnVtYmVyKHNlY1JlY3ROb3cud2lkdGggfHwgMCkudG9GaXhlZCgxKSkgKyBcInhcIiArICgrTnVtYmVyKHNlY1JlY3ROb3cuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSkpXG4gICAgICAgICsgXCIgbW9iaWxlVmlld3BvcnQ9XCIgKyBTdHJpbmcobW9iaWxlVmlld3BvcnQpXG4gICAgICAgICsgXCIgZGVza3RvcE1vYmlsZVByZXZpZXc9XCIgKyBTdHJpbmcoZGVza3RvcE1vYmlsZVByZXZpZXcpXG4gICAgICAgICsgXCIgbW9iaWxlVUE9XCIgKyBTdHJpbmcobW9iaWxlVUEpXG4gICAgICAgICsgXCIgY29hcnNlUG9pbnRlcj1cIiArIFN0cmluZyhjb2Fyc2VQb2ludGVyKVxuICAgICAgICArIFwiIHRvdWNoUG9pbnRzPVwiICsgU3RyaW5nKHRvdWNoUG9pbnRzKVxuICAgICAgKTtcbiAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICBcImZpdCBzY2FsZT1cIiArICgrTnVtYmVyKHNjYWxlIHx8IDEpLnRvRml4ZWQoMykpXG4gICAgICAgICsgXCIgY292ZXJhZ2VGaXQ9XCIgKyAoK2NvdmVyYWdlRml0LnRvRml4ZWQoMykpXG4gICAgICAgICsgXCIgY292ZXJhZ2VBbGw9XCIgKyAoY292ZXJhZ2VBbGwgPT0gbnVsbCA/IFwibnVsbFwiIDogU3RyaW5nKCtjb3ZlcmFnZUFsbC50b0ZpeGVkKDMpKSlcbiAgICAgICAgKyBcIiBub2Rlcz1cIiArIFN0cmluZyhmaXROb2Rlc0NvdW50KSArIFwiL1wiICsgU3RyaW5nKHRvdGFsTm9kZXMpXG4gICAgICAgICsgXCIgaWdub3JlZEJsZWVkPVwiICsgU3RyaW5nKGlnbm9yZWRCbGVlZClcbiAgICAgICAgKyBcIiBpZ25vcmVkRXhwbGljaXQ9XCIgKyBTdHJpbmcoaWdub3JlZEV4cGxpY2l0KVxuICAgICAgICArIFwiIHRpbnlTaHJpbmtQcm90ZWN0ZWQ9XCIgKyBTdHJpbmcoISEoZml0RGVidWcgJiYgZml0RGVidWcudGlueVNocmlua1Byb3RlY3RlZCkpXG4gICAgICAgICsgXCIgcGFudGFsbGFEb3duc2NhbGVCbG9ja2VkPVwiICsgU3RyaW5nKCEhKGZpdERlYnVnICYmIGZpdERlYnVnLnBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZCkpXG4gICAgICApO1xuICAgICAgaWYgKGRvbWluYW50VGV4dCkge1xuICAgICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgICBcImRvbWluYW50VGV4dCBoU2VjUmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmhlaWdodFNlY1JhdGlvKVxuICAgICAgICAgICsgXCIgaFZpZXdwb3J0UmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmhlaWdodFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiB3U2VjUmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LndpZHRoU2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBmb250U2l6ZT1cIiArIFN0cmluZyhkb21pbmFudFRleHQuZm9udFNpemUgfHwgXCJcIilcbiAgICAgICAgICArIFwiIGxpbmVIZWlnaHQ9XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmxpbmVIZWlnaHQgfHwgXCJcIilcbiAgICAgICAgICArIFwiIHNhbXBsZT0nXCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LnRleHRTYW1wbGUgfHwgXCJcIikgKyBcIidcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdExpbmVzLnB1c2goXCJkb21pbmFudFRleHQgbm9uZVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHRlPTA7IHRlPHRvcEVsZW1lbnRzLmxlbmd0aDsgdGUrKyl7XG4gICAgICAgIHZhciBlID0gdG9wRWxlbWVudHNbdGVdO1xuICAgICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgICBcImVsI1wiICsgU3RyaW5nKHRlICsgMSlcbiAgICAgICAgICArIFwiIGtpbmQ9XCIgKyBTdHJpbmcoZS5raW5kIHx8IFwiXCIpXG4gICAgICAgICAgKyBcIiB3VnA9XCIgKyBTdHJpbmcoZS53aWR0aFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiBoVnA9XCIgKyBTdHJpbmcoZS5oZWlnaHRWaWV3cG9ydFJhdGlvKVxuICAgICAgICAgICsgXCIgdG9wU2VjPVwiICsgU3RyaW5nKGUudG9wU2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBib3R0b21TZWM9XCIgKyBTdHJpbmcoZS5ib3R0b21TZWNSYXRpbylcbiAgICAgICAgICArIChlLnNhbXBsZSA/IChcIiBzYW1wbGU9J1wiICsgU3RyaW5nKGUuc2FtcGxlKSArIFwiJ1wiKSA6IFwiXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmZpdFNjYWxlOnBhbnRhbGxhOmZsYXRcIiwgZmxhdExpbmVzLmpvaW4oXCJcXFxcblwiKSk7XG5cbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGU6cGFudGFsbGFcIiwge1xuICAgICAgICBzZWNJbmRleDogbWV0YSAmJiBOdW1iZXIuaXNGaW5pdGUobWV0YS5zZWNJbmRleCkgPyBtZXRhLnNlY0luZGV4IDogLTEsXG4gICAgICAgIHNlY1c6ICtOdW1iZXIoc2VjUmVjdE5vdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICBzZWNIOiArTnVtYmVyKHNlY1JlY3ROb3cuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIodmlld3BvcnRXIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKHZpZXdwb3J0SCB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXlDb250ZXh0OiB7XG4gICAgICAgICAgbW9iaWxlVmlld3BvcnQ6IG1vYmlsZVZpZXdwb3J0LFxuICAgICAgICAgIGRlc2t0b3BNb2JpbGVQcmV2aWV3OiBkZXNrdG9wTW9iaWxlUHJldmlldyxcbiAgICAgICAgICBtb2JpbGVVQTogbW9iaWxlVUEsXG4gICAgICAgICAgY29hcnNlUG9pbnRlcjogY29hcnNlUG9pbnRlcixcbiAgICAgICAgICB0b3VjaFBvaW50czogdG91Y2hQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtwcmVzZXJ2ZUJvdHRvbUdhcC50b0ZpeGVkKDEpLFxuICAgICAgICB0b3RhbE5vZGVzOiB0b3RhbE5vZGVzLFxuICAgICAgICBmaXROb2RlczogZml0Tm9kZXNDb3VudCxcbiAgICAgICAgdGV4dE5vZGVzQWxsOiB0ZXh0QWxsLFxuICAgICAgICB0ZXh0Tm9kZXNGaXQ6IHRleHRGaXQsXG4gICAgICAgIGlnbm9yZWRCbGVlZDogaWdub3JlZEJsZWVkLFxuICAgICAgICBpZ25vcmVkRXhwbGljaXQ6IGlnbm9yZWRFeHBsaWNpdCxcbiAgICAgICAgY292ZXJhZ2VGaXQ6ICtjb3ZlcmFnZUZpdC50b0ZpeGVkKDMpLFxuICAgICAgICBjb3ZlcmFnZUFsbDogY292ZXJhZ2VBbGwgPT0gbnVsbCA/IG51bGwgOiArY292ZXJhZ2VBbGwudG9GaXhlZCgzKSxcbiAgICAgICAgZml0Qm91bmRzOiB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIoYm91bmRzLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKGJvdW5kcy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBtYXhCb3R0b206ICtOdW1iZXIoYm91bmRzLm1heEJvdHRvbSB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0sXG4gICAgICAgIGFsbEJvdW5kczogYm91bmRzQWxsID8ge1xuICAgICAgICAgIHdpZHRoOiArTnVtYmVyKGJvdW5kc0FsbC53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIGhlaWdodDogK051bWJlcihib3VuZHNBbGwuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgbWF4Qm90dG9tOiArTnVtYmVyKGJvdW5kc0FsbC5tYXhCb3R0b20gfHwgMCkudG9GaXhlZCgxKVxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgZml0RGVidWc6IGZpdERlYnVnID8ge1xuICAgICAgICAgIHRhcmdldENvdmVyYWdlOiArTnVtYmVyKGZpdERlYnVnLnRhcmdldENvdmVyYWdlIHx8IDApLnRvRml4ZWQoMyksXG4gICAgICAgICAgbWluRmlsbEZvclVwc2NhbGU6ICtOdW1iZXIoZml0RGVidWcubWluRmlsbEZvclVwc2NhbGUgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBjb3ZlcmFnZTogK051bWJlcihmaXREZWJ1Zy5jb3ZlcmFnZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIGluaXRpYWxTY2FsZTogK051bWJlcihmaXREZWJ1Zy5pbml0aWFsU2NhbGUgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBtYXhTY2FsZUJ5V2lkdGg6IGZpdERlYnVnLm1heFNjYWxlQnlXaWR0aCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcubWF4U2NhbGVCeVdpZHRoKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIG1heFNjYWxlQnlIZWlnaHQ6IGZpdERlYnVnLm1heFNjYWxlQnlIZWlnaHQgPT0gbnVsbCA/IG51bGwgOiArTnVtYmVyKGZpdERlYnVnLm1heFNjYWxlQnlIZWlnaHQpLnRvRml4ZWQoMyksXG4gICAgICAgICAgc2NhbGVBZnRlcldpZHRoQ2xhbXA6IGZpdERlYnVnLnNjYWxlQWZ0ZXJXaWR0aENsYW1wID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5zY2FsZUFmdGVyV2lkdGhDbGFtcCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBzY2FsZUFmdGVySGVpZ2h0Q2xhbXA6IGZpdERlYnVnLnNjYWxlQWZ0ZXJIZWlnaHRDbGFtcCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcuc2NhbGVBZnRlckhlaWdodENsYW1wKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIHRpbnlTaHJpbmtQcm90ZWN0ZWQ6ICEhZml0RGVidWcudGlueVNocmlua1Byb3RlY3RlZCxcbiAgICAgICAgICBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ6ICEhZml0RGVidWcucGFudGFsbGFEb3duc2NhbGVCbG9ja2VkXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBhcHBsaWVkU2NhbGU6ICtOdW1iZXIoc2NhbGUgfHwgMSkudG9GaXhlZCgzKSxcbiAgICAgICAgZG9taW5hbnRUZXh0OiBkb21pbmFudFRleHQsXG4gICAgICAgIHRvcEVsZW1lbnRzOiB0b3BFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBTdHJpbmcoK3NjYWxlLnRvRml4ZWQoMykpKTtcbiAgICBtc2xMb2coXCJzZWN0aW9uOmZpdFNjYWxlXCIsIHtcbiAgICAgIHNlY0luZGV4OiBtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSxcbiAgICAgIG1vZGU6IHNlY01vZG8sXG4gICAgICBub2RlczogYm91bmRzLmNvdW50LFxuICAgICAgY292ZXJhZ2U6ICsoYm91bmRzLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IDApKS50b0ZpeGVkKDMpLFxuICAgICAgYm94VzogK2JvdW5kcy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgYm94SDogK2JvdW5kcy5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgIHNjYWxlOiArc2NhbGUudG9GaXhlZCgzKSxcbiAgICAgIHByZXNlcnZlQm90dG9tR2FwOiArcHJlc2VydmVCb3R0b21HYXAudG9GaXhlZCgxKSxcbiAgICAgIHNjYWxlZEJvdHRvbUdhcDogKygocHJlc2VydmVCb3R0b21HYXAgfHwgMCkgKiBzY2FsZSkudG9GaXhlZCgxKSxcbiAgICAgIG5lZWRlZEhlaWdodDogbmVlZGVkSGVpZ2h0XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgbmVlZGVkSGVpZ2h0OiBuZWVkZWRIZWlnaHQsXG4gICAgICBib3VuZHM6IGJvdW5kc1xuICAgIH07XG4gIH1cbmAudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbImpzRml0U2NhbGVCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* reexport safe */ _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__.buildScript),\n/* harmony export */   normalizeConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts\");\n/* harmony import */ var _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scriptTemplate */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\");\n// functions/src/utils/mobileSmartLayout/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlEQUFpRDtBQUVOO0FBQ0kiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHNcclxuZXhwb3J0IHR5cGUgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5leHBvcnQgeyBub3JtYWxpemVDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcclxuZXhwb3J0IHsgYnVpbGRTY3JpcHQgfSBmcm9tIFwiLi9zY3JpcHRUZW1wbGF0ZVwiO1xyXG4iXSwibmFtZXMiOlsibm9ybWFsaXplQ29uZmlnIiwiYnVpbGRTY3JpcHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/ordering.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsOrderingBlock: () => (/* binding */ jsOrderingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/ordering.ts\nfunction jsOrderingBlock() {\n    return `\n  /**\n   * Ordena CLUSTERS (no items) para lectura mobile.\n   * Devuelve groups (array de columnas/grupos) y mode.\n   *\n   * - three: [colL, colC, colR]\n   * - two:   [left, right]\n   * - rows:  [out] (fila+left)\n   * - one:   [sortedTop]\n   */\n  function orderClustersForMobile(clusters, rootW, CFG){\n    if (!rootW || rootW <= 0) {\n      var o = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n      return { groups: [o], mode: \"one\" };\n    }\n\n    function clusterHasText(c){\n      if (!c || !c.items || !c.items.length) return false;\n      for (var iTxt=0; iTxt<c.items.length; iTxt++){\n        if ((c.items[iTxt].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return true;\n      }\n      return false;\n    }\n\n    function columnHasText(col){\n      if (!col || !col.length) return false;\n      for (var iCol=0; iCol<col.length; iCol++){\n        if (clusterHasText(col[iCol])) return true;\n      }\n      return false;\n    }\n\n    // Un cluster \"invade\" una frontera si queda partido de forma significativa\n    // entre ambos lados de la linea divisoria.\n    function clusterInvadesDivider(c, dividerX){\n      if (!c) return false;\n      var left = Number(c.left || 0);\n      var width = Math.max(0, Number(c.width || 0));\n      var right = left + width;\n      if (width <= 1) return false;\n      if (right <= dividerX || left >= dividerX) return false;\n\n      var partLeft = dividerX - left;\n      var partRight = right - dividerX;\n      var minPart = Math.min(partLeft, partRight);\n      var minRequired = Math.max(22, width * 0.22);\n      return minPart >= minRequired;\n    }\n\n    function dividerInvasionRatio(list, dividerX){\n      if (!list || !list.length) return 0;\n      var invaded = 0;\n      for (var iInv=0; iInv<list.length; iInv++){\n        if (clusterInvadesDivider(list[iInv], dividerX)) invaded++;\n      }\n      return invaded / Math.max(1, list.length);\n    }\n\n    // -------- 0) Intentar 3 columnas claras --------\n    var t1 = rootW / 3;\n    var t2 = (2 * rootW) / 3;\n\n    var colL = [];\n    var colC = [];\n    var colR = [];\n\n    for (var i=0;i<clusters.length;i++){\n      var c = clusters[i];\n      var x = c.cx;\n      if (x < t1) colL.push(c);\n      else if (x < t2) colC.push(c);\n      else colR.push(c);\n    }\n\n    var looksThree =\n      (colL.length >= CFG.MIN_PER_COL_3 && colC.length >= CFG.MIN_PER_COL_3 && colR.length >= CFG.MIN_PER_COL_3);\n    var textColsThree =\n      (columnHasText(colL) ? 1 : 0) +\n      (columnHasText(colC) ? 1 : 0) +\n      (columnHasText(colR) ? 1 : 0);\n    var hasTextSignalThree = textColsThree >= 2;\n    mslLog(\"order:three:candidates\", {\n      rootW: rootW,\n      total: clusters.length,\n      colL: colL.length,\n      colC: colC.length,\n      colR: colR.length,\n      minPerCol3: CFG.MIN_PER_COL_3,\n      textColsThree: textColsThree,\n      hasTextSignalThree: hasTextSignalThree\n    });\n\n    if (looksThree) {\n      var cxs = [];\n      for (var j=0;j<clusters.length;j++) cxs.push(clusters[j].cx);\n      cxs.sort(function(a,b){ return a-b; });\n      var p20 = percentile(cxs, 0.20);\n      var p80 = percentile(cxs, 0.80);\n      var spread = (p80 - p20);\n      mslLog(\"order:three:spread\", {\n        p20: p20,\n        p80: p80,\n        spread: spread,\n        minSpread: rootW * CFG.THREE_COL_SPREAD_RATIO,\n        pass: spread >= rootW * CFG.THREE_COL_SPREAD_RATIO\n      });\n      if (spread < rootW * CFG.THREE_COL_SPREAD_RATIO) looksThree = false;\n    }\n\n    if (looksThree) {\n      var invadeT1 = dividerInvasionRatio(clusters, t1);\n      var invadeT2 = dividerInvasionRatio(clusters, t2);\n      var invadeThree = Math.max(invadeT1, invadeT2);\n      var invasionLimitThree = hasTextSignalThree ? 0.46 : 0.34;\n      mslLog(\"order:three:invasion\", {\n        t1: +t1.toFixed(1),\n        t2: +t2.toFixed(1),\n        invadeT1: +invadeT1.toFixed(3),\n        invadeT2: +invadeT2.toFixed(3),\n        invadeThree: +invadeThree.toFixed(3),\n        limit: +invasionLimitThree.toFixed(3),\n        hasTextSignalThree: hasTextSignalThree,\n        pass: invadeThree <= invasionLimitThree\n      });\n      if (invadeThree > invasionLimitThree) looksThree = false;\n    }\n\n    if (looksThree) {\n      colL.sort(function(a,b){ return a.top - b.top; });\n      colC.sort(function(a,b){ return a.top - b.top; });\n      colR.sort(function(a,b){ return a.top - b.top; });\n      return { groups: [colL, colC, colR], mode: \"three\" };\n    }\n\n    // -------- 1) Intentar 2 columnas claras --------\n    var mid = rootW / 2;\n    var left = [];\n    var right = [];\n\n    for (var k=0;k<clusters.length;k++){\n      var c2 = clusters[k];\n      if (c2.cx < mid) left.push(c2);\n      else right.push(c2);\n    }\n\n    var looksTwo = (left.length >= CFG.MIN_PER_COL_2 && right.length >= CFG.MIN_PER_COL_2);\n    var hasTextSignalTwo = columnHasText(left) && columnHasText(right);\n    mslLog(\"order:two:candidates\", {\n      rootW: rootW,\n      total: clusters.length,\n      left: left.length,\n      right: right.length,\n      minPerCol2: CFG.MIN_PER_COL_2,\n      hasTextSignalTwo: hasTextSignalTwo\n    });\n\n    // Politica para pares (2 clusters):\n    // - par de columnas reales => mode \"two\"\n    // - resto de casos => mode \"one\" (fitCheck decide si reflowea)\n    if (clusters.length === 2) {\n      var cA = clusters[0];\n      var cB = clusters[1];\n\n      function pairStats(c){\n        var text = 0;\n        var non = 0;\n        var force = 0;\n        for (var q=0; q<c.items.length; q++) {\n          var n = c.items[q].node;\n          if ((n.getAttribute(\"data-mobile-center\") || \"\") === \"force\") force++;\n          if ((n.getAttribute(\"data-debug-texto\") || \"\") === \"1\") text++;\n          else non++;\n        }\n        return { text: text, non: non, force: force };\n      }\n\n      var sA = pairStats(cA);\n      var sB = pairStats(cB);\n\n      var topDelta = Math.abs((cA.top || 0) - (cB.top || 0));\n      var xOverlap = Math.max(0, Math.min((cA.left + cA.width), (cB.left + cB.width)) - Math.max(cA.left, cB.left));\n      var minWPair = Math.max(1, Math.min((cA.width || 0), (cB.width || 0)));\n      var xOverlapRatio = xOverlap / minWPair;\n      var sideBySide = topDelta <= (CFG.ROW_TOL * 1.5) && xOverlapRatio < 0.25;\n      var pairInvasion = dividerInvasionRatio([cA, cB], mid);\n      var pairInvasionLimit = hasTextSignalTwo ? 0.5 : 0.34;\n\n      var anyForceCenter = (sA.force > 0 || sB.force > 0);\n      var bothMixed = (sA.text > 0 && sA.non > 0 && sB.text > 0 && sB.non > 0);\n      // Señal robusta de \"par de columnas\":\n      // - están lado a lado y pasan split left/right\n      // - y además no son simplemente 2 textos sueltos en una fila\n      var hasColumnSignal =\n        (sA.non > 0 || sB.non > 0) ||\n        ((cA.items && cA.items.length > 1) || (cB.items && cB.items.length > 1));\n\n      if (looksTwo && sideBySide && hasColumnSignal && pairInvasion <= pairInvasionLimit) {\n        var leftPair = (cA.cx <= cB.cx) ? [cA] : [cB];\n        var rightPair = (cA.cx <= cB.cx) ? [cB] : [cA];\n        mslLog(\"order:two:pairPolicy\", {\n          mode: \"two\",\n          reason: \"pairColumns\",\n          topDelta: +topDelta.toFixed(1),\n          xOverlapRatio: +xOverlapRatio.toFixed(3),\n          hasColumnSignal: hasColumnSignal,\n          bothMixed: bothMixed,\n          anyForceCenter: anyForceCenter,\n          pairInvasion: +pairInvasion.toFixed(3),\n          pairInvasionLimit: +pairInvasionLimit.toFixed(3),\n          lefts: [+(cA.left || 0).toFixed(1), +(cB.left || 0).toFixed(1)]\n        });\n        return { groups: [leftPair, rightPair], mode: \"two\" };\n      }\n\n      var pair = clusters.slice().sort(function(a,b){\n        if (Math.abs(a.top - b.top) > 0.5) return a.top - b.top;\n        return a.left - b.left;\n      });\n      mslLog(\"order:two:pairPolicy\", {\n        mode: \"one\",\n        reason: anyForceCenter ? \"forceCenterPair\" : \"pairDefault\",\n        topDelta: +topDelta.toFixed(1),\n        xOverlapRatio: +xOverlapRatio.toFixed(3),\n        sideBySide: sideBySide,\n        bothMixed: bothMixed,\n        anyForceCenter: anyForceCenter,\n        pairInvasion: +pairInvasion.toFixed(3),\n        pairInvasionLimit: +pairInvasionLimit.toFixed(3),\n        tops: pair.map(function(c){ return +c.top.toFixed(1); }),\n        lefts: pair.map(function(c){ return +c.left.toFixed(1); })\n      });\n      return { groups: [pair], mode: \"one\" };\n    }\n    if (looksTwo) {\n      var cxs2 = [];\n      for (var m=0;m<clusters.length;m++) cxs2.push(clusters[m].cx);\n      cxs2.sort(function(a,b){ return a-b; });\n      var p25 = percentile(cxs2, 0.25);\n      var p75 = percentile(cxs2, 0.75);\n      var spread2 = (p75 - p25);\n      mslLog(\"order:two:spread\", {\n        p25: p25,\n        p75: p75,\n        spread: spread2,\n        minSpread: rootW * CFG.TWO_COL_SPREAD_RATIO,\n        pass: spread2 >= rootW * CFG.TWO_COL_SPREAD_RATIO\n      });\n      if (spread2 < rootW * CFG.TWO_COL_SPREAD_RATIO) looksTwo = false;\n    }\n\n    if (looksTwo) {\n      var invadeMid = dividerInvasionRatio(clusters, mid);\n      var invasionLimitTwo = hasTextSignalTwo ? 0.48 : 0.34;\n      mslLog(\"order:two:invasion\", {\n        mid: +mid.toFixed(1),\n        invadeMid: +invadeMid.toFixed(3),\n        limit: +invasionLimitTwo.toFixed(3),\n        hasTextSignalTwo: hasTextSignalTwo,\n        pass: invadeMid <= invasionLimitTwo\n      });\n      if (invadeMid > invasionLimitTwo) looksTwo = false;\n    }\n\n    if (looksTwo) {\n      left.sort(function(a,b){ return a.top - b.top; });\n      right.sort(function(a,b){ return a.top - b.top; });\n      return { groups: [left, right], mode: \"two\" };\n    }\n\n    // -------- 2) Guard tardio: una sola columna visual --------\n    // Se evalua despues de two/three para evitar falsos \"one\" cuando hay\n    // dos columnas reales con varios clusters.\n    if (clusters.length >= 2) {\n      var cxsOne = clusters.map(function(c){ return c.cx; }).sort(function(a,b){ return a-b; });\n      var medianCx = percentile(cxsOne, 0.50);\n      var maxDevCx = 0;\n      for (var s=0; s<clusters.length; s++) {\n        var dev = Math.abs((clusters[s].cx || 0) - medianCx);\n        if (dev > maxDevCx) maxDevCx = dev;\n      }\n\n      var singleColMaxDev = rootW * 0.18;\n      var looksOneCol = maxDevCx <= singleColMaxDev;\n      mslLog(\"order:one:candidates\", {\n        rootW: rootW,\n        total: clusters.length,\n        medianCx: +medianCx.toFixed(1),\n        maxDevCx: +maxDevCx.toFixed(1),\n        maxAllowed: +singleColMaxDev.toFixed(1),\n        pass: looksOneCol,\n        stage: \"postTwoThree\"\n      });\n\n      if (looksOneCol) {\n        var oneCol = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n        return { groups: [oneCol], mode: \"one\" };\n      }\n    }\n\n    // -------- 3) Fallback: filas (top) y dentro por left --------\n    var sorted = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n\n    var rows = [];\n    for (var r=0;r<sorted.length;r++){\n      var c3 = sorted[r];\n      var placed = false;\n\n      for (var rr=0; rr<rows.length; rr++){\n        var row = rows[rr];\n        if (Math.abs(c3.top - row.top) <= CFG.ROW_TOL){\n          row.items.push(c3);\n          row.top = (row.top * (row.items.length - 1) + c3.top) / row.items.length;\n          placed = true;\n          break;\n        }\n      }\n\n      if (!placed) rows.push({ top: c3.top, items: [c3] });\n    }\n\n    rows.sort(function(a,b){ return a.top - b.top; });\n    rows.forEach(function(row){\n      row.items.sort(function(a,b){ return a.left - b.left; });\n    });\n\n    function clusterIsText(c){\n      if (!c || !c.items || !c.items.length) return false;\n      for (var i2=0; i2<c.items.length; i2++){\n        if ((c.items[i2].node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\n      }\n      return true;\n    }\n\n    var out = [];\n    var didInterleave = false;\n    // Caso especial: dos filas simetricas (ej. iconos arriba y textos abajo).\n    // Reordenamos por columna: top1,bottom1,top2,bottom2,...\n    if (rows.length === 2 && rows[0].items.length === rows[1].items.length && rows[0].items.length >= 2) {\n      var topRow = rows[0].items.slice();\n      var botRow = rows[1].items.slice();\n      var topHasNonText = topRow.some(function(c){ return !clusterIsText(c); });\n      var botMostlyText = botRow.filter(function(c){ return clusterIsText(c); }).length >= Math.ceil(botRow.length / 2);\n\n      if (topHasNonText && botMostlyText) {\n        var usedBottom = {};\n        for (var tr=0; tr<topRow.length; tr++){\n          var a = topRow[tr];\n          out.push(a);\n\n          var bestIdx = -1;\n          var bestDist = Infinity;\n          for (var br=0; br<botRow.length; br++){\n            if (usedBottom[br]) continue;\n            var b = botRow[br];\n            var d = Math.abs((a.left || 0) - (b.left || 0));\n            if (d < bestDist) {\n              bestDist = d;\n              bestIdx = br;\n            }\n          }\n          if (bestIdx >= 0) {\n            out.push(botRow[bestIdx]);\n            usedBottom[bestIdx] = true;\n          }\n        }\n        for (var br2=0; br2<botRow.length; br2++){\n          if (!usedBottom[br2]) out.push(botRow[br2]);\n        }\n        didInterleave = true;\n      }\n    }\n\n    if (!didInterleave) {\n      rows.forEach(function(row){\n        for (var z=0; z<row.items.length; z++) out.push(row.items[z]);\n      });\n    }\n    mslLog(\"order:rows:fallback\", {\n      rows: rows.map(function(r){\n        return {\n          top: +r.top.toFixed(1),\n          len: r.items.length,\n          lefts: r.items.map(function(it){ return +it.left.toFixed(1); })\n        };\n      }),\n      outLen: out.length,\n      didInterleave: didInterleave\n    });\n\n    return { groups: [out], mode: \"rows\" };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvb3JkZXJpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVZVixDQUFDLENBQUNDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcb3JkZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9vcmRlcmluZy50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNPcmRlcmluZ0Jsb2NrKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBcclxuICAvKipcclxuICAgKiBPcmRlbmEgQ0xVU1RFUlMgKG5vIGl0ZW1zKSBwYXJhIGxlY3R1cmEgbW9iaWxlLlxyXG4gICAqIERldnVlbHZlIGdyb3VwcyAoYXJyYXkgZGUgY29sdW1uYXMvZ3J1cG9zKSB5IG1vZGUuXHJcbiAgICpcclxuICAgKiAtIHRocmVlOiBbY29sTCwgY29sQywgY29sUl1cclxuICAgKiAtIHR3bzogICBbbGVmdCwgcmlnaHRdXHJcbiAgICogLSByb3dzOiAgW291dF0gKGZpbGErbGVmdClcclxuICAgKiAtIG9uZTogICBbc29ydGVkVG9wXVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG9yZGVyQ2x1c3RlcnNGb3JNb2JpbGUoY2x1c3RlcnMsIHJvb3RXLCBDRkcpe1xuICAgIGlmICghcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgdmFyIG8gPSBjbHVzdGVycy5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbb10sIG1vZGU6IFwib25lXCIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbHVzdGVySGFzVGV4dChjKXtcbiAgICAgIGlmICghYyB8fCAhYy5pdGVtcyB8fCAhYy5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGlUeHQ9MDsgaVR4dDxjLml0ZW1zLmxlbmd0aDsgaVR4dCsrKXtcbiAgICAgICAgaWYgKChjLml0ZW1zW2lUeHRdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbkhhc1RleHQoY29sKXtcbiAgICAgIGlmICghY29sIHx8ICFjb2wubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpQ29sPTA7IGlDb2w8Y29sLmxlbmd0aDsgaUNvbCsrKXtcbiAgICAgICAgaWYgKGNsdXN0ZXJIYXNUZXh0KGNvbFtpQ29sXSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVuIGNsdXN0ZXIgXCJpbnZhZGVcIiB1bmEgZnJvbnRlcmEgc2kgcXVlZGEgcGFydGlkbyBkZSBmb3JtYSBzaWduaWZpY2F0aXZhXG4gICAgLy8gZW50cmUgYW1ib3MgbGFkb3MgZGUgbGEgbGluZWEgZGl2aXNvcmlhLlxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJJbnZhZGVzRGl2aWRlcihjLCBkaXZpZGVyWCl7XG4gICAgICBpZiAoIWMpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZWZ0ID0gTnVtYmVyKGMubGVmdCB8fCAwKTtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KDAsIE51bWJlcihjLndpZHRoIHx8IDApKTtcbiAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIGlmICh3aWR0aCA8PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocmlnaHQgPD0gZGl2aWRlclggfHwgbGVmdCA+PSBkaXZpZGVyWCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgcGFydExlZnQgPSBkaXZpZGVyWCAtIGxlZnQ7XG4gICAgICB2YXIgcGFydFJpZ2h0ID0gcmlnaHQgLSBkaXZpZGVyWDtcbiAgICAgIHZhciBtaW5QYXJ0ID0gTWF0aC5taW4ocGFydExlZnQsIHBhcnRSaWdodCk7XG4gICAgICB2YXIgbWluUmVxdWlyZWQgPSBNYXRoLm1heCgyMiwgd2lkdGggKiAwLjIyKTtcbiAgICAgIHJldHVybiBtaW5QYXJ0ID49IG1pblJlcXVpcmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdmlkZXJJbnZhc2lvblJhdGlvKGxpc3QsIGRpdmlkZXJYKXtcbiAgICAgIGlmICghbGlzdCB8fCAhbGlzdC5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgdmFyIGludmFkZWQgPSAwO1xuICAgICAgZm9yICh2YXIgaUludj0wOyBpSW52PGxpc3QubGVuZ3RoOyBpSW52Kyspe1xuICAgICAgICBpZiAoY2x1c3RlckludmFkZXNEaXZpZGVyKGxpc3RbaUludl0sIGRpdmlkZXJYKSkgaW52YWRlZCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludmFkZWQgLyBNYXRoLm1heCgxLCBsaXN0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMCkgSW50ZW50YXIgMyBjb2x1bW5hcyBjbGFyYXMgLS0tLS0tLS1cbiAgICB2YXIgdDEgPSByb290VyAvIDM7XG4gICAgdmFyIHQyID0gKDIgKiByb290VykgLyAzO1xuXHJcbiAgICB2YXIgY29sTCA9IFtdO1xyXG4gICAgdmFyIGNvbEMgPSBbXTtcclxuICAgIHZhciBjb2xSID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaT0wO2k8Y2x1c3RlcnMubGVuZ3RoO2krKyl7XHJcbiAgICAgIHZhciBjID0gY2x1c3RlcnNbaV07XHJcbiAgICAgIHZhciB4ID0gYy5jeDtcclxuICAgICAgaWYgKHggPCB0MSkgY29sTC5wdXNoKGMpO1xyXG4gICAgICBlbHNlIGlmICh4IDwgdDIpIGNvbEMucHVzaChjKTtcclxuICAgICAgZWxzZSBjb2xSLnB1c2goYyk7XHJcbiAgICB9XHJcblxuICAgIHZhciBsb29rc1RocmVlID1cbiAgICAgIChjb2xMLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyAmJiBjb2xDLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyAmJiBjb2xSLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyk7XG4gICAgdmFyIHRleHRDb2xzVGhyZWUgPVxuICAgICAgKGNvbHVtbkhhc1RleHQoY29sTCkgPyAxIDogMCkgK1xuICAgICAgKGNvbHVtbkhhc1RleHQoY29sQykgPyAxIDogMCkgK1xuICAgICAgKGNvbHVtbkhhc1RleHQoY29sUikgPyAxIDogMCk7XG4gICAgdmFyIGhhc1RleHRTaWduYWxUaHJlZSA9IHRleHRDb2xzVGhyZWUgPj0gMjtcbiAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTpjYW5kaWRhdGVzXCIsIHtcbiAgICAgIHJvb3RXOiByb290VyxcbiAgICAgIHRvdGFsOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICBjb2xMOiBjb2xMLmxlbmd0aCxcbiAgICAgIGNvbEM6IGNvbEMubGVuZ3RoLFxuICAgICAgY29sUjogY29sUi5sZW5ndGgsXG4gICAgICBtaW5QZXJDb2wzOiBDRkcuTUlOX1BFUl9DT0xfMyxcbiAgICAgIHRleHRDb2xzVGhyZWU6IHRleHRDb2xzVGhyZWUsXG4gICAgICBoYXNUZXh0U2lnbmFsVGhyZWU6IGhhc1RleHRTaWduYWxUaHJlZVxuICAgIH0pO1xuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIHZhciBjeHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGo9MDtqPGNsdXN0ZXJzLmxlbmd0aDtqKyspIGN4cy5wdXNoKGNsdXN0ZXJzW2pdLmN4KTtcclxuICAgICAgY3hzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XHJcbiAgICAgIHZhciBwMjAgPSBwZXJjZW50aWxlKGN4cywgMC4yMCk7XG4gICAgICB2YXIgcDgwID0gcGVyY2VudGlsZShjeHMsIDAuODApO1xuICAgICAgdmFyIHNwcmVhZCA9IChwODAgLSBwMjApO1xuICAgICAgbXNsTG9nKFwib3JkZXI6dGhyZWU6c3ByZWFkXCIsIHtcbiAgICAgICAgcDIwOiBwMjAsXG4gICAgICAgIHA4MDogcDgwLFxuICAgICAgICBzcHJlYWQ6IHNwcmVhZCxcbiAgICAgICAgbWluU3ByZWFkOiByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPLFxuICAgICAgICBwYXNzOiBzcHJlYWQgPj0gcm9vdFcgKiBDRkcuVEhSRUVfQ09MX1NQUkVBRF9SQVRJT1xuICAgICAgfSk7XG4gICAgICBpZiAoc3ByZWFkIDwgcm9vdFcgKiBDRkcuVEhSRUVfQ09MX1NQUkVBRF9SQVRJTykgbG9va3NUaHJlZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1RocmVlKSB7XG4gICAgICB2YXIgaW52YWRlVDEgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgdDEpO1xuICAgICAgdmFyIGludmFkZVQyID0gZGl2aWRlckludmFzaW9uUmF0aW8oY2x1c3RlcnMsIHQyKTtcbiAgICAgIHZhciBpbnZhZGVUaHJlZSA9IE1hdGgubWF4KGludmFkZVQxLCBpbnZhZGVUMik7XG4gICAgICB2YXIgaW52YXNpb25MaW1pdFRocmVlID0gaGFzVGV4dFNpZ25hbFRocmVlID8gMC40NiA6IDAuMzQ7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTppbnZhc2lvblwiLCB7XG4gICAgICAgIHQxOiArdDEudG9GaXhlZCgxKSxcbiAgICAgICAgdDI6ICt0Mi50b0ZpeGVkKDEpLFxuICAgICAgICBpbnZhZGVUMTogK2ludmFkZVQxLnRvRml4ZWQoMyksXG4gICAgICAgIGludmFkZVQyOiAraW52YWRlVDIudG9GaXhlZCgzKSxcbiAgICAgICAgaW52YWRlVGhyZWU6ICtpbnZhZGVUaHJlZS50b0ZpeGVkKDMpLFxuICAgICAgICBsaW1pdDogK2ludmFzaW9uTGltaXRUaHJlZS50b0ZpeGVkKDMpLFxuICAgICAgICBoYXNUZXh0U2lnbmFsVGhyZWU6IGhhc1RleHRTaWduYWxUaHJlZSxcbiAgICAgICAgcGFzczogaW52YWRlVGhyZWUgPD0gaW52YXNpb25MaW1pdFRocmVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhZGVUaHJlZSA+IGludmFzaW9uTGltaXRUaHJlZSkgbG9va3NUaHJlZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1RocmVlKSB7XG4gICAgICBjb2xMLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgY29sQy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcbiAgICAgIGNvbFIuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcbiAgICAgIHJldHVybiB7IGdyb3VwczogW2NvbEwsIGNvbEMsIGNvbFJdLCBtb2RlOiBcInRocmVlXCIgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLSAxKSBJbnRlbnRhciAyIGNvbHVtbmFzIGNsYXJhcyAtLS0tLS0tLVxuICAgIHZhciBtaWQgPSByb290VyAvIDI7XHJcbiAgICB2YXIgbGVmdCA9IFtdO1xyXG4gICAgdmFyIHJpZ2h0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaz0wO2s8Y2x1c3RlcnMubGVuZ3RoO2srKyl7XG4gICAgICB2YXIgYzIgPSBjbHVzdGVyc1trXTtcbiAgICAgIGlmIChjMi5jeCA8IG1pZCkgbGVmdC5wdXNoKGMyKTtcbiAgICAgIGVsc2UgcmlnaHQucHVzaChjMik7XG4gICAgfVxuXG4gICAgdmFyIGxvb2tzVHdvID0gKGxlZnQubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8yICYmIHJpZ2h0Lmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMik7XG4gICAgdmFyIGhhc1RleHRTaWduYWxUd28gPSBjb2x1bW5IYXNUZXh0KGxlZnQpICYmIGNvbHVtbkhhc1RleHQocmlnaHQpO1xuICAgIG1zbExvZyhcIm9yZGVyOnR3bzpjYW5kaWRhdGVzXCIsIHtcbiAgICAgIHJvb3RXOiByb290VyxcbiAgICAgIHRvdGFsOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICBsZWZ0OiBsZWZ0Lmxlbmd0aCxcbiAgICAgIHJpZ2h0OiByaWdodC5sZW5ndGgsXG4gICAgICBtaW5QZXJDb2wyOiBDRkcuTUlOX1BFUl9DT0xfMixcbiAgICAgIGhhc1RleHRTaWduYWxUd286IGhhc1RleHRTaWduYWxUd29cbiAgICB9KTtcblxuICAgIC8vIFBvbGl0aWNhIHBhcmEgcGFyZXMgKDIgY2x1c3RlcnMpOlxuICAgIC8vIC0gcGFyIGRlIGNvbHVtbmFzIHJlYWxlcyA9PiBtb2RlIFwidHdvXCJcbiAgICAvLyAtIHJlc3RvIGRlIGNhc29zID0+IG1vZGUgXCJvbmVcIiAoZml0Q2hlY2sgZGVjaWRlIHNpIHJlZmxvd2VhKVxyXG4gICAgaWYgKGNsdXN0ZXJzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICB2YXIgY0EgPSBjbHVzdGVyc1swXTtcclxuICAgICAgdmFyIGNCID0gY2x1c3RlcnNbMV07XHJcblxyXG4gICAgICBmdW5jdGlvbiBwYWlyU3RhdHMoYyl7XHJcbiAgICAgICAgdmFyIHRleHQgPSAwO1xyXG4gICAgICAgIHZhciBub24gPSAwO1xyXG4gICAgICAgIHZhciBmb3JjZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgcT0wOyBxPGMuaXRlbXMubGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgIHZhciBuID0gYy5pdGVtc1txXS5ub2RlO1xyXG4gICAgICAgICAgaWYgKChuLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNlbnRlclwiKSB8fCBcIlwiKSA9PT0gXCJmb3JjZVwiKSBmb3JjZSsrO1xyXG4gICAgICAgICAgaWYgKChuLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSB0ZXh0Kys7XHJcbiAgICAgICAgICBlbHNlIG5vbisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0ZXh0OiB0ZXh0LCBub246IG5vbiwgZm9yY2U6IGZvcmNlIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzQSA9IHBhaXJTdGF0cyhjQSk7XHJcbiAgICAgIHZhciBzQiA9IHBhaXJTdGF0cyhjQik7XHJcblxyXG4gICAgICB2YXIgdG9wRGVsdGEgPSBNYXRoLmFicygoY0EudG9wIHx8IDApIC0gKGNCLnRvcCB8fCAwKSk7XG4gICAgICB2YXIgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigoY0EubGVmdCArIGNBLndpZHRoKSwgKGNCLmxlZnQgKyBjQi53aWR0aCkpIC0gTWF0aC5tYXgoY0EubGVmdCwgY0IubGVmdCkpO1xuICAgICAgdmFyIG1pbldQYWlyID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oKGNBLndpZHRoIHx8IDApLCAoY0Iud2lkdGggfHwgMCkpKTtcbiAgICAgIHZhciB4T3ZlcmxhcFJhdGlvID0geE92ZXJsYXAgLyBtaW5XUGFpcjtcbiAgICAgIHZhciBzaWRlQnlTaWRlID0gdG9wRGVsdGEgPD0gKENGRy5ST1dfVE9MICogMS41KSAmJiB4T3ZlcmxhcFJhdGlvIDwgMC4yNTtcbiAgICAgIHZhciBwYWlySW52YXNpb24gPSBkaXZpZGVySW52YXNpb25SYXRpbyhbY0EsIGNCXSwgbWlkKTtcbiAgICAgIHZhciBwYWlySW52YXNpb25MaW1pdCA9IGhhc1RleHRTaWduYWxUd28gPyAwLjUgOiAwLjM0O1xuXG4gICAgICB2YXIgYW55Rm9yY2VDZW50ZXIgPSAoc0EuZm9yY2UgPiAwIHx8IHNCLmZvcmNlID4gMCk7XG4gICAgICB2YXIgYm90aE1peGVkID0gKHNBLnRleHQgPiAwICYmIHNBLm5vbiA+IDAgJiYgc0IudGV4dCA+IDAgJiYgc0Iubm9uID4gMCk7XG4gICAgICAvLyBTZcOxYWwgcm9idXN0YSBkZSBcInBhciBkZSBjb2x1bW5hc1wiOlxuICAgICAgLy8gLSBlc3TDoW4gbGFkbyBhIGxhZG8geSBwYXNhbiBzcGxpdCBsZWZ0L3JpZ2h0XG4gICAgICAvLyAtIHkgYWRlbcOhcyBubyBzb24gc2ltcGxlbWVudGUgMiB0ZXh0b3Mgc3VlbHRvcyBlbiB1bmEgZmlsYVxuICAgICAgdmFyIGhhc0NvbHVtblNpZ25hbCA9XG4gICAgICAgIChzQS5ub24gPiAwIHx8IHNCLm5vbiA+IDApIHx8XG4gICAgICAgICgoY0EuaXRlbXMgJiYgY0EuaXRlbXMubGVuZ3RoID4gMSkgfHwgKGNCLml0ZW1zICYmIGNCLml0ZW1zLmxlbmd0aCA+IDEpKTtcblxuICAgICAgaWYgKGxvb2tzVHdvICYmIHNpZGVCeVNpZGUgJiYgaGFzQ29sdW1uU2lnbmFsICYmIHBhaXJJbnZhc2lvbiA8PSBwYWlySW52YXNpb25MaW1pdCkge1xuICAgICAgICB2YXIgbGVmdFBhaXIgPSAoY0EuY3ggPD0gY0IuY3gpID8gW2NBXSA6IFtjQl07XG4gICAgICAgIHZhciByaWdodFBhaXIgPSAoY0EuY3ggPD0gY0IuY3gpID8gW2NCXSA6IFtjQV07XG4gICAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzpwYWlyUG9saWN5XCIsIHtcbiAgICAgICAgICBtb2RlOiBcInR3b1wiLFxuICAgICAgICAgIHJlYXNvbjogXCJwYWlyQ29sdW1uc1wiLFxuICAgICAgICAgIHRvcERlbHRhOiArdG9wRGVsdGEudG9GaXhlZCgxKSxcbiAgICAgICAgICB4T3ZlcmxhcFJhdGlvOiAreE92ZXJsYXBSYXRpby50b0ZpeGVkKDMpLFxuICAgICAgICAgIGhhc0NvbHVtblNpZ25hbDogaGFzQ29sdW1uU2lnbmFsLFxuICAgICAgICAgIGJvdGhNaXhlZDogYm90aE1peGVkLFxuICAgICAgICAgIGFueUZvcmNlQ2VudGVyOiBhbnlGb3JjZUNlbnRlcixcbiAgICAgICAgICBwYWlySW52YXNpb246ICtwYWlySW52YXNpb24udG9GaXhlZCgzKSxcbiAgICAgICAgICBwYWlySW52YXNpb25MaW1pdDogK3BhaXJJbnZhc2lvbkxpbWl0LnRvRml4ZWQoMyksXG4gICAgICAgICAgbGVmdHM6IFsrKGNBLmxlZnQgfHwgMCkudG9GaXhlZCgxKSwgKyhjQi5sZWZ0IHx8IDApLnRvRml4ZWQoMSldXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBncm91cHM6IFtsZWZ0UGFpciwgcmlnaHRQYWlyXSwgbW9kZTogXCJ0d29cIiB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFpciA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhhLnRvcCAtIGIudG9wKSA+IDAuNSkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgfSk7XHJcbiAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzpwYWlyUG9saWN5XCIsIHtcclxuICAgICAgICBtb2RlOiBcIm9uZVwiLFxyXG4gICAgICAgIHJlYXNvbjogYW55Rm9yY2VDZW50ZXIgPyBcImZvcmNlQ2VudGVyUGFpclwiIDogXCJwYWlyRGVmYXVsdFwiLFxyXG4gICAgICAgIHRvcERlbHRhOiArdG9wRGVsdGEudG9GaXhlZCgxKSxcclxuICAgICAgICB4T3ZlcmxhcFJhdGlvOiAreE92ZXJsYXBSYXRpby50b0ZpeGVkKDMpLFxuICAgICAgICBzaWRlQnlTaWRlOiBzaWRlQnlTaWRlLFxuICAgICAgICBib3RoTWl4ZWQ6IGJvdGhNaXhlZCxcbiAgICAgICAgYW55Rm9yY2VDZW50ZXI6IGFueUZvcmNlQ2VudGVyLFxuICAgICAgICBwYWlySW52YXNpb246ICtwYWlySW52YXNpb24udG9GaXhlZCgzKSxcbiAgICAgICAgcGFpckludmFzaW9uTGltaXQ6ICtwYWlySW52YXNpb25MaW1pdC50b0ZpeGVkKDMpLFxuICAgICAgICB0b3BzOiBwYWlyLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLnRvcC50b0ZpeGVkKDEpOyB9KSxcbiAgICAgICAgbGVmdHM6IHBhaXIubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MubGVmdC50b0ZpeGVkKDEpOyB9KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtwYWlyXSwgbW9kZTogXCJvbmVcIiB9O1xuICAgIH1cclxuICAgIGlmIChsb29rc1R3bykge1xyXG4gICAgICB2YXIgY3hzMiA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBtPTA7bTxjbHVzdGVycy5sZW5ndGg7bSsrKSBjeHMyLnB1c2goY2x1c3RlcnNbbV0uY3gpO1xyXG4gICAgICBjeHMyLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XHJcbiAgICAgIHZhciBwMjUgPSBwZXJjZW50aWxlKGN4czIsIDAuMjUpO1xuICAgICAgdmFyIHA3NSA9IHBlcmNlbnRpbGUoY3hzMiwgMC43NSk7XG4gICAgICB2YXIgc3ByZWFkMiA9IChwNzUgLSBwMjUpO1xuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnNwcmVhZFwiLCB7XG4gICAgICAgIHAyNTogcDI1LFxuICAgICAgICBwNzU6IHA3NSxcbiAgICAgICAgc3ByZWFkOiBzcHJlYWQyLFxuICAgICAgICBtaW5TcHJlYWQ6IHJvb3RXICogQ0ZHLlRXT19DT0xfU1BSRUFEX1JBVElPLFxuICAgICAgICBwYXNzOiBzcHJlYWQyID49IHJvb3RXICogQ0ZHLlRXT19DT0xfU1BSRUFEX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmIChzcHJlYWQyIDwgcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU8pIGxvb2tzVHdvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVHdvKSB7XG4gICAgICB2YXIgaW52YWRlTWlkID0gZGl2aWRlckludmFzaW9uUmF0aW8oY2x1c3RlcnMsIG1pZCk7XG4gICAgICB2YXIgaW52YXNpb25MaW1pdFR3byA9IGhhc1RleHRTaWduYWxUd28gPyAwLjQ4IDogMC4zNDtcbiAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzppbnZhc2lvblwiLCB7XG4gICAgICAgIG1pZDogK21pZC50b0ZpeGVkKDEpLFxuICAgICAgICBpbnZhZGVNaWQ6ICtpbnZhZGVNaWQudG9GaXhlZCgzKSxcbiAgICAgICAgbGltaXQ6ICtpbnZhc2lvbkxpbWl0VHdvLnRvRml4ZWQoMyksXG4gICAgICAgIGhhc1RleHRTaWduYWxUd286IGhhc1RleHRTaWduYWxUd28sXG4gICAgICAgIHBhc3M6IGludmFkZU1pZCA8PSBpbnZhc2lvbkxpbWl0VHdvXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhZGVNaWQgPiBpbnZhc2lvbkxpbWl0VHdvKSBsb29rc1R3byA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1R3bykge1xuICAgICAgbGVmdC5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcbiAgICAgIHJpZ2h0LnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbbGVmdCwgcmlnaHRdLCBtb2RlOiBcInR3b1wiIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMikgR3VhcmQgdGFyZGlvOiB1bmEgc29sYSBjb2x1bW5hIHZpc3VhbCAtLS0tLS0tLVxuICAgIC8vIFNlIGV2YWx1YSBkZXNwdWVzIGRlIHR3by90aHJlZSBwYXJhIGV2aXRhciBmYWxzb3MgXCJvbmVcIiBjdWFuZG8gaGF5XG4gICAgLy8gZG9zIGNvbHVtbmFzIHJlYWxlcyBjb24gdmFyaW9zIGNsdXN0ZXJzLlxuICAgIGlmIChjbHVzdGVycy5sZW5ndGggPj0gMikge1xuICAgICAgdmFyIGN4c09uZSA9IGNsdXN0ZXJzLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuIGMuY3g7IH0pLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XG4gICAgICB2YXIgbWVkaWFuQ3ggPSBwZXJjZW50aWxlKGN4c09uZSwgMC41MCk7XG4gICAgICB2YXIgbWF4RGV2Q3ggPSAwO1xuICAgICAgZm9yICh2YXIgcz0wOyBzPGNsdXN0ZXJzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHZhciBkZXYgPSBNYXRoLmFicygoY2x1c3RlcnNbc10uY3ggfHwgMCkgLSBtZWRpYW5DeCk7XG4gICAgICAgIGlmIChkZXYgPiBtYXhEZXZDeCkgbWF4RGV2Q3ggPSBkZXY7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW5nbGVDb2xNYXhEZXYgPSByb290VyAqIDAuMTg7XG4gICAgICB2YXIgbG9va3NPbmVDb2wgPSBtYXhEZXZDeCA8PSBzaW5nbGVDb2xNYXhEZXY7XG4gICAgICBtc2xMb2coXCJvcmRlcjpvbmU6Y2FuZGlkYXRlc1wiLCB7XG4gICAgICAgIHJvb3RXOiByb290VyxcbiAgICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgbWVkaWFuQ3g6ICttZWRpYW5DeC50b0ZpeGVkKDEpLFxuICAgICAgICBtYXhEZXZDeDogK21heERldkN4LnRvRml4ZWQoMSksXG4gICAgICAgIG1heEFsbG93ZWQ6ICtzaW5nbGVDb2xNYXhEZXYudG9GaXhlZCgxKSxcbiAgICAgICAgcGFzczogbG9va3NPbmVDb2wsXG4gICAgICAgIHN0YWdlOiBcInBvc3RUd29UaHJlZVwiXG4gICAgICB9KTtcblxuICAgICAgaWYgKGxvb2tzT25lQ29sKSB7XG4gICAgICAgIHZhciBvbmVDb2wgPSBjbHVzdGVycy5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgICByZXR1cm4geyBncm91cHM6IFtvbmVDb2xdLCBtb2RlOiBcIm9uZVwiIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMykgRmFsbGJhY2s6IGZpbGFzICh0b3ApIHkgZGVudHJvIHBvciBsZWZ0IC0tLS0tLS0tXG4gICAgdmFyIHNvcnRlZCA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcblxyXG4gICAgdmFyIHJvd3MgPSBbXTtcclxuICAgIGZvciAodmFyIHI9MDtyPHNvcnRlZC5sZW5ndGg7cisrKXtcclxuICAgICAgdmFyIGMzID0gc29ydGVkW3JdO1xyXG4gICAgICB2YXIgcGxhY2VkID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBycj0wOyBycjxyb3dzLmxlbmd0aDsgcnIrKyl7XHJcbiAgICAgICAgdmFyIHJvdyA9IHJvd3NbcnJdO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhjMy50b3AgLSByb3cudG9wKSA8PSBDRkcuUk9XX1RPTCl7XHJcbiAgICAgICAgICByb3cuaXRlbXMucHVzaChjMyk7XHJcbiAgICAgICAgICByb3cudG9wID0gKHJvdy50b3AgKiAocm93Lml0ZW1zLmxlbmd0aCAtIDEpICsgYzMudG9wKSAvIHJvdy5pdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBsYWNlZCkgcm93cy5wdXNoKHsgdG9wOiBjMy50b3AsIGl0ZW1zOiBbYzNdIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJvd3Muc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KXtcclxuICAgICAgcm93Lml0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEubGVmdCAtIGIubGVmdDsgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbHVzdGVySXNUZXh0KGMpe1xuICAgICAgaWYgKCFjIHx8ICFjLml0ZW1zIHx8ICFjLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaTI9MDsgaTI8Yy5pdGVtcy5sZW5ndGg7IGkyKyspe1xuICAgICAgICBpZiAoKGMuaXRlbXNbaTJdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgZGlkSW50ZXJsZWF2ZSA9IGZhbHNlO1xuICAgIC8vIENhc28gZXNwZWNpYWw6IGRvcyBmaWxhcyBzaW1ldHJpY2FzIChlai4gaWNvbm9zIGFycmliYSB5IHRleHRvcyBhYmFqbykuXG4gICAgLy8gUmVvcmRlbmFtb3MgcG9yIGNvbHVtbmE6IHRvcDEsYm90dG9tMSx0b3AyLGJvdHRvbTIsLi4uXG4gICAgaWYgKHJvd3MubGVuZ3RoID09PSAyICYmIHJvd3NbMF0uaXRlbXMubGVuZ3RoID09PSByb3dzWzFdLml0ZW1zLmxlbmd0aCAmJiByb3dzWzBdLml0ZW1zLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgdG9wUm93ID0gcm93c1swXS5pdGVtcy5zbGljZSgpO1xuICAgICAgdmFyIGJvdFJvdyA9IHJvd3NbMV0uaXRlbXMuc2xpY2UoKTtcbiAgICAgIHZhciB0b3BIYXNOb25UZXh0ID0gdG9wUm93LnNvbWUoZnVuY3Rpb24oYyl7IHJldHVybiAhY2x1c3RlcklzVGV4dChjKTsgfSk7XG4gICAgICB2YXIgYm90TW9zdGx5VGV4dCA9IGJvdFJvdy5maWx0ZXIoZnVuY3Rpb24oYyl7IHJldHVybiBjbHVzdGVySXNUZXh0KGMpOyB9KS5sZW5ndGggPj0gTWF0aC5jZWlsKGJvdFJvdy5sZW5ndGggLyAyKTtcblxuICAgICAgaWYgKHRvcEhhc05vblRleHQgJiYgYm90TW9zdGx5VGV4dCkge1xuICAgICAgICB2YXIgdXNlZEJvdHRvbSA9IHt9O1xuICAgICAgICBmb3IgKHZhciB0cj0wOyB0cjx0b3BSb3cubGVuZ3RoOyB0cisrKXtcbiAgICAgICAgICB2YXIgYSA9IHRvcFJvd1t0cl07XG4gICAgICAgICAgb3V0LnB1c2goYSk7XG5cbiAgICAgICAgICB2YXIgYmVzdElkeCA9IC0xO1xuICAgICAgICAgIHZhciBiZXN0RGlzdCA9IEluZmluaXR5O1xuICAgICAgICAgIGZvciAodmFyIGJyPTA7IGJyPGJvdFJvdy5sZW5ndGg7IGJyKyspe1xuICAgICAgICAgICAgaWYgKHVzZWRCb3R0b21bYnJdKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBiID0gYm90Um93W2JyXTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5hYnMoKGEubGVmdCB8fCAwKSAtIChiLmxlZnQgfHwgMCkpO1xuICAgICAgICAgICAgaWYgKGQgPCBiZXN0RGlzdCkge1xuICAgICAgICAgICAgICBiZXN0RGlzdCA9IGQ7XG4gICAgICAgICAgICAgIGJlc3RJZHggPSBicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJlc3RJZHggPj0gMCkge1xuICAgICAgICAgICAgb3V0LnB1c2goYm90Um93W2Jlc3RJZHhdKTtcbiAgICAgICAgICAgIHVzZWRCb3R0b21bYmVzdElkeF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBicjI9MDsgYnIyPGJvdFJvdy5sZW5ndGg7IGJyMisrKXtcbiAgICAgICAgICBpZiAoIXVzZWRCb3R0b21bYnIyXSkgb3V0LnB1c2goYm90Um93W2JyMl0pO1xuICAgICAgICB9XG4gICAgICAgIGRpZEludGVybGVhdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGlkSW50ZXJsZWF2ZSkge1xuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdyl7XG4gICAgICAgIGZvciAodmFyIHo9MDsgejxyb3cuaXRlbXMubGVuZ3RoOyB6KyspIG91dC5wdXNoKHJvdy5pdGVtc1t6XSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbXNsTG9nKFwib3JkZXI6cm93czpmYWxsYmFja1wiLCB7XG4gICAgICByb3dzOiByb3dzLm1hcChmdW5jdGlvbihyKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICtyLnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGxlbjogci5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgbGVmdHM6IHIuaXRlbXMubWFwKGZ1bmN0aW9uKGl0KXsgcmV0dXJuICtpdC5sZWZ0LnRvRml4ZWQoMSk7IH0pXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG91dExlbjogb3V0Lmxlbmd0aCxcbiAgICAgIGRpZEludGVybGVhdmU6IGRpZEludGVybGVhdmVcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGdyb3VwczogW291dF0sIG1vZGU6IFwicm93c1wiIH07XG4gIH1cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzT3JkZXJpbmdCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts":
/*!*****************************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/scriptTemplate.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* binding */ buildScript)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts\");\n/* harmony import */ var _fitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitScale */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts\");\n/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordering */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts\");\n/* harmony import */ var _stacking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacking */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts\");\n// functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n\n\n\n\nfunction buildScript(cfg) {\n    if (!cfg.enabled) return \"\";\n    return `\n<script>\n(function(){\n  var ENABLED = true;\n  function readDebugFlag(name){\n    try {\n      var search = (window.location && window.location.search) ? window.location.search : \"\";\n      var qp = new URLSearchParams(search);\n      var qv = qp.get(name);\n      if (qv === \"1\" || String(qv).toLowerCase() === \"true\") return true;\n    } catch(_e1) {}\n\n    // srcDoc/about:srcdoc no suele tener querystring.\n    try {\n      if (window.parent && window.parent !== window && window.parent.location) {\n        var pSearch = window.parent.location.search || \"\";\n        var pQ = new URLSearchParams(pSearch);\n        var pV = pQ.get(name);\n        if (pV === \"1\" || String(pV).toLowerCase() === \"true\") return true;\n      }\n    } catch(_e2) {}\n\n    try {\n      if (window.top && window.top !== window && window.top.location) {\n        var tSearch = window.top.location.search || \"\";\n        var tQ = new URLSearchParams(tSearch);\n        var tV = tQ.get(name);\n        if (tV === \"1\" || String(tV).toLowerCase() === \"true\") return true;\n      }\n    } catch(_e3) {}\n\n    try {\n      var ls = window.localStorage ? window.localStorage.getItem(name) : null;\n      if (ls === \"1\" || String(ls).toLowerCase() === \"true\") return true;\n    } catch(_e4) {}\n\n    return false;\n  }\n  var MSL_DEBUG = readDebugFlag(\"mslDebug\");\n  var MSL_VERBOSE = readDebugFlag(\"mslVerbose\");\n  function dbg(label, payload){\n    if (!MSL_DEBUG) return;\n    if (arguments.length <= 1) {\n      console.log(\"[MSL] \" + label);\n      return;\n    }\n    if (typeof payload === \"string\") {\n      console.log(\"[MSL] \" + label + \" \" + payload);\n      return;\n    }\n    var pretty = \"\";\n    try {\n      pretty = JSON.stringify(payload, null, 2);\n    } catch(e) {\n      try { pretty = String(payload); } catch(_) { pretty = \"[unserializable]\"; }\n    }\n    console.log(\"[MSL] \" + label + \"\\\\n\" + pretty);\n  }\n  function mslLog(){\n    if (!MSL_DEBUG) return;\n    var args = Array.prototype.slice.call(arguments);\n    if (!args.length) return;\n    var label = String(args[0]);\n    if (!MSL_VERBOSE) {\n      var noisy = {\n        \"section:nodeSources\": 1,\n        \"section:baselineRestore\": 1,\n        \"section:anchorSplit\": 1,\n        \"section:clusters\": 1,\n        \"order:three:candidates\": 1,\n        \"order:three:spread\": 1,\n        \"order:two:candidates\": 1,\n        \"order:two:spread\": 1,\n        \"order:one:candidates\": 1,\n        \"order:rows:fallback\": 1\n      };\n      if (noisy[label]) return;\n    }\n    if (args.length === 1) {\n      dbg(label);\n      return;\n    }\n    if (args.length === 2) {\n      dbg(label, args[1]);\n      return;\n    }\n    dbg(label, args.slice(1));\n  }\n\n  var CFG = {\n    MIN_GAP: ${cfg.minGapPx},\n    MAX_GAP: ${cfg.maxGapPx},\n    GAP_SCALE: ${cfg.gapScale},\n\n    PAD_TOP: ${cfg.paddingTopPx},\n    PAD_BOT: ${cfg.paddingBottomPx},\n\n    ONLY_FIXED: ${cfg.onlyFixedSections ? \"true\" : \"false\"},\n    ONLY_WHEN_REORDERED: ${cfg.onlyWhenReordered ? \"true\" : \"false\"},\n\n    ROW_TOL: ${cfg.rowTolPx},\n\n    TWO_COL_SPREAD_RATIO: ${cfg.twoColSpreadRatio},\n    MIN_PER_COL_2: ${cfg.minPerColumn2},\n\n    THREE_COL_SPREAD_RATIO: ${cfg.threeColSpreadRatio},\n    MIN_PER_COL_3: ${cfg.minPerColumn3},\n\n    FIT_MIN_SCALE: ${cfg.fitMinScale},\n    FIT_MAX_SCALE: ${cfg.fitMaxScale},\n    FIT_TARGET_WIDTH_RATIO: ${cfg.fitTargetWidthRatio},\n    FIT_MIN_FILL_RATIO: ${cfg.fitMinFillRatio}\n  };\n\n  ${(0,_dom__WEBPACK_IMPORTED_MODULE_0__.jsDomHelpersBlock)()}\n\n  ${(0,_ordering__WEBPACK_IMPORTED_MODULE_2__.jsOrderingBlock)()}\n\n  ${(0,_stacking__WEBPACK_IMPORTED_MODULE_3__.jsStackingBlock)()}\n\n  ${(0,_fitScale__WEBPACK_IMPORTED_MODULE_1__.jsFitScaleBlock)()}\n\n  function expandFixedSection(sec, neededHeight){\n    var currentH = sec.getBoundingClientRect().height || 0;\n    if (neededHeight > currentH + 1) {\n      sec.style.height = Math.ceil(neededHeight) + \"px\";\n      return true;\n    }\n    return false;\n  }\n\n  function shouldProcessSection(sec){\n    if(!sec) return false;\n    if(!CFG.ONLY_FIXED) return true;\n    var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n    return modo === \"fijo\";\n  }\n\n  function restoreNodeBaseline(node){\n    if (!node) return 0;\n    var restored = 0;\n\n    if (!node.hasAttribute(\"data-msl-orig-top\")) {\n      node.setAttribute(\"data-msl-orig-top\", node.style.top || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-left\")) {\n      node.setAttribute(\"data-msl-orig-left\", node.style.left || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-transform\")) {\n      node.setAttribute(\"data-msl-orig-transform\", node.style.transform || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-text-align\")) {\n      node.setAttribute(\"data-msl-orig-text-align\", node.style.textAlign || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-transform-origin\")) {\n      node.setAttribute(\"data-msl-orig-transform-origin\", node.style.transformOrigin || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-text-zoom\")) {\n      node.setAttribute(\"data-msl-orig-text-zoom\", node.style.getPropertyValue(\"--text-zoom\") || \"\");\n    }\n\n    var origTop = node.getAttribute(\"data-msl-orig-top\");\n    var origLeft = node.getAttribute(\"data-msl-orig-left\");\n    var origTransform = node.getAttribute(\"data-msl-orig-transform\");\n    var origTextAlign = node.getAttribute(\"data-msl-orig-text-align\");\n    var origTransformOrigin = node.getAttribute(\"data-msl-orig-transform-origin\");\n    var origTextZoom = node.getAttribute(\"data-msl-orig-text-zoom\");\n\n    if (origTop != null && node.style.top !== origTop) {\n      node.style.top = origTop;\n      restored++;\n    }\n    if (origLeft != null && node.style.left !== origLeft) {\n      node.style.left = origLeft;\n      restored++;\n    }\n    if (origTransform != null && node.style.transform !== origTransform) {\n      node.style.transform = origTransform;\n      restored++;\n    }\n    if (origTextAlign != null && node.style.textAlign !== origTextAlign) {\n      if (origTextAlign) node.style.textAlign = origTextAlign;\n      else node.style.removeProperty(\"text-align\");\n      restored++;\n    }\n    if (origTransformOrigin != null && node.style.transformOrigin !== origTransformOrigin) {\n      if (origTransformOrigin) node.style.transformOrigin = origTransformOrigin;\n      else node.style.removeProperty(\"transform-origin\");\n      restored++;\n    }\n    if (origTextZoom != null) {\n      var currentTextZoom = node.style.getPropertyValue(\"--text-zoom\") || \"\";\n      if (currentTextZoom !== origTextZoom) {\n        if (origTextZoom) node.style.setProperty(\"--text-zoom\", origTextZoom);\n        else node.style.removeProperty(\"--text-zoom\");\n        restored++;\n      }\n    }\n\n    node.style.right = \"auto\";\n    node.style.marginLeft = \"0px\";\n    return restored;\n  }\n\n  function runOnce(){\n    if(!ENABLED) return;\n    if(!isMobile()) {\n      Array.from(document.querySelectorAll(\".sec\")).forEach(function(sec){\n        var content = sec.querySelector(\".sec-content\");\n        if(!content) return;\n        var bleed = sec.querySelector(\".sec-bleed\");\n        resetSectionFitScale(sec, content, bleed);\n        var nodesAllDesktop = getObjNodes(sec);\n        for (var nd=0; nd<nodesAllDesktop.length; nd++) {\n          restoreNodeBaseline(nodesAllDesktop[nd]);\n        }\n        sec.setAttribute(\"data-msl-fit-scale\", \"1\");\n      });\n      return;\n    }\n\n    var secs = Array.from(document.querySelectorAll(\".sec\"));\n    if(!secs.length) return;\n\n    secs.forEach(function(sec){\n      var secIndex = secs.indexOf(sec);\n      var secModo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n      var allowReflow = shouldProcessSection(sec);\n      mslLog(\"section:start\", { secIndex: secIndex, modo: secModo, allowReflow: allowReflow });\n\n      var content = sec.querySelector(\".sec-content\");\n      if(!content) return;\n      var bleed = sec.querySelector(\".sec-bleed\");\n      resetSectionFitScale(sec, content, bleed);\n      var nodesAll = getObjNodes(sec);\n\n      var reflowElementsDump = [];\n      function buildReflowElementsDump(items, contentWNow){\n        if (!MSL_DEBUG) return;\n        var list = (items || []);\n        var maxItems = 120;\n        var out = [];\n        for (var iDump=0; iDump<list.length && iDump<maxItems; iDump++){\n          var itDump = list[iDump];\n          if (!itDump || !itDump.node) continue;\n          var nDump = itDump.node;\n          var textRaw = ((nDump.textContent || \"\").trim()).replace(/\\s+/g, \" \");\n          var isTextDump = (nDump.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          var clsDump = (nDump.className && typeof nDump.className === \"string\") ? nDump.className : \"\";\n          var rootZone = (nDump.closest && nDump.closest(\".sec-bleed\")) ? \"bleed\" : \"content\";\n          out.push({\n            i: iDump,\n            kind: isTextDump ? \"texto\" : String((nDump.tagName || \"\").toLowerCase()),\n            zone: rootZone,\n            top: +Number(itDump.top || 0).toFixed(1),\n            left: +Number(itDump.left || 0).toFixed(1),\n            w: +Number(itDump.width || 0).toFixed(1),\n            h: +Number(itDump.height || 0).toFixed(1),\n            right: +Number((itDump.left || 0) + (itDump.width || 0)).toFixed(1),\n            bottom: +Number((itDump.top || 0) + (itDump.height || 0)).toFixed(1),\n            cx: +Number((itDump.left || 0) + ((itDump.width || 0) / 2)).toFixed(1),\n            wRatio: contentWNow > 1 ? +Number((itDump.width || 0) / contentWNow).toFixed(3) : null,\n            className: clsDump,\n            mobileLayout: nDump.getAttribute(\"data-mobile-layout\") || \"\",\n            mobileRole: nDump.getAttribute(\"data-mobile-role\") || \"\",\n            mobileCluster: nDump.getAttribute(\"data-mobile-cluster\") || \"\",\n            mobileClusterId: nDump.getAttribute(\"data-mobile-cluster-id\") || \"\",\n            mobileCenter: nDump.getAttribute(\"data-mobile-center\") || \"\",\n            mobileAlign: nDump.getAttribute(\"data-mobile-align\") || \"\",\n            mobileFit: nDump.getAttribute(\"data-mobile-fit\") || \"\",\n            textAlign: (nDump.style && nDump.style.textAlign) ? nDump.style.textAlign : \"\",\n            textSample: isTextDump ? textRaw.slice(0, 90) : \"\"\n          });\n        }\n        reflowElementsDump = out;\n      }\n\n      function logReflowDecision(reason, extra){\n        if (!MSL_DEBUG) return;\n        var payload = {\n          secIndex: secIndex,\n          secModo: secModo,\n          allowReflow: allowReflow,\n          totalNodes: (nodesAll || []).length,\n          reason: String(reason || \"\"),\n          details: extra || {}\n        };\n        mslLog(\"section:reflow:decision\", payload);\n      }\n\n      function finalizeSection(minNeededHeight, preserveBottomGap){\n        var gap = Number.isFinite(preserveBottomGap) ? Math.max(0, Number(preserveBottomGap)) : 0;\n        var fit = applySectionFitScale(\n          sec,\n          content,\n          bleed,\n          nodesAll,\n          secModo,\n          CFG,\n          { secIndex: secIndex },\n          { preserveBottomGap: gap }\n        );\n        var fitNeeded = (fit && Number.isFinite(fit.neededHeight)) ? Number(fit.neededHeight) : 0;\n        var neededHeight = Math.max(Number(minNeededHeight || 0), fitNeeded);\n        mslLog(\"section:heightFinal\", {\n          secIndex: secIndex,\n          mode: secModo,\n          minNeededHeight: +Number(minNeededHeight || 0).toFixed(1),\n          fitNeededHeight: +fitNeeded.toFixed(1),\n          preserveBottomGap: +gap.toFixed(1),\n          finalNeededHeight: +neededHeight.toFixed(1)\n        });\n        if (secModo === \"fijo\" && neededHeight > 0) {\n          expandFixedSection(sec, neededHeight);\n        }\n      }\n\n      if(!nodesAll.length) {\n        logReflowDecision(\"skip:noNodes\", { willApplyReflow: false });\n        finalizeSection(0, 0);\n        return;\n      }\n\n      var debugCounts = {\n        secIndex: secIndex,\n        contentObj: content ? content.querySelectorAll(\".objeto\").length : 0,\n        bleedObj: bleed ? bleed.querySelectorAll(\".objeto\").length : 0,\n        contentAbs: content ? Array.from(content.querySelectorAll(\"*\")).filter(function(el){\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\n        }).length : 0,\n        bleedAbs: bleed ? Array.from(bleed.querySelectorAll(\"*\")).filter(function(el){\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\n        }).length : 0\n      };\n      mslLog(\"section:nodeSources\", debugCounts);\n\n      if (MSL_VERBOSE) {\n        mslLog(\"section:nodesAll:raw\", {\n          secIndex: secIndex,\n          total: nodesAll.length,\n          nodes: nodesAll.map(function(n, i){\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\n            var parentCls = (n.parentElement && n.parentElement.className && typeof n.parentElement.className === \"string\")\n              ? n.parentElement.className\n              : \"\";\n            return {\n              i: i,\n              tag: (n.tagName || \"\").toLowerCase(),\n              cls: cls,\n              parentCls: parentCls,\n              top: n.style ? n.style.top : \"\",\n              left: n.style ? n.style.left : \"\",\n              pos: n.style ? n.style.position : \"\",\n              text: ((n.textContent || \"\").trim()).slice(0, 40)\n            };\n          })\n        });\n        try {\n          var flat = nodesAll.map(function(n, i){\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\n            var txt = ((n.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 60);\n            return \"#\" + i\n              + \" tag=\" + String((n.tagName || \"\").toLowerCase())\n              + \" cls=\" + cls\n              + \" pos=\" + (n.style ? n.style.position : \"\")\n              + \" top=\" + (n.style ? n.style.top : \"\")\n              + \" left=\" + (n.style ? n.style.left : \"\")\n              + \" text=\" + txt;\n          });\n          mslLog(\"section:nodesAll:flat\", \"sec=\" + secIndex + \" total=\" + nodesAll.length + \" :: \" + flat.join(\" | \"));\n        } catch(e) {}\n      }\n      var restoredCount = 0;\n      nodesAll.forEach(function(node){\n        restoredCount += restoreNodeBaseline(node);\n      });\n      mslLog(\"section:baselineRestore\", { secIndex: secIndex, nodes: nodesAll.length, restored: restoredCount });\n\n      // Rect del content (métricas reales)\n      var contentRect = content.getBoundingClientRect();\n      var contentW = contentRect.width || 0;\n      var secCurrentH = sec.getBoundingClientRect().height || 0;\n      var baseHeightAttr = \"data-msl-base-height\";\n      if (!sec.hasAttribute(baseHeightAttr)) {\n        sec.setAttribute(baseHeightAttr, String(secCurrentH));\n      }\n      var baseSecHeight = parseFloat(sec.getAttribute(baseHeightAttr) || \"\");\n      if (!isFinite(baseSecHeight) || baseSecHeight <= 0) baseSecHeight = secCurrentH;\n\n      // items (rects) en coordenadas del content (TODOS)\n      var itemsAll = nodesAll.map(function(node){\n        var rc = relRect(node, content);\n        return {\n          node: node,\n          top: rc.top,\n          left: rc.left,\n          height: rc.height,\n          width: rc.width\n        };\n      });\n      buildReflowElementsDump(itemsAll, contentW);\n      mslLog(\"section:reflow:elements\", {\n        secIndex: secIndex,\n        secModo: secModo,\n        contentW: +Number(contentW || 0).toFixed(1),\n        total: reflowElementsDump.length,\n        elements: reflowElementsDump\n      });\n      if (MSL_VERBOSE) {\n        mslLog(\"section:itemsAll\", {\n          secIndex: secIndex,\n          total: itemsAll.length,\n          items: itemsAll.map(function(it, idx){\n            return {\n              i: idx,\n              kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\n              top: +it.top.toFixed(1),\n              left: +it.left.toFixed(1),\n              w: +it.width.toFixed(1),\n              h: +it.height.toFixed(1),\n              textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\n            };\n          })\n        });\n      }\n\n      // Preservar el \"aire\" inferior original de la seccion tras el reflow.\n      var maxOriginalBottom = 0;\n      for (var ib=0; ib<itemsAll.length; ib++){\n        var itb = itemsAll[ib];\n        var btm = (itb.top || 0) + (itb.height || 0);\n        if (btm > maxOriginalBottom) maxOriginalBottom = btm;\n      }\n      var baseBottomGap = Math.max(0, baseSecHeight - maxOriginalBottom);\n\n      // Si todo mide 0 (fonts no listas), reintentamos luego\n      var anyValidAll = itemsAll.some(function(it){ return it.height > 0.5; });\n      if(!anyValidAll) {\n        logReflowDecision(\"skip:invalidRects\", {\n          willApplyReflow: false,\n          allHeightsTiny: true\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      if (!allowReflow || nodesAll.length < 2) {\n        logReflowDecision(\"skip:notEligible\", {\n          willApplyReflow: false,\n          allowReflow: allowReflow,\n          totalNodes: nodesAll.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      function detectHeroLikeCentralText(items, rootW){\n        var out = {\n          isHero: false,\n          reason: \"\",\n          textCount: 0,\n          textColumnCount: 0,\n          textColumns: [],\n          singleTextColumn: false,\n          maxTextWidthRatio: null,\n          widthRatio: null,\n          centerDelta: null,\n          centerTol: null,\n          centeredByAlign: false,\n          centeredByGeometry: false,\n          decorNear: 0,\n          decorLeft: 0,\n          decorRight: 0,\n          decorInvadingTextColumn: 0\n        };\n        if (!items || !items.length || !rootW || rootW <= 0) {\n          out.reason = \"noItemsOrWidth\";\n          return out;\n        }\n\n        var textItems = items.filter(function(it){\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\n          var tw = Number(it.width || 0);\n          var th = Number(it.height || 0);\n          return tw > 2 && th > 2;\n        });\n        out.textCount = textItems.length;\n        if (!textItems.length) {\n          out.reason = \"noText\";\n          return out;\n        }\n\n        var explicitHero = false;\n        for (var eh=0; eh<textItems.length; eh++){\n          var roleEh = (textItems[eh].node.getAttribute(\"data-mobile-role\") || \"\").toLowerCase();\n          if (roleEh === \"hero\") {\n            explicitHero = true;\n            break;\n          }\n        }\n\n        var colTol = Math.max(18, rootW * 0.14);\n        var textCols = [];\n        for (var tc=0; tc<textItems.length; tc++){\n          var txt = textItems[tc];\n          var txtCx = Number(txt.left || 0) + Number(txt.width || 0) / 2;\n          var attached = false;\n          for (var cc=0; cc<textCols.length; cc++){\n            if (Math.abs(txtCx - textCols[cc].cx) <= colTol) {\n              var nCol = textCols[cc].count + 1;\n              textCols[cc].cx = ((textCols[cc].cx * textCols[cc].count) + txtCx) / nCol;\n              textCols[cc].count = nCol;\n              textCols[cc].minLeft = Math.min(textCols[cc].minLeft, Number(txt.left || 0));\n              textCols[cc].maxRight = Math.max(textCols[cc].maxRight, Number(txt.left || 0) + Number(txt.width || 0));\n              textCols[cc].minTop = Math.min(textCols[cc].minTop, Number(txt.top || 0));\n              textCols[cc].maxBottom = Math.max(textCols[cc].maxBottom, Number(txt.top || 0) + Number(txt.height || 0));\n              attached = true;\n              break;\n            }\n          }\n          if (!attached) {\n            textCols.push({\n              cx: txtCx,\n              count: 1,\n              minLeft: Number(txt.left || 0),\n              maxRight: Number(txt.left || 0) + Number(txt.width || 0),\n              minTop: Number(txt.top || 0),\n              maxBottom: Number(txt.top || 0) + Number(txt.height || 0)\n            });\n          }\n        }\n        textCols.sort(function(a,b){ return a.cx - b.cx; });\n        out.textColumnCount = textCols.length;\n        out.singleTextColumn = textCols.length === 1;\n        out.textColumns = textCols.map(function(col){\n          return {\n            cx: +Number(col.cx || 0).toFixed(1),\n            count: col.count,\n            left: +Number(col.minLeft || 0).toFixed(1),\n            right: +Number(col.maxRight || 0).toFixed(1),\n            top: +Number(col.minTop || 0).toFixed(1),\n            bottom: +Number(col.maxBottom || 0).toFixed(1)\n          };\n        });\n        if (!out.singleTextColumn) {\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"multiTextColumns\";\n          out.isHero = explicitHero;\n          return out;\n        }\n\n        var centerX = rootW / 2;\n        var textCol = textCols[0];\n        var textCenterX = Number(textCol.cx || centerX);\n        var centerDelta = Math.abs(textCenterX - centerX);\n        var centerTol = Math.max(18, rootW * 0.12);\n        out.centerDelta = +centerDelta.toFixed(1);\n        out.centerTol = +centerTol.toFixed(1);\n\n        var centeredAlignCount = 0;\n        var maxTextWidthRatio = 0;\n        var textTop = Infinity;\n        var textBottom = -Infinity;\n        for (var tix=0; tix<textItems.length; tix++){\n          var t = textItems[tix];\n          var ta = (t.node && t.node.style && t.node.style.textAlign)\n            ? String(t.node.style.textAlign).toLowerCase()\n            : \"\";\n          if (ta === \"center\") centeredAlignCount++;\n          var wRatio = Number(t.width || 0) / Math.max(1, rootW);\n          if (wRatio > maxTextWidthRatio) maxTextWidthRatio = wRatio;\n          textTop = Math.min(textTop, Number(t.top || 0));\n          textBottom = Math.max(textBottom, Number(t.top || 0) + Number(t.height || 0));\n        }\n        out.maxTextWidthRatio = +maxTextWidthRatio.toFixed(3);\n        out.widthRatio = out.maxTextWidthRatio;\n        out.centeredByAlign = centeredAlignCount >= Math.max(1, Math.ceil(textItems.length * 0.5));\n        out.centeredByGeometry = centerDelta <= centerTol;\n        if (!out.centeredByAlign && !out.centeredByGeometry) {\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"singleTextColumnNotCentered\";\n          out.isHero = explicitHero;\n          return out;\n        }\n\n        // Evita marcar como hero textos sueltos muy chicos.\n        if (textItems.length < 2 && maxTextWidthRatio < 0.28 && !explicitHero) {\n          out.reason = \"textTooSmall\";\n          return out;\n        }\n\n        if (!isFinite(textTop) || !isFinite(textBottom) || textBottom <= textTop) {\n          textTop = 0;\n          textBottom = 0;\n        }\n        var nearTop = textTop - Math.max(28, (textBottom - textTop) * 0.2);\n        var nearBottom = textBottom + Math.max(36, (textBottom - textTop) * 0.35);\n        var invadePad = Math.max(24, rootW * 0.17);\n        var invadeLeft = textCenterX - invadePad;\n        var invadeRight = textCenterX + invadePad;\n\n        var decorNear = 0;\n        var decorLeft = 0;\n        var decorRight = 0;\n        var decorInvading = 0;\n\n        for (var iHero=0; iHero<items.length; iHero++){\n          var it = items[iHero];\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") continue;\n\n          var w = Number(it.width || 0);\n          var h = Number(it.height || 0);\n          if (w < 8 || h < 8) continue;\n\n          var top = Number(it.top || 0);\n          var bottom = top + h;\n          var inBand = !(bottom < nearTop || top > nearBottom);\n          if (!inBand) continue;\n\n          decorNear++;\n          var cx = Number(it.left || 0) + w / 2;\n          if (cx < textCenterX - 8) decorLeft++;\n          else if (cx > textCenterX + 8) decorRight++;\n\n          var left = Number(it.left || 0);\n          var right = left + w;\n          if (right > invadeLeft && left < invadeRight) decorInvading++;\n        }\n\n        out.decorNear = decorNear;\n        out.decorLeft = decorLeft;\n        out.decorRight = decorRight;\n        out.decorInvadingTextColumn = decorInvading;\n\n        var decorAround = (decorLeft > 0 && decorRight > 0) || decorNear >= 3;\n        var centeredSingleTextColumn = out.singleTextColumn && (out.centeredByAlign || out.centeredByGeometry);\n        out.isHero = explicitHero || centeredSingleTextColumn;\n        out.reason = out.isHero\n          ? (\n            explicitHero\n              ? \"explicitHeroRole\"\n              : (decorInvading > 0\n                ? \"singleCenteredTextColumnDecorInvades\"\n                : (decorAround\n                  ? \"singleCenteredTextColumnWithDecor\"\n                  : \"singleCenteredTextColumn\"))\n          )\n          : \"noHeroSignal\";\n        return out;\n      }\n\n      function detectInlinePairNoReflow(flowItems, allItems, rootW, CFG){\n        var out = {\n          skip: false,\n          reason: \"\",\n          totalFlow: flowItems ? flowItems.length : 0,\n          totalAll: allItems ? allItems.length : 0,\n          rowDelta: null,\n          rowTol: null,\n          pairSpan: null,\n          pairSpanRatio: null,\n          fitsTogether: false,\n          bothSmall: false,\n          smallWLimit: null,\n          smallHLimit: null,\n          widths: [],\n          heights: []\n        };\n        if (!flowItems || flowItems.length !== 2 || !allItems || allItems.length !== 2 || !rootW || rootW <= 0) {\n          out.reason = \"notExactPair\";\n          return out;\n        }\n\n        var a = flowItems[0];\n        var b = flowItems[1];\n        var aW = Math.max(0, Number(a.width || 0));\n        var bW = Math.max(0, Number(b.width || 0));\n        var aH = Math.max(0, Number(a.height || 0));\n        var bH = Math.max(0, Number(b.height || 0));\n        out.widths = [+aW.toFixed(1), +bW.toFixed(1)];\n        out.heights = [+aH.toFixed(1), +bH.toFixed(1)];\n\n        if (aW < 2 || bW < 2 || aH < 2 || bH < 2) {\n          out.reason = \"invalidSizes\";\n          return out;\n        }\n\n        var rowTol = Math.max(12, Number((CFG && CFG.ROW_TOL) || 28) * 1.2);\n        var rowDelta = Math.abs(Number(a.top || 0) - Number(b.top || 0));\n        out.rowTol = +rowTol.toFixed(1);\n        out.rowDelta = +rowDelta.toFixed(1);\n        if (rowDelta > rowTol) {\n          out.reason = \"notInlineRow\";\n          return out;\n        }\n\n        var smallWLimit = Math.max(74, rootW * 0.42);\n        var smallHLimit = Math.max(34, rootW * 0.2);\n        out.smallWLimit = +smallWLimit.toFixed(1);\n        out.smallHLimit = +smallHLimit.toFixed(1);\n        var bothSmall =\n          aW <= smallWLimit &&\n          bW <= smallWLimit &&\n          aH <= smallHLimit &&\n          bH <= smallHLimit;\n        out.bothSmall = bothSmall;\n        if (!bothSmall) {\n          out.reason = \"pairNotSmall\";\n          return out;\n        }\n\n        var pairLeft = Math.min(Number(a.left || 0), Number(b.left || 0));\n        var pairRight = Math.max(Number(a.left || 0) + aW, Number(b.left || 0) + bW);\n        var pairSpan = Math.max(0, pairRight - pairLeft);\n        var fitsTogether = pairSpan <= (rootW + 1);\n        out.pairSpan = +pairSpan.toFixed(1);\n        out.pairSpanRatio = +(pairSpan / Math.max(1, rootW)).toFixed(3);\n        out.fitsTogether = fitsTogether;\n\n        if (fitsTogether) {\n          out.skip = true;\n          out.reason = \"smallInlinePairFits\";\n          return out;\n        }\n\n        out.reason = \"smallInlinePairOverflow\";\n        return out;\n      }\n\n      function enforceInlinePairGap(flowItems, rootEl, rootW){\n        var out = {\n          applied: false,\n          reason: \"\",\n          minGap: 6,\n          gapBefore: null,\n          gapAfter: null,\n          need: null,\n          moveLeft: 0,\n          moveRight: 0,\n          overflowBefore: false,\n          overflowAfter: false\n        };\n        var rootPadLeft = 0;\n        if (rootEl) {\n          var rootCS = getComputedStyle(rootEl);\n          rootPadLeft = parseFloat(rootCS.paddingLeft) || 0;\n        }\n        if (!flowItems || flowItems.length !== 2 || !rootEl || !rootW || rootW <= 0) {\n          out.reason = \"notExactPair\";\n          return out;\n        }\n\n        var a = flowItems[0];\n        var b = flowItems[1];\n        if (!a || !b || !a.node || !b.node) {\n          out.reason = \"missingNodes\";\n          return out;\n        }\n\n        var leftItem = Number(a.left || 0) <= Number(b.left || 0) ? a : b;\n        var rightItem = (leftItem === a) ? b : a;\n\n        var rrL = relRect(leftItem.node, rootEl);\n        var rrR = relRect(rightItem.node, rootEl);\n        var lLeft = Number(rrL.left || 0);\n        var lW = Number(rrL.width || 0);\n        var rLeft = Number(rrR.left || 0);\n        var rW = Number(rrR.width || 0);\n        if (!isFinite(lLeft) || !isFinite(lW) || !isFinite(rLeft) || !isFinite(rW)) {\n          out.reason = \"invalidRects\";\n          return out;\n        }\n\n        var gapBefore = rLeft - (lLeft + lW);\n        out.gapBefore = +gapBefore.toFixed(2);\n        out.overflowBefore = (lLeft < -0.5) || ((rLeft + rW) > (rootW + 0.5));\n\n        var need = Math.max(0, out.minGap - gapBefore);\n        out.need = +need.toFixed(2);\n        if (need <= 0.25) {\n          out.reason = \"alreadySpaced\";\n          out.gapAfter = out.gapBefore;\n          out.overflowAfter = out.overflowBefore;\n          return out;\n        }\n\n        var availRight = Math.max(0, rootW - (rLeft + rW));\n        var availLeft = Math.max(0, lLeft);\n        var moveRight = Math.min(availRight, need);\n        var remaining = Math.max(0, need - moveRight);\n        var moveLeft = Math.min(availLeft, remaining);\n\n        if (moveRight <= 0.01 && moveLeft <= 0.01) {\n          out.reason = \"noRoomToAdjust\";\n          return out;\n        }\n\n        if (moveRight > 0.01) {\n          rightItem.node.style.left = ((Number(rightItem.left || 0) + moveRight) - rootPadLeft) + \"px\";\n          rightItem.node.style.right = \"auto\";\n          rightItem.node.style.marginLeft = \"0px\";\n        }\n        if (moveLeft > 0.01) {\n          leftItem.node.style.left = ((Number(leftItem.left || 0) - moveLeft) - rootPadLeft) + \"px\";\n          leftItem.node.style.right = \"auto\";\n          leftItem.node.style.marginLeft = \"0px\";\n        }\n\n        var rrL2 = relRect(leftItem.node, rootEl);\n        var rrR2 = relRect(rightItem.node, rootEl);\n        var lLeft2 = Number(rrL2.left || 0);\n        var lW2 = Number(rrL2.width || 0);\n        var rLeft2 = Number(rrR2.left || 0);\n        var rW2 = Number(rrR2.width || 0);\n        var gapAfter = rLeft2 - (lLeft2 + lW2);\n\n        out.moveRight = +moveRight.toFixed(2);\n        out.moveLeft = +moveLeft.toFixed(2);\n        out.gapAfter = isFinite(gapAfter) ? +gapAfter.toFixed(2) : null;\n        out.overflowAfter = (lLeft2 < -0.5) || ((rLeft2 + rW2) > (rootW + 0.5));\n        out.applied = (moveRight > 0.01 || moveLeft > 0.01);\n        out.reason = out.applied ? \"applied\" : \"noChange\";\n        if (isFinite(gapAfter) && gapAfter < -0.2) out.reason = \"appliedButStillOverlap\";\n        return out;\n      }\n\n      var prominentNonTextCount = itemsAll.filter(function(it){\n        if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return false;\n        var w = Number(it.width || 0);\n        var h = Number(it.height || 0);\n        if (w < Math.max(10, contentW * 0.06)) return false;\n        if (h < Math.max(10, contentW * 0.04)) return false;\n        return true;\n      }).length;\n      var allowHeuristicAnchors = prominentNonTextCount <= 1;\n\n      // ✅ Determinar qué nodos son \"ANCHOR\" (no se reflowean)\n      // Regla: texto centrado + casi full-width => título/hero, no mover.\n      function isAnchorNode(it){\n        var node = it.node;\n\n        // opt-out explícito\n        var keepLayout = (node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n        if (keepLayout) return true;\n\n        // anchor explícito (si lo usás)\n        var role = (node.getAttribute(\"data-mobile-role\") || \"\");\n        if (role === \"anchor\") return true;\n\n        // heurística para textos\n        var isText = (node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n        if (!isText) return false;\n        if (!allowHeuristicAnchors) return false;\n\n        var ta = (node.style && node.style.textAlign) ? String(node.style.textAlign).toLowerCase() : \"\";\n        if (!ta) {\n          try {\n            ta = String(getComputedStyle(node).textAlign || \"\").toLowerCase();\n          } catch(_e) {}\n        }\n        if (ta !== \"center\") return false;\n\n        // solo si realmente ocupa casi todo el ancho usable\n        // (esto evita romper textos centrados dentro de columnas)\n        if (contentW > 0 && it.width >= contentW * 0.78) return true;\n\n        return false;\n      }\n\n      // ✅ Flow = todo lo que NO es anchor\n      var itemsFlow = itemsAll.filter(function(it){ return !isAnchorNode(it); });\n      var itemsAnchor = itemsAll.filter(function(it){ return isAnchorNode(it); });\n      mslLog(\"section:anchorSplit\", {\n        secIndex: secIndex,\n        anchors: itemsAnchor.length,\n        flow: itemsFlow.length,\n        prominentNonTextCount: prominentNonTextCount,\n        allowHeuristicAnchors: allowHeuristicAnchors,\n        anchorsDetail: itemsAnchor.map(function(it){\n          return {\n            kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\n            top: +it.top.toFixed(1),\n            left: +it.left.toFixed(1),\n            w: +it.width.toFixed(1),\n            h: +it.height.toFixed(1),\n            textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\n          };\n        })\n      });\n\n      // Si no hay suficientes elementos reflowables, no hacemos nada\n      if(itemsFlow.length < 2) {\n        logReflowDecision(\"skip:flowTooSmall\", {\n          willApplyReflow: false,\n          flowCount: itemsFlow.length,\n          anchorCount: itemsAnchor.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      // ✅ Para que \"altura necesaria\" no quede corta,\n      // medimos el bottom máximo de anchors (en coords del content)\n      var maxAnchorBottom = 0;\n      itemsAll.forEach(function(it){\n        if (!isAnchorNode(it)) return;\n        var b = (it.top || 0) + (it.height || 0);\n        if (b > maxAnchorBottom) maxAnchorBottom = b;\n      });\n\n      // ✅ 1) agrupar por solape → clusters (SOLO FLOW)\n      var clusters = buildOverlapClusters(itemsFlow);\n      mslLog(\"section:clusters\", {\n        secIndex: secIndex,\n        count: clusters.length,\n        clusters: clusters.map(function(c, idx){\n          return {\n            i: idx,\n            top: +c.top.toFixed(1),\n            left: +c.left.toFixed(1),\n            w: +c.width.toFixed(1),\n            h: +c.height.toFixed(1),\n            cx: +c.cx.toFixed(1),\n            items: c.items.length\n          };\n        })\n      });\n\n      // ✅ 2) Detectar columnas/rows (SOLO FLOW)\n      var rootW = contentW || 0;\n      var ord = orderClustersForMobile(clusters, rootW, CFG);\n      var groups = ord.groups;\n      var mode = ord.mode;\n      mslLog(\"section:ordering\", {\n        secIndex: secIndex,\n        mode: mode,\n        rootW: rootW,\n        groups: groups.map(function(grp, gi){\n          return {\n            g: gi,\n            count: grp.length,\n            tops: grp.map(function(c){ return +c.top.toFixed(1); }),\n            lefts: grp.map(function(c){ return +c.left.toFixed(1); })\n          };\n        })\n      });\n\n      var heroSignal = detectHeroLikeCentralText(itemsAll, rootW);\n      mslLog(\"section:heroCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        isHero: heroSignal.isHero,\n        reason: heroSignal.reason,\n        textCount: heroSignal.textCount,\n        textColumnCount: heroSignal.textColumnCount,\n        singleTextColumn: heroSignal.singleTextColumn,\n        textColumns: heroSignal.textColumns,\n        maxTextWidthRatio: heroSignal.maxTextWidthRatio,\n        widthRatio: heroSignal.widthRatio,\n        centerDelta: heroSignal.centerDelta,\n        centerTol: heroSignal.centerTol,\n        centeredByAlign: heroSignal.centeredByAlign,\n        centeredByGeometry: heroSignal.centeredByGeometry,\n        decorNear: heroSignal.decorNear,\n        decorLeft: heroSignal.decorLeft,\n        decorRight: heroSignal.decorRight,\n        decorInvadingTextColumn: heroSignal.decorInvadingTextColumn\n      });\n      if (heroSignal.isHero) {\n        logReflowDecision(\"skip:heroCentralText\", {\n          willApplyReflow: false,\n          mode: mode,\n          heroReason: heroSignal.reason,\n          hero: heroSignal\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      var inlinePairSignal = detectInlinePairNoReflow(itemsFlow, itemsAll, rootW, CFG);\n      mslLog(\"section:inlinePairCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        skip: inlinePairSignal.skip,\n        reason: inlinePairSignal.reason,\n        totalFlow: inlinePairSignal.totalFlow,\n        totalAll: inlinePairSignal.totalAll,\n        rowDelta: inlinePairSignal.rowDelta,\n        rowTol: inlinePairSignal.rowTol,\n        widths: inlinePairSignal.widths,\n        heights: inlinePairSignal.heights,\n        bothSmall: inlinePairSignal.bothSmall,\n        smallWLimit: inlinePairSignal.smallWLimit,\n        smallHLimit: inlinePairSignal.smallHLimit,\n        pairSpan: inlinePairSignal.pairSpan,\n        pairSpanRatio: inlinePairSignal.pairSpanRatio,\n        fitsTogether: inlinePairSignal.fitsTogether\n      });\n      if (inlinePairSignal.skip) {\n        var inlinePairAdjust = enforceInlinePairGap(itemsFlow, content, rootW);\n        mslLog(\"section:inlinePairAdjust\", {\n          secIndex: secIndex,\n          mode: mode,\n          adjust: inlinePairAdjust\n        });\n        logReflowDecision(\"skip:smallInlinePairFits\", {\n          willApplyReflow: false,\n          mode: mode,\n          inlinePair: inlinePairSignal,\n          inlinePairAdjust: inlinePairAdjust\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      // ✅ 3) Gate \"mejor de ambos mundos\":\n      // - Si es \"one\" (layout ya natural) Y además entra, NO hacemos reflow.\n      // - En cualquier otro caso (two/three/rows), hacemos reflow para lectura mobile,\n      //   incluso aunque \"entre\".\n      var fits = clustersFitInMobile(clusters, content);\n      mslLog(\"section:fitCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        fits: fits,\n        willSkip: (mode === \"one\" && fits)\n      });\n      if (mode === \"one\" && fits) {\n        logReflowDecision(\"skip:modeOneFits\", {\n          willApplyReflow: false,\n          mode: mode,\n          fits: fits,\n          clusters: clusters.length,\n          flowCount: itemsFlow.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      logReflowDecision(\"apply:modeRequiresReflow\", {\n        willApplyReflow: true,\n        mode: mode,\n        fits: fits,\n        clusters: clusters.length,\n        flowCount: itemsFlow.length,\n        anchorCount: itemsAnchor.length,\n        groupSizes: groups.map(function(grp){ return grp.length; })\n      });\n\n      // ✅ 4) Reflow solo sobre FLOW (preserva solapes dentro de cada cluster)\n      var res = applyClusterStack(groups, content, CFG, mode);\n      mslLog(\"section:applyResult\", {\n        secIndex: secIndex,\n        changed: !!(res && res.changed),\n        neededHeight: res ? res.neededHeight : null,\n        maxAnchorBottom: +maxAnchorBottom.toFixed(1),\n        baseBottomGap: +baseBottomGap.toFixed(1)\n      });\n      logReflowDecision(\"postApply\", {\n        willApplyReflow: true,\n        changed: !!(res && res.changed),\n        neededHeight: res ? +Number(res.neededHeight || 0).toFixed(1) : null,\n        mode: mode\n      });\n\n      var neededAfterReflow = 0;\n      if (res && res.changed) {\n        // Evitar que la sección quede chica si hay anchors más abajo\n        var needed = Number(res.neededHeight || 0);\n        if (Number(maxAnchorBottom) > 0) {\n          // sumamos padding bottom para que no quede pegado\n          var anchorNeeded = Math.ceil(maxAnchorBottom + (CFG.PAD_BOT || 0));\n          if (anchorNeeded > needed) needed = anchorNeeded;\n        }\n        if (baseBottomGap > 0) {\n          needed = Math.ceil(needed + baseBottomGap);\n        }\n        if (needed > 0) neededAfterReflow = needed;\n      }\n      finalizeSection(neededAfterReflow, baseBottomGap);\n    });\n  }\n\n  function boot(){\n    mslLog(\"boot\", { cfg: CFG });\n    runOnce();\n    setTimeout(runOnce, 150);\n    setTimeout(runOnce, 600);\n    setTimeout(runOnce, 1800);\n\n    if(document.fonts && document.fonts.ready){\n      document.fonts.ready.then(function(){ runOnce(); }).catch(function(){});\n    }\n  }\n\n  window.addEventListener(\"load\", boot);\n  window.addEventListener(\"resize\", runOnce);\n\n  if(window.visualViewport){\n    window.visualViewport.addEventListener(\"resize\", runOnce);\n    window.visualViewport.addEventListener(\"scroll\", runOnce);\n  }\n\n  if(document.readyState !== \"loading\") boot();\n  else document.addEventListener(\"DOMContentLoaded\", boot);\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFFaEI7QUFDRztBQUNBO0FBQ0E7QUFFdEMsU0FBU0ksWUFBWUMsR0FBcUI7SUFDL0MsSUFBSSxDQUFDQSxJQUFJQyxPQUFPLEVBQUUsT0FBTztJQUV6QixPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQTBGRyxFQUFFRCxJQUFJRSxRQUFRLENBQUM7YUFDZixFQUFFRixJQUFJRyxRQUFRLENBQUM7ZUFDYixFQUFFSCxJQUFJSSxRQUFRLENBQUM7O2FBRWpCLEVBQUVKLElBQUlLLFlBQVksQ0FBQzthQUNuQixFQUFFTCxJQUFJTSxlQUFlLENBQUM7O2dCQUVuQixFQUFFTixJQUFJTyxpQkFBaUIsR0FBRyxTQUFTLFFBQVE7eUJBQ2xDLEVBQUVQLElBQUlRLGlCQUFpQixHQUFHLFNBQVMsUUFBUTs7YUFFdkQsRUFBRVIsSUFBSVMsUUFBUSxDQUFDOzswQkFFRixFQUFFVCxJQUFJVSxpQkFBaUIsQ0FBQzttQkFDL0IsRUFBRVYsSUFBSVcsYUFBYSxDQUFDOzs0QkFFWCxFQUFFWCxJQUFJWSxtQkFBbUIsQ0FBQzttQkFDbkMsRUFBRVosSUFBSWEsYUFBYSxDQUFDOzttQkFFcEIsRUFBRWIsSUFBSWMsV0FBVyxDQUFDO21CQUNsQixFQUFFZCxJQUFJZSxXQUFXLENBQUM7NEJBQ1QsRUFBRWYsSUFBSWdCLG1CQUFtQixDQUFDO3dCQUM5QixFQUFFaEIsSUFBSWlCLGVBQWUsQ0FBQzs7O0VBRzVDLEVBQUV0Qix1REFBaUJBLEdBQUc7O0VBRXRCLEVBQUVFLDBEQUFlQSxHQUFHOztFQUVwQixFQUFFQywwREFBZUEsR0FBRzs7RUFFcEIsRUFBRUYsMERBQWVBLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXc5QnRCLENBQUMsQ0FBQ3NCLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcc2NyaXB0VGVtcGxhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9zY3JpcHRUZW1wbGF0ZS50c1xyXG5pbXBvcnQgeyBOb3JtYWxpemVkQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgeyBqc0RvbUhlbHBlcnNCbG9jayB9IGZyb20gXCIuL2RvbVwiO1xuaW1wb3J0IHsganNGaXRTY2FsZUJsb2NrIH0gZnJvbSBcIi4vZml0U2NhbGVcIjtcbmltcG9ydCB7IGpzT3JkZXJpbmdCbG9jayB9IGZyb20gXCIuL29yZGVyaW5nXCI7XG5pbXBvcnQgeyBqc1N0YWNraW5nQmxvY2sgfSBmcm9tIFwiLi9zdGFja2luZ1wiO1xuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNjcmlwdChjZmc6IE5vcm1hbGl6ZWRDb25maWcpOiBzdHJpbmcge1xyXG4gIGlmICghY2ZnLmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICByZXR1cm4gYFxuPHNjcmlwdD5cbihmdW5jdGlvbigpe1xuICB2YXIgRU5BQkxFRCA9IHRydWU7XG4gIGZ1bmN0aW9uIHJlYWREZWJ1Z0ZsYWcobmFtZSl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzZWFyY2ggPSAod2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpID8gd2luZG93LmxvY2F0aW9uLnNlYXJjaCA6IFwiXCI7XG4gICAgICB2YXIgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCk7XG4gICAgICB2YXIgcXYgPSBxcC5nZXQobmFtZSk7XG4gICAgICBpZiAocXYgPT09IFwiMVwiIHx8IFN0cmluZyhxdikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goX2UxKSB7fVxuXG4gICAgLy8gc3JjRG9jL2Fib3V0OnNyY2RvYyBubyBzdWVsZSB0ZW5lciBxdWVyeXN0cmluZy5cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5wYXJlbnQgJiYgd2luZG93LnBhcmVudCAhPT0gd2luZG93ICYmIHdpbmRvdy5wYXJlbnQubG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHBTZWFyY2ggPSB3aW5kb3cucGFyZW50LmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiO1xuICAgICAgICB2YXIgcFEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBTZWFyY2gpO1xuICAgICAgICB2YXIgcFYgPSBwUS5nZXQobmFtZSk7XG4gICAgICAgIGlmIChwViA9PT0gXCIxXCIgfHwgU3RyaW5nKHBWKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIikgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChfZTIpIHt9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy50b3AgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICYmIHdpbmRvdy50b3AubG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHRTZWFyY2ggPSB3aW5kb3cudG9wLmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiO1xuICAgICAgICB2YXIgdFEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRTZWFyY2gpO1xuICAgICAgICB2YXIgdFYgPSB0US5nZXQobmFtZSk7XG4gICAgICAgIGlmICh0ViA9PT0gXCIxXCIgfHwgU3RyaW5nKHRWKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIikgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChfZTMpIHt9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxzID0gd2luZG93LmxvY2FsU3RvcmFnZSA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKSA6IG51bGw7XG4gICAgICBpZiAobHMgPT09IFwiMVwiIHx8IFN0cmluZyhscykudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goX2U0KSB7fVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBNU0xfREVCVUcgPSByZWFkRGVidWdGbGFnKFwibXNsRGVidWdcIik7XG4gIHZhciBNU0xfVkVSQk9TRSA9IHJlYWREZWJ1Z0ZsYWcoXCJtc2xWZXJib3NlXCIpO1xuICBmdW5jdGlvbiBkYmcobGFiZWwsIHBheWxvYWQpe1xuICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltNU0xdIFwiICsgbGFiZWwgKyBcIiBcIiArIHBheWxvYWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldHR5ID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgcHJldHR5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgbnVsbCwgMik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0cnkgeyBwcmV0dHkgPSBTdHJpbmcocGF5bG9hZCk7IH0gY2F0Y2goXykgeyBwcmV0dHkgPSBcIlt1bnNlcmlhbGl6YWJsZV1cIjsgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIltNU0xdIFwiICsgbGFiZWwgKyBcIlxcXFxuXCIgKyBwcmV0dHkpO1xuICB9XG4gIGZ1bmN0aW9uIG1zbExvZygpe1xuICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgbGFiZWwgPSBTdHJpbmcoYXJnc1swXSk7XG4gICAgaWYgKCFNU0xfVkVSQk9TRSkge1xuICAgICAgdmFyIG5vaXN5ID0ge1xuICAgICAgICBcInNlY3Rpb246bm9kZVNvdXJjZXNcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmJhc2VsaW5lUmVzdG9yZVwiOiAxLFxuICAgICAgICBcInNlY3Rpb246YW5jaG9yU3BsaXRcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmNsdXN0ZXJzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6dGhyZWU6Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnRocmVlOnNwcmVhZFwiOiAxLFxuICAgICAgICBcIm9yZGVyOnR3bzpjYW5kaWRhdGVzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6dHdvOnNwcmVhZFwiOiAxLFxuICAgICAgICBcIm9yZGVyOm9uZTpjYW5kaWRhdGVzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6cm93czpmYWxsYmFja1wiOiAxXG4gICAgICB9O1xuICAgICAgaWYgKG5vaXN5W2xhYmVsXSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRiZyhsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgZGJnKGxhYmVsLCBhcmdzWzFdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGJnKGxhYmVsLCBhcmdzLnNsaWNlKDEpKTtcbiAgfVxuXHJcbiAgdmFyIENGRyA9IHtcclxuICAgIE1JTl9HQVA6ICR7Y2ZnLm1pbkdhcFB4fSxcclxuICAgIE1BWF9HQVA6ICR7Y2ZnLm1heEdhcFB4fSxcclxuICAgIEdBUF9TQ0FMRTogJHtjZmcuZ2FwU2NhbGV9LFxyXG5cclxuICAgIFBBRF9UT1A6ICR7Y2ZnLnBhZGRpbmdUb3BQeH0sXHJcbiAgICBQQURfQk9UOiAke2NmZy5wYWRkaW5nQm90dG9tUHh9LFxyXG5cclxuICAgIE9OTFlfRklYRUQ6ICR7Y2ZnLm9ubHlGaXhlZFNlY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9LFxyXG4gICAgT05MWV9XSEVOX1JFT1JERVJFRDogJHtjZmcub25seVdoZW5SZW9yZGVyZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIn0sXHJcblxyXG4gICAgUk9XX1RPTDogJHtjZmcucm93VG9sUHh9LFxyXG5cclxuICAgIFRXT19DT0xfU1BSRUFEX1JBVElPOiAke2NmZy50d29Db2xTcHJlYWRSYXRpb30sXHJcbiAgICBNSU5fUEVSX0NPTF8yOiAke2NmZy5taW5QZXJDb2x1bW4yfSxcclxuXHJcbiAgICBUSFJFRV9DT0xfU1BSRUFEX1JBVElPOiAke2NmZy50aHJlZUNvbFNwcmVhZFJhdGlvfSxcbiAgICBNSU5fUEVSX0NPTF8zOiAke2NmZy5taW5QZXJDb2x1bW4zfSxcblxuICAgIEZJVF9NSU5fU0NBTEU6ICR7Y2ZnLmZpdE1pblNjYWxlfSxcbiAgICBGSVRfTUFYX1NDQUxFOiAke2NmZy5maXRNYXhTY2FsZX0sXG4gICAgRklUX1RBUkdFVF9XSURUSF9SQVRJTzogJHtjZmcuZml0VGFyZ2V0V2lkdGhSYXRpb30sXG4gICAgRklUX01JTl9GSUxMX1JBVElPOiAke2NmZy5maXRNaW5GaWxsUmF0aW99XG4gIH07XG5cclxuICAke2pzRG9tSGVscGVyc0Jsb2NrKCl9XHJcblxyXG4gICR7anNPcmRlcmluZ0Jsb2NrKCl9XHJcblxyXG4gICR7anNTdGFja2luZ0Jsb2NrKCl9XG5cbiAgJHtqc0ZpdFNjYWxlQmxvY2soKX1cblxyXG4gIGZ1bmN0aW9uIGV4cGFuZEZpeGVkU2VjdGlvbihzZWMsIG5lZWRlZEhlaWdodCl7XHJcbiAgICB2YXIgY3VycmVudEggPSBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IDA7XHJcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEggKyAxKSB7XHJcbiAgICAgIHNlYy5zdHlsZS5oZWlnaHQgPSBNYXRoLmNlaWwobmVlZGVkSGVpZ2h0KSArIFwicHhcIjtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzaG91bGRQcm9jZXNzU2VjdGlvbihzZWMpe1xuICAgIGlmKCFzZWMpIHJldHVybiBmYWxzZTtcbiAgICBpZighQ0ZHLk9OTFlfRklYRUQpIHJldHVybiB0cnVlO1xuICAgIHZhciBtb2RvID0gKHNlYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZG9cIikgfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1vZG8gPT09IFwiZmlqb1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZU5vZGVCYXNlbGluZShub2RlKXtcbiAgICBpZiAoIW5vZGUpIHJldHVybiAwO1xuICAgIHZhciByZXN0b3JlZCA9IDA7XG5cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIiwgbm9kZS5zdHlsZS50b3AgfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLWxlZnRcIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIsIG5vZGUuc3R5bGUubGVmdCB8fCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIsIG5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LWFsaWduXCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdGV4dC1hbGlnblwiLCBub2RlLnN0eWxlLnRleHRBbGlnbiB8fCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtLW9yaWdpblwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybS1vcmlnaW5cIiwgbm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtem9vbVwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtem9vbVwiLCBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLXRleHQtem9vbVwiKSB8fCBcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ1RvcCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIik7XG4gICAgdmFyIG9yaWdMZWZ0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLWxlZnRcIik7XG4gICAgdmFyIG9yaWdUcmFuc2Zvcm0gPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIpO1xuICAgIHZhciBvcmlnVGV4dEFsaWduID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtYWxpZ25cIik7XG4gICAgdmFyIG9yaWdUcmFuc2Zvcm1PcmlnaW4gPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtLW9yaWdpblwiKTtcbiAgICB2YXIgb3JpZ1RleHRab29tID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtem9vbVwiKTtcblxuICAgIGlmIChvcmlnVG9wICE9IG51bGwgJiYgbm9kZS5zdHlsZS50b3AgIT09IG9yaWdUb3ApIHtcbiAgICAgIG5vZGUuc3R5bGUudG9wID0gb3JpZ1RvcDtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnTGVmdCAhPSBudWxsICYmIG5vZGUuc3R5bGUubGVmdCAhPT0gb3JpZ0xlZnQpIHtcbiAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG9yaWdMZWZ0O1xuICAgICAgcmVzdG9yZWQrKztcbiAgICB9XG4gICAgaWYgKG9yaWdUcmFuc2Zvcm0gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRyYW5zZm9ybSAhPT0gb3JpZ1RyYW5zZm9ybSkge1xuICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBvcmlnVHJhbnNmb3JtO1xuICAgICAgcmVzdG9yZWQrKztcbiAgICB9XG4gICAgaWYgKG9yaWdUZXh0QWxpZ24gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRleHRBbGlnbiAhPT0gb3JpZ1RleHRBbGlnbikge1xuICAgICAgaWYgKG9yaWdUZXh0QWxpZ24pIG5vZGUuc3R5bGUudGV4dEFsaWduID0gb3JpZ1RleHRBbGlnbjtcbiAgICAgIGVsc2Ugbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRleHQtYWxpZ25cIik7XG4gICAgICByZXN0b3JlZCsrO1xuICAgIH1cbiAgICBpZiAob3JpZ1RyYW5zZm9ybU9yaWdpbiAhPSBudWxsICYmIG5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luICE9PSBvcmlnVHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICBpZiAob3JpZ1RyYW5zZm9ybU9yaWdpbikgbm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnVHJhbnNmb3JtT3JpZ2luO1xuICAgICAgZWxzZSBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidHJhbnNmb3JtLW9yaWdpblwiKTtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnVGV4dFpvb20gIT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRUZXh0Wm9vbSA9IG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tdGV4dC16b29tXCIpIHx8IFwiXCI7XG4gICAgICBpZiAoY3VycmVudFRleHRab29tICE9PSBvcmlnVGV4dFpvb20pIHtcbiAgICAgICAgaWYgKG9yaWdUZXh0Wm9vbSkgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIG9yaWdUZXh0Wm9vbSk7XG4gICAgICAgIGVsc2Ugbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIpO1xuICAgICAgICByZXN0b3JlZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgIHJldHVybiByZXN0b3JlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bk9uY2UoKXtcbiAgICBpZighRU5BQkxFRCkgcmV0dXJuO1xuICAgIGlmKCFpc01vYmlsZSgpKSB7XG4gICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VjXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKHNlYyl7XG4gICAgICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XG4gICAgICAgIGlmKCFjb250ZW50KSByZXR1cm47XG4gICAgICAgIHZhciBibGVlZCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1ibGVlZFwiKTtcbiAgICAgICAgcmVzZXRTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCk7XG4gICAgICAgIHZhciBub2Rlc0FsbERlc2t0b3AgPSBnZXRPYmpOb2RlcyhzZWMpO1xuICAgICAgICBmb3IgKHZhciBuZD0wOyBuZDxub2Rlc0FsbERlc2t0b3AubGVuZ3RoOyBuZCsrKSB7XG4gICAgICAgICAgcmVzdG9yZU5vZGVCYXNlbGluZShub2Rlc0FsbERlc2t0b3BbbmRdKTtcbiAgICAgICAgfVxuICAgICAgICBzZWMuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LXNjYWxlXCIsIFwiMVwiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxyXG4gICAgdmFyIHNlY3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VjXCIpKTtcclxuICAgIGlmKCFzZWNzLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgIHNlY3MuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgdmFyIHNlY0luZGV4ID0gc2Vjcy5pbmRleE9mKHNlYyk7XG4gICAgICB2YXIgc2VjTW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGFsbG93UmVmbG93ID0gc2hvdWxkUHJvY2Vzc1NlY3Rpb24oc2VjKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246c3RhcnRcIiwgeyBzZWNJbmRleDogc2VjSW5kZXgsIG1vZG86IHNlY01vZG8sIGFsbG93UmVmbG93OiBhbGxvd1JlZmxvdyB9KTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtY29udGVudFwiKTtcbiAgICAgIGlmKCFjb250ZW50KSByZXR1cm47XG4gICAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XG4gICAgICByZXNldFNlY3Rpb25GaXRTY2FsZShzZWMsIGNvbnRlbnQsIGJsZWVkKTtcbiAgICAgIHZhciBub2Rlc0FsbCA9IGdldE9iak5vZGVzKHNlYyk7XG5cbiAgICAgIHZhciByZWZsb3dFbGVtZW50c0R1bXAgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGJ1aWxkUmVmbG93RWxlbWVudHNEdW1wKGl0ZW1zLCBjb250ZW50V05vdyl7XG4gICAgICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgICAgIHZhciBsaXN0ID0gKGl0ZW1zIHx8IFtdKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gMTIwO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAodmFyIGlEdW1wPTA7IGlEdW1wPGxpc3QubGVuZ3RoICYmIGlEdW1wPG1heEl0ZW1zOyBpRHVtcCsrKXtcbiAgICAgICAgICB2YXIgaXREdW1wID0gbGlzdFtpRHVtcF07XG4gICAgICAgICAgaWYgKCFpdER1bXAgfHwgIWl0RHVtcC5ub2RlKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgbkR1bXAgPSBpdER1bXAubm9kZTtcbiAgICAgICAgICB2YXIgdGV4dFJhdyA9ICgobkR1bXAudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgICAgICB2YXIgaXNUZXh0RHVtcCA9IChuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgICB2YXIgY2xzRHVtcCA9IChuRHVtcC5jbGFzc05hbWUgJiYgdHlwZW9mIG5EdW1wLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikgPyBuRHVtcC5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgIHZhciByb290Wm9uZSA9IChuRHVtcC5jbG9zZXN0ICYmIG5EdW1wLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSA/IFwiYmxlZWRcIiA6IFwiY29udGVudFwiO1xuICAgICAgICAgIG91dC5wdXNoKHtcbiAgICAgICAgICAgIGk6IGlEdW1wLFxuICAgICAgICAgICAga2luZDogaXNUZXh0RHVtcCA/IFwidGV4dG9cIiA6IFN0cmluZygobkR1bXAudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIHpvbmU6IHJvb3Rab25lLFxuICAgICAgICAgICAgdG9wOiArTnVtYmVyKGl0RHVtcC50b3AgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtOdW1iZXIoaXREdW1wLmxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtOdW1iZXIoaXREdW1wLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiArTnVtYmVyKGl0RHVtcC5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHJpZ2h0OiArTnVtYmVyKChpdER1bXAubGVmdCB8fCAwKSArIChpdER1bXAud2lkdGggfHwgMCkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBib3R0b206ICtOdW1iZXIoKGl0RHVtcC50b3AgfHwgMCkgKyAoaXREdW1wLmhlaWdodCB8fCAwKSkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGN4OiArTnVtYmVyKChpdER1bXAubGVmdCB8fCAwKSArICgoaXREdW1wLndpZHRoIHx8IDApIC8gMikpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3UmF0aW86IGNvbnRlbnRXTm93ID4gMSA/ICtOdW1iZXIoKGl0RHVtcC53aWR0aCB8fCAwKSAvIGNvbnRlbnRXTm93KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzRHVtcCxcbiAgICAgICAgICAgIG1vYmlsZUxheW91dDogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVSb2xlOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDbHVzdGVyOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDbHVzdGVySWQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXItaWRcIikgfHwgXCJcIixcbiAgICAgICAgICAgIG1vYmlsZUNlbnRlcjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVBbGlnbjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIixcbiAgICAgICAgICAgIG1vYmlsZUZpdDogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IChuRHVtcC5zdHlsZSAmJiBuRHVtcC5zdHlsZS50ZXh0QWxpZ24pID8gbkR1bXAuc3R5bGUudGV4dEFsaWduIDogXCJcIixcbiAgICAgICAgICAgIHRleHRTYW1wbGU6IGlzVGV4dER1bXAgPyB0ZXh0UmF3LnNsaWNlKDAsIDkwKSA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZWZsb3dFbGVtZW50c0R1bXAgPSBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvZ1JlZmxvd0RlY2lzaW9uKHJlYXNvbiwgZXh0cmEpe1xuICAgICAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgc2VjTW9kbzogc2VjTW9kbyxcbiAgICAgICAgICBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3csXG4gICAgICAgICAgdG90YWxOb2RlczogKG5vZGVzQWxsIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgICAgcmVhc29uOiBTdHJpbmcocmVhc29uIHx8IFwiXCIpLFxuICAgICAgICAgIGRldGFpbHM6IGV4dHJhIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246cmVmbG93OmRlY2lzaW9uXCIsIHBheWxvYWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNlY3Rpb24obWluTmVlZGVkSGVpZ2h0LCBwcmVzZXJ2ZUJvdHRvbUdhcCl7XG4gICAgICAgIHZhciBnYXAgPSBOdW1iZXIuaXNGaW5pdGUocHJlc2VydmVCb3R0b21HYXApID8gTWF0aC5tYXgoMCwgTnVtYmVyKHByZXNlcnZlQm90dG9tR2FwKSkgOiAwO1xuICAgICAgICB2YXIgZml0ID0gYXBwbHlTZWN0aW9uRml0U2NhbGUoXG4gICAgICAgICAgc2VjLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgYmxlZWQsXG4gICAgICAgICAgbm9kZXNBbGwsXG4gICAgICAgICAgc2VjTW9kbyxcbiAgICAgICAgICBDRkcsXG4gICAgICAgICAgeyBzZWNJbmRleDogc2VjSW5kZXggfSxcbiAgICAgICAgICB7IHByZXNlcnZlQm90dG9tR2FwOiBnYXAgfVxuICAgICAgICApO1xuICAgICAgICB2YXIgZml0TmVlZGVkID0gKGZpdCAmJiBOdW1iZXIuaXNGaW5pdGUoZml0Lm5lZWRlZEhlaWdodCkpID8gTnVtYmVyKGZpdC5uZWVkZWRIZWlnaHQpIDogMDtcbiAgICAgICAgdmFyIG5lZWRlZEhlaWdodCA9IE1hdGgubWF4KE51bWJlcihtaW5OZWVkZWRIZWlnaHQgfHwgMCksIGZpdE5lZWRlZCk7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246aGVpZ2h0RmluYWxcIiwge1xuICAgICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgICBtb2RlOiBzZWNNb2RvLFxuICAgICAgICAgIG1pbk5lZWRlZEhlaWdodDogK051bWJlcihtaW5OZWVkZWRIZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBmaXROZWVkZWRIZWlnaHQ6ICtmaXROZWVkZWQudG9GaXhlZCgxKSxcbiAgICAgICAgICBwcmVzZXJ2ZUJvdHRvbUdhcDogK2dhcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGZpbmFsTmVlZGVkSGVpZ2h0OiArbmVlZGVkSGVpZ2h0LnRvRml4ZWQoMSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWNNb2RvID09PSBcImZpam9cIiAmJiBuZWVkZWRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgZXhwYW5kRml4ZWRTZWN0aW9uKHNlYywgbmVlZGVkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZighbm9kZXNBbGwubGVuZ3RoKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpub05vZGVzXCIsIHsgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWJ1Z0NvdW50cyA9IHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjb250ZW50T2JqOiBjb250ZW50ID8gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKS5sZW5ndGggOiAwLFxuICAgICAgICBibGVlZE9iajogYmxlZWQgPyBibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKS5sZW5ndGggOiAwLFxuICAgICAgICBjb250ZW50QWJzOiBjb250ZW50ID8gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5maWx0ZXIoZnVuY3Rpb24oZWwpe1xuICAgICAgICAgIHJldHVybiAhIShlbCAmJiBlbC5zdHlsZSAmJiAoZWwuc3R5bGUucG9zaXRpb24gfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJhYnNvbHV0ZVwiICYmIGVsLnN0eWxlLnRvcCAmJiBlbC5zdHlsZS5sZWZ0KTtcbiAgICAgICAgfSkubGVuZ3RoIDogMCxcbiAgICAgICAgYmxlZWRBYnM6IGJsZWVkID8gQXJyYXkuZnJvbShibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYWJzb2x1dGVcIiAmJiBlbC5zdHlsZS50b3AgJiYgZWwuc3R5bGUubGVmdCk7XG4gICAgICAgIH0pLmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVTb3VyY2VzXCIsIGRlYnVnQ291bnRzKTtcblxuICAgICAgaWYgKE1TTF9WRVJCT1NFKSB7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246bm9kZXNBbGw6cmF3XCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgdG90YWw6IG5vZGVzQWxsLmxlbmd0aCxcbiAgICAgICAgICBub2Rlczogbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG4sIGkpe1xuICAgICAgICAgICAgdmFyIGNscyA9IChuLmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbi5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhcmVudENscyA9IChuLnBhcmVudEVsZW1lbnQgJiYgbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgPyBuLnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIHRhZzogKG4udGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICBjbHM6IGNscyxcbiAgICAgICAgICAgICAgcGFyZW50Q2xzOiBwYXJlbnRDbHMsXG4gICAgICAgICAgICAgIHRvcDogbi5zdHlsZSA/IG4uc3R5bGUudG9wIDogXCJcIixcbiAgICAgICAgICAgICAgbGVmdDogbi5zdHlsZSA/IG4uc3R5bGUubGVmdCA6IFwiXCIsXG4gICAgICAgICAgICAgIHBvczogbi5zdHlsZSA/IG4uc3R5bGUucG9zaXRpb24gOiBcIlwiLFxuICAgICAgICAgICAgICB0ZXh0OiAoKG4udGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5zbGljZSgwLCA0MClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGZsYXQgPSBub2Rlc0FsbC5tYXAoZnVuY3Rpb24obiwgaSl7XG4gICAgICAgICAgICB2YXIgY2xzID0gKG4uY2xhc3NOYW1lICYmIHR5cGVvZiBuLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikgPyBuLmNsYXNzTmFtZSA6IFwiXCI7XG4gICAgICAgICAgICB2YXIgdHh0ID0gKChuLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA2MCk7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBpXG4gICAgICAgICAgICAgICsgXCIgdGFnPVwiICsgU3RyaW5nKChuLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgKyBcIiBjbHM9XCIgKyBjbHNcbiAgICAgICAgICAgICAgKyBcIiBwb3M9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUucG9zaXRpb24gOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIHRvcD1cIiArIChuLnN0eWxlID8gbi5zdHlsZS50b3AgOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIGxlZnQ9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUubGVmdCA6IFwiXCIpXG4gICAgICAgICAgICAgICsgXCIgdGV4dD1cIiArIHR4dDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVzQWxsOmZsYXRcIiwgXCJzZWM9XCIgKyBzZWNJbmRleCArIFwiIHRvdGFsPVwiICsgbm9kZXNBbGwubGVuZ3RoICsgXCIgOjogXCIgKyBmbGF0LmpvaW4oXCIgfCBcIikpO1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdG9yZWRDb3VudCA9IDA7XG4gICAgICBub2Rlc0FsbC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICByZXN0b3JlZENvdW50ICs9IHJlc3RvcmVOb2RlQmFzZWxpbmUobm9kZSk7XG4gICAgICB9KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246YmFzZWxpbmVSZXN0b3JlXCIsIHsgc2VjSW5kZXg6IHNlY0luZGV4LCBub2Rlczogbm9kZXNBbGwubGVuZ3RoLCByZXN0b3JlZDogcmVzdG9yZWRDb3VudCB9KTtcblxuICAgICAgLy8gUmVjdCBkZWwgY29udGVudCAobcOpdHJpY2FzIHJlYWxlcylcbiAgICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY29udGVudFcgPSBjb250ZW50UmVjdC53aWR0aCB8fCAwO1xuICAgICAgdmFyIHNlY0N1cnJlbnRIID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCAwO1xuICAgICAgdmFyIGJhc2VIZWlnaHRBdHRyID0gXCJkYXRhLW1zbC1iYXNlLWhlaWdodFwiO1xuICAgICAgaWYgKCFzZWMuaGFzQXR0cmlidXRlKGJhc2VIZWlnaHRBdHRyKSkge1xuICAgICAgICBzZWMuc2V0QXR0cmlidXRlKGJhc2VIZWlnaHRBdHRyLCBTdHJpbmcoc2VjQ3VycmVudEgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlU2VjSGVpZ2h0ID0gcGFyc2VGbG9hdChzZWMuZ2V0QXR0cmlidXRlKGJhc2VIZWlnaHRBdHRyKSB8fCBcIlwiKTtcbiAgICAgIGlmICghaXNGaW5pdGUoYmFzZVNlY0hlaWdodCkgfHwgYmFzZVNlY0hlaWdodCA8PSAwKSBiYXNlU2VjSGVpZ2h0ID0gc2VjQ3VycmVudEg7XG5cclxuICAgICAgLy8gaXRlbXMgKHJlY3RzKSBlbiBjb29yZGVuYWRhcyBkZWwgY29udGVudCAoVE9ET1MpXHJcbiAgICAgIHZhciBpdGVtc0FsbCA9IG5vZGVzQWxsLm1hcChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIHJjID0gcmVsUmVjdChub2RlLCBjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIHRvcDogcmMudG9wLFxuICAgICAgICAgIGxlZnQ6IHJjLmxlZnQsXHJcbiAgICAgICAgICBoZWlnaHQ6IHJjLmhlaWdodCxcclxuICAgICAgICAgIHdpZHRoOiByYy53aWR0aFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBidWlsZFJlZmxvd0VsZW1lbnRzRHVtcChpdGVtc0FsbCwgY29udGVudFcpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpyZWZsb3c6ZWxlbWVudHNcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIHNlY01vZG86IHNlY01vZG8sXG4gICAgICAgIGNvbnRlbnRXOiArTnVtYmVyKGNvbnRlbnRXIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHRvdGFsOiByZWZsb3dFbGVtZW50c0R1bXAubGVuZ3RoLFxuICAgICAgICBlbGVtZW50czogcmVmbG93RWxlbWVudHNEdW1wXG4gICAgICB9KTtcbiAgICAgIGlmIChNU0xfVkVSQk9TRSkge1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOml0ZW1zQWxsXCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgdG90YWw6IGl0ZW1zQWxsLmxlbmd0aCxcbiAgICAgICAgICBpdGVtczogaXRlbXNBbGwubWFwKGZ1bmN0aW9uKGl0LCBpZHgpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaTogaWR4LFxuICAgICAgICAgICAgICBraW5kOiAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIiA/IFwidGV4dG9cIiA6IChpdC5ub2RlLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgdG9wOiAraXQudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGxlZnQ6ICtpdC5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIHc6ICtpdC53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBoOiAraXQuaGVpZ2h0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogKGl0Lm5vZGUuc3R5bGUgJiYgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24pID8gaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gOiBcIlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVzZXJ2YXIgZWwgXCJhaXJlXCIgaW5mZXJpb3Igb3JpZ2luYWwgZGUgbGEgc2VjY2lvbiB0cmFzIGVsIHJlZmxvdy5cbiAgICAgIHZhciBtYXhPcmlnaW5hbEJvdHRvbSA9IDA7XG4gICAgICBmb3IgKHZhciBpYj0wOyBpYjxpdGVtc0FsbC5sZW5ndGg7IGliKyspe1xuICAgICAgICB2YXIgaXRiID0gaXRlbXNBbGxbaWJdO1xuICAgICAgICB2YXIgYnRtID0gKGl0Yi50b3AgfHwgMCkgKyAoaXRiLmhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKGJ0bSA+IG1heE9yaWdpbmFsQm90dG9tKSBtYXhPcmlnaW5hbEJvdHRvbSA9IGJ0bTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlQm90dG9tR2FwID0gTWF0aC5tYXgoMCwgYmFzZVNlY0hlaWdodCAtIG1heE9yaWdpbmFsQm90dG9tKTtcblxuICAgICAgLy8gU2kgdG9kbyBtaWRlIDAgKGZvbnRzIG5vIGxpc3RhcyksIHJlaW50ZW50YW1vcyBsdWVnb1xuICAgICAgdmFyIGFueVZhbGlkQWxsID0gaXRlbXNBbGwuc29tZShmdW5jdGlvbihpdCl7IHJldHVybiBpdC5oZWlnaHQgPiAwLjU7IH0pO1xuICAgICAgaWYoIWFueVZhbGlkQWxsKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDppbnZhbGlkUmVjdHNcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgYWxsSGVpZ2h0c1Rpbnk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFsbG93UmVmbG93IHx8IG5vZGVzQWxsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOm5vdEVsaWdpYmxlXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGFsbG93UmVmbG93OiBhbGxvd1JlZmxvdyxcbiAgICAgICAgICB0b3RhbE5vZGVzOiBub2Rlc0FsbC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXRlY3RIZXJvTGlrZUNlbnRyYWxUZXh0KGl0ZW1zLCByb290Vyl7XG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgaXNIZXJvOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgdGV4dENvdW50OiAwLFxuICAgICAgICAgIHRleHRDb2x1bW5Db3VudDogMCxcbiAgICAgICAgICB0ZXh0Q29sdW1uczogW10sXG4gICAgICAgICAgc2luZ2xlVGV4dENvbHVtbjogZmFsc2UsXG4gICAgICAgICAgbWF4VGV4dFdpZHRoUmF0aW86IG51bGwsXG4gICAgICAgICAgd2lkdGhSYXRpbzogbnVsbCxcbiAgICAgICAgICBjZW50ZXJEZWx0YTogbnVsbCxcbiAgICAgICAgICBjZW50ZXJUb2w6IG51bGwsXG4gICAgICAgICAgY2VudGVyZWRCeUFsaWduOiBmYWxzZSxcbiAgICAgICAgICBjZW50ZXJlZEJ5R2VvbWV0cnk6IGZhbHNlLFxuICAgICAgICAgIGRlY29yTmVhcjogMCxcbiAgICAgICAgICBkZWNvckxlZnQ6IDAsXG4gICAgICAgICAgZGVjb3JSaWdodDogMCxcbiAgICAgICAgICBkZWNvckludmFkaW5nVGV4dENvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggfHwgIXJvb3RXIHx8IHJvb3RXIDw9IDApIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub0l0ZW1zT3JXaWR0aFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dEl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICBpZiAoKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB2YXIgdHcgPSBOdW1iZXIoaXQud2lkdGggfHwgMCk7XG4gICAgICAgICAgdmFyIHRoID0gTnVtYmVyKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgICByZXR1cm4gdHcgPiAyICYmIHRoID4gMjtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dC50ZXh0Q291bnQgPSB0ZXh0SXRlbXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXRleHRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub1RleHRcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGxpY2l0SGVybyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBlaD0wOyBlaDx0ZXh0SXRlbXMubGVuZ3RoOyBlaCsrKXtcbiAgICAgICAgICB2YXIgcm9sZUVoID0gKHRleHRJdGVtc1tlaF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHJvbGVFaCA9PT0gXCJoZXJvXCIpIHtcbiAgICAgICAgICAgIGV4cGxpY2l0SGVybyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sVG9sID0gTWF0aC5tYXgoMTgsIHJvb3RXICogMC4xNCk7XG4gICAgICAgIHZhciB0ZXh0Q29scyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB0Yz0wOyB0Yzx0ZXh0SXRlbXMubGVuZ3RoOyB0YysrKXtcbiAgICAgICAgICB2YXIgdHh0ID0gdGV4dEl0ZW1zW3RjXTtcbiAgICAgICAgICB2YXIgdHh0Q3ggPSBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICB2YXIgYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBjYz0wOyBjYzx0ZXh0Q29scy5sZW5ndGg7IGNjKyspe1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHR4dEN4IC0gdGV4dENvbHNbY2NdLmN4KSA8PSBjb2xUb2wpIHtcbiAgICAgICAgICAgICAgdmFyIG5Db2wgPSB0ZXh0Q29sc1tjY10uY291bnQgKyAxO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10uY3ggPSAoKHRleHRDb2xzW2NjXS5jeCAqIHRleHRDb2xzW2NjXS5jb3VudCkgKyB0eHRDeCkgLyBuQ29sO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10uY291bnQgPSBuQ29sO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWluTGVmdCA9IE1hdGgubWluKHRleHRDb2xzW2NjXS5taW5MZWZ0LCBOdW1iZXIodHh0LmxlZnQgfHwgMCkpO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWF4UmlnaHQgPSBNYXRoLm1heCh0ZXh0Q29sc1tjY10ubWF4UmlnaHQsIE51bWJlcih0eHQubGVmdCB8fCAwKSArIE51bWJlcih0eHQud2lkdGggfHwgMCkpO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWluVG9wID0gTWF0aC5taW4odGV4dENvbHNbY2NdLm1pblRvcCwgTnVtYmVyKHR4dC50b3AgfHwgMCkpO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWF4Qm90dG9tID0gTWF0aC5tYXgodGV4dENvbHNbY2NdLm1heEJvdHRvbSwgTnVtYmVyKHR4dC50b3AgfHwgMCkgKyBOdW1iZXIodHh0LmhlaWdodCB8fCAwKSk7XG4gICAgICAgICAgICAgIGF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRleHRDb2xzLnB1c2goe1xuICAgICAgICAgICAgICBjeDogdHh0Q3gsXG4gICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICBtaW5MZWZ0OiBOdW1iZXIodHh0LmxlZnQgfHwgMCksXG4gICAgICAgICAgICAgIG1heFJpZ2h0OiBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApLFxuICAgICAgICAgICAgICBtaW5Ub3A6IE51bWJlcih0eHQudG9wIHx8IDApLFxuICAgICAgICAgICAgICBtYXhCb3R0b206IE51bWJlcih0eHQudG9wIHx8IDApICsgTnVtYmVyKHR4dC5oZWlnaHQgfHwgMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0Q29scy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLmN4IC0gYi5jeDsgfSk7XG4gICAgICAgIG91dC50ZXh0Q29sdW1uQ291bnQgPSB0ZXh0Q29scy5sZW5ndGg7XG4gICAgICAgIG91dC5zaW5nbGVUZXh0Q29sdW1uID0gdGV4dENvbHMubGVuZ3RoID09PSAxO1xuICAgICAgICBvdXQudGV4dENvbHVtbnMgPSB0ZXh0Q29scy5tYXAoZnVuY3Rpb24oY29sKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3g6ICtOdW1iZXIoY29sLmN4IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjb3VudDogY29sLmNvdW50LFxuICAgICAgICAgICAgbGVmdDogK051bWJlcihjb2wubWluTGVmdCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgcmlnaHQ6ICtOdW1iZXIoY29sLm1heFJpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB0b3A6ICtOdW1iZXIoY29sLm1pblRvcCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgYm90dG9tOiArTnVtYmVyKGNvbC5tYXhCb3R0b20gfHwgMCkudG9GaXhlZCgxKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW91dC5zaW5nbGVUZXh0Q29sdW1uKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IGV4cGxpY2l0SGVybyA/IFwiZXhwbGljaXRIZXJvUm9sZVwiIDogXCJtdWx0aVRleHRDb2x1bW5zXCI7XG4gICAgICAgICAgb3V0LmlzSGVybyA9IGV4cGxpY2l0SGVybztcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlclggPSByb290VyAvIDI7XG4gICAgICAgIHZhciB0ZXh0Q29sID0gdGV4dENvbHNbMF07XG4gICAgICAgIHZhciB0ZXh0Q2VudGVyWCA9IE51bWJlcih0ZXh0Q29sLmN4IHx8IGNlbnRlclgpO1xuICAgICAgICB2YXIgY2VudGVyRGVsdGEgPSBNYXRoLmFicyh0ZXh0Q2VudGVyWCAtIGNlbnRlclgpO1xuICAgICAgICB2YXIgY2VudGVyVG9sID0gTWF0aC5tYXgoMTgsIHJvb3RXICogMC4xMik7XG4gICAgICAgIG91dC5jZW50ZXJEZWx0YSA9ICtjZW50ZXJEZWx0YS50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQuY2VudGVyVG9sID0gK2NlbnRlclRvbC50b0ZpeGVkKDEpO1xuXG4gICAgICAgIHZhciBjZW50ZXJlZEFsaWduQ291bnQgPSAwO1xuICAgICAgICB2YXIgbWF4VGV4dFdpZHRoUmF0aW8gPSAwO1xuICAgICAgICB2YXIgdGV4dFRvcCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgdGV4dEJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgdGl4PTA7IHRpeDx0ZXh0SXRlbXMubGVuZ3RoOyB0aXgrKyl7XG4gICAgICAgICAgdmFyIHQgPSB0ZXh0SXRlbXNbdGl4XTtcbiAgICAgICAgICB2YXIgdGEgPSAodC5ub2RlICYmIHQubm9kZS5zdHlsZSAmJiB0Lm5vZGUuc3R5bGUudGV4dEFsaWduKVxuICAgICAgICAgICAgPyBTdHJpbmcodC5ub2RlLnN0eWxlLnRleHRBbGlnbikudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgIGlmICh0YSA9PT0gXCJjZW50ZXJcIikgY2VudGVyZWRBbGlnbkNvdW50Kys7XG4gICAgICAgICAgdmFyIHdSYXRpbyA9IE51bWJlcih0LndpZHRoIHx8IDApIC8gTWF0aC5tYXgoMSwgcm9vdFcpO1xuICAgICAgICAgIGlmICh3UmF0aW8gPiBtYXhUZXh0V2lkdGhSYXRpbykgbWF4VGV4dFdpZHRoUmF0aW8gPSB3UmF0aW87XG4gICAgICAgICAgdGV4dFRvcCA9IE1hdGgubWluKHRleHRUb3AsIE51bWJlcih0LnRvcCB8fCAwKSk7XG4gICAgICAgICAgdGV4dEJvdHRvbSA9IE1hdGgubWF4KHRleHRCb3R0b20sIE51bWJlcih0LnRvcCB8fCAwKSArIE51bWJlcih0LmhlaWdodCB8fCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0Lm1heFRleHRXaWR0aFJhdGlvID0gK21heFRleHRXaWR0aFJhdGlvLnRvRml4ZWQoMyk7XG4gICAgICAgIG91dC53aWR0aFJhdGlvID0gb3V0Lm1heFRleHRXaWR0aFJhdGlvO1xuICAgICAgICBvdXQuY2VudGVyZWRCeUFsaWduID0gY2VudGVyZWRBbGlnbkNvdW50ID49IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0ZXh0SXRlbXMubGVuZ3RoICogMC41KSk7XG4gICAgICAgIG91dC5jZW50ZXJlZEJ5R2VvbWV0cnkgPSBjZW50ZXJEZWx0YSA8PSBjZW50ZXJUb2w7XG4gICAgICAgIGlmICghb3V0LmNlbnRlcmVkQnlBbGlnbiAmJiAhb3V0LmNlbnRlcmVkQnlHZW9tZXRyeSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBleHBsaWNpdEhlcm8gPyBcImV4cGxpY2l0SGVyb1JvbGVcIiA6IFwic2luZ2xlVGV4dENvbHVtbk5vdENlbnRlcmVkXCI7XG4gICAgICAgICAgb3V0LmlzSGVybyA9IGV4cGxpY2l0SGVybztcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZpdGEgbWFyY2FyIGNvbW8gaGVybyB0ZXh0b3Mgc3VlbHRvcyBtdXkgY2hpY29zLlxuICAgICAgICBpZiAodGV4dEl0ZW1zLmxlbmd0aCA8IDIgJiYgbWF4VGV4dFdpZHRoUmF0aW8gPCAwLjI4ICYmICFleHBsaWNpdEhlcm8pIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJ0ZXh0VG9vU21hbGxcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh0ZXh0VG9wKSB8fCAhaXNGaW5pdGUodGV4dEJvdHRvbSkgfHwgdGV4dEJvdHRvbSA8PSB0ZXh0VG9wKSB7XG4gICAgICAgICAgdGV4dFRvcCA9IDA7XG4gICAgICAgICAgdGV4dEJvdHRvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJUb3AgPSB0ZXh0VG9wIC0gTWF0aC5tYXgoMjgsICh0ZXh0Qm90dG9tIC0gdGV4dFRvcCkgKiAwLjIpO1xuICAgICAgICB2YXIgbmVhckJvdHRvbSA9IHRleHRCb3R0b20gKyBNYXRoLm1heCgzNiwgKHRleHRCb3R0b20gLSB0ZXh0VG9wKSAqIDAuMzUpO1xuICAgICAgICB2YXIgaW52YWRlUGFkID0gTWF0aC5tYXgoMjQsIHJvb3RXICogMC4xNyk7XG4gICAgICAgIHZhciBpbnZhZGVMZWZ0ID0gdGV4dENlbnRlclggLSBpbnZhZGVQYWQ7XG4gICAgICAgIHZhciBpbnZhZGVSaWdodCA9IHRleHRDZW50ZXJYICsgaW52YWRlUGFkO1xuXG4gICAgICAgIHZhciBkZWNvck5lYXIgPSAwO1xuICAgICAgICB2YXIgZGVjb3JMZWZ0ID0gMDtcbiAgICAgICAgdmFyIGRlY29yUmlnaHQgPSAwO1xuICAgICAgICB2YXIgZGVjb3JJbnZhZGluZyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaUhlcm89MDsgaUhlcm88aXRlbXMubGVuZ3RoOyBpSGVybysrKXtcbiAgICAgICAgICB2YXIgaXQgPSBpdGVtc1tpSGVyb107XG4gICAgICAgICAgaWYgKChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciB3ID0gTnVtYmVyKGl0LndpZHRoIHx8IDApO1xuICAgICAgICAgIHZhciBoID0gTnVtYmVyKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgICBpZiAodyA8IDggfHwgaCA8IDgpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgdmFyIHRvcCA9IE51bWJlcihpdC50b3AgfHwgMCk7XG4gICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGg7XG4gICAgICAgICAgdmFyIGluQmFuZCA9ICEoYm90dG9tIDwgbmVhclRvcCB8fCB0b3AgPiBuZWFyQm90dG9tKTtcbiAgICAgICAgICBpZiAoIWluQmFuZCkgY29udGludWU7XG5cbiAgICAgICAgICBkZWNvck5lYXIrKztcbiAgICAgICAgICB2YXIgY3ggPSBOdW1iZXIoaXQubGVmdCB8fCAwKSArIHcgLyAyO1xuICAgICAgICAgIGlmIChjeCA8IHRleHRDZW50ZXJYIC0gOCkgZGVjb3JMZWZ0Kys7XG4gICAgICAgICAgZWxzZSBpZiAoY3ggPiB0ZXh0Q2VudGVyWCArIDgpIGRlY29yUmlnaHQrKztcblxuICAgICAgICAgIHZhciBsZWZ0ID0gTnVtYmVyKGl0LmxlZnQgfHwgMCk7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHc7XG4gICAgICAgICAgaWYgKHJpZ2h0ID4gaW52YWRlTGVmdCAmJiBsZWZ0IDwgaW52YWRlUmlnaHQpIGRlY29ySW52YWRpbmcrKztcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5kZWNvck5lYXIgPSBkZWNvck5lYXI7XG4gICAgICAgIG91dC5kZWNvckxlZnQgPSBkZWNvckxlZnQ7XG4gICAgICAgIG91dC5kZWNvclJpZ2h0ID0gZGVjb3JSaWdodDtcbiAgICAgICAgb3V0LmRlY29ySW52YWRpbmdUZXh0Q29sdW1uID0gZGVjb3JJbnZhZGluZztcblxuICAgICAgICB2YXIgZGVjb3JBcm91bmQgPSAoZGVjb3JMZWZ0ID4gMCAmJiBkZWNvclJpZ2h0ID4gMCkgfHwgZGVjb3JOZWFyID49IDM7XG4gICAgICAgIHZhciBjZW50ZXJlZFNpbmdsZVRleHRDb2x1bW4gPSBvdXQuc2luZ2xlVGV4dENvbHVtbiAmJiAob3V0LmNlbnRlcmVkQnlBbGlnbiB8fCBvdXQuY2VudGVyZWRCeUdlb21ldHJ5KTtcbiAgICAgICAgb3V0LmlzSGVybyA9IGV4cGxpY2l0SGVybyB8fCBjZW50ZXJlZFNpbmdsZVRleHRDb2x1bW47XG4gICAgICAgIG91dC5yZWFzb24gPSBvdXQuaXNIZXJvXG4gICAgICAgICAgPyAoXG4gICAgICAgICAgICBleHBsaWNpdEhlcm9cbiAgICAgICAgICAgICAgPyBcImV4cGxpY2l0SGVyb1JvbGVcIlxuICAgICAgICAgICAgICA6IChkZWNvckludmFkaW5nID4gMFxuICAgICAgICAgICAgICAgID8gXCJzaW5nbGVDZW50ZXJlZFRleHRDb2x1bW5EZWNvckludmFkZXNcIlxuICAgICAgICAgICAgICAgIDogKGRlY29yQXJvdW5kXG4gICAgICAgICAgICAgICAgICA/IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uV2l0aERlY29yXCJcbiAgICAgICAgICAgICAgICAgIDogXCJzaW5nbGVDZW50ZXJlZFRleHRDb2x1bW5cIikpXG4gICAgICAgICAgKVxuICAgICAgICAgIDogXCJub0hlcm9TaWduYWxcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0SW5saW5lUGFpck5vUmVmbG93KGZsb3dJdGVtcywgYWxsSXRlbXMsIHJvb3RXLCBDRkcpe1xuICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgIHNraXA6IGZhbHNlLFxuICAgICAgICAgIHJlYXNvbjogXCJcIixcbiAgICAgICAgICB0b3RhbEZsb3c6IGZsb3dJdGVtcyA/IGZsb3dJdGVtcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHRvdGFsQWxsOiBhbGxJdGVtcyA/IGFsbEl0ZW1zLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcm93RGVsdGE6IG51bGwsXG4gICAgICAgICAgcm93VG9sOiBudWxsLFxuICAgICAgICAgIHBhaXJTcGFuOiBudWxsLFxuICAgICAgICAgIHBhaXJTcGFuUmF0aW86IG51bGwsXG4gICAgICAgICAgZml0c1RvZ2V0aGVyOiBmYWxzZSxcbiAgICAgICAgICBib3RoU21hbGw6IGZhbHNlLFxuICAgICAgICAgIHNtYWxsV0xpbWl0OiBudWxsLFxuICAgICAgICAgIHNtYWxsSExpbWl0OiBudWxsLFxuICAgICAgICAgIHdpZHRoczogW10sXG4gICAgICAgICAgaGVpZ2h0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFmbG93SXRlbXMgfHwgZmxvd0l0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhYWxsSXRlbXMgfHwgYWxsSXRlbXMubGVuZ3RoICE9PSAyIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90RXhhY3RQYWlyXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gZmxvd0l0ZW1zWzBdO1xuICAgICAgICB2YXIgYiA9IGZsb3dJdGVtc1sxXTtcbiAgICAgICAgdmFyIGFXID0gTWF0aC5tYXgoMCwgTnVtYmVyKGEud2lkdGggfHwgMCkpO1xuICAgICAgICB2YXIgYlcgPSBNYXRoLm1heCgwLCBOdW1iZXIoYi53aWR0aCB8fCAwKSk7XG4gICAgICAgIHZhciBhSCA9IE1hdGgubWF4KDAsIE51bWJlcihhLmhlaWdodCB8fCAwKSk7XG4gICAgICAgIHZhciBiSCA9IE1hdGgubWF4KDAsIE51bWJlcihiLmhlaWdodCB8fCAwKSk7XG4gICAgICAgIG91dC53aWR0aHMgPSBbK2FXLnRvRml4ZWQoMSksICtiVy50b0ZpeGVkKDEpXTtcbiAgICAgICAgb3V0LmhlaWdodHMgPSBbK2FILnRvRml4ZWQoMSksICtiSC50b0ZpeGVkKDEpXTtcblxuICAgICAgICBpZiAoYVcgPCAyIHx8IGJXIDwgMiB8fCBhSCA8IDIgfHwgYkggPCAyKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiaW52YWxpZFNpemVzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3dUb2wgPSBNYXRoLm1heCgxMiwgTnVtYmVyKChDRkcgJiYgQ0ZHLlJPV19UT0wpIHx8IDI4KSAqIDEuMik7XG4gICAgICAgIHZhciByb3dEZWx0YSA9IE1hdGguYWJzKE51bWJlcihhLnRvcCB8fCAwKSAtIE51bWJlcihiLnRvcCB8fCAwKSk7XG4gICAgICAgIG91dC5yb3dUb2wgPSArcm93VG9sLnRvRml4ZWQoMSk7XG4gICAgICAgIG91dC5yb3dEZWx0YSA9ICtyb3dEZWx0YS50b0ZpeGVkKDEpO1xuICAgICAgICBpZiAocm93RGVsdGEgPiByb3dUb2wpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub3RJbmxpbmVSb3dcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNtYWxsV0xpbWl0ID0gTWF0aC5tYXgoNzQsIHJvb3RXICogMC40Mik7XG4gICAgICAgIHZhciBzbWFsbEhMaW1pdCA9IE1hdGgubWF4KDM0LCByb290VyAqIDAuMik7XG4gICAgICAgIG91dC5zbWFsbFdMaW1pdCA9ICtzbWFsbFdMaW1pdC50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQuc21hbGxITGltaXQgPSArc21hbGxITGltaXQudG9GaXhlZCgxKTtcbiAgICAgICAgdmFyIGJvdGhTbWFsbCA9XG4gICAgICAgICAgYVcgPD0gc21hbGxXTGltaXQgJiZcbiAgICAgICAgICBiVyA8PSBzbWFsbFdMaW1pdCAmJlxuICAgICAgICAgIGFIIDw9IHNtYWxsSExpbWl0ICYmXG4gICAgICAgICAgYkggPD0gc21hbGxITGltaXQ7XG4gICAgICAgIG91dC5ib3RoU21hbGwgPSBib3RoU21hbGw7XG4gICAgICAgIGlmICghYm90aFNtYWxsKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwicGFpck5vdFNtYWxsXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWlyTGVmdCA9IE1hdGgubWluKE51bWJlcihhLmxlZnQgfHwgMCksIE51bWJlcihiLmxlZnQgfHwgMCkpO1xuICAgICAgICB2YXIgcGFpclJpZ2h0ID0gTWF0aC5tYXgoTnVtYmVyKGEubGVmdCB8fCAwKSArIGFXLCBOdW1iZXIoYi5sZWZ0IHx8IDApICsgYlcpO1xuICAgICAgICB2YXIgcGFpclNwYW4gPSBNYXRoLm1heCgwLCBwYWlyUmlnaHQgLSBwYWlyTGVmdCk7XG4gICAgICAgIHZhciBmaXRzVG9nZXRoZXIgPSBwYWlyU3BhbiA8PSAocm9vdFcgKyAxKTtcbiAgICAgICAgb3V0LnBhaXJTcGFuID0gK3BhaXJTcGFuLnRvRml4ZWQoMSk7XG4gICAgICAgIG91dC5wYWlyU3BhblJhdGlvID0gKyhwYWlyU3BhbiAvIE1hdGgubWF4KDEsIHJvb3RXKSkudG9GaXhlZCgzKTtcbiAgICAgICAgb3V0LmZpdHNUb2dldGhlciA9IGZpdHNUb2dldGhlcjtcblxuICAgICAgICBpZiAoZml0c1RvZ2V0aGVyKSB7XG4gICAgICAgICAgb3V0LnNraXAgPSB0cnVlO1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcInNtYWxsSW5saW5lUGFpckZpdHNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LnJlYXNvbiA9IFwic21hbGxJbmxpbmVQYWlyT3ZlcmZsb3dcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5mb3JjZUlubGluZVBhaXJHYXAoZmxvd0l0ZW1zLCByb290RWwsIHJvb3RXKXtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICBhcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgbWluR2FwOiA2LFxuICAgICAgICAgIGdhcEJlZm9yZTogbnVsbCxcbiAgICAgICAgICBnYXBBZnRlcjogbnVsbCxcbiAgICAgICAgICBuZWVkOiBudWxsLFxuICAgICAgICAgIG1vdmVMZWZ0OiAwLFxuICAgICAgICAgIG1vdmVSaWdodDogMCxcbiAgICAgICAgICBvdmVyZmxvd0JlZm9yZTogZmFsc2UsXG4gICAgICAgICAgb3ZlcmZsb3dBZnRlcjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJvb3RQYWRMZWZ0ID0gMDtcbiAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgIHZhciByb290Q1MgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbCk7XG4gICAgICAgICAgcm9vdFBhZExlZnQgPSBwYXJzZUZsb2F0KHJvb3RDUy5wYWRkaW5nTGVmdCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsb3dJdGVtcyB8fCBmbG93SXRlbXMubGVuZ3RoICE9PSAyIHx8ICFyb290RWwgfHwgIXJvb3RXIHx8IHJvb3RXIDw9IDApIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub3RFeGFjdFBhaXJcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBmbG93SXRlbXNbMF07XG4gICAgICAgIHZhciBiID0gZmxvd0l0ZW1zWzFdO1xuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgIWEubm9kZSB8fCAhYi5ub2RlKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibWlzc2luZ05vZGVzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0SXRlbSA9IE51bWJlcihhLmxlZnQgfHwgMCkgPD0gTnVtYmVyKGIubGVmdCB8fCAwKSA/IGEgOiBiO1xuICAgICAgICB2YXIgcmlnaHRJdGVtID0gKGxlZnRJdGVtID09PSBhKSA/IGIgOiBhO1xuXG4gICAgICAgIHZhciByckwgPSByZWxSZWN0KGxlZnRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciByclIgPSByZWxSZWN0KHJpZ2h0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgbExlZnQgPSBOdW1iZXIocnJMLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciBsVyA9IE51bWJlcihyckwud2lkdGggfHwgMCk7XG4gICAgICAgIHZhciByTGVmdCA9IE51bWJlcihyclIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIHJXID0gTnVtYmVyKHJyUi53aWR0aCB8fCAwKTtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsTGVmdCkgfHwgIWlzRmluaXRlKGxXKSB8fCAhaXNGaW5pdGUockxlZnQpIHx8ICFpc0Zpbml0ZShyVykpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJpbnZhbGlkUmVjdHNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdhcEJlZm9yZSA9IHJMZWZ0IC0gKGxMZWZ0ICsgbFcpO1xuICAgICAgICBvdXQuZ2FwQmVmb3JlID0gK2dhcEJlZm9yZS50b0ZpeGVkKDIpO1xuICAgICAgICBvdXQub3ZlcmZsb3dCZWZvcmUgPSAobExlZnQgPCAtMC41KSB8fCAoKHJMZWZ0ICsgclcpID4gKHJvb3RXICsgMC41KSk7XG5cbiAgICAgICAgdmFyIG5lZWQgPSBNYXRoLm1heCgwLCBvdXQubWluR2FwIC0gZ2FwQmVmb3JlKTtcbiAgICAgICAgb3V0Lm5lZWQgPSArbmVlZC50b0ZpeGVkKDIpO1xuICAgICAgICBpZiAobmVlZCA8PSAwLjI1KSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiYWxyZWFkeVNwYWNlZFwiO1xuICAgICAgICAgIG91dC5nYXBBZnRlciA9IG91dC5nYXBCZWZvcmU7XG4gICAgICAgICAgb3V0Lm92ZXJmbG93QWZ0ZXIgPSBvdXQub3ZlcmZsb3dCZWZvcmU7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdmFpbFJpZ2h0ID0gTWF0aC5tYXgoMCwgcm9vdFcgLSAockxlZnQgKyByVykpO1xuICAgICAgICB2YXIgYXZhaWxMZWZ0ID0gTWF0aC5tYXgoMCwgbExlZnQpO1xuICAgICAgICB2YXIgbW92ZVJpZ2h0ID0gTWF0aC5taW4oYXZhaWxSaWdodCwgbmVlZCk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBNYXRoLm1heCgwLCBuZWVkIC0gbW92ZVJpZ2h0KTtcbiAgICAgICAgdmFyIG1vdmVMZWZ0ID0gTWF0aC5taW4oYXZhaWxMZWZ0LCByZW1haW5pbmcpO1xuXG4gICAgICAgIGlmIChtb3ZlUmlnaHQgPD0gMC4wMSAmJiBtb3ZlTGVmdCA8PSAwLjAxKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9Sb29tVG9BZGp1c3RcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmVSaWdodCA+IDAuMDEpIHtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5sZWZ0ID0gKChOdW1iZXIocmlnaHRJdGVtLmxlZnQgfHwgMCkgKyBtb3ZlUmlnaHQpIC0gcm9vdFBhZExlZnQpICsgXCJweFwiO1xuICAgICAgICAgIHJpZ2h0SXRlbS5ub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgcmlnaHRJdGVtLm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVMZWZ0ID4gMC4wMSkge1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUubGVmdCA9ICgoTnVtYmVyKGxlZnRJdGVtLmxlZnQgfHwgMCkgLSBtb3ZlTGVmdCkgLSByb290UGFkTGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgbGVmdEl0ZW0ubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnJMMiA9IHJlbFJlY3QobGVmdEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIHJyUjIgPSByZWxSZWN0KHJpZ2h0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgbExlZnQyID0gTnVtYmVyKHJyTDIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIGxXMiA9IE51bWJlcihyckwyLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgckxlZnQyID0gTnVtYmVyKHJyUjIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIHJXMiA9IE51bWJlcihyclIyLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgZ2FwQWZ0ZXIgPSByTGVmdDIgLSAobExlZnQyICsgbFcyKTtcblxuICAgICAgICBvdXQubW92ZVJpZ2h0ID0gK21vdmVSaWdodC50b0ZpeGVkKDIpO1xuICAgICAgICBvdXQubW92ZUxlZnQgPSArbW92ZUxlZnQudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0LmdhcEFmdGVyID0gaXNGaW5pdGUoZ2FwQWZ0ZXIpID8gK2dhcEFmdGVyLnRvRml4ZWQoMikgOiBudWxsO1xuICAgICAgICBvdXQub3ZlcmZsb3dBZnRlciA9IChsTGVmdDIgPCAtMC41KSB8fCAoKHJMZWZ0MiArIHJXMikgPiAocm9vdFcgKyAwLjUpKTtcbiAgICAgICAgb3V0LmFwcGxpZWQgPSAobW92ZVJpZ2h0ID4gMC4wMSB8fCBtb3ZlTGVmdCA+IDAuMDEpO1xuICAgICAgICBvdXQucmVhc29uID0gb3V0LmFwcGxpZWQgPyBcImFwcGxpZWRcIiA6IFwibm9DaGFuZ2VcIjtcbiAgICAgICAgaWYgKGlzRmluaXRlKGdhcEFmdGVyKSAmJiBnYXBBZnRlciA8IC0wLjIpIG91dC5yZWFzb24gPSBcImFwcGxpZWRCdXRTdGlsbE92ZXJsYXBcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pbmVudE5vblRleHRDb3VudCA9IGl0ZW1zQWxsLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICAgIGlmICgoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgdyA9IE51bWJlcihpdC53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIGggPSBOdW1iZXIoaXQuaGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAodyA8IE1hdGgubWF4KDEwLCBjb250ZW50VyAqIDAuMDYpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChoIDwgTWF0aC5tYXgoMTAsIGNvbnRlbnRXICogMC4wNCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KS5sZW5ndGg7XG4gICAgICB2YXIgYWxsb3dIZXVyaXN0aWNBbmNob3JzID0gcHJvbWluZW50Tm9uVGV4dENvdW50IDw9IDE7XG5cbiAgICAgIC8vIOKchSBEZXRlcm1pbmFyIHF1w6kgbm9kb3Mgc29uIFwiQU5DSE9SXCIgKG5vIHNlIHJlZmxvd2VhbilcbiAgICAgIC8vIFJlZ2xhOiB0ZXh0byBjZW50cmFkbyArIGNhc2kgZnVsbC13aWR0aCA9PiB0w610dWxvL2hlcm8sIG5vIG1vdmVyLlxuICAgICAgZnVuY3Rpb24gaXNBbmNob3JOb2RlKGl0KXtcbiAgICAgICAgdmFyIG5vZGUgPSBpdC5ub2RlO1xuXHJcbiAgICAgICAgLy8gb3B0LW91dCBleHBsw61jaXRvXHJcbiAgICAgICAgdmFyIGtlZXBMYXlvdXQgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1sYXlvdXRcIikgfHwgXCJcIikgPT09IFwia2VlcFwiO1xyXG4gICAgICAgIGlmIChrZWVwTGF5b3V0KSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gYW5jaG9yIGV4cGzDrWNpdG8gKHNpIGxvIHVzw6FzKVxyXG4gICAgICAgIHZhciByb2xlID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiKTtcclxuICAgICAgICBpZiAocm9sZSA9PT0gXCJhbmNob3JcIikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIGhldXLDrXN0aWNhIHBhcmEgdGV4dG9zXG4gICAgICAgIHZhciBpc1RleHQgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgaWYgKCFpc1RleHQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhbGxvd0hldXJpc3RpY0FuY2hvcnMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgdGEgPSAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlLnRleHRBbGlnbikgPyBTdHJpbmcobm9kZS5zdHlsZS50ZXh0QWxpZ24pLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xuICAgICAgICBpZiAoIXRhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhID0gU3RyaW5nKGdldENvbXB1dGVkU3R5bGUobm9kZSkudGV4dEFsaWduIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfSBjYXRjaChfZSkge31cbiAgICAgICAgfVxuICAgICAgICBpZiAodGEgIT09IFwiY2VudGVyXCIpIHJldHVybiBmYWxzZTtcblxyXG4gICAgICAgIC8vIHNvbG8gc2kgcmVhbG1lbnRlIG9jdXBhIGNhc2kgdG9kbyBlbCBhbmNobyB1c2FibGVcclxuICAgICAgICAvLyAoZXN0byBldml0YSByb21wZXIgdGV4dG9zIGNlbnRyYWRvcyBkZW50cm8gZGUgY29sdW1uYXMpXHJcbiAgICAgICAgaWYgKGNvbnRlbnRXID4gMCAmJiBpdC53aWR0aCA+PSBjb250ZW50VyAqIDAuNzgpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIOKchSBGbG93ID0gdG9kbyBsbyBxdWUgTk8gZXMgYW5jaG9yXG4gICAgICB2YXIgaXRlbXNGbG93ID0gaXRlbXNBbGwuZmlsdGVyKGZ1bmN0aW9uKGl0KXsgcmV0dXJuICFpc0FuY2hvck5vZGUoaXQpOyB9KTtcbiAgICAgIHZhciBpdGVtc0FuY2hvciA9IGl0ZW1zQWxsLmZpbHRlcihmdW5jdGlvbihpdCl7IHJldHVybiBpc0FuY2hvck5vZGUoaXQpOyB9KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246YW5jaG9yU3BsaXRcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIGFuY2hvcnM6IGl0ZW1zQW5jaG9yLmxlbmd0aCxcbiAgICAgICAgZmxvdzogaXRlbXNGbG93Lmxlbmd0aCxcbiAgICAgICAgcHJvbWluZW50Tm9uVGV4dENvdW50OiBwcm9taW5lbnROb25UZXh0Q291bnQsXG4gICAgICAgIGFsbG93SGV1cmlzdGljQW5jaG9yczogYWxsb3dIZXVyaXN0aWNBbmNob3JzLFxuICAgICAgICBhbmNob3JzRGV0YWlsOiBpdGVtc0FuY2hvci5tYXAoZnVuY3Rpb24oaXQpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIiA/IFwidGV4dG9cIiA6IChpdC5ub2RlLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHRvcDogK2l0LnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgbGVmdDogK2l0LmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtpdC53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK2l0LmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAoaXQubm9kZS5zdHlsZSAmJiBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbikgPyBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbiA6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cclxuICAgICAgLy8gU2kgbm8gaGF5IHN1ZmljaWVudGVzIGVsZW1lbnRvcyByZWZsb3dhYmxlcywgbm8gaGFjZW1vcyBuYWRhXG4gICAgICBpZihpdGVtc0Zsb3cubGVuZ3RoIDwgMikge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6Zmxvd1Rvb1NtYWxsXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aCxcbiAgICAgICAgICBhbmNob3JDb3VudDogaXRlbXNBbmNob3IubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxyXG4gICAgICAvLyDinIUgUGFyYSBxdWUgXCJhbHR1cmEgbmVjZXNhcmlhXCIgbm8gcXVlZGUgY29ydGEsXHJcbiAgICAgIC8vIG1lZGltb3MgZWwgYm90dG9tIG3DoXhpbW8gZGUgYW5jaG9ycyAoZW4gY29vcmRzIGRlbCBjb250ZW50KVxyXG4gICAgICB2YXIgbWF4QW5jaG9yQm90dG9tID0gMDtcclxuICAgICAgaXRlbXNBbGwuZm9yRWFjaChmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgaWYgKCFpc0FuY2hvck5vZGUoaXQpKSByZXR1cm47XHJcbiAgICAgICAgdmFyIGIgPSAoaXQudG9wIHx8IDApICsgKGl0LmhlaWdodCB8fCAwKTtcclxuICAgICAgICBpZiAoYiA+IG1heEFuY2hvckJvdHRvbSkgbWF4QW5jaG9yQm90dG9tID0gYjtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyDinIUgMSkgYWdydXBhciBwb3Igc29sYXBlIOKGkiBjbHVzdGVycyAoU09MTyBGTE9XKVxuICAgICAgdmFyIGNsdXN0ZXJzID0gYnVpbGRPdmVybGFwQ2x1c3RlcnMoaXRlbXNGbG93KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246Y2x1c3RlcnNcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIGNvdW50OiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycy5tYXAoZnVuY3Rpb24oYywgaWR4KXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTogaWR4LFxuICAgICAgICAgICAgdG9wOiArYy50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtjLmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGN4OiArYy5jeC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyDinIUgMikgRGV0ZWN0YXIgY29sdW1uYXMvcm93cyAoU09MTyBGTE9XKVxuICAgICAgdmFyIHJvb3RXID0gY29udGVudFcgfHwgMDtcbiAgICAgIHZhciBvcmQgPSBvcmRlckNsdXN0ZXJzRm9yTW9iaWxlKGNsdXN0ZXJzLCByb290VywgQ0ZHKTtcbiAgICAgIHZhciBncm91cHMgPSBvcmQuZ3JvdXBzO1xuICAgICAgdmFyIG1vZGUgPSBvcmQubW9kZTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246b3JkZXJpbmdcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHJvb3RXOiByb290VyxcbiAgICAgICAgZ3JvdXBzOiBncm91cHMubWFwKGZ1bmN0aW9uKGdycCwgZ2kpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnOiBnaSxcbiAgICAgICAgICAgIGNvdW50OiBncnAubGVuZ3RoLFxuICAgICAgICAgICAgdG9wczogZ3JwLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLnRvcC50b0ZpeGVkKDEpOyB9KSxcbiAgICAgICAgICAgIGxlZnRzOiBncnAubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MubGVmdC50b0ZpeGVkKDEpOyB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgdmFyIGhlcm9TaWduYWwgPSBkZXRlY3RIZXJvTGlrZUNlbnRyYWxUZXh0KGl0ZW1zQWxsLCByb290Vyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmhlcm9DaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgaXNIZXJvOiBoZXJvU2lnbmFsLmlzSGVybyxcbiAgICAgICAgcmVhc29uOiBoZXJvU2lnbmFsLnJlYXNvbixcbiAgICAgICAgdGV4dENvdW50OiBoZXJvU2lnbmFsLnRleHRDb3VudCxcbiAgICAgICAgdGV4dENvbHVtbkNvdW50OiBoZXJvU2lnbmFsLnRleHRDb2x1bW5Db3VudCxcbiAgICAgICAgc2luZ2xlVGV4dENvbHVtbjogaGVyb1NpZ25hbC5zaW5nbGVUZXh0Q29sdW1uLFxuICAgICAgICB0ZXh0Q29sdW1uczogaGVyb1NpZ25hbC50ZXh0Q29sdW1ucyxcbiAgICAgICAgbWF4VGV4dFdpZHRoUmF0aW86IGhlcm9TaWduYWwubWF4VGV4dFdpZHRoUmF0aW8sXG4gICAgICAgIHdpZHRoUmF0aW86IGhlcm9TaWduYWwud2lkdGhSYXRpbyxcbiAgICAgICAgY2VudGVyRGVsdGE6IGhlcm9TaWduYWwuY2VudGVyRGVsdGEsXG4gICAgICAgIGNlbnRlclRvbDogaGVyb1NpZ25hbC5jZW50ZXJUb2wsXG4gICAgICAgIGNlbnRlcmVkQnlBbGlnbjogaGVyb1NpZ25hbC5jZW50ZXJlZEJ5QWxpZ24sXG4gICAgICAgIGNlbnRlcmVkQnlHZW9tZXRyeTogaGVyb1NpZ25hbC5jZW50ZXJlZEJ5R2VvbWV0cnksXG4gICAgICAgIGRlY29yTmVhcjogaGVyb1NpZ25hbC5kZWNvck5lYXIsXG4gICAgICAgIGRlY29yTGVmdDogaGVyb1NpZ25hbC5kZWNvckxlZnQsXG4gICAgICAgIGRlY29yUmlnaHQ6IGhlcm9TaWduYWwuZGVjb3JSaWdodCxcbiAgICAgICAgZGVjb3JJbnZhZGluZ1RleHRDb2x1bW46IGhlcm9TaWduYWwuZGVjb3JJbnZhZGluZ1RleHRDb2x1bW5cbiAgICAgIH0pO1xuICAgICAgaWYgKGhlcm9TaWduYWwuaXNIZXJvKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpoZXJvQ2VudHJhbFRleHRcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBoZXJvUmVhc29uOiBoZXJvU2lnbmFsLnJlYXNvbixcbiAgICAgICAgICBoZXJvOiBoZXJvU2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlubGluZVBhaXJTaWduYWwgPSBkZXRlY3RJbmxpbmVQYWlyTm9SZWZsb3coaXRlbXNGbG93LCBpdGVtc0FsbCwgcm9vdFcsIENGRyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmlubGluZVBhaXJDaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgc2tpcDogaW5saW5lUGFpclNpZ25hbC5za2lwLFxuICAgICAgICByZWFzb246IGlubGluZVBhaXJTaWduYWwucmVhc29uLFxuICAgICAgICB0b3RhbEZsb3c6IGlubGluZVBhaXJTaWduYWwudG90YWxGbG93LFxuICAgICAgICB0b3RhbEFsbDogaW5saW5lUGFpclNpZ25hbC50b3RhbEFsbCxcbiAgICAgICAgcm93RGVsdGE6IGlubGluZVBhaXJTaWduYWwucm93RGVsdGEsXG4gICAgICAgIHJvd1RvbDogaW5saW5lUGFpclNpZ25hbC5yb3dUb2wsXG4gICAgICAgIHdpZHRoczogaW5saW5lUGFpclNpZ25hbC53aWR0aHMsXG4gICAgICAgIGhlaWdodHM6IGlubGluZVBhaXJTaWduYWwuaGVpZ2h0cyxcbiAgICAgICAgYm90aFNtYWxsOiBpbmxpbmVQYWlyU2lnbmFsLmJvdGhTbWFsbCxcbiAgICAgICAgc21hbGxXTGltaXQ6IGlubGluZVBhaXJTaWduYWwuc21hbGxXTGltaXQsXG4gICAgICAgIHNtYWxsSExpbWl0OiBpbmxpbmVQYWlyU2lnbmFsLnNtYWxsSExpbWl0LFxuICAgICAgICBwYWlyU3BhbjogaW5saW5lUGFpclNpZ25hbC5wYWlyU3BhbixcbiAgICAgICAgcGFpclNwYW5SYXRpbzogaW5saW5lUGFpclNpZ25hbC5wYWlyU3BhblJhdGlvLFxuICAgICAgICBmaXRzVG9nZXRoZXI6IGlubGluZVBhaXJTaWduYWwuZml0c1RvZ2V0aGVyXG4gICAgICB9KTtcbiAgICAgIGlmIChpbmxpbmVQYWlyU2lnbmFsLnNraXApIHtcbiAgICAgICAgdmFyIGlubGluZVBhaXJBZGp1c3QgPSBlbmZvcmNlSW5saW5lUGFpckdhcChpdGVtc0Zsb3csIGNvbnRlbnQsIHJvb3RXKTtcbiAgICAgICAgbXNsTG9nKFwic2VjdGlvbjppbmxpbmVQYWlyQWRqdXN0XCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBhZGp1c3Q6IGlubGluZVBhaXJBZGp1c3RcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpzbWFsbElubGluZVBhaXJGaXRzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgaW5saW5lUGFpcjogaW5saW5lUGFpclNpZ25hbCxcbiAgICAgICAgICBpbmxpbmVQYWlyQWRqdXN0OiBpbmxpbmVQYWlyQWRqdXN0XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8g4pyFIDMpIEdhdGUgXCJtZWpvciBkZSBhbWJvcyBtdW5kb3NcIjpcbiAgICAgIC8vIC0gU2kgZXMgXCJvbmVcIiAobGF5b3V0IHlhIG5hdHVyYWwpIFkgYWRlbcOhcyBlbnRyYSwgTk8gaGFjZW1vcyByZWZsb3cuXG4gICAgICAvLyAtIEVuIGN1YWxxdWllciBvdHJvIGNhc28gKHR3by90aHJlZS9yb3dzKSwgaGFjZW1vcyByZWZsb3cgcGFyYSBsZWN0dXJhIG1vYmlsZSxcbiAgICAgIC8vICAgaW5jbHVzbyBhdW5xdWUgXCJlbnRyZVwiLlxyXG4gICAgICB2YXIgZml0cyA9IGNsdXN0ZXJzRml0SW5Nb2JpbGUoY2x1c3RlcnMsIGNvbnRlbnQpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpmaXRDaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgd2lsbFNraXA6IChtb2RlID09PSBcIm9uZVwiICYmIGZpdHMpXG4gICAgICB9KTtcbiAgICAgIGlmIChtb2RlID09PSBcIm9uZVwiICYmIGZpdHMpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOm1vZGVPbmVGaXRzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwiYXBwbHk6bW9kZVJlcXVpcmVzUmVmbG93XCIsIHtcbiAgICAgICAgd2lsbEFwcGx5UmVmbG93OiB0cnVlLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBmaXRzOiBmaXRzLFxuICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgIGFuY2hvckNvdW50OiBpdGVtc0FuY2hvci5sZW5ndGgsXG4gICAgICAgIGdyb3VwU2l6ZXM6IGdyb3Vwcy5tYXAoZnVuY3Rpb24oZ3JwKXsgcmV0dXJuIGdycC5sZW5ndGg7IH0pXG4gICAgICB9KTtcblxuICAgICAgLy8g4pyFIDQpIFJlZmxvdyBzb2xvIHNvYnJlIEZMT1cgKHByZXNlcnZhIHNvbGFwZXMgZGVudHJvIGRlIGNhZGEgY2x1c3RlcilcbiAgICAgIHZhciByZXMgPSBhcHBseUNsdXN0ZXJTdGFjayhncm91cHMsIGNvbnRlbnQsIENGRywgbW9kZSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmFwcGx5UmVzdWx0XCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjaGFuZ2VkOiAhIShyZXMgJiYgcmVzLmNoYW5nZWQpLFxuICAgICAgICBuZWVkZWRIZWlnaHQ6IHJlcyA/IHJlcy5uZWVkZWRIZWlnaHQgOiBudWxsLFxuICAgICAgICBtYXhBbmNob3JCb3R0b206ICttYXhBbmNob3JCb3R0b20udG9GaXhlZCgxKSxcbiAgICAgICAgYmFzZUJvdHRvbUdhcDogK2Jhc2VCb3R0b21HYXAudG9GaXhlZCgxKVxuICAgICAgfSk7XG4gICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInBvc3RBcHBseVwiLCB7XG4gICAgICAgIHdpbGxBcHBseVJlZmxvdzogdHJ1ZSxcbiAgICAgICAgY2hhbmdlZDogISEocmVzICYmIHJlcy5jaGFuZ2VkKSxcbiAgICAgICAgbmVlZGVkSGVpZ2h0OiByZXMgPyArTnVtYmVyKHJlcy5uZWVkZWRIZWlnaHQgfHwgMCkudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbmVlZGVkQWZ0ZXJSZWZsb3cgPSAwO1xuICAgICAgaWYgKHJlcyAmJiByZXMuY2hhbmdlZCkge1xuICAgICAgICAvLyBFdml0YXIgcXVlIGxhIHNlY2Npw7NuIHF1ZWRlIGNoaWNhIHNpIGhheSBhbmNob3JzIG3DoXMgYWJham9cbiAgICAgICAgdmFyIG5lZWRlZCA9IE51bWJlcihyZXMubmVlZGVkSGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAoTnVtYmVyKG1heEFuY2hvckJvdHRvbSkgPiAwKSB7XG4gICAgICAgICAgLy8gc3VtYW1vcyBwYWRkaW5nIGJvdHRvbSBwYXJhIHF1ZSBubyBxdWVkZSBwZWdhZG9cbiAgICAgICAgICB2YXIgYW5jaG9yTmVlZGVkID0gTWF0aC5jZWlsKG1heEFuY2hvckJvdHRvbSArIChDRkcuUEFEX0JPVCB8fCAwKSk7XG4gICAgICAgICAgaWYgKGFuY2hvck5lZWRlZCA+IG5lZWRlZCkgbmVlZGVkID0gYW5jaG9yTmVlZGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlQm90dG9tR2FwID4gMCkge1xuICAgICAgICAgIG5lZWRlZCA9IE1hdGguY2VpbChuZWVkZWQgKyBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZGVkID4gMCkgbmVlZGVkQWZ0ZXJSZWZsb3cgPSBuZWVkZWQ7XG4gICAgICB9XG4gICAgICBmaW5hbGl6ZVNlY3Rpb24obmVlZGVkQWZ0ZXJSZWZsb3csIGJhc2VCb3R0b21HYXApO1xuICAgIH0pO1xuICB9XG5cclxuICBmdW5jdGlvbiBib290KCl7XG4gICAgbXNsTG9nKFwiYm9vdFwiLCB7IGNmZzogQ0ZHIH0pO1xuICAgIHJ1bk9uY2UoKTtcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDE1MCk7XHJcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDYwMCk7XHJcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDE4MDApO1xyXG5cclxuICAgIGlmKGRvY3VtZW50LmZvbnRzICYmIGRvY3VtZW50LmZvbnRzLnJlYWR5KXtcclxuICAgICAgZG9jdW1lbnQuZm9udHMucmVhZHkudGhlbihmdW5jdGlvbigpeyBydW5PbmNlKCk7IH0pLmNhdGNoKGZ1bmN0aW9uKCl7fSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYm9vdCk7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcnVuT25jZSk7XHJcblxyXG4gIGlmKHdpbmRvdy52aXN1YWxWaWV3cG9ydCl7XHJcbiAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBydW5PbmNlKTtcclxuICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHJ1bk9uY2UpO1xyXG4gIH1cclxuXHJcbiAgaWYoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIGJvb3QoKTtcclxuICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xyXG59KSgpO1xyXG48L3NjcmlwdD5cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzRG9tSGVscGVyc0Jsb2NrIiwianNGaXRTY2FsZUJsb2NrIiwianNPcmRlcmluZ0Jsb2NrIiwianNTdGFja2luZ0Jsb2NrIiwiYnVpbGRTY3JpcHQiLCJjZmciLCJlbmFibGVkIiwibWluR2FwUHgiLCJtYXhHYXBQeCIsImdhcFNjYWxlIiwicGFkZGluZ1RvcFB4IiwicGFkZGluZ0JvdHRvbVB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJmaXRNaW5TY2FsZSIsImZpdE1heFNjYWxlIiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpbyIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/stacking.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsStackingBlock: () => (/* binding */ jsStackingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/stacking.ts\nfunction jsStackingBlock() {\n    return `\n  // Centro real del área usable (compensa padding safe-left/right)\n  function computeCenterX(rootEl){\n    var rootRect = rootEl.getBoundingClientRect();\n    var rootW = rootRect.width || 0;\n\n    var cs = getComputedStyle(rootEl);\n    var padL = parseFloat(cs.paddingLeft) || 0;\n    var padR = parseFloat(cs.paddingRight) || 0;\n\n    var usableW = Math.max(0, rootW - padL - padR);\n    var centerX = padL + usableW / 2; // centro del área usable\n\n    return { rootW: rootW, usableW: usableW, centerX: centerX, padL: padL, padR: padR };\n  }\n\n  function clamp(n, a, b){\n    if (!isFinite(n)) return a;\n    return Math.max(a, Math.min(b, n));\n  }\n\n  /**\n   * Apila CLUSTERS por groups (columnas/filas) y:\n   * - mueve cada cluster como bloque\n   * - preserva solape/posiciones relativas dentro del cluster\n   * - centra el cluster como bloque en el eje X (sin transform)\n   *\n   * Devuelve changed + neededHeight (para expandir sección)\n   */\n  function applyClusterStack(groups, rootEl, CFG, mode){\n    var info = computeCenterX(rootEl);\n    var centerX = info.centerX;\n    mslLog(\"stack:start\", {\n      groupCount: groups.length,\n      groupSizes: groups.map(function(g){ return g.length; }),\n      centerX: +centerX.toFixed(1),\n      usableW: +info.usableW.toFixed(1)\n    });\n\n    var changed = false;\n    var isMultiColLayout = (mode === \"two\" || mode === \"three\");\n\n    // En multi-columna: cada columna apilada se centra por su propio bbox.\n    // Así, el centro de cada columna coincide con el centro de pantalla.\n\n    // --- Anchor global: dónde estaba “el bloque” originalmente ---\n    var firstGroup = groups[0] || [];\n    var anchor = Infinity;\n    for (var i=0;i<firstGroup.length;i++){\n      anchor = Math.min(anchor, firstGroup[i].top);\n    }\n    if (!isFinite(anchor)) anchor = CFG.PAD_TOP;\n    anchor = Math.max(CFG.PAD_TOP, anchor);\n\n    // Cursor global: dónde termina el contenido apilado hasta ahora\n    var globalCursor = anchor;\n\n    // Separación entre columnas apiladas (izq, centro, der)\n    var GROUP_GAP = 14;\n\n    for (var g=0; g<groups.length; g++){\n      var col = groups[g] || [];\n      if (!col.length) continue;\n      var colReferenceCenterX = NaN;\n      var colSourceReferenceCenterX = NaN;\n      var narrowClusterCount = 0;\n      var wideClusterCount = 0;\n\n      // Métricas por grupo solo para debug.\n      var groupMinLeft = Infinity;\n      var groupMaxRight = -Infinity;\n      if (isMultiColLayout){\n        for (var gg=0; gg<col.length; gg++){\n          groupMinLeft = Math.min(groupMinLeft, col[gg].left);\n          groupMaxRight = Math.max(groupMaxRight, col[gg].left + col[gg].width);\n          var clusterWDbg = Number(col[gg].width || 0);\n          if (clusterWDbg <= (info.usableW * 0.72)) narrowClusterCount++;\n          if (clusterWDbg >= (info.usableW * 0.88)) wideClusterCount++;\n        }\n      }\n      var groupWidth = isMultiColLayout ? Math.max(0, groupMaxRight - groupMinLeft) : 0;\n      var groupBaseLeft = isMultiColLayout ? (centerX - groupWidth / 2) : 0;\n      var suspiciousWideSpan = isMultiColLayout &&\n        col.length > 1 &&\n        groupWidth >= (info.usableW * 0.88) &&\n        narrowClusterCount >= 1 &&\n        wideClusterCount >= 1;\n      var preserveColumnOffsets = isMultiColLayout && !suspiciousWideSpan;\n\n      // Offset vertical original de esta columna respecto del anchor\n      var colMinTop = Infinity;\n      for (var k=0;k<col.length;k++){\n        colMinTop = Math.min(colMinTop, col[k].top);\n      }\n      if (!isFinite(colMinTop)) colMinTop = anchor;\n\n      var colOffset = colMinTop - anchor;\n      var colStart = globalCursor + (g === 0 ? 0 : GROUP_GAP) + Math.max(0, colOffset);\n      mslLog(\"stack:group:start\", {\n        g: g,\n        colSize: col.length,\n        colMinTop: +colMinTop.toFixed(1),\n        colOffset: +colOffset.toFixed(1),\n        colStart: +colStart.toFixed(1),\n        globalCursor: +globalCursor.toFixed(1),\n        mode: mode,\n        groupMinLeft: isMultiColLayout ? +groupMinLeft.toFixed(1) : null,\n        groupWidth: isMultiColLayout ? +groupWidth.toFixed(1) : null,\n        groupBaseLeft: isMultiColLayout ? +groupBaseLeft.toFixed(1) : null,\n        narrowClusterCount: isMultiColLayout ? narrowClusterCount : null,\n        wideClusterCount: isMultiColLayout ? wideClusterCount : null,\n        preserveColumnOffsets: isMultiColLayout ? preserveColumnOffsets : null\n      });\n\n      // Cursor local de esta columna\n      var colCursor = colStart;\n\n      for (var j=0; j<col.length; j++){\n        var c = col[j];\n\n        // Top del cluster en el flujo mobile\n        var clusterTop;\n\n        if (j === 0) {\n          clusterTop = colCursor;\n        } else {\n          var prevC = col[j-1];\n          var prevBottom = (clusterTopPrev + prevC.height);\n\n          // ✅ Gap original entre clusters (canvas)\n          var prevBottomOrig = (prevC.top + prevC.height);\n          var gapOrig = c.top - prevBottomOrig;\n          if (!isFinite(gapOrig)) gapOrig = 0;\n\n          var overlapInSource = gapOrig < 0;\n          if ((mode === \"two\" || mode === \"three\") && overlapInSource) {\n            // Si en el original este cluster cae dentro del anterior, respetamos\n            // su top relativo para no mandarlo al final de la columna.\n            var relTopInCol = c.top - colMinTop;\n            if (!isFinite(relTopInCol)) relTopInCol = 0;\n            clusterTop = colStart + Math.max(0, relTopInCol);\n          } else {\n            // ✅ Gap “mobile-friendly”: escalado + clamp\n            var gapWanted = clamp(gapOrig * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\n\n            // ✅ Anti-solape definitivo:\n            //   el próximo cluster SIEMPRE empieza después del bottom real del anterior + gapWanted\n            clusterTop = prevBottom + gapWanted;\n\n            // En multi-columna nunca avanzamos hacia arriba respecto al flujo ya consumido.\n            if ((mode === \"two\" || mode === \"three\") && clusterTop < colCursor) {\n              clusterTop = colCursor;\n            }\n          }\n        }\n\n        // Guardamos para el próximo loop\n        var clusterTopPrev = clusterTop;\n\n        // ¿centrar este cluster?\n        var forceCenter = false;\n        var hasTextInCluster = false;\n        var hasNonTextInCluster = false;\n        for (var t=0; t<c.items.length; t++){\n          var isTextT = (c.items[t].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          if (isTextT) hasTextInCluster = true;\n          else hasNonTextInCluster = true;\n          if ((c.items[t].node.getAttribute(\"data-mobile-center\") || \"\") === \"force\") {\n            forceCenter = true;\n          }\n        }\n\n        // one/rows: centro por cluster (comportamiento original)\n        // two/three: apilar cada columna en la misma referencia X,\n        // preservando offsets internos de esa columna.\n        var keepCenter = forceCenter ? true : (c.width < (info.usableW * 0.95));\n        var clusterLeft = keepCenter ? (centerX - c.width / 2) : c.left;\n        var isTextOnlyCluster = hasTextInCluster && !hasNonTextInCluster;\n        var shouldCenterTextWithinCluster = false;\n        if (isMultiColLayout) {\n          // Modo lectura mobile multi-col:\n          // usar una misma referencia X para toda la columna apilada y\n          // preservar el offset horizontal original de cada cluster.\n          // Esto mantiene alineado texto/forma cuando la columna se parte\n          // en varios clusters.\n          // Si el bbox de la columna queda contaminado por un outlier ancho\n          // (tipicamente texto), centrar por offsets deja la columna pegada\n          // al borde; en ese caso centramos cada cluster individualmente.\n          if (preserveColumnOffsets) {\n            var relClusterLeft = (c.left || 0) - (groupMinLeft || 0);\n            clusterLeft = groupBaseLeft + relClusterLeft;\n          } else {\n            clusterLeft = centerX - c.width / 2;\n          }\n\n          // Permite forzar centrado por cluster si el nodo lo pide.\n          if (forceCenter) clusterLeft = centerX - c.width / 2;\n\n          // Si esta columna tiene un cluster con forma (o mixto), usamos su\n          // centro como referencia para alinear clusters solo-texto debajo.\n          var clusterRefCenterX = NaN;\n          if (hasNonTextInCluster) {\n            // Referencia basada en items no-texto (forma/icono), no en todo el\n            // cluster, para que textos largos no desplacen el centro de columna.\n            var ntMinRel = Infinity;\n            var ntMaxRel = -Infinity;\n            for (var nti=0; nti<c.items.length; nti++){\n              var ntIt = c.items[nti];\n              var ntIsText = (ntIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              if (ntIsText) continue;\n              ntMinRel = Math.min(ntMinRel, (ntIt._relLeft || 0));\n              ntMaxRel = Math.max(ntMaxRel, (ntIt._relLeft || 0) + (ntIt.width || 0));\n            }\n            var sourceClusterRefCenterX = NaN;\n            if (isFinite(ntMinRel) && isFinite(ntMaxRel) && ntMaxRel > ntMinRel) {\n              clusterRefCenterX = clusterLeft + ((ntMinRel + ntMaxRel) / 2);\n              sourceClusterRefCenterX = (c.left || 0) + ((ntMinRel + ntMaxRel) / 2);\n            } else {\n              clusterRefCenterX = clusterLeft + c.width / 2;\n              sourceClusterRefCenterX = (c.left || 0) + c.width / 2;\n            }\n\n            colReferenceCenterX = clusterRefCenterX;\n            colSourceReferenceCenterX = sourceClusterRefCenterX;\n          }\n\n          if (isTextOnlyCluster && isFinite(colReferenceCenterX)) {\n            var maxSnapDelta = Math.min(120, info.usableW * 0.35);\n            var sourceClusterCenterX = (c.left || 0) + c.width / 2;\n            var sourceDriftX = isFinite(colSourceReferenceCenterX)\n              ? (sourceClusterCenterX - colSourceReferenceCenterX)\n              : NaN;\n            if (isFinite(sourceDriftX) && Math.abs(sourceDriftX) <= maxSnapDelta) {\n              clusterLeft = (colReferenceCenterX + sourceDriftX) - c.width / 2;\n            }\n            // Para labels cortos, centrar el contenido textual dentro del box.\n            shouldCenterTextWithinCluster = c.width <= (info.usableW * 0.65);\n          }\n\n          // Guard rail: en apilado multi-columna, un cluster no debe quedar\n          // desviado demasiado del eje central del layout mobile.\n          var clusterCenterXNow = clusterLeft + c.width / 2;\n          var maxCenterDrift = Math.max(24, info.usableW * 0.18);\n          if (Math.abs(clusterCenterXNow - centerX) > maxCenterDrift) {\n            mslLog(\"stack:cluster:centerFallback\", {\n              g: g,\n              j: j,\n              prevLeft: +clusterLeft.toFixed(1),\n              centerX: +centerX.toFixed(1),\n              clusterCenterX: +clusterCenterXNow.toFixed(1),\n              maxCenterDrift: +maxCenterDrift.toFixed(1),\n              clusterW: +(c.width || 0).toFixed(1)\n            });\n            clusterLeft = centerX - c.width / 2;\n          }\n        }\n        mslLog(\"stack:cluster\", {\n          g: g,\n          j: j,\n          origTop: +c.top.toFixed(1),\n          origLeft: +c.left.toFixed(1),\n          newTop: +clusterTop.toFixed(1),\n          newLeft: +clusterLeft.toFixed(1),\n          h: +c.height.toFixed(1),\n          w: +c.width.toFixed(1),\n          forceCenter: forceCenter,\n          keepCenter: keepCenter,\n          items: c.items.length,\n          colReferenceCenterX: (typeof colReferenceCenterX === \"number\" && isFinite(colReferenceCenterX)) ? +colReferenceCenterX.toFixed(1) : null,\n          isTextOnlyCluster: isTextOnlyCluster,\n          centerShortText: shouldCenterTextWithinCluster\n        });\n\n        var textCount = 0;\n        for (var tc=0; tc<c.items.length; tc++){\n          if ((c.items[tc].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textCount++;\n        }\n        var linearizeCluster = (mode === \"rows\" && c.items.length > 1 && textCount >= 2);\n        var clusterBottomUsed = clusterTop + c.height;\n\n        // Caso especial: en rows, si el cluster agrupa varios textos, lo\n        // convertimos a flujo vertical centrado para evitar texto lado a lado.\n        if (linearizeCluster){\n          var allItems = c.items.slice();\n          var nonText = allItems.filter(function(itx){\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\";\n          }).sort(function(a,b){\n            if (a.top !== b.top) return a.top - b.top;\n            return a.left - b.left;\n          });\n          var texts = allItems.filter(function(itx){\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          }).sort(function(a,b){\n            if (a.top !== b.top) return a.top - b.top;\n            return a.left - b.left;\n          });\n\n          // Orden semántico de lectura:\n          // no-texto + texto más cercano (debajo y por eje X), luego remanentes.\n          var ordered = [];\n          var usedText = {};\n\n          for (var nt=0; nt<nonText.length; nt++){\n            var ntItem = nonText[nt];\n            ordered.push(ntItem);\n\n            var ntCx = (ntItem.left || 0) + (ntItem.width || 0) / 2;\n            var ntBottom = (ntItem.top || 0) + (ntItem.height || 0);\n            var bestIdxTxt = -1;\n            var bestScore = Infinity;\n\n            for (var tx=0; tx<texts.length; tx++){\n              if (usedText[tx]) continue;\n              var tItem = texts[tx];\n              var tCx = (tItem.left || 0) + (tItem.width || 0) / 2;\n              var vGapTxt = (tItem.top || 0) - ntBottom; // preferir texto debajo\n              var hDistTxt = Math.abs(tCx - ntCx);\n              var penaltyAbove = vGapTxt < -2 ? 10000 : 0;\n              var score = penaltyAbove + Math.abs(vGapTxt) * 2 + hDistTxt;\n              if (score < bestScore){\n                bestScore = score;\n                bestIdxTxt = tx;\n              }\n            }\n\n            if (bestIdxTxt >= 0){\n              ordered.push(texts[bestIdxTxt]);\n              usedText[bestIdxTxt] = true;\n            }\n          }\n\n          // Textos no emparejados\n          for (var tx2=0; tx2<texts.length; tx2++){\n            if (!usedText[tx2]) ordered.push(texts[tx2]);\n          }\n\n          // Si no hubo no-texto, fallback simple por top/left\n          if (!ordered.length) {\n            ordered = allItems.sort(function(a,b){\n              if (a.top !== b.top) return a.top - b.top;\n              return a.left - b.left;\n            });\n          }\n\n          var localCursor = clusterTop;\n          var prevIt = null;\n          var prevTopApplied = clusterTop;\n          var EXTRA_COL_BREAK_GAP = 8;\n\n          for (var li=0; li<ordered.length; li++){\n            var lit = ordered[li];\n\n            var keepLayoutLin = (lit.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n            if (keepLayoutLin) continue;\n\n            var newTopLin = localCursor;\n            if (prevIt){\n              var gapOrigLin = lit.top - (prevIt.top + prevIt.height);\n              if (!isFinite(gapOrigLin)) gapOrigLin = 0;\n              var gapWantedLin = clamp(gapOrigLin * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\n              var prevIsTextLin = (prevIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              var currIsTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              // Al pasar de \"texto final de columna\" a \"nuevo no-texto\" agregamos aire.\n              if (prevIsTextLin && !currIsTextLin) gapWantedLin += EXTRA_COL_BREAK_GAP;\n              newTopLin = prevTopApplied + prevIt.height + gapWantedLin;\n            }\n\n            var newLeftLin = centerX - (lit.width || 0) / 2;\n            var keepAlignLin = (lit.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\n            if (keepAlignLin) newLeftLin = lit.left;\n\n            if (Math.abs(newTopLin - lit.top) > 0.5 || Math.abs(newLeftLin - lit.left) > 0.5) changed = true;\n\n            // En rows linealizado, forzamos centrado visual real de texto.\n            var isTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n            if (isTextLin && !keepAlignLin) {\n              lit.node.style.textAlign = \"center\";\n              lit.node.style.transformOrigin = \"top center\";\n              lit.node.style.setProperty(\"--text-zoom\", \"1\");\n              var tfLin = lit.node.style.transform || \"\";\n              if (tfLin.indexOf(\"translateX(\") !== -1) {\n                lit.node.style.transform = tfLin.replace(/translateX\\([^)]*\\)/, \"translateX(0px)\");\n              }\n            }\n\n            var cssLeftLin = newLeftLin - (info.padL || 0);\n            lit.node.style.top = newTopLin + \"px\";\n            lit.node.style.left = cssLeftLin + \"px\";\n            lit.node.style.right = \"auto\";\n            lit.node.style.marginLeft = \"0px\";\n\n            prevIt = lit;\n            prevTopApplied = newTopLin;\n            localCursor = newTopLin + (lit.height || 0);\n            if (localCursor > clusterBottomUsed) clusterBottomUsed = localCursor;\n          }\n\n          colCursor = Math.max(colCursor, clusterBottomUsed);\n          continue;\n        }\n\n        // Aplicar a cada item preservando offsets relativos (solape intacto)\n        for (var ii=0; ii<c.items.length; ii++){\n          var it = c.items[ii];\n\n          // Opt-out total del layout (decoraciones, etc.)\n          var keepLayout = (it.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n          if (keepLayout) continue;\n\n          var newTop = clusterTop + (it._relTop || 0);\n          var newLeft = clusterLeft + (it._relLeft || 0);\n\n          // Opt-out de centrado (mantener left original del item)\n          var keepAlign = (it.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\n          if (keepAlign) newLeft = it.left;\n\n          // En multi-col, neutralizamos SIEMPRE translateX(...) de textos\n          // para que la posición left calculada sea la referencia visual real.\n          var isTextNode = (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          var isShortTextBox = false;\n          var shouldRecenterTextItem = false;\n          var centerByAlign = false;\n          var targetTextCenterX = NaN;\n          if (isTextNode && isMultiColLayout) {\n            var tf = it.node.style.transform || \"\";\n            if (tf.indexOf(\"translateX(\") !== -1) {\n              it.node.style.transform = tf.replace(/translateX\\([^)]*\\)/, \"translateX(0px)\");\n            }\n            isShortTextBox = (it.width || 0) <= (info.usableW * 0.5) && (it.height || 0) <= 42;\n            var taCurrent = ((it.node.style && it.node.style.textAlign) || \"\").toLowerCase();\n            centerByAlign = taCurrent === \"center\";\n            var shouldCenterVisualText =\n              (shouldCenterTextWithinCluster || isShortTextBox || centerByAlign) &&\n              !keepAlign;\n            shouldRecenterTextItem =\n              shouldCenterVisualText &&\n              isFinite(colReferenceCenterX);\n            if (shouldRecenterTextItem) {\n              var prevLeftTxt = newLeft;\n              var sourceItemCenterX = (it.left || 0) + (it.width || 0) / 2;\n              var sourceDriftItemX = isFinite(colSourceReferenceCenterX)\n                ? (sourceItemCenterX - colSourceReferenceCenterX)\n                : NaN;\n              var targetCenterX = colReferenceCenterX;\n              // En textos centrados (o labels cortos forzados al centro),\n              // no arrastramos drift horizontal del layout original para\n              // evitar corrimientos laterales en mobile.\n              var preserveSourceDrift =\n                !centerByAlign &&\n                !shouldCenterTextWithinCluster &&\n                !isShortTextBox;\n              if (preserveSourceDrift && isFinite(sourceDriftItemX)) {\n                targetCenterX += sourceDriftItemX;\n              }\n              targetTextCenterX = targetCenterX;\n              newLeft = targetCenterX - (it.width || 0) / 2;\n              if (Math.abs(newLeft - prevLeftTxt) > 0.5) {\n                mslLog(\"stack:item:textRecenter\", {\n                  g: g,\n                  j: j,\n                  ii: ii,\n                  prevLeft: +prevLeftTxt.toFixed(1),\n                  newLeft: +newLeft.toFixed(1),\n                  itemW: +(it.width || 0).toFixed(1),\n                  refCenterX: +colReferenceCenterX.toFixed(1),\n                  sourceRefCenterX: (typeof colSourceReferenceCenterX === \"number\" && isFinite(colSourceReferenceCenterX)) ? +colSourceReferenceCenterX.toFixed(1) : null,\n                  sourceDriftX: isFinite(sourceDriftItemX) ? +sourceDriftItemX.toFixed(1) : null,\n                  preserveSourceDrift: preserveSourceDrift,\n                  shortBox: isShortTextBox,\n                  centerByAlign: centerByAlign\n                });\n              }\n            }\n            if (shouldCenterVisualText) {\n              it.node.style.textAlign = \"center\";\n              it.node.style.transformOrigin = \"top center\";\n              // Evita encogimiento horizontal heredado que desplaza el centro visual.\n              it.node.style.setProperty(\"--text-zoom\", \"1\");\n            }\n          }\n\n          var cssLeft = newLeft - (info.padL || 0);\n          it.node.style.top = newTop + \"px\";\n          it.node.style.left = cssLeft + \"px\";\n          it.node.style.right = \"auto\";\n          it.node.style.marginLeft = \"0px\";\n\n          // Corrección final por posición renderizada real del texto\n          // (fuentes/transform pueden introducir desvíos visuales sub-píxel).\n          if (isTextNode && isMultiColLayout && shouldRecenterTextItem) {\n            var rrTxt = relRect(it.node, rootEl);\n            var renderedCenterX = (rrTxt.left || 0) + (rrTxt.width || 0) / 2;\n            var targetRenderCenterX = isFinite(targetTextCenterX) ? targetTextCenterX : colReferenceCenterX;\n            var renderDelta = renderedCenterX - targetRenderCenterX;\n            if (isFinite(renderDelta) && Math.abs(renderDelta) > 0.6) {\n              var correctedLeft = newLeft - renderDelta;\n              if (isFinite(correctedLeft)) {\n                mslLog(\"stack:item:textRenderAdjust\", {\n                  g: g,\n                  j: j,\n                  ii: ii,\n                  prevLeft: +newLeft.toFixed(1),\n                  correctedLeft: +correctedLeft.toFixed(1),\n                  renderedCenterX: +renderedCenterX.toFixed(1),\n                  refCenterX: +targetRenderCenterX.toFixed(1),\n                  delta: +renderDelta.toFixed(2)\n                });\n                newLeft = correctedLeft;\n                it.node.style.left = (newLeft - (info.padL || 0)) + \"px\";\n              }\n            }\n          }\n\n          if (Math.abs(newTop - it.top) > 0.5 || Math.abs(newLeft - it.left) > 0.5) changed = true;\n\n          var itemBottom = newTop + (it.height || 0);\n          if (itemBottom > clusterBottomUsed) clusterBottomUsed = itemBottom;\n        }\n\n        // Avanza el cursor local al final del cluster\n        colCursor = Math.max(colCursor, clusterBottomUsed);\n      }\n\n      // Al terminar la columna, el cursor global baja hasta donde llegó esta columna\n      globalCursor = Math.max(globalCursor, colCursor);\n    }\n\n    var needed = globalCursor + CFG.PAD_BOT;\n    mslLog(\"stack:end\", {\n      changed: changed,\n      neededHeight: +needed.toFixed(1),\n      finalCursor: +globalCursor.toFixed(1)\n    });\n    return { changed: changed, neededHeight: needed };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVoQlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHN0YWNraW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHNcclxuZXhwb3J0IGZ1bmN0aW9uIGpzU3RhY2tpbmdCbG9jaygpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgXHJcbiAgLy8gQ2VudHJvIHJlYWwgZGVsIMOhcmVhIHVzYWJsZSAoY29tcGVuc2EgcGFkZGluZyBzYWZlLWxlZnQvcmlnaHQpXHJcbiAgZnVuY3Rpb24gY29tcHV0ZUNlbnRlclgocm9vdEVsKXtcclxuICAgIHZhciByb290UmVjdCA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciByb290VyA9IHJvb3RSZWN0LndpZHRoIHx8IDA7XHJcblxyXG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWwpO1xyXG4gICAgdmFyIHBhZEwgPSBwYXJzZUZsb2F0KGNzLnBhZGRpbmdMZWZ0KSB8fCAwO1xyXG4gICAgdmFyIHBhZFIgPSBwYXJzZUZsb2F0KGNzLnBhZGRpbmdSaWdodCkgfHwgMDtcclxuXHJcbiAgICB2YXIgdXNhYmxlVyA9IE1hdGgubWF4KDAsIHJvb3RXIC0gcGFkTCAtIHBhZFIpO1xyXG4gICAgdmFyIGNlbnRlclggPSBwYWRMICsgdXNhYmxlVyAvIDI7IC8vIGNlbnRybyBkZWwgw6FyZWEgdXNhYmxlXHJcblxyXG4gICAgcmV0dXJuIHsgcm9vdFc6IHJvb3RXLCB1c2FibGVXOiB1c2FibGVXLCBjZW50ZXJYOiBjZW50ZXJYLCBwYWRMOiBwYWRMLCBwYWRSOiBwYWRSIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbGFtcChuLCBhLCBiKXtcclxuICAgIGlmICghaXNGaW5pdGUobikpIHJldHVybiBhO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIG4pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwaWxhIENMVVNURVJTIHBvciBncm91cHMgKGNvbHVtbmFzL2ZpbGFzKSB5OlxyXG4gICAqIC0gbXVldmUgY2FkYSBjbHVzdGVyIGNvbW8gYmxvcXVlXHJcbiAgICogLSBwcmVzZXJ2YSBzb2xhcGUvcG9zaWNpb25lcyByZWxhdGl2YXMgZGVudHJvIGRlbCBjbHVzdGVyXHJcbiAgICogLSBjZW50cmEgZWwgY2x1c3RlciBjb21vIGJsb3F1ZSBlbiBlbCBlamUgWCAoc2luIHRyYW5zZm9ybSlcclxuICAgKlxyXG4gICAqIERldnVlbHZlIGNoYW5nZWQgKyBuZWVkZWRIZWlnaHQgKHBhcmEgZXhwYW5kaXIgc2VjY2nDs24pXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXBwbHlDbHVzdGVyU3RhY2soZ3JvdXBzLCByb290RWwsIENGRywgbW9kZSl7XHJcbiAgICB2YXIgaW5mbyA9IGNvbXB1dGVDZW50ZXJYKHJvb3RFbCk7XHJcbiAgICB2YXIgY2VudGVyWCA9IGluZm8uY2VudGVyWDtcclxuICAgIG1zbExvZyhcInN0YWNrOnN0YXJ0XCIsIHtcclxuICAgICAgZ3JvdXBDb3VudDogZ3JvdXBzLmxlbmd0aCxcclxuICAgICAgZ3JvdXBTaXplczogZ3JvdXBzLm1hcChmdW5jdGlvbihnKXsgcmV0dXJuIGcubGVuZ3RoOyB9KSxcclxuICAgICAgY2VudGVyWDogK2NlbnRlclgudG9GaXhlZCgxKSxcclxuICAgICAgdXNhYmxlVzogK2luZm8udXNhYmxlVy50b0ZpeGVkKDEpXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGlzTXVsdGlDb2xMYXlvdXQgPSAobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpO1xyXG5cclxuICAgIC8vIEVuIG11bHRpLWNvbHVtbmE6IGNhZGEgY29sdW1uYSBhcGlsYWRhIHNlIGNlbnRyYSBwb3Igc3UgcHJvcGlvIGJib3guXG4gICAgLy8gQXPDrSwgZWwgY2VudHJvIGRlIGNhZGEgY29sdW1uYSBjb2luY2lkZSBjb24gZWwgY2VudHJvIGRlIHBhbnRhbGxhLlxuXHJcbiAgICAvLyAtLS0gQW5jaG9yIGdsb2JhbDogZMOzbmRlIGVzdGFiYSDigJxlbCBibG9xdWXigJ0gb3JpZ2luYWxtZW50ZSAtLS1cclxuICAgIHZhciBmaXJzdEdyb3VwID0gZ3JvdXBzWzBdIHx8IFtdO1xyXG4gICAgdmFyIGFuY2hvciA9IEluZmluaXR5O1xyXG4gICAgZm9yICh2YXIgaT0wO2k8Zmlyc3RHcm91cC5sZW5ndGg7aSsrKXtcclxuICAgICAgYW5jaG9yID0gTWF0aC5taW4oYW5jaG9yLCBmaXJzdEdyb3VwW2ldLnRvcCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRmluaXRlKGFuY2hvcikpIGFuY2hvciA9IENGRy5QQURfVE9QO1xyXG4gICAgYW5jaG9yID0gTWF0aC5tYXgoQ0ZHLlBBRF9UT1AsIGFuY2hvcik7XHJcblxyXG4gICAgLy8gQ3Vyc29yIGdsb2JhbDogZMOzbmRlIHRlcm1pbmEgZWwgY29udGVuaWRvIGFwaWxhZG8gaGFzdGEgYWhvcmFcclxuICAgIHZhciBnbG9iYWxDdXJzb3IgPSBhbmNob3I7XHJcblxyXG4gICAgLy8gU2VwYXJhY2nDs24gZW50cmUgY29sdW1uYXMgYXBpbGFkYXMgKGl6cSwgY2VudHJvLCBkZXIpXHJcbiAgICB2YXIgR1JPVVBfR0FQID0gMTQ7XHJcblxyXG4gICAgZm9yICh2YXIgZz0wOyBnPGdyb3Vwcy5sZW5ndGg7IGcrKyl7XG4gICAgICB2YXIgY29sID0gZ3JvdXBzW2ddIHx8IFtdO1xuICAgICAgaWYgKCFjb2wubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgIHZhciBjb2xSZWZlcmVuY2VDZW50ZXJYID0gTmFOO1xuICAgICAgdmFyIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPSBOYU47XG4gICAgICB2YXIgbmFycm93Q2x1c3RlckNvdW50ID0gMDtcbiAgICAgIHZhciB3aWRlQ2x1c3RlckNvdW50ID0gMDtcblxyXG4gICAgICAvLyBNw6l0cmljYXMgcG9yIGdydXBvIHNvbG8gcGFyYSBkZWJ1Zy5cclxuICAgICAgdmFyIGdyb3VwTWluTGVmdCA9IEluZmluaXR5O1xyXG4gICAgICB2YXIgZ3JvdXBNYXhSaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpe1xuICAgICAgICBmb3IgKHZhciBnZz0wOyBnZzxjb2wubGVuZ3RoOyBnZysrKXtcbiAgICAgICAgICBncm91cE1pbkxlZnQgPSBNYXRoLm1pbihncm91cE1pbkxlZnQsIGNvbFtnZ10ubGVmdCk7XG4gICAgICAgICAgZ3JvdXBNYXhSaWdodCA9IE1hdGgubWF4KGdyb3VwTWF4UmlnaHQsIGNvbFtnZ10ubGVmdCArIGNvbFtnZ10ud2lkdGgpO1xuICAgICAgICAgIHZhciBjbHVzdGVyV0RiZyA9IE51bWJlcihjb2xbZ2ddLndpZHRoIHx8IDApO1xuICAgICAgICAgIGlmIChjbHVzdGVyV0RiZyA8PSAoaW5mby51c2FibGVXICogMC43MikpIG5hcnJvd0NsdXN0ZXJDb3VudCsrO1xuICAgICAgICAgIGlmIChjbHVzdGVyV0RiZyA+PSAoaW5mby51c2FibGVXICogMC44OCkpIHdpZGVDbHVzdGVyQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGdyb3VwV2lkdGggPSBpc011bHRpQ29sTGF5b3V0ID8gTWF0aC5tYXgoMCwgZ3JvdXBNYXhSaWdodCAtIGdyb3VwTWluTGVmdCkgOiAwO1xuICAgICAgdmFyIGdyb3VwQmFzZUxlZnQgPSBpc011bHRpQ29sTGF5b3V0ID8gKGNlbnRlclggLSBncm91cFdpZHRoIC8gMikgOiAwO1xuICAgICAgdmFyIHN1c3BpY2lvdXNXaWRlU3BhbiA9IGlzTXVsdGlDb2xMYXlvdXQgJiZcbiAgICAgICAgY29sLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgZ3JvdXBXaWR0aCA+PSAoaW5mby51c2FibGVXICogMC44OCkgJiZcbiAgICAgICAgbmFycm93Q2x1c3RlckNvdW50ID49IDEgJiZcbiAgICAgICAgd2lkZUNsdXN0ZXJDb3VudCA+PSAxO1xuICAgICAgdmFyIHByZXNlcnZlQ29sdW1uT2Zmc2V0cyA9IGlzTXVsdGlDb2xMYXlvdXQgJiYgIXN1c3BpY2lvdXNXaWRlU3BhbjtcblxyXG4gICAgICAvLyBPZmZzZXQgdmVydGljYWwgb3JpZ2luYWwgZGUgZXN0YSBjb2x1bW5hIHJlc3BlY3RvIGRlbCBhbmNob3JcclxuICAgICAgdmFyIGNvbE1pblRvcCA9IEluZmluaXR5O1xyXG4gICAgICBmb3IgKHZhciBrPTA7azxjb2wubGVuZ3RoO2srKyl7XHJcbiAgICAgICAgY29sTWluVG9wID0gTWF0aC5taW4oY29sTWluVG9wLCBjb2xba10udG9wKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzRmluaXRlKGNvbE1pblRvcCkpIGNvbE1pblRvcCA9IGFuY2hvcjtcclxuXHJcbiAgICAgIHZhciBjb2xPZmZzZXQgPSBjb2xNaW5Ub3AgLSBhbmNob3I7XHJcbiAgICAgIHZhciBjb2xTdGFydCA9IGdsb2JhbEN1cnNvciArIChnID09PSAwID8gMCA6IEdST1VQX0dBUCkgKyBNYXRoLm1heCgwLCBjb2xPZmZzZXQpO1xyXG4gICAgICBtc2xMb2coXCJzdGFjazpncm91cDpzdGFydFwiLCB7XHJcbiAgICAgICAgZzogZyxcclxuICAgICAgICBjb2xTaXplOiBjb2wubGVuZ3RoLFxyXG4gICAgICAgIGNvbE1pblRvcDogK2NvbE1pblRvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgIGNvbE9mZnNldDogK2NvbE9mZnNldC50b0ZpeGVkKDEpLFxyXG4gICAgICAgIGNvbFN0YXJ0OiArY29sU3RhcnQudG9GaXhlZCgxKSxcbiAgICAgICAgZ2xvYmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSksXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGdyb3VwTWluTGVmdDogaXNNdWx0aUNvbExheW91dCA/ICtncm91cE1pbkxlZnQudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgIGdyb3VwV2lkdGg6IGlzTXVsdGlDb2xMYXlvdXQgPyArZ3JvdXBXaWR0aC50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgZ3JvdXBCYXNlTGVmdDogaXNNdWx0aUNvbExheW91dCA/ICtncm91cEJhc2VMZWZ0LnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICBuYXJyb3dDbHVzdGVyQ291bnQ6IGlzTXVsdGlDb2xMYXlvdXQgPyBuYXJyb3dDbHVzdGVyQ291bnQgOiBudWxsLFxuICAgICAgICB3aWRlQ2x1c3RlckNvdW50OiBpc011bHRpQ29sTGF5b3V0ID8gd2lkZUNsdXN0ZXJDb3VudCA6IG51bGwsXG4gICAgICAgIHByZXNlcnZlQ29sdW1uT2Zmc2V0czogaXNNdWx0aUNvbExheW91dCA/IHByZXNlcnZlQ29sdW1uT2Zmc2V0cyA6IG51bGxcbiAgICAgIH0pO1xuXHJcbiAgICAgIC8vIEN1cnNvciBsb2NhbCBkZSBlc3RhIGNvbHVtbmFcclxuICAgICAgdmFyIGNvbEN1cnNvciA9IGNvbFN0YXJ0O1xyXG5cclxuICAgICAgZm9yICh2YXIgaj0wOyBqPGNvbC5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgdmFyIGMgPSBjb2xbal07XHJcblxyXG4gICAgICAgIC8vIFRvcCBkZWwgY2x1c3RlciBlbiBlbCBmbHVqbyBtb2JpbGVcclxuICAgICAgICB2YXIgY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICBjbHVzdGVyVG9wID0gY29sQ3Vyc29yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2QyA9IGNvbFtqLTFdO1xuICAgICAgICAgIHZhciBwcmV2Qm90dG9tID0gKGNsdXN0ZXJUb3BQcmV2ICsgcHJldkMuaGVpZ2h0KTtcblxuICAgICAgICAgIC8vIOKchSBHYXAgb3JpZ2luYWwgZW50cmUgY2x1c3RlcnMgKGNhbnZhcylcbiAgICAgICAgICB2YXIgcHJldkJvdHRvbU9yaWcgPSAocHJldkMudG9wICsgcHJldkMuaGVpZ2h0KTtcbiAgICAgICAgICB2YXIgZ2FwT3JpZyA9IGMudG9wIC0gcHJldkJvdHRvbU9yaWc7XG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShnYXBPcmlnKSkgZ2FwT3JpZyA9IDA7XG5cbiAgICAgICAgICB2YXIgb3ZlcmxhcEluU291cmNlID0gZ2FwT3JpZyA8IDA7XG4gICAgICAgICAgaWYgKChtb2RlID09PSBcInR3b1wiIHx8IG1vZGUgPT09IFwidGhyZWVcIikgJiYgb3ZlcmxhcEluU291cmNlKSB7XG4gICAgICAgICAgICAvLyBTaSBlbiBlbCBvcmlnaW5hbCBlc3RlIGNsdXN0ZXIgY2FlIGRlbnRybyBkZWwgYW50ZXJpb3IsIHJlc3BldGFtb3NcbiAgICAgICAgICAgIC8vIHN1IHRvcCByZWxhdGl2byBwYXJhIG5vIG1hbmRhcmxvIGFsIGZpbmFsIGRlIGxhIGNvbHVtbmEuXG4gICAgICAgICAgICB2YXIgcmVsVG9wSW5Db2wgPSBjLnRvcCAtIGNvbE1pblRvcDtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUocmVsVG9wSW5Db2wpKSByZWxUb3BJbkNvbCA9IDA7XG4gICAgICAgICAgICBjbHVzdGVyVG9wID0gY29sU3RhcnQgKyBNYXRoLm1heCgwLCByZWxUb3BJbkNvbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOKchSBHYXAg4oCcbW9iaWxlLWZyaWVuZGx54oCdOiBlc2NhbGFkbyArIGNsYW1wXG4gICAgICAgICAgICB2YXIgZ2FwV2FudGVkID0gY2xhbXAoZ2FwT3JpZyAqIChDRkcuR0FQX1NDQUxFIHx8IDEpLCBDRkcuTUlOX0dBUCwgQ0ZHLk1BWF9HQVApO1xuXG4gICAgICAgICAgICAvLyDinIUgQW50aS1zb2xhcGUgZGVmaW5pdGl2bzpcbiAgICAgICAgICAgIC8vICAgZWwgcHLDs3hpbW8gY2x1c3RlciBTSUVNUFJFIGVtcGllemEgZGVzcHXDqXMgZGVsIGJvdHRvbSByZWFsIGRlbCBhbnRlcmlvciArIGdhcFdhbnRlZFxuICAgICAgICAgICAgY2x1c3RlclRvcCA9IHByZXZCb3R0b20gKyBnYXBXYW50ZWQ7XG5cbiAgICAgICAgICAgIC8vIEVuIG11bHRpLWNvbHVtbmEgbnVuY2EgYXZhbnphbW9zIGhhY2lhIGFycmliYSByZXNwZWN0byBhbCBmbHVqbyB5YSBjb25zdW1pZG8uXG4gICAgICAgICAgICBpZiAoKG1vZGUgPT09IFwidHdvXCIgfHwgbW9kZSA9PT0gXCJ0aHJlZVwiKSAmJiBjbHVzdGVyVG9wIDwgY29sQ3Vyc29yKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xDdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cclxuICAgICAgICAvLyBHdWFyZGFtb3MgcGFyYSBlbCBwcsOzeGltbyBsb29wXHJcbiAgICAgICAgdmFyIGNsdXN0ZXJUb3BQcmV2ID0gY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgLy8gwr9jZW50cmFyIGVzdGUgY2x1c3Rlcj9cbiAgICAgICAgdmFyIGZvcmNlQ2VudGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNUZXh0SW5DbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNOb25UZXh0SW5DbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIHQ9MDsgdDxjLml0ZW1zLmxlbmd0aDsgdCsrKXtcbiAgICAgICAgICB2YXIgaXNUZXh0VCA9IChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgaWYgKGlzVGV4dFQpIGhhc1RleHRJbkNsdXN0ZXIgPSB0cnVlO1xuICAgICAgICAgIGVsc2UgaGFzTm9uVGV4dEluQ2x1c3RlciA9IHRydWU7XG4gICAgICAgICAgaWYgKChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIpID09PSBcImZvcmNlXCIpIHtcbiAgICAgICAgICAgIGZvcmNlQ2VudGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxyXG4gICAgICAgIC8vIG9uZS9yb3dzOiBjZW50cm8gcG9yIGNsdXN0ZXIgKGNvbXBvcnRhbWllbnRvIG9yaWdpbmFsKVxyXG4gICAgICAgIC8vIHR3by90aHJlZTogYXBpbGFyIGNhZGEgY29sdW1uYSBlbiBsYSBtaXNtYSByZWZlcmVuY2lhIFgsXHJcbiAgICAgICAgLy8gcHJlc2VydmFuZG8gb2Zmc2V0cyBpbnRlcm5vcyBkZSBlc2EgY29sdW1uYS5cclxuICAgICAgICB2YXIga2VlcENlbnRlciA9IGZvcmNlQ2VudGVyID8gdHJ1ZSA6IChjLndpZHRoIDwgKGluZm8udXNhYmxlVyAqIDAuOTUpKTtcbiAgICAgICAgdmFyIGNsdXN0ZXJMZWZ0ID0ga2VlcENlbnRlciA/IChjZW50ZXJYIC0gYy53aWR0aCAvIDIpIDogYy5sZWZ0O1xuICAgICAgICB2YXIgaXNUZXh0T25seUNsdXN0ZXIgPSBoYXNUZXh0SW5DbHVzdGVyICYmICFoYXNOb25UZXh0SW5DbHVzdGVyO1xuICAgICAgICB2YXIgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpIHtcbiAgICAgICAgICAvLyBNb2RvIGxlY3R1cmEgbW9iaWxlIG11bHRpLWNvbDpcbiAgICAgICAgICAvLyB1c2FyIHVuYSBtaXNtYSByZWZlcmVuY2lhIFggcGFyYSB0b2RhIGxhIGNvbHVtbmEgYXBpbGFkYSB5XG4gICAgICAgICAgLy8gcHJlc2VydmFyIGVsIG9mZnNldCBob3Jpem9udGFsIG9yaWdpbmFsIGRlIGNhZGEgY2x1c3Rlci5cbiAgICAgICAgICAvLyBFc3RvIG1hbnRpZW5lIGFsaW5lYWRvIHRleHRvL2Zvcm1hIGN1YW5kbyBsYSBjb2x1bW5hIHNlIHBhcnRlXG4gICAgICAgICAgLy8gZW4gdmFyaW9zIGNsdXN0ZXJzLlxuICAgICAgICAgIC8vIFNpIGVsIGJib3ggZGUgbGEgY29sdW1uYSBxdWVkYSBjb250YW1pbmFkbyBwb3IgdW4gb3V0bGllciBhbmNob1xuICAgICAgICAgIC8vICh0aXBpY2FtZW50ZSB0ZXh0byksIGNlbnRyYXIgcG9yIG9mZnNldHMgZGVqYSBsYSBjb2x1bW5hIHBlZ2FkYVxuICAgICAgICAgIC8vIGFsIGJvcmRlOyBlbiBlc2UgY2FzbyBjZW50cmFtb3MgY2FkYSBjbHVzdGVyIGluZGl2aWR1YWxtZW50ZS5cbiAgICAgICAgICBpZiAocHJlc2VydmVDb2x1bW5PZmZzZXRzKSB7XG4gICAgICAgICAgICB2YXIgcmVsQ2x1c3RlckxlZnQgPSAoYy5sZWZ0IHx8IDApIC0gKGdyb3VwTWluTGVmdCB8fCAwKTtcbiAgICAgICAgICAgIGNsdXN0ZXJMZWZ0ID0gZ3JvdXBCYXNlTGVmdCArIHJlbENsdXN0ZXJMZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQZXJtaXRlIGZvcnphciBjZW50cmFkbyBwb3IgY2x1c3RlciBzaSBlbCBub2RvIGxvIHBpZGUuXG4gICAgICAgICAgaWYgKGZvcmNlQ2VudGVyKSBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcblxuICAgICAgICAgIC8vIFNpIGVzdGEgY29sdW1uYSB0aWVuZSB1biBjbHVzdGVyIGNvbiBmb3JtYSAobyBtaXh0byksIHVzYW1vcyBzdVxuICAgICAgICAgIC8vIGNlbnRybyBjb21vIHJlZmVyZW5jaWEgcGFyYSBhbGluZWFyIGNsdXN0ZXJzIHNvbG8tdGV4dG8gZGViYWpvLlxuICAgICAgICAgIHZhciBjbHVzdGVyUmVmQ2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaGFzTm9uVGV4dEluQ2x1c3Rlcikge1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNpYSBiYXNhZGEgZW4gaXRlbXMgbm8tdGV4dG8gKGZvcm1hL2ljb25vKSwgbm8gZW4gdG9kbyBlbFxuICAgICAgICAgICAgLy8gY2x1c3RlciwgcGFyYSBxdWUgdGV4dG9zIGxhcmdvcyBubyBkZXNwbGFjZW4gZWwgY2VudHJvIGRlIGNvbHVtbmEuXG4gICAgICAgICAgICB2YXIgbnRNaW5SZWwgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBudE1heFJlbCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIG50aT0wOyBudGk8Yy5pdGVtcy5sZW5ndGg7IG50aSsrKXtcbiAgICAgICAgICAgICAgdmFyIG50SXQgPSBjLml0ZW1zW250aV07XG4gICAgICAgICAgICAgIHZhciBudElzVGV4dCA9IChudEl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgICAgIGlmIChudElzVGV4dCkgY29udGludWU7XG4gICAgICAgICAgICAgIG50TWluUmVsID0gTWF0aC5taW4obnRNaW5SZWwsIChudEl0Ll9yZWxMZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgbnRNYXhSZWwgPSBNYXRoLm1heChudE1heFJlbCwgKG50SXQuX3JlbExlZnQgfHwgMCkgKyAobnRJdC53aWR0aCB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUobnRNaW5SZWwpICYmIGlzRmluaXRlKG50TWF4UmVsKSAmJiBudE1heFJlbCA+IG50TWluUmVsKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyAoKG50TWluUmVsICsgbnRNYXhSZWwpIC8gMik7XG4gICAgICAgICAgICAgIHNvdXJjZUNsdXN0ZXJSZWZDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArICgobnRNaW5SZWwgKyBudE1heFJlbCkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyBjLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclggPSBjbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICAgIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPSBzb3VyY2VDbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUZXh0T25seUNsdXN0ZXIgJiYgaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpIHtcbiAgICAgICAgICAgIHZhciBtYXhTbmFwRGVsdGEgPSBNYXRoLm1pbigxMjAsIGluZm8udXNhYmxlVyAqIDAuMzUpO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUNsdXN0ZXJDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0WCA9IGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXG4gICAgICAgICAgICAgID8gKHNvdXJjZUNsdXN0ZXJDZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgOiBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRYKSAmJiBNYXRoLmFicyhzb3VyY2VEcmlmdFgpIDw9IG1heFNuYXBEZWx0YSkge1xuICAgICAgICAgICAgICBjbHVzdGVyTGVmdCA9IChjb2xSZWZlcmVuY2VDZW50ZXJYICsgc291cmNlRHJpZnRYKSAtIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyYSBsYWJlbHMgY29ydG9zLCBjZW50cmFyIGVsIGNvbnRlbmlkbyB0ZXh0dWFsIGRlbnRybyBkZWwgYm94LlxuICAgICAgICAgICAgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBjLndpZHRoIDw9IChpbmZvLnVzYWJsZVcgKiAwLjY1KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHdWFyZCByYWlsOiBlbiBhcGlsYWRvIG11bHRpLWNvbHVtbmEsIHVuIGNsdXN0ZXIgbm8gZGViZSBxdWVkYXJcbiAgICAgICAgICAvLyBkZXN2aWFkbyBkZW1hc2lhZG8gZGVsIGVqZSBjZW50cmFsIGRlbCBsYXlvdXQgbW9iaWxlLlxuICAgICAgICAgIHZhciBjbHVzdGVyQ2VudGVyWE5vdyA9IGNsdXN0ZXJMZWZ0ICsgYy53aWR0aCAvIDI7XG4gICAgICAgICAgdmFyIG1heENlbnRlckRyaWZ0ID0gTWF0aC5tYXgoMjQsIGluZm8udXNhYmxlVyAqIDAuMTgpO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjbHVzdGVyQ2VudGVyWE5vdyAtIGNlbnRlclgpID4gbWF4Q2VudGVyRHJpZnQpIHtcbiAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOmNsdXN0ZXI6Y2VudGVyRmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICBwcmV2TGVmdDogK2NsdXN0ZXJMZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGNlbnRlclg6ICtjZW50ZXJYLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJYOiArY2x1c3RlckNlbnRlclhOb3cudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgbWF4Q2VudGVyRHJpZnQ6ICttYXhDZW50ZXJEcmlmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBjbHVzdGVyVzogKyhjLndpZHRoIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2x1c3RlckxlZnQgPSBjZW50ZXJYIC0gYy53aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1zbExvZyhcInN0YWNrOmNsdXN0ZXJcIiwge1xuICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgajogaixcbiAgICAgICAgICBvcmlnVG9wOiArYy50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICBvcmlnTGVmdDogK2MubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgIG5ld1RvcDogK2NsdXN0ZXJUb3AudG9GaXhlZCgxKSxcclxuICAgICAgICAgIG5ld0xlZnQ6ICtjbHVzdGVyTGVmdC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgaDogK2MuaGVpZ2h0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgICB3OiArYy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGZvcmNlQ2VudGVyOiBmb3JjZUNlbnRlcixcbiAgICAgICAgICBrZWVwQ2VudGVyOiBrZWVwQ2VudGVyLFxuICAgICAgICAgIGl0ZW1zOiBjLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBjb2xSZWZlcmVuY2VDZW50ZXJYOiAodHlwZW9mIGNvbFJlZmVyZW5jZUNlbnRlclggPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpID8gK2NvbFJlZmVyZW5jZUNlbnRlclgudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgICAgaXNUZXh0T25seUNsdXN0ZXI6IGlzVGV4dE9ubHlDbHVzdGVyLFxuICAgICAgICAgIGNlbnRlclNob3J0VGV4dDogc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXJcbiAgICAgICAgfSk7XG5cclxuICAgICAgICB2YXIgdGV4dENvdW50ID0gMDtcclxuICAgICAgICBmb3IgKHZhciB0Yz0wOyB0YzxjLml0ZW1zLmxlbmd0aDsgdGMrKyl7XHJcbiAgICAgICAgICBpZiAoKGMuaXRlbXNbdGNdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHRDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGluZWFyaXplQ2x1c3RlciA9IChtb2RlID09PSBcInJvd3NcIiAmJiBjLml0ZW1zLmxlbmd0aCA+IDEgJiYgdGV4dENvdW50ID49IDIpO1xyXG4gICAgICAgIHZhciBjbHVzdGVyQm90dG9tVXNlZCA9IGNsdXN0ZXJUb3AgKyBjLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gQ2FzbyBlc3BlY2lhbDogZW4gcm93cywgc2kgZWwgY2x1c3RlciBhZ3J1cGEgdmFyaW9zIHRleHRvcywgbG9cclxuICAgICAgICAvLyBjb252ZXJ0aW1vcyBhIGZsdWpvIHZlcnRpY2FsIGNlbnRyYWRvIHBhcmEgZXZpdGFyIHRleHRvIGxhZG8gYSBsYWRvLlxyXG4gICAgICAgIGlmIChsaW5lYXJpemVDbHVzdGVyKXtcclxuICAgICAgICAgIHZhciBhbGxJdGVtcyA9IGMuaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICAgIHZhciBub25UZXh0ID0gYWxsSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0eCl7XHJcbiAgICAgICAgICAgIHJldHVybiAoaXR4Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCI7XHJcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgIGlmIChhLnRvcCAhPT0gYi50b3ApIHJldHVybiBhLnRvcCAtIGIudG9wO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB2YXIgdGV4dHMgPSBhbGxJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXR4KXtcclxuICAgICAgICAgICAgcmV0dXJuIChpdHgubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgaWYgKGEudG9wICE9PSBiLnRvcCkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBPcmRlbiBzZW3DoW50aWNvIGRlIGxlY3R1cmE6XHJcbiAgICAgICAgICAvLyBuby10ZXh0byArIHRleHRvIG3DoXMgY2VyY2FubyAoZGViYWpvIHkgcG9yIGVqZSBYKSwgbHVlZ28gcmVtYW5lbnRlcy5cclxuICAgICAgICAgIHZhciBvcmRlcmVkID0gW107XHJcbiAgICAgICAgICB2YXIgdXNlZFRleHQgPSB7fTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBudD0wOyBudDxub25UZXh0Lmxlbmd0aDsgbnQrKyl7XHJcbiAgICAgICAgICAgIHZhciBudEl0ZW0gPSBub25UZXh0W250XTtcclxuICAgICAgICAgICAgb3JkZXJlZC5wdXNoKG50SXRlbSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbnRDeCA9IChudEl0ZW0ubGVmdCB8fCAwKSArIChudEl0ZW0ud2lkdGggfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbnRCb3R0b20gPSAobnRJdGVtLnRvcCB8fCAwKSArIChudEl0ZW0uaGVpZ2h0IHx8IDApO1xyXG4gICAgICAgICAgICB2YXIgYmVzdElkeFR4dCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgYmVzdFNjb3JlID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciB0eD0wOyB0eDx0ZXh0cy5sZW5ndGg7IHR4Kyspe1xyXG4gICAgICAgICAgICAgIGlmICh1c2VkVGV4dFt0eF0pIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIHZhciB0SXRlbSA9IHRleHRzW3R4XTtcclxuICAgICAgICAgICAgICB2YXIgdEN4ID0gKHRJdGVtLmxlZnQgfHwgMCkgKyAodEl0ZW0ud2lkdGggfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICAgIHZhciB2R2FwVHh0ID0gKHRJdGVtLnRvcCB8fCAwKSAtIG50Qm90dG9tOyAvLyBwcmVmZXJpciB0ZXh0byBkZWJham9cclxuICAgICAgICAgICAgICB2YXIgaERpc3RUeHQgPSBNYXRoLmFicyh0Q3ggLSBudEN4KTtcclxuICAgICAgICAgICAgICB2YXIgcGVuYWx0eUFib3ZlID0gdkdhcFR4dCA8IC0yID8gMTAwMDAgOiAwO1xyXG4gICAgICAgICAgICAgIHZhciBzY29yZSA9IHBlbmFsdHlBYm92ZSArIE1hdGguYWJzKHZHYXBUeHQpICogMiArIGhEaXN0VHh0O1xyXG4gICAgICAgICAgICAgIGlmIChzY29yZSA8IGJlc3RTY29yZSl7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgICAgICAgIGJlc3RJZHhUeHQgPSB0eDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChiZXN0SWR4VHh0ID49IDApe1xyXG4gICAgICAgICAgICAgIG9yZGVyZWQucHVzaCh0ZXh0c1tiZXN0SWR4VHh0XSk7XHJcbiAgICAgICAgICAgICAgdXNlZFRleHRbYmVzdElkeFR4dF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVGV4dG9zIG5vIGVtcGFyZWphZG9zXHJcbiAgICAgICAgICBmb3IgKHZhciB0eDI9MDsgdHgyPHRleHRzLmxlbmd0aDsgdHgyKyspe1xyXG4gICAgICAgICAgICBpZiAoIXVzZWRUZXh0W3R4Ml0pIG9yZGVyZWQucHVzaCh0ZXh0c1t0eDJdKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTaSBubyBodWJvIG5vLXRleHRvLCBmYWxsYmFjayBzaW1wbGUgcG9yIHRvcC9sZWZ0XHJcbiAgICAgICAgICBpZiAoIW9yZGVyZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG9yZGVyZWQgPSBhbGxJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgICAgaWYgKGEudG9wICE9PSBiLnRvcCkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGxvY2FsQ3Vyc29yID0gY2x1c3RlclRvcDtcclxuICAgICAgICAgIHZhciBwcmV2SXQgPSBudWxsO1xyXG4gICAgICAgICAgdmFyIHByZXZUb3BBcHBsaWVkID0gY2x1c3RlclRvcDtcclxuICAgICAgICAgIHZhciBFWFRSQV9DT0xfQlJFQUtfR0FQID0gODtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBsaT0wOyBsaTxvcmRlcmVkLmxlbmd0aDsgbGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBsaXQgPSBvcmRlcmVkW2xpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZWVwTGF5b3V0TGluID0gKGxpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XHJcbiAgICAgICAgICAgIGlmIChrZWVwTGF5b3V0TGluKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdUb3BMaW4gPSBsb2NhbEN1cnNvcjtcclxuICAgICAgICAgICAgaWYgKHByZXZJdCl7XHJcbiAgICAgICAgICAgICAgdmFyIGdhcE9yaWdMaW4gPSBsaXQudG9wIC0gKHByZXZJdC50b3AgKyBwcmV2SXQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGdhcE9yaWdMaW4pKSBnYXBPcmlnTGluID0gMDtcclxuICAgICAgICAgICAgICB2YXIgZ2FwV2FudGVkTGluID0gY2xhbXAoZ2FwT3JpZ0xpbiAqIChDRkcuR0FQX1NDQUxFIHx8IDEpLCBDRkcuTUlOX0dBUCwgQ0ZHLk1BWF9HQVApO1xyXG4gICAgICAgICAgICAgIHZhciBwcmV2SXNUZXh0TGluID0gKHByZXZJdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgICAgICAgICAgIHZhciBjdXJySXNUZXh0TGluID0gKGxpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgICAgICAgICAgIC8vIEFsIHBhc2FyIGRlIFwidGV4dG8gZmluYWwgZGUgY29sdW1uYVwiIGEgXCJudWV2byBuby10ZXh0b1wiIGFncmVnYW1vcyBhaXJlLlxyXG4gICAgICAgICAgICAgIGlmIChwcmV2SXNUZXh0TGluICYmICFjdXJySXNUZXh0TGluKSBnYXBXYW50ZWRMaW4gKz0gRVhUUkFfQ09MX0JSRUFLX0dBUDtcclxuICAgICAgICAgICAgICBuZXdUb3BMaW4gPSBwcmV2VG9wQXBwbGllZCArIHByZXZJdC5oZWlnaHQgKyBnYXBXYW50ZWRMaW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0TGluID0gY2VudGVyWCAtIChsaXQud2lkdGggfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIga2VlcEFsaWduTGluID0gKGxpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWFsaWduXCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgICAgaWYgKGtlZXBBbGlnbkxpbikgbmV3TGVmdExpbiA9IGxpdC5sZWZ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5ld1RvcExpbiAtIGxpdC50b3ApID4gMC41IHx8IE1hdGguYWJzKG5ld0xlZnRMaW4gLSBsaXQubGVmdCkgPiAwLjUpIGNoYW5nZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gRW4gcm93cyBsaW5lYWxpemFkbywgZm9yemFtb3MgY2VudHJhZG8gdmlzdWFsIHJlYWwgZGUgdGV4dG8uXHJcbiAgICAgICAgICAgIHZhciBpc1RleHRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgIGlmIChpc1RleHRMaW4gJiYgIWtlZXBBbGlnbkxpbikge1xyXG4gICAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRleHQtem9vbVwiLCBcIjFcIik7XHJcbiAgICAgICAgICAgICAgdmFyIHRmTGluID0gbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgaWYgKHRmTGluLmluZGV4T2YoXCJ0cmFuc2xhdGVYKFwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRmTGluLnJlcGxhY2UoL3RyYW5zbGF0ZVhcXChbXildKlxcKS8sIFwidHJhbnNsYXRlWCgwcHgpXCIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNzc0xlZnRMaW4gPSBuZXdMZWZ0TGluIC0gKGluZm8ucGFkTCB8fCAwKTtcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLnRvcCA9IG5ld1RvcExpbiArIFwicHhcIjtcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLmxlZnQgPSBjc3NMZWZ0TGluICsgXCJweFwiO1xuICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuXHJcbiAgICAgICAgICAgIHByZXZJdCA9IGxpdDtcclxuICAgICAgICAgICAgcHJldlRvcEFwcGxpZWQgPSBuZXdUb3BMaW47XHJcbiAgICAgICAgICAgIGxvY2FsQ3Vyc29yID0gbmV3VG9wTGluICsgKGxpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEN1cnNvciA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcGxpY2FyIGEgY2FkYSBpdGVtIHByZXNlcnZhbmRvIG9mZnNldHMgcmVsYXRpdm9zIChzb2xhcGUgaW50YWN0bylcclxuICAgICAgICBmb3IgKHZhciBpaT0wOyBpaTxjLml0ZW1zLmxlbmd0aDsgaWkrKyl7XHJcbiAgICAgICAgICB2YXIgaXQgPSBjLml0ZW1zW2lpXTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IHRvdGFsIGRlbCBsYXlvdXQgKGRlY29yYWNpb25lcywgZXRjLilcclxuICAgICAgICAgIHZhciBrZWVwTGF5b3V0ID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgIGlmIChrZWVwTGF5b3V0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICB2YXIgbmV3VG9wID0gY2x1c3RlclRvcCArIChpdC5fcmVsVG9wIHx8IDApO1xyXG4gICAgICAgICAgdmFyIG5ld0xlZnQgPSBjbHVzdGVyTGVmdCArIChpdC5fcmVsTGVmdCB8fCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IGRlIGNlbnRyYWRvIChtYW50ZW5lciBsZWZ0IG9yaWdpbmFsIGRlbCBpdGVtKVxuICAgICAgICAgIHZhciBrZWVwQWxpZ24gPSAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1hbGlnblwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBBbGlnbikgbmV3TGVmdCA9IGl0LmxlZnQ7XG5cbiAgICAgICAgICAvLyBFbiBtdWx0aS1jb2wsIG5ldXRyYWxpemFtb3MgU0lFTVBSRSB0cmFuc2xhdGVYKC4uLikgZGUgdGV4dG9zXG4gICAgICAgICAgLy8gcGFyYSBxdWUgbGEgcG9zaWNpw7NuIGxlZnQgY2FsY3VsYWRhIHNlYSBsYSByZWZlcmVuY2lhIHZpc3VhbCByZWFsLlxuICAgICAgICAgIHZhciBpc1RleHROb2RlID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGlzU2hvcnRUZXh0Qm94ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNob3VsZFJlY2VudGVyVGV4dEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2VudGVyQnlBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0YXJnZXRUZXh0Q2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZSAmJiBpc011bHRpQ29sTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgdGYgPSBpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRmLmluZGV4T2YoXCJ0cmFuc2xhdGVYKFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0Zi5yZXBsYWNlKC90cmFuc2xhdGVYXFwoW14pXSpcXCkvLCBcInRyYW5zbGF0ZVgoMHB4KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzU2hvcnRUZXh0Qm94ID0gKGl0LndpZHRoIHx8IDApIDw9IChpbmZvLnVzYWJsZVcgKiAwLjUpICYmIChpdC5oZWlnaHQgfHwgMCkgPD0gNDI7XG4gICAgICAgICAgICB2YXIgdGFDdXJyZW50ID0gKChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2VudGVyQnlBbGlnbiA9IHRhQ3VycmVudCA9PT0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIHZhciBzaG91bGRDZW50ZXJWaXN1YWxUZXh0ID1cbiAgICAgICAgICAgICAgKHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyIHx8IGlzU2hvcnRUZXh0Qm94IHx8IGNlbnRlckJ5QWxpZ24pICYmXG4gICAgICAgICAgICAgICFrZWVwQWxpZ247XG4gICAgICAgICAgICBzaG91bGRSZWNlbnRlclRleHRJdGVtID1cbiAgICAgICAgICAgICAgc2hvdWxkQ2VudGVyVmlzdWFsVGV4dCAmJlxuICAgICAgICAgICAgICBpc0Zpbml0ZShjb2xSZWZlcmVuY2VDZW50ZXJYKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2TGVmdFR4dCA9IG5ld0xlZnQ7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VJdGVtQ2VudGVyWCA9IChpdC5sZWZ0IHx8IDApICsgKGl0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0SXRlbVggPSBpc0Zpbml0ZShjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYKVxuICAgICAgICAgICAgICAgID8gKHNvdXJjZUl0ZW1DZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgICA6IE5hTjtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldENlbnRlclggPSBjb2xSZWZlcmVuY2VDZW50ZXJYO1xuICAgICAgICAgICAgICAvLyBFbiB0ZXh0b3MgY2VudHJhZG9zIChvIGxhYmVscyBjb3J0b3MgZm9yemFkb3MgYWwgY2VudHJvKSxcbiAgICAgICAgICAgICAgLy8gbm8gYXJyYXN0cmFtb3MgZHJpZnQgaG9yaXpvbnRhbCBkZWwgbGF5b3V0IG9yaWdpbmFsIHBhcmFcbiAgICAgICAgICAgICAgLy8gZXZpdGFyIGNvcnJpbWllbnRvcyBsYXRlcmFsZXMgZW4gbW9iaWxlLlxuICAgICAgICAgICAgICB2YXIgcHJlc2VydmVTb3VyY2VEcmlmdCA9XG4gICAgICAgICAgICAgICAgIWNlbnRlckJ5QWxpZ24gJiZcbiAgICAgICAgICAgICAgICAhc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgJiZcbiAgICAgICAgICAgICAgICAhaXNTaG9ydFRleHRCb3g7XG4gICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVNvdXJjZURyaWZ0ICYmIGlzRmluaXRlKHNvdXJjZURyaWZ0SXRlbVgpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyWCArPSBzb3VyY2VEcmlmdEl0ZW1YO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldFRleHRDZW50ZXJYID0gdGFyZ2V0Q2VudGVyWDtcbiAgICAgICAgICAgICAgbmV3TGVmdCA9IHRhcmdldENlbnRlclggLSAoaXQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3TGVmdCAtIHByZXZMZWZ0VHh0KSA+IDAuNSkge1xuICAgICAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOml0ZW06dGV4dFJlY2VudGVyXCIsIHtcbiAgICAgICAgICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgaWk6IGlpLFxuICAgICAgICAgICAgICAgICAgcHJldkxlZnQ6ICtwcmV2TGVmdFR4dC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgbmV3TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIGl0ZW1XOiArKGl0LndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICByZWZDZW50ZXJYOiArY29sUmVmZXJlbmNlQ2VudGVyWC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgc291cmNlUmVmQ2VudGVyWDogKHR5cGVvZiBjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpKSA/ICtjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc291cmNlRHJpZnRYOiBpc0Zpbml0ZShzb3VyY2VEcmlmdEl0ZW1YKSA/ICtzb3VyY2VEcmlmdEl0ZW1YLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcHJlc2VydmVTb3VyY2VEcmlmdDogcHJlc2VydmVTb3VyY2VEcmlmdCxcbiAgICAgICAgICAgICAgICAgIHNob3J0Qm94OiBpc1Nob3J0VGV4dEJveCxcbiAgICAgICAgICAgICAgICAgIGNlbnRlckJ5QWxpZ246IGNlbnRlckJ5QWxpZ25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZENlbnRlclZpc3VhbFRleHQpIHtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgICBpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwidG9wIGNlbnRlclwiO1xuICAgICAgICAgICAgICAvLyBFdml0YSBlbmNvZ2ltaWVudG8gaG9yaXpvbnRhbCBoZXJlZGFkbyBxdWUgZGVzcGxhemEgZWwgY2VudHJvIHZpc3VhbC5cbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3NzTGVmdCA9IG5ld0xlZnQgLSAoaW5mby5wYWRMIHx8IDApO1xuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUudG9wID0gbmV3VG9wICsgXCJweFwiO1xuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IGNzc0xlZnQgKyBcInB4XCI7XG4gICAgICAgICAgaXQubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG5cbiAgICAgICAgICAvLyBDb3JyZWNjacOzbiBmaW5hbCBwb3IgcG9zaWNpw7NuIHJlbmRlcml6YWRhIHJlYWwgZGVsIHRleHRvXG4gICAgICAgICAgLy8gKGZ1ZW50ZXMvdHJhbnNmb3JtIHB1ZWRlbiBpbnRyb2R1Y2lyIGRlc3bDrW9zIHZpc3VhbGVzIHN1Yi1ww614ZWwpLlxuICAgICAgICAgIGlmIChpc1RleHROb2RlICYmIGlzTXVsdGlDb2xMYXlvdXQgJiYgc2hvdWxkUmVjZW50ZXJUZXh0SXRlbSkge1xuICAgICAgICAgICAgdmFyIHJyVHh0ID0gcmVsUmVjdChpdC5ub2RlLCByb290RWwpO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQ2VudGVyWCA9IChyclR4dC5sZWZ0IHx8IDApICsgKHJyVHh0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICAgIHZhciB0YXJnZXRSZW5kZXJDZW50ZXJYID0gaXNGaW5pdGUodGFyZ2V0VGV4dENlbnRlclgpID8gdGFyZ2V0VGV4dENlbnRlclggOiBjb2xSZWZlcmVuY2VDZW50ZXJYO1xuICAgICAgICAgICAgdmFyIHJlbmRlckRlbHRhID0gcmVuZGVyZWRDZW50ZXJYIC0gdGFyZ2V0UmVuZGVyQ2VudGVyWDtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShyZW5kZXJEZWx0YSkgJiYgTWF0aC5hYnMocmVuZGVyRGVsdGEpID4gMC42KSB7XG4gICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRMZWZ0ID0gbmV3TGVmdCAtIHJlbmRlckRlbHRhO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoY29ycmVjdGVkTGVmdCkpIHtcbiAgICAgICAgICAgICAgICBtc2xMb2coXCJzdGFjazppdGVtOnRleHRSZW5kZXJBZGp1c3RcIiwge1xuICAgICAgICAgICAgICAgICAgZzogZyxcbiAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICBpaTogaWksXG4gICAgICAgICAgICAgICAgICBwcmV2TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZExlZnQ6ICtjb3JyZWN0ZWRMZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJlZENlbnRlclg6ICtyZW5kZXJlZENlbnRlclgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIHJlZkNlbnRlclg6ICt0YXJnZXRSZW5kZXJDZW50ZXJYLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICBkZWx0YTogK3JlbmRlckRlbHRhLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdMZWZ0ID0gY29ycmVjdGVkTGVmdDtcbiAgICAgICAgICAgICAgICBpdC5ub2RlLnN0eWxlLmxlZnQgPSAobmV3TGVmdCAtIChpbmZvLnBhZEwgfHwgMCkpICsgXCJweFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKG5ld1RvcCAtIGl0LnRvcCkgPiAwLjUgfHwgTWF0aC5hYnMobmV3TGVmdCAtIGl0LmxlZnQpID4gMC41KSBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBpdGVtQm90dG9tID0gbmV3VG9wICsgKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgICBpZiAoaXRlbUJvdHRvbSA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGl0ZW1Cb3R0b207XG4gICAgICAgIH1cblxyXG4gICAgICAgIC8vIEF2YW56YSBlbCBjdXJzb3IgbG9jYWwgYWwgZmluYWwgZGVsIGNsdXN0ZXJcclxuICAgICAgICBjb2xDdXJzb3IgPSBNYXRoLm1heChjb2xDdXJzb3IsIGNsdXN0ZXJCb3R0b21Vc2VkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWwgdGVybWluYXIgbGEgY29sdW1uYSwgZWwgY3Vyc29yIGdsb2JhbCBiYWphIGhhc3RhIGRvbmRlIGxsZWfDsyBlc3RhIGNvbHVtbmFcclxuICAgICAgZ2xvYmFsQ3Vyc29yID0gTWF0aC5tYXgoZ2xvYmFsQ3Vyc29yLCBjb2xDdXJzb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZWVkZWQgPSBnbG9iYWxDdXJzb3IgKyBDRkcuUEFEX0JPVDtcclxuICAgIG1zbExvZyhcInN0YWNrOmVuZFwiLCB7XHJcbiAgICAgIGNoYW5nZWQ6IGNoYW5nZWQsXHJcbiAgICAgIG5lZWRlZEhlaWdodDogK25lZWRlZC50b0ZpeGVkKDEpLFxyXG4gICAgICBmaW5hbEN1cnNvcjogK2dsb2JhbEN1cnNvci50b0ZpeGVkKDEpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IGNoYW5nZWQ6IGNoYW5nZWQsIG5lZWRlZEhlaWdodDogbmVlZGVkIH07XHJcbiAgfVxyXG5gLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsianNTdGFja2luZ0Jsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartSectionLayout.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMobileSmartSectionLayoutScript: () => (/* binding */ buildMobileSmartSectionLayoutScript)\n/* harmony export */ });\n/* harmony import */ var _mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobileSmartLayout */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts\");\n// functions/src/utils/mobileSmartSectionLayout.ts\n\nfunction buildMobileSmartSectionLayoutScript(opts) {\n    const cfg = (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)(opts);\n    return (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.buildScript)(cfg);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBRWlCO0FBRTVELFNBQVNFLG9DQUFvQ0MsSUFBOEI7SUFDaEYsTUFBTUMsTUFBTUosbUVBQWVBLENBQUNHO0lBQzVCLE9BQU9GLCtEQUFXQSxDQUFDRztBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHNcclxuaW1wb3J0IHsgTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zIH0gZnJvbSBcIi4vbW9iaWxlU21hcnRMYXlvdXRcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplQ29uZmlnLCBidWlsZFNjcmlwdCB9IGZyb20gXCIuL21vYmlsZVNtYXJ0TGF5b3V0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQob3B0czogTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBjZmcgPSBub3JtYWxpemVDb25maWcob3B0cyk7XHJcbiAgcmV0dXJuIGJ1aWxkU2NyaXB0KGNmZyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUNvbmZpZyIsImJ1aWxkU2NyaXB0IiwiYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQiLCJvcHRzIiwiY2ZnIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts\n");

/***/ })

};
;