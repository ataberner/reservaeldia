"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_functions_src_utils_generarHTMLDesdeSecciones_ts";
exports.ids = ["_pages-dir-node_functions_src_utils_generarHTMLDesdeSecciones_ts"];
exports.modules = {

/***/ "(pages-dir-node)/./functions/src/models/lineConstants.ts":
/*!***********************************************!*\
  !*** ./functions/src/models/lineConstants.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LINE_CONSTANTS: () => (/* binding */ LINE_CONSTANTS)\n/* harmony export */ });\n// functions/src/models/lineConstants.ts\n// Mismas constantes para el backend (TypeScript)\nconst LINE_CONSTANTS = {\n    STROKE_WIDTH: 2,\n    HIT_STROKE_WIDTH: 15,\n    DEFAULT_LENGTH: 100,\n    DEFAULT_COLOR: \"#000000\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvbW9kZWxzL2xpbmVDb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDMUMsTUFBTUEsaUJBQWlCO0lBQzVCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0FBQ2pCLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFxtb2RlbHNcXGxpbmVDb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy9tb2RlbHMvbGluZUNvbnN0YW50cy50c1xyXG4vLyBNaXNtYXMgY29uc3RhbnRlcyBwYXJhIGVsIGJhY2tlbmQgKFR5cGVTY3JpcHQpXHJcbmV4cG9ydCBjb25zdCBMSU5FX0NPTlNUQU5UUyA9IHtcclxuICBTVFJPS0VfV0lEVEg6IDIsXHJcbiAgSElUX1NUUk9LRV9XSURUSDogMTUsXHJcbiAgREVGQVVMVF9MRU5HVEg6IDEwMCxcclxuICBERUZBVUxUX0NPTE9SOiBcIiMwMDAwMDBcIlxyXG59OyJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsIlNUUk9LRV9XSURUSCIsIkhJVF9TVFJPS0VfV0lEVEgiLCJERUZBVUxUX0xFTkdUSCIsIkRFRkFVTFRfQ09MT1IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/models/lineConstants.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeObjetos.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   generarHTMLDesdeObjetos: () => (/* binding */ generarHTMLDesdeObjetos)\n/* harmony export */ });\n/* harmony import */ var _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/lineConstants */ \"(pages-dir-node)/./functions/src/models/lineConstants.ts\");\n\n// ✅ Escapar strings para meterlos en atributos/HTML\nfunction escHTML(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction escapeAttr(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nconst MOTION_EFFECT_VALUES = new Set([\n    \"none\",\n    \"reveal\",\n    \"draw\",\n    \"zoom\",\n    \"hover\",\n    \"pulse\"\n]);\nfunction sanitizeMotionEffect(value) {\n    const normalized = String(value || \"\").trim().toLowerCase();\n    return MOTION_EFFECT_VALUES.has(normalized) ? normalized : \"none\";\n}\nfunction normalizeRoleValue(value) {\n    return String(value || \"\").trim().toLowerCase();\n}\nfunction mapObjToDataType(obj) {\n    const tipo = normalizeRoleValue(obj?.tipo);\n    const figura = normalizeRoleValue(obj?.figura);\n    if (tipo === \"texto\" || tipo === \"text\") return \"text\";\n    if (tipo === \"imagen\" || tipo === \"image\") return \"image\";\n    if (tipo === \"icono\" || tipo === \"icono-svg\" || tipo === \"icon\") return \"icon\";\n    if (tipo === \"galeria\" || tipo === \"gallery\") return \"gallery\";\n    if (tipo === \"countdown\") return \"countdown\";\n    if (tipo === \"rsvp-boton\" || tipo === \"rsvp\") return \"rsvp\";\n    if (tipo === \"button\" || tipo === \"boton\") return \"button\";\n    if (tipo === \"line\" || tipo === \"divider\") return \"divider\";\n    if (tipo === \"forma\" && figura === \"line\") return \"divider\";\n    if (tipo === \"forma\") return \"shape\";\n    return \"unknown\";\n}\nfunction inferDataRole(obj) {\n    const explicitRole = normalizeRoleValue(obj?.role || obj?.rol);\n    if (explicitRole) return explicitRole;\n    const type = mapObjToDataType(obj);\n    if (type === \"text\") {\n        const fontSize = Number(obj?.fontSize);\n        if (Number.isFinite(fontSize) && fontSize >= 30) return \"title\";\n        if (Number.isFinite(fontSize) && fontSize >= 22) return \"subtitle\";\n        return \"body\";\n    }\n    if (type === \"divider\") return \"divider\";\n    if (type === \"image\") return \"image\";\n    if (type === \"icon\") return \"icon\";\n    if (type === \"gallery\") return \"gallery\";\n    if (type === \"countdown\") return \"countdown\";\n    if (type === \"rsvp\" || type === \"button\") return \"cta\";\n    if (type === \"shape\") return \"decorative\";\n    return \"content\";\n}\nfunction buildMotionDataAttrs(obj) {\n    const dataType = escapeAttr(mapObjToDataType(obj));\n    const dataRole = escapeAttr(inferDataRole(obj));\n    const dataMotion = escapeAttr(sanitizeMotionEffect(obj?.motionEffect));\n    return `data-type=\"${dataType}\" data-role=\"${dataRole}\" data-motion=\"${dataMotion}\"`;\n}\nfunction appendMotionDataAttrs(htmlElemento, obj) {\n    if (!htmlElemento || typeof htmlElemento !== \"string\") return htmlElemento;\n    const attrs = buildMotionDataAttrs(obj);\n    return htmlElemento.replace(/(<(?:div|img|svg)\\b[^>]*\\bclass=\"[^\"]*\\bobjeto\\b[^\"]*\")/i, `$1 ${attrs}`);\n}\nfunction getLinkProps(obj) {\n    const raw = obj?.enlace;\n    if (!raw) return null;\n    if (typeof raw === \"string\") {\n        const href = escapeAttr(raw);\n        if (!href) return null;\n        return {\n            href,\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n        };\n    }\n    const href = escapeAttr(raw.href || \"\");\n    if (!href) return null;\n    const target = escapeAttr(raw.target || \"_blank\");\n    const rel = escapeAttr(raw.rel || \"noopener noreferrer\");\n    return {\n        href,\n        target,\n        rel\n    };\n}\nfunction envolverSiEnlace(htmlElemento, obj) {\n    const htmlConData = appendMotionDataAttrs(htmlElemento, obj);\n    if (obj?.tipo === \"rsvp-boton\") return htmlConData;\n    const link = getLinkProps(obj);\n    if (!link) return htmlConData;\n    return `<a href=\"${link.href}\" target=\"${link.target}\" rel=\"${link.rel}\" style=\"text-decoration:none;color:inherit;display:contents\">${htmlConData}</a>`;\n}\nfunction escapeHTML(texto = \"\") {\n    return texto.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction generarHTMLDesdeObjetos(objetos, _secciones) {\n    const altoModoPorSeccion = new Map((_secciones || []).map((s)=>[\n            s.id,\n            String(s.altoModo || \"fijo\").toLowerCase()\n        ]));\n    function esSeccionPantalla(obj) {\n        const modo = altoModoPorSeccion.get(obj?.seccionId) || \"fijo\";\n        return modo === \"pantalla\";\n    }\n    function isFullBleed(obj) {\n        return String(obj?.anclaje || \"\").toLowerCase() === \"fullbleed\";\n    }\n    /**\r\n   * ✅ Escala uniforme del CONTENIDO:\r\n   * - pantalla: var(--sfinal) (fit si hace falta)\r\n   * - fijo: var(--sx)\r\n   */ function sContenidoVar(obj) {\n        return esSeccionPantalla(obj) ? \"var(--sfinal)\" : \"var(--sx)\";\n    }\n    /**\r\n   * ✅ X scale:\r\n   * - fullBleed: var(--bx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sX(obj) {\n        return isFullBleed(obj) ? \"var(--bx)\" : sContenidoVar(obj);\n    }\n    /**\r\n   * ✅ Y scale:\r\n   * - fullBleed: var(--sx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sY(obj) {\n        return isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n    }\n    function pxX(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return `calc(${sX(obj)} * ${n}px)`;\n    }\n    function pxY(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return `calc(${sY(obj)} * ${n}px)`;\n    }\n    // ===========================\n    // ✅ PANTALLA: top por porcentaje\n    // ===========================\n    const ALTURA_EDITOR_PANTALLA = 500;\n    // ✅ Offsets en secciones Pantalla: ON\n    // ⚠️ IMPORTANTE: este archivo SOLO genera objetos.\n    // El valor DESKTOP/MOBILE real se controla vía CSS global con:\n    //   :root { --pantalla-y-offset: Xpx }\n    //   @media (max-width: 640px) { :root { --pantalla-y-offset: Ypx } }\n    //\n    // Acá dejamos fallback (desktop) por si la variable CSS no existe.\n    const PANTALLA_Y_OFFSET_DESKTOP_PX = 0;\n    function clamp01(n) {\n        const x = Number(n);\n        if (!Number.isFinite(x)) return null;\n        return Math.max(0, Math.min(1, x));\n    }\n    function getYPxEditor(obj) {\n        // ✅ En Pantalla ON: yNorm es la fuente de verdad (0..1)\n        const yn = clamp01(obj?.yNorm);\n        if (yn != null) return yn * ALTURA_EDITOR_PANTALLA;\n        // fallback: si no hay yNorm, usamos y como \"editor px\"\n        const yPx = Number(obj?.y);\n        if (Number.isFinite(yPx)) return yPx;\n        return 0;\n    }\n    function topPantallaCSS(obj, ynRaw) {\n        const yn = clamp01(ynRaw) ?? 0;\n        const yBloqueDisenio = `calc(${sContenidoVar(obj)} * ${ALTURA_EDITOR_PANTALLA}px)`;\n        const yBasePantalla = `var(--pantalla-y-base, 0px)`;\n        const ynCompactado = `calc(0.5 + ((${yn}) - 0.5) * (1 - var(--pantalla-y-compact, 0)))`;\n        return `calc(\n  ${yBasePantalla}\n  + (${yBloqueDisenio} * ${ynCompactado})\n  + (${sContenidoVar(obj)} * var(--pantalla-y-offset, ${PANTALLA_Y_OFFSET_DESKTOP_PX}px))\n)`;\n    }\n    /**\n   * ✅ topCSS:\n   * - Pantalla ON: usa bloque de diseño escalado (500px * sfinal) + offset base uniforme\n   * - Texto en Pantalla ON: suma offset (CSS var) escalado por sContenidoVar\n   * - Fijo: pxY(obj, y)\n   */ function topCSS(obj) {\n        if (esSeccionPantalla(obj)) {\n            const yPxEditor = getYPxEditor(obj);\n            const yn = clamp01(yPxEditor / ALTURA_EDITOR_PANTALLA) ?? 0;\n            return topPantallaCSS(obj, yn);\n        }\n        const y = Number(obj?.y || 0);\n        return pxY(obj, y);\n    }\n    /**\r\n   * ✅ Variante para cuando ya tenés yPx (en \"px editor\")\r\n   */ function topCSSFromYPx(obj, yPx) {\n        if (esSeccionPantalla(obj)) {\n            const yn = clamp01(yPx / ALTURA_EDITOR_PANTALLA) ?? 0;\n            return topPantallaCSS(obj, yn);\n        }\n        return pxY(obj, yPx);\n    }\n    function stylePosBase(obj) {\n        const x = Number(obj?.x || 0);\n        const rot = obj?.rotation ?? 0;\n        const scaleX = obj?.scaleX ?? 1;\n        const scaleY = obj?.scaleY ?? 1;\n        const zIndex = Number.isFinite(obj?.zIndex) ? obj.zIndex : undefined;\n        return `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSS(obj)};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: top left;\n${zIndex !== undefined ? `z-index:${zIndex};` : \"\"}\npointer-events: auto;\n`.trim();\n    }\n    function styleSize(obj, w, h) {\n        const ww = Number.isFinite(w) ? w : undefined;\n        const hh = Number.isFinite(h) ? h : undefined;\n        const parts = [];\n        if (ww !== undefined) parts.push(`width: ${pxX(obj, ww)};`);\n        if (hh !== undefined) parts.push(`height: ${pxY(obj, hh)};`);\n        return parts.join(\"\\n\");\n    }\n    function renderIconoSvgNuevoInline(obj) {\n        const viewBox = obj.viewBox || \"0 0 24 24\";\n        const color = obj.color || \"#000\";\n        const paths = Array.isArray(obj.paths) ? obj.paths : [];\n        if (!paths.length) return \"\";\n        const w = Number.isFinite(obj?.width) ? obj.width : 24;\n        const h = Number.isFinite(obj?.height) ? obj.height : 24;\n        const rot = obj?.rotation ?? 0;\n        const scaleX = obj?.scaleX ?? 1;\n        const scaleY = obj?.scaleY ?? 1;\n        const x = Number(obj?.x || 0);\n        const yPx = getYPxEditor(obj);\n        const pathsHtml = paths.map((p)=>p?.d ? `<path d=\"${escHTML(p.d)}\" fill=\"${escHTML(color)}\"></path>` : \"\").join(\"\");\n        const style = `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSSFromYPx(obj, yPx)};\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: top left;\npointer-events: auto;\n`.trim();\n        return `<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${escHTML(viewBox)}\" style=\"${style}\">${pathsHtml}</svg>`;\n    }\n    return objetos.map((obj)=>{\n        const tipo = obj?.tipo;\n        // ---------------- TEXTO ----------------\n        if (tipo === \"texto\") {\n            const align = String(obj.align || obj.textAlign || \"left\").toLowerCase();\n            const color = obj.colorTexto || obj.color || obj.fill || \"#000\";\n            const baseLineHeight = typeof obj.lineHeight === \"number\" && obj.lineHeight > 0 ? obj.lineHeight : 1.2;\n            const lineHeightFinal = baseLineHeight * 0.92;\n            const safeTexto = escHTML(obj.texto || \"\");\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const fs = Number.isFinite(obj?.fontSize) ? obj.fontSize : 24;\n            // ⚠️ texto fullBleed NO hace fit => escala con var(--sx)\n            const sFont = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const rot = obj?.rotation ?? 0;\n            const scaleX = obj?.scaleX ?? 1;\n            const scaleY = obj?.scaleY ?? 1;\n            const origin = align === \"center\" ? \"top center\" : align === \"right\" ? \"top right\" : \"top left\";\n            const style = `\n${baseStyle}\n/* ✅ mantener geometría estable y escalar tipografía por font-size (no por transform). */\ntransform-origin: ${origin};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\n${w !== undefined ? `width: ${pxX(obj, w)};` : \"\"}\nfont-size: calc(${sFont} * ${fs}px * var(--text-zoom, 1));\nfont-family: ${obj.fontFamily || \"sans-serif\"};\nfont-weight: ${obj.fontWeight || \"normal\"};\nfont-style: ${obj.fontStyle || \"normal\"};\ntext-decoration: ${obj.textDecoration || \"none\"};\ncolor: ${color};\ntext-align: ${align};\nwhite-space: pre-wrap;\nline-height: ${lineHeightFinal};\npadding: 0;\nmargin: 0;\nbox-sizing: content-box;\n${obj.stroke && obj.strokeWidth > 0 ? `-webkit-text-stroke: ${obj.strokeWidth}px ${obj.stroke};` : \"\"}\n${obj.shadowColor ? `text-shadow: ${obj.shadowOffsetX || 0}px ${obj.shadowOffsetY || 0}px ${obj.shadowBlur || 0}px ${obj.shadowColor};` : \"text-shadow: none;\"}\n`.trim();\n            return envolverSiEnlace(`<div class=\"objeto\" data-debug-texto=\"1\" style=\"${style}\">${safeTexto}</div>`, obj);\n        }\n        // ---------------- IMAGEN ----------------\n        if (tipo === \"imagen\") {\n            const src = obj.src || obj.url || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const style = `\n${baseStyle}\n${styleSize(obj, w, h)}\nobject-fit: contain;\ndisplay: block;\n`.trim();\n            return envolverSiEnlace(`<img class=\"objeto\" src=\"${escapeAttr(src)}\" style=\"${style}\" />`, obj);\n        }\n        // ---------------- ICONO (nuevo) ----------------\n        if (tipo === \"icono\") {\n            if (obj.formato === \"svg\") {\n                const svgHtml = renderIconoSvgNuevoInline(obj);\n                if (!svgHtml) return \"\";\n                return envolverSiEnlace(svgHtml, obj);\n            }\n            const src = obj.url || obj.src || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const style = `\n${baseStyle}\n${styleSize(obj, w, h)}\nobject-fit: contain;\ndisplay: block;\n`.trim();\n            return envolverSiEnlace(`<img class=\"objeto\" src=\"${escapeAttr(src)}\" style=\"${style}\" />`, obj);\n        }\n        // ---------------- ICONO LEGACY (icono-svg) ----------------\n        if (tipo === \"icono-svg\" && obj.d) {\n            const vb = obj.viewBox || \"0 0 100 100\";\n            const fill = obj.color || \"#000\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : 100;\n            const h = Number.isFinite(obj?.height) ? obj.height : 100;\n            const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nfill: ${escapeAttr(fill)};\n`.trim();\n            const svg = `<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${escapeAttr(vb)}\" style=\"${style}\"><path d=\"${escHTML(obj.d)}\" /></svg>`;\n            return envolverSiEnlace(svg, obj);\n        }\n        // ---------------- COUNTDOWN ----------------\n        if (tipo === \"countdown\") {\n            const targetISO = obj.targetISO || obj.fechaObjetivo || obj.fechaISO || \"\";\n            const textColor = obj.colorTexto ?? obj.color ?? \"#111\";\n            const fontFamily = obj.fontFamily || \"Inter, system-ui, sans-serif\";\n            const preset = obj.presetId || obj.layout || \"pills\";\n            const isMinimal = String(preset).toLowerCase().includes(\"minimal\");\n            // ✅ ancho/alto del objeto (si existen)\n            const wObj = Number.isFinite(obj?.width) ? Number(obj.width) : null;\n            const hObj = Number.isFinite(obj?.height) ? Number(obj.height) : null;\n            // ✅ gap: si viene de Konva, respetarlo\n            const gap = Number.isFinite(obj.gap) ? Number(obj.gap) : Number.isFinite(obj.spacing) ? Number(obj.spacing) : 8;\n            // ✅ Si tu Konva guarda chipWidth / paddingX, respetalos\n            // chipWidth: ancho interno del texto (sin padding)\n            const chipWidthProp = Number.isFinite(obj.chipWidth) ? Number(obj.chipWidth) : null;\n            const paddingXProp = Number.isFinite(obj.paddingX) ? Number(obj.paddingX) : null;\n            // ✅ Derivación raíz (cuando no hay props)\n            const n = 4;\n            // chipWTotal: ancho total de cada chip (incluye padding)\n            let chipWTotal = 56; // fallback razonable\n            if (wObj && wObj > 0) {\n                chipWTotal = Math.max(40, (wObj - gap * (n - 1)) / n);\n            }\n            // paddingX derivado del chipWTotal (si no vino)\n            const paddingX = paddingXProp ?? Math.max(6, Math.round(chipWTotal * 0.18)); // ~18%\n            const paddingY = Math.max(5, Math.round(paddingX * 0.65));\n            // chipWidth (texto) derivado si no vino\n            const chipWidth = chipWidthProp ?? Math.max(10, Math.round(chipWTotal - paddingX * 2));\n            // ✅ font sizes: si vienen, respetar; si no, derivar desde chipWTotal\n            const valueSize = Number.isFinite(obj.fontSize) ? Number(obj.fontSize) : Math.max(14, Math.round(chipWTotal * 0.34));\n            const labelSize = Number.isFinite(obj.labelSize) ? Number(obj.labelSize) : Math.max(9, Math.round(valueSize * 0.62));\n            const labelColor = obj.labelColor ?? \"#6b7280\";\n            const fontWeight = Number.isFinite(obj.fontWeight) ? obj.fontWeight : 700;\n            const letterSpacing = Number.isFinite(obj.letterSpacing) ? obj.letterSpacing : 0;\n            // ✅ estilos de chip\n            const containerBgFinal = \"transparent\";\n            const chipBgFinal = isMinimal ? \"transparent\" : obj.chipBackground ?? obj.boxBg ?? \"rgba(255,255,255,.75)\";\n            const chipBorderColorFinal = isMinimal ? \"transparent\" : obj.chipBorder ?? obj.boxBorder ?? \"rgba(0,0,0,.08)\";\n            const containerRadius = Number.isFinite(obj.boxRadius) ? obj.boxRadius : Number.isFinite(obj.radius) ? obj.radius : 10;\n            const chipRadiusFinal = Number.isFinite(obj.chipRadius) ? obj.chipRadius : containerRadius;\n            const baseStyle = stylePosBase(obj);\n            // ✅ Escala correcta (respeta pantalla y bleed)\n            const sChip = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const containerStyle = `\n${baseStyle}\n${wObj ? `width: ${pxX(obj, wObj)};` : \"\"}\n${hObj ? `height: ${pxY(obj, hObj)};` : \"\"}\ndisplay: flex;\nalign-items: center;\njustify-content: center;\ngap: calc(${sChip} * ${gap}px);\nfont-family: ${fontFamily};\ncolor: ${textColor};\nbackground: ${containerBgFinal};\nborder-radius: calc(${sChip} * ${containerRadius}px);\nletter-spacing: calc(${sChip} * ${letterSpacing}px);\n`.trim();\n            const chipStyle = `\nwidth: calc(${sChip} * ${Math.round(chipWTotal)}px);\npadding: calc(${sChip} * ${paddingY}px) calc(${sChip} * ${paddingX}px);\nborder: ${isMinimal ? \"0\" : `calc(${sChip} * 1px) solid ${chipBorderColorFinal}`};\nborder-radius: calc(${sChip} * ${chipRadiusFinal}px);\ndisplay: flex;\nflex-direction: column;\nalign-items: center;\njustify-content: center;\nbackground: ${chipBgFinal};\nbox-sizing: border-box;\n`.trim();\n            const valueStyle = `\nfont-weight: ${fontWeight};\nfont-size: calc(${sChip} * ${valueSize}px);\nline-height: 1;\n`.trim();\n            const labelStyle = `\nfont-size: calc(${sChip} * ${labelSize}px);\ncolor: ${labelColor};\nline-height: 1.05;\n`.trim();\n            const showLabels = obj.showLabels !== false;\n            const labels = obj.labels ?? {\n                dias: \"Días\",\n                horas: \"Horas\",\n                min: \"Min\",\n                seg: \"Seg\"\n            };\n            const htmlCountdown = `\n<div class=\"objeto\"\n  data-mobile-cluster=\"isolated\"\n  data-mobile-center=\"force\"\n  data-countdown\n  data-target=\"${escapeAttr(targetISO)}\"\n  data-preset=\"${escapeAttr(preset)}\" style=\"${containerStyle}\">\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.dias)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.horas)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.min)}</span>` : \"\"}\n  </div>\n  <div class=\"cd-chip\" style=\"${chipStyle}\">\n    <span class=\"cd-val\" style=\"${valueStyle}\">00</span>\n    ${showLabels ? `<span class=\"cd-lab\" style=\"${labelStyle}\">${escapeAttr(labels.seg)}</span>` : \"\"}\n  </div>\n</div>\n`.trim();\n            return appendMotionDataAttrs(htmlCountdown, obj);\n        }\n        // ---------------- GALERÍA ----------------\n        if (tipo === \"galeria\") {\n            const rows = Math.max(1, parseInt(obj.rows || 1, 10));\n            const cols = Math.max(1, parseInt(obj.cols || 1, 10));\n            const gapPx = Math.max(0, parseInt(obj.gap || 0, 10));\n            const radiusPx = Math.max(0, parseInt(obj.radius || 0, 10));\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj?.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj?.height) ? obj.height : undefined;\n            const sGrid = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const styleContenedor = `\n${baseStyle}\n${styleSize(obj, w, h)}\ndisplay: grid;\ngrid-template-columns: repeat(${cols}, 1fr);\ngrid-template-rows: repeat(${rows}, 1fr);\ngap: calc(${sGrid} * ${gapPx}px);\nbox-sizing: border-box;\n`.trim();\n            const total = rows * cols;\n            const cells = Array.from({\n                length: total\n            }, (_, i)=>{\n                const c = obj.cells && obj.cells[i] || {};\n                return {\n                    mediaUrl: c.mediaUrl || \"\",\n                    fit: c.fit === \"contain\" ? \"contain\" : \"cover\",\n                    bg: c.bg || \"#f3f4f6\"\n                };\n            });\n            const htmlCeldas = cells.map((cell, idx)=>{\n                const safeSrc = escapeAttr(cell.mediaUrl || \"\");\n                const celdaStyle = `\nposition: relative;\nwidth: 100%;\nheight: 100%;\noverflow: hidden;\nborder-radius: calc(${sGrid} * ${radiusPx}px);\nbackground: ${cell.bg};\n`.trim();\n                if (!safeSrc) {\n                    return `<div class=\"galeria-celda\" data-index=\"${idx}\" style=\"${celdaStyle}\"></div>`;\n                }\n                return `\n<div class=\"galeria-celda galeria-celda--clickable\"\n     data-index=\"${idx}\"\n     data-gallery-image=\"1\"\n     role=\"button\"\n     tabindex=\"0\"\n     aria-label=\"Ver imagen en pantalla completa\"\n     style=\"${celdaStyle}\">\n  <img src=\"${safeSrc}\" alt=\"\" loading=\"lazy\" decoding=\"async\"\n       style=\"width:100%;height:100%;object-fit:${cell.fit};display:block;\" />\n</div>\n`.trim();\n            }).join(\"\");\n            const htmlGaleria = `<div class=\"objeto galeria\" style=\"${styleContenedor}\">${htmlCeldas}</div>`;\n            return envolverSiEnlace(htmlGaleria, obj);\n        }\n        // ---------------- RSVP BOTÓN ----------------\n        if (tipo === \"rsvp-boton\") {\n            const texto = escapeHTML(obj.texto || \"Confirmar asistencia\");\n            const w = Number.isFinite(obj?.ancho) ? obj.ancho : 200;\n            const h = Number.isFinite(obj?.alto) ? obj.alto : 50;\n            const color = obj.color || \"#773dbe\";\n            const colorTexto = obj.colorTexto || \"#ffffff\";\n            const fontSize = Number.isFinite(obj?.fontSize) ? obj.fontSize : 18;\n            const fontFamily = obj.fontFamily || \"sans-serif\";\n            const fontWeight = obj.fontWeight || \"bold\";\n            const fontStyle = obj.fontStyle || \"normal\";\n            const textDecoration = obj.textDecoration || \"none\";\n            const align = obj.align || \"center\";\n            const baseStyle = stylePosBase(obj);\n            // RSVP (contenido): si está en pantalla, fittea (sContenidoVar)\n            const sBtn = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nbackground-color: ${color};\ncolor: ${colorTexto};\nfont-size: calc(${sBtn} * ${fontSize}px);\nfont-family: ${fontFamily};\nfont-weight: ${fontWeight};\nfont-style: ${fontStyle};\ntext-decoration: ${textDecoration};\ntext-align: ${align};\ndisplay: flex;\nalign-items: center;\njustify-content: center;\nborder-radius: calc(${sBtn} * 8px);\ncursor: pointer;\n`.trim();\n            const htmlRsvp = `\n<div class=\"objeto is-interactive rsvp-boton\"\n  id=\"abrirModalRSVP\"\n  data-accion=\"abrir-rsvp\"\n  data-rsvp-open\n  role=\"button\"\n  tabindex=\"0\"\n  aria-label=\"Confirmar asistencia\"\n  style=\"${style}\">\n  ${texto}\n</div>\n`.trim();\n            return appendMotionDataAttrs(htmlRsvp, obj);\n        }\n        // ---------------- FORMAS ----------------\n        if (tipo === \"forma\") {\n            const fill = obj.color || \"#000\";\n            const figura = obj.figura;\n            if (figura === \"rect\") {\n                const w = Number.isFinite(obj?.width) ? obj.width : 100;\n                const h = Number.isFinite(obj?.height) ? obj.height : 100;\n                const cornerRadius = obj.cornerRadius || 0;\n                const fontSize = obj.fontSize || 24;\n                const fontFamily = obj.fontFamily || \"sans-serif\";\n                const fontWeight = obj.fontWeight || \"normal\";\n                const fontStyle = obj.fontStyle || \"normal\";\n                const textDecoration = obj.textDecoration || \"none\";\n                const align = obj.align || \"center\";\n                const colorTexto = obj.colorTexto || \"#000000\";\n                const texto = escHTML(obj.texto || \"\");\n                const baseStyle = stylePosBase(obj);\n                const sRectText = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n                const style = `\n${baseStyle}\nwidth: ${pxX(obj, w)};\nheight: ${pxY(obj, h)};\nbackground: ${fill};\nborder-radius: calc(${sRectText} * ${cornerRadius}px);\ndisplay: flex;\nalign-items: center;\njustify-content: ${align === \"left\" ? \"flex-start\" : align === \"right\" ? \"flex-end\" : \"center\"};\ntext-align: ${align};\npadding: calc(${sRectText} * 4px);\nbox-sizing: border-box;\n`.trim();\n                const inner = `\n<div style=\"\n  width: 100%;\n  font-size: calc(${sRectText} * ${fontSize}px);\n  font-family: ${fontFamily};\n  font-weight: ${fontWeight};\n  font-style: ${fontStyle};\n  text-decoration: ${textDecoration};\n  color: ${colorTexto};\n  line-height: 1.2;\n  white-space: pre-wrap;\n  word-break: break-word;\n\">${texto}</div>\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${style}\">${inner}</div>`, obj);\n            }\n            if (figura === \"circle\") {\n                const radius = Number.isFinite(obj?.radius) ? obj.radius : 50;\n                const diameter = radius * 2;\n                const x = Number(obj?.x || 0) - radius;\n                const yPxCenter = getYPxEditor(obj);\n                const yPxTopLeft = yPxCenter - radius;\n                const rot = obj?.rotation ?? 0;\n                const scaleX = obj?.scaleX ?? 1;\n                const scaleY = obj?.scaleY ?? 1;\n                const style = `\nposition: absolute;\nleft: ${pxX(obj, x)};\ntop: ${topCSSFromYPx(obj, yPxTopLeft)};\nwidth: ${pxX(obj, diameter)};\nheight: ${pxY(obj, diameter)};\nborder-radius: 50%;\nbackground: ${fill};\ntransform: rotate(${rot}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: center center;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${style}\"></div>`, obj);\n            }\n            if (figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH,\n                    0\n                ];\n                const x1 = parseFloat(points[0]) || 0;\n                const y1 = parseFloat(points[1]) || 0;\n                const x2 = parseFloat(points[2]) || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH;\n                const y2 = parseFloat(points[3]) || 0;\n                const strokeWidth = obj.strokeWidth || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.STROKE_WIDTH;\n                const deltaX = x2 - x1;\n                const deltaY = y2 - y1;\n                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n                const startX = Number(obj?.x || 0) + x1;\n                const baseY = getYPxEditor(obj);\n                const startY = baseY + y1;\n                const totalRotation = angle + (obj.rotation || 0);\n                const scaleX = obj?.scaleX ?? 1;\n                const scaleY = obj?.scaleY ?? 1;\n                // alto de línea: usamos escala Y del objeto (contenido: sfinal/sx, bleed: sx)\n                const lineH = `calc(${sY(obj)} * ${strokeWidth}px)`;\n                const style = `\nposition: absolute;\nleft: ${pxX(obj, startX)};\ntop: ${topCSSFromYPx(obj, startY)};\nwidth: ${pxX(obj, length)};\nheight: ${lineH};\nbackground: ${fill};\ntransform: rotate(${totalRotation}deg) scale(${scaleX}, ${scaleY});\ntransform-origin: 0 50%;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto linea\" style=\"${style}\"></div>`, obj);\n            }\n            if (figura === \"triangle\") {\n                const radius = obj.radius || 60;\n                const sin60 = Math.sqrt(3) / 2;\n                const cos60 = 0.5;\n                const triangleWidth = 2 * radius * sin60;\n                const triangleHeight = radius * (1 + cos60);\n                const centroidOffsetY = triangleHeight / 3;\n                const baseY = getYPxEditor(obj);\n                const topContainerPx = baseY - (triangleHeight - centroidOffsetY);\n                const leftContainer = Number(obj?.x || 0) - triangleWidth / 2;\n                const baseStyle = `\nposition: absolute;\nleft: ${pxX(obj, leftContainer)};\ntop: ${topCSSFromYPx(obj, topContainerPx)};\nwidth: ${pxX(obj, triangleWidth)};\nheight: ${pxY(obj, triangleHeight)};\nbackground: ${fill};\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%);\ntransform: rotate(${obj.rotation ?? 0}deg) scale(${obj.scaleX ?? 1}, ${obj.scaleY ?? 1});\ntransform-origin: center center;\npointer-events: auto;\n`.trim();\n                return envolverSiEnlace(`<div class=\"objeto\" style=\"${baseStyle}\"></div>`, obj);\n            }\n            return \"\";\n        }\n        return \"\";\n    }).join(\"\\n\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBRXpELG9EQUFvRDtBQUNwRCxTQUFTQyxRQUFRQyxNQUFXLEVBQUU7SUFDNUIsT0FBT0MsT0FBT0QsS0FDWEUsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxTQUFTQyxXQUFXSCxNQUFjLEVBQUU7SUFDbEMsT0FBT0MsT0FBT0QsS0FDWEUsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxNQUFNRSx1QkFBdUIsSUFBSUMsSUFBSTtJQUFDO0lBQVE7SUFBVTtJQUFRO0lBQVE7SUFBUztDQUFRO0FBRXpGLFNBQVNDLHFCQUFxQkMsS0FBVTtJQUN0QyxNQUFNQyxhQUFhUCxPQUFPTSxTQUFTLElBQUlFLElBQUksR0FBR0MsV0FBVztJQUN6RCxPQUFPTixxQkFBcUJPLEdBQUcsQ0FBQ0gsY0FBY0EsYUFBYTtBQUM3RDtBQUVBLFNBQVNJLG1CQUFtQkwsS0FBVTtJQUNwQyxPQUFPTixPQUFPTSxTQUFTLElBQUlFLElBQUksR0FBR0MsV0FBVztBQUMvQztBQUVBLFNBQVNHLGlCQUFpQkMsR0FBUTtJQUNoQyxNQUFNQyxPQUFPSCxtQkFBbUJFLEtBQUtDO0lBQ3JDLE1BQU1DLFNBQVNKLG1CQUFtQkUsS0FBS0U7SUFFdkMsSUFBSUQsU0FBUyxXQUFXQSxTQUFTLFFBQVEsT0FBTztJQUNoRCxJQUFJQSxTQUFTLFlBQVlBLFNBQVMsU0FBUyxPQUFPO0lBQ2xELElBQUlBLFNBQVMsV0FBV0EsU0FBUyxlQUFlQSxTQUFTLFFBQVEsT0FBTztJQUN4RSxJ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LGdCQUFnQi9OLE9BQU9ULEtBQUt1RCxLQUFLLEtBQUs2SyxnQkFBZ0I7Z0JBRTVELE1BQU14SCxZQUFZLENBQUM7O01BRXZCLEVBQUU1RCxJQUFJaEQsS0FBS3dPLGVBQWU7S0FDM0IsRUFBRWpLLGNBQWN2RSxLQUFLdU8sZ0JBQWdCO09BQ25DLEVBQUV2TCxJQUFJaEQsS0FBS29PLGVBQWU7UUFDekIsRUFBRWpMLElBQUluRCxLQUFLcU8sZ0JBQWdCO1lBQ3ZCLEVBQUU5SCxLQUFLOztrQkFFRCxFQUFFdkcsSUFBSTBFLFFBQVEsSUFBSSxFQUFFLFdBQVcsRUFBRTFFLElBQUkyRSxNQUFNLElBQUksRUFBRSxFQUFFLEVBQUUzRSxJQUFJNEUsTUFBTSxJQUFJLEVBQUU7OztBQUd2RixDQUFDLENBQUNqRixJQUFJO2dCQUVJLE9BQU84QixpQkFBaUIsQ0FBQywyQkFBMkIsRUFBRW1GLFVBQVUsUUFBUSxDQUFDLEVBQUU1RztZQUM3RTtZQUVBLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVCxHQUNDc0YsSUFBSSxDQUFDO0FBQ1YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTElORV9DT05TVEFOVFMgfSBmcm9tIFwiLi4vbW9kZWxzL2xpbmVDb25zdGFudHNcIjtcclxuXHJcbi8vIOKchSBFc2NhcGFyIHN0cmluZ3MgcGFyYSBtZXRlcmxvcyBlbiBhdHJpYnV0b3MvSFRNTFxyXG5mdW5jdGlvbiBlc2NIVE1MKHN0cjogYW55ID0gXCJcIik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIFN0cmluZyhzdHIpXHJcbiAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXHJcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcclxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxyXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXNjYXBlQXR0cihzdHI6IHN0cmluZyA9IFwiXCIpOiBzdHJpbmcge1xuICByZXR1cm4gU3RyaW5nKHN0cilcbiAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xufVxuXG5jb25zdCBNT1RJT05fRUZGRUNUX1ZBTFVFUyA9IG5ldyBTZXQoW1wibm9uZVwiLCBcInJldmVhbFwiLCBcImRyYXdcIiwgXCJ6b29tXCIsIFwiaG92ZXJcIiwgXCJwdWxzZVwiXSk7XG5cbmZ1bmN0aW9uIHNhbml0aXplTW90aW9uRWZmZWN0KHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBub3JtYWxpemVkID0gU3RyaW5nKHZhbHVlIHx8IFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gTU9USU9OX0VGRkVDVF9WQUxVRVMuaGFzKG5vcm1hbGl6ZWQpID8gbm9ybWFsaXplZCA6IFwibm9uZVwiO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSb2xlVmFsdWUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIHJldHVybiBTdHJpbmcodmFsdWUgfHwgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG1hcE9ialRvRGF0YVR5cGUob2JqOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCB0aXBvID0gbm9ybWFsaXplUm9sZVZhbHVlKG9iaj8udGlwbyk7XG4gIGNvbnN0IGZpZ3VyYSA9IG5vcm1hbGl6ZVJvbGVWYWx1ZShvYmo/LmZpZ3VyYSk7XG5cbiAgaWYgKHRpcG8gPT09IFwidGV4dG9cIiB8fCB0aXBvID09PSBcInRleHRcIikgcmV0dXJuIFwidGV4dFwiO1xuICBpZiAodGlwbyA9PT0gXCJpbWFnZW5cIiB8fCB0aXBvID09PSBcImltYWdlXCIpIHJldHVybiBcImltYWdlXCI7XG4gIGlmICh0aXBvID09PSBcImljb25vXCIgfHwgdGlwbyA9PT0gXCJpY29uby1zdmdcIiB8fCB0aXBvID09PSBcImljb25cIikgcmV0dXJuIFwiaWNvblwiO1xuICBpZiAodGlwbyA9PT0gXCJnYWxlcmlhXCIgfHwgdGlwbyA9PT0gXCJnYWxsZXJ5XCIpIHJldHVybiBcImdhbGxlcnlcIjtcbiAgaWYgKHRpcG8gPT09IFwiY291bnRkb3duXCIpIHJldHVybiBcImNvdW50ZG93blwiO1xuICBpZiAodGlwbyA9PT0gXCJyc3ZwLWJvdG9uXCIgfHwgdGlwbyA9PT0gXCJyc3ZwXCIpIHJldHVybiBcInJzdnBcIjtcbiAgaWYgKHRpcG8gPT09IFwiYnV0dG9uXCIgfHwgdGlwbyA9PT0gXCJib3RvblwiKSByZXR1cm4gXCJidXR0b25cIjtcbiAgaWYgKHRpcG8gPT09IFwibGluZVwiIHx8IHRpcG8gPT09IFwiZGl2aWRlclwiKSByZXR1cm4gXCJkaXZpZGVyXCI7XG4gIGlmICh0aXBvID09PSBcImZvcm1hXCIgJiYgZmlndXJhID09PSBcImxpbmVcIikgcmV0dXJuIFwiZGl2aWRlclwiO1xuICBpZiAodGlwbyA9PT0gXCJmb3JtYVwiKSByZXR1cm4gXCJzaGFwZVwiO1xuXG4gIHJldHVybiBcInVua25vd25cIjtcbn1cblxuZnVuY3Rpb24gaW5mZXJEYXRhUm9sZShvYmo6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IGV4cGxpY2l0Um9sZSA9IG5vcm1hbGl6ZVJvbGVWYWx1ZShvYmo/LnJvbGUgfHwgb2JqPy5yb2wpO1xuICBpZiAoZXhwbGljaXRSb2xlKSByZXR1cm4gZXhwbGljaXRSb2xlO1xuXG4gIGNvbnN0IHR5cGUgPSBtYXBPYmpUb0RhdGFUeXBlKG9iaik7XG4gIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgIGNvbnN0IGZvbnRTaXplID0gTnVtYmVyKG9iaj8uZm9udFNpemUpO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZm9udFNpemUpICYmIGZvbnRTaXplID49IDMwKSByZXR1cm4gXCJ0aXRsZVwiO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZm9udFNpemUpICYmIGZvbnRTaXplID49IDIyKSByZXR1cm4gXCJzdWJ0aXRsZVwiO1xuICAgIHJldHVybiBcImJvZHlcIjtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBcImRpdmlkZXJcIikgcmV0dXJuIFwiZGl2aWRlclwiO1xuICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSByZXR1cm4gXCJpbWFnZVwiO1xuICBpZiAodHlwZSA9PT0gXCJpY29uXCIpIHJldHVybiBcImljb25cIjtcbiAgaWYgKHR5cGUgPT09IFwiZ2FsbGVyeVwiKSByZXR1cm4gXCJnYWxsZXJ5XCI7XG4gIGlmICh0eXBlID09PSBcImNvdW50ZG93blwiKSByZXR1cm4gXCJjb3VudGRvd25cIjtcbiAgaWYgKHR5cGUgPT09IFwicnN2cFwiIHx8IHR5cGUgPT09IFwiYnV0dG9uXCIpIHJldHVybiBcImN0YVwiO1xuICBpZiAodHlwZSA9PT0gXCJzaGFwZVwiKSByZXR1cm4gXCJkZWNvcmF0aXZlXCI7XG5cbiAgcmV0dXJuIFwiY29udGVudFwiO1xufVxuXG5mdW5jdGlvbiBidWlsZE1vdGlvbkRhdGFBdHRycyhvYmo6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IGRhdGFUeXBlID0gZXNjYXBlQXR0cihtYXBPYmpUb0RhdGFUeXBlKG9iaikpO1xuICBjb25zdCBkYXRhUm9sZSA9IGVzY2FwZUF0dHIoaW5mZXJEYXRhUm9sZShvYmopKTtcbiAgY29uc3QgZGF0YU1vdGlvbiA9IGVzY2FwZUF0dHIoc2FuaXRpemVNb3Rpb25FZmZlY3Qob2JqPy5tb3Rpb25FZmZlY3QpKTtcbiAgcmV0dXJuIGBkYXRhLXR5cGU9XCIke2RhdGFUeXBlfVwiIGRhdGEtcm9sZT1cIiR7ZGF0YVJvbGV9XCIgZGF0YS1tb3Rpb249XCIke2RhdGFNb3Rpb259XCJgO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRNb3Rpb25EYXRhQXR0cnMoaHRtbEVsZW1lbnRvOiBzdHJpbmcsIG9iajogYW55KTogc3RyaW5nIHtcbiAgaWYgKCFodG1sRWxlbWVudG8gfHwgdHlwZW9mIGh0bWxFbGVtZW50byAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGh0bWxFbGVtZW50bztcblxuICBjb25zdCBhdHRycyA9IGJ1aWxkTW90aW9uRGF0YUF0dHJzKG9iaik7XG4gIHJldHVybiBodG1sRWxlbWVudG8ucmVwbGFjZShcbiAgICAvKDwoPzpkaXZ8aW1nfHN2ZylcXGJbXj5dKlxcYmNsYXNzPVwiW15cIl0qXFxib2JqZXRvXFxiW15cIl0qXCIpL2ksXG4gICAgYCQxICR7YXR0cnN9YFxuICApO1xufVxuXHJcbmZ1bmN0aW9uIGdldExpbmtQcm9wcyhvYmo6IGFueSkge1xyXG4gIGNvbnN0IHJhdyA9IG9iaj8uZW5sYWNlO1xyXG4gIGlmICghcmF3KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgaWYgKHR5cGVvZiByYXcgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGNvbnN0IGhyZWYgPSBlc2NhcGVBdHRyKHJhdyk7XHJcbiAgICBpZiAoIWhyZWYpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHsgaHJlZiwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCBocmVmID0gZXNjYXBlQXR0cihyYXcuaHJlZiB8fCBcIlwiKTtcclxuICBpZiAoIWhyZWYpIHJldHVybiBudWxsO1xyXG5cclxuICBjb25zdCB0YXJnZXQgPSBlc2NhcGVBdHRyKHJhdy50YXJnZXQgfHwgXCJfYmxhbmtcIik7XHJcbiAgY29uc3QgcmVsID0gZXNjYXBlQXR0cihyYXcucmVsIHx8IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKTtcclxuICByZXR1cm4geyBocmVmLCB0YXJnZXQsIHJlbCB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnZvbHZlclNpRW5sYWNlKGh0bWxFbGVtZW50bzogc3RyaW5nLCBvYmo6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IGh0bWxDb25EYXRhID0gYXBwZW5kTW90aW9uRGF0YUF0dHJzKGh0bWxFbGVtZW50bywgb2JqKTtcbiAgaWYgKG9iaj8udGlwbyA9PT0gXCJyc3ZwLWJvdG9uXCIpIHJldHVybiBodG1sQ29uRGF0YTtcblxuICBjb25zdCBsaW5rID0gZ2V0TGlua1Byb3BzKG9iaik7XG4gIGlmICghbGluaykgcmV0dXJuIGh0bWxDb25EYXRhO1xuXG4gIHJldHVybiBgPGEgaHJlZj1cIiR7bGluay5ocmVmfVwiIHRhcmdldD1cIiR7bGluay50YXJnZXR9XCIgcmVsPVwiJHtsaW5rLnJlbH1cIiBzdHlsZT1cInRleHQtZGVjb3JhdGlvbjpub25lO2NvbG9yOmluaGVyaXQ7ZGlzcGxheTpjb250ZW50c1wiPiR7aHRtbENvbkRhdGF9PC9hPmA7XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUhUTUwodGV4dG86IHN0cmluZyA9IFwiXCIpOiBzdHJpbmcge1xyXG4gIHJldHVybiB0ZXh0b1xyXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcclxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxyXG4gICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyhvYmpldG9zOiBhbnlbXSwgX3NlY2Npb25lczogYW55W10pOiBzdHJpbmcge1xyXG4gIGNvbnN0IGFsdG9Nb2RvUG9yU2VjY2lvbiA9IG5ldyBNYXAoXHJcbiAgICAoX3NlY2Npb25lcyB8fCBbXSkubWFwKChzOiBhbnkpID0+IFtzLmlkLCBTdHJpbmcocy5hbHRvTW9kbyB8fCBcImZpam9cIikudG9Mb3dlckNhc2UoKV0pXHJcbiAgKTtcclxuXHJcbiAgZnVuY3Rpb24gZXNTZWNjaW9uUGFudGFsbGEob2JqOiBhbnkpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IG1vZG8gPSBhbHRvTW9kb1BvclNlY2Npb24uZ2V0KG9iaj8uc2VjY2lvbklkKSB8fCBcImZpam9cIjtcclxuICAgIHJldHVybiBtb2RvID09PSBcInBhbnRhbGxhXCI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0Z1bGxCbGVlZChvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIFN0cmluZyhvYmo/LmFuY2xhamUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJmdWxsYmxlZWRcIjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOKchSBFc2NhbGEgdW5pZm9ybWUgZGVsIENPTlRFTklETzpcclxuICAgKiAtIHBhbnRhbGxhOiB2YXIoLS1zZmluYWwpIChmaXQgc2kgaGFjZSBmYWx0YSlcclxuICAgKiAtIGZpam86IHZhcigtLXN4KVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNDb250ZW5pZG9WYXIob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGVzU2VjY2lvblBhbnRhbGxhKG9iaikgPyBcInZhcigtLXNmaW5hbClcIiA6IFwidmFyKC0tc3gpXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgWCBzY2FsZTpcclxuICAgKiAtIGZ1bGxCbGVlZDogdmFyKC0tYngpIChOTyBmaXQpXHJcbiAgICogLSBjb250ZW5pZG86IHNDb250ZW5pZG9WYXIgKGZpdCBzaSBwYW50YWxsYSlcclxuICAgKi9cclxuICBmdW5jdGlvbiBzWChvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tYngpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgWSBzY2FsZTpcclxuICAgKiAtIGZ1bGxCbGVlZDogdmFyKC0tc3gpIChOTyBmaXQpXHJcbiAgICogLSBjb250ZW5pZG86IHNDb250ZW5pZG9WYXIgKGZpdCBzaSBwYW50YWxsYSlcclxuICAgKi9cclxuICBmdW5jdGlvbiBzWShvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBweFgob2JqOiBhbnksIHB4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbiA9IE51bWJlci5pc0Zpbml0ZShweCkgPyBweCA6IDA7XHJcbiAgICByZXR1cm4gYGNhbGMoJHtzWChvYmopfSAqICR7bn1weClgO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHhZKG9iajogYW55LCBweDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG4gPSBOdW1iZXIuaXNGaW5pdGUocHgpID8gcHggOiAwO1xyXG4gICAgcmV0dXJuIGBjYWxjKCR7c1kob2JqKX0gKiAke259cHgpYDtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIOKchSBQQU5UQUxMQTogdG9wIHBvciBwb3JjZW50YWplXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgY29uc3QgQUxUVVJBX0VESVRPUl9QQU5UQUxMQSA9IDUwMDtcclxuXHJcbiAgLy8g4pyFIE9mZnNldHMgZW4gc2VjY2lvbmVzIFBhbnRhbGxhOiBPTlxyXG4gIC8vIOKaoO+4jyBJTVBPUlRBTlRFOiBlc3RlIGFyY2hpdm8gU09MTyBnZW5lcmEgb2JqZXRvcy5cclxuICAvLyBFbCB2YWxvciBERVNLVE9QL01PQklMRSByZWFsIHNlIGNvbnRyb2xhIHbDrWEgQ1NTIGdsb2JhbCBjb246XHJcbiAgLy8gICA6cm9vdCB7IC0tcGFudGFsbGEteS1vZmZzZXQ6IFhweCB9XHJcbiAgLy8gICBAbWVkaWEgKG1heC13aWR0aDogNjQwcHgpIHsgOnJvb3QgeyAtLXBhbnRhbGxhLXktb2Zmc2V0OiBZcHggfSB9XHJcbiAgLy9cclxuICAvLyBBY8OhIGRlamFtb3MgZmFsbGJhY2sgKGRlc2t0b3ApIHBvciBzaSBsYSB2YXJpYWJsZSBDU1Mgbm8gZXhpc3RlLlxyXG4gIGNvbnN0IFBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFggPSAwO1xuXHJcbiAgZnVuY3Rpb24gY2xhbXAwMShuOiBhbnkpOiBudW1iZXIgfCBudWxsIHtcclxuICAgIGNvbnN0IHggPSBOdW1iZXIobik7XHJcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0WVB4RWRpdG9yKG9iajogYW55KTogbnVtYmVyIHtcbiAgICAvLyDinIUgRW4gUGFudGFsbGEgT046IHlOb3JtIGVzIGxhIGZ1ZW50ZSBkZSB2ZXJkYWQgKDAuLjEpXHJcbiAgICBjb25zdCB5biA9IGNsYW1wMDEob2JqPy55Tm9ybSk7XHJcbiAgICBpZiAoeW4gIT0gbnVsbCkgcmV0dXJuIHluICogQUxUVVJBX0VESVRPUl9QQU5UQUxMQTtcclxuXHJcbiAgICAvLyBmYWxsYmFjazogc2kgbm8gaGF5IHlOb3JtLCB1c2Ftb3MgeSBjb21vIFwiZWRpdG9yIHB4XCJcclxuICAgIGNvbnN0IHlQeCA9IE51bWJlcihvYmo/LnkpO1xyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh5UHgpKSByZXR1cm4geVB4O1xyXG5cclxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9wUGFudGFsbGFDU1Mob2JqOiBhbnksIHluUmF3OiBhbnkpOiBzdHJpbmcge1xuICAgIGNvbnN0IHluID0gY2xhbXAwMSh5blJhdykgPz8gMDtcbiAgICBjb25zdCB5QmxvcXVlRGlzZW5pbyA9IGBjYWxjKCR7c0NvbnRlbmlkb1ZhcihvYmopfSAqICR7QUxUVVJBX0VESVRPUl9QQU5UQUxMQX1weClgO1xuICAgIGNvbnN0IHlCYXNlUGFudGFsbGEgPSBgdmFyKC0tcGFudGFsbGEteS1iYXNlLCAwcHgpYDtcbiAgICBjb25zdCB5bkNvbXBhY3RhZG8gPSBgY2FsYygwLjUgKyAoKCR7eW59KSAtIDAuNSkgKiAoMSAtIHZhcigtLXBhbnRhbGxhLXktY29tcGFjdCwgMCkpKWA7XG4gICAgcmV0dXJuIGBjYWxjKFxuICAke3lCYXNlUGFudGFsbGF9XG4gICsgKCR7eUJsb3F1ZURpc2VuaW99ICogJHt5bkNvbXBhY3RhZG99KVxuICArICgke3NDb250ZW5pZG9WYXIob2JqKX0gKiB2YXIoLS1wYW50YWxsYS15LW9mZnNldCwgJHtQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYfXB4KSlcbilgO1xuICB9XG5cbiAgLyoqXG4gICAqIOKchSB0b3BDU1M6XG4gICAqIC0gUGFudGFsbGEgT046IHVzYSBibG9xdWUgZGUgZGlzZcOxbyBlc2NhbGFkbyAoNTAwcHggKiBzZmluYWwpICsgb2Zmc2V0IGJhc2UgdW5pZm9ybWVcbiAgICogLSBUZXh0byBlbiBQYW50YWxsYSBPTjogc3VtYSBvZmZzZXQgKENTUyB2YXIpIGVzY2FsYWRvIHBvciBzQ29udGVuaWRvVmFyXG4gICAqIC0gRmlqbzogcHhZKG9iaiwgeSlcbiAgICovXG4gIGZ1bmN0aW9uIHRvcENTUyhvYmo6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKGVzU2VjY2lvblBhbnRhbGxhKG9iaikpIHtcbiAgICAgIGNvbnN0IHlQeEVkaXRvciA9IGdldFlQeEVkaXRvcihvYmopO1xuICAgICAgY29uc3QgeW4gPSBjbGFtcDAxKHlQeEVkaXRvciAvIEFMVFVSQV9FRElUT1JfUEFOVEFMTEEpID8/IDA7XG4gICAgICByZXR1cm4gdG9wUGFudGFsbGFDU1Mob2JqLCB5bik7XG4gICAgfVxuXG4gICAgY29uc3QgeSA9IE51bWJlcihvYmo/LnkgfHwgMCk7XG4gICAgcmV0dXJuIHB4WShvYmosIHkpO1xuICB9XG5cclxuICAvKipcclxuICAgKiDinIUgVmFyaWFudGUgcGFyYSBjdWFuZG8geWEgdGVuw6lzIHlQeCAoZW4gXCJweCBlZGl0b3JcIilcclxuICAgKi9cclxuICBmdW5jdGlvbiB0b3BDU1NGcm9tWVB4KG9iajogYW55LCB5UHg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKGVzU2VjY2lvblBhbnRhbGxhKG9iaikpIHtcbiAgICAgIGNvbnN0IHluID0gY2xhbXAwMSh5UHggLyBBTFRVUkFfRURJVE9SX1BBTlRBTExBKSA/PyAwO1xuICAgICAgcmV0dXJuIHRvcFBhbnRhbGxhQ1NTKG9iaiwgeW4pO1xuICAgIH1cblxuICAgIHJldHVybiBweFkob2JqLCB5UHgpO1xuICB9XG5cclxuICBmdW5jdGlvbiBzdHlsZVBvc0Jhc2Uob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihvYmo/LnggfHwgMCk7XHJcblxyXG4gICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgY29uc3QgekluZGV4ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uekluZGV4KSA/IG9iai56SW5kZXggOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHgpfTtcclxudG9wOiAke3RvcENTUyhvYmopfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4ke3pJbmRleCAhPT0gdW5kZWZpbmVkID8gYHotaW5kZXg6JHt6SW5kZXh9O2AgOiBcIlwifVxyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdHlsZVNpemUob2JqOiBhbnksIHc/OiBudW1iZXIsIGg/OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgd3cgPSBOdW1iZXIuaXNGaW5pdGUodykgPyAodyBhcyBudW1iZXIpIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaGggPSBOdW1iZXIuaXNGaW5pdGUoaCkgPyAoaCBhcyBudW1iZXIpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgaWYgKHd3ICE9PSB1bmRlZmluZWQpIHBhcnRzLnB1c2goYHdpZHRoOiAke3B4WChvYmosIHd3KX07YCk7XHJcbiAgICBpZiAoaGggIT09IHVuZGVmaW5lZCkgcGFydHMucHVzaChgaGVpZ2h0OiAke3B4WShvYmosIGhoKX07YCk7XHJcbiAgICByZXR1cm4gcGFydHMuam9pbihcIlxcblwiKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbmRlckljb25vU3ZnTnVldm9JbmxpbmUob2JqOiBhbnkpIHtcclxuICAgIGNvbnN0IHZpZXdCb3ggPSBvYmoudmlld0JveCB8fCBcIjAgMCAyNCAyNFwiO1xyXG4gICAgY29uc3QgY29sb3IgPSBvYmouY29sb3IgfHwgXCIjMDAwXCI7XHJcbiAgICBjb25zdCBwYXRocyA9IEFycmF5LmlzQXJyYXkob2JqLnBhdGhzKSA/IG9iai5wYXRocyA6IFtdO1xyXG4gICAgaWYgKCFwYXRocy5sZW5ndGgpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiAyNDtcclxuICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IDI0O1xyXG5cclxuICAgIGNvbnN0IHJvdCA9IG9iaj8ucm90YXRpb24gPz8gMDtcclxuICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgIGNvbnN0IHggPSBOdW1iZXIob2JqPy54IHx8IDApO1xyXG4gICAgY29uc3QgeVB4ID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcblxyXG4gICAgY29uc3QgcGF0aHNIdG1sID0gcGF0aHNcclxuICAgICAgLm1hcCgocDogYW55KSA9PiAocD8uZCA/IGA8cGF0aCBkPVwiJHtlc2NIVE1MKHAuZCl9XCIgZmlsbD1cIiR7ZXNjSFRNTChjb2xvcil9XCI+PC9wYXRoPmAgOiBcIlwiKSlcclxuICAgICAgLmpvaW4oXCJcIik7XHJcblxyXG4gICAgY29uc3Qgc3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCB4KX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgeVB4KX07XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgcmV0dXJuIGA8c3ZnIGNsYXNzPVwib2JqZXRvXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIke2VzY0hUTUwoXHJcbiAgICAgIHZpZXdCb3hcclxuICAgICl9XCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7cGF0aHNIdG1sfTwvc3ZnPmA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqZXRvc1xyXG4gICAgLm1hcCgob2JqKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRpcG8gPSBvYmo/LnRpcG87XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIFRFWFRPIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwidGV4dG9cIikge1xyXG4gICAgICAgIGNvbnN0IGFsaWduID0gU3RyaW5nKG9iai5hbGlnbiB8fCBvYmoudGV4dEFsaWduIHx8IFwibGVmdFwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gb2JqLmNvbG9yVGV4dG8gfHwgb2JqLmNvbG9yIHx8IG9iai5maWxsIHx8IFwiIzAwMFwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlTGluZUhlaWdodCA9XHJcbiAgICAgICAgICB0eXBlb2Ygb2JqLmxpbmVIZWlnaHQgPT09IFwibnVtYmVyXCIgJiYgb2JqLmxpbmVIZWlnaHQgPiAwID8gb2JqLmxpbmVIZWlnaHQgOiAxLjI7XHJcbiAgICAgICAgY29uc3QgbGluZUhlaWdodEZpbmFsID0gYmFzZUxpbmVIZWlnaHQgKiAwLjkyO1xyXG5cclxuICAgICAgICBjb25zdCBzYWZlVGV4dG8gPSBlc2NIVE1MKG9iai50ZXh0byB8fCBcIlwiKTtcclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBmcyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmZvbnRTaXplKSA/IG9iai5mb250U2l6ZSA6IDI0O1xyXG5cclxuICAgICAgICAvLyDimqDvuI8gdGV4dG8gZnVsbEJsZWVkIE5PIGhhY2UgZml0ID0+IGVzY2FsYSBjb24gdmFyKC0tc3gpXHJcbiAgICAgICAgY29uc3Qgc0ZvbnQgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID1cclxuICAgICAgICAgIGFsaWduID09PSBcImNlbnRlclwiID8gXCJ0b3AgY2VudGVyXCIgOlxyXG4gICAgICAgICAgICAoYWxpZ24gPT09IFwicmlnaHRcIiA/IFwidG9wIHJpZ2h0XCIgOiBcInRvcCBsZWZ0XCIpO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcbiR7YmFzZVN0eWxlfVxuLyog4pyFIG1hbnRlbmVyIGdlb21ldHLDrWEgZXN0YWJsZSB5IGVzY2FsYXIgdGlwb2dyYWbDrWEgcG9yIGZvbnQtc2l6ZSAobm8gcG9yIHRyYW5zZm9ybSkuICovXG50cmFuc2Zvcm0tb3JpZ2luOiAke29yaWdpbn07XG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcbiR7dyAhPT0gdW5kZWZpbmVkID8gYHdpZHRoOiAke3B4WChvYmosIHcpfTtgIDogXCJcIn1cbmZvbnQtc2l6ZTogY2FsYygke3NGb250fSAqICR7ZnN9cHggKiB2YXIoLS10ZXh0LXpvb20sIDEpKTtcbmZvbnQtZmFtaWx5OiAke29iai5mb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwifTtcbmZvbnQtd2VpZ2h0OiAke29iai5mb250V2VpZ2h0IHx8IFwibm9ybWFsXCJ9O1xuZm9udC1zdHlsZTogJHtvYmouZm9udFN0eWxlIHx8IFwibm9ybWFsXCJ9O1xudGV4dC1kZWNvcmF0aW9uOiAke29iai50ZXh0RGVjb3JhdGlvbiB8fCBcIm5vbmVcIn07XHJcbmNvbG9yOiAke2NvbG9yfTtcclxudGV4dC1hbGlnbjogJHthbGlnbn07XHJcbndoaXRlLXNwYWNlOiBwcmUtd3JhcDtcclxubGluZS1oZWlnaHQ6ICR7bGluZUhlaWdodEZpbmFsfTtcclxucGFkZGluZzogMDtcclxubWFyZ2luOiAwO1xyXG5ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcclxuJHtvYmouc3Ryb2tlICYmIG9iai5zdHJva2VXaWR0aCA+IDBcclxuICAgICAgICAgICAgPyBgLXdlYmtpdC10ZXh0LXN0cm9rZTogJHtvYmouc3Ryb2tlV2lkdGh9cHggJHtvYmouc3Ryb2tlfTtgXHJcbiAgICAgICAgICAgIDogXCJcIlxyXG4gICAgICAgICAgfVxyXG4ke29iai5zaGFkb3dDb2xvclxyXG4gICAgICAgICAgICA/IGB0ZXh0LXNoYWRvdzogJHtvYmouc2hhZG93T2Zmc2V0WCB8fCAwfXB4ICR7b2JqLnNoYWRvd09mZnNldFkgfHwgMH1weCAke29iai5zaGFkb3dCbHVyIHx8IDB9cHggJHtvYmouc2hhZG93Q29sb3J9O2BcclxuICAgICAgICAgICAgOiBcInRleHQtc2hhZG93OiBub25lO1wiXHJcbiAgICAgICAgICB9XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShcclxuICAgICAgICAgIGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgZGF0YS1kZWJ1Zy10ZXh0bz1cIjFcIiBzdHlsZT1cIiR7c3R5bGV9XCI+JHtzYWZlVGV4dG99PC9kaXY+YCxcclxuICAgICAgICAgIG9ialxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIElNQUdFTiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImltYWdlblwiKSB7XHJcbiAgICAgICAgY29uc3Qgc3JjID0gb2JqLnNyYyB8fCBvYmoudXJsIHx8IFwiXCI7XHJcbiAgICAgICAgaWYgKCFzcmMpIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3N0eWxlU2l6ZShvYmosIHcsIGgpfVxyXG5vYmplY3QtZml0OiBjb250YWluO1xyXG5kaXNwbGF5OiBibG9jaztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8aW1nIGNsYXNzPVwib2JqZXRvXCIgc3JjPVwiJHtlc2NhcGVBdHRyKHNyYyl9XCIgc3R5bGU9XCIke3N0eWxlfVwiIC8+YCwgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBJQ09OTyAobnVldm8pIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiaWNvbm9cIikge1xyXG4gICAgICAgIGlmIChvYmouZm9ybWF0byA9PT0gXCJzdmdcIikge1xyXG4gICAgICAgICAgY29uc3Qgc3ZnSHRtbCA9IHJlbmRlckljb25vU3ZnTnVldm9JbmxpbmUob2JqKTtcclxuICAgICAgICAgIGlmICghc3ZnSHRtbCkgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShzdmdIdG1sLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3JjID0gb2JqLnVybCB8fCBvYmouc3JjIHx8IFwiXCI7XHJcbiAgICAgICAgaWYgKCFzcmMpIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3N0eWxlU2l6ZShvYmosIHcsIGgpfVxyXG5vYmplY3QtZml0OiBjb250YWluO1xyXG5kaXNwbGF5OiBibG9jaztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8aW1nIGNsYXNzPVwib2JqZXRvXCIgc3JjPVwiJHtlc2NhcGVBdHRyKHNyYyl9XCIgc3R5bGU9XCIke3N0eWxlfVwiIC8+YCwgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBJQ09OTyBMRUdBQ1kgKGljb25vLXN2ZykgLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJpY29uby1zdmdcIiAmJiBvYmouZCkge1xyXG4gICAgICAgIGNvbnN0IHZiID0gb2JqLnZpZXdCb3ggfHwgXCIwIDAgMTAwIDEwMFwiO1xyXG4gICAgICAgIGNvbnN0IGZpbGwgPSBvYmouY29sb3IgfHwgXCIjMDAwXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiAxMDA7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogMTAwO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxuZmlsbDogJHtlc2NhcGVBdHRyKGZpbGwpfTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGA8c3ZnIGNsYXNzPVwib2JqZXRvXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIke2VzY2FwZUF0dHIoXHJcbiAgICAgICAgICB2YlxyXG4gICAgICAgICl9XCIgc3R5bGU9XCIke3N0eWxlfVwiPjxwYXRoIGQ9XCIke2VzY0hUTUwob2JqLmQpfVwiIC8+PC9zdmc+YDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2Uoc3ZnLCBvYmopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIENPVU5URE9XTiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImNvdW50ZG93blwiKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SVNPID0gb2JqLnRhcmdldElTTyB8fCBvYmouZmVjaGFPYmpldGl2byB8fCBvYmouZmVjaGFJU08gfHwgXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gb2JqLmNvbG9yVGV4dG8gPz8gb2JqLmNvbG9yID8/IFwiIzExMVwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseSB8fCBcIkludGVyLCBzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIjtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlc2V0ID0gb2JqLnByZXNldElkIHx8IG9iai5sYXlvdXQgfHwgXCJwaWxsc1wiO1xyXG4gICAgICAgIGNvbnN0IGlzTWluaW1hbCA9IFN0cmluZyhwcmVzZXQpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJtaW5pbWFsXCIpO1xyXG5cclxuICAgICAgICAvLyDinIUgYW5jaG8vYWx0byBkZWwgb2JqZXRvIChzaSBleGlzdGVuKVxyXG4gICAgICAgIGNvbnN0IHdPYmogPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBOdW1iZXIob2JqLndpZHRoKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgaE9iaiA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBOdW1iZXIob2JqLmhlaWdodCkgOiBudWxsO1xyXG5cclxuICAgICAgICAvLyDinIUgZ2FwOiBzaSB2aWVuZSBkZSBLb252YSwgcmVzcGV0YXJsb1xyXG4gICAgICAgIGNvbnN0IGdhcCA9IE51bWJlci5pc0Zpbml0ZShvYmouZ2FwKVxyXG4gICAgICAgICAgPyBOdW1iZXIob2JqLmdhcClcclxuICAgICAgICAgIDogTnVtYmVyLmlzRmluaXRlKG9iai5zcGFjaW5nKVxyXG4gICAgICAgICAgICA/IE51bWJlcihvYmouc3BhY2luZylcclxuICAgICAgICAgICAgOiA4O1xyXG5cclxuICAgICAgICAvLyDinIUgU2kgdHUgS29udmEgZ3VhcmRhIGNoaXBXaWR0aCAvIHBhZGRpbmdYLCByZXNwZXRhbG9zXHJcbiAgICAgICAgLy8gY2hpcFdpZHRoOiBhbmNobyBpbnRlcm5vIGRlbCB0ZXh0byAoc2luIHBhZGRpbmcpXHJcbiAgICAgICAgY29uc3QgY2hpcFdpZHRoUHJvcCA9IE51bWJlci5pc0Zpbml0ZShvYmouY2hpcFdpZHRoKSA/IE51bWJlcihvYmouY2hpcFdpZHRoKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1hQcm9wID0gTnVtYmVyLmlzRmluaXRlKG9iai5wYWRkaW5nWCkgPyBOdW1iZXIob2JqLnBhZGRpbmdYKSA6IG51bGw7XHJcblxyXG4gICAgICAgIC8vIOKchSBEZXJpdmFjacOzbiByYcOteiAoY3VhbmRvIG5vIGhheSBwcm9wcylcclxuICAgICAgICBjb25zdCBuID0gNDtcclxuXHJcbiAgICAgICAgLy8gY2hpcFdUb3RhbDogYW5jaG8gdG90YWwgZGUgY2FkYSBjaGlwIChpbmNsdXllIHBhZGRpbmcpXHJcbiAgICAgICAgbGV0IGNoaXBXVG90YWwgPSA1NjsgLy8gZmFsbGJhY2sgcmF6b25hYmxlXHJcbiAgICAgICAgaWYgKHdPYmogJiYgd09iaiA+IDApIHtcclxuICAgICAgICAgIGNoaXBXVG90YWwgPSBNYXRoLm1heCg0MCwgKHdPYmogLSBnYXAgKiAobiAtIDEpKSAvIG4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcGFkZGluZ1ggZGVyaXZhZG8gZGVsIGNoaXBXVG90YWwgKHNpIG5vIHZpbm8pXHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSBwYWRkaW5nWFByb3AgPz8gTWF0aC5tYXgoNiwgTWF0aC5yb3VuZChjaGlwV1RvdGFsICogMC4xOCkpOyAvLyB+MTglXHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSBNYXRoLm1heCg1LCBNYXRoLnJvdW5kKHBhZGRpbmdYICogMC42NSkpO1xyXG5cclxuICAgICAgICAvLyBjaGlwV2lkdGggKHRleHRvKSBkZXJpdmFkbyBzaSBubyB2aW5vXHJcbiAgICAgICAgY29uc3QgY2hpcFdpZHRoID0gY2hpcFdpZHRoUHJvcCA/PyBNYXRoLm1heCgxMCwgTWF0aC5yb3VuZChjaGlwV1RvdGFsIC0gcGFkZGluZ1ggKiAyKSk7XHJcblxyXG4gICAgICAgIC8vIOKchSBmb250IHNpemVzOiBzaSB2aWVuZW4sIHJlc3BldGFyOyBzaSBubywgZGVyaXZhciBkZXNkZSBjaGlwV1RvdGFsXHJcbiAgICAgICAgY29uc3QgdmFsdWVTaXplID1cclxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShvYmouZm9udFNpemUpID8gTnVtYmVyKG9iai5mb250U2l6ZSkgOiBNYXRoLm1heCgxNCwgTWF0aC5yb3VuZChjaGlwV1RvdGFsICogMC4zNCkpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsU2l6ZSA9XHJcbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2JqLmxhYmVsU2l6ZSkgPyBOdW1iZXIob2JqLmxhYmVsU2l6ZSkgOiBNYXRoLm1heCg5LCBNYXRoLnJvdW5kKHZhbHVlU2l6ZSAqIDAuNjIpKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWxDb2xvciA9IG9iai5sYWJlbENvbG9yID8/IFwiIzZiNzI4MFwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRXZWlnaHQgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmZvbnRXZWlnaHQpID8gb2JqLmZvbnRXZWlnaHQgOiA3MDA7XHJcbiAgICAgICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IE51bWJlci5pc0Zpbml0ZShvYmoubGV0dGVyU3BhY2luZykgPyBvYmoubGV0dGVyU3BhY2luZyA6IDA7XHJcblxyXG4gICAgICAgIC8vIOKchSBlc3RpbG9zIGRlIGNoaXBcclxuICAgICAgICBjb25zdCBjb250YWluZXJCZ0ZpbmFsID0gXCJ0cmFuc3BhcmVudFwiO1xyXG4gICAgICAgIGNvbnN0IGNoaXBCZ0ZpbmFsID0gaXNNaW5pbWFsID8gXCJ0cmFuc3BhcmVudFwiIDogb2JqLmNoaXBCYWNrZ3JvdW5kID8/IG9iai5ib3hCZyA/PyBcInJnYmEoMjU1LDI1NSwyNTUsLjc1KVwiO1xyXG4gICAgICAgIGNvbnN0IGNoaXBCb3JkZXJDb2xvckZpbmFsID0gaXNNaW5pbWFsID8gXCJ0cmFuc3BhcmVudFwiIDogb2JqLmNoaXBCb3JkZXIgPz8gb2JqLmJveEJvcmRlciA/PyBcInJnYmEoMCwwLDAsLjA4KVwiO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXJSYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmJveFJhZGl1cylcclxuICAgICAgICAgID8gb2JqLmJveFJhZGl1c1xyXG4gICAgICAgICAgOiBOdW1iZXIuaXNGaW5pdGUob2JqLnJhZGl1cylcclxuICAgICAgICAgICAgPyBvYmoucmFkaXVzXHJcbiAgICAgICAgICAgIDogMTA7XHJcblxyXG4gICAgICAgIGNvbnN0IGNoaXBSYWRpdXNGaW5hbCA9IE51bWJlci5pc0Zpbml0ZShvYmouY2hpcFJhZGl1cykgPyBvYmouY2hpcFJhZGl1cyA6IGNvbnRhaW5lclJhZGl1cztcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcblxyXG4gICAgICAgIC8vIOKchSBFc2NhbGEgY29ycmVjdGEgKHJlc3BldGEgcGFudGFsbGEgeSBibGVlZClcclxuICAgICAgICBjb25zdCBzQ2hpcCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbiR7d09iaiA/IGB3aWR0aDogJHtweFgob2JqLCB3T2JqKX07YCA6IFwiXCJ9XHJcbiR7aE9iaiA/IGBoZWlnaHQ6ICR7cHhZKG9iaiwgaE9iail9O2AgOiBcIlwifVxyXG5kaXNwbGF5OiBmbGV4O1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuZ2FwOiBjYWxjKCR7c0NoaXB9ICogJHtnYXB9cHgpO1xyXG5mb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcclxuY29sb3I6ICR7dGV4dENvbG9yfTtcclxuYmFja2dyb3VuZDogJHtjb250YWluZXJCZ0ZpbmFsfTtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NDaGlwfSAqICR7Y29udGFpbmVyUmFkaXVzfXB4KTtcclxubGV0dGVyLXNwYWNpbmc6IGNhbGMoJHtzQ2hpcH0gKiAke2xldHRlclNwYWNpbmd9cHgpO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2hpcFN0eWxlID0gYFxyXG53aWR0aDogY2FsYygke3NDaGlwfSAqICR7TWF0aC5yb3VuZChjaGlwV1RvdGFsKX1weCk7XHJcbnBhZGRpbmc6IGNhbGMoJHtzQ2hpcH0gKiAke3BhZGRpbmdZfXB4KSBjYWxjKCR7c0NoaXB9ICogJHtwYWRkaW5nWH1weCk7XHJcbmJvcmRlcjogJHtpc01pbmltYWwgPyBcIjBcIiA6IGBjYWxjKCR7c0NoaXB9ICogMXB4KSBzb2xpZCAke2NoaXBCb3JkZXJDb2xvckZpbmFsfWB9O1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c0NoaXB9ICogJHtjaGlwUmFkaXVzRmluYWx9cHgpO1xyXG5kaXNwbGF5OiBmbGV4O1xyXG5mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuYmFja2dyb3VuZDogJHtjaGlwQmdGaW5hbH07XHJcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCB2YWx1ZVN0eWxlID0gYFxyXG5mb250LXdlaWdodDogJHtmb250V2VpZ2h0fTtcclxuZm9udC1zaXplOiBjYWxjKCR7c0NoaXB9ICogJHt2YWx1ZVNpemV9cHgpO1xyXG5saW5lLWhlaWdodDogMTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsU3R5bGUgPSBgXHJcbmZvbnQtc2l6ZTogY2FsYygke3NDaGlwfSAqICR7bGFiZWxTaXplfXB4KTtcclxuY29sb3I6ICR7bGFiZWxDb2xvcn07XHJcbmxpbmUtaGVpZ2h0OiAxLjA1O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2hvd0xhYmVscyA9IG9iai5zaG93TGFiZWxzICE9PSBmYWxzZTtcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBvYmoubGFiZWxzID8/IHsgZGlhczogXCJEw61hc1wiLCBob3JhczogXCJIb3Jhc1wiLCBtaW46IFwiTWluXCIsIHNlZzogXCJTZWdcIiB9O1xyXG5cclxuICAgICAgICBjb25zdCBodG1sQ291bnRkb3duID0gYFxuPGRpdiBjbGFzcz1cIm9iamV0b1wiXG4gIGRhdGEtbW9iaWxlLWNsdXN0ZXI9XCJpc29sYXRlZFwiXG4gIGRhdGEtbW9iaWxlLWNlbnRlcj1cImZvcmNlXCJcbiAgZGF0YS1jb3VudGRvd25cclxuICBkYXRhLXRhcmdldD1cIiR7ZXNjYXBlQXR0cih0YXJnZXRJU08pfVwiXHJcbiAgZGF0YS1wcmVzZXQ9XCIke2VzY2FwZUF0dHIoXHJcbiAgICAgICAgICBwcmVzZXRcclxuICAgICAgICApfVwiIHN0eWxlPVwiJHtjb250YWluZXJTdHlsZX1cIj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5kaWFzKX08L3NwYW4+YCA6IFwiXCJ9XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImNkLWNoaXBcIiBzdHlsZT1cIiR7Y2hpcFN0eWxlfVwiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJjZC12YWxcIiBzdHlsZT1cIiR7dmFsdWVTdHlsZX1cIj4wMDwvc3Bhbj5cclxuICAgICR7c2hvd0xhYmVscyA/IGA8c3BhbiBjbGFzcz1cImNkLWxhYlwiIHN0eWxlPVwiJHtsYWJlbFN0eWxlfVwiPiR7ZXNjYXBlQXR0cihsYWJlbHMuaG9yYXMpfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5taW4pfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5zZWcpfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuPC9kaXY+XG5gLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGFwcGVuZE1vdGlvbkRhdGFBdHRycyhodG1sQ291bnRkb3duLCBvYmopO1xuICAgICAgfVxuXHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIEdBTEVSw41BIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiZ2FsZXJpYVwiKSB7XHJcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIHBhcnNlSW50KG9iai5yb3dzIHx8IDEsIDEwKSk7XHJcbiAgICAgICAgY29uc3QgY29scyA9IE1hdGgubWF4KDEsIHBhcnNlSW50KG9iai5jb2xzIHx8IDEsIDEwKSk7XHJcbiAgICAgICAgY29uc3QgZ2FwUHggPSBNYXRoLm1heCgwLCBwYXJzZUludChvYmouZ2FwIHx8IDAsIDEwKSk7XHJcbiAgICAgICAgY29uc3QgcmFkaXVzUHggPSBNYXRoLm1heCgwLCBwYXJzZUludChvYmoucmFkaXVzIHx8IDAsIDEwKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBjb25zdCBzR3JpZCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZUNvbnRlbmVkb3IgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3N0eWxlU2l6ZShvYmosIHcsIGgpfVxyXG5kaXNwbGF5OiBncmlkO1xyXG5ncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgke2NvbHN9LCAxZnIpO1xyXG5ncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgke3Jvd3N9LCAxZnIpO1xyXG5nYXA6IGNhbGMoJHtzR3JpZH0gKiAke2dhcFB4fXB4KTtcclxuYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvdGFsID0gcm93cyAqIGNvbHM7XHJcbiAgICAgICAgY29uc3QgY2VsbHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0b3RhbCB9LCAoXywgaSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgYyA9IChvYmouY2VsbHMgJiYgb2JqLmNlbGxzW2ldKSB8fCB7fTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1lZGlhVXJsOiBjLm1lZGlhVXJsIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGZpdDogYy5maXQgPT09IFwiY29udGFpblwiID8gXCJjb250YWluXCIgOiBcImNvdmVyXCIsXHJcbiAgICAgICAgICAgIGJnOiBjLmJnIHx8IFwiI2YzZjRmNlwiLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgaHRtbENlbGRhcyA9IGNlbGxzXHJcbiAgICAgICAgICAubWFwKChjZWxsLCBpZHgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2FmZVNyYyA9IGVzY2FwZUF0dHIoY2VsbC5tZWRpYVVybCB8fCBcIlwiKTtcclxuICAgICAgICAgICAgY29uc3QgY2VsZGFTdHlsZSA9IGBcclxucG9zaXRpb246IHJlbGF0aXZlO1xyXG53aWR0aDogMTAwJTtcclxuaGVpZ2h0OiAxMDAlO1xyXG5vdmVyZmxvdzogaGlkZGVuO1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c0dyaWR9ICogJHtyYWRpdXNQeH1weCk7XHJcbmJhY2tncm91bmQ6ICR7Y2VsbC5iZ307XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzYWZlU3JjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cImdhbGVyaWEtY2VsZGFcIiBkYXRhLWluZGV4PVwiJHtpZHh9XCIgc3R5bGU9XCIke2NlbGRhU3R5bGV9XCI+PC9kaXY+YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGBcbjxkaXYgY2xhc3M9XCJnYWxlcmlhLWNlbGRhIGdhbGVyaWEtY2VsZGEtLWNsaWNrYWJsZVwiXG4gICAgIGRhdGEtaW5kZXg9XCIke2lkeH1cIlxuICAgICBkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJcbiAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgIHRhYmluZGV4PVwiMFwiXG4gICAgIGFyaWEtbGFiZWw9XCJWZXIgaW1hZ2VuIGVuIHBhbnRhbGxhIGNvbXBsZXRhXCJcbiAgICAgc3R5bGU9XCIke2NlbGRhU3R5bGV9XCI+XG4gIDxpbWcgc3JjPVwiJHtzYWZlU3JjfVwiIGFsdD1cIlwiIGxvYWRpbmc9XCJsYXp5XCIgZGVjb2Rpbmc9XCJhc3luY1wiXG4gICAgICAgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO29iamVjdC1maXQ6JHtjZWxsLmZpdH07ZGlzcGxheTpibG9jaztcIiAvPlxuPC9kaXY+XG5gLnRyaW0oKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBodG1sR2FsZXJpYSA9IGA8ZGl2IGNsYXNzPVwib2JqZXRvIGdhbGVyaWFcIiBzdHlsZT1cIiR7c3R5bGVDb250ZW5lZG9yfVwiPiR7aHRtbENlbGRhc308L2Rpdj5gO1xyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGh0bWxHYWxlcmlhLCBvYmopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIFJTVlAgQk9Uw5NOIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwicnN2cC1ib3RvblwiKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dG8gPSBlc2NhcGVIVE1MKG9iai50ZXh0byB8fCBcIkNvbmZpcm1hciBhc2lzdGVuY2lhXCIpO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5hbmNobykgPyBvYmouYW5jaG8gOiAyMDA7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmFsdG8pID8gb2JqLmFsdG8gOiA1MDtcclxuXHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBvYmouY29sb3IgfHwgXCIjNzczZGJlXCI7XHJcbiAgICAgICAgY29uc3QgY29sb3JUZXh0byA9IG9iai5jb2xvclRleHRvIHx8IFwiI2ZmZmZmZlwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uZm9udFNpemUpID8gb2JqLmZvbnRTaXplIDogMTg7XHJcbiAgICAgICAgY29uc3QgZm9udEZhbWlseSA9IG9iai5mb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRXZWlnaHQgPSBvYmouZm9udFdlaWdodCB8fCBcImJvbGRcIjtcclxuICAgICAgICBjb25zdCBmb250U3R5bGUgPSBvYmouZm9udFN0eWxlIHx8IFwibm9ybWFsXCI7XHJcbiAgICAgICAgY29uc3QgdGV4dERlY29yYXRpb24gPSBvYmoudGV4dERlY29yYXRpb24gfHwgXCJub25lXCI7XHJcbiAgICAgICAgY29uc3QgYWxpZ24gPSBvYmouYWxpZ24gfHwgXCJjZW50ZXJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcblxyXG4gICAgICAgIC8vIFJTVlAgKGNvbnRlbmlkbyk6IHNpIGVzdMOhIGVuIHBhbnRhbGxhLCBmaXR0ZWEgKHNDb250ZW5pZG9WYXIpXHJcbiAgICAgICAgY29uc3Qgc0J0biA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxuYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvcn07XHJcbmNvbG9yOiAke2NvbG9yVGV4dG99O1xyXG5mb250LXNpemU6IGNhbGMoJHtzQnRufSAqICR7Zm9udFNpemV9cHgpO1xyXG5mb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcclxuZm9udC13ZWlnaHQ6ICR7Zm9udFdlaWdodH07XHJcbmZvbnQtc3R5bGU6ICR7Zm9udFN0eWxlfTtcclxudGV4dC1kZWNvcmF0aW9uOiAke3RleHREZWNvcmF0aW9ufTtcclxudGV4dC1hbGlnbjogJHthbGlnbn07XHJcbmRpc3BsYXk6IGZsZXg7XHJcbmFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbmp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c0J0bn0gKiA4cHgpO1xyXG5jdXJzb3I6IHBvaW50ZXI7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBodG1sUnN2cCA9IGBcbjxkaXYgY2xhc3M9XCJvYmpldG8gaXMtaW50ZXJhY3RpdmUgcnN2cC1ib3RvblwiXG4gIGlkPVwiYWJyaXJNb2RhbFJTVlBcIlxuICBkYXRhLWFjY2lvbj1cImFicmlyLXJzdnBcIlxuICBkYXRhLXJzdnAtb3BlblxyXG4gIHJvbGU9XCJidXR0b25cIlxyXG4gIHRhYmluZGV4PVwiMFwiXHJcbiAgYXJpYS1sYWJlbD1cIkNvbmZpcm1hciBhc2lzdGVuY2lhXCJcclxuICBzdHlsZT1cIiR7c3R5bGV9XCI+XHJcbiAgJHt0ZXh0b31cbjwvZGl2PlxuYC50cmltKCk7XG4gICAgICAgIHJldHVybiBhcHBlbmRNb3Rpb25EYXRhQXR0cnMoaHRtbFJzdnAsIG9iaik7XG4gICAgICB9XG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBGT1JNQVMgLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJmb3JtYVwiKSB7XHJcbiAgICAgICAgY29uc3QgZmlsbCA9IG9iai5jb2xvciB8fCBcIiMwMDBcIjtcclxuICAgICAgICBjb25zdCBmaWd1cmEgPSBvYmouZmlndXJhO1xyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcInJlY3RcIikge1xyXG4gICAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IDEwMDtcclxuICAgICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IDEwMDtcclxuICAgICAgICAgIGNvbnN0IGNvcm5lclJhZGl1cyA9IG9iai5jb3JuZXJSYWRpdXMgfHwgMDtcclxuXHJcbiAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IG9iai5mb250U2l6ZSB8fCAyNDtcclxuICAgICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseSB8fCBcInNhbnMtc2VyaWZcIjtcclxuICAgICAgICAgIGNvbnN0IGZvbnRXZWlnaHQgPSBvYmouZm9udFdlaWdodCB8fCBcIm5vcm1hbFwiO1xyXG4gICAgICAgICAgY29uc3QgZm9udFN0eWxlID0gb2JqLmZvbnRTdHlsZSB8fCBcIm5vcm1hbFwiO1xyXG4gICAgICAgICAgY29uc3QgdGV4dERlY29yYXRpb24gPSBvYmoudGV4dERlY29yYXRpb24gfHwgXCJub25lXCI7XHJcbiAgICAgICAgICBjb25zdCBhbGlnbiA9IG9iai5hbGlnbiB8fCBcImNlbnRlclwiO1xyXG4gICAgICAgICAgY29uc3QgY29sb3JUZXh0byA9IG9iai5jb2xvclRleHRvIHx8IFwiIzAwMDAwMFwiO1xyXG4gICAgICAgICAgY29uc3QgdGV4dG8gPSBlc2NIVE1MKG9iai50ZXh0byB8fCBcIlwiKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHNSZWN0VGV4dCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxud2lkdGg6ICR7cHhYKG9iaiwgdyl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgaCl9O1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c1JlY3RUZXh0fSAqICR7Y29ybmVyUmFkaXVzfXB4KTtcclxuZGlzcGxheTogZmxleDtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiAke2FsaWduID09PSBcImxlZnRcIiA/IFwiZmxleC1zdGFydFwiIDogYWxpZ24gPT09IFwicmlnaHRcIiA/IFwiZmxleC1lbmRcIiA6IFwiY2VudGVyXCJcclxuICAgICAgICAgICAgfTtcclxudGV4dC1hbGlnbjogJHthbGlnbn07XHJcbnBhZGRpbmc6IGNhbGMoJHtzUmVjdFRleHR9ICogNHB4KTtcclxuYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgY29uc3QgaW5uZXIgPSBgXHJcbjxkaXYgc3R5bGU9XCJcclxuICB3aWR0aDogMTAwJTtcclxuICBmb250LXNpemU6IGNhbGMoJHtzUmVjdFRleHR9ICogJHtmb250U2l6ZX1weCk7XHJcbiAgZm9udC1mYW1pbHk6ICR7Zm9udEZhbWlseX07XHJcbiAgZm9udC13ZWlnaHQ6ICR7Zm9udFdlaWdodH07XHJcbiAgZm9udC1zdHlsZTogJHtmb250U3R5bGV9O1xyXG4gIHRleHQtZGVjb3JhdGlvbjogJHt0ZXh0RGVjb3JhdGlvbn07XHJcbiAgY29sb3I6ICR7Y29sb3JUZXh0b307XHJcbiAgbGluZS1oZWlnaHQ6IDEuMjtcclxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XHJcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcclxuXCI+JHt0ZXh0b308L2Rpdj5cclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxkaXYgY2xhc3M9XCJvYmpldG9cIiBzdHlsZT1cIiR7c3R5bGV9XCI+JHtpbm5lcn08L2Rpdj5gLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xyXG4gICAgICAgICAgY29uc3QgcmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ucmFkaXVzKSA/IG9iai5yYWRpdXMgOiA1MDtcclxuICAgICAgICAgIGNvbnN0IGRpYW1ldGVyID0gcmFkaXVzICogMjtcclxuXHJcbiAgICAgICAgICBjb25zdCB4ID0gTnVtYmVyKG9iaj8ueCB8fCAwKSAtIHJhZGl1cztcclxuICAgICAgICAgIGNvbnN0IHlQeENlbnRlciA9IGdldFlQeEVkaXRvcihvYmopO1xyXG4gICAgICAgICAgY29uc3QgeVB4VG9wTGVmdCA9IHlQeENlbnRlciAtIHJhZGl1cztcclxuXHJcbiAgICAgICAgICBjb25zdCByb3QgPSBvYmo/LnJvdGF0aW9uID8/IDA7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVggPSBvYmo/LnNjYWxlWCA/PyAxO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHgpfTtcclxudG9wOiAke3RvcENTU0Zyb21ZUHgob2JqLCB5UHhUb3BMZWZ0KX07XHJcbndpZHRoOiAke3B4WChvYmosIGRpYW1ldGVyKX07XHJcbmhlaWdodDogJHtweFkob2JqLCBkaWFtZXRlcil9O1xyXG5ib3JkZXItcmFkaXVzOiA1MCU7XHJcbmJhY2tncm91bmQ6ICR7ZmlsbH07XHJcbnRyYW5zZm9ybTogcm90YXRlKCR7cm90fWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxkaXYgY2xhc3M9XCJvYmpldG9cIiBzdHlsZT1cIiR7c3R5bGV9XCI+PC9kaXY+YCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwibGluZVwiKSB7XHJcbiAgICAgICAgICBjb25zdCBwb2ludHMgPSBvYmoucG9pbnRzIHx8IFswLCAwLCBMSU5FX0NPTlNUQU5UUy5ERUZBVUxUX0xFTkdUSCwgMF07XHJcbiAgICAgICAgICBjb25zdCB4MSA9IHBhcnNlRmxvYXQocG9pbnRzWzBdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgeTEgPSBwYXJzZUZsb2F0KHBvaW50c1sxXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHgyID0gcGFyc2VGbG9hdChwb2ludHNbMl0pIHx8IExJTkVfQ09OU1RBTlRTLkRFRkFVTFRfTEVOR1RIO1xyXG4gICAgICAgICAgY29uc3QgeTIgPSBwYXJzZUZsb2F0KHBvaW50c1szXSkgfHwgMDtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9iai5zdHJva2VXaWR0aCB8fCBMSU5FX0NPTlNUQU5UUy5TVFJPS0VfV0lEVEg7XHJcblxyXG4gICAgICAgICAgY29uc3QgZGVsdGFYID0geDIgLSB4MTtcclxuICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IHkyIC0geTE7XHJcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcclxuICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkZWx0YVksIGRlbHRhWCkgKiAoMTgwIC8gTWF0aC5QSSk7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3RhcnRYID0gTnVtYmVyKG9iaj8ueCB8fCAwKSArIHgxO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGJhc2VZID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcbiAgICAgICAgICBjb25zdCBzdGFydFkgPSBiYXNlWSArIHkxO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHRvdGFsUm90YXRpb24gPSBhbmdsZSArIChvYmoucm90YXRpb24gfHwgMCk7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVggPSBvYmo/LnNjYWxlWCA/PyAxO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICAgICAgICAvLyBhbHRvIGRlIGzDrW5lYTogdXNhbW9zIGVzY2FsYSBZIGRlbCBvYmpldG8gKGNvbnRlbmlkbzogc2ZpbmFsL3N4LCBibGVlZDogc3gpXHJcbiAgICAgICAgICBjb25zdCBsaW5lSCA9IGBjYWxjKCR7c1kob2JqKX0gKiAke3N0cm9rZVdpZHRofXB4KWA7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCBzdGFydFgpfTtcclxudG9wOiAke3RvcENTU0Zyb21ZUHgob2JqLCBzdGFydFkpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgbGVuZ3RoKX07XHJcbmhlaWdodDogJHtsaW5lSH07XHJcbmJhY2tncm91bmQ6ICR7ZmlsbH07XHJcbnRyYW5zZm9ybTogcm90YXRlKCR7dG90YWxSb3RhdGlvbn1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogMCA1MCU7XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGRpdiBjbGFzcz1cIm9iamV0byBsaW5lYVwiIHN0eWxlPVwiJHtzdHlsZX1cIj48L2Rpdj5gLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZpZ3VyYSA9PT0gXCJ0cmlhbmdsZVwiKSB7XHJcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSBvYmoucmFkaXVzIHx8IDYwO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHNpbjYwID0gTWF0aC5zcXJ0KDMpIC8gMjtcclxuICAgICAgICAgIGNvbnN0IGNvczYwID0gMC41O1xyXG5cclxuICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlV2lkdGggPSAyICogcmFkaXVzICogc2luNjA7XHJcbiAgICAgICAgICBjb25zdCB0cmlhbmdsZUhlaWdodCA9IHJhZGl1cyAqICgxICsgY29zNjApO1xyXG4gICAgICAgICAgY29uc3QgY2VudHJvaWRPZmZzZXRZID0gdHJpYW5nbGVIZWlnaHQgLyAzO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGJhc2VZID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcbiAgICAgICAgICBjb25zdCB0b3BDb250YWluZXJQeCA9IGJhc2VZIC0gKHRyaWFuZ2xlSGVpZ2h0IC0gY2VudHJvaWRPZmZzZXRZKTtcclxuICAgICAgICAgIGNvbnN0IGxlZnRDb250YWluZXIgPSBOdW1iZXIob2JqPy54IHx8IDApIC0gdHJpYW5nbGVXaWR0aCAvIDI7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgbGVmdENvbnRhaW5lcil9O1xyXG50b3A6ICR7dG9wQ1NTRnJvbVlQeChvYmosIHRvcENvbnRhaW5lclB4KX07XHJcbndpZHRoOiAke3B4WChvYmosIHRyaWFuZ2xlV2lkdGgpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIHRyaWFuZ2xlSGVpZ2h0KX07XHJcbmJhY2tncm91bmQ6ICR7ZmlsbH07XHJcbmNsaXAtcGF0aDogcG9seWdvbig1MCUgMCUsIDAlIDEwMCUsIDEwMCUgMTAwJSk7XHJcbnRyYW5zZm9ybTogcm90YXRlKCR7b2JqLnJvdGF0aW9uID8/IDB9ZGVnKSBzY2FsZSgke29iai5zY2FsZVggPz8gMX0sICR7b2JqLnNjYWxlWSA/PyAxfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGRpdiBjbGFzcz1cIm9iamV0b1wiIHN0eWxlPVwiJHtiYXNlU3R5bGV9XCI+PC9kaXY+YCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0pXHJcbiAgICAuam9pbihcIlxcblwiKTtcclxufVxyXG4iXSwibmFtZXMiOlsiTElORV9DT05TVEFOVFMiLCJlc2NIVE1MIiwic3RyIiwiU3RyaW5nIiwicmVwbGFjZSIsImVzY2FwZUF0dHIiLCJNT1RJT05fRUZGRUNUX1ZBTFVFUyIsIlNldCIsInNhbml0aXplTW90aW9uRWZmZWN0IiwidmFsdWUiLCJub3JtYWxpemVkIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiaGFzIiwibm9ybWFsaXplUm9sZVZhbHVlIiwibWFwT2JqVG9EYXRhVHlwZSIsIm9iaiIsInRpcG8iLCJmaWd1cmEiLCJpbmZlckRhdGFSb2xlIiwiZXhwbGljaXRSb2xlIiwicm9sZSIsInJvbCIsInR5cGUiLCJmb250U2l6ZSIsIk51bWJlciIsImlzRmluaXRlIiwiYnVpbGRNb3Rpb25EYXRhQXR0cnMiLCJkYXRhVHlwZSIsImRhdGFSb2xlIiwiZGF0YU1vdGlvbiIsIm1vdGlvbkVmZmVjdCIsImFwcGVuZE1vdGlvbkRhdGFBdHRycyIsImh0bWxFbGVtZW50byIsImF0dHJzIiwiZ2V0TGlua1Byb3BzIiwicmF3IiwiZW5sYWNlIiwiaHJlZiIsInRhcmdldCIsInJlbCIsImVudm9sdmVyU2lFbmxhY2UiLCJodG1sQ29uRGF0YSIsImxpbmsiLCJlc2NhcGVIVE1MIiwidGV4dG8iLCJnZW5lcmFySFRNTERlc2RlT2JqZXRvcyIsIm9iamV0b3MiLCJfc2VjY2lvbmVzIiwiYWx0b01vZG9Qb3JTZWNjaW9uIiwiTWFwIiwibWFwIiwicyIsImlkIiwiYWx0b01vZG8iLCJlc1NlY2Npb25QYW50YWxsYSIsIm1vZG8iLCJnZXQiLCJzZWNjaW9uSWQiLCJpc0Z1bGxCbGVlZCIsImFuY2xhamUiLCJzQ29udGVuaWRvVmFyIiwic1giLCJzWSIsInB4WCIsInB4IiwibiIsInB4WSIsIkFMVFVSQV9FRElUT1JfUEFOVEFMTEEiLCJQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYIiwiY2xhbXAwMSIsIngiLCJNYXRoIiwibWF4IiwibWluIiwiZ2V0WVB4RWRpdG9yIiwieW4iLCJ5Tm9ybSIsInlQeCIsInkiLCJ0b3BQYW50YWxsYUNTUyIsInluUmF3IiwieUJsb3F1ZURpc2VuaW8iLCJ5QmFzZVBhbnRhbGxhIiwieW5Db21wYWN0YWRvIiwidG9wQ1NTIiwieVB4RWRpdG9yIiwidG9wQ1NTRnJvbVlQeCIsInN0eWxlUG9zQmFzZSIsInJvdCIsInJvdGF0aW9uIiwic2NhbGVYIiwic2NhbGVZIiwiekluZGV4IiwidW5kZWZpbmVkIiwic3R5bGVTaXplIiwidyIsImgiLCJ3dyIsImhoIiwicGFydHMiLCJwdXNoIiwiam9pbiIsInJlbmRlckljb25vU3ZnTnVldm9JbmxpbmUiLCJ2aWV3Qm94IiwiY29sb3IiLCJwYXRocyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIndpZHRoIiwiaGVpZ2h0IiwicGF0aHNIdG1sIiwicCIsImQiLCJzdHlsZSIsImFsaWduIiwidGV4dEFsaWduIiwiY29sb3JUZXh0byIsImZpbGwiLCJiYXNlTGluZUhlaWdodCIsImxpbmVIZWlnaHQiLCJsaW5lSGVpZ2h0RmluYWwiLCJzYWZlVGV4dG8iLCJiYXNlU3R5bGUiLCJmcyIsInNGb250Iiwib3JpZ2luIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJ0ZXh0RGVjb3JhdGlvbiIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic2hhZG93Q29sb3IiLCJzaGFkb3dPZmZzZXRYIiwic2hhZG93T2Zmc2V0WSIsInNoYWRvd0JsdXIiLCJzcmMiLCJ1cmwiLCJmb3JtYXRvIiwic3ZnSHRtbCIsInZiIiwic3ZnIiwidGFyZ2V0SVNPIiwiZmVjaGFPYmpldGl2byIsImZlY2hhSVNPIiwidGV4dENvbG9yIiwicHJlc2V0IiwicHJlc2V0SWQiLCJsYXlvdXQiLCJpc01pbmltYWwiLCJpbmNsdWRlcyIsIndPYmoiLCJoT2JqIiwiZ2FwIiwic3BhY2luZyIsImNoaXBXaWR0aFByb3AiLCJjaGlwV2lkdGgiLCJwYWRkaW5nWFByb3AiLCJwYWRkaW5nWCIsImNoaXBXVG90YWwiLCJyb3VuZCIsInBhZGRpbmdZIiwidmFsdWVTaXplIiwibGFiZWxTaXplIiwibGFiZWxDb2xvciIsImxldHRlclNwYWNpbmciLCJjb250YWluZXJCZ0ZpbmFsIiwiY2hpcEJnRmluYWwiLCJjaGlwQmFja2dyb3VuZCIsImJveEJnIiwiY2hpcEJvcmRlckNvbG9yRmluYWwiLCJjaGlwQm9yZGVyIiwiYm94Qm9yZGVyIiwiY29udGFpbmVyUmFkaXVzIiwiYm94UmFkaXVzIiwicmFkaXVzIiwiY2hpcFJhZGl1c0ZpbmFsIiwiY2hpcFJhZGl1cyIsInNDaGlwIiwiY29udGFpbmVyU3R5bGUiLCJjaGlwU3R5bGUiLCJ2YWx1ZVN0eWxlIiwibGFiZWxTdHlsZSIsInNob3dMYWJlbHMiLCJsYWJlbHMiLCJkaWFzIiwiaG9yYXMiLCJzZWciLCJodG1sQ291bnRkb3duIiwicm93cyIsInBhcnNlSW50IiwiY29scyIsImdhcFB4IiwicmFkaXVzUHgiLCJzR3JpZCIsInN0eWxlQ29udGVuZWRvciIsInRvdGFsIiwiY2VsbHMiLCJmcm9tIiwiXyIsImkiLCJjIiwibWVkaWFVcmwiLCJmaXQiLCJiZyIsImh0bWxDZWxkYXMiLCJjZWxsIiwiaWR4Iiwic2FmZVNyYyIsImNlbGRhU3R5bGUiLCJodG1sR2FsZXJpYSIsImFuY2hvIiwiYWx0byIsInNCdG4iLCJodG1sUnN2cCIsImNvcm5lclJhZGl1cyIsInNSZWN0VGV4dCIsImlubmVyIiwiZGlhbWV0ZXIiLCJ5UHhDZW50ZXIiLCJ5UHhUb3BMZWZ0IiwicG9pbnRzIiwiREVGQVVMVF9MRU5HVEgiLCJ4MSIsInBhcnNlRmxvYXQiLCJ5MSIsIngyIiwieTIiLCJTVFJPS0VfV0lEVEgiLCJkZWx0YVgiLCJkZWx0YVkiLCJzcXJ0IiwiYW5nbGUiLCJhdGFuMiIsIlBJIiwic3RhcnRYIiwiYmFzZVkiLCJzdGFydFkiLCJ0b3RhbFJvdGF0aW9uIiwibGluZUgiLCJzaW42MCIsImNvczYwIiwidHJpYW5nbGVXaWR0aCIsInRyaWFuZ2xlSGVpZ2h0IiwiY2VudHJvaWRPZmZzZXRZIiwidG9wQ29udGFpbmVyUHgiLCJsZWZ0Q29udGFpbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarHTMLDesdeSecciones.ts":
/*!**********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeSecciones.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarHTMLDesdeSecciones: () => (/* binding */ generarHTMLDesdeSecciones)\n/* harmony export */ });\n/* harmony import */ var _generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generarHTMLDesdeObjetos */ \"(pages-dir-node)/./functions/src/utils/generarHTMLDesdeObjetos.ts\");\n/* harmony import */ var _models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/dimensionesBase */ \"(pages-dir-node)/./functions/src/models/dimensionesBase.ts\");\n/* harmony import */ var _generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generarModalRSVP */ \"(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts\");\n/* harmony import */ var _generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generarModalGaleria */ \"(pages-dir-node)/./functions/src/utils/generarModalGaleria.ts\");\n/* harmony import */ var _mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mobileSmartSectionLayout */ \"(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts\");\n/* harmony import */ var _generarMotionEffectsRuntime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generarMotionEffectsRuntime */ \"(pages-dir-node)/./functions/src/utils/generarMotionEffectsRuntime.ts\");\n/* harmony import */ var _generarInvitationLoaderRuntime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./generarInvitationLoaderRuntime */ \"(pages-dir-node)/./functions/src/utils/generarInvitationLoaderRuntime.ts\");\n\n\n\n\n\n\n\nconst ENABLE_MOBILE_SMART_LAYOUT = true; // ✅ empezamos apagado\nconst EXCLUDE_FONTS = new Set([\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\",\n    \"Arial\",\n    \"Helvetica\",\n    \"Times\",\n    \"Times New Roman\",\n    \"Georgia\",\n    \"Courier New\"\n]);\nconst ALTURA_REFERENCIA_PANTALLA = 500;\n// ✅ Offsets SOLO para texto en secciones Pantalla: ON\n// - Desktop: aplica cuando vw > 767px\n// - Mobile: aplica cuando vw <= 767px\n// (Estos valores se vuelcan a CSS variables en :root)\nconst PANTALLA_Y_OFFSET_DESKTOP_PX = 0;\nconst PANTALLA_Y_OFFSET_MOBILE_PX = 0;\nfunction buildGoogleFontsLink(fonts) {\n    const familias = fonts.map((f)=>f.replace(/['\"]/g, \"\").split(\",\")[0].trim()).filter((n)=>n && !EXCLUDE_FONTS.has(n)).map((n)=>`family=${n.replace(/ /g, \"+\")}`).join(\"&\");\n    if (!familias) return \"\";\n    return `\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?${familias}&display=swap\" rel=\"stylesheet\">`.trim();\n}\nfunction escapeAttr(str = \"\") {\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction buildFondoStyle(seccion) {\n    const fondoValue = seccion?.fondo || \"transparent\";\n    const esImagenFondo = seccion?.fondoTipo === \"imagen\" && seccion?.fondoImagen;\n    let estilosFondo = \"\";\n    if (esImagenFondo) {\n        let imageUrl = seccion.fondoImagen;\n        if (imageUrl && imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        let backgroundPosition = \"center center\";\n        if (seccion.fondoImagenOffsetX !== undefined || seccion.fondoImagenOffsetY !== undefined) {\n            const offsetX = seccion.fondoImagenOffsetX || 0;\n            const offsetY = seccion.fondoImagenOffsetY || 0;\n            const offsetXPercent = offsetX !== 0 ? `calc(50% - ${-offsetX}px)` : \"50%\";\n            const offsetYPercent = offsetY !== 0 ? `calc(50% - ${-offsetY}px)` : \"50%\";\n            backgroundPosition = `${offsetXPercent} ${offsetYPercent}`;\n        }\n        estilosFondo = `background-image: url('${imageUrl}'); background-size: cover; background-position: ${backgroundPosition}; background-repeat: no-repeat;`;\n    } else if (fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\")) {\n        let imageUrl = fondoValue.replace(\"url(\", \"\").replace(\")\", \"\");\n        if (imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        estilosFondo = `background-image: url('${imageUrl}'); background-size: cover; background-position: center center; background-repeat: no-repeat;`;\n    } else {\n        estilosFondo = `background: ${fondoValue};`;\n    }\n    return estilosFondo.replace(/\\s+/g, \" \").trim();\n}\nfunction hasImageBackground(seccion) {\n    if (seccion?.fondoTipo === \"imagen\" && seccion?.fondoImagen) return true;\n    const fondoValue = typeof seccion?.fondo === \"string\" ? seccion.fondo.trim() : \"\";\n    return fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\");\n}\nfunction generarHTMLDesdeSecciones(secciones, objetos, rsvp, opciones, opts) {\n    const slug = opciones?.slug ?? \"\";\n    const slugPublica = opts?.slug ?? \"\";\n    const fuentesUsadas = [\n        ...new Set(objetos.filter((o)=>(o.tipo === \"texto\" || o.tipo === \"countdown\") && o.fontFamily).map((o)=>o.fontFamily))\n    ];\n    const googleFontsLink = buildGoogleFontsLink(fuentesUsadas);\n    const hayRSVPEnCanvas = objetos?.some((o)=>o.tipo === \"rsvp-boton\");\n    const botonRSVP = \"\"; // (si querés agregar un botón fijo fuera del canvas, hacelo acá)\n    const modalRSVP = hayRSVPEnCanvas && rsvp?.enabled ? (0,_generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__.generarModalRSVPHTML)(rsvp) : \"\";\n    const modalGaleria = (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.hayGaleriaConImagenes)(objetos) ? (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.generarModalGaleriaHTML)() : \"\";\n    const invitationLoaderRuntime = (0,_generarInvitationLoaderRuntime__WEBPACK_IMPORTED_MODULE_6__.generarInvitationLoaderRuntimeHTML)();\n    const motionEffectsRuntime = (0,_generarMotionEffectsRuntime__WEBPACK_IMPORTED_MODULE_5__.generarMotionEffectsRuntimeHTML)();\n    function hayCountdown(objs) {\n        return Array.isArray(objs) && objs.some((o)=>o?.tipo === \"countdown\");\n    }\n    const scriptCountdown = hayCountdown(objetos) ? `\n<script>\n(function(){\n  function pad(n){ n=Math.floor(Math.abs(n)); return n<10 ? \"0\"+n : \"\"+n; }\n  function diffParts(target){\n    const now = Date.now();\n    let ms = Math.max(0, target.getTime() - now);\n    const d = Math.floor(ms / 86400000); ms -= d*86400000;\n    const h = Math.floor(ms / 3600000);  ms -= h*3600000;\n    const m = Math.floor(ms / 60000);    ms -= m*60000;\n    const s = Math.floor(ms / 1000);\n    return { d, h, m, s };\n  }\n  function tickOne(root){\n    const iso = root.getAttribute(\"data-target\");\n    if(!iso) return;\n    const t = new Date(iso);\n    if(isNaN(t.getTime())) return;\n    const p = diffParts(t);\n    const vals = root.querySelectorAll(\".cd-val\");\n    if(vals && vals.length >= 4){\n      vals[0].textContent = String(p.d).padStart(2,\"0\");\n      vals[1].textContent = pad(p.h);\n      vals[2].textContent = pad(p.m);\n      vals[3].textContent = pad(p.s);\n    }\n  }\n  function boot(){\n    const roots = Array.from(document.querySelectorAll(\"[data-countdown]\"));\n    if(!roots.length) return;\n    roots.forEach(tickOne);\n    setInterval(() => roots.forEach(tickOne), 1000);\n  }\n  if(document.readyState === \"loading\"){\n    document.addEventListener(\"DOMContentLoaded\", boot);\n  } else {\n    boot();\n  }\n})();\n</script>\n`.trim() : \"\";\n    const seccionesOrdenadas = [\n        ...secciones || []\n    ].sort((a, b)=>(Number(a?.orden) || 0) - (Number(b?.orden) || 0));\n    const htmlSecciones = seccionesOrdenadas.map((seccion)=>{\n        const modo = String(seccion?.altoModo || \"fijo\").toLowerCase();\n        const hbase = Number.isFinite(seccion?.altura) ? Number(seccion.altura) : 600;\n        const fondoEsImagen = hasImageBackground(seccion);\n        const objsDeSeccion = objetos.filter((o)=>o.seccionId === seccion.id);\n        const objsBleed = objsDeSeccion.filter((o)=>String(o?.anclaje || \"\").toLowerCase() === \"fullbleed\");\n        const objsContenido = objsDeSeccion.filter((o)=>String(o?.anclaje || \"\").toLowerCase() !== \"fullbleed\");\n        const fondoStyle = buildFondoStyle(seccion);\n        const htmlBleed = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsBleed, seccionesOrdenadas);\n        const htmlContenido = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsContenido, seccionesOrdenadas);\n        return `\n<section class=\"sec\" data-modo=\"${escapeAttr(modo)}\" data-fondo=\"${fondoEsImagen ? \"imagen\" : \"color\"}\" style=\"--hbase:${hbase}\">\n  <div class=\"sec-zoom\">\n    <div class=\"sec-bg\" style=\"${fondoStyle}\"></div>\n    <div class=\"sec-bleed\">${htmlBleed}</div>\n    <div class=\"sec-content\">${htmlContenido}</div>\n  </div>\n</section>\n`.trim();\n    }).join(\"\\n\");\n    const scriptMobileSmart = (0,_mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__.buildMobileSmartSectionLayoutScript)({\n        enabled: ENABLE_MOBILE_SMART_LAYOUT,\n        minGapPx: 1,\n        paddingTopPx: 0,\n        paddingBottomPx: 2,\n        onlyFixedSections: true,\n        minPerColumn2: 1,\n        fitMinScale: 0.88,\n        fitMaxScale: 1.16,\n        fitTargetWidthRatio: 0.94,\n        fitMinFillRatio: 0.9\n    });\n    return `\n<!DOCTYPE html>\n<html lang=\"es\"${slug ? ` data-slug=\"${escapeAttr(slug)}\"` : \"\"}>\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\" />\n  <title>Invitación</title>\n  ${googleFontsLink}\n  <style>\n    * { box-sizing: border-box; margin: 0; padding: 0; }\n\n    html, body {\n      width: 100%;\n      height: 100%;\n      background: white;\n      overflow-x: hidden;\n      font-family: sans-serif;\n    }\n\n    /* ✅ SOLO MOBILE: evita “auto-resize / font boosting” del texto */\n    @media (max-width: 767px){\n      html{\n        -webkit-text-size-adjust: 100%;\n        text-size-adjust: 100%;\n      }\n      \n        :root{ --text-zoom: 1; }\n    }\n\n    :root{\n      --safe-top: env(safe-area-inset-top, 0px);\n      --safe-right: env(safe-area-inset-right, 0px);\n      --safe-bottom: env(safe-area-inset-bottom, 0px);\n      --safe-left: env(safe-area-inset-left, 0px);\n      --bp-mobile: 767px;\n      \n\n\n      /* Global scales */\n      --content-w: ${_models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__.CANVAS_BASE.ANCHO}px;\n      --sx: 1;   /* contentW/800 */\n      --bx: 1;   /* viewportW/800 */\n\n      /* vh lógico por defecto */\n      --vh-safe: 100vh;\n      --vh-logical: var(--vh-safe);\n      --pantalla-y-compact: 0;\n      --pantalla-y-base: 0px;\n\n      /* ✅ Offset SOLO para texto en Pantalla: ON (desktop default) */\n      --pantalla-y-offset: ${PANTALLA_Y_OFFSET_DESKTOP_PX}px;\n    }\n\n    /* ✅ Mobile: offset distinto SOLO para texto en Pantalla: ON */\n    @media (max-width: 767px){\n      :root{\n        --pantalla-y-offset: ${PANTALLA_Y_OFFSET_MOBILE_PX}px;\n      }\n    }\n\n    .inv{ width: 100%; background: white; }\n\n    .sec{\n      position: relative;\n      width: 100vw;\n      left: 50%;\n      transform: translateX(-50%);\n      overflow: visible; /* bleed puede salirse */\n    }\n\n    /* ✅ Wrapper que hace “zoom” centrado (evita corrimiento a la derecha) */\n    .sec-zoom{\n      position: relative;\n      width: 100%;\n      height: 100%;\n      transform-origin: top center;\n      transform: scale(var(--zoom, 1));\n    }\n\n    /* ✅ Pantalla ON: recorte para que el zoom no desborde */\n    .sec[data-modo=\"pantalla\"]{\n      overflow: hidden;\n      height: 100dvh;\n      height: 100vh;\n      padding-top: var(--safe-top);\n      padding-bottom: var(--safe-bottom);\n\n      /* fallback CSS (JS lo pisa en mobile con px reales) */\n      --vh-safe: calc(100dvh - var(--safe-top) - var(--safe-bottom));\n\n      /* el zoom extra va por --zoom (NO por sfinal) */\n      --zoom: 1;\n      --bgzoom: 1;\n\n      /* factor final para CONTENIDO (se setea por JS) */\n      --sfinal: 1;\n    }\n\n    .sec[data-modo=\"fijo\"]{\n      /* altura fija escalada por ancho; JS setea --sfinal = sx */\n      height: calc(var(--sfinal) * var(--hbase) * 1px);\n      --zoom: 1;\n      --bgzoom: 1;\n    }\n\n    /* Fondo */\n    .sec-bg{\n      position: absolute;\n      inset: 0;\n      z-index: 0;\n      pointer-events: none;\n    }\n\n    /* ✅ Fondo agrandable solo en pantalla (acompaña el zoom hero) */\n    .sec[data-modo=\"pantalla\"] .sec-bg{\n      transform: scale(var(--bgzoom, 1));\n      transform-origin: center;\n    }\n\n    /* ✅ En fondos de imagen, compensamos desde el mismo origen que el wrapper */\n    .sec[data-modo=\"pantalla\"][data-fondo=\"imagen\"] .sec-bg{\n      transform-origin: top center;\n    }\n\n    .sec-bleed{\n      position: absolute;\n      inset: 0;\n      z-index: 2;\n      overflow: visible;\n      pointer-events: none;\n    }\n\n    .sec-content{\n      position: relative;\n      z-index: 3;\n      width: var(--content-w);\n      margin: 0 auto;\n      height: 100%;\n      pointer-events: none;\n    }\n\n    /* ✅ Pantalla ON: el ancho del “content” puede crecer con la escala vertical */\n    .sec[data-modo=\"pantalla\"] .sec-content{\n      width: var(--content-w-pantalla, var(--content-w));\n    }\n\n    @media (max-width: 767px){\n      .sec-content{\n        width: 100%;\n        margin: 0;\n        box-sizing: border-box;\n        padding-left: var(--safe-left);\n        padding-right: var(--safe-right);\n      }\n    }\n\n    .objeto{\n      position: absolute;\n      transform-origin: top left;\n      overflow: visible;\n      pointer-events: auto;\n    }\n\n    .objeto[data-debug-texto=\"1\"]{\n      -webkit-font-smoothing: antialiased;\n      text-rendering: optimizeLegibility;\n    }\n\n    .objeto.is-interactive{ pointer-events: auto; }\n\n    .cd-chip { backdrop-filter: saturate(1.1); }\n  </style>\n</head>\n\n<body data-loader-ready=\"0\" data-slug=\"${escapeAttr(slugPublica)}\">\n  ${invitationLoaderRuntime}\n  <div class=\"inv\">\n    ${htmlSecciones}\n  </div>\n\n  ${botonRSVP}\n  ${modalRSVP}\n  ${modalGaleria}\n  ${motionEffectsRuntime}\n\n  ${scriptCountdown}\n\n  <script>\n    (function(){\n      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }\n\n      function compute(){\n        var vw = document.documentElement.clientWidth;\n        var BASE_W = 800; // = CANVAS_BASE.ANCHO\n\n        // contentW (sin vw-32)\n        var contentW = Math.min(BASE_W, vw);\n\n        var sx = contentW / BASE_W;\n        var bx = vw / BASE_W;\n\n        document.documentElement.style.setProperty(\"--content-w\", contentW + \"px\");\n        document.documentElement.style.setProperty(\"--sx\", String(sx));\n        document.documentElement.style.setProperty(\"--bx\", String(bx));\n\n        var secs = Array.from(document.querySelectorAll(\".sec\"));\n        var isMobile = vw <= 767;\n\n        // viewport real (más estable en mobile)\n        var vv = window.visualViewport;\n        var viewportH = (vv && vv.height) ? vv.height : window.innerHeight;\n\n        // safe areas (css env)\n        var safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-top\")) || 0;\n        var safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-bottom\")) || 0;\n\n        // diseño base del modo \"pantalla\" (800 x 500)\n        var DESIGN_W = BASE_W;\n        var DESIGN_H = ${ALTURA_REFERENCIA_PANTALLA}; // = ALTURA_REFERENCIA_PANTALLA\n        var designAR = DESIGN_H / DESIGN_W; // 0.625\n        var deviceAR = viewportH / vw;\n\n        // zoom extra (solo si el device es más vertical que el diseño)\n        var zoomExtra = 1;\n        if (isMobile && deviceAR > designAR){\n          var k = deviceAR / designAR;\n          zoomExtra = clamp(1 + (k - 1) * 0.18, 1, 1.35);\n        }\n\n        // 🔧 Ajuste fino: cuánto mantiene el zoom visual del fondo en mobile/pantalla.\n        // 0   => el fondo se compensa para verse similar a desktop.\n        // 1   => comportamiento anterior (fondo acompaña completo el zoom del hero).\n        // 0.3 => compensación parcial.\n        var BG_ZOOM_FACTOR = 0;\n\n        // 🔧 Ajuste fino: cuánto acompaña el CONTENIDO (texto/objetos) al zoom hero\n        // 0   => comportamiento actual\n        // 0.3 => recomendado\n        // 1   => texto escala igual que el hero (no aconsejado)\n        var TEXT_ZOOM_FACTOR = 0;\n\n\n        secs.forEach(function(sec){\n          var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n          var fondoTipo = (sec.getAttribute(\"data-fondo\") || \"color\").toLowerCase();\n\n          // defaults\n          var zoom = 1;\n          var bgzoom = 1;\n\n          // ✅ Por defecto, tamaños escalan por ancho (comportamiento actual)\n          var sfinal = sx;\n          var pantallaYCompact = 0;\n          var pantallaYBasePx = 0;\n\n          // limpiar custom width si no aplica\n          sec.style.removeProperty(\"--content-w-pantalla\");\n\n          if (modo === \"pantalla\"){\n            // vh-safe real en px\n            var vhSafePx = Math.max(0, viewportH - safeTop - safeBottom);\n            sec.style.setProperty(\"--vh-safe\", vhSafePx + \"px\");\n\n            // 🔥 Desktop: escalar el contenido por ALTURA (vhSafe/500)\n            // Esto alinea el HTML publicado con lo que ves en preview\n            if (!isMobile){\n              var sh = vhSafePx / DESIGN_H;\n              sfinal = sh;\n\n              // para que el \"content\" quede centrado y coherente con la nueva escala vertical\n              sec.style.setProperty(\"--content-w-pantalla\", (DESIGN_W * sh) + \"px\");\n            }\n\n            // ✅ Mobile: mantenemos tu comportamiento actual (zoom hero suave)\n            if (isMobile){\n              zoom = zoomExtra;\n              var bgVisualZoom = 1 + (zoomExtra - 1) * BG_ZOOM_FACTOR;\n              if (fondoTipo === \"imagen\") {\n                bgzoom = bgVisualZoom / Math.max(0.01, zoom);\n              } else {\n                bgzoom = bgVisualZoom;\n              }\n\n              // 🔥 NUEVO: el contenido acompaña parcialmente el zoom\n              sfinal = sx * (1 + (zoomExtra - 1) * TEXT_ZOOM_FACTOR);\n\n              // ✅ Fidelity de diseño en Pantalla:ON:\n              // no compactamos distancias verticales para respetar posiciones\n              // intencionales (incluyendo textos encimados o muy cercanos).\n              pantallaYCompact = 0;\n\n              // ✅ Ajuste de posición vertical global (uniforme):\n              // desplazamos TODO el bloque por igual para no alterar posiciones relativas.\n              var vhLogicalPx = vhSafePx / Math.max(0.01, zoom || 1);\n              var designScaledHPx = sfinal * DESIGN_H;\n              var spareVerticalPx = Math.max(0, vhLogicalPx - designScaledHPx);\n              pantallaYBasePx = spareVerticalPx * 0.36;\n            }\n          }\n\n          sec.style.setProperty(\"--sfinal\", String(sfinal));\n          sec.style.setProperty(\"--zoom\", String(zoom));\n          sec.style.setProperty(\"--bgzoom\", String(bgzoom));\n\n          // ✅ Solo en mobile + pantalla: corregir el \"vh\" que después se escala con zoom\n          if (isMobile && modo === \"pantalla\") {\n            // --vh-logical = --vh-safe / --zoom\n            sec.style.setProperty(\"--vh-logical\", \"calc(var(--vh-safe) / var(--zoom))\");\n          } else {\n            // resto: se comporta como siempre\n            sec.style.setProperty(\"--vh-logical\", \"var(--vh-safe)\");\n          }\n          sec.style.setProperty(\"--pantalla-y-compact\", String(pantallaYCompact));\n          sec.style.setProperty(\"--pantalla-y-base\", pantallaYBasePx + \"px\");\n        });\n\n\n      }\n\n      window.addEventListener(\"load\", compute);\n      window.addEventListener(\"resize\", compute);\n\n      if (window.visualViewport){\n        window.visualViewport.addEventListener(\"resize\", compute);\n        window.visualViewport.addEventListener(\"scroll\", compute);\n      }\n\n      window.addEventListener(\"orientationchange\", function(){\n        setTimeout(compute, 50);\n        setTimeout(compute, 250);\n      });\n\n      compute();\n    })();\n  </script>\n\n    \n\n\n   ${scriptMobileSmart}\n \n</body>\n</html>\n`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvRTtBQUNaO0FBQ2tDO0FBQ0g7QUFDTjtBQUNEO0FBQ007QUFFdEYsTUFBTVEsNkJBQTZCLE1BQU0sc0JBQXNCO0FBRS9ELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJO0lBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsNkJBQTZCO0FBRW5DLHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxNQUFNQywrQkFBK0I7QUFDckMsTUFBTUMsOEJBQThCO0FBRXBDLFNBQVNDLHFCQUFxQkMsS0FBZTtJQUMzQyxNQUFNQyxXQUFXRCxNQUNkRSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsT0FBTyxDQUFDLFNBQVMsSUFBSUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLElBQUksSUFDcERDLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxLQUFLLENBQUNkLGNBQWNlLEdBQUcsQ0FBQ0QsSUFDdENOLEdBQUcsQ0FBQyxDQUFDTSxJQUFNLENBQUMsT0FBTyxFQUFFQSxFQUFFSixPQUFPLENBQUMsTUFBTSxNQUFNLEVBQzNDTSxJQUFJLENBQUM7SUFFUixJQUFJLENBQUNULFVBQVUsT0FBTztJQUV0QixPQUFPLENBQUM7OzhDQUVvQyxFQUFFQSxTQUFTLGdDQUFnQyxDQUFDLENBQUNLLElBQUk7QUFDL0Y7QUFNQSxTQUFTSyxXQUFXQyxNQUFjLEVBQUU7SUFDbEMsT0FBT0MsT0FBT0QsS0FDWFIsT0FBTyxDQUFDLE1BQU0sU0FDZEEsT0FBTyxDQUFDLE1BQU0sVUFDZEEsT0FBTyxDQUFDLE1BQU0sUUFDZEEsT0FBTyxDQUFDLE1BQU07QUFDbkI7QUFFQSxTQUFTVSxn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RXhCLEVBQUVhLGNBQWM7OztFQUdsQixFQUFFakIsVUFBVTtFQUNaLEVBQUVDLFVBQVU7RUFDWixFQUFFRSxhQUFhO0VBQ2YsRUFBRUUscUJBQXFCOztFQUV2QixFQUFFSyxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFpQ0csRUFBRS9ELDJCQUEyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlIakQsRUFBRXVGLGtCQUFrQjs7OztBQUl2QixDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyB9IGZyb20gXCIuL2dlbmVyYXJIVE1MRGVzZGVPYmpldG9zXCI7XHJcbmltcG9ydCB7IENBTlZBU19CQVNFIH0gZnJvbSBcIi4uL21vZGVscy9kaW1lbnNpb25lc0Jhc2VcIjtcclxuaW1wb3J0IHsgZ2VuZXJhck1vZGFsUlNWUEhUTUwsIHR5cGUgUlNWUENvbmZpZyBhcyBNb2RhbENvbmZpZyB9IGZyb20gXCIuL2dlbmVyYXJNb2RhbFJTVlBcIjtcclxuaW1wb3J0IHsgZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwsIGhheUdhbGVyaWFDb25JbWFnZW5lcyB9IGZyb20gXCIuL2dlbmVyYXJNb2RhbEdhbGVyaWFcIjtcclxuaW1wb3J0IHsgYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQgfSBmcm9tIFwiLi9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRcIjtcclxuaW1wb3J0IHsgZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lSFRNTCB9IGZyb20gXCIuL2dlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZVwiO1xyXG5pbXBvcnQgeyBnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIH0gZnJvbSBcIi4vZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lXCI7XHJcblxyXG5jb25zdCBFTkFCTEVfTU9CSUxFX1NNQVJUX0xBWU9VVCA9IHRydWU7IC8vIOKchSBlbXBlemFtb3MgYXBhZ2Fkb1xyXG5cclxuY29uc3QgRVhDTFVERV9GT05UUyA9IG5ldyBTZXQoW1xyXG4gIFwic2VyaWZcIixcclxuICBcInNhbnMtc2VyaWZcIixcclxuICBcIm1vbm9zcGFjZVwiLFxyXG4gIFwiY3Vyc2l2ZVwiLFxyXG4gIFwiZmFudGFzeVwiLFxyXG4gIFwic3lzdGVtLXVpXCIsXHJcbiAgXCJBcmlhbFwiLFxyXG4gIFwiSGVsdmV0aWNhXCIsXHJcbiAgXCJUaW1lc1wiLFxyXG4gIFwiVGltZXMgTmV3IFJvbWFuXCIsXHJcbiAgXCJHZW9yZ2lhXCIsXHJcbiAgXCJDb3VyaWVyIE5ld1wiLFxyXG5dKTtcclxuXHJcbmNvbnN0IEFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBID0gNTAwO1xyXG5cclxuLy8g4pyFIE9mZnNldHMgU09MTyBwYXJhIHRleHRvIGVuIHNlY2Npb25lcyBQYW50YWxsYTogT05cclxuLy8gLSBEZXNrdG9wOiBhcGxpY2EgY3VhbmRvIHZ3ID4gNzY3cHhcclxuLy8gLSBNb2JpbGU6IGFwbGljYSBjdWFuZG8gdncgPD0gNzY3cHhcclxuLy8gKEVzdG9zIHZhbG9yZXMgc2UgdnVlbGNhbiBhIENTUyB2YXJpYWJsZXMgZW4gOnJvb3QpXHJcbmNvbnN0IFBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFggPSAwO1xuY29uc3QgUEFOVEFMTEFfWV9PRkZTRVRfTU9CSUxFX1BYID0gMDtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlRm9udHNMaW5rKGZvbnRzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgY29uc3QgZmFtaWxpYXMgPSBmb250c1xyXG4gICAgLm1hcCgoZikgPT4gZi5yZXBsYWNlKC9bJ1wiXS9nLCBcIlwiKS5zcGxpdChcIixcIilbMF0udHJpbSgpKVxyXG4gICAgLmZpbHRlcigobikgPT4gbiAmJiAhRVhDTFVERV9GT05UUy5oYXMobikpXHJcbiAgICAubWFwKChuKSA9PiBgZmFtaWx5PSR7bi5yZXBsYWNlKC8gL2csIFwiK1wiKX1gKVxyXG4gICAgLmpvaW4oXCImXCIpO1xyXG5cclxuICBpZiAoIWZhbWlsaWFzKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgcmV0dXJuIGBcclxuPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tXCIgY3Jvc3NvcmlnaW4+XHJcbjxsaW5rIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/JHtmYW1pbGlhc30mZGlzcGxheT1zd2FwXCIgcmVsPVwic3R5bGVzaGVldFwiPmAudHJpbSgpO1xyXG59XHJcblxyXG50eXBlIEdlbmVyYXJIVE1MT3BjaW9uZXMgPSB7XG4gIHNsdWc/OiBzdHJpbmc7XG59O1xuXHJcbmZ1bmN0aW9uIGVzY2FwZUF0dHIoc3RyOiBzdHJpbmcgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gU3RyaW5nKHN0cilcclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkRm9uZG9TdHlsZShzZWNjaW9uOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBmb25kb1ZhbHVlID0gc2VjY2lvbj8uZm9uZG8gfHwgXCJ0cmFuc3BhcmVudFwiO1xuICBjb25zdCBlc0ltYWdlbkZvbmRvID0gc2VjY2lvbj8uZm9uZG9UaXBvID09PSBcImltYWdlblwiICYmIHNlY2Npb24/LmZvbmRvSW1hZ2VuO1xuXHJcbiAgbGV0IGVzdGlsb3NGb25kbyA9IFwiXCI7XHJcblxyXG4gIGlmIChlc0ltYWdlbkZvbmRvKSB7XHJcbiAgICBsZXQgaW1hZ2VVcmwgPSBzZWNjaW9uLmZvbmRvSW1hZ2VuO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgaW1hZ2VVcmwgJiZcclxuICAgICAgaW1hZ2VVcmwuaW5jbHVkZXMoXCJmaXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb21cIikgJiZcclxuICAgICAgIWltYWdlVXJsLmluY2x1ZGVzKFwiYWx0PW1lZGlhXCIpXHJcbiAgICApIHtcclxuICAgICAgaW1hZ2VVcmwgPSBpbWFnZVVybCArIChpbWFnZVVybC5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiKSArIFwiYWx0PW1lZGlhXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGJhY2tncm91bmRQb3NpdGlvbiA9IFwiY2VudGVyIGNlbnRlclwiO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgc2VjY2lvbi5mb25kb0ltYWdlbk9mZnNldFggIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WSAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IHNlY2Npb24uZm9uZG9JbWFnZW5PZmZzZXRYIHx8IDA7XHJcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WSB8fCAwO1xyXG5cclxuICAgICAgY29uc3Qgb2Zmc2V0WFBlcmNlbnQgPSBvZmZzZXRYICE9PSAwID8gYGNhbGMoNTAlIC0gJHstb2Zmc2V0WH1weClgIDogXCI1MCVcIjtcclxuICAgICAgY29uc3Qgb2Zmc2V0WVBlcmNlbnQgPSBvZmZzZXRZICE9PSAwID8gYGNhbGMoNTAlIC0gJHstb2Zmc2V0WX1weClgIDogXCI1MCVcIjtcclxuXHJcbiAgICAgIGJhY2tncm91bmRQb3NpdGlvbiA9IGAke29mZnNldFhQZXJjZW50fSAke29mZnNldFlQZXJjZW50fWA7XHJcbiAgICB9XHJcblxyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgnJHtpbWFnZVVybH0nKTsgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjsgYmFja2dyb3VuZC1wb3NpdGlvbjogJHtiYWNrZ3JvdW5kUG9zaXRpb259OyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O2A7XHJcbiAgfSBlbHNlIGlmIChcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImh0dHBcIikgfHxcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImRhdGE6XCIpIHx8XHJcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJibG9iOlwiKVxyXG4gICkge1xyXG4gICAgbGV0IGltYWdlVXJsID0gZm9uZG9WYWx1ZS5yZXBsYWNlKFwidXJsKFwiLCBcIlwiKS5yZXBsYWNlKFwiKVwiLCBcIlwiKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGltYWdlVXJsLmluY2x1ZGVzKFwiZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tXCIpICYmXHJcbiAgICAgICFpbWFnZVVybC5pbmNsdWRlcyhcImFsdD1tZWRpYVwiKVxyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlVXJsID0gaW1hZ2VVcmwgKyAoaW1hZ2VVcmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIikgKyBcImFsdD1tZWRpYVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGVzdGlsb3NGb25kbyA9IGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJyR7aW1hZ2VVcmx9Jyk7IGJhY2tncm91bmQtc2l6ZTogY292ZXI7IGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7YDtcclxuICB9IGVsc2Uge1xyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQ6ICR7Zm9uZG9WYWx1ZX07YDtcclxuICB9XHJcblxuICByZXR1cm4gZXN0aWxvc0ZvbmRvLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gaGFzSW1hZ2VCYWNrZ3JvdW5kKHNlY2Npb246IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoc2VjY2lvbj8uZm9uZG9UaXBvID09PSBcImltYWdlblwiICYmIHNlY2Npb24/LmZvbmRvSW1hZ2VuKSByZXR1cm4gdHJ1ZTtcblxuICBjb25zdCBmb25kb1ZhbHVlID0gdHlwZW9mIHNlY2Npb24/LmZvbmRvID09PSBcInN0cmluZ1wiID8gc2VjY2lvbi5mb25kby50cmltKCkgOiBcIlwiO1xuICByZXR1cm4gKFxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImh0dHBcIikgfHxcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fFxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImJsb2I6XCIpXG4gICk7XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJIVE1MRGVzZGVTZWNjaW9uZXMoXG4gIHNlY2Npb25lczogYW55W10sXG4gIG9iamV0b3M6IGFueVtdLFxuICByc3ZwPzogTW9kYWxDb25maWcsXG4gIG9wY2lvbmVzPzogR2VuZXJhckhUTUxPcGNpb25lcyxcclxuICBvcHRzPzogeyBzbHVnPzogc3RyaW5nIH1cclxuKTogc3RyaW5nIHtcbiAgY29uc3Qgc2x1ZyA9IG9wY2lvbmVzPy5zbHVnID8/IFwiXCI7XG4gIGNvbnN0IHNsdWdQdWJsaWNhID0gb3B0cz8uc2x1ZyA/PyBcIlwiO1xuXHJcbiAgY29uc3QgZnVlbnRlc1VzYWRhcyA9IFtcclxuICAgIC4uLm5ldyBTZXQoXHJcbiAgICAgIG9iamV0b3NcclxuICAgICAgICAuZmlsdGVyKChvKSA9PiAoby50aXBvID09PSBcInRleHRvXCIgfHwgby50aXBvID09PSBcImNvdW50ZG93blwiKSAmJiBvLmZvbnRGYW1pbHkpXHJcbiAgICAgICAgLm1hcCgobykgPT4gby5mb250RmFtaWx5KVxyXG4gICAgKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnb29nbGVGb250c0xpbmsgPSBidWlsZEdvb2dsZUZvbnRzTGluayhmdWVudGVzVXNhZGFzKTtcclxuXHJcbiAgY29uc3QgaGF5UlNWUEVuQ2FudmFzID0gb2JqZXRvcz8uc29tZSgobykgPT4gby50aXBvID09PSBcInJzdnAtYm90b25cIik7XHJcbiAgY29uc3QgYm90b25SU1ZQID0gXCJcIjsgLy8gKHNpIHF1ZXLDqXMgYWdyZWdhciB1biBib3TDs24gZmlqbyBmdWVyYSBkZWwgY2FudmFzLCBoYWNlbG8gYWPDoSlcclxuICBjb25zdCBtb2RhbFJTVlAgPSBoYXlSU1ZQRW5DYW52YXMgJiYgcnN2cD8uZW5hYmxlZCA/IGdlbmVyYXJNb2RhbFJTVlBIVE1MKHJzdnApIDogXCJcIjtcclxuICBjb25zdCBtb2RhbEdhbGVyaWEgPSBoYXlHYWxlcmlhQ29uSW1hZ2VuZXMob2JqZXRvcykgPyBnZW5lcmFyTW9kYWxHYWxlcmlhSFRNTCgpIDogXCJcIjtcclxuICBjb25zdCBpbnZpdGF0aW9uTG9hZGVyUnVudGltZSA9IGdlbmVyYXJJbnZpdGF0aW9uTG9hZGVyUnVudGltZUhUTUwoKTtcclxuICBjb25zdCBtb3Rpb25FZmZlY3RzUnVudGltZSA9IGdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwoKTtcclxuXHJcbiAgZnVuY3Rpb24gaGF5Q291bnRkb3duKG9ianM6IGFueVtdKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmpzKSAmJiBvYmpzLnNvbWUoKG8pID0+IG8/LnRpcG8gPT09IFwiY291bnRkb3duXCIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2NyaXB0Q291bnRkb3duID0gaGF5Q291bnRkb3duKG9iamV0b3MpXHJcbiAgICA/IGBcclxuPHNjcmlwdD5cclxuKGZ1bmN0aW9uKCl7XHJcbiAgZnVuY3Rpb24gcGFkKG4peyBuPU1hdGguZmxvb3IoTWF0aC5hYnMobikpOyByZXR1cm4gbjwxMCA/IFwiMFwiK24gOiBcIlwiK247IH1cclxuICBmdW5jdGlvbiBkaWZmUGFydHModGFyZ2V0KXtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgbXMgPSBNYXRoLm1heCgwLCB0YXJnZXQuZ2V0VGltZSgpIC0gbm93KTtcclxuICAgIGNvbnN0IGQgPSBNYXRoLmZsb29yKG1zIC8gODY0MDAwMDApOyBtcyAtPSBkKjg2NDAwMDAwO1xyXG4gICAgY29uc3QgaCA9IE1hdGguZmxvb3IobXMgLyAzNjAwMDAwKTsgIG1zIC09IGgqMzYwMDAwMDtcclxuICAgIGNvbnN0IG0gPSBNYXRoLmZsb29yKG1zIC8gNjAwMDApOyAgICBtcyAtPSBtKjYwMDAwO1xyXG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IobXMgLyAxMDAwKTtcclxuICAgIHJldHVybiB7IGQsIGgsIG0sIHMgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdGlja09uZShyb290KXtcclxuICAgIGNvbnN0IGlzbyA9IHJvb3QuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIik7XHJcbiAgICBpZighaXNvKSByZXR1cm47XHJcbiAgICBjb25zdCB0ID0gbmV3IERhdGUoaXNvKTtcclxuICAgIGlmKGlzTmFOKHQuZ2V0VGltZSgpKSkgcmV0dXJuO1xyXG4gICAgY29uc3QgcCA9IGRpZmZQYXJ0cyh0KTtcclxuICAgIGNvbnN0IHZhbHMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2QtdmFsXCIpO1xyXG4gICAgaWYodmFscyAmJiB2YWxzLmxlbmd0aCA+PSA0KXtcclxuICAgICAgdmFsc1swXS50ZXh0Q29udGVudCA9IFN0cmluZyhwLmQpLnBhZFN0YXJ0KDIsXCIwXCIpO1xyXG4gICAgICB2YWxzWzFdLnRleHRDb250ZW50ID0gcGFkKHAuaCk7XHJcbiAgICAgIHZhbHNbMl0udGV4dENvbnRlbnQgPSBwYWQocC5tKTtcclxuICAgICAgdmFsc1szXS50ZXh0Q29udGVudCA9IHBhZChwLnMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBib290KCl7XHJcbiAgICBjb25zdCByb290cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNvdW50ZG93bl1cIikpO1xyXG4gICAgaWYoIXJvb3RzLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgcm9vdHMuZm9yRWFjaCh0aWNrT25lKTtcclxuICAgIHNldEludGVydmFsKCgpID0+IHJvb3RzLmZvckVhY2godGlja09uZSksIDEwMDApO1xyXG4gIH1cclxuICBpZihkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIil7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBib290KTtcclxuICB9IGVsc2Uge1xyXG4gICAgYm9vdCgpO1xyXG4gIH1cclxufSkoKTtcclxuPC9zY3JpcHQ+XHJcbmAudHJpbSgpXHJcbiAgICA6IFwiXCI7XHJcblxyXG4gIGNvbnN0IHNlY2Npb25lc09yZGVuYWRhcyA9IFsuLi4oc2VjY2lvbmVzIHx8IFtdKV0uc29ydChcclxuICAgIChhLCBiKSA9PiAoTnVtYmVyKGE/Lm9yZGVuKSB8fCAwKSAtIChOdW1iZXIoYj8ub3JkZW4pIHx8IDApXHJcbiAgKTtcclxuXHJcblxyXG4gIGNvbnN0IGh0bWxTZWNjaW9uZXMgPSBzZWNjaW9uZXNPcmRlbmFkYXNcbiAgICAubWFwKChzZWNjaW9uKSA9PiB7XG4gICAgICBjb25zdCBtb2RvID0gU3RyaW5nKHNlY2Npb24/LmFsdG9Nb2RvIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaGJhc2UgPSBOdW1iZXIuaXNGaW5pdGUoc2VjY2lvbj8uYWx0dXJhKSA/IE51bWJlcihzZWNjaW9uLmFsdHVyYSkgOiA2MDA7XG4gICAgICBjb25zdCBmb25kb0VzSW1hZ2VuID0gaGFzSW1hZ2VCYWNrZ3JvdW5kKHNlY2Npb24pO1xuXHJcbiAgICAgIGNvbnN0IG9ianNEZVNlY2Npb24gPSBvYmpldG9zLmZpbHRlcigobykgPT4gby5zZWNjaW9uSWQgPT09IHNlY2Npb24uaWQpO1xyXG5cclxuICAgICAgY29uc3Qgb2Jqc0JsZWVkID0gb2Jqc0RlU2VjY2lvbi5maWx0ZXIoXHJcbiAgICAgICAgKG8pID0+IFN0cmluZyhvPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiZnVsbGJsZWVkXCJcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgb2Jqc0NvbnRlbmlkbyA9IG9ianNEZVNlY2Npb24uZmlsdGVyKFxyXG4gICAgICAgIChvKSA9PiBTdHJpbmcobz8uYW5jbGFqZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpICE9PSBcImZ1bGxibGVlZFwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBmb25kb1N0eWxlID0gYnVpbGRGb25kb1N0eWxlKHNlY2Npb24pO1xyXG5cclxuICAgICAgY29uc3QgaHRtbEJsZWVkID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0JsZWVkLCBzZWNjaW9uZXNPcmRlbmFkYXMpO1xyXG4gICAgICBjb25zdCBodG1sQ29udGVuaWRvID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0NvbnRlbmlkbywgc2VjY2lvbmVzT3JkZW5hZGFzKTtcclxuXHJcblxuICAgICAgcmV0dXJuIGBcbjxzZWN0aW9uIGNsYXNzPVwic2VjXCIgZGF0YS1tb2RvPVwiJHtlc2NhcGVBdHRyKG1vZG8pfVwiIGRhdGEtZm9uZG89XCIke2ZvbmRvRXNJbWFnZW4gPyBcImltYWdlblwiIDogXCJjb2xvclwifVwiIHN0eWxlPVwiLS1oYmFzZToke2hiYXNlfVwiPlxuICA8ZGl2IGNsYXNzPVwic2VjLXpvb21cIj5cbiAgICA8ZGl2IGNsYXNzPVwic2VjLWJnXCIgc3R5bGU9XCIke2ZvbmRvU3R5bGV9XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNlYy1ibGVlZFwiPiR7aHRtbEJsZWVkfTwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzZWMtY29udGVudFwiPiR7aHRtbENvbnRlbmlkb308L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5gLnRyaW0oKTtcclxuICAgIH0pXHJcbiAgICAuam9pbihcIlxcblwiKTtcclxuXHJcbiAgY29uc3Qgc2NyaXB0TW9iaWxlU21hcnQgPSBidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCh7XHJcbiAgICBlbmFibGVkOiBFTkFCTEVfTU9CSUxFX1NNQVJUX0xBWU9VVCxcclxuICAgIG1pbkdhcFB4OiAxLFxyXG4gICAgcGFkZGluZ1RvcFB4OiAwLFxyXG4gICAgcGFkZGluZ0JvdHRvbVB4OiAyLFxyXG4gICAgb25seUZpeGVkU2VjdGlvbnM6IHRydWUsXHJcbiAgICBtaW5QZXJDb2x1bW4yOiAxLFxyXG4gICAgZml0TWluU2NhbGU6IDAuODgsXHJcbiAgICBmaXRNYXhTY2FsZTogMS4xNixcclxuICAgIGZpdFRhcmdldFdpZHRoUmF0aW86IDAuOTQsXHJcbiAgICBmaXRNaW5GaWxsUmF0aW86IDAuOSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGBcclxuPCFET0NUWVBFIGh0bWw+XG48aHRtbCBsYW5nPVwiZXNcIiR7c2x1ZyA/IGAgZGF0YS1zbHVnPVwiJHtlc2NhcGVBdHRyKHNsdWcpfVwiYCA6IFwiXCJ9PlxuPGhlYWQ+XG4gIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiIC8+XHJcbiAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIHZpZXdwb3J0LWZpdD1jb3ZlclwiIC8+XHJcbiAgPHRpdGxlPkludml0YWNpw7NuPC90aXRsZT5cclxuICAke2dvb2dsZUZvbnRzTGlua31cclxuICA8c3R5bGU+XHJcbiAgICAqIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyB9XHJcblxyXG4gICAgaHRtbCwgYm9keSB7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICBvdmVyZmxvdy14OiBoaWRkZW47XHJcbiAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBTT0xPIE1PQklMRTogZXZpdGEg4oCcYXV0by1yZXNpemUgLyBmb250IGJvb3N0aW5n4oCdIGRlbCB0ZXh0byAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgaHRtbHtcclxuICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XHJcbiAgICAgICAgdGV4dC1zaXplLWFkanVzdDogMTAwJTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICA6cm9vdHsgLS10ZXh0LXpvb206IDE7IH1cbiAgICB9XHJcblxyXG4gICAgOnJvb3R7XHJcbiAgICAgIC0tc2FmZS10b3A6IGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtcmlnaHQ6IGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweCk7XHJcbiAgICAgIC0tc2FmZS1ib3R0b206IGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtbGVmdDogZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpO1xyXG4gICAgICAtLWJwLW1vYmlsZTogNzY3cHg7XHJcbiAgICAgIFxyXG5cclxuXHJcbiAgICAgIC8qIEdsb2JhbCBzY2FsZXMgKi9cclxuICAgICAgLS1jb250ZW50LXc6ICR7Q0FOVkFTX0JBU0UuQU5DSE99cHg7XHJcbiAgICAgIC0tc3g6IDE7ICAgLyogY29udGVudFcvODAwICovXHJcbiAgICAgIC0tYng6IDE7ICAgLyogdmlld3BvcnRXLzgwMCAqL1xyXG5cclxuICAgICAgLyogdmggbMOzZ2ljbyBwb3IgZGVmZWN0byAqL1xyXG4gICAgICAtLXZoLXNhZmU6IDEwMHZoO1xuICAgICAgLS12aC1sb2dpY2FsOiB2YXIoLS12aC1zYWZlKTtcbiAgICAgIC0tcGFudGFsbGEteS1jb21wYWN0OiAwO1xuICAgICAgLS1wYW50YWxsYS15LWJhc2U6IDBweDtcblxyXG4gICAgICAvKiDinIUgT2Zmc2V0IFNPTE8gcGFyYSB0ZXh0byBlbiBQYW50YWxsYTogT04gKGRlc2t0b3AgZGVmYXVsdCkgKi9cclxuICAgICAgLS1wYW50YWxsYS15LW9mZnNldDogJHtQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYfXB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBNb2JpbGU6IG9mZnNldCBkaXN0aW50byBTT0xPIHBhcmEgdGV4dG8gZW4gUGFudGFsbGE6IE9OICovXHJcbiAgICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpe1xyXG4gICAgICA6cm9vdHtcclxuICAgICAgICAtLXBhbnRhbGxhLXktb2Zmc2V0OiAke1BBTlRBTExBX1lfT0ZGU0VUX01PQklMRV9QWH1weDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5pbnZ7IHdpZHRoOiAxMDAlOyBiYWNrZ3JvdW5kOiB3aGl0ZTsgfVxyXG5cclxuICAgIC5zZWN7XHJcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgd2lkdGg6IDEwMHZ3O1xyXG4gICAgICBsZWZ0OiA1MCU7XHJcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIGJsZWVkIHB1ZWRlIHNhbGlyc2UgKi9cclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgV3JhcHBlciBxdWUgaGFjZSDigJx6b29t4oCdIGNlbnRyYWRvIChldml0YSBjb3JyaW1pZW50byBhIGxhIGRlcmVjaGEpICovXHJcbiAgICAuc2VjLXpvb217XHJcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIGNlbnRlcjtcclxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS16b29tLCAxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiByZWNvcnRlIHBhcmEgcXVlIGVsIHpvb20gbm8gZGVzYm9yZGUgKi9cclxuICAgIC5zZWNbZGF0YS1tb2RvPVwicGFudGFsbGFcIl17XHJcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgIGhlaWdodDogMTAwZHZoO1xyXG4gICAgICBoZWlnaHQ6IDEwMHZoO1xyXG4gICAgICBwYWRkaW5nLXRvcDogdmFyKC0tc2FmZS10b3ApO1xyXG4gICAgICBwYWRkaW5nLWJvdHRvbTogdmFyKC0tc2FmZS1ib3R0b20pO1xyXG5cclxuICAgICAgLyogZmFsbGJhY2sgQ1NTIChKUyBsbyBwaXNhIGVuIG1vYmlsZSBjb24gcHggcmVhbGVzKSAqL1xyXG4gICAgICAtLXZoLXNhZmU6IGNhbGMoMTAwZHZoIC0gdmFyKC0tc2FmZS10b3ApIC0gdmFyKC0tc2FmZS1ib3R0b20pKTtcclxuXHJcbiAgICAgIC8qIGVsIHpvb20gZXh0cmEgdmEgcG9yIC0tem9vbSAoTk8gcG9yIHNmaW5hbCkgKi9cclxuICAgICAgLS16b29tOiAxO1xyXG4gICAgICAtLWJnem9vbTogMTtcclxuXHJcbiAgICAgIC8qIGZhY3RvciBmaW5hbCBwYXJhIENPTlRFTklETyAoc2Ugc2V0ZWEgcG9yIEpTKSAqL1xyXG4gICAgICAtLXNmaW5hbDogMTtcclxuICAgIH1cclxuXHJcbiAgICAuc2VjW2RhdGEtbW9kbz1cImZpam9cIl17XHJcbiAgICAgIC8qIGFsdHVyYSBmaWphIGVzY2FsYWRhIHBvciBhbmNobzsgSlMgc2V0ZWEgLS1zZmluYWwgPSBzeCAqL1xyXG4gICAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2ZpbmFsKSAqIHZhcigtLWhiYXNlKSAqIDFweCk7XHJcbiAgICAgIC0tem9vbTogMTtcclxuICAgICAgLS1iZ3pvb206IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyogRm9uZG8gKi9cclxuICAgIC5zZWMtYmd7XHJcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgaW5zZXQ6IDA7XHJcbiAgICAgIHotaW5kZXg6IDA7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBGb25kbyBhZ3JhbmRhYmxlIHNvbG8gZW4gcGFudGFsbGEgKGFjb21wYcOxYSBlbCB6b29tIGhlcm8pICovXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWJne1xuICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1iZ3pvb20sIDEpKTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgICB9XG5cbiAgICAvKiDinIUgRW4gZm9uZG9zIGRlIGltYWdlbiwgY29tcGVuc2Ftb3MgZGVzZGUgZWwgbWlzbW8gb3JpZ2VuIHF1ZSBlbCB3cmFwcGVyICovXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXVtkYXRhLWZvbmRvPVwiaW1hZ2VuXCJdIC5zZWMtYmd7XG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgY2VudGVyO1xuICAgIH1cblxyXG4gICAgLnNlYy1ibGVlZHtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICBpbnNldDogMDtcclxuICAgICAgei1pbmRleDogMjtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5zZWMtY29udGVudHtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICB6LWluZGV4OiAzO1xyXG4gICAgICB3aWR0aDogdmFyKC0tY29udGVudC13KTtcclxuICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiBlbCBhbmNobyBkZWwg4oCcY29udGVudOKAnSBwdWVkZSBjcmVjZXIgY29uIGxhIGVzY2FsYSB2ZXJ0aWNhbCAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWNvbnRlbnR7XHJcbiAgICAgIHdpZHRoOiB2YXIoLS1jb250ZW50LXctcGFudGFsbGEsIHZhcigtLWNvbnRlbnQtdykpO1xyXG4gICAgfVxyXG5cclxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCl7XHJcbiAgICAgIC5zZWMtY29udGVudHtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNhZmUtbGVmdCk7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2FmZS1yaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAub2JqZXRve1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0b1tkYXRhLWRlYnVnLXRleHRvPVwiMVwiXXtcclxuICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XHJcbiAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0by5pcy1pbnRlcmFjdGl2ZXsgcG9pbnRlci1ldmVudHM6IGF1dG87IH1cclxuXHJcbiAgICAuY2QtY2hpcCB7IGJhY2tkcm9wLWZpbHRlcjogc2F0dXJhdGUoMS4xKTsgfVxyXG4gIDwvc3R5bGU+XHJcbjwvaGVhZD5cclxuXHJcbjxib2R5IGRhdGEtbG9hZGVyLXJlYWR5PVwiMFwiIGRhdGEtc2x1Zz1cIiR7ZXNjYXBlQXR0cihzbHVnUHVibGljYSl9XCI+XHJcbiAgJHtpbnZpdGF0aW9uTG9hZGVyUnVudGltZX1cclxuICA8ZGl2IGNsYXNzPVwiaW52XCI+XHJcbiAgICAke2h0bWxTZWNjaW9uZXN9XHJcbiAgPC9kaXY+XHJcblxyXG4gICR7Ym90b25SU1ZQfVxyXG4gICR7bW9kYWxSU1ZQfVxyXG4gICR7bW9kYWxHYWxlcmlhfVxyXG4gICR7bW90aW9uRWZmZWN0c1J1bnRpbWV9XHJcblxyXG4gICR7c2NyaXB0Q291bnRkb3dufVxyXG5cclxuICA8c2NyaXB0PlxyXG4gICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZ1bmN0aW9uIGNsYW1wKG4sIGEsIGIpeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgbikpOyB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wdXRlKCl7XHJcbiAgICAgICAgdmFyIHZ3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBCQVNFX1cgPSA4MDA7IC8vID0gQ0FOVkFTX0JBU0UuQU5DSE9cclxuXHJcbiAgICAgICAgLy8gY29udGVudFcgKHNpbiB2dy0zMilcclxuICAgICAgICB2YXIgY29udGVudFcgPSBNYXRoLm1pbihCQVNFX1csIHZ3KTtcclxuXHJcbiAgICAgICAgdmFyIHN4ID0gY29udGVudFcgLyBCQVNFX1c7XHJcbiAgICAgICAgdmFyIGJ4ID0gdncgLyBCQVNFX1c7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tY29udGVudC13XCIsIGNvbnRlbnRXICsgXCJweFwiKTtcclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXN4XCIsIFN0cmluZyhzeCkpO1xyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYnhcIiwgU3RyaW5nKGJ4KSk7XHJcblxyXG4gICAgICAgIHZhciBzZWNzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSk7XHJcbiAgICAgICAgdmFyIGlzTW9iaWxlID0gdncgPD0gNzY3O1xyXG5cclxuICAgICAgICAvLyB2aWV3cG9ydCByZWFsIChtw6FzIGVzdGFibGUgZW4gbW9iaWxlKVxyXG4gICAgICAgIHZhciB2diA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcclxuICAgICAgICB2YXIgdmlld3BvcnRIID0gKHZ2ICYmIHZ2LmhlaWdodCkgPyB2di5oZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHNhZmUgYXJlYXMgKGNzcyBlbnYpXHJcbiAgICAgICAgdmFyIHNhZmVUb3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zYWZlLXRvcFwiKSkgfHwgMDtcclxuICAgICAgICB2YXIgc2FmZUJvdHRvbSA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCItLXNhZmUtYm90dG9tXCIpKSB8fCAwO1xyXG5cclxuICAgICAgICAvLyBkaXNlw7FvIGJhc2UgZGVsIG1vZG8gXCJwYW50YWxsYVwiICg4MDAgeCA1MDApXHJcbiAgICAgICAgdmFyIERFU0lHTl9XID0gQkFTRV9XO1xyXG4gICAgICAgIHZhciBERVNJR05fSCA9ICR7QUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEF9OyAvLyA9IEFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBXHJcbiAgICAgICAgdmFyIGRlc2lnbkFSID0gREVTSUdOX0ggLyBERVNJR05fVzsgLy8gMC42MjVcclxuICAgICAgICB2YXIgZGV2aWNlQVIgPSB2aWV3cG9ydEggLyB2dztcclxuXHJcbiAgICAgICAgLy8gem9vbSBleHRyYSAoc29sbyBzaSBlbCBkZXZpY2UgZXMgbcOhcyB2ZXJ0aWNhbCBxdWUgZWwgZGlzZcOxbylcclxuICAgICAgICB2YXIgem9vbUV4dHJhID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGUgJiYgZGV2aWNlQVIgPiBkZXNpZ25BUil7XHJcbiAgICAgICAgICB2YXIgayA9IGRldmljZUFSIC8gZGVzaWduQVI7XHJcbiAgICAgICAgICB6b29tRXh0cmEgPSBjbGFtcCgxICsgKGsgLSAxKSAqIDAuMTgsIDEsIDEuMzUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g8J+UpyBBanVzdGUgZmlubzogY3XDoW50byBtYW50aWVuZSBlbCB6b29tIHZpc3VhbCBkZWwgZm9uZG8gZW4gbW9iaWxlL3BhbnRhbGxhLlxuICAgICAgICAvLyAwICAgPT4gZWwgZm9uZG8gc2UgY29tcGVuc2EgcGFyYSB2ZXJzZSBzaW1pbGFyIGEgZGVza3RvcC5cbiAgICAgICAgLy8gMSAgID0+IGNvbXBvcnRhbWllbnRvIGFudGVyaW9yIChmb25kbyBhY29tcGHDsWEgY29tcGxldG8gZWwgem9vbSBkZWwgaGVybykuXG4gICAgICAgIC8vIDAuMyA9PiBjb21wZW5zYWNpw7NuIHBhcmNpYWwuXG4gICAgICAgIHZhciBCR19aT09NX0ZBQ1RPUiA9IDA7XG5cclxuICAgICAgICAvLyDwn5SnIEFqdXN0ZSBmaW5vOiBjdcOhbnRvIGFjb21wYcOxYSBlbCBDT05URU5JRE8gKHRleHRvL29iamV0b3MpIGFsIHpvb20gaGVyb1xyXG4gICAgICAgIC8vIDAgICA9PiBjb21wb3J0YW1pZW50byBhY3R1YWxcclxuICAgICAgICAvLyAwLjMgPT4gcmVjb21lbmRhZG9cclxuICAgICAgICAvLyAxICAgPT4gdGV4dG8gZXNjYWxhIGlndWFsIHF1ZSBlbCBoZXJvIChubyBhY29uc2VqYWRvKVxyXG4gICAgICAgIHZhciBURVhUX1pPT01fRkFDVE9SID0gMDtcclxuXHJcblxyXG4gICAgICAgIHNlY3MuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgICAgIHZhciBtb2RvID0gKHNlYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZG9cIikgfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGZvbmRvVGlwbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1mb25kb1wiKSB8fCBcImNvbG9yXCIpLnRvTG93ZXJDYXNlKCk7XG5cclxuICAgICAgICAgIC8vIGRlZmF1bHRzXHJcbiAgICAgICAgICB2YXIgem9vbSA9IDE7XHJcbiAgICAgICAgICB2YXIgYmd6b29tID0gMTtcclxuXHJcbiAgICAgICAgICAvLyDinIUgUG9yIGRlZmVjdG8sIHRhbWHDsW9zIGVzY2FsYW4gcG9yIGFuY2hvIChjb21wb3J0YW1pZW50byBhY3R1YWwpXG4gICAgICAgICAgdmFyIHNmaW5hbCA9IHN4O1xuICAgICAgICAgIHZhciBwYW50YWxsYVlDb21wYWN0ID0gMDtcbiAgICAgICAgICB2YXIgcGFudGFsbGFZQmFzZVB4ID0gMDtcblxyXG4gICAgICAgICAgLy8gbGltcGlhciBjdXN0b20gd2lkdGggc2kgbm8gYXBsaWNhXHJcbiAgICAgICAgICBzZWMuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLWNvbnRlbnQtdy1wYW50YWxsYVwiKTtcclxuXHJcbiAgICAgICAgICBpZiAobW9kbyA9PT0gXCJwYW50YWxsYVwiKXtcclxuICAgICAgICAgICAgLy8gdmgtc2FmZSByZWFsIGVuIHB4XHJcbiAgICAgICAgICAgIHZhciB2aFNhZmVQeCA9IE1hdGgubWF4KDAsIHZpZXdwb3J0SCAtIHNhZmVUb3AgLSBzYWZlQm90dG9tKTtcclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1zYWZlXCIsIHZoU2FmZVB4ICsgXCJweFwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIPCflKUgRGVza3RvcDogZXNjYWxhciBlbCBjb250ZW5pZG8gcG9yIEFMVFVSQSAodmhTYWZlLzUwMClcclxuICAgICAgICAgICAgLy8gRXN0byBhbGluZWEgZWwgSFRNTCBwdWJsaWNhZG8gY29uIGxvIHF1ZSB2ZXMgZW4gcHJldmlld1xyXG4gICAgICAgICAgICBpZiAoIWlzTW9iaWxlKXtcclxuICAgICAgICAgICAgICB2YXIgc2ggPSB2aFNhZmVQeCAvIERFU0lHTl9IO1xyXG4gICAgICAgICAgICAgIHNmaW5hbCA9IHNoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwYXJhIHF1ZSBlbCBcImNvbnRlbnRcIiBxdWVkZSBjZW50cmFkbyB5IGNvaGVyZW50ZSBjb24gbGEgbnVldmEgZXNjYWxhIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1jb250ZW50LXctcGFudGFsbGFcIiwgKERFU0lHTl9XICogc2gpICsgXCJweFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIE1vYmlsZTogbWFudGVuZW1vcyB0dSBjb21wb3J0YW1pZW50byBhY3R1YWwgKHpvb20gaGVybyBzdWF2ZSlcbiAgICAgICAgICAgIGlmIChpc01vYmlsZSl7XG4gICAgICAgICAgICAgIHpvb20gPSB6b29tRXh0cmE7XG4gICAgICAgICAgICAgIHZhciBiZ1Zpc3VhbFpvb20gPSAxICsgKHpvb21FeHRyYSAtIDEpICogQkdfWk9PTV9GQUNUT1I7XG4gICAgICAgICAgICAgIGlmIChmb25kb1RpcG8gPT09IFwiaW1hZ2VuXCIpIHtcbiAgICAgICAgICAgICAgICBiZ3pvb20gPSBiZ1Zpc3VhbFpvb20gLyBNYXRoLm1heCgwLjAxLCB6b29tKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZ3pvb20gPSBiZ1Zpc3VhbFpvb207XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyDwn5SlIE5VRVZPOiBlbCBjb250ZW5pZG8gYWNvbXBhw7FhIHBhcmNpYWxtZW50ZSBlbCB6b29tXG4gICAgICAgICAgICAgIHNmaW5hbCA9IHN4ICogKDEgKyAoem9vbUV4dHJhIC0gMSkgKiBURVhUX1pPT01fRkFDVE9SKTtcblxyXG4gICAgICAgICAgICAgIC8vIOKchSBGaWRlbGl0eSBkZSBkaXNlw7FvIGVuIFBhbnRhbGxhOk9OOlxuICAgICAgICAgICAgICAvLyBubyBjb21wYWN0YW1vcyBkaXN0YW5jaWFzIHZlcnRpY2FsZXMgcGFyYSByZXNwZXRhciBwb3NpY2lvbmVzXG4gICAgICAgICAgICAgIC8vIGludGVuY2lvbmFsZXMgKGluY2x1eWVuZG8gdGV4dG9zIGVuY2ltYWRvcyBvIG11eSBjZXJjYW5vcykuXG4gICAgICAgICAgICAgIHBhbnRhbGxhWUNvbXBhY3QgPSAwO1xuXG4gICAgICAgICAgICAgIC8vIOKchSBBanVzdGUgZGUgcG9zaWNpw7NuIHZlcnRpY2FsIGdsb2JhbCAodW5pZm9ybWUpOlxuICAgICAgICAgICAgICAvLyBkZXNwbGF6YW1vcyBUT0RPIGVsIGJsb3F1ZSBwb3IgaWd1YWwgcGFyYSBubyBhbHRlcmFyIHBvc2ljaW9uZXMgcmVsYXRpdmFzLlxuICAgICAgICAgICAgICB2YXIgdmhMb2dpY2FsUHggPSB2aFNhZmVQeCAvIE1hdGgubWF4KDAuMDEsIHpvb20gfHwgMSk7XG4gICAgICAgICAgICAgIHZhciBkZXNpZ25TY2FsZWRIUHggPSBzZmluYWwgKiBERVNJR05fSDtcbiAgICAgICAgICAgICAgdmFyIHNwYXJlVmVydGljYWxQeCA9IE1hdGgubWF4KDAsIHZoTG9naWNhbFB4IC0gZGVzaWduU2NhbGVkSFB4KTtcbiAgICAgICAgICAgICAgcGFudGFsbGFZQmFzZVB4ID0gc3BhcmVWZXJ0aWNhbFB4ICogMC4zNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cclxuICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tc2ZpbmFsXCIsIFN0cmluZyhzZmluYWwpKTtcclxuICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tem9vbVwiLCBTdHJpbmcoem9vbSkpO1xyXG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1iZ3pvb21cIiwgU3RyaW5nKGJnem9vbSkpO1xyXG5cclxuICAgICAgICAgIC8vIOKchSBTb2xvIGVuIG1vYmlsZSArIHBhbnRhbGxhOiBjb3JyZWdpciBlbCBcInZoXCIgcXVlIGRlc3B1w6lzIHNlIGVzY2FsYSBjb24gem9vbVxyXG4gICAgICAgICAgaWYgKGlzTW9iaWxlICYmIG1vZG8gPT09IFwicGFudGFsbGFcIikge1xyXG4gICAgICAgICAgICAvLyAtLXZoLWxvZ2ljYWwgPSAtLXZoLXNhZmUgLyAtLXpvb21cclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1sb2dpY2FsXCIsIFwiY2FsYyh2YXIoLS12aC1zYWZlKSAvIHZhcigtLXpvb20pKVwiKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlc3RvOiBzZSBjb21wb3J0YSBjb21vIHNpZW1wcmVcclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1sb2dpY2FsXCIsIFwidmFyKC0tdmgtc2FmZSlcIik7XHJcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1wYW50YWxsYS15LWNvbXBhY3RcIiwgU3RyaW5nKHBhbnRhbGxhWUNvbXBhY3QpKTtcbiAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXBhbnRhbGxhLXktYmFzZVwiLCBwYW50YWxsYVlCYXNlUHggKyBcInB4XCIpO1xuICAgICAgICB9KTtcblxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXB1dGUpO1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjb21wdXRlKTtcclxuXHJcbiAgICAgIGlmICh3aW5kb3cudmlzdWFsVmlld3BvcnQpe1xyXG4gICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNvbXB1dGUpO1xyXG4gICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGNvbXB1dGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgc2V0VGltZW91dChjb21wdXRlLCA1MCk7XHJcbiAgICAgICAgc2V0VGltZW91dChjb21wdXRlLCAyNTApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbXB1dGUoKTtcclxuICAgIH0pKCk7XHJcbiAgPC9zY3JpcHQ+XHJcblxyXG4gICAgXHJcblxyXG5cclxuICAgJHtzY3JpcHRNb2JpbGVTbWFydH1cclxuIFxyXG48L2JvZHk+XHJcbjwvaHRtbD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MiLCJDQU5WQVNfQkFTRSIsImdlbmVyYXJNb2RhbFJTVlBIVE1MIiwiZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwiLCJoYXlHYWxlcmlhQ29uSW1hZ2VuZXMiLCJidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCIsImdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwiLCJnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIiwiRU5BQkxFX01PQklMRV9TTUFSVF9MQVlPVVQiLCJFWENMVURFX0ZPTlRTIiwiU2V0IiwiQUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEEiLCJQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYIiwiUEFOVEFMTEFfWV9PRkZTRVRfTU9CSUxFX1BYIiwiYnVpbGRHb29nbGVGb250c0xpbmsiLCJmb250cyIsImZhbWlsaWFzIiwibWFwIiwiZiIsInJlcGxhY2UiLCJzcGxpdCIsInRyaW0iLCJmaWx0ZXIiLCJuIiwiaGFzIiwiam9pbiIsImVzY2FwZUF0dHIiLCJzdHIiLCJTdHJpbmciLCJidWlsZEZvbmRvU3R5bGUiLCJzZWNjaW9uIiwiZm9uZG9WYWx1ZSIsImZvbmRvIiwiZXNJbWFnZW5Gb25kbyIsImZvbmRvVGlwbyIsImZvbmRvSW1hZ2VuIiwiZXN0aWxvc0ZvbmRvIiwiaW1hZ2VVcmwiLCJpbmNsdWRlcyIsImJhY2tncm91bmRQb3NpdGlvbiIsImZvbmRvSW1hZ2VuT2Zmc2V0WCIsInVuZGVmaW5lZCIsImZvbmRvSW1hZ2VuT2Zmc2V0WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwib2Zmc2V0WFBlcmNlbnQiLCJvZmZzZXRZUGVyY2VudCIsInN0YXJ0c1dpdGgiLCJoYXNJbWFnZUJhY2tncm91bmQiLCJnZW5lcmFySFRNTERlc2RlU2VjY2lvbmVzIiwic2VjY2lvbmVzIiwib2JqZXRvcyIsInJzdnAiLCJvcGNpb25lcyIsIm9wdHMiLCJzbHVnIiwic2x1Z1B1YmxpY2EiLCJmdWVudGVzVXNhZGFzIiwibyIsInRpcG8iLCJmb250RmFtaWx5IiwiZ29vZ2xlRm9udHNMaW5rIiwiaGF5UlNWUEVuQ2FudmFzIiwic29tZSIsImJvdG9uUlNWUCIsIm1vZGFsUlNWUCIsImVuYWJsZWQiLCJtb2RhbEdhbGVyaWEiLCJpbnZpdGF0aW9uTG9hZGVyUnVudGltZSIsIm1vdGlvbkVmZmVjdHNSdW50aW1lIiwiaGF5Q291bnRkb3duIiwib2JqcyIsIkFycmF5IiwiaXNBcnJheSIsInNjcmlwdENvdW50ZG93biIsInNlY2Npb25lc09yZGVuYWRhcyIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm9yZGVuIiwiaHRtbFNlY2Npb25lcyIsIm1vZG8iLCJhbHRvTW9kbyIsInRvTG93ZXJDYXNlIiwiaGJhc2UiLCJpc0Zpbml0ZSIsImFsdHVyYSIsImZvbmRvRXNJbWFnZW4iLCJvYmpzRGVTZWNjaW9uIiwic2VjY2lvbklkIiwiaWQiLCJvYmpzQmxlZWQiLCJhbmNsYWplIiwib2Jqc0NvbnRlbmlkbyIsImZvbmRvU3R5bGUiLCJodG1sQmxlZWQiLCJodG1sQ29udGVuaWRvIiwic2NyaXB0TW9iaWxlU21hcnQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm9ubHlGaXhlZFNlY3Rpb25zIiwibWluUGVyQ29sdW1uMiIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGUiLCJmaXRUYXJnZXRXaWR0aFJhdGlvIiwiZml0TWluRmlsbFJhdGlvIiwiQU5DSE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarHTMLDesdeSecciones.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarInvitationLoaderRuntime.ts":
/*!***************************************************************!*\
  !*** ./functions/src/utils/generarInvitationLoaderRuntime.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarInvitationLoaderRuntimeHTML: () => (/* binding */ generarInvitationLoaderRuntimeHTML)\n/* harmony export */ });\nfunction generarInvitationLoaderRuntimeHTML() {\n    return `\n<style>\n  body[data-loader-ready=\"0\"] {\n    overflow: hidden;\n  }\n\n  body[data-loader-ready=\"0\"] .inv {\n    opacity: 0;\n  }\n\n  body[data-loader-ready=\"1\"] .inv {\n    opacity: 1;\n    transition: opacity 360ms ease;\n  }\n\n  .inv-loader {\n    position: fixed;\n    inset: 0;\n    z-index: 9999;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 18px;\n    background:\n      radial-gradient(120% 90% at 80% 20%, rgba(255, 223, 236, 0.42) 0%, rgba(255, 223, 236, 0) 62%),\n      radial-gradient(120% 90% at 14% 82%, rgba(239, 208, 255, 0.34) 0%, rgba(239, 208, 255, 0) 66%),\n      linear-gradient(180deg, #fffafc 0%, #fff 100%);\n    transition: opacity 420ms ease, visibility 420ms ease;\n  }\n\n  .inv-loader--exit {\n    opacity: 0;\n    visibility: hidden;\n    pointer-events: none;\n  }\n\n  .inv-loader__stage {\n    position: relative;\n    width: 112px;\n    height: 112px;\n    display: grid;\n    place-items: center;\n  }\n\n  .inv-loader__halo {\n    position: absolute;\n    inset: 10px;\n    border-radius: 999px;\n    background: radial-gradient(circle, rgba(255, 255, 255, 0.98) 0%, rgba(249, 206, 224, 0.74) 56%, rgba(244, 175, 204, 0.28) 100%);\n    box-shadow:\n      0 12px 30px rgba(230, 123, 168, 0.24),\n      inset 0 0 0 1px rgba(255, 255, 255, 0.64);\n    animation: invLoaderHalo 2.3s ease-in-out infinite;\n  }\n\n  .inv-loader__ring {\n    position: absolute;\n    inset: 0;\n    border-radius: 999px;\n    border: 2px solid rgba(221, 126, 165, 0.2);\n    border-top-color: rgba(211, 70, 130, 0.84);\n    border-right-color: rgba(233, 145, 179, 0.58);\n    animation: invLoaderSpin 1.15s linear infinite;\n  }\n\n  .inv-loader__heart {\n    width: 34px;\n    height: 34px;\n    display: block;\n    animation: invLoaderBeat 1.4s ease-in-out infinite;\n  }\n\n  .inv-loader__heart-svg {\n    width: 100%;\n    height: 100%;\n    display: block;\n  }\n\n  .inv-loader__heart-path {\n    fill: none;\n    stroke: #cf4f89;\n    stroke-width: 2.15;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    filter: drop-shadow(0 3px 8px rgba(216, 61, 124, 0.18));\n  }\n\n  .inv-loader__label {\n    margin: 0;\n    font-family: \"Playfair Display\", Georgia, serif;\n    font-size: 16px;\n    letter-spacing: 0.2px;\n    color: #6d2a53;\n    text-align: center;\n  }\n\n  @keyframes invLoaderSpin {\n    to {\n      transform: rotate(360deg);\n    }\n  }\n\n  @keyframes invLoaderHalo {\n    0%, 100% {\n      transform: scale(0.98);\n      opacity: 0.86;\n    }\n    50% {\n      transform: scale(1.02);\n      opacity: 1;\n    }\n  }\n\n  @keyframes invLoaderBeat {\n    0%, 100% {\n      transform: rotate(-45deg) scale(1);\n    }\n    42% {\n      transform: rotate(-45deg) scale(1.12);\n    }\n    64% {\n      transform: rotate(-45deg) scale(0.98);\n    }\n  }\n\n  @media (max-width: 767px) {\n    .inv-loader__stage {\n      width: 96px;\n      height: 96px;\n    }\n\n    .inv-loader__heart {\n      width: 30px;\n      height: 30px;\n    }\n\n    .inv-loader__label {\n      font-size: 14px;\n    }\n  }\n\n  @media (prefers-reduced-motion: reduce) {\n    .inv-loader__halo,\n    .inv-loader__ring,\n    .inv-loader__heart {\n      animation: none !important;\n    }\n  }\n</style>\n\n<div id=\"inv-loader\" class=\"inv-loader\" role=\"status\" aria-live=\"polite\" aria-label=\"Cargando invitacion\">\n  <div class=\"inv-loader__stage\">\n    <span class=\"inv-loader__halo\" aria-hidden=\"true\"></span>\n    <span class=\"inv-loader__ring\" aria-hidden=\"true\"></span>\n    <span class=\"inv-loader__heart\" aria-hidden=\"true\">\n      <svg class=\"inv-loader__heart-svg\" viewBox=\"0 0 24 24\" aria-hidden=\"true\" focusable=\"false\">\n        <path\n          class=\"inv-loader__heart-path\"\n          d=\"M12 20.2c-.2 0-.4-.1-.5-.2C8.5 17.4 3 13.3 3 8.5 3 5.8 5.1 3.8 7.7 3.8c1.6 0 3.1.8 4.1 2.2 1-1.4 2.5-2.2 4.1-2.2C18.5 3.8 20.6 5.8 20.6 8.5c0 4.8-5.5 8.9-8.5 11.5-.1.1-.3.2-.5.2z\"\n        />\n      </svg>\n    </span>\n  </div>\n  <p class=\"inv-loader__label\">Preparando invitacion...</p>\n</div>\n\n<script>\n(function(){\n  var RUNTIME_READY_EVENT = \"invitation-runtime-ready\";\n  var RUNTIME_FAIL_EVENT = \"invitation-runtime-failed\";\n  var LOADER_HIDDEN_EVENT = \"invitation-loader-hidden\";\n  var MAX_WAIT_MS = 10000;\n  var closed = false;\n\n  function dispatchLoaderEvent(name){\n    try {\n      window.dispatchEvent(new CustomEvent(name));\n    } catch (_error) {\n      // noop\n    }\n  }\n\n  function closeLoader(){\n    if (closed) return;\n    closed = true;\n\n    if (document.body) {\n      document.body.setAttribute(\"data-loader-ready\", \"1\");\n    }\n\n    var loader = document.getElementById(\"inv-loader\");\n    if (!loader) return;\n\n    loader.classList.add(\"inv-loader--exit\");\n    window.setTimeout(function(){\n      if (loader.parentNode) {\n        loader.parentNode.removeChild(loader);\n      }\n      dispatchLoaderEvent(LOADER_HIDDEN_EVENT);\n    }, 520);\n  }\n\n  function armEvents(){\n    if (document.body) {\n      document.body.setAttribute(\"data-loader-ready\", \"0\");\n    }\n\n    window.addEventListener(RUNTIME_READY_EVENT, closeLoader, { once: true });\n    window.addEventListener(RUNTIME_FAIL_EVENT, closeLoader, { once: true });\n\n    window.setTimeout(closeLoader, MAX_WAIT_MS);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", armEvents, { once: true });\n  } else {\n    armEvents();\n  }\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2TlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG48c3R5bGU+XG4gIGJvZHlbZGF0YS1sb2FkZXItcmVhZHk9XCIwXCJdIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICB9XG5cbiAgYm9keVtkYXRhLWxvYWRlci1yZWFkeT1cIjBcIl0gLmludiB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuXG4gIGJvZHlbZGF0YS1sb2FkZXItcmVhZHk9XCIxXCJdIC5pbnYge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAzNjBtcyBlYXNlO1xuICB9XG5cbiAgLmludi1sb2FkZXIge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBpbnNldDogMDtcbiAgICB6LWluZGV4OiA5OTk5O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGdhcDogMThweDtcbiAgICBiYWNrZ3JvdW5kOlxuICAgICAgcmFkaWFsLWdyYWRpZW50KDEyMCUgOTAlIGF0IDgwJSAyMCUsIHJnYmEoMjU1LCAyMjMsIDIzNiwgMC40MikgMCUsIHJnYmEoMjU1LCAyMjMsIDIzNiwgMCkgNjIlKSxcbiAgICAgIHJhZGlhbC1ncmFkaWVudCgxMjAlIDkwJSBhdCAxNCUgODIlLCByZ2JhKDIzOSwgMjA4LCAyNTUsIDAuMzQpIDAlLCByZ2JhKDIzOSwgMjA4LCAyNTUsIDApIDY2JSksXG4gICAgICBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCAjZmZmYWZjIDAlLCAjZmZmIDEwMCUpO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgNDIwbXMgZWFzZSwgdmlzaWJpbGl0eSA0MjBtcyBlYXNlO1xuICB9XG5cbiAgLmludi1sb2FkZXItLWV4aXQge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX3N0YWdlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDExMnB4O1xuICAgIGhlaWdodDogMTEycHg7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBwbGFjZS1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2hhbG8ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBpbnNldDogMTBweDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcbiAgICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTgpIDAlLCByZ2JhKDI0OSwgMjA2LCAyMjQsIDAuNzQpIDU2JSwgcmdiYSgyNDQsIDE3NSwgMjA0LCAwLjI4KSAxMDAlKTtcbiAgICBib3gtc2hhZG93OlxuICAgICAgMCAxMnB4IDMwcHggcmdiYSgyMzAsIDEyMywgMTY4LCAwLjI0KSxcbiAgICAgIGluc2V0IDAgMCAwIDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNjQpO1xuICAgIGFuaW1hdGlvbjogaW52TG9hZGVySGFsbyAyLjNzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX3Jpbmcge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBpbnNldDogMDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcbiAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDIyMSwgMTI2LCAxNjUsIDAuMik7XG4gICAgYm9yZGVyLXRvcC1jb2xvcjogcmdiYSgyMTEsIDcwLCAxMzAsIDAuODQpO1xuICAgIGJvcmRlci1yaWdodC1jb2xvcjogcmdiYSgyMzMsIDE0NSwgMTc5LCAwLjU4KTtcbiAgICBhbmltYXRpb246IGludkxvYWRlclNwaW4gMS4xNXMgbGluZWFyIGluZmluaXRlO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2hlYXJ0IHtcbiAgICB3aWR0aDogMzRweDtcbiAgICBoZWlnaHQ6IDM0cHg7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgYW5pbWF0aW9uOiBpbnZMb2FkZXJCZWF0IDEuNHMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gIH1cblxuICAuaW52LWxvYWRlcl9faGVhcnQtc3ZnIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cblxuICAuaW52LWxvYWRlcl9faGVhcnQtcGF0aCB7XG4gICAgZmlsbDogbm9uZTtcbiAgICBzdHJva2U6ICNjZjRmODk7XG4gICAgc3Ryb2tlLXdpZHRoOiAyLjE1O1xuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xuICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMCAzcHggOHB4IHJnYmEoMjE2LCA2MSwgMTI0LCAwLjE4KSk7XG4gIH1cblxuICAuaW52LWxvYWRlcl9fbGFiZWwge1xuICAgIG1hcmdpbjogMDtcbiAgICBmb250LWZhbWlseTogXCJQbGF5ZmFpciBEaXNwbGF5XCIsIEdlb3JnaWEsIHNlcmlmO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsZXR0ZXItc3BhY2luZzogMC4ycHg7XG4gICAgY29sb3I6ICM2ZDJhNTM7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG5cbiAgQGtleWZyYW1lcyBpbnZMb2FkZXJTcGluIHtcbiAgICB0byB7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgaW52TG9hZGVySGFsbyB7XG4gICAgMCUsIDEwMCUge1xuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk4KTtcbiAgICAgIG9wYWNpdHk6IDAuODY7XG4gICAgfVxuICAgIDUwJSB7XG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDIpO1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIGludkxvYWRlckJlYXQge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZykgc2NhbGUoMSk7XG4gICAgfVxuICAgIDQyJSB7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpIHNjYWxlKDEuMTIpO1xuICAgIH1cbiAgICA2NCUge1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKSBzY2FsZSgwLjk4KTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICAuaW52LWxvYWRlcl9fc3RhZ2Uge1xuICAgICAgd2lkdGg6IDk2cHg7XG4gICAgICBoZWlnaHQ6IDk2cHg7XG4gICAgfVxuXG4gICAgLmludi1sb2FkZXJfX2hlYXJ0IHtcbiAgICAgIHdpZHRoOiAzMHB4O1xuICAgICAgaGVpZ2h0OiAzMHB4O1xuICAgIH1cblxuICAgIC5pbnYtbG9hZGVyX19sYWJlbCB7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpIHtcbiAgICAuaW52LWxvYWRlcl9faGFsbyxcbiAgICAuaW52LWxvYWRlcl9fcmluZyxcbiAgICAuaW52LWxvYWRlcl9faGVhcnQge1xuICAgICAgYW5pbWF0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2IGlkPVwiaW52LWxvYWRlclwiIGNsYXNzPVwiaW52LWxvYWRlclwiIHJvbGU9XCJzdGF0dXNcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIiBhcmlhLWxhYmVsPVwiQ2FyZ2FuZG8gaW52aXRhY2lvblwiPlxuICA8ZGl2IGNsYXNzPVwiaW52LWxvYWRlcl9fc3RhZ2VcIj5cbiAgICA8c3BhbiBjbGFzcz1cImludi1sb2FkZXJfX2hhbG9cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJpbnYtbG9hZGVyX19yaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaW52LWxvYWRlcl9faGVhcnRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgIDxzdmcgY2xhc3M9XCJpbnYtbG9hZGVyX19oZWFydC1zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzcz1cImludi1sb2FkZXJfX2hlYXJ0LXBhdGhcIlxuICAgICAgICAgIGQ9XCJNMTIgMjAuMmMtLjIgMC0uNC0uMS0uNS0uMkM4LjUgMTcuNCAzIDEzLjMgMyA4LjUgMyA1LjggNS4xIDMuOCA3LjcgMy44YzEuNiAwIDMuMS44IDQuMSAyLjIgMS0xLjQgMi41LTIuMiA0LjEtMi4yQzE4LjUgMy44IDIwLjYgNS44IDIwLjYgOC41YzAgNC44LTUuNSA4LjktOC41IDExLjUtLjEuMS0uMy4yLS41LjJ6XCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvc3Bhbj5cbiAgPC9kaXY+XG4gIDxwIGNsYXNzPVwiaW52LWxvYWRlcl9fbGFiZWxcIj5QcmVwYXJhbmRvIGludml0YWNpb24uLi48L3A+XG48L2Rpdj5cblxuPHNjcmlwdD5cbihmdW5jdGlvbigpe1xuICB2YXIgUlVOVElNRV9SRUFEWV9FVkVOVCA9IFwiaW52aXRhdGlvbi1ydW50aW1lLXJlYWR5XCI7XG4gIHZhciBSVU5USU1FX0ZBSUxfRVZFTlQgPSBcImludml0YXRpb24tcnVudGltZS1mYWlsZWRcIjtcbiAgdmFyIExPQURFUl9ISURERU5fRVZFTlQgPSBcImludml0YXRpb24tbG9hZGVyLWhpZGRlblwiO1xuICB2YXIgTUFYX1dBSVRfTVMgPSAxMDAwMDtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoTG9hZGVyRXZlbnQobmFtZSl7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lKSk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAvLyBub29wXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VMb2FkZXIoKXtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgY2xvc2VkID0gdHJ1ZTtcblxuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShcImRhdGEtbG9hZGVyLXJlYWR5XCIsIFwiMVwiKTtcbiAgICB9XG5cbiAgICB2YXIgbG9hZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnYtbG9hZGVyXCIpO1xuICAgIGlmICghbG9hZGVyKSByZXR1cm47XG5cbiAgICBsb2FkZXIuY2xhc3NMaXN0LmFkZChcImludi1sb2FkZXItLWV4aXRcIik7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChsb2FkZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBsb2FkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2hMb2FkZXJFdmVudChMT0FERVJfSElEREVOX0VWRU5UKTtcbiAgICB9LCA1MjApO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJtRXZlbnRzKCl7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKFwiZGF0YS1sb2FkZXItcmVhZHlcIiwgXCIwXCIpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJVTlRJTUVfUkVBRFlfRVZFTlQsIGNsb3NlTG9hZGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUlVOVElNRV9GQUlMX0VWRU5ULCBjbG9zZUxvYWRlciwgeyBvbmNlOiB0cnVlIH0pO1xuXG4gICAgd2luZG93LnNldFRpbWVvdXQoY2xvc2VMb2FkZXIsIE1BWF9XQUlUX01TKTtcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGFybUV2ZW50cywgeyBvbmNlOiB0cnVlIH0pO1xuICB9IGVsc2Uge1xuICAgIGFybUV2ZW50cygpO1xuICB9XG59KSgpO1xuPC9zY3JpcHQ+XG5gLnRyaW0oKTtcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarInvitationLoaderRuntime.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarModalGaleria.ts":
/*!****************************************************!*\
  !*** ./functions/src/utils/generarModalGaleria.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalGaleriaHTML: () => (/* binding */ generarModalGaleriaHTML),\n/* harmony export */   hayGaleriaConImagenes: () => (/* binding */ hayGaleriaConImagenes)\n/* harmony export */ });\nfunction hayGaleriaConImagenes(objetos = []) {\n    return objetos.some((obj)=>{\n        if (obj?.tipo !== \"galeria\" || !Array.isArray(obj?.cells)) return false;\n        return obj.cells.some((cell)=>typeof cell?.mediaUrl === \"string\" && cell.mediaUrl.trim().length > 0);\n    });\n}\nfunction generarModalGaleriaHTML() {\n    return `\n<style>\n  .objeto.galeria .galeria-celda--clickable {\n    cursor: zoom-in;\n  }\n\n  .objeto.galeria .galeria-celda--clickable:focus-visible {\n    outline: 2px solid rgba(255, 255, 255, 0.95);\n    outline-offset: -2px;\n  }\n\n  .gallery-lightbox {\n    position: fixed;\n    inset: 0;\n    z-index: 11000;\n    opacity: 0;\n    visibility: hidden;\n    pointer-events: none;\n    transition: opacity 0.32s ease, visibility 0.32s ease;\n  }\n\n  .gallery-lightbox.is-open {\n    opacity: 1;\n    visibility: visible;\n    pointer-events: auto;\n  }\n\n  .gallery-lightbox__backdrop {\n    position: absolute;\n    inset: 0;\n    background:\n      radial-gradient(circle at 50% 10%, rgba(66, 66, 75, 0.35), transparent 48%),\n      rgba(7, 8, 11, 0.96);\n    backdrop-filter: blur(8px);\n  }\n\n  .gallery-lightbox__stage {\n    position: relative;\n    z-index: 1;\n    width: min(1320px, 100vw);\n    height: min(94vh, 920px);\n    margin: 0 auto;\n    padding: clamp(24px, 4vw, 44px) clamp(56px, 8vw, 120px);\n    display: grid;\n    grid-template-columns: minmax(0, 1fr) minmax(0, 1.65fr) minmax(0, 1fr);\n    align-items: center;\n    gap: clamp(10px, 2.2vw, 28px);\n  }\n\n  .gallery-lightbox__slot {\n    width: 100%;\n    height: min(84vh, 780px);\n    background: rgba(255, 255, 255, 0.05);\n    border: 1px solid rgba(255, 255, 255, 0.16);\n    border-radius: 20px;\n    overflow: hidden;\n    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.36);\n    transition: opacity 0.26s ease, transform 0.26s ease, filter 0.26s ease;\n  }\n\n  .gallery-lightbox__slot img {\n    width: 100%;\n    height: 100%;\n    display: block;\n    object-fit: contain;\n  }\n\n  .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\n    opacity: 0.52;\n    transform: translateX(10%) scale(0.9);\n    filter: saturate(0.72);\n  }\n\n  .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\n    opacity: 1;\n    transform: scale(1);\n    filter: none;\n  }\n\n  .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\n    opacity: 0.52;\n    transform: translateX(-10%) scale(0.9);\n    filter: saturate(0.72);\n  }\n\n  .gallery-lightbox__slot.is-empty {\n    opacity: 0;\n    transform: scale(0.85);\n    pointer-events: none;\n  }\n\n  .gallery-lightbox__nav,\n  .gallery-lightbox__close {\n    position: absolute;\n    z-index: 2;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    border-radius: 9999px;\n    background: rgba(15, 16, 22, 0.62);\n    color: #fff;\n    cursor: pointer;\n    transition: background 0.2s ease, transform 0.2s ease;\n    backdrop-filter: blur(4px);\n  }\n\n  .gallery-lightbox__nav:hover,\n  .gallery-lightbox__close:hover {\n    background: rgba(22, 25, 34, 0.9);\n    transform: translateY(-1px);\n  }\n\n  .gallery-lightbox__nav {\n    top: 50%;\n    transform: translateY(-50%);\n    width: 52px;\n    height: 52px;\n    font-size: 28px;\n    line-height: 1;\n  }\n\n  .gallery-lightbox__nav--prev {\n    left: clamp(10px, 2vw, 32px);\n  }\n\n  .gallery-lightbox__nav--next {\n    right: clamp(10px, 2vw, 32px);\n  }\n\n  .gallery-lightbox__nav:disabled {\n    opacity: 0.35;\n    cursor: default;\n  }\n\n  .gallery-lightbox__close {\n    top: clamp(14px, 2.5vh, 26px);\n    right: clamp(14px, 2vw, 28px);\n    width: 44px;\n    height: 44px;\n    font-size: 24px;\n    line-height: 1;\n  }\n\n  .gallery-lightbox__counter {\n    position: absolute;\n    z-index: 2;\n    bottom: clamp(12px, 2vh, 24px);\n    left: 50%;\n    transform: translateX(-50%);\n    color: rgba(255, 255, 255, 0.9);\n    background: rgba(14, 16, 24, 0.55);\n    border: 1px solid rgba(255, 255, 255, 0.18);\n    padding: 8px 14px;\n    border-radius: 9999px;\n    font-size: 14px;\n    font-weight: 600;\n    letter-spacing: 0.03em;\n  }\n\n  @media (max-width: 900px) {\n    .gallery-lightbox__stage {\n      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.8fr) minmax(0, 0.9fr);\n      padding: 64px 12px 66px;\n      height: 100dvh;\n      height: 100vh;\n      gap: 12px;\n    }\n\n    .gallery-lightbox__slot {\n      height: min(76vh, 700px);\n      border-radius: 16px;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\n      opacity: 0.34;\n      transform: translateX(22%) scale(0.84);\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\n      opacity: 0.34;\n      transform: translateX(-22%) scale(0.84);\n    }\n  }\n\n  @media (max-width: 640px) {\n    .gallery-lightbox__stage {\n      width: 100vw;\n      max-width: 100vw;\n      height: 100dvh;\n      height: 100vh;\n      grid-template-columns: minmax(0, 1fr);\n      padding:\n        calc(env(safe-area-inset-top, 0px) + 8px)\n        calc(env(safe-area-inset-right, 0px) + 4px)\n        calc(env(safe-area-inset-bottom, 0px) + 50px)\n        calc(env(safe-area-inset-left, 0px) + 4px);\n      gap: 0;\n      align-items: stretch;\n    }\n\n    .gallery-lightbox__slot {\n      height: 100%;\n      border-radius: 12px;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"],\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\n      display: none;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\n      background: transparent;\n      border: none;\n      border-radius: 0;\n      box-shadow: none;\n    }\n\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] img {\n      width: 100%;\n      height: 100%;\n      object-fit: contain;\n    }\n\n    .gallery-lightbox__nav {\n      width: 42px;\n      height: 42px;\n      font-size: 24px;\n    }\n\n    .gallery-lightbox__nav--prev {\n      left: calc(env(safe-area-inset-left, 0px) + 6px);\n    }\n\n    .gallery-lightbox__nav--next {\n      right: calc(env(safe-area-inset-right, 0px) + 6px);\n    }\n\n    .gallery-lightbox__close {\n      top: calc(env(safe-area-inset-top, 0px) + 10px);\n      right: calc(env(safe-area-inset-right, 0px) + 10px);\n    }\n\n    .gallery-lightbox__counter {\n      bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);\n    }\n  }\n</style>\n\n<div id=\"gallery-lightbox\" class=\"gallery-lightbox\" aria-hidden=\"true\" role=\"dialog\" aria-modal=\"true\">\n  <div class=\"gallery-lightbox__backdrop\" data-gallery-close></div>\n\n  <button type=\"button\" class=\"gallery-lightbox__close\" data-gallery-close aria-label=\"Cerrar galeria\">\n    &#10005;\n  </button>\n\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--prev\" data-gallery-prev aria-label=\"Imagen anterior\">\n    &#8249;\n  </button>\n\n  <div class=\"gallery-lightbox__stage\">\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"prev\">\n      <img alt=\"\" />\n    </figure>\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"current\">\n      <img alt=\"\" />\n    </figure>\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"next\">\n      <img alt=\"\" />\n    </figure>\n  </div>\n\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--next\" data-gallery-next aria-label=\"Imagen siguiente\">\n    &#8250;\n  </button>\n\n  <div class=\"gallery-lightbox__counter\" data-gallery-counter>1 / 1</div>\n</div>\n\n<script>\n(function(){\n  function clampIndex(index, total){\n    if (!total) return 0;\n    var normalized = index % total;\n    return normalized < 0 ? normalized + total : normalized;\n  }\n\n  function boot(){\n    var modal = document.getElementById(\"gallery-lightbox\");\n    if (!modal) return;\n\n    var closeEls = Array.from(modal.querySelectorAll(\"[data-gallery-close]\"));\n    var prevBtn = modal.querySelector(\"[data-gallery-prev]\");\n    var nextBtn = modal.querySelector(\"[data-gallery-next]\");\n    var counter = modal.querySelector(\"[data-gallery-counter]\");\n\n    var prevSlot = modal.querySelector('[data-gallery-slot=\"prev\"]');\n    var currentSlot = modal.querySelector('[data-gallery-slot=\"current\"]');\n    var nextSlot = modal.querySelector('[data-gallery-slot=\"next\"]');\n\n    var prevImg = prevSlot ? prevSlot.querySelector(\"img\") : null;\n    var currentImg = currentSlot ? currentSlot.querySelector(\"img\") : null;\n    var nextImg = nextSlot ? nextSlot.querySelector(\"img\") : null;\n    var stage = modal.querySelector(\".gallery-lightbox__stage\");\n\n    var state = {\n      images: [],\n      index: 0,\n      isOpen: false,\n      originalOverflow: \"\"\n    };\n\n    function setSlotImage(imgNode, src, altText){\n      if (!imgNode) return;\n      if (!src) {\n        imgNode.removeAttribute(\"src\");\n        imgNode.alt = \"\";\n        return;\n      }\n      if (imgNode.getAttribute(\"src\") !== src) {\n        imgNode.setAttribute(\"src\", src);\n      }\n      imgNode.alt = altText || \"\";\n    }\n\n    function refresh(){\n      var total = state.images.length;\n      if (!total) return;\n\n      state.index = clampIndex(state.index, total);\n      var currentIndex = state.index;\n      var hasNeighbors = total > 1;\n\n      var prevIndex = clampIndex(currentIndex - 1, total);\n      var nextIndex = clampIndex(currentIndex + 1, total);\n\n      setSlotImage(currentImg, state.images[currentIndex], \"Imagen \" + (currentIndex + 1));\n      setSlotImage(\n        prevImg,\n        hasNeighbors ? state.images[prevIndex] : \"\",\n        hasNeighbors ? \"Imagen anterior\" : \"\"\n      );\n      setSlotImage(\n        nextImg,\n        hasNeighbors ? state.images[nextIndex] : \"\",\n        hasNeighbors ? \"Imagen siguiente\" : \"\"\n      );\n\n      if (prevSlot) prevSlot.classList.toggle(\"is-empty\", !hasNeighbors);\n      if (nextSlot) nextSlot.classList.toggle(\"is-empty\", !hasNeighbors);\n\n      if (counter) counter.textContent = (currentIndex + 1) + \" / \" + total;\n      if (prevBtn) prevBtn.disabled = !hasNeighbors;\n      if (nextBtn) nextBtn.disabled = !hasNeighbors;\n    }\n\n    function open(images, startIndex){\n      if (!Array.isArray(images) || !images.length) return;\n      state.images = images.slice();\n      state.index = clampIndex(Number(startIndex) || 0, state.images.length);\n      state.isOpen = true;\n\n      state.originalOverflow = document.body.style.overflow || \"\";\n      document.body.style.overflow = \"hidden\";\n\n      modal.setAttribute(\"aria-hidden\", \"false\");\n      modal.classList.add(\"is-open\");\n      refresh();\n\n      if (closeEls[0] && typeof closeEls[0].focus === \"function\") {\n        closeEls[0].focus();\n      }\n    }\n\n    function close(){\n      if (!state.isOpen) return;\n      state.isOpen = false;\n      modal.classList.remove(\"is-open\");\n      modal.setAttribute(\"aria-hidden\", \"true\");\n      document.body.style.overflow = state.originalOverflow;\n    }\n\n    function navigate(step){\n      if (!state.isOpen || state.images.length < 2) return;\n      state.index = clampIndex(state.index + step, state.images.length);\n      refresh();\n    }\n\n    closeEls.forEach(function(el){\n      el.addEventListener(\"click\", function(ev){\n        ev.preventDefault();\n        close();\n      });\n    });\n\n    if (prevBtn) {\n      prevBtn.addEventListener(\"click\", function(ev){\n        ev.preventDefault();\n        navigate(-1);\n      });\n    }\n\n    if (nextBtn) {\n      nextBtn.addEventListener(\"click\", function(ev){\n        ev.preventDefault();\n        navigate(1);\n      });\n    }\n\n    document.addEventListener(\"keydown\", function(ev){\n      if (!state.isOpen) return;\n      if (ev.key === \"Escape\") {\n        ev.preventDefault();\n        close();\n        return;\n      }\n      if (ev.key === \"ArrowLeft\") {\n        ev.preventDefault();\n        navigate(-1);\n        return;\n      }\n      if (ev.key === \"ArrowRight\") {\n        ev.preventDefault();\n        navigate(1);\n      }\n    });\n\n    if (stage) {\n      var startX = 0;\n      var startY = 0;\n      var pointerDown = false;\n\n      stage.addEventListener(\"touchstart\", function(ev){\n        if (!ev.touches || !ev.touches.length) return;\n        pointerDown = true;\n        startX = ev.touches[0].clientX;\n        startY = ev.touches[0].clientY;\n      }, { passive: true });\n\n      stage.addEventListener(\"touchend\", function(ev){\n        if (!pointerDown || !ev.changedTouches || !ev.changedTouches.length) return;\n        pointerDown = false;\n        var endX = ev.changedTouches[0].clientX;\n        var endY = ev.changedTouches[0].clientY;\n        var dx = endX - startX;\n        var dy = endY - startY;\n\n        if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {\n          navigate(dx > 0 ? -1 : 1);\n        }\n      }, { passive: true });\n    }\n\n    var galleries = Array.from(document.querySelectorAll(\".objeto.galeria\"));\n    galleries.forEach(function(gallery){\n      var cells = Array.from(\n        gallery.querySelectorAll('.galeria-celda[data-gallery-image=\"1\"]')\n      );\n      if (!cells.length) return;\n\n      var images = cells\n        .map(function(cell){\n          var img = cell.querySelector(\"img\");\n          if (!img) return \"\";\n          return (img.getAttribute(\"src\") || \"\").trim();\n        })\n        .filter(Boolean);\n\n      if (!images.length) return;\n\n      gallery.addEventListener(\"click\", function(ev){\n        var target = ev.target;\n        if (!(target instanceof Element)) return;\n\n        var cell = target.closest('.galeria-celda[data-gallery-image=\"1\"]');\n        if (!cell || !gallery.contains(cell)) return;\n\n        var index = cells.indexOf(cell);\n        if (index < 0) return;\n\n        ev.preventDefault();\n        ev.stopPropagation();\n        open(images, index);\n      });\n\n      gallery.addEventListener(\"keydown\", function(ev){\n        if (ev.key !== \"Enter\" && ev.key !== \" \") return;\n        var target = ev.target;\n        if (!(target instanceof Element)) return;\n\n        var cell = target.closest('.galeria-celda[data-gallery-image=\"1\"]');\n        if (!cell || !gallery.contains(cell)) return;\n\n        var index = cells.indexOf(cell);\n        if (index < 0) return;\n\n        ev.preventDefault();\n        open(images, index);\n      });\n    });\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", boot);\n  } else {\n    boot();\n  }\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsR2FsZXJpYS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQVNPLFNBQVNBLHNCQUFzQkMsVUFBaUIsRUFBRTtJQUN2RCxPQUFPQSxRQUFRQyxJQUFJLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsS0FBS0MsU0FBUyxhQUFhLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0gsS0FBS0ksUUFBUSxPQUFPO1FBQ2xFLE9BQU9KLElBQUlJLEtBQUssQ0FBQ0wsSUFBSSxDQUNuQixDQUFDTSxPQUFTLE9BQU9BLE1BQU1DLGFBQWEsWUFBWUQsS0FBS0MsUUFBUSxDQUFDQyxJQUFJLEdBQUdDLE1BQU0sR0FBRztJQUVsRjtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMGZWLENBQUMsQ0FBQ0YsSUFBSTtBQUNOIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXGdlbmVyYXJNb2RhbEdhbGVyaWEudHMiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBHYWxlcmlhQ2VsbCA9IHtcbiAgbWVkaWFVcmw/OiBzdHJpbmcgfCBudWxsO1xufTtcblxudHlwZSBPYmpldG9HYWxlcmlhID0ge1xuICB0aXBvPzogc3RyaW5nO1xuICBjZWxscz86IEdhbGVyaWFDZWxsW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaGF5R2FsZXJpYUNvbkltYWdlbmVzKG9iamV0b3M6IGFueVtdID0gW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIG9iamV0b3Muc29tZSgob2JqOiBPYmpldG9HYWxlcmlhKSA9PiB7XG4gICAgaWYgKG9iaj8udGlwbyAhPT0gXCJnYWxlcmlhXCIgfHwgIUFycmF5LmlzQXJyYXkob2JqPy5jZWxscykpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb2JqLmNlbGxzLnNvbWUoXG4gICAgICAoY2VsbCkgPT4gdHlwZW9mIGNlbGw/Lm1lZGlhVXJsID09PSBcInN0cmluZ1wiICYmIGNlbGwubWVkaWFVcmwudHJpbSgpLmxlbmd0aCA+IDBcbiAgICApO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJNb2RhbEdhbGVyaWFIVE1MKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG48c3R5bGU+XG4gIC5vYmpldG8uZ2FsZXJpYSAuZ2FsZXJpYS1jZWxkYS0tY2xpY2thYmxlIHtcbiAgICBjdXJzb3I6IHpvb20taW47XG4gIH1cblxuICAub2JqZXRvLmdhbGVyaWEgLmdhbGVyaWEtY2VsZGEtLWNsaWNrYWJsZTpmb2N1cy12aXNpYmxlIHtcbiAgICBvdXRsaW5lOiAycHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KTtcbiAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgaW5zZXQ6IDA7XG4gICAgei1pbmRleDogMTEwMDA7XG4gICAgb3BhY2l0eTogMDtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjMycyBlYXNlLCB2aXNpYmlsaXR5IDAuMzJzIGVhc2U7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveC5pcy1vcGVuIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fYmFja2Ryb3Age1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBpbnNldDogMDtcbiAgICBiYWNrZ3JvdW5kOlxuICAgICAgcmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCA1MCUgMTAlLCByZ2JhKDY2LCA2NiwgNzUsIDAuMzUpLCB0cmFuc3BhcmVudCA0OCUpLFxuICAgICAgcmdiYSg3LCA4LCAxMSwgMC45Nik7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2Uge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB6LWluZGV4OiAxO1xuICAgIHdpZHRoOiBtaW4oMTMyMHB4LCAxMDB2dyk7XG4gICAgaGVpZ2h0OiBtaW4oOTR2aCwgOTIwcHgpO1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICAgIHBhZGRpbmc6IGNsYW1wKDI0cHgsIDR2dywgNDRweCkgY2xhbXAoNTZweCwgOHZ3LCAxMjBweCk7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IG1pbm1heCgwLCAxZnIpIG1pbm1heCgwLCAxLjY1ZnIpIG1pbm1heCgwLCAxZnIpO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiBjbGFtcCgxMHB4LCAyLjJ2dywgMjhweCk7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBtaW4oODR2aCwgNzgwcHgpO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE2KTtcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNoYWRvdzogMCAyNHB4IDYwcHggcmdiYSgwLCAwLCAwLCAwLjM2KTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjZzIGVhc2UsIHRyYW5zZm9ybSAwLjI2cyBlYXNlLCBmaWx0ZXIgMC4yNnMgZWFzZTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90IGltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cInByZXZcIl0ge1xuICAgIG9wYWNpdHk6IDAuNTI7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwJSkgc2NhbGUoMC45KTtcbiAgICBmaWx0ZXI6IHNhdHVyYXRlKDAuNzIpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJjdXJyZW50XCJdIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgZmlsdGVyOiBub25lO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJuZXh0XCJdIHtcbiAgICBvcGFjaXR5OiAwLjUyO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAlKSBzY2FsZSgwLjkpO1xuICAgIGZpbHRlcjogc2F0dXJhdGUoMC43Mik7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdC5pcy1lbXB0eSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODUpO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdixcbiAgLmdhbGxlcnktbGlnaHRib3hfX2Nsb3NlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMjtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMTUsIDE2LCAyMiwgMC42Mik7XG4gICAgY29sb3I6ICNmZmY7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4ycyBlYXNlLCB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig0cHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdjpob3ZlcixcbiAgLmdhbGxlcnktbGlnaHRib3hfX2Nsb3NlOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIyLCAyNSwgMzQsIDAuOSk7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xcHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdiB7XG4gICAgdG9wOiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIHdpZHRoOiA1MnB4O1xuICAgIGhlaWdodDogNTJweDtcbiAgICBmb250LXNpemU6IDI4cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fbmF2LS1wcmV2IHtcbiAgICBsZWZ0OiBjbGFtcCgxMHB4LCAydncsIDMycHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tbmV4dCB7XG4gICAgcmlnaHQ6IGNsYW1wKDEwcHgsIDJ2dywgMzJweCk7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fbmF2OmRpc2FibGVkIHtcbiAgICBvcGFjaXR5OiAwLjM1O1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZSB7XG4gICAgdG9wOiBjbGFtcCgxNHB4LCAyLjV2aCwgMjZweCk7XG4gICAgcmlnaHQ6IGNsYW1wKDE0cHgsIDJ2dywgMjhweCk7XG4gICAgd2lkdGg6IDQ0cHg7XG4gICAgaGVpZ2h0OiA0NHB4O1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jb3VudGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMjtcbiAgICBib3R0b206IGNsYW1wKDEycHgsIDJ2aCwgMjRweCk7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMTQsIDE2LCAyNCwgMC41NSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE4KTtcbiAgICBwYWRkaW5nOiA4cHggMTRweDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgbGV0dGVyLXNwYWNpbmc6IDAuMDNlbTtcbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA5MDBweCkge1xuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zdGFnZSB7XG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IG1pbm1heCgwLCAwLjlmcikgbWlubWF4KDAsIDEuOGZyKSBtaW5tYXgoMCwgMC45ZnIpO1xuICAgICAgcGFkZGluZzogNjRweCAxMnB4IDY2cHg7XG4gICAgICBoZWlnaHQ6IDEwMGR2aDtcbiAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICBnYXA6IDEycHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3Qge1xuICAgICAgaGVpZ2h0OiBtaW4oNzZ2aCwgNzAwcHgpO1xuICAgICAgYm9yZGVyLXJhZGl1czogMTZweDtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cInByZXZcIl0ge1xuICAgICAgb3BhY2l0eTogMC4zNDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMiUpIHNjYWxlKDAuODQpO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiXSB7XG4gICAgICBvcGFjaXR5OiAwLjM0O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yMiUpIHNjYWxlKDAuODQpO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA2NDBweCkge1xuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zdGFnZSB7XG4gICAgICB3aWR0aDogMTAwdnc7XG4gICAgICBtYXgtd2lkdGg6IDEwMHZ3O1xuICAgICAgaGVpZ2h0OiAxMDBkdmg7XG4gICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMCwgMWZyKTtcbiAgICAgIHBhZGRpbmc6XG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC10b3AsIDBweCkgKyA4cHgpXG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KSArIDRweClcbiAgICAgICAgY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSwgMHB4KSArIDUwcHgpXG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpICsgNHB4KTtcbiAgICAgIGdhcDogMDtcbiAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90IHtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdLFxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiXSB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXSB7XG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICBib3gtc2hhZG93OiBub25lO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXSBpbWcge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYge1xuICAgICAgd2lkdGg6IDQycHg7XG4gICAgICBoZWlnaHQ6IDQycHg7XG4gICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tcHJldiB7XG4gICAgICBsZWZ0OiBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCwgMHB4KSArIDZweCk7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tbmV4dCB7XG4gICAgICByaWdodDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0LCAwcHgpICsgNnB4KTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fY2xvc2Uge1xuICAgICAgdG9wOiBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpICsgMTBweCk7XG4gICAgICByaWdodDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXJpZ2h0LCAwcHgpICsgMTBweCk7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX2NvdW50ZXIge1xuICAgICAgYm90dG9tOiBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpICsgOHB4KTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgaWQ9XCJnYWxsZXJ5LWxpZ2h0Ym94XCIgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cImRpYWxvZ1wiIGFyaWEtbW9kYWw9XCJ0cnVlXCI+XG4gIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19iYWNrZHJvcFwiIGRhdGEtZ2FsbGVyeS1jbG9zZT48L2Rpdj5cblxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX2Nsb3NlXCIgZGF0YS1nYWxsZXJ5LWNsb3NlIGFyaWEtbGFiZWw9XCJDZXJyYXIgZ2FsZXJpYVwiPlxuICAgICYjMTAwMDU7XG4gIDwvYnV0dG9uPlxuXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fbmF2IGdhbGxlcnktbGlnaHRib3hfX25hdi0tcHJldlwiIGRhdGEtZ2FsbGVyeS1wcmV2IGFyaWEtbGFiZWw9XCJJbWFnZW4gYW50ZXJpb3JcIj5cbiAgICAmIzgyNDk7XG4gIDwvYnV0dG9uPlxuXG4gIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19zdGFnZVwiPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19zbG90XCIgZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCI+XG4gICAgICA8aW1nIGFsdD1cIlwiIC8+XG4gICAgPC9maWd1cmU+XG4gICAgPGZpZ3VyZSBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX3Nsb3RcIiBkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIj5cbiAgICAgIDxpbWcgYWx0PVwiXCIgLz5cbiAgICA8L2ZpZ3VyZT5cbiAgICA8ZmlndXJlIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fc2xvdFwiIGRhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiPlxuICAgICAgPGltZyBhbHQ9XCJcIiAvPlxuICAgIDwvZmlndXJlPlxuICA8L2Rpdj5cblxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX25hdiBnYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLW5leHRcIiBkYXRhLWdhbGxlcnktbmV4dCBhcmlhLWxhYmVsPVwiSW1hZ2VuIHNpZ3VpZW50ZVwiPlxuICAgICYjODI1MDtcbiAgPC9idXR0b24+XG5cbiAgPGRpdiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX2NvdW50ZXJcIiBkYXRhLWdhbGxlcnktY291bnRlcj4xIC8gMTwvZGl2PlxuPC9kaXY+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gY2xhbXBJbmRleChpbmRleCwgdG90YWwpe1xuICAgIGlmICghdG90YWwpIHJldHVybiAwO1xuICAgIHZhciBub3JtYWxpemVkID0gaW5kZXggJSB0b3RhbDtcbiAgICByZXR1cm4gbm9ybWFsaXplZCA8IDAgPyBub3JtYWxpemVkICsgdG90YWwgOiBub3JtYWxpemVkO1xuICB9XG5cbiAgZnVuY3Rpb24gYm9vdCgpe1xuICAgIHZhciBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FsbGVyeS1saWdodGJveFwiKTtcbiAgICBpZiAoIW1vZGFsKSByZXR1cm47XG5cbiAgICB2YXIgY2xvc2VFbHMgPSBBcnJheS5mcm9tKG1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1nYWxsZXJ5LWNsb3NlXVwiKSk7XG4gICAgdmFyIHByZXZCdG4gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZ2FsbGVyeS1wcmV2XVwiKTtcbiAgICB2YXIgbmV4dEJ0biA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1nYWxsZXJ5LW5leHRdXCIpO1xuICAgIHZhciBjb3VudGVyID0gbW9kYWwucXVlcnlTZWxlY3RvcihcIltkYXRhLWdhbGxlcnktY291bnRlcl1cIik7XG5cbiAgICB2YXIgcHJldlNsb3QgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdJyk7XG4gICAgdmFyIGN1cnJlbnRTbG90ID0gbW9kYWwucXVlcnlTZWxlY3RvcignW2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXScpO1xuICAgIHZhciBuZXh0U2xvdCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIl0nKTtcblxuICAgIHZhciBwcmV2SW1nID0gcHJldlNsb3QgPyBwcmV2U2xvdC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpIDogbnVsbDtcbiAgICB2YXIgY3VycmVudEltZyA9IGN1cnJlbnRTbG90ID8gY3VycmVudFNsb3QucXVlcnlTZWxlY3RvcihcImltZ1wiKSA6IG51bGw7XG4gICAgdmFyIG5leHRJbWcgPSBuZXh0U2xvdCA/IG5leHRTbG90LnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIikgOiBudWxsO1xuICAgIHZhciBzdGFnZSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCIuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2VcIik7XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBpbWFnZXM6IFtdLFxuICAgICAgaW5kZXg6IDAsXG4gICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgb3JpZ2luYWxPdmVyZmxvdzogXCJcIlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRTbG90SW1hZ2UoaW1nTm9kZSwgc3JjLCBhbHRUZXh0KXtcbiAgICAgIGlmICghaW1nTm9kZSkgcmV0dXJuO1xuICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgaW1nTm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgIGltZ05vZGUuYWx0ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGltZ05vZGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpICE9PSBzcmMpIHtcbiAgICAgICAgaW1nTm9kZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTtcbiAgICAgIH1cbiAgICAgIGltZ05vZGUuYWx0ID0gYWx0VGV4dCB8fCBcIlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2goKXtcbiAgICAgIHZhciB0b3RhbCA9IHN0YXRlLmltYWdlcy5sZW5ndGg7XG4gICAgICBpZiAoIXRvdGFsKSByZXR1cm47XG5cbiAgICAgIHN0YXRlLmluZGV4ID0gY2xhbXBJbmRleChzdGF0ZS5pbmRleCwgdG90YWwpO1xuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgdmFyIGhhc05laWdoYm9ycyA9IHRvdGFsID4gMTtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGNsYW1wSW5kZXgoY3VycmVudEluZGV4IC0gMSwgdG90YWwpO1xuICAgICAgdmFyIG5leHRJbmRleCA9IGNsYW1wSW5kZXgoY3VycmVudEluZGV4ICsgMSwgdG90YWwpO1xuXG4gICAgICBzZXRTbG90SW1hZ2UoY3VycmVudEltZywgc3RhdGUuaW1hZ2VzW2N1cnJlbnRJbmRleF0sIFwiSW1hZ2VuIFwiICsgKGN1cnJlbnRJbmRleCArIDEpKTtcbiAgICAgIHNldFNsb3RJbWFnZShcbiAgICAgICAgcHJldkltZyxcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gc3RhdGUuaW1hZ2VzW3ByZXZJbmRleF0gOiBcIlwiLFxuICAgICAgICBoYXNOZWlnaGJvcnMgPyBcIkltYWdlbiBhbnRlcmlvclwiIDogXCJcIlxuICAgICAgKTtcbiAgICAgIHNldFNsb3RJbWFnZShcbiAgICAgICAgbmV4dEltZyxcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gc3RhdGUuaW1hZ2VzW25leHRJbmRleF0gOiBcIlwiLFxuICAgICAgICBoYXNOZWlnaGJvcnMgPyBcIkltYWdlbiBzaWd1aWVudGVcIiA6IFwiXCJcbiAgICAgICk7XG5cbiAgICAgIGlmIChwcmV2U2xvdCkgcHJldlNsb3QuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWVtcHR5XCIsICFoYXNOZWlnaGJvcnMpO1xuICAgICAgaWYgKG5leHRTbG90KSBuZXh0U2xvdC5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtZW1wdHlcIiwgIWhhc05laWdoYm9ycyk7XG5cbiAgICAgIGlmIChjb3VudGVyKSBjb3VudGVyLnRleHRDb250ZW50ID0gKGN1cnJlbnRJbmRleCArIDEpICsgXCIgLyBcIiArIHRvdGFsO1xuICAgICAgaWYgKHByZXZCdG4pIHByZXZCdG4uZGlzYWJsZWQgPSAhaGFzTmVpZ2hib3JzO1xuICAgICAgaWYgKG5leHRCdG4pIG5leHRCdG4uZGlzYWJsZWQgPSAhaGFzTmVpZ2hib3JzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wZW4oaW1hZ2VzLCBzdGFydEluZGV4KXtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbWFnZXMpIHx8ICFpbWFnZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICBzdGF0ZS5pbWFnZXMgPSBpbWFnZXMuc2xpY2UoKTtcbiAgICAgIHN0YXRlLmluZGV4ID0gY2xhbXBJbmRleChOdW1iZXIoc3RhcnRJbmRleCkgfHwgMCwgc3RhdGUuaW1hZ2VzLmxlbmd0aCk7XG4gICAgICBzdGF0ZS5pc09wZW4gPSB0cnVlO1xuXG4gICAgICBzdGF0ZS5vcmlnaW5hbE92ZXJmbG93ID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyB8fCBcIlwiO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cbiAgICAgIG1vZGFsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIik7XG4gICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKFwiaXMtb3BlblwiKTtcbiAgICAgIHJlZnJlc2goKTtcblxuICAgICAgaWYgKGNsb3NlRWxzWzBdICYmIHR5cGVvZiBjbG9zZUVsc1swXS5mb2N1cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNsb3NlRWxzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICAgIGlmICghc3RhdGUuaXNPcGVuKSByZXR1cm47XG4gICAgICBzdGF0ZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIG1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1vcGVuXCIpO1xuICAgICAgbW9kYWwuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHN0YXRlLm9yaWdpbmFsT3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmF2aWdhdGUoc3RlcCl7XG4gICAgICBpZiAoIXN0YXRlLmlzT3BlbiB8fCBzdGF0ZS5pbWFnZXMubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgc3RhdGUuaW5kZXggPSBjbGFtcEluZGV4KHN0YXRlLmluZGV4ICsgc3RlcCwgc3RhdGUuaW1hZ2VzLmxlbmd0aCk7XG4gICAgICByZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgY2xvc2VFbHMuZm9yRWFjaChmdW5jdGlvbihlbCl7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJldkJ0bikge1xuICAgICAgcHJldkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBuYXZpZ2F0ZSgtMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEJ0bikge1xuICAgICAgbmV4dEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBuYXZpZ2F0ZSgxKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgIGlmICghc3RhdGUuaXNPcGVuKSByZXR1cm47XG4gICAgICBpZiAoZXYua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldi5rZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoLTEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXYua2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBuYXZpZ2F0ZSgxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzdGFnZSkge1xuICAgICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgICB2YXIgc3RhcnRZID0gMDtcbiAgICAgIHZhciBwb2ludGVyRG93biA9IGZhbHNlO1xuXG4gICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihldil7XG4gICAgICAgIGlmICghZXYudG91Y2hlcyB8fCAhZXYudG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcG9pbnRlckRvd24gPSB0cnVlO1xuICAgICAgICBzdGFydFggPSBldi50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHN0YXJ0WSA9IGV2LnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAgICAgc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgaWYgKCFwb2ludGVyRG93biB8fCAhZXYuY2hhbmdlZFRvdWNoZXMgfHwgIWV2LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBwb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICB2YXIgZW5kWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHZhciBlbmRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgdmFyIGR4ID0gZW5kWCAtIHN0YXJ0WDtcbiAgICAgICAgdmFyIGR5ID0gZW5kWSAtIHN0YXJ0WTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID4gNDAgJiYgTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICAgICAgbmF2aWdhdGUoZHggPiAwID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHZhciBnYWxsZXJpZXMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIub2JqZXRvLmdhbGVyaWFcIikpO1xuICAgIGdhbGxlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGdhbGxlcnkpe1xuICAgICAgdmFyIGNlbGxzID0gQXJyYXkuZnJvbShcbiAgICAgICAgZ2FsbGVyeS5xdWVyeVNlbGVjdG9yQWxsKCcuZ2FsZXJpYS1jZWxkYVtkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJdJylcbiAgICAgICk7XG4gICAgICBpZiAoIWNlbGxzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICB2YXIgaW1hZ2VzID0gY2VsbHNcbiAgICAgICAgLm1hcChmdW5jdGlvbihjZWxsKXtcbiAgICAgICAgICB2YXIgaW1nID0gY2VsbC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpO1xuICAgICAgICAgIGlmICghaW1nKSByZXR1cm4gXCJcIjtcbiAgICAgICAgICByZXR1cm4gKGltZy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCJcIikudHJpbSgpO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICBpZiAoIWltYWdlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgZ2FsbGVyeS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjZWxsID0gdGFyZ2V0LmNsb3Nlc3QoJy5nYWxlcmlhLWNlbGRhW2RhdGEtZ2FsbGVyeS1pbWFnZT1cIjFcIl0nKTtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFnYWxsZXJ5LmNvbnRhaW5zKGNlbGwpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGluZGV4ID0gY2VsbHMuaW5kZXhPZihjZWxsKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBvcGVuKGltYWdlcywgaW5kZXgpO1xuICAgICAgfSk7XG5cbiAgICAgIGdhbGxlcnkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBpZiAoZXYua2V5ICE9PSBcIkVudGVyXCIgJiYgZXYua2V5ICE9PSBcIiBcIikgcmV0dXJuO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjZWxsID0gdGFyZ2V0LmNsb3Nlc3QoJy5nYWxlcmlhLWNlbGRhW2RhdGEtZ2FsbGVyeS1pbWFnZT1cIjFcIl0nKTtcbiAgICAgICAgaWYgKCFjZWxsIHx8ICFnYWxsZXJ5LmNvbnRhaW5zKGNlbGwpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGluZGV4ID0gY2VsbHMuaW5kZXhPZihjZWxsKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9wZW4oaW1hZ2VzLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGJvb3QoKTtcbiAgfVxufSkoKTtcbjwvc2NyaXB0PlxuYC50cmltKCk7XG59XG4iXSwibmFtZXMiOlsiaGF5R2FsZXJpYUNvbkltYWdlbmVzIiwib2JqZXRvcyIsInNvbWUiLCJvYmoiLCJ0aXBvIiwiQXJyYXkiLCJpc0FycmF5IiwiY2VsbHMiLCJjZWxsIiwibWVkaWFVcmwiLCJ0cmltIiwibGVuZ3RoIiwiZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarModalGaleria.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts":
/*!*************************************************!*\
  !*** ./functions/src/utils/generarModalRSVP.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalRSVPHTML: () => (/* binding */ generarModalRSVPHTML)\n/* harmony export */ });\n// functions/src/utils/generarModalRSVP.ts\nfunction generarModalRSVPHTML(cfg) {\n    if (!cfg?.enabled) return \"\";\n    const title = cfg.title ?? \"Confirmar asistencia\";\n    const subtitle = cfg.subtitle ?? \"\";\n    const btnText = cfg.buttonText ?? \"Enviar\";\n    const color = cfg.primaryColor ?? \"#773dbe\";\n    // Nota: el botón que abre el modal debe tener [data-rsvp-open]\n    // (el listener de abajo lo busca)\n    return `\n<div id=\"modal-rsvp\" style=\"\n  position: fixed; inset: 0; display:none;\n  background: rgba(0,0,0,.6); z-index: 9999;\n  align-items: center; justify-content: center;\">\n  <div style=\"\n    background: #fff; width: 90%; max-width: 420px; border-radius: 10px;\n    padding: 20px; font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,.2);\">\n    <div style=\"display:flex; justify-content: space-between; align-items:center;\">\n      <h2 style=\"margin:0; font-size:20px;\">${title}</h2>\n      <button id=\"rsvp-close\" aria-label=\"Cerrar\" style=\"border:none; background:transparent; font-size:18px; cursor:pointer;\">✕</button>\n    </div>\n    ${subtitle ? `<p style=\"margin:8px 0 16px; color:#555;\">${subtitle}</p>` : \"\"}\n\n    <div style=\"display:flex; flex-direction:column; gap:10px;\">\n      <input id=\"rsvp-nombre\" placeholder=\"Tu nombre\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\n      <input id=\"rsvp-mensaje\" placeholder=\"Mensaje (opcional)\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\n    </div>\n\n     <!-- ✅ NUEVO: selector Sí/No con estilo segmentado -->\n    <div style=\"margin-top:12px;\">\n      <label style=\"display:block; font-weight:600; margin-bottom:8px;\">¿Confirmás asistencia?</label>\n      <div id=\"rsvp-confirma\" style=\"\n        display:inline-flex; gap:0; border:1px solid #ddd; border-radius:10px; overflow:hidden;\n        box-shadow: inset 0 1px 0 rgba(0,0,0,0.03);\n      \">\n        <button type=\"button\" data-confirma=\"si\" aria-pressed=\"true\" style=\"\n          padding:10px 14px; border:none; background:${color}; color:#fff; font-weight:600; cursor:pointer;\n        \">Sí, voy</button>\n        <button type=\"button\" data-confirma=\"no\" aria-pressed=\"false\" style=\"\n          padding:10px 14px; border:none; background:#f6f6f6; color:#444; cursor:pointer;\n        \">No puedo</button>\n      </div>\n    </div>\n\n    <div style=\"display:flex; justify-content:flex-end; gap:10px; margin-top:16px;\">\n      <button id=\"rsvp-cancel\" style=\"padding:8px 12px; border-radius:6px; border:1px solid #ddd; background:#f3f3f3; cursor:pointer;\">Cancelar</button>\n      <button id=\"rsvp-send\" style=\"padding:8px 12px; border-radius:6px; border:none; color:#fff; cursor:pointer; background:${color};\">${btnText}</button>\n    </div>\n  </div>\n</div>\n\n<script>\ndocument.addEventListener('DOMContentLoaded', function () {\n\nfunction getSlugDePagina() {\n  // 0) Log de ayuda\n  try { console.log(\"[RSVP] href:\", location.href); } catch (e) {}\n\n  // 1) <html data-slug=\"...\"> (si lo inyectás en el HTML final)\n  const ds = document.documentElement?.dataset?.slug;\n  if (ds) {\n    console.log(\"[RSVP] slug por data-atributo:\", ds);\n    return ds;\n  }\n\n  // 2) ?slug=... en la URL\n  const q = new URLSearchParams(location.search).get(\"slug\");\n  if (q) {\n    console.log(\"[RSVP] slug por querystring:\", q);\n    return q;\n  }\n\n  // 3) /publicadas/<slug>/... en un sitio estático (Hosting/Proxy)\n  const parts = location.pathname.split(\"/\").filter(Boolean);\n  const i = parts.indexOf(\"publicadas\");\n  if (i >= 0 && parts[i + 1]) {\n    console.log(\"[RSVP] slug por pathname directo:\", parts[i + 1]);\n    return parts[i + 1];\n  }\n\n  // 4) URL de Firebase Storage:\n  //    https://firebasestorage.googleapis.com/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media&token=...\n  //    https://<bucket>.firebasestorage.app/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media\n  try {\n    const pathAfterO = location.pathname.split(\"/o/\")[1]; // \"publicadas%2F<slug>%2Findex.html\"\n    if (pathAfterO) {\n      const decoded = decodeURIComponent(pathAfterO);      // \"publicadas/<slug>/index.html\"\n      const segs = decoded.split(\"/\").filter(Boolean);\n      const j = segs.indexOf(\"publicadas\");\n      if (j >= 0 && segs[j + 1]) {\n        console.log(\"[RSVP] slug por URL de Storage:\", segs[j + 1]);\n        return segs[j + 1];\n      }\n    }\n  } catch (e) {\n    console.warn(\"[RSVP] Error parseando URL de Storage:\", e);\n  }\n\n  console.warn(\"[RSVP] No se pudo detectar slug. Fallback: sin-slug\");\n  return \"sin-slug\";\n}\n\n\n  var modal = document.getElementById('modal-rsvp');\n  if (!modal) return;\n\n  function openModal() { \n  modal.style.display = 'flex'; \n  // 🔁 Reset visual y estado cada vez que se abre\n  setConfirmaUI(\"si\", ${JSON.stringify(color)});\n}\n\n  function closeModal() { modal.style.display = 'none'; }\n\n  // Botones internos\n  var closeBtn = document.getElementById('rsvp-close');\n  var cancelBtn = document.getElementById('rsvp-cancel');\n  var sendBtn = document.getElementById('rsvp-send');\n\n  if (closeBtn) closeBtn.addEventListener('click', closeModal);\n  if (cancelBtn) cancelBtn.addEventListener('click', closeModal);\n\n  // Click fuera del cuadro\n  modal.addEventListener('click', function(e) {\n    if (e.target === modal) closeModal();\n  });\n\n  // Abridores: cualquier elemento con data-rsvp-open\ndocument.querySelectorAll('[data-rsvp-open], [data-accion=\"abrir-rsvp\"], .rsvp-boton').forEach(function(el) {\n    el.addEventListener('click', function(e) {\n      e.preventDefault();\n      openModal();\n    });\n  });\n\n\n// Estado interno del selector Sí/No\nvar confirmaValor = \"si\"; // default\n\nfunction setConfirmaUI(valor, color) {\n  var cont = document.getElementById('rsvp-confirma');\n  if (!cont) return;\n  var btnSi = cont.querySelector('[data-confirma=\"si\"]');\n  var btnNo = cont.querySelector('[data-confirma=\"no\"]');\n  confirmaValor = (valor === \"no\") ? \"no\" : \"si\";\n\n  if (btnSi && btnNo) {\n    if (confirmaValor === \"si\") {\n      btnSi.style.background = color;\n      btnSi.style.color = \"#fff\";\n      btnSi.setAttribute(\"aria-pressed\", \"true\");\n\n      btnNo.style.background = \"#f6f6f6\";\n      btnNo.style.color = \"#444\";\n      btnNo.setAttribute(\"aria-pressed\", \"false\");\n    } else {\n      btnNo.style.background = color;\n      btnNo.style.color = \"#fff\";\n      btnNo.setAttribute(\"aria-pressed\", \"true\");\n\n      btnSi.style.background = \"#f6f6f6\";\n      btnSi.style.color = \"#444\";\n      btnSi.setAttribute(\"aria-pressed\", \"false\");\n    }\n  }\n}\n\n// 🔹 Dejar \"Sí\" seleccionado al cargar\nsetConfirmaUI(\"si\", ${JSON.stringify(color)});\n\n// 🔹 Alternar selección al click\nvar confirmaWrap = document.getElementById('rsvp-confirma');\nif (confirmaWrap) {\n  confirmaWrap.addEventListener('click', function(e) {\n    var btn = e.target.closest('[data-confirma]');\n    if (!btn) return;\n    var v = btn.getAttribute('data-confirma');\n    setConfirmaUI(v, ${JSON.stringify(color)});\n    try { console.log(\"[RSVP] cambia confirmaValor =\", v); } catch(_) {}\n  });\n}\n\n\n\n  // ✅ Envío con Firestore + logs\nif (sendBtn) {\n  sendBtn.addEventListener('click', function() {\n    var nombre = (document.getElementById('rsvp-nombre') || {}).value || '';\n    var mensaje = (document.getElementById('rsvp-mensaje') || {}).value || '';\n\n    if (!nombre.trim()) {\n      alert('Por favor ingresá tu nombre.');\n      return;\n    }\n\n    const confirma = (confirmaValor === \"si\"); \n    const slug = getSlugDePagina();\n    console.log(\"[RSVP] Enviando RSVP… slug =\", slug);\n\n    // (opcional) si seguís usando sheetUrl, mantenemos el POST “en paralelo”\n    var sheetUrl = ${JSON.stringify(cfg.sheetUrl || \"\")};\n    if (sheetUrl) {\n      try {\n        fetch(sheetUrl, {\n          method: 'POST',\n          headers: {'Content-Type':'application/json'},\n          body: JSON.stringify({\n            nombre: nombre.trim(),\n            mensaje: mensaje.trim(),\n            slug: slug,\n            ts: Date.now()\n          })\n        }).catch(function(e){ console.warn(\"[RSVP] sheetUrl error:\", e); });\n      } catch (e) {\n        console.warn(\"[RSVP] sheetUrl throw:\", e);\n      }\n    }\n\n    // 🔌 Importar Firebase dinámicamente y guardar en Firestore\n    Promise.all([\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js\"),\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js\"),\n    ])\n    .then(([appMod, fsMod]) => {\n      const { initializeApp } = appMod;\n      const { getFirestore, collection, addDoc, serverTimestamp } = fsMod;\n\n      // ⚙️ Config mínima (apiKey y projectId son suficientes para el cliente)\n      const firebaseConfig = {\n        apiKey: \"AIzaSyALCvU48_HRp26cXpQcTX5S33Adpwfl3z4\",\n        authDomain: \"reservaeldia.com.ar\",\n        projectId: \"reservaeldia-7a440\",\n        appId: \"1:860495975406:web:3a49ad0cf55d60313534ff\"\n      };\n\n      const app = initializeApp(firebaseConfig);\n      const db  = getFirestore(app);\n\n      const payload = {\n        nombre: nombre.trim(),\n        mensaje: (mensaje && mensaje.trim()) || null,\n        confirma,\n        createdAt: serverTimestamp(),\n        userAgent: navigator.userAgent.slice(0, 512)\n      };\n\n      console.log(\"[RSVP] Payload keys =\", Object.keys(payload));\n      console.log(\"[RSVP] Payload =\", JSON.stringify(payload));\n\n      return addDoc(collection(db, \"publicadas\", slug, \"rsvps\"), payload);\n    })\n    .then((docRef) => {\n      console.log(\"[RSVP] RSVP guardado con ID:\", docRef.id, \"en /publicadas/\"+slug+\"/rsvps\");\n      alert('¡Gracias por confirmar tu asistencia, ' + nombre + '!');\n      closeModal();\n    })\n    .catch((err) => {\n      console.error(\"[RSVP] Error guardando en Firestore:\", err);\n      alert('Hubo un error al guardar tu confirmación. Probá de nuevo.');\n    });\n  });\n}\n \n  \n\n});\n</script>\n`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsUlNWUC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMENBQTBDO0FBV25DLFNBQVNBLHFCQUFxQkMsR0FBZTtJQUNoRCxJQUFJLENBQUNBLEtBQUtDLFNBQVMsT0FBTztJQUUxQixNQUFNQyxRQUFRRixJQUFJRSxLQUFLLElBQUk7SUFDM0IsTUFBTUMsV0FBV0gsSUFBSUcsUUFBUSxJQUFJO0lBQ2pDLE1BQU1DLFVBQVVKLElBQUlLLFVBQVUsSUFBSTtJQUNsQyxNQUFNQyxRQUFRTixJQUFJTyxZQUFZLElBQUk7SUFFbEMsK0RBQStEO0lBQy9ELGtDQUFrQztJQUNsQyxPQUFPLENBQUM7Ozs7Ozs7Ozs0Q0FTZ0MsRUFBRUwsTUFBTTs7O0lBR2hELEVBQUVDLFdBQVcsQ0FBQywwQ0FBMEMsRUFBRUEsU0FBUyxJQUFJLENBQUMsR0FBRyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7cURBZTdCLEVBQUVHLE1BQU07Ozs7Ozs7Ozs7NkhBVWdFLEVBQUVBLE1BQU0sR0FBRyxFQUFFRixRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBK0Q1SCxFQUFFSSxLQUFLQyxTQUFTLENBQUNILE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTJEMUIsRUFBRUUsS0FBS0MsU0FBUyxDQUFDSCxPQUFPOzs7Ozs7Ozs7cUJBU3ZCLEVBQUVFLEtBQUtDLFNBQVMsQ0FBQ0gsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBdUIxQixFQUFFRSxLQUFLQyxTQUFTLENBQUNULElBQUlVLFFBQVEsSUFBSSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUV4RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vZGFsUlNWUC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL2dlbmVyYXJNb2RhbFJTVlAudHNcclxuXHJcbmV4cG9ydCB0eXBlIFJTVlBDb25maWcgPSB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG4gICAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgICBzdWJ0aXRsZT86IHN0cmluZztcclxuICAgIGJ1dHRvblRleHQ/OiBzdHJpbmc7XHJcbiAgICBwcmltYXJ5Q29sb3I/OiBzdHJpbmc7IC8vIGNvbG9yIGRlbCBib3TDs24vY2FiZWNlcmFcclxuICAgIHNoZWV0VXJsPzogc3RyaW5nOyAgICAgLy8gb3BjaW9uYWwgc2kgdmFzIGEgZW52aWFyIGEgR29vZ2xlIFNoZWV0cyBvIHNpbWlsYXJcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxSU1ZQSFRNTChjZmc6IFJTVlBDb25maWcpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFjZmc/LmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gY2ZnLnRpdGxlID8/IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIjtcclxuICAgIGNvbnN0IHN1YnRpdGxlID0gY2ZnLnN1YnRpdGxlID8/IFwiXCI7XHJcbiAgICBjb25zdCBidG5UZXh0ID0gY2ZnLmJ1dHRvblRleHQgPz8gXCJFbnZpYXJcIjtcclxuICAgIGNvbnN0IGNvbG9yID0gY2ZnLnByaW1hcnlDb2xvciA/PyBcIiM3NzNkYmVcIjtcclxuXHJcbiAgICAvLyBOb3RhOiBlbCBib3TDs24gcXVlIGFicmUgZWwgbW9kYWwgZGViZSB0ZW5lciBbZGF0YS1yc3ZwLW9wZW5dXHJcbiAgICAvLyAoZWwgbGlzdGVuZXIgZGUgYWJham8gbG8gYnVzY2EpXHJcbiAgICByZXR1cm4gYFxyXG48ZGl2IGlkPVwibW9kYWwtcnN2cFwiIHN0eWxlPVwiXHJcbiAgcG9zaXRpb246IGZpeGVkOyBpbnNldDogMDsgZGlzcGxheTpub25lO1xyXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjYpOyB6LWluZGV4OiA5OTk5O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyO1wiPlxyXG4gIDxkaXYgc3R5bGU9XCJcclxuICAgIGJhY2tncm91bmQ6ICNmZmY7IHdpZHRoOiA5MCU7IG1heC13aWR0aDogNDIwcHg7IGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICBwYWRkaW5nOiAyMHB4OyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgYm94LXNoYWRvdzogMCAxMHB4IDMwcHggcmdiYSgwLDAsMCwuMik7XCI+XHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOmNlbnRlcjtcIj5cclxuICAgICAgPGgyIHN0eWxlPVwibWFyZ2luOjA7IGZvbnQtc2l6ZToyMHB4O1wiPiR7dGl0bGV9PC9oMj5cclxuICAgICAgPGJ1dHRvbiBpZD1cInJzdnAtY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2VycmFyXCIgc3R5bGU9XCJib3JkZXI6bm9uZTsgYmFja2dyb3VuZDp0cmFuc3BhcmVudDsgZm9udC1zaXplOjE4cHg7IGN1cnNvcjpwb2ludGVyO1wiPuKclTwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICAke3N1YnRpdGxlID8gYDxwIHN0eWxlPVwibWFyZ2luOjhweCAwIDE2cHg7IGNvbG9yOiM1NTU7XCI+JHtzdWJ0aXRsZX08L3A+YCA6IFwiXCJ9XHJcblxyXG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDtcIj5cclxuICAgICAgPGlucHV0IGlkPVwicnN2cC1ub21icmVcIiBwbGFjZWhvbGRlcj1cIlR1IG5vbWJyZVwiIHN0eWxlPVwicGFkZGluZzoxMHB4OyBib3JkZXI6MXB4IHNvbGlkICNjY2M7IGJvcmRlci1yYWRpdXM6NnB4O1wiIC8+XHJcbiAgICAgIDxpbnB1dCBpZD1cInJzdnAtbWVuc2FqZVwiIHBsYWNlaG9sZGVyPVwiTWVuc2FqZSAob3BjaW9uYWwpXCIgc3R5bGU9XCJwYWRkaW5nOjEwcHg7IGJvcmRlcjoxcHggc29saWQgI2NjYzsgYm9yZGVyLXJhZGl1czo2cHg7XCIgLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgICA8IS0tIOKchSBOVUVWTzogc2VsZWN0b3IgU8OtL05vIGNvbiBlc3RpbG8gc2VnbWVudGFkbyAtLT5cclxuICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tdG9wOjEycHg7XCI+XHJcbiAgICAgIDxsYWJlbCBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IGZvbnQtd2VpZ2h0OjYwMDsgbWFyZ2luLWJvdHRvbTo4cHg7XCI+wr9Db25maXJtw6FzIGFzaXN0ZW5jaWE/PC9sYWJlbD5cclxuICAgICAgPGRpdiBpZD1cInJzdnAtY29uZmlybWFcIiBzdHlsZT1cIlxyXG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWZsZXg7IGdhcDowOyBib3JkZXI6MXB4IHNvbGlkICNkZGQ7IGJvcmRlci1yYWRpdXM6MTBweDsgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgwLDAsMCwwLjAzKTtcclxuICAgICAgXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1jb25maXJtYT1cInNpXCIgYXJpYS1wcmVzc2VkPVwidHJ1ZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6JHtjb2xvcn07IGNvbG9yOiNmZmY7IGZvbnQtd2VpZ2h0OjYwMDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+U8OtLCB2b3k8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWNvbmZpcm1hPVwibm9cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6I2Y2ZjZmNjsgY29sb3I6IzQ0NDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+Tm8gcHVlZG88L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7IGdhcDoxMHB4OyBtYXJnaW4tdG9wOjE2cHg7XCI+XHJcbiAgICAgIDxidXR0b24gaWQ9XCJyc3ZwLWNhbmNlbFwiIHN0eWxlPVwicGFkZGluZzo4cHggMTJweDsgYm9yZGVyLXJhZGl1czo2cHg7IGJvcmRlcjoxcHggc29saWQgI2RkZDsgYmFja2dyb3VuZDojZjNmM2YzOyBjdXJzb3I6cG9pbnRlcjtcIj5DYW5jZWxhcjwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGlkPVwicnN2cC1zZW5kXCIgc3R5bGU9XCJwYWRkaW5nOjhweCAxMnB4OyBib3JkZXItcmFkaXVzOjZweDsgYm9yZGVyOm5vbmU7IGNvbG9yOiNmZmY7IGN1cnNvcjpwb2ludGVyOyBiYWNrZ3JvdW5kOiR7Y29sb3J9O1wiPiR7YnRuVGV4dH08L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5mdW5jdGlvbiBnZXRTbHVnRGVQYWdpbmEoKSB7XHJcbiAgLy8gMCkgTG9nIGRlIGF5dWRhXHJcbiAgdHJ5IHsgY29uc29sZS5sb2coXCJbUlNWUF0gaHJlZjpcIiwgbG9jYXRpb24uaHJlZik7IH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIC8vIDEpIDxodG1sIGRhdGEtc2x1Zz1cIi4uLlwiPiAoc2kgbG8gaW55ZWN0w6FzIGVuIGVsIEhUTUwgZmluYWwpXHJcbiAgY29uc3QgZHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/LmRhdGFzZXQ/LnNsdWc7XHJcbiAgaWYgKGRzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBkYXRhLWF0cmlidXRvOlwiLCBkcyk7XHJcbiAgICByZXR1cm4gZHM7XHJcbiAgfVxyXG5cclxuICAvLyAyKSA/c2x1Zz0uLi4gZW4gbGEgVVJMXHJcbiAgY29uc3QgcSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKS5nZXQoXCJzbHVnXCIpO1xyXG4gIGlmIChxKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBxdWVyeXN0cmluZzpcIiwgcSk7XHJcbiAgICByZXR1cm4gcTtcclxuICB9XHJcblxyXG4gIC8vIDMpIC9wdWJsaWNhZGFzLzxzbHVnPi8uLi4gZW4gdW4gc2l0aW8gZXN0w6F0aWNvIChIb3N0aW5nL1Byb3h5KVxyXG4gIGNvbnN0IHBhcnRzID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcclxuICBjb25zdCBpID0gcGFydHMuaW5kZXhPZihcInB1YmxpY2FkYXNcIik7XHJcbiAgaWYgKGkgPj0gMCAmJiBwYXJ0c1tpICsgMV0pIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIHBhdGhuYW1lIGRpcmVjdG86XCIsIHBhcnRzW2kgKyAxXSk7XHJcbiAgICByZXR1cm4gcGFydHNbaSArIDFdO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgVVJMIGRlIEZpcmViYXNlIFN0b3JhZ2U6XHJcbiAgLy8gICAgaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYSZ0b2tlbj0uLi5cclxuICAvLyAgICBodHRwczovLzxidWNrZXQ+LmZpcmViYXNlc3RvcmFnZS5hcHAvdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXRoQWZ0ZXJPID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvby9cIilbMV07IC8vIFwicHVibGljYWRhcyUyRjxzbHVnPiUyRmluZGV4Lmh0bWxcIlxyXG4gICAgaWYgKHBhdGhBZnRlck8pIHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXRoQWZ0ZXJPKTsgICAgICAvLyBcInB1YmxpY2FkYXMvPHNsdWc+L2luZGV4Lmh0bWxcIlxyXG4gICAgICBjb25zdCBzZWdzID0gZGVjb2RlZC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICBjb25zdCBqID0gc2Vncy5pbmRleE9mKFwicHVibGljYWRhc1wiKTtcclxuICAgICAgaWYgKGogPj0gMCAmJiBzZWdzW2ogKyAxXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIFVSTCBkZSBTdG9yYWdlOlwiLCBzZWdzW2ogKyAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiW1JTVlBdIEVycm9yIHBhcnNlYW5kbyBVUkwgZGUgU3RvcmFnZTpcIiwgZSk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLndhcm4oXCJbUlNWUF0gTm8gc2UgcHVkbyBkZXRlY3RhciBzbHVnLiBGYWxsYmFjazogc2luLXNsdWdcIik7XHJcbiAgcmV0dXJuIFwic2luLXNsdWdcIjtcclxufVxyXG5cclxuXHJcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsLXJzdnAnKTtcclxuICBpZiAoIW1vZGFsKSByZXR1cm47XHJcblxyXG4gIGZ1bmN0aW9uIG9wZW5Nb2RhbCgpIHsgXHJcbiAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgXHJcbiAgLy8g8J+UgSBSZXNldCB2aXN1YWwgeSBlc3RhZG8gY2FkYSB2ZXogcXVlIHNlIGFicmVcclxuICBzZXRDb25maXJtYVVJKFwic2lcIiwgJHtKU09OLnN0cmluZ2lmeShjb2xvcil9KTtcclxufVxyXG5cclxuICBmdW5jdGlvbiBjbG9zZU1vZGFsKCkgeyBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9XHJcblxyXG4gIC8vIEJvdG9uZXMgaW50ZXJub3NcclxuICB2YXIgY2xvc2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jbG9zZScpO1xyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jYW5jZWwnKTtcclxuICB2YXIgc2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLXNlbmQnKTtcclxuXHJcbiAgaWYgKGNsb3NlQnRuKSBjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG4gIGlmIChjYW5jZWxCdG4pIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG5cclxuICAvLyBDbGljayBmdWVyYSBkZWwgY3VhZHJvXHJcbiAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgPT09IG1vZGFsKSBjbG9zZU1vZGFsKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEFicmlkb3JlczogY3VhbHF1aWVyIGVsZW1lbnRvIGNvbiBkYXRhLXJzdnAtb3BlblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yc3ZwLW9wZW5dLCBbZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJdLCAucnN2cC1ib3RvbicpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIG9wZW5Nb2RhbCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG5cclxuLy8gRXN0YWRvIGludGVybm8gZGVsIHNlbGVjdG9yIFPDrS9Ob1xyXG52YXIgY29uZmlybWFWYWxvciA9IFwic2lcIjsgLy8gZGVmYXVsdFxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlybWFVSSh2YWxvciwgY29sb3IpIHtcclxuICB2YXIgY29udCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbiAgaWYgKCFjb250KSByZXR1cm47XHJcbiAgdmFyIGJ0blNpID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cInNpXCJdJyk7XHJcbiAgdmFyIGJ0bk5vID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cIm5vXCJdJyk7XHJcbiAgY29uZmlybWFWYWxvciA9ICh2YWxvciA9PT0gXCJub1wiKSA/IFwibm9cIiA6IFwic2lcIjtcclxuXHJcbiAgaWYgKGJ0blNpICYmIGJ0bk5vKSB7XHJcbiAgICBpZiAoY29uZmlybWFWYWxvciA9PT0gXCJzaVwiKSB7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcjtcclxuICAgICAgYnRuU2kuc3R5bGUuY29sb3IgPSBcIiNmZmZcIjtcclxuICAgICAgYnRuU2kuc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKTtcclxuXHJcbiAgICAgIGJ0bk5vLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgYnRuTm8uc3R5bGUuY29sb3IgPSBcIiM0NDRcIjtcclxuICAgICAgYnRuTm8uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidG5Oby5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3I7XHJcbiAgICAgIGJ0bk5vLnN0eWxlLmNvbG9yID0gXCIjZmZmXCI7XHJcbiAgICAgIGJ0bk5vLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XHJcblxyXG4gICAgICBidG5TaS5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZjZmNmY2XCI7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmNvbG9yID0gXCIjNDQ0XCI7XHJcbiAgICAgIGJ0blNpLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+UuSBEZWphciBcIlPDrVwiIHNlbGVjY2lvbmFkbyBhbCBjYXJnYXJcclxuc2V0Q29uZmlybWFVSShcInNpXCIsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcblxyXG4vLyDwn5S5IEFsdGVybmFyIHNlbGVjY2nDs24gYWwgY2xpY2tcclxudmFyIGNvbmZpcm1hV3JhcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbmlmIChjb25maXJtYVdyYXApIHtcclxuICBjb25maXJtYVdyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgYnRuID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtY29uZmlybWFdJyk7XHJcbiAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG4gICAgdmFyIHYgPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm1hJyk7XHJcbiAgICBzZXRDb25maXJtYVVJKHYsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcbiAgICB0cnkgeyBjb25zb2xlLmxvZyhcIltSU1ZQXSBjYW1iaWEgY29uZmlybWFWYWxvciA9XCIsIHYpOyB9IGNhdGNoKF8pIHt9XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICAvLyDinIUgRW52w61vIGNvbiBGaXJlc3RvcmUgKyBsb2dzXHJcbmlmIChzZW5kQnRuKSB7XHJcbiAgc2VuZEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5vbWJyZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1ub21icmUnKSB8fCB7fSkudmFsdWUgfHwgJyc7XHJcbiAgICB2YXIgbWVuc2FqZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1tZW5zYWplJykgfHwge30pLnZhbHVlIHx8ICcnO1xyXG5cclxuICAgIGlmICghbm9tYnJlLnRyaW0oKSkge1xyXG4gICAgICBhbGVydCgnUG9yIGZhdm9yIGluZ3Jlc8OhIHR1IG5vbWJyZS4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpcm1hID0gKGNvbmZpcm1hVmFsb3IgPT09IFwic2lcIik7IFxyXG4gICAgY29uc3Qgc2x1ZyA9IGdldFNsdWdEZVBhZ2luYSgpO1xyXG4gICAgY29uc29sZS5sb2coXCJbUlNWUF0gRW52aWFuZG8gUlNWUOKApiBzbHVnID1cIiwgc2x1Zyk7XHJcblxyXG4gICAgLy8gKG9wY2lvbmFsKSBzaSBzZWd1w61zIHVzYW5kbyBzaGVldFVybCwgbWFudGVuZW1vcyBlbCBQT1NUIOKAnGVuIHBhcmFsZWxv4oCdXHJcbiAgICB2YXIgc2hlZXRVcmwgPSAke0pTT04uc3RyaW5naWZ5KGNmZy5zaGVldFVybCB8fCBcIlwiKX07XHJcbiAgICBpZiAoc2hlZXRVcmwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmZXRjaChzaGVldFVybCwge1xyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgbm9tYnJlOiBub21icmUudHJpbSgpLFxyXG4gICAgICAgICAgICBtZW5zYWplOiBtZW5zYWplLnRyaW0oKSxcclxuICAgICAgICAgICAgc2x1Zzogc2x1ZyxcclxuICAgICAgICAgICAgdHM6IERhdGUubm93KClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSl7IGNvbnNvbGUud2FybihcIltSU1ZQXSBzaGVldFVybCBlcnJvcjpcIiwgZSk7IH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1JTVlBdIHNoZWV0VXJsIHRocm93OlwiLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIPCflIwgSW1wb3J0YXIgRmlyZWJhc2UgZGluw6FtaWNhbWVudGUgeSBndWFyZGFyIGVuIEZpcmVzdG9yZVxyXG4gICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtYXBwLmpzXCIpLFxyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtZmlyZXN0b3JlLmpzXCIpLFxyXG4gICAgXSlcclxuICAgIC50aGVuKChbYXBwTW9kLCBmc01vZF0pID0+IHtcclxuICAgICAgY29uc3QgeyBpbml0aWFsaXplQXBwIH0gPSBhcHBNb2Q7XHJcbiAgICAgIGNvbnN0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCB9ID0gZnNNb2Q7XHJcblxyXG4gICAgICAvLyDimpnvuI8gQ29uZmlnIG3DrW5pbWEgKGFwaUtleSB5IHByb2plY3RJZCBzb24gc3VmaWNpZW50ZXMgcGFyYSBlbCBjbGllbnRlKVxuICAgICAgY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gICAgICAgIGFwaUtleTogXCJBSXphU3lBTEN2VTQ4X0hScDI2Y1hwUWNUWDVTMzNBZHB3ZmwzejRcIixcbiAgICAgICAgYXV0aERvbWFpbjogXCJyZXNlcnZhZWxkaWEuY29tLmFyXCIsXG4gICAgICAgIHByb2plY3RJZDogXCJyZXNlcnZhZWxkaWEtN2E0NDBcIixcbiAgICAgICAgYXBwSWQ6IFwiMTo4NjA0OTU5NzU0MDY6d2ViOjNhNDlhZDBjZjU1ZDYwMzEzNTM0ZmZcIlxuICAgICAgfTtcblxyXG4gICAgICBjb25zdCBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcclxuICAgICAgY29uc3QgZGIgID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgIG5vbWJyZTogbm9tYnJlLnRyaW0oKSxcclxuICAgICAgICBtZW5zYWplOiAobWVuc2FqZSAmJiBtZW5zYWplLnRyaW0oKSkgfHwgbnVsbCxcclxuICAgICAgICBjb25maXJtYSxcclxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudC5zbGljZSgwLCA1MTIpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBQYXlsb2FkIGtleXMgPVwiLCBPYmplY3Qua2V5cyhwYXlsb2FkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFBheWxvYWQgPVwiLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcblxyXG4gICAgICByZXR1cm4gYWRkRG9jKGNvbGxlY3Rpb24oZGIsIFwicHVibGljYWRhc1wiLCBzbHVnLCBcInJzdnBzXCIpLCBwYXlsb2FkKTtcclxuICAgIH0pXHJcbiAgICAudGhlbigoZG9jUmVmKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFJTVlAgZ3VhcmRhZG8gY29uIElEOlwiLCBkb2NSZWYuaWQsIFwiZW4gL3B1YmxpY2FkYXMvXCIrc2x1ZytcIi9yc3Zwc1wiKTtcclxuICAgICAgYWxlcnQoJ8KhR3JhY2lhcyBwb3IgY29uZmlybWFyIHR1IGFzaXN0ZW5jaWEsICcgKyBub21icmUgKyAnIScpO1xyXG4gICAgICBjbG9zZU1vZGFsKCk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltSU1ZQXSBFcnJvciBndWFyZGFuZG8gZW4gRmlyZXN0b3JlOlwiLCBlcnIpO1xyXG4gICAgICBhbGVydCgnSHVibyB1biBlcnJvciBhbCBndWFyZGFyIHR1IGNvbmZpcm1hY2nDs24uIFByb2LDoSBkZSBudWV2by4nKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbiBcclxuICBcclxuXHJcbn0pO1xyXG48L3NjcmlwdD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhck1vZGFsUlNWUEhUTUwiLCJjZmciLCJlbmFibGVkIiwidGl0bGUiLCJzdWJ0aXRsZSIsImJ0blRleHQiLCJidXR0b25UZXh0IiwiY29sb3IiLCJwcmltYXJ5Q29sb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hlZXRVcmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarModalRSVP.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/generarMotionEffectsRuntime.ts":
/*!************************************************************!*\
  !*** ./functions/src/utils/generarMotionEffectsRuntime.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarMotionEffectsRuntimeHTML: () => (/* binding */ generarMotionEffectsRuntimeHTML)\n/* harmony export */ });\nfunction generarMotionEffectsRuntimeHTML() {\n    return `\n<style>\n  .mefx-preparing .mefx-reveal-init,\n  .mefx-preparing .mefx-zoom-init,\n  .mefx-preparing .mefx-draw-init,\n  .mefx-preparing .mefx-stagger-item {\n    transition: none !important;\n  }\n\n  .mefx-reveal-init {\n    opacity: 0;\n    translate: 0 14px;\n    will-change: opacity, translate;\n    transition:\n      opacity 640ms cubic-bezier(0.22, 1, 0.36, 1),\n      translate 640ms cubic-bezier(0.22, 1, 0.36, 1);\n  }\n\n  .mefx-reveal-on {\n    opacity: 1;\n    translate: 0 0;\n  }\n\n  .mefx-zoom-init {\n    opacity: 0;\n    scale: 0.98;\n    transform-origin: center center;\n    will-change: opacity, scale;\n    transition:\n      opacity 620ms cubic-bezier(0.22, 1, 0.36, 1),\n      scale 760ms cubic-bezier(0.22, 1, 0.36, 1);\n  }\n\n  .mefx-zoom-on {\n    opacity: 1;\n    scale: 1;\n  }\n\n  .mefx-draw-init {\n    opacity: 0.95;\n    scale: 0 1;\n    transform-origin: left center;\n    will-change: scale;\n    transition:\n      opacity 520ms ease,\n      scale 800ms cubic-bezier(0.2, 0.8, 0.2, 1);\n  }\n\n  .mefx-draw-on {\n    opacity: 1;\n    scale: 1 1;\n  }\n\n  .mefx-hover {\n    cursor: pointer;\n    transform-origin: center center;\n    will-change: scale, opacity;\n    transition:\n      scale 230ms ease,\n      opacity 230ms ease;\n  }\n\n  .mefx-hover:hover {\n    scale: 1.01;\n  }\n\n  .mefx-hover:active {\n    scale: 0.99;\n  }\n\n  .mefx-hover:focus-visible {\n    outline: 2px solid rgba(119, 61, 190, 0.34);\n    outline-offset: 2px;\n  }\n\n  @keyframes mefxPulse {\n    0%, 100% {\n      opacity: 1;\n      filter: none;\n    }\n    50% {\n      opacity: 0.9;\n      filter: saturate(1.03);\n    }\n  }\n\n  @keyframes mefxPulseCountdownChip {\n    0%, 100% {\n      transform: translateY(0) scale(1);\n      box-shadow: 0 0 0 rgba(17, 24, 39, 0);\n    }\n    50% {\n      transform: translateY(-1px) scale(1.018);\n      box-shadow: 0 8px 16px rgba(17, 24, 39, 0.14);\n    }\n  }\n\n  .mefx-pulse {\n    animation: mefxPulse 2.6s ease-in-out infinite;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip {\n    animation: mefxPulseCountdownChip 2.6s ease-in-out infinite;\n    transform-origin: center center;\n    will-change: transform, box-shadow;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(1) {\n    animation-delay: 0ms;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(2) {\n    animation-delay: 90ms;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(3) {\n    animation-delay: 180ms;\n  }\n\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(4) {\n    animation-delay: 270ms;\n  }\n\n  .mefx-stagger-item {\n    opacity: 0;\n    translate: 0 10px;\n    will-change: translate, opacity;\n    transition:\n      opacity 620ms cubic-bezier(0.22, 1, 0.36, 1),\n      translate 620ms cubic-bezier(0.22, 1, 0.36, 1);\n    transition-delay: var(--mefx-stagger-delay, 0ms);\n  }\n\n  .mefx-stagger-item.mefx-stagger-on {\n    opacity: 1;\n    translate: 0 0;\n  }\n\n  @keyframes mefxRevealMobileIn {\n    from {\n      opacity: 0;\n      translate: 0 10px;\n    }\n    to {\n      opacity: 1;\n      translate: 0 0;\n    }\n  }\n\n  @keyframes mefxZoomMobileIn {\n    from {\n      opacity: 0;\n      scale: 0.99;\n    }\n    to {\n      opacity: 1;\n      scale: 1;\n    }\n  }\n\n  @keyframes mefxDrawMobileIn {\n    from {\n      opacity: 0.95;\n      scale: 0 1;\n    }\n    to {\n      opacity: 1;\n      scale: 1 1;\n    }\n  }\n\n  @media (max-width: 767px) {\n    .mefx-reveal-init {\n      translate: 0 10px;\n      transition-duration: 540ms;\n    }\n\n    .mefx-zoom-init {\n      scale: 0.99;\n      transition-duration: 580ms;\n    }\n\n    .mefx-draw-init {\n      transition-duration: 640ms;\n    }\n\n    .mefx-stagger-item {\n      transition-duration: 540ms;\n    }\n\n    /* Fallback robusto mobile: cuando se agrega \"on\", forzamos keyframes */\n    .mefx-reveal-on {\n      animation: mefxRevealMobileIn 540ms cubic-bezier(0.22, 1, 0.36, 1) both;\n    }\n\n    .mefx-zoom-on {\n      animation: mefxZoomMobileIn 580ms cubic-bezier(0.22, 1, 0.36, 1) both;\n    }\n\n    .mefx-draw-on {\n      animation: mefxDrawMobileIn 640ms cubic-bezier(0.2, 0.8, 0.2, 1) both;\n    }\n\n    .mefx-stagger-item.mefx-stagger-on {\n      animation: mefxRevealMobileIn 540ms cubic-bezier(0.22, 1, 0.36, 1) both;\n      animation-delay: var(--mefx-stagger-delay, 0ms);\n    }\n  }\n\n  @media (prefers-reduced-motion: reduce) {\n    .mefx-reveal-init,\n    .mefx-zoom-init,\n    .mefx-draw-init,\n    .mefx-stagger-item {\n      opacity: 1 !important;\n      translate: 0 0 !important;\n      scale: 1 !important;\n      transition: none !important;\n    }\n\n    .mefx-pulse {\n      animation: none !important;\n    }\n\n    .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip {\n      animation: none !important;\n      transform: none !important;\n      box-shadow: none !important;\n    }\n  }\n</style>\n\n<script>\n(function(){\n  var VALID_EFFECTS = { none: 1, reveal: 1, draw: 1, zoom: 1, hover: 1, pulse: 1 };\n  var OBSERVED_EFFECTS = { reveal: 1, draw: 1, zoom: 1 };\n  var STAGGER_SELECTOR = \".galeria-celda\";\n  var PREPARING_CLASS = \"mefx-preparing\";\n  var RUNTIME_READY_EVENT = \"invitation-runtime-ready\";\n  var RUNTIME_FAIL_EVENT = \"invitation-runtime-failed\";\n  var LOADER_HIDDEN_EVENT = \"invitation-loader-hidden\";\n  var LOADER_WAIT_TIMEOUT_MS = 2400;\n  var READY_TIMEOUT_MS = 2600;\n  var FONTS_TIMEOUT_MS = 1200;\n  var bootStarted = false;\n\n  function normalizeEffect(value){\n    var normalized = String(value || \"\").trim().toLowerCase();\n    return VALID_EFFECTS[normalized] ? normalized : \"none\";\n  }\n\n  function normalizeType(value){\n    return String(value || \"\").trim().toLowerCase();\n  }\n\n  function setPreparingState(active){\n    if (!document.body || !document.body.classList) return;\n    if (active) {\n      document.body.classList.add(PREPARING_CLASS);\n      return;\n    }\n    document.body.classList.remove(PREPARING_CLASS);\n  }\n\n  function dispatchRuntimeEvent(name, detail){\n    try {\n      window.dispatchEvent(new CustomEvent(name, { detail: detail || {} }));\n    } catch (_error) {\n      // noop\n    }\n  }\n\n  function isReducedMotion(){\n    try {\n      return !!(window.matchMedia && window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches);\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  function waitForWindowLoad(maxWaitMs){\n    return new Promise(function(resolve){\n      if (document.readyState === \"complete\") {\n        resolve();\n        return;\n      }\n\n      var finished = false;\n      var onLoad = function(){\n        if (finished) return;\n        finished = true;\n        resolve();\n      };\n\n      window.addEventListener(\"load\", onLoad, { once: true });\n      window.setTimeout(function(){\n        if (finished) return;\n        finished = true;\n        resolve();\n      }, maxWaitMs);\n    });\n  }\n\n  function waitForFonts(maxWaitMs){\n    if (!document.fonts || !document.fonts.ready) {\n      return Promise.resolve();\n    }\n\n    return Promise.race([\n      document.fonts.ready.catch(function(){ return null; }),\n      new Promise(function(resolve){\n        window.setTimeout(resolve, maxWaitMs);\n      })\n    ]).then(function(){ return null; });\n  }\n\n  function waitForRuntimeReady(){\n    return Promise.all([\n      waitForWindowLoad(READY_TIMEOUT_MS),\n      waitForFonts(FONTS_TIMEOUT_MS)\n    ]).then(function(){ return null; });\n  }\n\n  function extractFirstUrl(value){\n    var raw = String(value || \"\");\n    if (!raw || raw === \"none\") return \"\";\n    var match = raw.match(/url\\((['\"]?)(.*?)\\\\1\\)/i);\n    if (!match || !match[2]) return \"\";\n    return match[2].trim();\n  }\n\n  function getFirstSectionBackgroundUrl(){\n    var firstSection = document.querySelector(\".sec\");\n    if (!firstSection) return \"\";\n    var bgNode = firstSection.querySelector(\".sec-bg\");\n    if (!bgNode) return \"\";\n\n    var inlineUrl = extractFirstUrl(bgNode.getAttribute(\"style\"));\n    if (inlineUrl) return inlineUrl;\n\n    try {\n      var computedUrl = extractFirstUrl(window.getComputedStyle(bgNode).backgroundImage);\n      return computedUrl;\n    } catch (_error) {\n      return \"\";\n    }\n  }\n\n  function loadImage(url){\n    return new Promise(function(resolve){\n      if (!url) {\n        resolve(true);\n        return;\n      }\n\n      var img = new Image();\n      img.decoding = \"async\";\n      img.loading = \"eager\";\n\n      img.onload = function(){\n        resolve(true);\n      };\n\n      img.onerror = function(){\n        resolve(false);\n      };\n\n      img.src = url;\n\n      if (img.complete && img.naturalWidth > 0) {\n        resolve(true);\n      }\n    });\n  }\n\n  function waitForFirstSectionBackground(){\n    var backgroundUrl = getFirstSectionBackgroundUrl();\n    return loadImage(backgroundUrl);\n  }\n\n  function waitForLoaderHidden(){\n    return new Promise(function(resolve){\n      var loaderNode = document.getElementById(\"inv-loader\");\n      if (!loaderNode) {\n        resolve();\n        return;\n      }\n\n      var finished = false;\n      function done(){\n        if (finished) return;\n        finished = true;\n        resolve();\n      }\n\n      window.addEventListener(LOADER_HIDDEN_EVENT, done, { once: true });\n      window.setTimeout(done, LOADER_WAIT_TIMEOUT_MS);\n    });\n  }\n\n  function prepareGalleryStagger(element){\n    var cells = Array.from(element.querySelectorAll(STAGGER_SELECTOR));\n    if (!cells.length) return [];\n\n    cells.forEach(function(cell, index){\n      var delayMs = Math.min(index, 11) * 70;\n      cell.style.setProperty(\"--mefx-stagger-delay\", delayMs + \"ms\");\n      cell.classList.add(\"mefx-stagger-item\");\n    });\n\n    return cells;\n  }\n\n  function prepareElement(element){\n    var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\n    var type = normalizeType(element.getAttribute(\"data-type\"));\n    element.setAttribute(\"data-motion\", effect);\n\n    if (effect === \"hover\") {\n      element.classList.add(\"mefx-hover\");\n    }\n\n    if (effect === \"pulse\" && (type === \"countdown\" || type === \"rsvp\")) {\n      element.classList.add(\"mefx-pulse\");\n    }\n\n    if (effect === \"reveal\") element.classList.add(\"mefx-reveal-init\");\n    if (effect === \"zoom\") element.classList.add(\"mefx-zoom-init\");\n    if (effect === \"draw\") element.classList.add(\"mefx-draw-init\");\n\n    if (type === \"gallery\" && effect === \"reveal\") {\n      prepareGalleryStagger(element);\n    }\n  }\n\n  function activateElement(element){\n    var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\n    var type = normalizeType(element.getAttribute(\"data-type\"));\n\n    if (effect === \"reveal\") element.classList.add(\"mefx-reveal-on\");\n    if (effect === \"zoom\") element.classList.add(\"mefx-zoom-on\");\n    if (effect === \"draw\") element.classList.add(\"mefx-draw-on\");\n\n    if (type === \"gallery\" && effect === \"reveal\") {\n      var staggerItems = Array.from(element.querySelectorAll(STAGGER_SELECTOR + \".mefx-stagger-item\"));\n      staggerItems.forEach(function(cell){\n        cell.classList.add(\"mefx-stagger-on\");\n      });\n    }\n  }\n\n  function boot(elements){\n    var list = Array.isArray(elements) ? elements : [];\n    if (!list.length) {\n      list = Array.from(document.querySelectorAll(\".objeto[data-motion]\"));\n    }\n\n    var elementsToAnimate = list;\n    if (!elementsToAnimate.length) return;\n\n    var reducedMotion = isReducedMotion();\n    if (reducedMotion || typeof IntersectionObserver === \"undefined\") {\n      setPreparingState(false);\n      elementsToAnimate.forEach(activateElement);\n      return;\n    }\n\n    // En mobile algunos navegadores colapsan \"quitar preparing + activar on\" en el mismo layout.\n    // Damos un frame para reactivar transiciones antes de observar/activar.\n    setPreparingState(false);\n    requestAnimationFrame(function(){\n      var queuedById = Object.create(null);\n      var queuedElements = [];\n      var activationReady = false;\n\n      function enqueueActivation(element){\n        if (!element || !element.getAttribute) return;\n        var key = element.getAttribute(\"data-motion-id\") || element.id || \"\";\n        if (!key) key = \"idx-\" + queuedElements.length;\n        if (queuedById[key]) return;\n        queuedById[key] = true;\n        queuedElements.push(element);\n      }\n\n      function activateOrQueue(element){\n        if (activationReady) {\n          activateElement(element);\n          return;\n        }\n        enqueueActivation(element);\n      }\n\n      var observer = new IntersectionObserver(\n        function(entries){\n          entries.forEach(function(entry){\n            if (!entry.isIntersecting) return;\n            activateOrQueue(entry.target);\n            observer.unobserve(entry.target);\n          });\n        },\n        {\n          root: null,\n          threshold: 0.16,\n          rootMargin: \"0px 0px -8% 0px\"\n        }\n      );\n\n      elementsToAnimate.forEach(function(element){\n        var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\n        if (OBSERVED_EFFECTS[effect]) {\n          observer.observe(element);\n          return;\n        }\n        activateOrQueue(element);\n      });\n\n      requestAnimationFrame(function(){\n        requestAnimationFrame(function(){\n          activationReady = true;\n          queuedElements.forEach(activateElement);\n          queuedElements = [];\n        });\n      });\n    });\n  }\n\n  function prepareAllElements(){\n    var elements = Array.from(document.querySelectorAll(\".objeto[data-motion]\"));\n    if (!elements.length) return;\n\n    setPreparingState(true);\n    elements.forEach(prepareElement);\n    return elements;\n  }\n\n  function startBoot(){\n    if (bootStarted) return;\n    bootStarted = true;\n\n    waitForRuntimeReady().then(function(){\n      waitForFirstSectionBackground().then(function(backgroundReady){\n        if (!backgroundReady) {\n          dispatchRuntimeEvent(RUNTIME_FAIL_EVENT, { reason: \"first-background-failed\" });\n          return;\n        }\n\n        var preparedElements = prepareAllElements() || [];\n        dispatchRuntimeEvent(RUNTIME_READY_EVENT, { source: \"motion-effects-runtime\" });\n        waitForLoaderHidden().then(function(){\n          requestAnimationFrame(function(){\n            requestAnimationFrame(function(){\n              boot(preparedElements);\n            });\n          });\n        });\n      });\n    });\n  }\n\n  startBoot();\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtqQlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWVIVE1MKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG48c3R5bGU+XG4gIC5tZWZ4LXByZXBhcmluZyAubWVmeC1yZXZlYWwtaW5pdCxcbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LXpvb20taW5pdCxcbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LWRyYXctaW5pdCxcbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICB9XG5cbiAgLm1lZngtcmV2ZWFsLWluaXQge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdHJhbnNsYXRlOiAwIDE0cHg7XG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHksIHRyYW5zbGF0ZTtcbiAgICB0cmFuc2l0aW9uOlxuICAgICAgb3BhY2l0eSA2NDBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSksXG4gICAgICB0cmFuc2xhdGUgNjQwbXMgY3ViaWMtYmV6aWVyKDAuMjIsIDEsIDAuMzYsIDEpO1xuICB9XG5cbiAgLm1lZngtcmV2ZWFsLW9uIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zbGF0ZTogMCAwO1xuICB9XG5cbiAgLm1lZngtem9vbS1pbml0IHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHNjYWxlOiAwLjk4O1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHksIHNjYWxlO1xuICAgIHRyYW5zaXRpb246XG4gICAgICBvcGFjaXR5IDYyMG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSxcbiAgICAgIHNjYWxlIDc2MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKTtcbiAgfVxuXG4gIC5tZWZ4LXpvb20tb24ge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgc2NhbGU6IDE7XG4gIH1cblxuICAubWVmeC1kcmF3LWluaXQge1xuICAgIG9wYWNpdHk6IDAuOTU7XG4gICAgc2NhbGU6IDAgMTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IGNlbnRlcjtcbiAgICB3aWxsLWNoYW5nZTogc2NhbGU7XG4gICAgdHJhbnNpdGlvbjpcbiAgICAgIG9wYWNpdHkgNTIwbXMgZWFzZSxcbiAgICAgIHNjYWxlIDgwMG1zIGN1YmljLWJlemllcigwLjIsIDAuOCwgMC4yLCAxKTtcbiAgfVxuXG4gIC5tZWZ4LWRyYXctb24ge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgc2NhbGU6IDEgMTtcbiAgfVxuXG4gIC5tZWZ4LWhvdmVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcbiAgICB3aWxsLWNoYW5nZTogc2NhbGUsIG9wYWNpdHk7XG4gICAgdHJhbnNpdGlvbjpcbiAgICAgIHNjYWxlIDIzMG1zIGVhc2UsXG4gICAgICBvcGFjaXR5IDIzMG1zIGVhc2U7XG4gIH1cblxuICAubWVmeC1ob3Zlcjpob3ZlciB7XG4gICAgc2NhbGU6IDEuMDE7XG4gIH1cblxuICAubWVmeC1ob3ZlcjphY3RpdmUge1xuICAgIHNjYWxlOiAwLjk5O1xuICB9XG5cbiAgLm1lZngtaG92ZXI6Zm9jdXMtdmlzaWJsZSB7XG4gICAgb3V0bGluZTogMnB4IHNvbGlkIHJnYmEoMTE5LCA2MSwgMTkwLCAwLjM0KTtcbiAgICBvdXRsaW5lLW9mZnNldDogMnB4O1xuICB9XG5cbiAgQGtleWZyYW1lcyBtZWZ4UHVsc2Uge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICBmaWx0ZXI6IG5vbmU7XG4gICAgfVxuICAgIDUwJSB7XG4gICAgICBvcGFjaXR5OiAwLjk7XG4gICAgICBmaWx0ZXI6IHNhdHVyYXRlKDEuMDMpO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeFB1bHNlQ291bnRkb3duQ2hpcCB7XG4gICAgMCUsIDEwMCUge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApIHNjYWxlKDEpO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDAgcmdiYSgxNywgMjQsIDM5LCAwKTtcbiAgICB9XG4gICAgNTAlIHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KSBzY2FsZSgxLjAxOCk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAxNnB4IHJnYmEoMTcsIDI0LCAzOSwgMC4xNCk7XG4gICAgfVxuICB9XG5cbiAgLm1lZngtcHVsc2Uge1xuICAgIGFuaW1hdGlvbjogbWVmeFB1bHNlIDIuNnMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwIHtcbiAgICBhbmltYXRpb246IG1lZnhQdWxzZUNvdW50ZG93bkNoaXAgMi42cyBlYXNlLWluLW91dCBpbmZpbml0ZTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm0sIGJveC1zaGFkb3c7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCgxKSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAwbXM7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCgyKSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiA5MG1zO1xuICB9XG5cbiAgLm9iamV0b1tkYXRhLXR5cGU9XCJjb3VudGRvd25cIl0ubWVmeC1wdWxzZSAuY2QtY2hpcDpudGgtY2hpbGQoMykge1xuICAgIGFuaW1hdGlvbi1kZWxheTogMTgwbXM7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCg0KSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAyNzBtcztcbiAgfVxuXG4gIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2xhdGU6IDAgMTBweDtcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNsYXRlLCBvcGFjaXR5O1xuICAgIHRyYW5zaXRpb246XG4gICAgICBvcGFjaXR5IDYyMG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSxcbiAgICAgIHRyYW5zbGF0ZSA2MjBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSk7XG4gICAgdHJhbnNpdGlvbi1kZWxheTogdmFyKC0tbWVmeC1zdGFnZ2VyLWRlbGF5LCAwbXMpO1xuICB9XG5cbiAgLm1lZngtc3RhZ2dlci1pdGVtLm1lZngtc3RhZ2dlci1vbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2xhdGU6IDAgMDtcbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeFJldmVhbE1vYmlsZUluIHtcbiAgICBmcm9tIHtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB0cmFuc2xhdGU6IDAgMTBweDtcbiAgICB9XG4gICAgdG8ge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIHRyYW5zbGF0ZTogMCAwO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeFpvb21Nb2JpbGVJbiB7XG4gICAgZnJvbSB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgICAgc2NhbGU6IDAuOTk7XG4gICAgfVxuICAgIHRvIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICBzY2FsZTogMTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIG1lZnhEcmF3TW9iaWxlSW4ge1xuICAgIGZyb20ge1xuICAgICAgb3BhY2l0eTogMC45NTtcbiAgICAgIHNjYWxlOiAwIDE7XG4gICAgfVxuICAgIHRvIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICBzY2FsZTogMSAxO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkge1xuICAgIC5tZWZ4LXJldmVhbC1pbml0IHtcbiAgICAgIHRyYW5zbGF0ZTogMCAxMHB4O1xuICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNTQwbXM7XG4gICAgfVxuXG4gICAgLm1lZngtem9vbS1pbml0IHtcbiAgICAgIHNjYWxlOiAwLjk5O1xuICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNTgwbXM7XG4gICAgfVxuXG4gICAgLm1lZngtZHJhdy1pbml0IHtcbiAgICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDY0MG1zO1xuICAgIH1cblxuICAgIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiA1NDBtcztcbiAgICB9XG5cbiAgICAvKiBGYWxsYmFjayByb2J1c3RvIG1vYmlsZTogY3VhbmRvIHNlIGFncmVnYSBcIm9uXCIsIGZvcnphbW9zIGtleWZyYW1lcyAqL1xuICAgIC5tZWZ4LXJldmVhbC1vbiB7XG4gICAgICBhbmltYXRpb246IG1lZnhSZXZlYWxNb2JpbGVJbiA1NDBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSkgYm90aDtcbiAgICB9XG5cbiAgICAubWVmeC16b29tLW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeFpvb21Nb2JpbGVJbiA1ODBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSkgYm90aDtcbiAgICB9XG5cbiAgICAubWVmeC1kcmF3LW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeERyYXdNb2JpbGVJbiA2NDBtcyBjdWJpYy1iZXppZXIoMC4yLCAwLjgsIDAuMiwgMSkgYm90aDtcbiAgICB9XG5cbiAgICAubWVmeC1zdGFnZ2VyLWl0ZW0ubWVmeC1zdGFnZ2VyLW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeFJldmVhbE1vYmlsZUluIDU0MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSBib3RoO1xuICAgICAgYW5pbWF0aW9uLWRlbGF5OiB2YXIoLS1tZWZ4LXN0YWdnZXItZGVsYXksIDBtcyk7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpIHtcbiAgICAubWVmeC1yZXZlYWwtaW5pdCxcbiAgICAubWVmeC16b29tLWluaXQsXG4gICAgLm1lZngtZHJhdy1pbml0LFxuICAgIC5tZWZ4LXN0YWdnZXItaXRlbSB7XG4gICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICB0cmFuc2xhdGU6IDAgMCAhaW1wb3J0YW50O1xuICAgICAgc2NhbGU6IDEgIWltcG9ydGFudDtcbiAgICAgIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAubWVmeC1wdWxzZSB7XG4gICAgICBhbmltYXRpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwIHtcbiAgICAgIGFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCl7XG4gIHZhciBWQUxJRF9FRkZFQ1RTID0geyBub25lOiAxLCByZXZlYWw6IDEsIGRyYXc6IDEsIHpvb206IDEsIGhvdmVyOiAxLCBwdWxzZTogMSB9O1xuICB2YXIgT0JTRVJWRURfRUZGRUNUUyA9IHsgcmV2ZWFsOiAxLCBkcmF3OiAxLCB6b29tOiAxIH07XG4gIHZhciBTVEFHR0VSX1NFTEVDVE9SID0gXCIuZ2FsZXJpYS1jZWxkYVwiO1xuICB2YXIgUFJFUEFSSU5HX0NMQVNTID0gXCJtZWZ4LXByZXBhcmluZ1wiO1xuICB2YXIgUlVOVElNRV9SRUFEWV9FVkVOVCA9IFwiaW52aXRhdGlvbi1ydW50aW1lLXJlYWR5XCI7XG4gIHZhciBSVU5USU1FX0ZBSUxfRVZFTlQgPSBcImludml0YXRpb24tcnVudGltZS1mYWlsZWRcIjtcbiAgdmFyIExPQURFUl9ISURERU5fRVZFTlQgPSBcImludml0YXRpb24tbG9hZGVyLWhpZGRlblwiO1xuICB2YXIgTE9BREVSX1dBSVRfVElNRU9VVF9NUyA9IDI0MDA7XG4gIHZhciBSRUFEWV9USU1FT1VUX01TID0gMjYwMDtcbiAgdmFyIEZPTlRTX1RJTUVPVVRfTVMgPSAxMjAwO1xuICB2YXIgYm9vdFN0YXJ0ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVFZmZlY3QodmFsdWUpe1xuICAgIHZhciBub3JtYWxpemVkID0gU3RyaW5nKHZhbHVlIHx8IFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBWQUxJRF9FRkZFQ1RTW25vcm1hbGl6ZWRdID8gbm9ybWFsaXplZCA6IFwibm9uZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVHlwZSh2YWx1ZSl7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSB8fCBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByZXBhcmluZ1N0YXRlKGFjdGl2ZSl7XG4gICAgaWYgKCFkb2N1bWVudC5ib2R5IHx8ICFkb2N1bWVudC5ib2R5LmNsYXNzTGlzdCkgcmV0dXJuO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChQUkVQQVJJTkdfQ0xBU1MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoUFJFUEFSSU5HX0NMQVNTKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoUnVudGltZUV2ZW50KG5hbWUsIGRldGFpbCl7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCB7IGRldGFpbDogZGV0YWlsIHx8IHt9IH0pKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZHVjZWRNb3Rpb24oKXtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhKHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvcldpbmRvd0xvYWQobWF4V2FpdE1zKXtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSl7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCBtYXhXYWl0TXMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvckZvbnRzKG1heFdhaXRNcyl7XG4gICAgaWYgKCFkb2N1bWVudC5mb250cyB8fCAhZG9jdW1lbnQuZm9udHMucmVhZHkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIGRvY3VtZW50LmZvbnRzLnJlYWR5LmNhdGNoKGZ1bmN0aW9uKCl7IHJldHVybiBudWxsOyB9KSxcbiAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCBtYXhXYWl0TXMpO1xuICAgICAgfSlcbiAgICBdKS50aGVuKGZ1bmN0aW9uKCl7IHJldHVybiBudWxsOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JSdW50aW1lUmVhZHkoKXtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgd2FpdEZvcldpbmRvd0xvYWQoUkVBRFlfVElNRU9VVF9NUyksXG4gICAgICB3YWl0Rm9yRm9udHMoRk9OVFNfVElNRU9VVF9NUylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKCl7IHJldHVybiBudWxsOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RGaXJzdFVybCh2YWx1ZSl7XG4gICAgdmFyIHJhdyA9IFN0cmluZyh2YWx1ZSB8fCBcIlwiKTtcbiAgICBpZiAoIXJhdyB8fCByYXcgPT09IFwibm9uZVwiKSByZXR1cm4gXCJcIjtcbiAgICB2YXIgbWF0Y2ggPSByYXcubWF0Y2goL3VybFxcKChbJ1wiXT8pKC4qPylcXFxcMVxcKS9pKTtcbiAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaFsyXSkgcmV0dXJuIFwiXCI7XG4gICAgcmV0dXJuIG1hdGNoWzJdLnRyaW0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0U2VjdGlvbkJhY2tncm91bmRVcmwoKXtcbiAgICB2YXIgZmlyc3RTZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zZWNcIik7XG4gICAgaWYgKCFmaXJzdFNlY3Rpb24pIHJldHVybiBcIlwiO1xuICAgIHZhciBiZ05vZGUgPSBmaXJzdFNlY3Rpb24ucXVlcnlTZWxlY3RvcihcIi5zZWMtYmdcIik7XG4gICAgaWYgKCFiZ05vZGUpIHJldHVybiBcIlwiO1xuXG4gICAgdmFyIGlubGluZVVybCA9IGV4dHJhY3RGaXJzdFVybChiZ05vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpO1xuICAgIGlmIChpbmxpbmVVcmwpIHJldHVybiBpbmxpbmVVcmw7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGNvbXB1dGVkVXJsID0gZXh0cmFjdEZpcnN0VXJsKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJnTm9kZSkuYmFja2dyb3VuZEltYWdlKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVybDtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpe1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKXtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLmRlY29kaW5nID0gXCJhc3luY1wiO1xuICAgICAgaW1nLmxvYWRpbmcgPSBcImVhZ2VyXCI7XG5cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH07XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG5cbiAgICAgIGlmIChpbWcuY29tcGxldGUgJiYgaW1nLm5hdHVyYWxXaWR0aCA+IDApIHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JGaXJzdFNlY3Rpb25CYWNrZ3JvdW5kKCl7XG4gICAgdmFyIGJhY2tncm91bmRVcmwgPSBnZXRGaXJzdFNlY3Rpb25CYWNrZ3JvdW5kVXJsKCk7XG4gICAgcmV0dXJuIGxvYWRJbWFnZShiYWNrZ3JvdW5kVXJsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JMb2FkZXJIaWRkZW4oKXtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSl7XG4gICAgICB2YXIgbG9hZGVyTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW52LWxvYWRlclwiKTtcbiAgICAgIGlmICghbG9hZGVyTm9kZSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBkb25lKCl7XG4gICAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoTE9BREVSX0hJRERFTl9FVkVOVCwgZG9uZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZG9uZSwgTE9BREVSX1dBSVRfVElNRU9VVF9NUyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlR2FsbGVyeVN0YWdnZXIoZWxlbWVudCl7XG4gICAgdmFyIGNlbGxzID0gQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU1RBR0dFUl9TRUxFQ1RPUikpO1xuICAgIGlmICghY2VsbHMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGluZGV4KXtcbiAgICAgIHZhciBkZWxheU1zID0gTWF0aC5taW4oaW5kZXgsIDExKSAqIDcwO1xuICAgICAgY2VsbC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbWVmeC1zdGFnZ2VyLWRlbGF5XCIsIGRlbGF5TXMgKyBcIm1zXCIpO1xuICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKFwibWVmeC1zdGFnZ2VyLWl0ZW1cIik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2VsbHM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlRWxlbWVudChlbGVtZW50KXtcbiAgICB2YXIgZWZmZWN0ID0gbm9ybWFsaXplRWZmZWN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb25cIikpO1xuICAgIHZhciB0eXBlID0gbm9ybWFsaXplVHlwZShlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1vdGlvblwiLCBlZmZlY3QpO1xuXG4gICAgaWYgKGVmZmVjdCA9PT0gXCJob3ZlclwiKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LWhvdmVyXCIpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3QgPT09IFwicHVsc2VcIiAmJiAodHlwZSA9PT0gXCJjb3VudGRvd25cIiB8fCB0eXBlID09PSBcInJzdnBcIikpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtcHVsc2VcIik7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdCA9PT0gXCJyZXZlYWxcIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC1yZXZlYWwtaW5pdFwiKTtcbiAgICBpZiAoZWZmZWN0ID09PSBcInpvb21cIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC16b29tLWluaXRcIik7XG4gICAgaWYgKGVmZmVjdCA9PT0gXCJkcmF3XCIpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtZHJhdy1pbml0XCIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZ2FsbGVyeVwiICYmIGVmZmVjdCA9PT0gXCJyZXZlYWxcIikge1xuICAgICAgcHJlcGFyZUdhbGxlcnlTdGFnZ2VyKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlRWxlbWVudChlbGVtZW50KXtcbiAgICB2YXIgZWZmZWN0ID0gbm9ybWFsaXplRWZmZWN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb25cIikpO1xuICAgIHZhciB0eXBlID0gbm9ybWFsaXplVHlwZShlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSk7XG5cbiAgICBpZiAoZWZmZWN0ID09PSBcInJldmVhbFwiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXJldmVhbC1vblwiKTtcbiAgICBpZiAoZWZmZWN0ID09PSBcInpvb21cIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC16b29tLW9uXCIpO1xuICAgIGlmIChlZmZlY3QgPT09IFwiZHJhd1wiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LWRyYXctb25cIik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJnYWxsZXJ5XCIgJiYgZWZmZWN0ID09PSBcInJldmVhbFwiKSB7XG4gICAgICB2YXIgc3RhZ2dlckl0ZW1zID0gQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU1RBR0dFUl9TRUxFQ1RPUiArIFwiLm1lZngtc3RhZ2dlci1pdGVtXCIpKTtcbiAgICAgIHN0YWdnZXJJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpe1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXN0YWdnZXItb25cIik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBib290KGVsZW1lbnRzKXtcbiAgICB2YXIgbGlzdCA9IEFycmF5LmlzQXJyYXkoZWxlbWVudHMpID8gZWxlbWVudHMgOiBbXTtcbiAgICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgICBsaXN0ID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1tkYXRhLW1vdGlvbl1cIikpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50c1RvQW5pbWF0ZSA9IGxpc3Q7XG4gICAgaWYgKCFlbGVtZW50c1RvQW5pbWF0ZS5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciByZWR1Y2VkTW90aW9uID0gaXNSZWR1Y2VkTW90aW9uKCk7XG4gICAgaWYgKHJlZHVjZWRNb3Rpb24gfHwgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBzZXRQcmVwYXJpbmdTdGF0ZShmYWxzZSk7XG4gICAgICBlbGVtZW50c1RvQW5pbWF0ZS5mb3JFYWNoKGFjdGl2YXRlRWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRW4gbW9iaWxlIGFsZ3Vub3MgbmF2ZWdhZG9yZXMgY29sYXBzYW4gXCJxdWl0YXIgcHJlcGFyaW5nICsgYWN0aXZhciBvblwiIGVuIGVsIG1pc21vIGxheW91dC5cbiAgICAvLyBEYW1vcyB1biBmcmFtZSBwYXJhIHJlYWN0aXZhciB0cmFuc2ljaW9uZXMgYW50ZXMgZGUgb2JzZXJ2YXIvYWN0aXZhci5cbiAgICBzZXRQcmVwYXJpbmdTdGF0ZShmYWxzZSk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcXVldWVkQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcXVldWVkRWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBhY3RpdmF0aW9uUmVhZHkgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gZW5xdWV1ZUFjdGl2YXRpb24oZWxlbWVudCl7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHJldHVybjtcbiAgICAgICAgdmFyIGtleSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb24taWRcIikgfHwgZWxlbWVudC5pZCB8fCBcIlwiO1xuICAgICAgICBpZiAoIWtleSkga2V5ID0gXCJpZHgtXCIgKyBxdWV1ZWRFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChxdWV1ZWRCeUlkW2tleV0pIHJldHVybjtcbiAgICAgICAgcXVldWVkQnlJZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgcXVldWVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWN0aXZhdGVPclF1ZXVlKGVsZW1lbnQpe1xuICAgICAgICBpZiAoYWN0aXZhdGlvblJlYWR5KSB7XG4gICAgICAgICAgYWN0aXZhdGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlQWN0aXZhdGlvbihlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICBmdW5jdGlvbihlbnRyaWVzKXtcbiAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpe1xuICAgICAgICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgYWN0aXZhdGVPclF1ZXVlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3Q6IG51bGwsXG4gICAgICAgICAgdGhyZXNob2xkOiAwLjE2LFxuICAgICAgICAgIHJvb3RNYXJnaW46IFwiMHB4IDBweCAtOCUgMHB4XCJcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgZWxlbWVudHNUb0FuaW1hdGUuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KXtcbiAgICAgICAgdmFyIGVmZmVjdCA9IG5vcm1hbGl6ZUVmZmVjdChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbW90aW9uXCIpKTtcbiAgICAgICAgaWYgKE9CU0VSVkVEX0VGRkVDVFNbZWZmZWN0XSkge1xuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2YXRlT3JRdWV1ZShlbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgYWN0aXZhdGlvblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICBxdWV1ZWRFbGVtZW50cy5mb3JFYWNoKGFjdGl2YXRlRWxlbWVudCk7XG4gICAgICAgICAgcXVldWVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVBbGxFbGVtZW50cygpe1xuICAgIHZhciBlbGVtZW50cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9bZGF0YS1tb3Rpb25dXCIpKTtcbiAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgc2V0UHJlcGFyaW5nU3RhdGUodHJ1ZSk7XG4gICAgZWxlbWVudHMuZm9yRWFjaChwcmVwYXJlRWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRCb290KCl7XG4gICAgaWYgKGJvb3RTdGFydGVkKSByZXR1cm47XG4gICAgYm9vdFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgd2FpdEZvclJ1bnRpbWVSZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgIHdhaXRGb3JGaXJzdFNlY3Rpb25CYWNrZ3JvdW5kKCkudGhlbihmdW5jdGlvbihiYWNrZ3JvdW5kUmVhZHkpe1xuICAgICAgICBpZiAoIWJhY2tncm91bmRSZWFkeSkge1xuICAgICAgICAgIGRpc3BhdGNoUnVudGltZUV2ZW50KFJVTlRJTUVfRkFJTF9FVkVOVCwgeyByZWFzb246IFwiZmlyc3QtYmFja2dyb3VuZC1mYWlsZWRcIiB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlcGFyZWRFbGVtZW50cyA9IHByZXBhcmVBbGxFbGVtZW50cygpIHx8IFtdO1xuICAgICAgICBkaXNwYXRjaFJ1bnRpbWVFdmVudChSVU5USU1FX1JFQURZX0VWRU5ULCB7IHNvdXJjZTogXCJtb3Rpb24tZWZmZWN0cy1ydW50aW1lXCIgfSk7XG4gICAgICAgIHdhaXRGb3JMb2FkZXJIaWRkZW4oKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgYm9vdChwcmVwYXJlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhcnRCb290KCk7XG59KSgpO1xuPC9zY3JpcHQ+XG5gLnRyaW0oKTtcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWVIVE1MIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/generarMotionEffectsRuntime.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/config.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/config.ts\nfunction normalizeConfig(opts) {\n    const fitMinScaleRaw = Number.isFinite(opts.fitMinScale) ? Number(opts.fitMinScale) : 0.88;\n    const fitMaxScaleRaw = Number.isFinite(opts.fitMaxScale) ? Number(opts.fitMaxScale) : 1.16;\n    const fitMinScale = Math.max(0.7, Math.min(1, fitMinScaleRaw));\n    const fitMaxScale = Math.max(1, fitMaxScaleRaw);\n    const fitTargetWidthRatioRaw = Number.isFinite(opts.fitTargetWidthRatio) ? Number(opts.fitTargetWidthRatio) : 0.94;\n    const fitTargetWidthRatio = Math.max(0.75, Math.min(0.99, fitTargetWidthRatioRaw));\n    const fitMinFillRatioRaw = Number.isFinite(opts.fitMinFillRatio) ? Number(opts.fitMinFillRatio) : 0.9;\n    const fitMinFillRatio = Math.max(0.6, Math.min(fitTargetWidthRatio, fitMinFillRatioRaw));\n    return {\n        enabled: !!opts.enabled,\n        minGapPx: Number.isFinite(opts.minGapPx) ? Number(opts.minGapPx) : 8,\n        paddingTopPx: Number.isFinite(opts.paddingTopPx) ? Number(opts.paddingTopPx) : 0,\n        paddingBottomPx: Number.isFinite(opts.paddingBottomPx) ? Number(opts.paddingBottomPx) : 12,\n        maxGapPx: Number.isFinite(opts.maxGapPx) ? Number(opts.maxGapPx) : 22,\n        onlyFixedSections: opts.onlyFixedSections !== false,\n        onlyWhenReordered: opts.onlyWhenReordered !== false,\n        rowTolPx: Number.isFinite(opts.rowTolPx) ? Number(opts.rowTolPx) : 28,\n        twoColSpreadRatio: Number.isFinite(opts.twoColSpreadRatio) ? Number(opts.twoColSpreadRatio) : 0.18,\n        minPerColumn2: Number.isFinite(opts.minPerColumn2) ? Number(opts.minPerColumn2) : 2,\n        threeColSpreadRatio: Number.isFinite(opts.threeColSpreadRatio) ? Number(opts.threeColSpreadRatio) : 0.22,\n        minPerColumn3: Number.isFinite(opts.minPerColumn3) ? Number(opts.minPerColumn3) : 2,\n        gapScale: Number.isFinite(opts.gapScale) ? Number(opts.gapScale) : 0.6,\n        fitMinScale,\n        fitMaxScale,\n        fitTargetWidthRatio,\n        fitMinFillRatio\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrREFBa0Q7QUFPM0MsU0FBU0EsZ0JBQWdCQyxJQUE4QjtJQUM1RCxNQUFNQyxpQkFBaUJDLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS0ksV0FBVyxJQUFJRixPQUFPRixLQUFLSSxXQUFXLElBQUk7SUFDdEYsTUFBTUMsaUJBQWlCSCxPQUFPQyxRQUFRLENBQUNILEtBQUtNLFdBQVcsSUFBSUosT0FBT0YsS0FBS00sV0FBVyxJQUFJO0lBQ3RGLE1BQU1GLGNBQWNHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLRSxHQUFHLENBQUMsR0FBR1I7SUFDOUMsTUFBTUssY0FBY0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdIO0lBQ2hDLE1BQU1LLHlCQUF5QlIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLVyxtQkFBbUIsSUFDbkVULE9BQU9GLEtBQUtXLG1CQUFtQixJQUMvQjtJQUNKLE1BQU1BLHNCQUFzQkosS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxNQUFNQztJQUMxRCxNQUFNRSxxQkFBcUJWLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS2EsZUFBZSxJQUMzRFgsT0FBT0YsS0FBS2EsZUFBZSxJQUMzQjtJQUNKLE1BQU1BLGtCQUFrQk4sS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtFLEdBQUcsQ0FBQ0UscUJBQXFCQztJQUVwRSxPQUFPO1FBQ0xFLFNBQVMsQ0FBQyxDQUFDZCxLQUFLYyxPQUFPO1FBRXZCQyxVQUFVYixPQUFPQyxRQUFRLENBQUNILEtBQUtlLFFBQVEsSUFBSWIsT0FBT0YsS0FBS2UsUUFBUSxJQUFJO1FBQ25FQyxjQUFjZCxPQUFPQyxRQUFRLENBQUNILEtBQUtnQixZQUFZLElBQUlkLE9BQU9GLEtBQUtnQixZQUFZLElBQUk7UUFDL0VDLGlCQUFpQmYsT0FBT0MsUUFBUSxDQUFDSCxLQUFLaUIsZUFBZSxJQUFJZixPQUFPRixLQUFLaUIsZUFBZSxJQUFJO1FBQ3hGQyxVQUFVaEIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLa0IsUUFBUSxJQUFJaEIsT0FBT0YsS0FBS2tCLFFBQVEsSUFBSTtRQUVuRUMsbUJBQW1CbkIsS0FBS21CLGlCQUFpQixLQUFLO1FBQzlDQyxtQkFBbUJwQixLQUFLb0IsaUJBQWlCLEtBQUs7UUFFOUNDLFVBQVVuQixPQUFPQyxRQUFRLENBQUNILEtBQUtxQixRQUFRLElBQUluQixPQUFPRixLQUFLcUIsUUFBUSxJQUFJO1FBRW5FQyxtQkFBbUJwQixPQUFPQyxRQUFRLENBQUNILEtBQUtzQixpQkFBaUIsSUFBSXBCLE9BQU9GLEtBQUtzQixpQkFBaUIsSUFBSTtRQUM5RkMsZUFBZXJCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3VCLGFBQWEsSUFBSXJCLE9BQU9GLEtBQUt1QixhQUFhLElBQUk7UUFFbEZDLHFCQUFxQnRCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3dCLG1CQUFtQixJQUFJdEIsT0FBT0YsS0FBS3dCLG1CQUFtQixJQUFJO1FBQ3BHQyxlQUFldkIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLeUIsYUFBYSxJQUFJdkIsT0FBT0YsS0FBS3lCLGFBQWEsSUFBSTtRQUVsRkMsVUFBVXhCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBSzBCLFFBQVEsSUFBSXhCLE9BQU9GLEtBQUswQixRQUFRLElBQUk7UUFDbkV0QjtRQUNBRTtRQUNBSztRQUNBRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2NvbmZpZy50c1xyXG5pbXBvcnQgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9ybWFsaXplZENvbmZpZyA9IFJlcXVpcmVkPE9taXQ8TW9iaWxlU21hcnRMYXlvdXRPcHRpb25zLCBcImVuYWJsZWRcIj4+ICYge1xyXG4gIGVuYWJsZWQ6IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKG9wdHM6IE1vYmlsZVNtYXJ0TGF5b3V0T3B0aW9ucyk6IE5vcm1hbGl6ZWRDb25maWcge1xuICBjb25zdCBmaXRNaW5TY2FsZVJhdyA9IE51bWJlci5pc0Zpbml0ZShvcHRzLmZpdE1pblNjYWxlKSA/IE51bWJlcihvcHRzLmZpdE1pblNjYWxlKSA6IDAuODg7XG4gIGNvbnN0IGZpdE1heFNjYWxlUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0TWF4U2NhbGUpID8gTnVtYmVyKG9wdHMuZml0TWF4U2NhbGUpIDogMS4xNjtcbiAgY29uc3QgZml0TWluU2NhbGUgPSBNYXRoLm1heCgwLjcsIE1hdGgubWluKDEsIGZpdE1pblNjYWxlUmF3KSk7XG4gIGNvbnN0IGZpdE1heFNjYWxlID0gTWF0aC5tYXgoMSwgZml0TWF4U2NhbGVSYXcpO1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0VGFyZ2V0V2lkdGhSYXRpbylcbiAgICA/IE51bWJlcihvcHRzLmZpdFRhcmdldFdpZHRoUmF0aW8pXG4gICAgOiAwLjk0O1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvID0gTWF0aC5tYXgoMC43NSwgTWF0aC5taW4oMC45OSwgZml0VGFyZ2V0V2lkdGhSYXRpb1JhdykpO1xuICBjb25zdCBmaXRNaW5GaWxsUmF0aW9SYXcgPSBOdW1iZXIuaXNGaW5pdGUob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgPyBOdW1iZXIob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgOiAwLjk7XG4gIGNvbnN0IGZpdE1pbkZpbGxSYXRpbyA9IE1hdGgubWF4KDAuNiwgTWF0aC5taW4oZml0VGFyZ2V0V2lkdGhSYXRpbywgZml0TWluRmlsbFJhdGlvUmF3KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiAhIW9wdHMuZW5hYmxlZCxcblxyXG4gICAgbWluR2FwUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pbkdhcFB4KSA/IE51bWJlcihvcHRzLm1pbkdhcFB4KSA6IDgsXHJcbiAgICBwYWRkaW5nVG9wUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnBhZGRpbmdUb3BQeCkgPyBOdW1iZXIob3B0cy5wYWRkaW5nVG9wUHgpIDogMCxcclxuICAgIHBhZGRpbmdCb3R0b21QeDogTnVtYmVyLmlzRmluaXRlKG9wdHMucGFkZGluZ0JvdHRvbVB4KSA/IE51bWJlcihvcHRzLnBhZGRpbmdCb3R0b21QeCkgOiAxMixcclxuICAgIG1heEdhcFB4OiBOdW1iZXIuaXNGaW5pdGUob3B0cy5tYXhHYXBQeCkgPyBOdW1iZXIob3B0cy5tYXhHYXBQeCkgOiAyMixcclxuXHJcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogb3B0cy5vbmx5Rml4ZWRTZWN0aW9ucyAhPT0gZmFsc2UsXHJcbiAgICBvbmx5V2hlblJlb3JkZXJlZDogb3B0cy5vbmx5V2hlblJlb3JkZXJlZCAhPT0gZmFsc2UsXHJcblxyXG4gICAgcm93VG9sUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnJvd1RvbFB4KSA/IE51bWJlcihvcHRzLnJvd1RvbFB4KSA6IDI4LFxyXG5cclxuICAgIHR3b0NvbFNwcmVhZFJhdGlvOiBOdW1iZXIuaXNGaW5pdGUob3B0cy50d29Db2xTcHJlYWRSYXRpbykgPyBOdW1iZXIob3B0cy50d29Db2xTcHJlYWRSYXRpbykgOiAwLjE4LFxyXG4gICAgbWluUGVyQ29sdW1uMjogTnVtYmVyLmlzRmluaXRlKG9wdHMubWluUGVyQ29sdW1uMikgPyBOdW1iZXIob3B0cy5taW5QZXJDb2x1bW4yKSA6IDIsXHJcblxuICAgIHRocmVlQ29sU3ByZWFkUmF0aW86IE51bWJlci5pc0Zpbml0ZShvcHRzLnRocmVlQ29sU3ByZWFkUmF0aW8pID8gTnVtYmVyKG9wdHMudGhyZWVDb2xTcHJlYWRSYXRpbykgOiAwLjIyLFxuICAgIG1pblBlckNvbHVtbjM6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pblBlckNvbHVtbjMpID8gTnVtYmVyKG9wdHMubWluUGVyQ29sdW1uMykgOiAyLFxuXG4gICAgZ2FwU2NhbGU6IE51bWJlci5pc0Zpbml0ZShvcHRzLmdhcFNjYWxlKSA/IE51bWJlcihvcHRzLmdhcFNjYWxlKSA6IDAuNixcbiAgICBmaXRNaW5TY2FsZSxcbiAgICBmaXRNYXhTY2FsZSxcbiAgICBmaXRUYXJnZXRXaWR0aFJhdGlvLFxuICAgIGZpdE1pbkZpbGxSYXRpbyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVDb25maWciLCJvcHRzIiwiZml0TWluU2NhbGVSYXciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGVSYXciLCJmaXRNYXhTY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmaXRUYXJnZXRXaWR0aFJhdGlvUmF3IiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpb1JhdyIsImZpdE1pbkZpbGxSYXRpbyIsImVuYWJsZWQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm1heEdhcFB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJnYXBTY2FsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts":
/*!******************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/dom.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsDomHelpersBlock: () => (/* binding */ jsDomHelpersBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/dom.ts\nfunction jsDomHelpersBlock() {\n    return `\n  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }\n\n  function isMobile(){\n    return (document.documentElement.clientWidth || 0) <= 767;\n  }\n\n  function getObjNodes(sec){\n    if(!sec) return [];\n    var nodes = [];\n    var content = sec.querySelector(\".sec-content\");\n    var bleed = sec.querySelector(\".sec-bleed\");\n\n    if (content) nodes = nodes.concat(Array.from(content.querySelectorAll(\".objeto\")));\n    if (bleed) nodes = nodes.concat(Array.from(bleed.querySelectorAll(\".objeto\")));\n\n    // Fallback: algunos elementos exportados pueden no traer clase \".objeto\"\n    // pero sí estar posicionados como objetos absolutos.\n    function collectAbsoluteCandidates(root){\n      if (!root) return [];\n      return Array.from(root.querySelectorAll(\"*\")).filter(function(el){\n        if (!el) return false;\n        var cs = getComputedStyle(el);\n        var pos = (cs.position || \"\").toLowerCase();\n        if (pos !== \"absolute\") return false;\n\n        var rr = el.getBoundingClientRect();\n        if (!rr || rr.width < 1 || rr.height < 1) return false;\n\n        // Evitar ruido estructural del layout de sección\n        if (el.classList && (\n          el.classList.contains(\"sec\") ||\n          el.classList.contains(\"sec-zoom\") ||\n          el.classList.contains(\"sec-bg\") ||\n          el.classList.contains(\"sec-content\") ||\n          el.classList.contains(\"sec-bleed\")\n        )) return false;\n\n        // Si ya está dentro de un \".objeto\", no lo contamos aparte.\n        var p = el.parentElement;\n        while (p){\n          if (p.classList && p.classList.contains(\"objeto\")) return false;\n          p = p.parentElement;\n        }\n        return true;\n      });\n    }\n\n    nodes = nodes.concat(collectAbsoluteCandidates(content));\n    nodes = nodes.concat(collectAbsoluteCandidates(bleed));\n\n    // Deduplicar preservando orden de aparición.\n    var seen = new Set();\n    return nodes.filter(function(n){\n      if (seen.has(n)) return false;\n      seen.add(n);\n      return true;\n    });\n  }\n\n  function relRect(el, root){\n    var r = el.getBoundingClientRect();\n    var rr = root.getBoundingClientRect();\n    return {\n      top: r.top - rr.top,\n      left: r.left - rr.left,\n      width: r.width,\n      height: r.height\n    };\n  }\n\n  function percentile(sortedArr, p){\n    if (!sortedArr.length) return 0;\n    var idx = Math.floor(sortedArr.length * p);\n    idx = Math.max(0, Math.min(sortedArr.length - 1, idx));\n    return sortedArr[idx];\n  }\n\n  function cx(it){ return it.left + (it.width || 0) / 2; }\n\n  // -------------------------\n  // ✅ CLUSTERS POR SOLAPE\n  // -------------------------\n  function rectsOverlap(a, b, tol){\n    tol = tol || 0;\n    return !(\n      (a.left + a.width) < (b.left + tol) ||\n      (b.left + b.width) < (a.left + tol) ||\n      (a.top + a.height) < (b.top + tol) ||\n      (b.top + b.height) < (a.top + tol)\n    );\n  }\n\n  function horizontalOverlapPx(a, b){\n    var l = Math.max(a.left, b.left);\n    var r = Math.min(a.left + a.width, b.left + b.width);\n    return Math.max(0, r - l);\n  }\n\n  function verticalGapPx(a, b){\n    var topAfter = Math.max(a.top, b.top);\n    var bottomBefore = Math.min(a.top + a.height, b.top + b.height);\n    return topAfter - bottomBefore;\n  }\n\n  function buildOverlapClusters(items){\n    var n = items.length;\n    var parent = new Array(n);\n    for (var i=0;i<n;i++) parent[i] = i;\n\n    function find(x){\n      while(parent[x] !== x){\n        parent[x] = parent[parent[x]];\n        x = parent[x];\n      }\n      return x;\n    }\n\n    function union(a,b){\n      var ra = find(a), rb = find(b);\n      if (ra !== rb) parent[rb] = ra;\n    }\n\n    // tol pequeño para considerar “encimado” aunque sea apenas\n    var TOL = 1;\n    // unión por cercanía vertical dentro de una misma \"columna visual\"\n    var PROX_Y = 34;\n    var MIN_H_OVERLAP_RATIO = 0.35;\n    var MAX_CX_DIST = 42;\n\n    for (var i=0;i<n;i++){\n      for (var j=i+1;j<n;j++){\n        var a = items[i], b = items[j];\n\n    var aIso = (a.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\n    var bIso = (b.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\n\n    // si cualquiera es isolated, no lo unimos con nadie\n    if (aIso || bIso) continue;\n\n    // opcional: cluster-id manual (si querés agrupar solo algunos)\n    var aKey = a.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\n    var bKey = b.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\n    if (aKey && bKey && aKey !== bKey) continue;\n\n    var aIsText = (a.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n    var bIsText = (b.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n    var involvesText = aIsText || bIsText;\n    var cxDist = Math.abs(cx(a) - cx(b));\n\n    if (rectsOverlap(a, b, TOL)) {\n      // Evita pegar columnas distintas por cajas de texto anchas.\n      // Si hay texto, exigimos cercania por eje X del centro.\n      if (!involvesText || cxDist <= MAX_CX_DIST) union(i,j);\n      continue;\n    }\n\n    // Si no se solapan pero están muy cerca en vertical y comparten columna,\n    // también los unimos para mantener bloque (ej: icono + texto debajo).\n    var hov = horizontalOverlapPx(a, b);\n    var minW = Math.max(1, Math.min(a.width || 0, b.width || 0));\n    var hovRatio = hov / minW;\n    // Con texto, usamos criterio más estricto para no cruzar columnas.\n    var sameVisualColumn = involvesText\n      ? (cxDist <= MAX_CX_DIST)\n      : ((hovRatio >= MIN_H_OVERLAP_RATIO) || (cxDist <= MAX_CX_DIST));\n    var vGap = verticalGapPx(a, b);\n    var nearVertical = vGap >= 0 && vGap <= PROX_Y;\n    var bothText = aIsText && bIsText;\n\n    // Evitar \"pegar\" párrafos entre sí solo por cercanía vertical.\n    // La unión por proximidad queda para pares mixtos (texto + no-texto),\n    // manteniendo el caso icono/forma + texto.\n    if (sameVisualColumn && nearVertical && !bothText) union(i,j);\n\n      }\n    }\n\n    var map = {};\n    for (var k=0;k<n;k++){\n      var r = find(k);\n      if (!map[r]) map[r] = [];\n      map[r].push(items[k]);\n    }\n\n    var clusters = [];\n    Object.keys(map).forEach(function(key){\n      var arr = map[key];\n\n      var minTop = Infinity, minLeft = Infinity, maxR = -Infinity, maxB = -Infinity;\n      for (var i=0;i<arr.length;i++){\n        var it = arr[i];\n        minTop = Math.min(minTop, it.top);\n        minLeft = Math.min(minLeft, it.left);\n        maxR = Math.max(maxR, it.left + it.width);\n        maxB = Math.max(maxB, it.top + it.height);\n      }\n\n      // offsets relativos para preservar el solape dentro del cluster\n      for (var i=0;i<arr.length;i++){\n        arr[i]._relTop = arr[i].top - minTop;\n        arr[i]._relLeft = arr[i].left - minLeft;\n      }\n\n      clusters.push({\n        items: arr,\n        top: minTop,\n        left: minLeft,\n        width: maxR - minLeft,\n        height: maxB - minTop,\n        cx: (minLeft + maxR) / 2\n      });\n    });\n\n    // orden estable por top para consistencia\n    clusters.sort(function(a,b){ return a.top - b.top; });\n\n    return clusters;\n  }\n\n  // ✅ “entra” si ningún cluster se sale horizontalmente del contenedor content\n  function clustersFitInMobile(clusters, rootEl){\n    var rootW = rootEl.getBoundingClientRect().width || 0;\n    if (!rootW) return true;\n\n    for (var i=0;i<clusters.length;i++){\n      var c = clusters[i];\n      if (c.left < -1) return false;\n      if ((c.left + c.width) > (rootW + 1)) return false;\n    }\n    return true;\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwrQ0FBK0M7QUFDeEMsU0FBU0E7SUFDZCxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3T1YsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGRvbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2RvbS50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNEb21IZWxwZXJzQmxvY2soKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFxyXG4gIGZ1bmN0aW9uIGNsYW1wKG4sYSxiKXsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsbikpOyB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzTW9iaWxlKCl7XHJcbiAgICByZXR1cm4gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwKSA8PSA3Njc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRPYmpOb2RlcyhzZWMpe1xyXG4gICAgaWYoIXNlYykgcmV0dXJuIFtdO1xyXG4gICAgdmFyIG5vZGVzID0gW107XHJcbiAgICB2YXIgY29udGVudCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1jb250ZW50XCIpO1xyXG4gICAgdmFyIGJsZWVkID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWJsZWVkXCIpO1xyXG5cclxuICAgIGlmIChjb250ZW50KSBub2RlcyA9IG5vZGVzLmNvbmNhdChBcnJheS5mcm9tKGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikpKTtcclxuICAgIGlmIChibGVlZCkgbm9kZXMgPSBub2Rlcy5jb25jYXQoQXJyYXkuZnJvbShibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKSkpO1xyXG5cclxuICAgIC8vIEZhbGxiYWNrOiBhbGd1bm9zIGVsZW1lbnRvcyBleHBvcnRhZG9zIHB1ZWRlbiBubyB0cmFlciBjbGFzZSBcIi5vYmpldG9cIlxyXG4gICAgLy8gcGVybyBzw60gZXN0YXIgcG9zaWNpb25hZG9zIGNvbW8gb2JqZXRvcyBhYnNvbHV0b3MuXHJcbiAgICBmdW5jdGlvbiBjb2xsZWN0QWJzb2x1dGVDYW5kaWRhdGVzKHJvb3Qpe1xyXG4gICAgICBpZiAoIXJvb3QpIHJldHVybiBbXTtcclxuICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcclxuICAgICAgICBpZiAoIWVsKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAgICAgdmFyIHBvcyA9IChjcy5wb3NpdGlvbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChwb3MgIT09IFwiYWJzb2x1dGVcIikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgcnIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBpZiAoIXJyIHx8IHJyLndpZHRoIDwgMSB8fCByci5oZWlnaHQgPCAxKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEV2aXRhciBydWlkbyBlc3RydWN0dXJhbCBkZWwgbGF5b3V0IGRlIHNlY2Npw7NuXHJcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAoXHJcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWNcIikgfHxcclxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy16b29tXCIpIHx8XHJcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWMtYmdcIikgfHxcclxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1jb250ZW50XCIpIHx8XHJcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWMtYmxlZWRcIilcclxuICAgICAgICApKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFNpIHlhIGVzdMOhIGRlbnRybyBkZSB1biBcIi5vYmpldG9cIiwgbm8gbG8gY29udGFtb3MgYXBhcnRlLlxyXG4gICAgICAgIHZhciBwID0gZWwucGFyZW50RWxlbWVudDtcclxuICAgICAgICB3aGlsZSAocCl7XHJcbiAgICAgICAgICBpZiAocC5jbGFzc0xpc3QgJiYgcC5jbGFzc0xpc3QuY29udGFpbnMoXCJvYmpldG9cIikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIHAgPSBwLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjb2xsZWN0QWJzb2x1dGVDYW5kaWRhdGVzKGNvbnRlbnQpKTtcclxuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMoYmxlZWQpKTtcclxuXHJcbiAgICAvLyBEZWR1cGxpY2FyIHByZXNlcnZhbmRvIG9yZGVuIGRlIGFwYXJpY2nDs24uXHJcbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoZnVuY3Rpb24obil7XHJcbiAgICAgIGlmIChzZWVuLmhhcyhuKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBzZWVuLmFkZChuKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbFJlY3QoZWwsIHJvb3Qpe1xyXG4gICAgdmFyIHIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciByciA9IHJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IHIudG9wIC0gcnIudG9wLFxyXG4gICAgICBsZWZ0OiByLmxlZnQgLSByci5sZWZ0LFxyXG4gICAgICB3aWR0aDogci53aWR0aCxcclxuICAgICAgaGVpZ2h0OiByLmhlaWdodFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlcmNlbnRpbGUoc29ydGVkQXJyLCBwKXtcclxuICAgIGlmICghc29ydGVkQXJyLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihzb3J0ZWRBcnIubGVuZ3RoICogcCk7XHJcbiAgICBpZHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzb3J0ZWRBcnIubGVuZ3RoIC0gMSwgaWR4KSk7XHJcbiAgICByZXR1cm4gc29ydGVkQXJyW2lkeF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjeChpdCl7IHJldHVybiBpdC5sZWZ0ICsgKGl0LndpZHRoIHx8IDApIC8gMjsgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8g4pyFIENMVVNURVJTIFBPUiBTT0xBUEVcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgZnVuY3Rpb24gcmVjdHNPdmVybGFwKGEsIGIsIHRvbCl7XHJcbiAgICB0b2wgPSB0b2wgfHwgMDtcclxuICAgIHJldHVybiAhKFxyXG4gICAgICAoYS5sZWZ0ICsgYS53aWR0aCkgPCAoYi5sZWZ0ICsgdG9sKSB8fFxyXG4gICAgICAoYi5sZWZ0ICsgYi53aWR0aCkgPCAoYS5sZWZ0ICsgdG9sKSB8fFxyXG4gICAgICAoYS50b3AgKyBhLmhlaWdodCkgPCAoYi50b3AgKyB0b2wpIHx8XHJcbiAgICAgIChiLnRvcCArIGIuaGVpZ2h0KSA8IChhLnRvcCArIHRvbClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBob3Jpem9udGFsT3ZlcmxhcFB4KGEsIGIpe1xyXG4gICAgdmFyIGwgPSBNYXRoLm1heChhLmxlZnQsIGIubGVmdCk7XHJcbiAgICB2YXIgciA9IE1hdGgubWluKGEubGVmdCArIGEud2lkdGgsIGIubGVmdCArIGIud2lkdGgpO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHIgLSBsKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHZlcnRpY2FsR2FwUHgoYSwgYil7XHJcbiAgICB2YXIgdG9wQWZ0ZXIgPSBNYXRoLm1heChhLnRvcCwgYi50b3ApO1xyXG4gICAgdmFyIGJvdHRvbUJlZm9yZSA9IE1hdGgubWluKGEudG9wICsgYS5oZWlnaHQsIGIudG9wICsgYi5oZWlnaHQpO1xyXG4gICAgcmV0dXJuIHRvcEFmdGVyIC0gYm90dG9tQmVmb3JlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYnVpbGRPdmVybGFwQ2x1c3RlcnMoaXRlbXMpe1xyXG4gICAgdmFyIG4gPSBpdGVtcy5sZW5ndGg7XHJcbiAgICB2YXIgcGFyZW50ID0gbmV3IEFycmF5KG4pO1xyXG4gICAgZm9yICh2YXIgaT0wO2k8bjtpKyspIHBhcmVudFtpXSA9IGk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZCh4KXtcclxuICAgICAgd2hpbGUocGFyZW50W3hdICE9PSB4KXtcclxuICAgICAgICBwYXJlbnRbeF0gPSBwYXJlbnRbcGFyZW50W3hdXTtcclxuICAgICAgICB4ID0gcGFyZW50W3hdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuaW9uKGEsYil7XHJcbiAgICAgIHZhciByYSA9IGZpbmQoYSksIHJiID0gZmluZChiKTtcclxuICAgICAgaWYgKHJhICE9PSByYikgcGFyZW50W3JiXSA9IHJhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvbCBwZXF1ZcOxbyBwYXJhIGNvbnNpZGVyYXIg4oCcZW5jaW1hZG/igJ0gYXVucXVlIHNlYSBhcGVuYXNcclxuICAgIHZhciBUT0wgPSAxO1xyXG4gICAgLy8gdW5pw7NuIHBvciBjZXJjYW7DrWEgdmVydGljYWwgZGVudHJvIGRlIHVuYSBtaXNtYSBcImNvbHVtbmEgdmlzdWFsXCJcclxuICAgIHZhciBQUk9YX1kgPSAzNDtcclxuICAgIHZhciBNSU5fSF9PVkVSTEFQX1JBVElPID0gMC4zNTtcclxuICAgIHZhciBNQVhfQ1hfRElTVCA9IDQyO1xyXG5cclxuICAgIGZvciAodmFyIGk9MDtpPG47aSsrKXtcclxuICAgICAgZm9yICh2YXIgaj1pKzE7ajxuO2orKyl7XHJcbiAgICAgICAgdmFyIGEgPSBpdGVtc1tpXSwgYiA9IGl0ZW1zW2pdO1xyXG5cclxuICAgIHZhciBhSXNvID0gKGEubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyXCIpIHx8IFwiXCIpID09PSBcImlzb2xhdGVkXCI7XHJcbiAgICB2YXIgYklzbyA9IChiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiKSA9PT0gXCJpc29sYXRlZFwiO1xyXG5cclxuICAgIC8vIHNpIGN1YWxxdWllcmEgZXMgaXNvbGF0ZWQsIG5vIGxvIHVuaW1vcyBjb24gbmFkaWVcclxuICAgIGlmIChhSXNvIHx8IGJJc28pIGNvbnRpbnVlO1xyXG5cclxuICAgIC8vIG9wY2lvbmFsOiBjbHVzdGVyLWlkIG1hbnVhbCAoc2kgcXVlcsOpcyBhZ3J1cGFyIHNvbG8gYWxndW5vcylcclxuICAgIHZhciBhS2V5ID0gYS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXItaWRcIikgfHwgXCJcIjtcclxuICAgIHZhciBiS2V5ID0gYi5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXItaWRcIikgfHwgXCJcIjtcclxuICAgIGlmIChhS2V5ICYmIGJLZXkgJiYgYUtleSAhPT0gYktleSkgY29udGludWU7XHJcblxyXG4gICAgdmFyIGFJc1RleHQgPSAoYS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgdmFyIGJJc1RleHQgPSAoYi5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgdmFyIGludm9sdmVzVGV4dCA9IGFJc1RleHQgfHwgYklzVGV4dDtcclxuICAgIHZhciBjeERpc3QgPSBNYXRoLmFicyhjeChhKSAtIGN4KGIpKTtcclxuXHJcbiAgICBpZiAocmVjdHNPdmVybGFwKGEsIGIsIFRPTCkpIHtcclxuICAgICAgLy8gRXZpdGEgcGVnYXIgY29sdW1uYXMgZGlzdGludGFzIHBvciBjYWphcyBkZSB0ZXh0byBhbmNoYXMuXHJcbiAgICAgIC8vIFNpIGhheSB0ZXh0bywgZXhpZ2ltb3MgY2VyY2FuaWEgcG9yIGVqZSBYIGRlbCBjZW50cm8uXHJcbiAgICAgIGlmICghaW52b2x2ZXNUZXh0IHx8IGN4RGlzdCA8PSBNQVhfQ1hfRElTVCkgdW5pb24oaSxqKTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2kgbm8gc2Ugc29sYXBhbiBwZXJvIGVzdMOhbiBtdXkgY2VyY2EgZW4gdmVydGljYWwgeSBjb21wYXJ0ZW4gY29sdW1uYSxcclxuICAgIC8vIHRhbWJpw6luIGxvcyB1bmltb3MgcGFyYSBtYW50ZW5lciBibG9xdWUgKGVqOiBpY29ubyArIHRleHRvIGRlYmFqbykuXHJcbiAgICB2YXIgaG92ID0gaG9yaXpvbnRhbE92ZXJsYXBQeChhLCBiKTtcclxuICAgIHZhciBtaW5XID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oYS53aWR0aCB8fCAwLCBiLndpZHRoIHx8IDApKTtcclxuICAgIHZhciBob3ZSYXRpbyA9IGhvdiAvIG1pblc7XHJcbiAgICAvLyBDb24gdGV4dG8sIHVzYW1vcyBjcml0ZXJpbyBtw6FzIGVzdHJpY3RvIHBhcmEgbm8gY3J1emFyIGNvbHVtbmFzLlxyXG4gICAgdmFyIHNhbWVWaXN1YWxDb2x1bW4gPSBpbnZvbHZlc1RleHRcclxuICAgICAgPyAoY3hEaXN0IDw9IE1BWF9DWF9ESVNUKVxyXG4gICAgICA6ICgoaG92UmF0aW8gPj0gTUlOX0hfT1ZFUkxBUF9SQVRJTykgfHwgKGN4RGlzdCA8PSBNQVhfQ1hfRElTVCkpO1xyXG4gICAgdmFyIHZHYXAgPSB2ZXJ0aWNhbEdhcFB4KGEsIGIpO1xyXG4gICAgdmFyIG5lYXJWZXJ0aWNhbCA9IHZHYXAgPj0gMCAmJiB2R2FwIDw9IFBST1hfWTtcclxuICAgIHZhciBib3RoVGV4dCA9IGFJc1RleHQgJiYgYklzVGV4dDtcclxuXHJcbiAgICAvLyBFdml0YXIgXCJwZWdhclwiIHDDoXJyYWZvcyBlbnRyZSBzw60gc29sbyBwb3IgY2VyY2Fuw61hIHZlcnRpY2FsLlxyXG4gICAgLy8gTGEgdW5pw7NuIHBvciBwcm94aW1pZGFkIHF1ZWRhIHBhcmEgcGFyZXMgbWl4dG9zICh0ZXh0byArIG5vLXRleHRvKSxcclxuICAgIC8vIG1hbnRlbmllbmRvIGVsIGNhc28gaWNvbm8vZm9ybWEgKyB0ZXh0by5cclxuICAgIGlmIChzYW1lVmlzdWFsQ29sdW1uICYmIG5lYXJWZXJ0aWNhbCAmJiAhYm90aFRleHQpIHVuaW9uKGksaik7XHJcblxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaz0wO2s8bjtrKyspe1xyXG4gICAgICB2YXIgciA9IGZpbmQoayk7XHJcbiAgICAgIGlmICghbWFwW3JdKSBtYXBbcl0gPSBbXTtcclxuICAgICAgbWFwW3JdLnB1c2goaXRlbXNba10pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbHVzdGVycyA9IFtdO1xyXG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBhcnIgPSBtYXBba2V5XTtcclxuXHJcbiAgICAgIHZhciBtaW5Ub3AgPSBJbmZpbml0eSwgbWluTGVmdCA9IEluZmluaXR5LCBtYXhSID0gLUluZmluaXR5LCBtYXhCID0gLUluZmluaXR5O1xyXG4gICAgICBmb3IgKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIGl0ID0gYXJyW2ldO1xyXG4gICAgICAgIG1pblRvcCA9IE1hdGgubWluKG1pblRvcCwgaXQudG9wKTtcclxuICAgICAgICBtaW5MZWZ0ID0gTWF0aC5taW4obWluTGVmdCwgaXQubGVmdCk7XHJcbiAgICAgICAgbWF4UiA9IE1hdGgubWF4KG1heFIsIGl0LmxlZnQgKyBpdC53aWR0aCk7XHJcbiAgICAgICAgbWF4QiA9IE1hdGgubWF4KG1heEIsIGl0LnRvcCArIGl0LmhlaWdodCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG9mZnNldHMgcmVsYXRpdm9zIHBhcmEgcHJlc2VydmFyIGVsIHNvbGFwZSBkZW50cm8gZGVsIGNsdXN0ZXJcclxuICAgICAgZm9yICh2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGFycltpXS5fcmVsVG9wID0gYXJyW2ldLnRvcCAtIG1pblRvcDtcclxuICAgICAgICBhcnJbaV0uX3JlbExlZnQgPSBhcnJbaV0ubGVmdCAtIG1pbkxlZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNsdXN0ZXJzLnB1c2goe1xyXG4gICAgICAgIGl0ZW1zOiBhcnIsXHJcbiAgICAgICAgdG9wOiBtaW5Ub3AsXHJcbiAgICAgICAgbGVmdDogbWluTGVmdCxcclxuICAgICAgICB3aWR0aDogbWF4UiAtIG1pbkxlZnQsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhCIC0gbWluVG9wLFxyXG4gICAgICAgIGN4OiAobWluTGVmdCArIG1heFIpIC8gMlxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG9yZGVuIGVzdGFibGUgcG9yIHRvcCBwYXJhIGNvbnNpc3RlbmNpYVxyXG4gICAgY2x1c3RlcnMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xyXG4gIH1cclxuXHJcbiAgLy8g4pyFIOKAnGVudHJh4oCdIHNpIG5pbmfDum4gY2x1c3RlciBzZSBzYWxlIGhvcml6b250YWxtZW50ZSBkZWwgY29udGVuZWRvciBjb250ZW50XHJcbiAgZnVuY3Rpb24gY2x1c3RlcnNGaXRJbk1vYmlsZShjbHVzdGVycywgcm9vdEVsKXtcclxuICAgIHZhciByb290VyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCAwO1xyXG4gICAgaWYgKCFyb290VykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgZm9yICh2YXIgaT0wO2k8Y2x1c3RlcnMubGVuZ3RoO2krKyl7XHJcbiAgICAgIHZhciBjID0gY2x1c3RlcnNbaV07XHJcbiAgICAgIGlmIChjLmxlZnQgPCAtMSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoKGMubGVmdCArIGMud2lkdGgpID4gKHJvb3RXICsgMSkpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzRG9tSGVscGVyc0Jsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/fitScale.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsFitScaleBlock: () => (/* binding */ jsFitScaleBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/fitScale.ts\nfunction jsFitScaleBlock() {\n    return `\n  function ensureFitScaleBaseline(el){\n    if (!el) return;\n    if (!el.hasAttribute(\"data-msl-fit-orig-transform\")) {\n      el.setAttribute(\"data-msl-fit-orig-transform\", el.style.transform || \"\");\n    }\n    if (!el.hasAttribute(\"data-msl-fit-orig-origin\")) {\n      el.setAttribute(\"data-msl-fit-orig-origin\", el.style.transformOrigin || \"\");\n    }\n  }\n\n  function restoreFitScaleBaseline(el){\n    if (!el) return;\n    ensureFitScaleBaseline(el);\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\n    var baseOrigin = el.getAttribute(\"data-msl-fit-orig-origin\") || \"\";\n    el.style.transform = baseTransform;\n    if (baseOrigin) el.style.transformOrigin = baseOrigin;\n    else el.style.removeProperty(\"transform-origin\");\n  }\n\n  function applyElementFitScale(el, scale){\n    if (!el) return;\n    ensureFitScaleBaseline(el);\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\n    var next = baseTransform ? (baseTransform + \" scale(\" + scale + \")\") : (\"scale(\" + scale + \")\");\n    el.style.transform = next;\n    el.style.transformOrigin = \"top center\";\n  }\n\n  function resetSectionFitScale(_sec, content, bleed){\n    restoreFitScaleBaseline(content);\n    restoreFitScaleBaseline(bleed);\n  }\n\n  function computeSectionBounds(sec, nodes){\n    if (!sec || !nodes || !nodes.length) return null;\n    var minLeft = Infinity;\n    var minTop = Infinity;\n    var maxRight = -Infinity;\n    var maxBottom = -Infinity;\n    var valid = 0;\n\n    for (var i=0; i<nodes.length; i++){\n      var node = nodes[i];\n      if (!node) continue;\n      var rr = relRect(node, sec);\n      var w = Number(rr.width || 0);\n      var h = Number(rr.height || 0);\n      if (w <= 0.5 && h <= 0.5) continue;\n\n      var l = Number(rr.left || 0);\n      var t = Number(rr.top || 0);\n      var r = l + Math.max(0, w);\n      var b = t + Math.max(0, h);\n\n      if (!isFinite(l) || !isFinite(t) || !isFinite(r) || !isFinite(b)) continue;\n\n      minLeft = Math.min(minLeft, l);\n      minTop = Math.min(minTop, t);\n      maxRight = Math.max(maxRight, r);\n      maxBottom = Math.max(maxBottom, b);\n      valid++;\n    }\n\n    if (!valid || !isFinite(minLeft) || !isFinite(maxRight) || !isFinite(minTop) || !isFinite(maxBottom)) {\n      return null;\n    }\n\n    return {\n      minLeft: minLeft,\n      minTop: minTop,\n      maxRight: maxRight,\n      maxBottom: maxBottom,\n      width: Math.max(0, maxRight - minLeft),\n      height: Math.max(0, maxBottom - minTop),\n      count: valid\n    };\n  }\n\n  function computeFitScale(sec, bounds, secModo, CFG){\n    if (!sec || !bounds) return 1;\n    var secRect = sec.getBoundingClientRect();\n    var secW = Number(secRect.width || 0);\n    var secH = Number(secRect.height || 0);\n    if (secW <= 1) {\n      return {\n        scale: 1,\n        debug: null\n      };\n    }\n\n    var targetCoverage = clamp(Number(CFG.FIT_TARGET_WIDTH_RATIO || 0.94), 0.75, 0.99);\n    var minFillForUpscale = clamp(Number(CFG.FIT_MIN_FILL_RATIO || 0.9), 0.6, targetCoverage);\n    var minScale = clamp(Number(CFG.FIT_MIN_SCALE || 0.88), 0.7, 1);\n    var maxScale = Math.max(1, Number(CFG.FIT_MAX_SCALE || 1.16));\n\n    var contentW = Math.max(1, Number(bounds.width || 0));\n    var coverage = contentW / secW;\n\n    var scale = 1;\n    var debug = {\n      secW: secW,\n      secH: secH,\n      targetCoverage: targetCoverage,\n      minFillForUpscale: minFillForUpscale,\n      minScale: minScale,\n      maxScale: maxScale,\n      coverage: coverage,\n      initialScale: 1,\n      maxScaleByWidth: null,\n      maxScaleByHeight: null,\n      scaleAfterWidthClamp: null,\n      scaleAfterHeightClamp: null,\n      tinyShrinkProtected: false,\n      pantallaDownscaleBlocked: false\n    };\n    if (coverage < minFillForUpscale) {\n      scale = targetCoverage / Math.max(0.01, coverage);\n    }\n    debug.initialScale = scale;\n\n    if (scale >= 1) scale = Math.min(scale, maxScale);\n    else scale = Math.max(scale, minScale);\n\n    // Límite horizontal duro por centro visual.\n    var centerX = secW / 2;\n    var distLeft = Math.max(0, centerX - Number(bounds.minLeft || 0));\n    var distRight = Math.max(0, Number(bounds.maxRight || 0) - centerX);\n    var maxScaleByWidth = Infinity;\n    if (distLeft > 0.5) {\n      maxScaleByWidth = Math.min(maxScaleByWidth, centerX / distLeft);\n    }\n    if (distRight > 0.5) {\n      maxScaleByWidth = Math.min(maxScaleByWidth, (secW - centerX) / distRight);\n    }\n    if (isFinite(maxScaleByWidth) && maxScaleByWidth > 0) {\n      scale = Math.min(scale, maxScaleByWidth);\n      debug.maxScaleByWidth = maxScaleByWidth;\n    }\n    debug.scaleAfterWidthClamp = scale;\n\n    if (secModo === \"pantalla\" && scale < 1 && scale > 0.94) {\n      // Avoid shrinking \"pantalla\" for tiny overflows; preserve visual impact.\n      scale = 1;\n      debug.tinyShrinkProtected = true;\n    }\n\n    // En modo pantalla no dejamos que el contenido se recorte por altura.\n    if (secModo === \"pantalla\" && secH > 1) {\n      var maxBottom = Number(bounds.maxBottom || 0);\n      if (maxBottom > 1) {\n        var maxScaleByHeight = secH / maxBottom;\n        if (isFinite(maxScaleByHeight) && maxScaleByHeight > 0) {\n          scale = Math.min(scale, maxScaleByHeight);\n          debug.maxScaleByHeight = maxScaleByHeight;\n        }\n      }\n    }\n    debug.scaleAfterHeightClamp = scale;\n\n    if (secModo === \"pantalla\" && scale < 1) {\n      // Pantalla sections already have their own viewport-fit logic.\n      // Avoid additional downscale here to keep hero text readable.\n      scale = 1;\n      debug.pantallaDownscaleBlocked = true;\n    }\n\n    if (!isFinite(scale) || scale <= 0) scale = 1;\n    if (Math.abs(scale - 1) < 0.02) scale = 1;\n    return {\n      scale: scale,\n      debug: debug\n    };\n  }\n\n  function applySectionFitScale(sec, content, bleed, nodesAll, secModo, CFG, meta, opts){\n    if (!sec || !content) {\n      return { scale: 1, neededHeight: 0, bounds: null };\n    }\n\n    ensureFitScaleBaseline(content);\n    ensureFitScaleBaseline(bleed);\n    var preserveBottomGap = 0;\n    if (opts && Number.isFinite(opts.preserveBottomGap)) {\n      preserveBottomGap = Math.max(0, Number(opts.preserveBottomGap));\n    }\n\n    var fitNodes = (nodesAll || []).filter(function(node){\n      if (!node) return false;\n      var fitMode = (node.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\n      if (fitMode === \"ignore\") return false;\n      if (node.closest && node.closest(\".sec-bleed\")) return false;\n      return true;\n    });\n\n    var bounds = computeSectionBounds(sec, fitNodes);\n    if (!bounds) {\n      bounds = computeSectionBounds(sec, nodesAll || []);\n    }\n    if (!bounds) {\n      restoreFitScaleBaseline(content);\n      restoreFitScaleBaseline(bleed);\n      sec.setAttribute(\"data-msl-fit-scale\", \"1\");\n      return { scale: 1, neededHeight: 0, bounds: null };\n    }\n\n    var fitResult = computeFitScale(sec, bounds, secModo, CFG);\n    var scale = (fitResult && Number.isFinite(fitResult.scale)) ? fitResult.scale : 1;\n    var fitDebug = fitResult && fitResult.debug ? fitResult.debug : null;\n    applyElementFitScale(content, scale);\n    applyElementFitScale(bleed, scale);\n\n    var neededHeight = 0;\n    if (secModo !== \"pantalla\") {\n      var maxBottomWithGap = Number(bounds.maxBottom || 0) + preserveBottomGap;\n      neededHeight = Math.ceil(maxBottomWithGap * scale + (CFG.PAD_BOT || 0));\n    }\n\n    if (secModo === \"pantalla\") {\n      var secRectNow = sec.getBoundingClientRect();\n      var vv = window.visualViewport;\n      var viewportW = (vv && vv.width) ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 0);\n      var viewportH = (vv && vv.height) ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 0);\n      var ua = navigator.userAgent || \"\";\n      var mobileUA = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);\n      var touchPoints = Number(navigator.maxTouchPoints || 0);\n      var coarsePointer = false;\n      if (window.matchMedia) {\n        try { coarsePointer = window.matchMedia(\"(pointer: coarse)\").matches; } catch(_e) {}\n      }\n      var mobileViewport = viewportW <= 767;\n      var desktopMobilePreview = mobileViewport && !mobileUA;\n\n      var boundsAll = computeSectionBounds(sec, nodesAll || []);\n      var totalNodes = (nodesAll || []).length;\n      var fitNodesCount = fitNodes.length;\n      var textAll = 0;\n      var textFit = 0;\n      var ignoredBleed = 0;\n      var ignoredExplicit = 0;\n      var dominantText = null;\n      var dominantTextH = -1;\n      var elementRows = [];\n\n      for (var ni=0; ni<totalNodes; ni++){\n        var nodeAll = nodesAll[ni];\n        if (!nodeAll) continue;\n\n        var fitModeAll = (nodeAll.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\n        if (fitModeAll === \"ignore\") ignoredExplicit++;\n        if (nodeAll.closest && nodeAll.closest(\".sec-bleed\")) ignoredBleed++;\n\n        var rrNode = relRect(nodeAll, sec);\n        var nodeW = Number(rrNode.width || 0);\n        var nodeH = Number(rrNode.height || 0);\n        var nodeTop = Number(rrNode.top || 0);\n        var nodeBottom = nodeTop + nodeH;\n        var isTextAll = (nodeAll.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n        if (isTextAll) textAll++;\n\n        if (nodeW > 0.5 || nodeH > 0.5) {\n          var kindAll = isTextAll ? \"texto\" : String((nodeAll.tagName || \"\").toLowerCase());\n          elementRows.push({\n            kind: kindAll,\n            width: nodeW,\n            height: nodeH,\n            top: nodeTop,\n            bottom: nodeBottom,\n            area: nodeW * nodeH,\n            textSample: isTextAll\n              ? ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 70)\n              : \"\"\n          });\n        }\n\n        if (!isTextAll) continue;\n        if (nodeH <= dominantTextH) continue;\n        dominantTextH = nodeH;\n        var csTxt = getComputedStyle(nodeAll);\n        dominantText = {\n          top: +nodeTop.toFixed(1),\n          left: +Number(rrNode.left || 0).toFixed(1),\n          width: +nodeW.toFixed(1),\n          height: +nodeH.toFixed(1),\n          bottom: +nodeBottom.toFixed(1),\n          widthSecRatio: secRectNow.width > 1 ? +(nodeW / secRectNow.width).toFixed(3) : null,\n          heightSecRatio: secRectNow.height > 1 ? +(nodeH / secRectNow.height).toFixed(3) : null,\n          widthViewportRatio: viewportW > 1 ? +(nodeW / viewportW).toFixed(3) : null,\n          heightViewportRatio: viewportH > 1 ? +(nodeH / viewportH).toFixed(3) : null,\n          fontSize: csTxt.fontSize || \"\",\n          lineHeight: csTxt.lineHeight || \"\",\n          textAlign: csTxt.textAlign || \"\",\n          transform: (nodeAll.style && nodeAll.style.transform) ? nodeAll.style.transform : \"\",\n          textSample: ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 90)\n        };\n      }\n\n      for (var fi=0; fi<fitNodes.length; fi++){\n        var fitNode = fitNodes[fi];\n        if ((fitNode.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textFit++;\n      }\n\n      var topElements = elementRows\n        .sort(function(a,b){ return (b.area || 0) - (a.area || 0); })\n        .slice(0, 6)\n        .map(function(row){\n          return {\n            kind: row.kind,\n            width: +Number(row.width || 0).toFixed(1),\n            height: +Number(row.height || 0).toFixed(1),\n            widthSecRatio: secRectNow.width > 1 ? +((row.width || 0) / secRectNow.width).toFixed(3) : null,\n            heightSecRatio: secRectNow.height > 1 ? +((row.height || 0) / secRectNow.height).toFixed(3) : null,\n            widthViewportRatio: viewportW > 1 ? +((row.width || 0) / viewportW).toFixed(3) : null,\n            heightViewportRatio: viewportH > 1 ? +((row.height || 0) / viewportH).toFixed(3) : null,\n            topSecRatio: secRectNow.height > 1 ? +((row.top || 0) / secRectNow.height).toFixed(3) : null,\n            bottomSecRatio: secRectNow.height > 1 ? +((row.bottom || 0) / secRectNow.height).toFixed(3) : null,\n            sample: row.textSample || \"\"\n          };\n        });\n\n      var coverageFit = bounds.width / Math.max(1, secRectNow.width || 0);\n      var coverageAll = boundsAll ? (boundsAll.width / Math.max(1, secRectNow.width || 0)) : null;\n\n      var flatLines = [];\n      flatLines.push(\n        \"sec=\" + String(meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1)\n        + \" viewport=\" + (+Number(viewportW || 0).toFixed(1)) + \"x\" + (+Number(viewportH || 0).toFixed(1))\n        + \" sec=\" + (+Number(secRectNow.width || 0).toFixed(1)) + \"x\" + (+Number(secRectNow.height || 0).toFixed(1))\n        + \" mobileViewport=\" + String(mobileViewport)\n        + \" desktopMobilePreview=\" + String(desktopMobilePreview)\n        + \" mobileUA=\" + String(mobileUA)\n        + \" coarsePointer=\" + String(coarsePointer)\n        + \" touchPoints=\" + String(touchPoints)\n      );\n      flatLines.push(\n        \"fit scale=\" + (+Number(scale || 1).toFixed(3))\n        + \" coverageFit=\" + (+coverageFit.toFixed(3))\n        + \" coverageAll=\" + (coverageAll == null ? \"null\" : String(+coverageAll.toFixed(3)))\n        + \" nodes=\" + String(fitNodesCount) + \"/\" + String(totalNodes)\n        + \" ignoredBleed=\" + String(ignoredBleed)\n        + \" ignoredExplicit=\" + String(ignoredExplicit)\n        + \" tinyShrinkProtected=\" + String(!!(fitDebug && fitDebug.tinyShrinkProtected))\n        + \" pantallaDownscaleBlocked=\" + String(!!(fitDebug && fitDebug.pantallaDownscaleBlocked))\n      );\n      if (dominantText) {\n        flatLines.push(\n          \"dominantText hSecRatio=\" + String(dominantText.heightSecRatio)\n          + \" hViewportRatio=\" + String(dominantText.heightViewportRatio)\n          + \" wSecRatio=\" + String(dominantText.widthSecRatio)\n          + \" fontSize=\" + String(dominantText.fontSize || \"\")\n          + \" lineHeight=\" + String(dominantText.lineHeight || \"\")\n          + \" sample='\" + String(dominantText.textSample || \"\") + \"'\"\n        );\n      } else {\n        flatLines.push(\"dominantText none\");\n      }\n      for (var te=0; te<topElements.length; te++){\n        var e = topElements[te];\n        flatLines.push(\n          \"el#\" + String(te + 1)\n          + \" kind=\" + String(e.kind || \"\")\n          + \" wVp=\" + String(e.widthViewportRatio)\n          + \" hVp=\" + String(e.heightViewportRatio)\n          + \" topSec=\" + String(e.topSecRatio)\n          + \" bottomSec=\" + String(e.bottomSecRatio)\n          + (e.sample ? (\" sample='\" + String(e.sample) + \"'\") : \"\")\n        );\n      }\n      mslLog(\"section:fitScale:pantalla:flat\", flatLines.join(\"\\\\n\"));\n\n      mslLog(\"section:fitScale:pantalla\", {\n        secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\n        secW: +Number(secRectNow.width || 0).toFixed(1),\n        secH: +Number(secRectNow.height || 0).toFixed(1),\n        viewport: {\n          width: +Number(viewportW || 0).toFixed(1),\n          height: +Number(viewportH || 0).toFixed(1)\n        },\n        displayContext: {\n          mobileViewport: mobileViewport,\n          desktopMobilePreview: desktopMobilePreview,\n          mobileUA: mobileUA,\n          coarsePointer: coarsePointer,\n          touchPoints: touchPoints\n        },\n        preserveBottomGap: +preserveBottomGap.toFixed(1),\n        totalNodes: totalNodes,\n        fitNodes: fitNodesCount,\n        textNodesAll: textAll,\n        textNodesFit: textFit,\n        ignoredBleed: ignoredBleed,\n        ignoredExplicit: ignoredExplicit,\n        coverageFit: +coverageFit.toFixed(3),\n        coverageAll: coverageAll == null ? null : +coverageAll.toFixed(3),\n        fitBounds: {\n          width: +Number(bounds.width || 0).toFixed(1),\n          height: +Number(bounds.height || 0).toFixed(1),\n          maxBottom: +Number(bounds.maxBottom || 0).toFixed(1)\n        },\n        allBounds: boundsAll ? {\n          width: +Number(boundsAll.width || 0).toFixed(1),\n          height: +Number(boundsAll.height || 0).toFixed(1),\n          maxBottom: +Number(boundsAll.maxBottom || 0).toFixed(1)\n        } : null,\n        fitDebug: fitDebug ? {\n          targetCoverage: +Number(fitDebug.targetCoverage || 0).toFixed(3),\n          minFillForUpscale: +Number(fitDebug.minFillForUpscale || 0).toFixed(3),\n          coverage: +Number(fitDebug.coverage || 0).toFixed(3),\n          initialScale: +Number(fitDebug.initialScale || 0).toFixed(3),\n          maxScaleByWidth: fitDebug.maxScaleByWidth == null ? null : +Number(fitDebug.maxScaleByWidth).toFixed(3),\n          maxScaleByHeight: fitDebug.maxScaleByHeight == null ? null : +Number(fitDebug.maxScaleByHeight).toFixed(3),\n          scaleAfterWidthClamp: fitDebug.scaleAfterWidthClamp == null ? null : +Number(fitDebug.scaleAfterWidthClamp).toFixed(3),\n          scaleAfterHeightClamp: fitDebug.scaleAfterHeightClamp == null ? null : +Number(fitDebug.scaleAfterHeightClamp).toFixed(3),\n          tinyShrinkProtected: !!fitDebug.tinyShrinkProtected,\n          pantallaDownscaleBlocked: !!fitDebug.pantallaDownscaleBlocked\n        } : null,\n        appliedScale: +Number(scale || 1).toFixed(3),\n        dominantText: dominantText,\n        topElements: topElements\n      });\n    }\n\n    sec.setAttribute(\"data-msl-fit-scale\", String(+scale.toFixed(3)));\n    mslLog(\"section:fitScale\", {\n      secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\n      mode: secModo,\n      nodes: bounds.count,\n      coverage: +(bounds.width / Math.max(1, sec.getBoundingClientRect().width || 0)).toFixed(3),\n      boxW: +bounds.width.toFixed(1),\n      boxH: +bounds.height.toFixed(1),\n      scale: +scale.toFixed(3),\n      preserveBottomGap: +preserveBottomGap.toFixed(1),\n      scaledBottomGap: +((preserveBottomGap || 0) * scale).toFixed(1),\n      neededHeight: neededHeight\n    });\n\n    return {\n      scale: scale,\n      neededHeight: neededHeight,\n      bounds: bounds\n    };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyYlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGZpdFNjYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHNcbmV4cG9ydCBmdW5jdGlvbiBqc0ZpdFNjYWxlQmxvY2soKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgZnVuY3Rpb24gZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCl7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctdHJhbnNmb3JtXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIiwgZWwuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLW9yaWdpblwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctb3JpZ2luXCIsIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiB8fCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlRml0U2NhbGVCYXNlbGluZShlbCl7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoZWwpO1xuICAgIHZhciBiYXNlVHJhbnNmb3JtID0gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctdHJhbnNmb3JtXCIpIHx8IFwiXCI7XG4gICAgdmFyIGJhc2VPcmlnaW4gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy1vcmlnaW5cIikgfHwgXCJcIjtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICAgIGlmIChiYXNlT3JpZ2luKSBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBiYXNlT3JpZ2luO1xuICAgIGVsc2UgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2Zvcm0tb3JpZ2luXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlFbGVtZW50Rml0U2NhbGUoZWwsIHNjYWxlKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCk7XG4gICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikgfHwgXCJcIjtcbiAgICB2YXIgbmV4dCA9IGJhc2VUcmFuc2Zvcm0gPyAoYmFzZVRyYW5zZm9ybSArIFwiIHNjYWxlKFwiICsgc2NhbGUgKyBcIilcIikgOiAoXCJzY2FsZShcIiArIHNjYWxlICsgXCIpXCIpO1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IG5leHQ7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFNlY3Rpb25GaXRTY2FsZShfc2VjLCBjb250ZW50LCBibGVlZCl7XG4gICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoY29udGVudCk7XG4gICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlcyl7XG4gICAgaWYgKCFzZWMgfHwgIW5vZGVzIHx8ICFub2Rlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBtaW5MZWZ0ID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblRvcCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhSaWdodCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4Qm90dG9tID0gLUluZmluaXR5O1xuICAgIHZhciB2YWxpZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgICB2YXIgcnIgPSByZWxSZWN0KG5vZGUsIHNlYyk7XG4gICAgICB2YXIgdyA9IE51bWJlcihyci53aWR0aCB8fCAwKTtcbiAgICAgIHZhciBoID0gTnVtYmVyKHJyLmhlaWdodCB8fCAwKTtcbiAgICAgIGlmICh3IDw9IDAuNSAmJiBoIDw9IDAuNSkgY29udGludWU7XG5cbiAgICAgIHZhciBsID0gTnVtYmVyKHJyLmxlZnQgfHwgMCk7XG4gICAgICB2YXIgdCA9IE51bWJlcihyci50b3AgfHwgMCk7XG4gICAgICB2YXIgciA9IGwgKyBNYXRoLm1heCgwLCB3KTtcbiAgICAgIHZhciBiID0gdCArIE1hdGgubWF4KDAsIGgpO1xuXG4gICAgICBpZiAoIWlzRmluaXRlKGwpIHx8ICFpc0Zpbml0ZSh0KSB8fCAhaXNGaW5pdGUocikgfHwgIWlzRmluaXRlKGIpKSBjb250aW51ZTtcblxuICAgICAgbWluTGVmdCA9IE1hdGgubWluKG1pbkxlZnQsIGwpO1xuICAgICAgbWluVG9wID0gTWF0aC5taW4obWluVG9wLCB0KTtcbiAgICAgIG1heFJpZ2h0ID0gTWF0aC5tYXgobWF4UmlnaHQsIHIpO1xuICAgICAgbWF4Qm90dG9tID0gTWF0aC5tYXgobWF4Qm90dG9tLCBiKTtcbiAgICAgIHZhbGlkKys7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCB8fCAhaXNGaW5pdGUobWluTGVmdCkgfHwgIWlzRmluaXRlKG1heFJpZ2h0KSB8fCAhaXNGaW5pdGUobWluVG9wKSB8fCAhaXNGaW5pdGUobWF4Qm90dG9tKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbkxlZnQ6IG1pbkxlZnQsXG4gICAgICBtaW5Ub3A6IG1pblRvcCxcbiAgICAgIG1heFJpZ2h0OiBtYXhSaWdodCxcbiAgICAgIG1heEJvdHRvbTogbWF4Qm90dG9tLFxuICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIG1heFJpZ2h0IC0gbWluTGVmdCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG1heEJvdHRvbSAtIG1pblRvcCksXG4gICAgICBjb3VudDogdmFsaWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUZpdFNjYWxlKHNlYywgYm91bmRzLCBzZWNNb2RvLCBDRkcpe1xuICAgIGlmICghc2VjIHx8ICFib3VuZHMpIHJldHVybiAxO1xuICAgIHZhciBzZWNSZWN0ID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzZWNXID0gTnVtYmVyKHNlY1JlY3Qud2lkdGggfHwgMCk7XG4gICAgdmFyIHNlY0ggPSBOdW1iZXIoc2VjUmVjdC5oZWlnaHQgfHwgMCk7XG4gICAgaWYgKHNlY1cgPD0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGRlYnVnOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRDb3ZlcmFnZSA9IGNsYW1wKE51bWJlcihDRkcuRklUX1RBUkdFVF9XSURUSF9SQVRJTyB8fCAwLjk0KSwgMC43NSwgMC45OSk7XG4gICAgdmFyIG1pbkZpbGxGb3JVcHNjYWxlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfTUlOX0ZJTExfUkFUSU8gfHwgMC45KSwgMC42LCB0YXJnZXRDb3ZlcmFnZSk7XG4gICAgdmFyIG1pblNjYWxlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfTUlOX1NDQUxFIHx8IDAuODgpLCAwLjcsIDEpO1xuICAgIHZhciBtYXhTY2FsZSA9IE1hdGgubWF4KDEsIE51bWJlcihDRkcuRklUX01BWF9TQ0FMRSB8fCAxLjE2KSk7XG5cbiAgICB2YXIgY29udGVudFcgPSBNYXRoLm1heCgxLCBOdW1iZXIoYm91bmRzLndpZHRoIHx8IDApKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBjb250ZW50VyAvIHNlY1c7XG5cbiAgICB2YXIgc2NhbGUgPSAxO1xuICAgIHZhciBkZWJ1ZyA9IHtcbiAgICAgIHNlY1c6IHNlY1csXG4gICAgICBzZWNIOiBzZWNILFxuICAgICAgdGFyZ2V0Q292ZXJhZ2U6IHRhcmdldENvdmVyYWdlLFxuICAgICAgbWluRmlsbEZvclVwc2NhbGU6IG1pbkZpbGxGb3JVcHNjYWxlLFxuICAgICAgbWluU2NhbGU6IG1pblNjYWxlLFxuICAgICAgbWF4U2NhbGU6IG1heFNjYWxlLFxuICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgaW5pdGlhbFNjYWxlOiAxLFxuICAgICAgbWF4U2NhbGVCeVdpZHRoOiBudWxsLFxuICAgICAgbWF4U2NhbGVCeUhlaWdodDogbnVsbCxcbiAgICAgIHNjYWxlQWZ0ZXJXaWR0aENsYW1wOiBudWxsLFxuICAgICAgc2NhbGVBZnRlckhlaWdodENsYW1wOiBudWxsLFxuICAgICAgdGlueVNocmlua1Byb3RlY3RlZDogZmFsc2UsXG4gICAgICBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoY292ZXJhZ2UgPCBtaW5GaWxsRm9yVXBzY2FsZSkge1xuICAgICAgc2NhbGUgPSB0YXJnZXRDb3ZlcmFnZSAvIE1hdGgubWF4KDAuMDEsIGNvdmVyYWdlKTtcbiAgICB9XG4gICAgZGVidWcuaW5pdGlhbFNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAoc2NhbGUgPj0gMSkgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4U2NhbGUpO1xuICAgIGVsc2Ugc2NhbGUgPSBNYXRoLm1heChzY2FsZSwgbWluU2NhbGUpO1xuXG4gICAgLy8gTMOtbWl0ZSBob3Jpem9udGFsIGR1cm8gcG9yIGNlbnRybyB2aXN1YWwuXG4gICAgdmFyIGNlbnRlclggPSBzZWNXIC8gMjtcbiAgICB2YXIgZGlzdExlZnQgPSBNYXRoLm1heCgwLCBjZW50ZXJYIC0gTnVtYmVyKGJvdW5kcy5taW5MZWZ0IHx8IDApKTtcbiAgICB2YXIgZGlzdFJpZ2h0ID0gTWF0aC5tYXgoMCwgTnVtYmVyKGJvdW5kcy5tYXhSaWdodCB8fCAwKSAtIGNlbnRlclgpO1xuICAgIHZhciBtYXhTY2FsZUJ5V2lkdGggPSBJbmZpbml0eTtcbiAgICBpZiAoZGlzdExlZnQgPiAwLjUpIHtcbiAgICAgIG1heFNjYWxlQnlXaWR0aCA9IE1hdGgubWluKG1heFNjYWxlQnlXaWR0aCwgY2VudGVyWCAvIGRpc3RMZWZ0KTtcbiAgICB9XG4gICAgaWYgKGRpc3RSaWdodCA+IDAuNSkge1xuICAgICAgbWF4U2NhbGVCeVdpZHRoID0gTWF0aC5taW4obWF4U2NhbGVCeVdpZHRoLCAoc2VjVyAtIGNlbnRlclgpIC8gZGlzdFJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKG1heFNjYWxlQnlXaWR0aCkgJiYgbWF4U2NhbGVCeVdpZHRoID4gMCkge1xuICAgICAgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4U2NhbGVCeVdpZHRoKTtcbiAgICAgIGRlYnVnLm1heFNjYWxlQnlXaWR0aCA9IG1heFNjYWxlQnlXaWR0aDtcbiAgICB9XG4gICAgZGVidWcuc2NhbGVBZnRlcldpZHRoQ2xhbXAgPSBzY2FsZTtcblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIgJiYgc2NhbGUgPCAxICYmIHNjYWxlID4gMC45NCkge1xuICAgICAgLy8gQXZvaWQgc2hyaW5raW5nIFwicGFudGFsbGFcIiBmb3IgdGlueSBvdmVyZmxvd3M7IHByZXNlcnZlIHZpc3VhbCBpbXBhY3QuXG4gICAgICBzY2FsZSA9IDE7XG4gICAgICBkZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBFbiBtb2RvIHBhbnRhbGxhIG5vIGRlamFtb3MgcXVlIGVsIGNvbnRlbmlkbyBzZSByZWNvcnRlIHBvciBhbHR1cmEuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzZWNIID4gMSkge1xuICAgICAgdmFyIG1heEJvdHRvbSA9IE51bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApO1xuICAgICAgaWYgKG1heEJvdHRvbSA+IDEpIHtcbiAgICAgICAgdmFyIG1heFNjYWxlQnlIZWlnaHQgPSBzZWNIIC8gbWF4Qm90dG9tO1xuICAgICAgICBpZiAoaXNGaW5pdGUobWF4U2NhbGVCeUhlaWdodCkgJiYgbWF4U2NhbGVCeUhlaWdodCA+IDApIHtcbiAgICAgICAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZUJ5SGVpZ2h0KTtcbiAgICAgICAgICBkZWJ1Zy5tYXhTY2FsZUJ5SGVpZ2h0ID0gbWF4U2NhbGVCeUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1Zy5zY2FsZUFmdGVySGVpZ2h0Q2xhbXAgPSBzY2FsZTtcblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIgJiYgc2NhbGUgPCAxKSB7XG4gICAgICAvLyBQYW50YWxsYSBzZWN0aW9ucyBhbHJlYWR5IGhhdmUgdGhlaXIgb3duIHZpZXdwb3J0LWZpdCBsb2dpYy5cbiAgICAgIC8vIEF2b2lkIGFkZGl0aW9uYWwgZG93bnNjYWxlIGhlcmUgdG8ga2VlcCBoZXJvIHRleHQgcmVhZGFibGUuXG4gICAgICBzY2FsZSA9IDE7XG4gICAgICBkZWJ1Zy5wYW50YWxsYURvd25zY2FsZUJsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUoc2NhbGUpIHx8IHNjYWxlIDw9IDApIHNjYWxlID0gMTtcbiAgICBpZiAoTWF0aC5hYnMoc2NhbGUgLSAxKSA8IDAuMDIpIHNjYWxlID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgZGVidWc6IGRlYnVnXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5U2VjdGlvbkZpdFNjYWxlKHNlYywgY29udGVudCwgYmxlZWQsIG5vZGVzQWxsLCBzZWNNb2RvLCBDRkcsIG1ldGEsIG9wdHMpe1xuICAgIGlmICghc2VjIHx8ICFjb250ZW50KSB7XG4gICAgICByZXR1cm4geyBzY2FsZTogMSwgbmVlZGVkSGVpZ2h0OiAwLCBib3VuZHM6IG51bGwgfTtcbiAgICB9XG5cbiAgICBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGNvbnRlbnQpO1xuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICAgIHZhciBwcmVzZXJ2ZUJvdHRvbUdhcCA9IDA7XG4gICAgaWYgKG9wdHMgJiYgTnVtYmVyLmlzRmluaXRlKG9wdHMucHJlc2VydmVCb3R0b21HYXApKSB7XG4gICAgICBwcmVzZXJ2ZUJvdHRvbUdhcCA9IE1hdGgubWF4KDAsIE51bWJlcihvcHRzLnByZXNlcnZlQm90dG9tR2FwKSk7XG4gICAgfVxuXG4gICAgdmFyIGZpdE5vZGVzID0gKG5vZGVzQWxsIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBmaXRNb2RlID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZml0TW9kZSA9PT0gXCJpZ25vcmVcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG5vZGUuY2xvc2VzdCAmJiBub2RlLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBib3VuZHMgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIGZpdE5vZGVzKTtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgYm91bmRzID0gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlc0FsbCB8fCBbXSk7XG4gICAgfVxuICAgIGlmICghYm91bmRzKSB7XG4gICAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShjb250ZW50KTtcbiAgICAgIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGJsZWVkKTtcbiAgICAgIHNlYy5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtc2NhbGVcIiwgXCIxXCIpO1xuICAgICAgcmV0dXJuIHsgc2NhbGU6IDEsIG5lZWRlZEhlaWdodDogMCwgYm91bmRzOiBudWxsIH07XG4gICAgfVxuXG4gICAgdmFyIGZpdFJlc3VsdCA9IGNvbXB1dGVGaXRTY2FsZShzZWMsIGJvdW5kcywgc2VjTW9kbywgQ0ZHKTtcbiAgICB2YXIgc2NhbGUgPSAoZml0UmVzdWx0ICYmIE51bWJlci5pc0Zpbml0ZShmaXRSZXN1bHQuc2NhbGUpKSA/IGZpdFJlc3VsdC5zY2FsZSA6IDE7XG4gICAgdmFyIGZpdERlYnVnID0gZml0UmVzdWx0ICYmIGZpdFJlc3VsdC5kZWJ1ZyA/IGZpdFJlc3VsdC5kZWJ1ZyA6IG51bGw7XG4gICAgYXBwbHlFbGVtZW50Rml0U2NhbGUoY29udGVudCwgc2NhbGUpO1xuICAgIGFwcGx5RWxlbWVudEZpdFNjYWxlKGJsZWVkLCBzY2FsZSk7XG5cbiAgICB2YXIgbmVlZGVkSGVpZ2h0ID0gMDtcbiAgICBpZiAoc2VjTW9kbyAhPT0gXCJwYW50YWxsYVwiKSB7XG4gICAgICB2YXIgbWF4Qm90dG9tV2l0aEdhcCA9IE51bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApICsgcHJlc2VydmVCb3R0b21HYXA7XG4gICAgICBuZWVkZWRIZWlnaHQgPSBNYXRoLmNlaWwobWF4Qm90dG9tV2l0aEdhcCAqIHNjYWxlICsgKENGRy5QQURfQk9UIHx8IDApKTtcbiAgICB9XG5cbiAgICBpZiAoc2VjTW9kbyA9PT0gXCJwYW50YWxsYVwiKSB7XG4gICAgICB2YXIgc2VjUmVjdE5vdyA9IHNlYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB2diA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbiAgICAgIHZhciB2aWV3cG9ydFcgPSAodnYgJiYgdnYud2lkdGgpID8gdnYud2lkdGggOiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDApO1xuICAgICAgdmFyIHZpZXdwb3J0SCA9ICh2diAmJiB2di5oZWlnaHQpID8gdnYuaGVpZ2h0IDogKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDApO1xuICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICAgICAgdmFyIG1vYmlsZVVBID0gL0FuZHJvaWR8aVBob25lfGlQYWR8aVBvZHxNb2JpbGUvaS50ZXN0KHVhKTtcbiAgICAgIHZhciB0b3VjaFBvaW50cyA9IE51bWJlcihuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgMCk7XG4gICAgICB2YXIgY29hcnNlUG9pbnRlciA9IGZhbHNlO1xuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHRyeSB7IGNvYXJzZVBvaW50ZXIgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwb2ludGVyOiBjb2Fyc2UpXCIpLm1hdGNoZXM7IH0gY2F0Y2goX2UpIHt9XG4gICAgICB9XG4gICAgICB2YXIgbW9iaWxlVmlld3BvcnQgPSB2aWV3cG9ydFcgPD0gNzY3O1xuICAgICAgdmFyIGRlc2t0b3BNb2JpbGVQcmV2aWV3ID0gbW9iaWxlVmlld3BvcnQgJiYgIW1vYmlsZVVBO1xuXG4gICAgICB2YXIgYm91bmRzQWxsID0gY29tcHV0ZVNlY3Rpb25Cb3VuZHMoc2VjLCBub2Rlc0FsbCB8fCBbXSk7XG4gICAgICB2YXIgdG90YWxOb2RlcyA9IChub2Rlc0FsbCB8fCBbXSkubGVuZ3RoO1xuICAgICAgdmFyIGZpdE5vZGVzQ291bnQgPSBmaXROb2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgdGV4dEFsbCA9IDA7XG4gICAgICB2YXIgdGV4dEZpdCA9IDA7XG4gICAgICB2YXIgaWdub3JlZEJsZWVkID0gMDtcbiAgICAgIHZhciBpZ25vcmVkRXhwbGljaXQgPSAwO1xuICAgICAgdmFyIGRvbWluYW50VGV4dCA9IG51bGw7XG4gICAgICB2YXIgZG9taW5hbnRUZXh0SCA9IC0xO1xuICAgICAgdmFyIGVsZW1lbnRSb3dzID0gW107XG5cbiAgICAgIGZvciAodmFyIG5pPTA7IG5pPHRvdGFsTm9kZXM7IG5pKyspe1xuICAgICAgICB2YXIgbm9kZUFsbCA9IG5vZGVzQWxsW25pXTtcbiAgICAgICAgaWYgKCFub2RlQWxsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZml0TW9kZUFsbCA9IChub2RlQWxsLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWZpdFwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZml0TW9kZUFsbCA9PT0gXCJpZ25vcmVcIikgaWdub3JlZEV4cGxpY2l0Kys7XG4gICAgICAgIGlmIChub2RlQWxsLmNsb3Nlc3QgJiYgbm9kZUFsbC5jbG9zZXN0KFwiLnNlYy1ibGVlZFwiKSkgaWdub3JlZEJsZWVkKys7XG5cbiAgICAgICAgdmFyIHJyTm9kZSA9IHJlbFJlY3Qobm9kZUFsbCwgc2VjKTtcbiAgICAgICAgdmFyIG5vZGVXID0gTnVtYmVyKHJyTm9kZS53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVIID0gTnVtYmVyKHJyTm9kZS5oZWlnaHQgfHwgMCk7XG4gICAgICAgIHZhciBub2RlVG9wID0gTnVtYmVyKHJyTm9kZS50b3AgfHwgMCk7XG4gICAgICAgIHZhciBub2RlQm90dG9tID0gbm9kZVRvcCArIG5vZGVIO1xuICAgICAgICB2YXIgaXNUZXh0QWxsID0gKG5vZGVBbGwuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgIGlmIChpc1RleHRBbGwpIHRleHRBbGwrKztcblxuICAgICAgICBpZiAobm9kZVcgPiAwLjUgfHwgbm9kZUggPiAwLjUpIHtcbiAgICAgICAgICB2YXIga2luZEFsbCA9IGlzVGV4dEFsbCA/IFwidGV4dG9cIiA6IFN0cmluZygobm9kZUFsbC50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGVsZW1lbnRSb3dzLnB1c2goe1xuICAgICAgICAgICAga2luZDoga2luZEFsbCxcbiAgICAgICAgICAgIHdpZHRoOiBub2RlVyxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZUgsXG4gICAgICAgICAgICB0b3A6IG5vZGVUb3AsXG4gICAgICAgICAgICBib3R0b206IG5vZGVCb3R0b20sXG4gICAgICAgICAgICBhcmVhOiBub2RlVyAqIG5vZGVILFxuICAgICAgICAgICAgdGV4dFNhbXBsZTogaXNUZXh0QWxsXG4gICAgICAgICAgICAgID8gKChub2RlQWxsLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA3MClcbiAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVGV4dEFsbCkgY29udGludWU7XG4gICAgICAgIGlmIChub2RlSCA8PSBkb21pbmFudFRleHRIKSBjb250aW51ZTtcbiAgICAgICAgZG9taW5hbnRUZXh0SCA9IG5vZGVIO1xuICAgICAgICB2YXIgY3NUeHQgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGVBbGwpO1xuICAgICAgICBkb21pbmFudFRleHQgPSB7XG4gICAgICAgICAgdG9wOiArbm9kZVRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGxlZnQ6ICtOdW1iZXIocnJOb2RlLmxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICB3aWR0aDogK25vZGVXLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArbm9kZUgudG9GaXhlZCgxKSxcbiAgICAgICAgICBib3R0b206ICtub2RlQm90dG9tLnRvRml4ZWQoMSksXG4gICAgICAgICAgd2lkdGhTZWNSYXRpbzogc2VjUmVjdE5vdy53aWR0aCA+IDEgPyArKG5vZGVXIC8gc2VjUmVjdE5vdy53aWR0aCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0U2VjUmF0aW86IHNlY1JlY3ROb3cuaGVpZ2h0ID4gMSA/ICsobm9kZUggLyBzZWNSZWN0Tm93LmhlaWdodCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgd2lkdGhWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydFcgPiAxID8gKyhub2RlVyAvIHZpZXdwb3J0VykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0Vmlld3BvcnRSYXRpbzogdmlld3BvcnRIID4gMSA/ICsobm9kZUggLyB2aWV3cG9ydEgpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgIGZvbnRTaXplOiBjc1R4dC5mb250U2l6ZSB8fCBcIlwiLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IGNzVHh0LmxpbmVIZWlnaHQgfHwgXCJcIixcbiAgICAgICAgICB0ZXh0QWxpZ246IGNzVHh0LnRleHRBbGlnbiB8fCBcIlwiLFxuICAgICAgICAgIHRyYW5zZm9ybTogKG5vZGVBbGwuc3R5bGUgJiYgbm9kZUFsbC5zdHlsZS50cmFuc2Zvcm0pID8gbm9kZUFsbC5zdHlsZS50cmFuc2Zvcm0gOiBcIlwiLFxuICAgICAgICAgIHRleHRTYW1wbGU6ICgobm9kZUFsbC50ZXh0Q29udGVudCB8fCBcIlwiKS50cmltKCkpLnJlcGxhY2UoL1xcXFxzKy9nLCBcIiBcIikuc2xpY2UoMCwgOTApXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGZpPTA7IGZpPGZpdE5vZGVzLmxlbmd0aDsgZmkrKyl7XG4gICAgICAgIHZhciBmaXROb2RlID0gZml0Tm9kZXNbZmldO1xuICAgICAgICBpZiAoKGZpdE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHRGaXQrKztcbiAgICAgIH1cblxuICAgICAgdmFyIHRvcEVsZW1lbnRzID0gZWxlbWVudFJvd3NcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIChiLmFyZWEgfHwgMCkgLSAoYS5hcmVhIHx8IDApOyB9KVxuICAgICAgICAuc2xpY2UoMCwgNilcbiAgICAgICAgLm1hcChmdW5jdGlvbihyb3cpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiByb3cua2luZCxcbiAgICAgICAgICAgIHdpZHRoOiArTnVtYmVyKHJvdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKHJvdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHdpZHRoU2VjUmF0aW86IHNlY1JlY3ROb3cud2lkdGggPiAxID8gKygocm93LndpZHRoIHx8IDApIC8gc2VjUmVjdE5vdy53aWR0aCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBoZWlnaHRTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKygocm93LmhlaWdodCB8fCAwKSAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIHdpZHRoVmlld3BvcnRSYXRpbzogdmlld3BvcnRXID4gMSA/ICsoKHJvdy53aWR0aCB8fCAwKSAvIHZpZXdwb3J0VykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBoZWlnaHRWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydEggPiAxID8gKygocm93LmhlaWdodCB8fCAwKSAvIHZpZXdwb3J0SCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICB0b3BTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKygocm93LnRvcCB8fCAwKSAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGJvdHRvbVNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cuYm90dG9tIHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgc2FtcGxlOiByb3cudGV4dFNhbXBsZSB8fCBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHZhciBjb3ZlcmFnZUZpdCA9IGJvdW5kcy53aWR0aCAvIE1hdGgubWF4KDEsIHNlY1JlY3ROb3cud2lkdGggfHwgMCk7XG4gICAgICB2YXIgY292ZXJhZ2VBbGwgPSBib3VuZHNBbGwgPyAoYm91bmRzQWxsLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjUmVjdE5vdy53aWR0aCB8fCAwKSkgOiBudWxsO1xuXG4gICAgICB2YXIgZmxhdExpbmVzID0gW107XG4gICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgXCJzZWM9XCIgKyBTdHJpbmcobWV0YSAmJiBOdW1iZXIuaXNGaW5pdGUobWV0YS5zZWNJbmRleCkgPyBtZXRhLnNlY0luZGV4IDogLTEpXG4gICAgICAgICsgXCIgdmlld3BvcnQ9XCIgKyAoK051bWJlcih2aWV3cG9ydFcgfHwgMCkudG9GaXhlZCgxKSkgKyBcInhcIiArICgrTnVtYmVyKHZpZXdwb3J0SCB8fCAwKS50b0ZpeGVkKDEpKVxuICAgICAgICArIFwiIHNlYz1cIiArICgrTnVtYmVyKHNlY1JlY3ROb3cud2lkdGggfHwgMCkudG9GaXhlZCgxKSkgKyBcInhcIiArICgrTnVtYmVyKHNlY1JlY3ROb3cuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSkpXG4gICAgICAgICsgXCIgbW9iaWxlVmlld3BvcnQ9XCIgKyBTdHJpbmcobW9iaWxlVmlld3BvcnQpXG4gICAgICAgICsgXCIgZGVza3RvcE1vYmlsZVByZXZpZXc9XCIgKyBTdHJpbmcoZGVza3RvcE1vYmlsZVByZXZpZXcpXG4gICAgICAgICsgXCIgbW9iaWxlVUE9XCIgKyBTdHJpbmcobW9iaWxlVUEpXG4gICAgICAgICsgXCIgY29hcnNlUG9pbnRlcj1cIiArIFN0cmluZyhjb2Fyc2VQb2ludGVyKVxuICAgICAgICArIFwiIHRvdWNoUG9pbnRzPVwiICsgU3RyaW5nKHRvdWNoUG9pbnRzKVxuICAgICAgKTtcbiAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICBcImZpdCBzY2FsZT1cIiArICgrTnVtYmVyKHNjYWxlIHx8IDEpLnRvRml4ZWQoMykpXG4gICAgICAgICsgXCIgY292ZXJhZ2VGaXQ9XCIgKyAoK2NvdmVyYWdlRml0LnRvRml4ZWQoMykpXG4gICAgICAgICsgXCIgY292ZXJhZ2VBbGw9XCIgKyAoY292ZXJhZ2VBbGwgPT0gbnVsbCA/IFwibnVsbFwiIDogU3RyaW5nKCtjb3ZlcmFnZUFsbC50b0ZpeGVkKDMpKSlcbiAgICAgICAgKyBcIiBub2Rlcz1cIiArIFN0cmluZyhmaXROb2Rlc0NvdW50KSArIFwiL1wiICsgU3RyaW5nKHRvdGFsTm9kZXMpXG4gICAgICAgICsgXCIgaWdub3JlZEJsZWVkPVwiICsgU3RyaW5nKGlnbm9yZWRCbGVlZClcbiAgICAgICAgKyBcIiBpZ25vcmVkRXhwbGljaXQ9XCIgKyBTdHJpbmcoaWdub3JlZEV4cGxpY2l0KVxuICAgICAgICArIFwiIHRpbnlTaHJpbmtQcm90ZWN0ZWQ9XCIgKyBTdHJpbmcoISEoZml0RGVidWcgJiYgZml0RGVidWcudGlueVNocmlua1Byb3RlY3RlZCkpXG4gICAgICAgICsgXCIgcGFudGFsbGFEb3duc2NhbGVCbG9ja2VkPVwiICsgU3RyaW5nKCEhKGZpdERlYnVnICYmIGZpdERlYnVnLnBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZCkpXG4gICAgICApO1xuICAgICAgaWYgKGRvbWluYW50VGV4dCkge1xuICAgICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgICBcImRvbWluYW50VGV4dCBoU2VjUmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmhlaWdodFNlY1JhdGlvKVxuICAgICAgICAgICsgXCIgaFZpZXdwb3J0UmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmhlaWdodFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiB3U2VjUmF0aW89XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LndpZHRoU2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBmb250U2l6ZT1cIiArIFN0cmluZyhkb21pbmFudFRleHQuZm9udFNpemUgfHwgXCJcIilcbiAgICAgICAgICArIFwiIGxpbmVIZWlnaHQ9XCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LmxpbmVIZWlnaHQgfHwgXCJcIilcbiAgICAgICAgICArIFwiIHNhbXBsZT0nXCIgKyBTdHJpbmcoZG9taW5hbnRUZXh0LnRleHRTYW1wbGUgfHwgXCJcIikgKyBcIidcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdExpbmVzLnB1c2goXCJkb21pbmFudFRleHQgbm9uZVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHRlPTA7IHRlPHRvcEVsZW1lbnRzLmxlbmd0aDsgdGUrKyl7XG4gICAgICAgIHZhciBlID0gdG9wRWxlbWVudHNbdGVdO1xuICAgICAgICBmbGF0TGluZXMucHVzaChcbiAgICAgICAgICBcImVsI1wiICsgU3RyaW5nKHRlICsgMSlcbiAgICAgICAgICArIFwiIGtpbmQ9XCIgKyBTdHJpbmcoZS5raW5kIHx8IFwiXCIpXG4gICAgICAgICAgKyBcIiB3VnA9XCIgKyBTdHJpbmcoZS53aWR0aFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiBoVnA9XCIgKyBTdHJpbmcoZS5oZWlnaHRWaWV3cG9ydFJhdGlvKVxuICAgICAgICAgICsgXCIgdG9wU2VjPVwiICsgU3RyaW5nKGUudG9wU2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBib3R0b21TZWM9XCIgKyBTdHJpbmcoZS5ib3R0b21TZWNSYXRpbylcbiAgICAgICAgICArIChlLnNhbXBsZSA/IChcIiBzYW1wbGU9J1wiICsgU3RyaW5nKGUuc2FtcGxlKSArIFwiJ1wiKSA6IFwiXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmZpdFNjYWxlOnBhbnRhbGxhOmZsYXRcIiwgZmxhdExpbmVzLmpvaW4oXCJcXFxcblwiKSk7XG5cbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGU6cGFudGFsbGFcIiwge1xuICAgICAgICBzZWNJbmRleDogbWV0YSAmJiBOdW1iZXIuaXNGaW5pdGUobWV0YS5zZWNJbmRleCkgPyBtZXRhLnNlY0luZGV4IDogLTEsXG4gICAgICAgIHNlY1c6ICtOdW1iZXIoc2VjUmVjdE5vdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICBzZWNIOiArTnVtYmVyKHNlY1JlY3ROb3cuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIodmlld3BvcnRXIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKHZpZXdwb3J0SCB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXlDb250ZXh0OiB7XG4gICAgICAgICAgbW9iaWxlVmlld3BvcnQ6IG1vYmlsZVZpZXdwb3J0LFxuICAgICAgICAgIGRlc2t0b3BNb2JpbGVQcmV2aWV3OiBkZXNrdG9wTW9iaWxlUHJldmlldyxcbiAgICAgICAgICBtb2JpbGVVQTogbW9iaWxlVUEsXG4gICAgICAgICAgY29hcnNlUG9pbnRlcjogY29hcnNlUG9pbnRlcixcbiAgICAgICAgICB0b3VjaFBvaW50czogdG91Y2hQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtwcmVzZXJ2ZUJvdHRvbUdhcC50b0ZpeGVkKDEpLFxuICAgICAgICB0b3RhbE5vZGVzOiB0b3RhbE5vZGVzLFxuICAgICAgICBmaXROb2RlczogZml0Tm9kZXNDb3VudCxcbiAgICAgICAgdGV4dE5vZGVzQWxsOiB0ZXh0QWxsLFxuICAgICAgICB0ZXh0Tm9kZXNGaXQ6IHRleHRGaXQsXG4gICAgICAgIGlnbm9yZWRCbGVlZDogaWdub3JlZEJsZWVkLFxuICAgICAgICBpZ25vcmVkRXhwbGljaXQ6IGlnbm9yZWRFeHBsaWNpdCxcbiAgICAgICAgY292ZXJhZ2VGaXQ6ICtjb3ZlcmFnZUZpdC50b0ZpeGVkKDMpLFxuICAgICAgICBjb3ZlcmFnZUFsbDogY292ZXJhZ2VBbGwgPT0gbnVsbCA/IG51bGwgOiArY292ZXJhZ2VBbGwudG9GaXhlZCgzKSxcbiAgICAgICAgZml0Qm91bmRzOiB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIoYm91bmRzLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKGJvdW5kcy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBtYXhCb3R0b206ICtOdW1iZXIoYm91bmRzLm1heEJvdHRvbSB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0sXG4gICAgICAgIGFsbEJvdW5kczogYm91bmRzQWxsID8ge1xuICAgICAgICAgIHdpZHRoOiArTnVtYmVyKGJvdW5kc0FsbC53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIGhlaWdodDogK051bWJlcihib3VuZHNBbGwuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgbWF4Qm90dG9tOiArTnVtYmVyKGJvdW5kc0FsbC5tYXhCb3R0b20gfHwgMCkudG9GaXhlZCgxKVxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgZml0RGVidWc6IGZpdERlYnVnID8ge1xuICAgICAgICAgIHRhcmdldENvdmVyYWdlOiArTnVtYmVyKGZpdERlYnVnLnRhcmdldENvdmVyYWdlIHx8IDApLnRvRml4ZWQoMyksXG4gICAgICAgICAgbWluRmlsbEZvclVwc2NhbGU6ICtOdW1iZXIoZml0RGVidWcubWluRmlsbEZvclVwc2NhbGUgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBjb3ZlcmFnZTogK051bWJlcihmaXREZWJ1Zy5jb3ZlcmFnZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIGluaXRpYWxTY2FsZTogK051bWJlcihmaXREZWJ1Zy5pbml0aWFsU2NhbGUgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBtYXhTY2FsZUJ5V2lkdGg6IGZpdERlYnVnLm1heFNjYWxlQnlXaWR0aCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcubWF4U2NhbGVCeVdpZHRoKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIG1heFNjYWxlQnlIZWlnaHQ6IGZpdERlYnVnLm1heFNjYWxlQnlIZWlnaHQgPT0gbnVsbCA/IG51bGwgOiArTnVtYmVyKGZpdERlYnVnLm1heFNjYWxlQnlIZWlnaHQpLnRvRml4ZWQoMyksXG4gICAgICAgICAgc2NhbGVBZnRlcldpZHRoQ2xhbXA6IGZpdERlYnVnLnNjYWxlQWZ0ZXJXaWR0aENsYW1wID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5zY2FsZUFmdGVyV2lkdGhDbGFtcCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBzY2FsZUFmdGVySGVpZ2h0Q2xhbXA6IGZpdERlYnVnLnNjYWxlQWZ0ZXJIZWlnaHRDbGFtcCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcuc2NhbGVBZnRlckhlaWdodENsYW1wKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIHRpbnlTaHJpbmtQcm90ZWN0ZWQ6ICEhZml0RGVidWcudGlueVNocmlua1Byb3RlY3RlZCxcbiAgICAgICAgICBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ6ICEhZml0RGVidWcucGFudGFsbGFEb3duc2NhbGVCbG9ja2VkXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBhcHBsaWVkU2NhbGU6ICtOdW1iZXIoc2NhbGUgfHwgMSkudG9GaXhlZCgzKSxcbiAgICAgICAgZG9taW5hbnRUZXh0OiBkb21pbmFudFRleHQsXG4gICAgICAgIHRvcEVsZW1lbnRzOiB0b3BFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBTdHJpbmcoK3NjYWxlLnRvRml4ZWQoMykpKTtcbiAgICBtc2xMb2coXCJzZWN0aW9uOmZpdFNjYWxlXCIsIHtcbiAgICAgIHNlY0luZGV4OiBtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSxcbiAgICAgIG1vZGU6IHNlY01vZG8sXG4gICAgICBub2RlczogYm91bmRzLmNvdW50LFxuICAgICAgY292ZXJhZ2U6ICsoYm91bmRzLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IDApKS50b0ZpeGVkKDMpLFxuICAgICAgYm94VzogK2JvdW5kcy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgYm94SDogK2JvdW5kcy5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgIHNjYWxlOiArc2NhbGUudG9GaXhlZCgzKSxcbiAgICAgIHByZXNlcnZlQm90dG9tR2FwOiArcHJlc2VydmVCb3R0b21HYXAudG9GaXhlZCgxKSxcbiAgICAgIHNjYWxlZEJvdHRvbUdhcDogKygocHJlc2VydmVCb3R0b21HYXAgfHwgMCkgKiBzY2FsZSkudG9GaXhlZCgxKSxcbiAgICAgIG5lZWRlZEhlaWdodDogbmVlZGVkSGVpZ2h0XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgbmVlZGVkSGVpZ2h0OiBuZWVkZWRIZWlnaHQsXG4gICAgICBib3VuZHM6IGJvdW5kc1xuICAgIH07XG4gIH1cbmAudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbImpzRml0U2NhbGVCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* reexport safe */ _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__.buildScript),\n/* harmony export */   normalizeConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/config.ts\");\n/* harmony import */ var _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scriptTemplate */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\");\n// functions/src/utils/mobileSmartLayout/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlEQUFpRDtBQUVOO0FBQ0kiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHNcclxuZXhwb3J0IHR5cGUgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5leHBvcnQgeyBub3JtYWxpemVDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcclxuZXhwb3J0IHsgYnVpbGRTY3JpcHQgfSBmcm9tIFwiLi9zY3JpcHRUZW1wbGF0ZVwiO1xyXG4iXSwibmFtZXMiOlsibm9ybWFsaXplQ29uZmlnIiwiYnVpbGRTY3JpcHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/ordering.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsOrderingBlock: () => (/* binding */ jsOrderingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/ordering.ts\nfunction jsOrderingBlock() {\n    return `\n  /**\n   * Ordena CLUSTERS (no items) para lectura mobile.\n   * Devuelve groups (array de columnas/grupos) y mode.\n   *\n   * - three: [colL, colC, colR]\n   * - two:   [left, right]\n   * - rows:  [out] (fila+left)\n   * - one:   [sortedTop]\n   */\n  function orderClustersForMobile(clusters, rootW, CFG){\n    if (!rootW || rootW <= 0) {\n      var o = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n      return { groups: [o], mode: \"one\" };\n    }\n\n    function clusterHasText(c){\n      if (!c || !c.items || !c.items.length) return false;\n      for (var iTxt=0; iTxt<c.items.length; iTxt++){\n        if ((c.items[iTxt].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return true;\n      }\n      return false;\n    }\n\n    function columnHasText(col){\n      if (!col || !col.length) return false;\n      for (var iCol=0; iCol<col.length; iCol++){\n        if (clusterHasText(col[iCol])) return true;\n      }\n      return false;\n    }\n\n    // Un cluster \"invade\" una frontera si queda partido de forma significativa\n    // entre ambos lados de la linea divisoria.\n    function clusterInvadesDivider(c, dividerX){\n      if (!c) return false;\n      var left = Number(c.left || 0);\n      var width = Math.max(0, Number(c.width || 0));\n      var right = left + width;\n      if (width <= 1) return false;\n      if (right <= dividerX || left >= dividerX) return false;\n\n      var partLeft = dividerX - left;\n      var partRight = right - dividerX;\n      var minPart = Math.min(partLeft, partRight);\n      var minRequired = Math.max(22, width * 0.22);\n      return minPart >= minRequired;\n    }\n\n    function dividerInvasionRatio(list, dividerX){\n      if (!list || !list.length) return 0;\n      var invaded = 0;\n      for (var iInv=0; iInv<list.length; iInv++){\n        if (clusterInvadesDivider(list[iInv], dividerX)) invaded++;\n      }\n      return invaded / Math.max(1, list.length);\n    }\n\n    // -------- 0) Intentar 3 columnas claras --------\n    var t1 = rootW / 3;\n    var t2 = (2 * rootW) / 3;\n\n    var colL = [];\n    var colC = [];\n    var colR = [];\n\n    for (var i=0;i<clusters.length;i++){\n      var c = clusters[i];\n      var x = c.cx;\n      if (x < t1) colL.push(c);\n      else if (x < t2) colC.push(c);\n      else colR.push(c);\n    }\n\n    var looksThree =\n      (colL.length >= CFG.MIN_PER_COL_3 && colC.length >= CFG.MIN_PER_COL_3 && colR.length >= CFG.MIN_PER_COL_3);\n    var textColsThree =\n      (columnHasText(colL) ? 1 : 0) +\n      (columnHasText(colC) ? 1 : 0) +\n      (columnHasText(colR) ? 1 : 0);\n    var hasTextSignalThree = textColsThree >= 2;\n    mslLog(\"order:three:candidates\", {\n      rootW: rootW,\n      total: clusters.length,\n      colL: colL.length,\n      colC: colC.length,\n      colR: colR.length,\n      minPerCol3: CFG.MIN_PER_COL_3,\n      textColsThree: textColsThree,\n      hasTextSignalThree: hasTextSignalThree\n    });\n\n    if (looksThree) {\n      var cxs = [];\n      for (var j=0;j<clusters.length;j++) cxs.push(clusters[j].cx);\n      cxs.sort(function(a,b){ return a-b; });\n      var p20 = percentile(cxs, 0.20);\n      var p80 = percentile(cxs, 0.80);\n      var spread = (p80 - p20);\n      mslLog(\"order:three:spread\", {\n        p20: p20,\n        p80: p80,\n        spread: spread,\n        minSpread: rootW * CFG.THREE_COL_SPREAD_RATIO,\n        pass: spread >= rootW * CFG.THREE_COL_SPREAD_RATIO\n      });\n      if (spread < rootW * CFG.THREE_COL_SPREAD_RATIO) looksThree = false;\n    }\n\n    if (looksThree) {\n      var invadeT1 = dividerInvasionRatio(clusters, t1);\n      var invadeT2 = dividerInvasionRatio(clusters, t2);\n      var invadeThree = Math.max(invadeT1, invadeT2);\n      var invasionLimitThree = hasTextSignalThree ? 0.46 : 0.34;\n      mslLog(\"order:three:invasion\", {\n        t1: +t1.toFixed(1),\n        t2: +t2.toFixed(1),\n        invadeT1: +invadeT1.toFixed(3),\n        invadeT2: +invadeT2.toFixed(3),\n        invadeThree: +invadeThree.toFixed(3),\n        limit: +invasionLimitThree.toFixed(3),\n        hasTextSignalThree: hasTextSignalThree,\n        pass: invadeThree <= invasionLimitThree\n      });\n      if (invadeThree > invasionLimitThree) looksThree = false;\n    }\n\n    if (looksThree) {\n      colL.sort(function(a,b){ return a.top - b.top; });\n      colC.sort(function(a,b){ return a.top - b.top; });\n      colR.sort(function(a,b){ return a.top - b.top; });\n      return { groups: [colL, colC, colR], mode: \"three\" };\n    }\n\n    // -------- 1) Intentar 2 columnas claras --------\n    var mid = rootW / 2;\n    var left = [];\n    var right = [];\n\n    for (var k=0;k<clusters.length;k++){\n      var c2 = clusters[k];\n      if (c2.cx < mid) left.push(c2);\n      else right.push(c2);\n    }\n\n    var looksTwo = (left.length >= CFG.MIN_PER_COL_2 && right.length >= CFG.MIN_PER_COL_2);\n    var hasTextSignalTwo = columnHasText(left) && columnHasText(right);\n    mslLog(\"order:two:candidates\", {\n      rootW: rootW,\n      total: clusters.length,\n      left: left.length,\n      right: right.length,\n      minPerCol2: CFG.MIN_PER_COL_2,\n      hasTextSignalTwo: hasTextSignalTwo\n    });\n\n    // Politica para pares (2 clusters):\n    // - par de columnas reales => mode \"two\"\n    // - resto de casos => mode \"one\" (fitCheck decide si reflowea)\n    if (clusters.length === 2) {\n      var cA = clusters[0];\n      var cB = clusters[1];\n\n      function pairStats(c){\n        var text = 0;\n        var non = 0;\n        var force = 0;\n        for (var q=0; q<c.items.length; q++) {\n          var n = c.items[q].node;\n          if ((n.getAttribute(\"data-mobile-center\") || \"\") === \"force\") force++;\n          if ((n.getAttribute(\"data-debug-texto\") || \"\") === \"1\") text++;\n          else non++;\n        }\n        return { text: text, non: non, force: force };\n      }\n\n      var sA = pairStats(cA);\n      var sB = pairStats(cB);\n\n      var topDelta = Math.abs((cA.top || 0) - (cB.top || 0));\n      var xOverlap = Math.max(0, Math.min((cA.left + cA.width), (cB.left + cB.width)) - Math.max(cA.left, cB.left));\n      var minWPair = Math.max(1, Math.min((cA.width || 0), (cB.width || 0)));\n      var xOverlapRatio = xOverlap / minWPair;\n      var sideBySide = topDelta <= (CFG.ROW_TOL * 1.5) && xOverlapRatio < 0.25;\n      var pairInvasion = dividerInvasionRatio([cA, cB], mid);\n      var pairInvasionLimit = hasTextSignalTwo ? 0.5 : 0.34;\n\n      var anyForceCenter = (sA.force > 0 || sB.force > 0);\n      var bothMixed = (sA.text > 0 && sA.non > 0 && sB.text > 0 && sB.non > 0);\n      // Señal robusta de \"par de columnas\":\n      // - están lado a lado y pasan split left/right\n      // - y además no son simplemente 2 textos sueltos en una fila\n      var hasColumnSignal =\n        (sA.non > 0 || sB.non > 0) ||\n        ((cA.items && cA.items.length > 1) || (cB.items && cB.items.length > 1));\n\n      if (looksTwo && sideBySide && hasColumnSignal && pairInvasion <= pairInvasionLimit) {\n        var leftPair = (cA.cx <= cB.cx) ? [cA] : [cB];\n        var rightPair = (cA.cx <= cB.cx) ? [cB] : [cA];\n        mslLog(\"order:two:pairPolicy\", {\n          mode: \"two\",\n          reason: \"pairColumns\",\n          topDelta: +topDelta.toFixed(1),\n          xOverlapRatio: +xOverlapRatio.toFixed(3),\n          hasColumnSignal: hasColumnSignal,\n          bothMixed: bothMixed,\n          anyForceCenter: anyForceCenter,\n          pairInvasion: +pairInvasion.toFixed(3),\n          pairInvasionLimit: +pairInvasionLimit.toFixed(3),\n          lefts: [+(cA.left || 0).toFixed(1), +(cB.left || 0).toFixed(1)]\n        });\n        return { groups: [leftPair, rightPair], mode: \"two\" };\n      }\n\n      var pair = clusters.slice().sort(function(a,b){\n        if (Math.abs(a.top - b.top) > 0.5) return a.top - b.top;\n        return a.left - b.left;\n      });\n      mslLog(\"order:two:pairPolicy\", {\n        mode: \"one\",\n        reason: anyForceCenter ? \"forceCenterPair\" : \"pairDefault\",\n        topDelta: +topDelta.toFixed(1),\n        xOverlapRatio: +xOverlapRatio.toFixed(3),\n        sideBySide: sideBySide,\n        bothMixed: bothMixed,\n        anyForceCenter: anyForceCenter,\n        pairInvasion: +pairInvasion.toFixed(3),\n        pairInvasionLimit: +pairInvasionLimit.toFixed(3),\n        tops: pair.map(function(c){ return +c.top.toFixed(1); }),\n        lefts: pair.map(function(c){ return +c.left.toFixed(1); })\n      });\n      return { groups: [pair], mode: \"one\" };\n    }\n    if (looksTwo) {\n      var cxs2 = [];\n      for (var m=0;m<clusters.length;m++) cxs2.push(clusters[m].cx);\n      cxs2.sort(function(a,b){ return a-b; });\n      var p25 = percentile(cxs2, 0.25);\n      var p75 = percentile(cxs2, 0.75);\n      var spread2 = (p75 - p25);\n      mslLog(\"order:two:spread\", {\n        p25: p25,\n        p75: p75,\n        spread: spread2,\n        minSpread: rootW * CFG.TWO_COL_SPREAD_RATIO,\n        pass: spread2 >= rootW * CFG.TWO_COL_SPREAD_RATIO\n      });\n      if (spread2 < rootW * CFG.TWO_COL_SPREAD_RATIO) looksTwo = false;\n    }\n\n    if (looksTwo) {\n      var invadeMid = dividerInvasionRatio(clusters, mid);\n      var invasionLimitTwo = hasTextSignalTwo ? 0.48 : 0.34;\n      mslLog(\"order:two:invasion\", {\n        mid: +mid.toFixed(1),\n        invadeMid: +invadeMid.toFixed(3),\n        limit: +invasionLimitTwo.toFixed(3),\n        hasTextSignalTwo: hasTextSignalTwo,\n        pass: invadeMid <= invasionLimitTwo\n      });\n      if (invadeMid > invasionLimitTwo) looksTwo = false;\n    }\n\n    if (looksTwo) {\n      left.sort(function(a,b){ return a.top - b.top; });\n      right.sort(function(a,b){ return a.top - b.top; });\n      return { groups: [left, right], mode: \"two\" };\n    }\n\n    // -------- 2) Guard tardio: una sola columna visual --------\n    // Se evalua despues de two/three para evitar falsos \"one\" cuando hay\n    // dos columnas reales con varios clusters.\n    if (clusters.length >= 2) {\n      var cxsOne = clusters.map(function(c){ return c.cx; }).sort(function(a,b){ return a-b; });\n      var medianCx = percentile(cxsOne, 0.50);\n      var maxDevCx = 0;\n      for (var s=0; s<clusters.length; s++) {\n        var dev = Math.abs((clusters[s].cx || 0) - medianCx);\n        if (dev > maxDevCx) maxDevCx = dev;\n      }\n\n      var singleColMaxDev = rootW * 0.18;\n      var looksOneCol = maxDevCx <= singleColMaxDev;\n      mslLog(\"order:one:candidates\", {\n        rootW: rootW,\n        total: clusters.length,\n        medianCx: +medianCx.toFixed(1),\n        maxDevCx: +maxDevCx.toFixed(1),\n        maxAllowed: +singleColMaxDev.toFixed(1),\n        pass: looksOneCol,\n        stage: \"postTwoThree\"\n      });\n\n      if (looksOneCol) {\n        var oneCol = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n        return { groups: [oneCol], mode: \"one\" };\n      }\n    }\n\n    // -------- 3) Fallback: filas (top) y dentro por left --------\n    var sorted = clusters.slice().sort(function(a,b){ return a.top - b.top; });\n\n    var rows = [];\n    for (var r=0;r<sorted.length;r++){\n      var c3 = sorted[r];\n      var placed = false;\n\n      for (var rr=0; rr<rows.length; rr++){\n        var row = rows[rr];\n        if (Math.abs(c3.top - row.top) <= CFG.ROW_TOL){\n          row.items.push(c3);\n          row.top = (row.top * (row.items.length - 1) + c3.top) / row.items.length;\n          placed = true;\n          break;\n        }\n      }\n\n      if (!placed) rows.push({ top: c3.top, items: [c3] });\n    }\n\n    rows.sort(function(a,b){ return a.top - b.top; });\n    rows.forEach(function(row){\n      row.items.sort(function(a,b){ return a.left - b.left; });\n    });\n\n    function clusterIsText(c){\n      if (!c || !c.items || !c.items.length) return false;\n      for (var i2=0; i2<c.items.length; i2++){\n        if ((c.items[i2].node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\n      }\n      return true;\n    }\n\n    var out = [];\n    var didInterleave = false;\n    // Caso especial: dos filas simetricas (ej. iconos arriba y textos abajo).\n    // Reordenamos por columna: top1,bottom1,top2,bottom2,...\n    if (rows.length === 2 && rows[0].items.length === rows[1].items.length && rows[0].items.length >= 2) {\n      var topRow = rows[0].items.slice();\n      var botRow = rows[1].items.slice();\n      var topHasNonText = topRow.some(function(c){ return !clusterIsText(c); });\n      var botMostlyText = botRow.filter(function(c){ return clusterIsText(c); }).length >= Math.ceil(botRow.length / 2);\n\n      if (topHasNonText && botMostlyText) {\n        var usedBottom = {};\n        for (var tr=0; tr<topRow.length; tr++){\n          var a = topRow[tr];\n          out.push(a);\n\n          var bestIdx = -1;\n          var bestDist = Infinity;\n          for (var br=0; br<botRow.length; br++){\n            if (usedBottom[br]) continue;\n            var b = botRow[br];\n            var d = Math.abs((a.left || 0) - (b.left || 0));\n            if (d < bestDist) {\n              bestDist = d;\n              bestIdx = br;\n            }\n          }\n          if (bestIdx >= 0) {\n            out.push(botRow[bestIdx]);\n            usedBottom[bestIdx] = true;\n          }\n        }\n        for (var br2=0; br2<botRow.length; br2++){\n          if (!usedBottom[br2]) out.push(botRow[br2]);\n        }\n        didInterleave = true;\n      }\n    }\n\n    if (!didInterleave) {\n      rows.forEach(function(row){\n        for (var z=0; z<row.items.length; z++) out.push(row.items[z]);\n      });\n    }\n    mslLog(\"order:rows:fallback\", {\n      rows: rows.map(function(r){\n        return {\n          top: +r.top.toFixed(1),\n          len: r.items.length,\n          lefts: r.items.map(function(it){ return +it.left.toFixed(1); })\n        };\n      }),\n      outLen: out.length,\n      didInterleave: didInterleave\n    });\n\n    return { groups: [out], mode: \"rows\" };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvb3JkZXJpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVZVixDQUFDLENBQUNDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcb3JkZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9vcmRlcmluZy50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNPcmRlcmluZ0Jsb2NrKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBcclxuICAvKipcclxuICAgKiBPcmRlbmEgQ0xVU1RFUlMgKG5vIGl0ZW1zKSBwYXJhIGxlY3R1cmEgbW9iaWxlLlxyXG4gICAqIERldnVlbHZlIGdyb3VwcyAoYXJyYXkgZGUgY29sdW1uYXMvZ3J1cG9zKSB5IG1vZGUuXHJcbiAgICpcclxuICAgKiAtIHRocmVlOiBbY29sTCwgY29sQywgY29sUl1cclxuICAgKiAtIHR3bzogICBbbGVmdCwgcmlnaHRdXHJcbiAgICogLSByb3dzOiAgW291dF0gKGZpbGErbGVmdClcclxuICAgKiAtIG9uZTogICBbc29ydGVkVG9wXVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG9yZGVyQ2x1c3RlcnNGb3JNb2JpbGUoY2x1c3RlcnMsIHJvb3RXLCBDRkcpe1xuICAgIGlmICghcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgdmFyIG8gPSBjbHVzdGVycy5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbb10sIG1vZGU6IFwib25lXCIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbHVzdGVySGFzVGV4dChjKXtcbiAgICAgIGlmICghYyB8fCAhYy5pdGVtcyB8fCAhYy5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGlUeHQ9MDsgaVR4dDxjLml0ZW1zLmxlbmd0aDsgaVR4dCsrKXtcbiAgICAgICAgaWYgKChjLml0ZW1zW2lUeHRdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbkhhc1RleHQoY29sKXtcbiAgICAgIGlmICghY29sIHx8ICFjb2wubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpQ29sPTA7IGlDb2w8Y29sLmxlbmd0aDsgaUNvbCsrKXtcbiAgICAgICAgaWYgKGNsdXN0ZXJIYXNUZXh0KGNvbFtpQ29sXSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVuIGNsdXN0ZXIgXCJpbnZhZGVcIiB1bmEgZnJvbnRlcmEgc2kgcXVlZGEgcGFydGlkbyBkZSBmb3JtYSBzaWduaWZpY2F0aXZhXG4gICAgLy8gZW50cmUgYW1ib3MgbGFkb3MgZGUgbGEgbGluZWEgZGl2aXNvcmlhLlxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJJbnZhZGVzRGl2aWRlcihjLCBkaXZpZGVyWCl7XG4gICAgICBpZiAoIWMpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZWZ0ID0gTnVtYmVyKGMubGVmdCB8fCAwKTtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KDAsIE51bWJlcihjLndpZHRoIHx8IDApKTtcbiAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIGlmICh3aWR0aCA8PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocmlnaHQgPD0gZGl2aWRlclggfHwgbGVmdCA+PSBkaXZpZGVyWCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgcGFydExlZnQgPSBkaXZpZGVyWCAtIGxlZnQ7XG4gICAgICB2YXIgcGFydFJpZ2h0ID0gcmlnaHQgLSBkaXZpZGVyWDtcbiAgICAgIHZhciBtaW5QYXJ0ID0gTWF0aC5taW4ocGFydExlZnQsIHBhcnRSaWdodCk7XG4gICAgICB2YXIgbWluUmVxdWlyZWQgPSBNYXRoLm1heCgyMiwgd2lkdGggKiAwLjIyKTtcbiAgICAgIHJldHVybiBtaW5QYXJ0ID49IG1pblJlcXVpcmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdmlkZXJJbnZhc2lvblJhdGlvKGxpc3QsIGRpdmlkZXJYKXtcbiAgICAgIGlmICghbGlzdCB8fCAhbGlzdC5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgdmFyIGludmFkZWQgPSAwO1xuICAgICAgZm9yICh2YXIgaUludj0wOyBpSW52PGxpc3QubGVuZ3RoOyBpSW52Kyspe1xuICAgICAgICBpZiAoY2x1c3RlckludmFkZXNEaXZpZGVyKGxpc3RbaUludl0sIGRpdmlkZXJYKSkgaW52YWRlZCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludmFkZWQgLyBNYXRoLm1heCgxLCBsaXN0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMCkgSW50ZW50YXIgMyBjb2x1bW5hcyBjbGFyYXMgLS0tLS0tLS1cbiAgICB2YXIgdDEgPSByb290VyAvIDM7XG4gICAgdmFyIHQyID0gKDIgKiByb290VykgLyAzO1xuXHJcbiAgICB2YXIgY29sTCA9IFtdO1xyXG4gICAgdmFyIGNvbEMgPSBbXTtcclxuICAgIHZhciBjb2xSID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaT0wO2k8Y2x1c3RlcnMubGVuZ3RoO2krKyl7XHJcbiAgICAgIHZhciBjID0gY2x1c3RlcnNbaV07XHJcbiAgICAgIHZhciB4ID0gYy5jeDtcclxuICAgICAgaWYgKHggPCB0MSkgY29sTC5wdXNoKGMpO1xyXG4gICAgICBlbHNlIGlmICh4IDwgdDIpIGNvbEMucHVzaChjKTtcclxuICAgICAgZWxzZSBjb2xSLnB1c2goYyk7XHJcbiAgICB9XHJcblxuICAgIHZhciBsb29rc1RocmVlID1cbiAgICAgIChjb2xMLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyAmJiBjb2xDLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyAmJiBjb2xSLmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMyk7XG4gICAgdmFyIHRleHRDb2xzVGhyZWUgPVxuICAgICAgKGNvbHVtbkhhc1RleHQoY29sTCkgPyAxIDogMCkgK1xuICAgICAgKGNvbHVtbkhhc1RleHQoY29sQykgPyAxIDogMCkgK1xuICAgICAgKGNvbHVtbkhhc1RleHQoY29sUikgPyAxIDogMCk7XG4gICAgdmFyIGhhc1RleHRTaWduYWxUaHJlZSA9IHRleHRDb2xzVGhyZWUgPj0gMjtcbiAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTpjYW5kaWRhdGVzXCIsIHtcbiAgICAgIHJvb3RXOiByb290VyxcbiAgICAgIHRvdGFsOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICBjb2xMOiBjb2xMLmxlbmd0aCxcbiAgICAgIGNvbEM6IGNvbEMubGVuZ3RoLFxuICAgICAgY29sUjogY29sUi5sZW5ndGgsXG4gICAgICBtaW5QZXJDb2wzOiBDRkcuTUlOX1BFUl9DT0xfMyxcbiAgICAgIHRleHRDb2xzVGhyZWU6IHRleHRDb2xzVGhyZWUsXG4gICAgICBoYXNUZXh0U2lnbmFsVGhyZWU6IGhhc1RleHRTaWduYWxUaHJlZVxuICAgIH0pO1xuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIHZhciBjeHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGo9MDtqPGNsdXN0ZXJzLmxlbmd0aDtqKyspIGN4cy5wdXNoKGNsdXN0ZXJzW2pdLmN4KTtcclxuICAgICAgY3hzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XHJcbiAgICAgIHZhciBwMjAgPSBwZXJjZW50aWxlKGN4cywgMC4yMCk7XG4gICAgICB2YXIgcDgwID0gcGVyY2VudGlsZShjeHMsIDAuODApO1xuICAgICAgdmFyIHNwcmVhZCA9IChwODAgLSBwMjApO1xuICAgICAgbXNsTG9nKFwib3JkZXI6dGhyZWU6c3ByZWFkXCIsIHtcbiAgICAgICAgcDIwOiBwMjAsXG4gICAgICAgIHA4MDogcDgwLFxuICAgICAgICBzcHJlYWQ6IHNwcmVhZCxcbiAgICAgICAgbWluU3ByZWFkOiByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPLFxuICAgICAgICBwYXNzOiBzcHJlYWQgPj0gcm9vdFcgKiBDRkcuVEhSRUVfQ09MX1NQUkVBRF9SQVRJT1xuICAgICAgfSk7XG4gICAgICBpZiAoc3ByZWFkIDwgcm9vdFcgKiBDRkcuVEhSRUVfQ09MX1NQUkVBRF9SQVRJTykgbG9va3NUaHJlZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1RocmVlKSB7XG4gICAgICB2YXIgaW52YWRlVDEgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgdDEpO1xuICAgICAgdmFyIGludmFkZVQyID0gZGl2aWRlckludmFzaW9uUmF0aW8oY2x1c3RlcnMsIHQyKTtcbiAgICAgIHZhciBpbnZhZGVUaHJlZSA9IE1hdGgubWF4KGludmFkZVQxLCBpbnZhZGVUMik7XG4gICAgICB2YXIgaW52YXNpb25MaW1pdFRocmVlID0gaGFzVGV4dFNpZ25hbFRocmVlID8gMC40NiA6IDAuMzQ7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTppbnZhc2lvblwiLCB7XG4gICAgICAgIHQxOiArdDEudG9GaXhlZCgxKSxcbiAgICAgICAgdDI6ICt0Mi50b0ZpeGVkKDEpLFxuICAgICAgICBpbnZhZGVUMTogK2ludmFkZVQxLnRvRml4ZWQoMyksXG4gICAgICAgIGludmFkZVQyOiAraW52YWRlVDIudG9GaXhlZCgzKSxcbiAgICAgICAgaW52YWRlVGhyZWU6ICtpbnZhZGVUaHJlZS50b0ZpeGVkKDMpLFxuICAgICAgICBsaW1pdDogK2ludmFzaW9uTGltaXRUaHJlZS50b0ZpeGVkKDMpLFxuICAgICAgICBoYXNUZXh0U2lnbmFsVGhyZWU6IGhhc1RleHRTaWduYWxUaHJlZSxcbiAgICAgICAgcGFzczogaW52YWRlVGhyZWUgPD0gaW52YXNpb25MaW1pdFRocmVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhZGVUaHJlZSA+IGludmFzaW9uTGltaXRUaHJlZSkgbG9va3NUaHJlZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1RocmVlKSB7XG4gICAgICBjb2xMLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgY29sQy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcbiAgICAgIGNvbFIuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcbiAgICAgIHJldHVybiB7IGdyb3VwczogW2NvbEwsIGNvbEMsIGNvbFJdLCBtb2RlOiBcInRocmVlXCIgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLSAxKSBJbnRlbnRhciAyIGNvbHVtbmFzIGNsYXJhcyAtLS0tLS0tLVxuICAgIHZhciBtaWQgPSByb290VyAvIDI7XHJcbiAgICB2YXIgbGVmdCA9IFtdO1xyXG4gICAgdmFyIHJpZ2h0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaz0wO2s8Y2x1c3RlcnMubGVuZ3RoO2srKyl7XG4gICAgICB2YXIgYzIgPSBjbHVzdGVyc1trXTtcbiAgICAgIGlmIChjMi5jeCA8IG1pZCkgbGVmdC5wdXNoKGMyKTtcbiAgICAgIGVsc2UgcmlnaHQucHVzaChjMik7XG4gICAgfVxuXG4gICAgdmFyIGxvb2tzVHdvID0gKGxlZnQubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8yICYmIHJpZ2h0Lmxlbmd0aCA+PSBDRkcuTUlOX1BFUl9DT0xfMik7XG4gICAgdmFyIGhhc1RleHRTaWduYWxUd28gPSBjb2x1bW5IYXNUZXh0KGxlZnQpICYmIGNvbHVtbkhhc1RleHQocmlnaHQpO1xuICAgIG1zbExvZyhcIm9yZGVyOnR3bzpjYW5kaWRhdGVzXCIsIHtcbiAgICAgIHJvb3RXOiByb290VyxcbiAgICAgIHRvdGFsOiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICBsZWZ0OiBsZWZ0Lmxlbmd0aCxcbiAgICAgIHJpZ2h0OiByaWdodC5sZW5ndGgsXG4gICAgICBtaW5QZXJDb2wyOiBDRkcuTUlOX1BFUl9DT0xfMixcbiAgICAgIGhhc1RleHRTaWduYWxUd286IGhhc1RleHRTaWduYWxUd29cbiAgICB9KTtcblxuICAgIC8vIFBvbGl0aWNhIHBhcmEgcGFyZXMgKDIgY2x1c3RlcnMpOlxuICAgIC8vIC0gcGFyIGRlIGNvbHVtbmFzIHJlYWxlcyA9PiBtb2RlIFwidHdvXCJcbiAgICAvLyAtIHJlc3RvIGRlIGNhc29zID0+IG1vZGUgXCJvbmVcIiAoZml0Q2hlY2sgZGVjaWRlIHNpIHJlZmxvd2VhKVxyXG4gICAgaWYgKGNsdXN0ZXJzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICB2YXIgY0EgPSBjbHVzdGVyc1swXTtcclxuICAgICAgdmFyIGNCID0gY2x1c3RlcnNbMV07XHJcblxyXG4gICAgICBmdW5jdGlvbiBwYWlyU3RhdHMoYyl7XHJcbiAgICAgICAgdmFyIHRleHQgPSAwO1xyXG4gICAgICAgIHZhciBub24gPSAwO1xyXG4gICAgICAgIHZhciBmb3JjZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgcT0wOyBxPGMuaXRlbXMubGVuZ3RoOyBxKyspIHtcclxuICAgICAgICAgIHZhciBuID0gYy5pdGVtc1txXS5ub2RlO1xyXG4gICAgICAgICAgaWYgKChuLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNlbnRlclwiKSB8fCBcIlwiKSA9PT0gXCJmb3JjZVwiKSBmb3JjZSsrO1xyXG4gICAgICAgICAgaWYgKChuLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSB0ZXh0Kys7XHJcbiAgICAgICAgICBlbHNlIG5vbisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0ZXh0OiB0ZXh0LCBub246IG5vbiwgZm9yY2U6IGZvcmNlIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzQSA9IHBhaXJTdGF0cyhjQSk7XHJcbiAgICAgIHZhciBzQiA9IHBhaXJTdGF0cyhjQik7XHJcblxyXG4gICAgICB2YXIgdG9wRGVsdGEgPSBNYXRoLmFicygoY0EudG9wIHx8IDApIC0gKGNCLnRvcCB8fCAwKSk7XG4gICAgICB2YXIgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigoY0EubGVmdCArIGNBLndpZHRoKSwgKGNCLmxlZnQgKyBjQi53aWR0aCkpIC0gTWF0aC5tYXgoY0EubGVmdCwgY0IubGVmdCkpO1xuICAgICAgdmFyIG1pbldQYWlyID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oKGNBLndpZHRoIHx8IDApLCAoY0Iud2lkdGggfHwgMCkpKTtcbiAgICAgIHZhciB4T3ZlcmxhcFJhdGlvID0geE92ZXJsYXAgLyBtaW5XUGFpcjtcbiAgICAgIHZhciBzaWRlQnlTaWRlID0gdG9wRGVsdGEgPD0gKENGRy5ST1dfVE9MICogMS41KSAmJiB4T3ZlcmxhcFJhdGlvIDwgMC4yNTtcbiAgICAgIHZhciBwYWlySW52YXNpb24gPSBkaXZpZGVySW52YXNpb25SYXRpbyhbY0EsIGNCXSwgbWlkKTtcbiAgICAgIHZhciBwYWlySW52YXNpb25MaW1pdCA9IGhhc1RleHRTaWduYWxUd28gPyAwLjUgOiAwLjM0O1xuXG4gICAgICB2YXIgYW55Rm9yY2VDZW50ZXIgPSAoc0EuZm9yY2UgPiAwIHx8IHNCLmZvcmNlID4gMCk7XG4gICAgICB2YXIgYm90aE1peGVkID0gKHNBLnRleHQgPiAwICYmIHNBLm5vbiA+IDAgJiYgc0IudGV4dCA+IDAgJiYgc0Iubm9uID4gMCk7XG4gICAgICAvLyBTZcOxYWwgcm9idXN0YSBkZSBcInBhciBkZSBjb2x1bW5hc1wiOlxuICAgICAgLy8gLSBlc3TDoW4gbGFkbyBhIGxhZG8geSBwYXNhbiBzcGxpdCBsZWZ0L3JpZ2h0XG4gICAgICAvLyAtIHkgYWRlbcOhcyBubyBzb24gc2ltcGxlbWVudGUgMiB0ZXh0b3Mgc3VlbHRvcyBlbiB1bmEgZmlsYVxuICAgICAgdmFyIGhhc0NvbHVtblNpZ25hbCA9XG4gICAgICAgIChzQS5ub24gPiAwIHx8IHNCLm5vbiA+IDApIHx8XG4gICAgICAgICgoY0EuaXRlbXMgJiYgY0EuaXRlbXMubGVuZ3RoID4gMSkgfHwgKGNCLml0ZW1zICYmIGNCLml0ZW1zLmxlbmd0aCA+IDEpKTtcblxuICAgICAgaWYgKGxvb2tzVHdvICYmIHNpZGVCeVNpZGUgJiYgaGFzQ29sdW1uU2lnbmFsICYmIHBhaXJJbnZhc2lvbiA8PSBwYWlySW52YXNpb25MaW1pdCkge1xuICAgICAgICB2YXIgbGVmdFBhaXIgPSAoY0EuY3ggPD0gY0IuY3gpID8gW2NBXSA6IFtjQl07XG4gICAgICAgIHZhciByaWdodFBhaXIgPSAoY0EuY3ggPD0gY0IuY3gpID8gW2NCXSA6IFtjQV07XG4gICAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzpwYWlyUG9saWN5XCIsIHtcbiAgICAgICAgICBtb2RlOiBcInR3b1wiLFxuICAgICAgICAgIHJlYXNvbjogXCJwYWlyQ29sdW1uc1wiLFxuICAgICAgICAgIHRvcERlbHRhOiArdG9wRGVsdGEudG9GaXhlZCgxKSxcbiAgICAgICAgICB4T3ZlcmxhcFJhdGlvOiAreE92ZXJsYXBSYXRpby50b0ZpeGVkKDMpLFxuICAgICAgICAgIGhhc0NvbHVtblNpZ25hbDogaGFzQ29sdW1uU2lnbmFsLFxuICAgICAgICAgIGJvdGhNaXhlZDogYm90aE1peGVkLFxuICAgICAgICAgIGFueUZvcmNlQ2VudGVyOiBhbnlGb3JjZUNlbnRlcixcbiAgICAgICAgICBwYWlySW52YXNpb246ICtwYWlySW52YXNpb24udG9GaXhlZCgzKSxcbiAgICAgICAgICBwYWlySW52YXNpb25MaW1pdDogK3BhaXJJbnZhc2lvbkxpbWl0LnRvRml4ZWQoMyksXG4gICAgICAgICAgbGVmdHM6IFsrKGNBLmxlZnQgfHwgMCkudG9GaXhlZCgxKSwgKyhjQi5sZWZ0IHx8IDApLnRvRml4ZWQoMSldXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBncm91cHM6IFtsZWZ0UGFpciwgcmlnaHRQYWlyXSwgbW9kZTogXCJ0d29cIiB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFpciA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhhLnRvcCAtIGIudG9wKSA+IDAuNSkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgfSk7XHJcbiAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzpwYWlyUG9saWN5XCIsIHtcclxuICAgICAgICBtb2RlOiBcIm9uZVwiLFxyXG4gICAgICAgIHJlYXNvbjogYW55Rm9yY2VDZW50ZXIgPyBcImZvcmNlQ2VudGVyUGFpclwiIDogXCJwYWlyRGVmYXVsdFwiLFxyXG4gICAgICAgIHRvcERlbHRhOiArdG9wRGVsdGEudG9GaXhlZCgxKSxcclxuICAgICAgICB4T3ZlcmxhcFJhdGlvOiAreE92ZXJsYXBSYXRpby50b0ZpeGVkKDMpLFxuICAgICAgICBzaWRlQnlTaWRlOiBzaWRlQnlTaWRlLFxuICAgICAgICBib3RoTWl4ZWQ6IGJvdGhNaXhlZCxcbiAgICAgICAgYW55Rm9yY2VDZW50ZXI6IGFueUZvcmNlQ2VudGVyLFxuICAgICAgICBwYWlySW52YXNpb246ICtwYWlySW52YXNpb24udG9GaXhlZCgzKSxcbiAgICAgICAgcGFpckludmFzaW9uTGltaXQ6ICtwYWlySW52YXNpb25MaW1pdC50b0ZpeGVkKDMpLFxuICAgICAgICB0b3BzOiBwYWlyLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLnRvcC50b0ZpeGVkKDEpOyB9KSxcbiAgICAgICAgbGVmdHM6IHBhaXIubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MubGVmdC50b0ZpeGVkKDEpOyB9KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtwYWlyXSwgbW9kZTogXCJvbmVcIiB9O1xuICAgIH1cclxuICAgIGlmIChsb29rc1R3bykge1xyXG4gICAgICB2YXIgY3hzMiA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBtPTA7bTxjbHVzdGVycy5sZW5ndGg7bSsrKSBjeHMyLnB1c2goY2x1c3RlcnNbbV0uY3gpO1xyXG4gICAgICBjeHMyLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XHJcbiAgICAgIHZhciBwMjUgPSBwZXJjZW50aWxlKGN4czIsIDAuMjUpO1xuICAgICAgdmFyIHA3NSA9IHBlcmNlbnRpbGUoY3hzMiwgMC43NSk7XG4gICAgICB2YXIgc3ByZWFkMiA9IChwNzUgLSBwMjUpO1xuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnNwcmVhZFwiLCB7XG4gICAgICAgIHAyNTogcDI1LFxuICAgICAgICBwNzU6IHA3NSxcbiAgICAgICAgc3ByZWFkOiBzcHJlYWQyLFxuICAgICAgICBtaW5TcHJlYWQ6IHJvb3RXICogQ0ZHLlRXT19DT0xfU1BSRUFEX1JBVElPLFxuICAgICAgICBwYXNzOiBzcHJlYWQyID49IHJvb3RXICogQ0ZHLlRXT19DT0xfU1BSRUFEX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmIChzcHJlYWQyIDwgcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU8pIGxvb2tzVHdvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVHdvKSB7XG4gICAgICB2YXIgaW52YWRlTWlkID0gZGl2aWRlckludmFzaW9uUmF0aW8oY2x1c3RlcnMsIG1pZCk7XG4gICAgICB2YXIgaW52YXNpb25MaW1pdFR3byA9IGhhc1RleHRTaWduYWxUd28gPyAwLjQ4IDogMC4zNDtcbiAgICAgIG1zbExvZyhcIm9yZGVyOnR3bzppbnZhc2lvblwiLCB7XG4gICAgICAgIG1pZDogK21pZC50b0ZpeGVkKDEpLFxuICAgICAgICBpbnZhZGVNaWQ6ICtpbnZhZGVNaWQudG9GaXhlZCgzKSxcbiAgICAgICAgbGltaXQ6ICtpbnZhc2lvbkxpbWl0VHdvLnRvRml4ZWQoMyksXG4gICAgICAgIGhhc1RleHRTaWduYWxUd286IGhhc1RleHRTaWduYWxUd28sXG4gICAgICAgIHBhc3M6IGludmFkZU1pZCA8PSBpbnZhc2lvbkxpbWl0VHdvXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnZhZGVNaWQgPiBpbnZhc2lvbkxpbWl0VHdvKSBsb29rc1R3byA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb29rc1R3bykge1xuICAgICAgbGVmdC5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcbiAgICAgIHJpZ2h0LnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbbGVmdCwgcmlnaHRdLCBtb2RlOiBcInR3b1wiIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMikgR3VhcmQgdGFyZGlvOiB1bmEgc29sYSBjb2x1bW5hIHZpc3VhbCAtLS0tLS0tLVxuICAgIC8vIFNlIGV2YWx1YSBkZXNwdWVzIGRlIHR3by90aHJlZSBwYXJhIGV2aXRhciBmYWxzb3MgXCJvbmVcIiBjdWFuZG8gaGF5XG4gICAgLy8gZG9zIGNvbHVtbmFzIHJlYWxlcyBjb24gdmFyaW9zIGNsdXN0ZXJzLlxuICAgIGlmIChjbHVzdGVycy5sZW5ndGggPj0gMikge1xuICAgICAgdmFyIGN4c09uZSA9IGNsdXN0ZXJzLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuIGMuY3g7IH0pLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEtYjsgfSk7XG4gICAgICB2YXIgbWVkaWFuQ3ggPSBwZXJjZW50aWxlKGN4c09uZSwgMC41MCk7XG4gICAgICB2YXIgbWF4RGV2Q3ggPSAwO1xuICAgICAgZm9yICh2YXIgcz0wOyBzPGNsdXN0ZXJzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIHZhciBkZXYgPSBNYXRoLmFicygoY2x1c3RlcnNbc10uY3ggfHwgMCkgLSBtZWRpYW5DeCk7XG4gICAgICAgIGlmIChkZXYgPiBtYXhEZXZDeCkgbWF4RGV2Q3ggPSBkZXY7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW5nbGVDb2xNYXhEZXYgPSByb290VyAqIDAuMTg7XG4gICAgICB2YXIgbG9va3NPbmVDb2wgPSBtYXhEZXZDeCA8PSBzaW5nbGVDb2xNYXhEZXY7XG4gICAgICBtc2xMb2coXCJvcmRlcjpvbmU6Y2FuZGlkYXRlc1wiLCB7XG4gICAgICAgIHJvb3RXOiByb290VyxcbiAgICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgbWVkaWFuQ3g6ICttZWRpYW5DeC50b0ZpeGVkKDEpLFxuICAgICAgICBtYXhEZXZDeDogK21heERldkN4LnRvRml4ZWQoMSksXG4gICAgICAgIG1heEFsbG93ZWQ6ICtzaW5nbGVDb2xNYXhEZXYudG9GaXhlZCgxKSxcbiAgICAgICAgcGFzczogbG9va3NPbmVDb2wsXG4gICAgICAgIHN0YWdlOiBcInBvc3RUd29UaHJlZVwiXG4gICAgICB9KTtcblxuICAgICAgaWYgKGxvb2tzT25lQ29sKSB7XG4gICAgICAgIHZhciBvbmVDb2wgPSBjbHVzdGVycy5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgICByZXR1cm4geyBncm91cHM6IFtvbmVDb2xdLCBtb2RlOiBcIm9uZVwiIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0gMykgRmFsbGJhY2s6IGZpbGFzICh0b3ApIHkgZGVudHJvIHBvciBsZWZ0IC0tLS0tLS0tXG4gICAgdmFyIHNvcnRlZCA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcblxyXG4gICAgdmFyIHJvd3MgPSBbXTtcclxuICAgIGZvciAodmFyIHI9MDtyPHNvcnRlZC5sZW5ndGg7cisrKXtcclxuICAgICAgdmFyIGMzID0gc29ydGVkW3JdO1xyXG4gICAgICB2YXIgcGxhY2VkID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBycj0wOyBycjxyb3dzLmxlbmd0aDsgcnIrKyl7XHJcbiAgICAgICAgdmFyIHJvdyA9IHJvd3NbcnJdO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhjMy50b3AgLSByb3cudG9wKSA8PSBDRkcuUk9XX1RPTCl7XHJcbiAgICAgICAgICByb3cuaXRlbXMucHVzaChjMyk7XHJcbiAgICAgICAgICByb3cudG9wID0gKHJvdy50b3AgKiAocm93Lml0ZW1zLmxlbmd0aCAtIDEpICsgYzMudG9wKSAvIHJvdy5pdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBsYWNlZCkgcm93cy5wdXNoKHsgdG9wOiBjMy50b3AsIGl0ZW1zOiBbYzNdIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJvd3Muc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KXtcclxuICAgICAgcm93Lml0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEubGVmdCAtIGIubGVmdDsgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbHVzdGVySXNUZXh0KGMpe1xuICAgICAgaWYgKCFjIHx8ICFjLml0ZW1zIHx8ICFjLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaTI9MDsgaTI8Yy5pdGVtcy5sZW5ndGg7IGkyKyspe1xuICAgICAgICBpZiAoKGMuaXRlbXNbaTJdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgZGlkSW50ZXJsZWF2ZSA9IGZhbHNlO1xuICAgIC8vIENhc28gZXNwZWNpYWw6IGRvcyBmaWxhcyBzaW1ldHJpY2FzIChlai4gaWNvbm9zIGFycmliYSB5IHRleHRvcyBhYmFqbykuXG4gICAgLy8gUmVvcmRlbmFtb3MgcG9yIGNvbHVtbmE6IHRvcDEsYm90dG9tMSx0b3AyLGJvdHRvbTIsLi4uXG4gICAgaWYgKHJvd3MubGVuZ3RoID09PSAyICYmIHJvd3NbMF0uaXRlbXMubGVuZ3RoID09PSByb3dzWzFdLml0ZW1zLmxlbmd0aCAmJiByb3dzWzBdLml0ZW1zLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgdG9wUm93ID0gcm93c1swXS5pdGVtcy5zbGljZSgpO1xuICAgICAgdmFyIGJvdFJvdyA9IHJvd3NbMV0uaXRlbXMuc2xpY2UoKTtcbiAgICAgIHZhciB0b3BIYXNOb25UZXh0ID0gdG9wUm93LnNvbWUoZnVuY3Rpb24oYyl7IHJldHVybiAhY2x1c3RlcklzVGV4dChjKTsgfSk7XG4gICAgICB2YXIgYm90TW9zdGx5VGV4dCA9IGJvdFJvdy5maWx0ZXIoZnVuY3Rpb24oYyl7IHJldHVybiBjbHVzdGVySXNUZXh0KGMpOyB9KS5sZW5ndGggPj0gTWF0aC5jZWlsKGJvdFJvdy5sZW5ndGggLyAyKTtcblxuICAgICAgaWYgKHRvcEhhc05vblRleHQgJiYgYm90TW9zdGx5VGV4dCkge1xuICAgICAgICB2YXIgdXNlZEJvdHRvbSA9IHt9O1xuICAgICAgICBmb3IgKHZhciB0cj0wOyB0cjx0b3BSb3cubGVuZ3RoOyB0cisrKXtcbiAgICAgICAgICB2YXIgYSA9IHRvcFJvd1t0cl07XG4gICAgICAgICAgb3V0LnB1c2goYSk7XG5cbiAgICAgICAgICB2YXIgYmVzdElkeCA9IC0xO1xuICAgICAgICAgIHZhciBiZXN0RGlzdCA9IEluZmluaXR5O1xuICAgICAgICAgIGZvciAodmFyIGJyPTA7IGJyPGJvdFJvdy5sZW5ndGg7IGJyKyspe1xuICAgICAgICAgICAgaWYgKHVzZWRCb3R0b21bYnJdKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBiID0gYm90Um93W2JyXTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5hYnMoKGEubGVmdCB8fCAwKSAtIChiLmxlZnQgfHwgMCkpO1xuICAgICAgICAgICAgaWYgKGQgPCBiZXN0RGlzdCkge1xuICAgICAgICAgICAgICBiZXN0RGlzdCA9IGQ7XG4gICAgICAgICAgICAgIGJlc3RJZHggPSBicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJlc3RJZHggPj0gMCkge1xuICAgICAgICAgICAgb3V0LnB1c2goYm90Um93W2Jlc3RJZHhdKTtcbiAgICAgICAgICAgIHVzZWRCb3R0b21bYmVzdElkeF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBicjI9MDsgYnIyPGJvdFJvdy5sZW5ndGg7IGJyMisrKXtcbiAgICAgICAgICBpZiAoIXVzZWRCb3R0b21bYnIyXSkgb3V0LnB1c2goYm90Um93W2JyMl0pO1xuICAgICAgICB9XG4gICAgICAgIGRpZEludGVybGVhdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGlkSW50ZXJsZWF2ZSkge1xuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdyl7XG4gICAgICAgIGZvciAodmFyIHo9MDsgejxyb3cuaXRlbXMubGVuZ3RoOyB6KyspIG91dC5wdXNoKHJvdy5pdGVtc1t6XSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbXNsTG9nKFwib3JkZXI6cm93czpmYWxsYmFja1wiLCB7XG4gICAgICByb3dzOiByb3dzLm1hcChmdW5jdGlvbihyKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICtyLnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGxlbjogci5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgbGVmdHM6IHIuaXRlbXMubWFwKGZ1bmN0aW9uKGl0KXsgcmV0dXJuICtpdC5sZWZ0LnRvRml4ZWQoMSk7IH0pXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG91dExlbjogb3V0Lmxlbmd0aCxcbiAgICAgIGRpZEludGVybGVhdmU6IGRpZEludGVybGVhdmVcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGdyb3VwczogW291dF0sIG1vZGU6IFwicm93c1wiIH07XG4gIH1cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzT3JkZXJpbmdCbG9jayIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts":
/*!*****************************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/scriptTemplate.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* binding */ buildScript)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/dom.ts\");\n/* harmony import */ var _fitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitScale */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/fitScale.ts\");\n/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordering */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/ordering.ts\");\n/* harmony import */ var _stacking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacking */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts\");\n// functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n\n\n\n\nfunction buildScript(cfg) {\n    if (!cfg.enabled) return \"\";\n    return `\n<script>\n(function(){\n  var ENABLED = true;\n  function readFlagFromSearch(search, name){\n    try {\n      if (typeof search !== \"string\" || !search) return false;\n      var normalized = search.charAt(0) === \"?\" ? search : (\"?\" + search);\n      var qp = new URLSearchParams(normalized);\n      var qv = qp.get(name);\n      return qv === \"1\" || String(qv).toLowerCase() === \"true\";\n    } catch(_e0) {\n      return false;\n    }\n  }\n  function readDebugFlag(name){\n    try {\n      var search = (window.location && window.location.search) ? window.location.search : \"\";\n      if (readFlagFromSearch(search, name)) return true;\n    } catch(_e1) {}\n\n    // srcDoc sandbox suele conservar document.referrer con la URL padre.\n    try {\n      var referrer = (typeof document !== \"undefined\" && document.referrer) ? String(document.referrer) : \"\";\n      if (referrer) {\n        var refUrl = new URL(referrer);\n        if (readFlagFromSearch(refUrl.search || \"\", name)) return true;\n      }\n    } catch(_eRef) {}\n\n    // srcDoc/about:srcdoc no suele tener querystring.\n    try {\n      if (window.parent && window.parent !== window && window.parent.location) {\n        var pSearch = window.parent.location.search || \"\";\n        if (readFlagFromSearch(pSearch, name)) return true;\n      }\n    } catch(_e2) {}\n\n    try {\n      if (window.top && window.top !== window && window.top.location) {\n        var tSearch = window.top.location.search || \"\";\n        if (readFlagFromSearch(tSearch, name)) return true;\n      }\n    } catch(_e3) {}\n\n    try {\n      var ls = window.localStorage ? window.localStorage.getItem(name) : null;\n      if (ls === \"1\" || String(ls).toLowerCase() === \"true\") return true;\n    } catch(_e4) {}\n\n    return false;\n  }\n  var MSL_DEBUG = readDebugFlag(\"mslDebug\");\n  var MSL_VERBOSE = readDebugFlag(\"mslVerbose\");\n  function dbg(label, payload){\n    if (!MSL_DEBUG) return;\n    if (arguments.length <= 1) {\n      console.log(\"[MSL] \" + label);\n      return;\n    }\n    if (typeof payload === \"string\") {\n      console.log(\"[MSL] \" + label + \" \" + payload);\n      return;\n    }\n    var pretty = \"\";\n    try {\n      pretty = JSON.stringify(payload, null, 2);\n    } catch(e) {\n      try { pretty = String(payload); } catch(_) { pretty = \"[unserializable]\"; }\n    }\n    console.log(\"[MSL] \" + label + \"\\\\n\" + pretty);\n  }\n  function mslLog(){\n    if (!MSL_DEBUG) return;\n    var args = Array.prototype.slice.call(arguments);\n    if (!args.length) return;\n    var label = String(args[0]);\n    if (!MSL_VERBOSE) {\n      var noisy = {\n        \"section:nodeSources\": 1,\n        \"section:baselineRestore\": 1,\n        \"section:anchorSplit\": 1,\n        \"section:clusters\": 1,\n        \"order:three:candidates\": 1,\n        \"order:three:spread\": 1,\n        \"order:two:candidates\": 1,\n        \"order:two:spread\": 1,\n        \"order:one:candidates\": 1,\n        \"order:rows:fallback\": 1\n      };\n      if (noisy[label]) return;\n    }\n    if (args.length === 1) {\n      dbg(label);\n      return;\n    }\n    if (args.length === 2) {\n      dbg(label, args[1]);\n      return;\n    }\n    dbg(label, args.slice(1));\n  }\n  var CFG = {\n    MIN_GAP: ${cfg.minGapPx},\n    MAX_GAP: ${cfg.maxGapPx},\n    GAP_SCALE: ${cfg.gapScale},\n\n    PAD_TOP: ${cfg.paddingTopPx},\n    PAD_BOT: ${cfg.paddingBottomPx},\n\n    ONLY_FIXED: ${cfg.onlyFixedSections ? \"true\" : \"false\"},\n    ONLY_WHEN_REORDERED: ${cfg.onlyWhenReordered ? \"true\" : \"false\"},\n\n    ROW_TOL: ${cfg.rowTolPx},\n\n    TWO_COL_SPREAD_RATIO: ${cfg.twoColSpreadRatio},\n    MIN_PER_COL_2: ${cfg.minPerColumn2},\n\n    THREE_COL_SPREAD_RATIO: ${cfg.threeColSpreadRatio},\n    MIN_PER_COL_3: ${cfg.minPerColumn3},\n\n    FIT_MIN_SCALE: ${cfg.fitMinScale},\n    FIT_MAX_SCALE: ${cfg.fitMaxScale},\n    FIT_TARGET_WIDTH_RATIO: ${cfg.fitTargetWidthRatio},\n    FIT_MIN_FILL_RATIO: ${cfg.fitMinFillRatio}\n  };\n\n  ${(0,_dom__WEBPACK_IMPORTED_MODULE_0__.jsDomHelpersBlock)()}\n\n  ${(0,_ordering__WEBPACK_IMPORTED_MODULE_2__.jsOrderingBlock)()}\n\n  ${(0,_stacking__WEBPACK_IMPORTED_MODULE_3__.jsStackingBlock)()}\n\n  ${(0,_fitScale__WEBPACK_IMPORTED_MODULE_1__.jsFitScaleBlock)()}\n\n  function expandFixedSection(sec, neededHeight){\n    var currentH = sec.getBoundingClientRect().height || 0;\n    if (neededHeight > currentH + 1) {\n      sec.style.height = Math.ceil(neededHeight) + \"px\";\n      return true;\n    }\n    return false;\n  }\n\n  function shouldProcessSection(sec){\n    if(!sec) return false;\n    if(!CFG.ONLY_FIXED) return true;\n    var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n    return modo === \"fijo\";\n  }\n\n  function restoreNodeBaseline(node){\n    if (!node) return 0;\n    var restored = 0;\n\n    if (!node.hasAttribute(\"data-msl-orig-top\")) {\n      node.setAttribute(\"data-msl-orig-top\", node.style.top || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-left\")) {\n      node.setAttribute(\"data-msl-orig-left\", node.style.left || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-transform\")) {\n      node.setAttribute(\"data-msl-orig-transform\", node.style.transform || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-text-align\")) {\n      node.setAttribute(\"data-msl-orig-text-align\", node.style.textAlign || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-transform-origin\")) {\n      node.setAttribute(\"data-msl-orig-transform-origin\", node.style.transformOrigin || \"\");\n    }\n    if (!node.hasAttribute(\"data-msl-orig-text-zoom\")) {\n      node.setAttribute(\"data-msl-orig-text-zoom\", node.style.getPropertyValue(\"--text-zoom\") || \"\");\n    }\n\n    var origTop = node.getAttribute(\"data-msl-orig-top\");\n    var origLeft = node.getAttribute(\"data-msl-orig-left\");\n    var origTransform = node.getAttribute(\"data-msl-orig-transform\");\n    var origTextAlign = node.getAttribute(\"data-msl-orig-text-align\");\n    var origTransformOrigin = node.getAttribute(\"data-msl-orig-transform-origin\");\n    var origTextZoom = node.getAttribute(\"data-msl-orig-text-zoom\");\n\n    if (origTop != null && node.style.top !== origTop) {\n      node.style.top = origTop;\n      restored++;\n    }\n    if (origLeft != null && node.style.left !== origLeft) {\n      node.style.left = origLeft;\n      restored++;\n    }\n    if (origTransform != null && node.style.transform !== origTransform) {\n      node.style.transform = origTransform;\n      restored++;\n    }\n    if (origTextAlign != null && node.style.textAlign !== origTextAlign) {\n      if (origTextAlign) node.style.textAlign = origTextAlign;\n      else node.style.removeProperty(\"text-align\");\n      restored++;\n    }\n    if (origTransformOrigin != null && node.style.transformOrigin !== origTransformOrigin) {\n      if (origTransformOrigin) node.style.transformOrigin = origTransformOrigin;\n      else node.style.removeProperty(\"transform-origin\");\n      restored++;\n    }\n    if (origTextZoom != null) {\n      var currentTextZoom = node.style.getPropertyValue(\"--text-zoom\") || \"\";\n      if (currentTextZoom !== origTextZoom) {\n        if (origTextZoom) node.style.setProperty(\"--text-zoom\", origTextZoom);\n        else node.style.removeProperty(\"--text-zoom\");\n        restored++;\n      }\n    }\n\n    node.style.right = \"auto\";\n    node.style.marginLeft = \"0px\";\n    return restored;\n  }\n\n  function runOnce(){\n    if(!ENABLED) return;\n    if(!isMobile()) {\n      Array.from(document.querySelectorAll(\".sec\")).forEach(function(sec){\n        var content = sec.querySelector(\".sec-content\");\n        if(!content) return;\n        var bleed = sec.querySelector(\".sec-bleed\");\n        resetSectionFitScale(sec, content, bleed);\n        var nodesAllDesktop = getObjNodes(sec);\n        for (var nd=0; nd<nodesAllDesktop.length; nd++) {\n          restoreNodeBaseline(nodesAllDesktop[nd]);\n        }\n        sec.setAttribute(\"data-msl-fit-scale\", \"1\");\n      });\n      return;\n    }\n\n    var secs = Array.from(document.querySelectorAll(\".sec\"));\n    if(!secs.length) return;\n\n    secs.forEach(function(sec){\n      var secIndex = secs.indexOf(sec);\n      var secModo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\n      var allowReflow = shouldProcessSection(sec);\n      mslLog(\"section:start\", { secIndex: secIndex, modo: secModo, allowReflow: allowReflow });\n\n      var content = sec.querySelector(\".sec-content\");\n      if(!content) return;\n      var bleed = sec.querySelector(\".sec-bleed\");\n      resetSectionFitScale(sec, content, bleed);\n      var nodesAll = getObjNodes(sec);\n\n      var reflowElementsDump = [];\n      function buildReflowElementsDump(items, contentWNow){\n        if (!MSL_DEBUG) return;\n        var list = (items || []);\n        var maxItems = 120;\n        var out = [];\n        for (var iDump=0; iDump<list.length && iDump<maxItems; iDump++){\n          var itDump = list[iDump];\n          if (!itDump || !itDump.node) continue;\n          var nDump = itDump.node;\n          var textRaw = ((nDump.textContent || \"\").trim()).replace(/\\s+/g, \" \");\n          var isTextDump = (nDump.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          var clsDump = (nDump.className && typeof nDump.className === \"string\") ? nDump.className : \"\";\n          var rootZone = (nDump.closest && nDump.closest(\".sec-bleed\")) ? \"bleed\" : \"content\";\n          out.push({\n            i: iDump,\n            kind: isTextDump ? \"texto\" : String((nDump.tagName || \"\").toLowerCase()),\n            zone: rootZone,\n            top: +Number(itDump.top || 0).toFixed(1),\n            left: +Number(itDump.left || 0).toFixed(1),\n            w: +Number(itDump.width || 0).toFixed(1),\n            h: +Number(itDump.height || 0).toFixed(1),\n            right: +Number((itDump.left || 0) + (itDump.width || 0)).toFixed(1),\n            bottom: +Number((itDump.top || 0) + (itDump.height || 0)).toFixed(1),\n            cx: +Number((itDump.left || 0) + ((itDump.width || 0) / 2)).toFixed(1),\n            wRatio: contentWNow > 1 ? +Number((itDump.width || 0) / contentWNow).toFixed(3) : null,\n            className: clsDump,\n            mobileLayout: nDump.getAttribute(\"data-mobile-layout\") || \"\",\n            mobileRole: nDump.getAttribute(\"data-mobile-role\") || \"\",\n            mobileCluster: nDump.getAttribute(\"data-mobile-cluster\") || \"\",\n            mobileClusterId: nDump.getAttribute(\"data-mobile-cluster-id\") || \"\",\n            mobileCenter: nDump.getAttribute(\"data-mobile-center\") || \"\",\n            mobileAlign: nDump.getAttribute(\"data-mobile-align\") || \"\",\n            mobileFit: nDump.getAttribute(\"data-mobile-fit\") || \"\",\n            textAlign: (nDump.style && nDump.style.textAlign) ? nDump.style.textAlign : \"\",\n            textSample: isTextDump ? textRaw.slice(0, 90) : \"\"\n          });\n        }\n        reflowElementsDump = out;\n      }\n\n      function logReflowDecision(reason, extra){\n        if (!MSL_DEBUG) return;\n        var payload = {\n          secIndex: secIndex,\n          secModo: secModo,\n          allowReflow: allowReflow,\n          totalNodes: (nodesAll || []).length,\n          reason: String(reason || \"\"),\n          details: extra || {}\n        };\n        mslLog(\"section:reflow:decision\", payload);\n      }\n\n      function finalizeSection(minNeededHeight, preserveBottomGap){\n        var gap = Number.isFinite(preserveBottomGap) ? Math.max(0, Number(preserveBottomGap)) : 0;\n        var fit = applySectionFitScale(\n          sec,\n          content,\n          bleed,\n          nodesAll,\n          secModo,\n          CFG,\n          { secIndex: secIndex },\n          { preserveBottomGap: gap }\n        );\n        var fitNeeded = (fit && Number.isFinite(fit.neededHeight)) ? Number(fit.neededHeight) : 0;\n        var neededHeight = Math.max(Number(minNeededHeight || 0), fitNeeded);\n        mslLog(\"section:heightFinal\", {\n          secIndex: secIndex,\n          mode: secModo,\n          minNeededHeight: +Number(minNeededHeight || 0).toFixed(1),\n          fitNeededHeight: +fitNeeded.toFixed(1),\n          preserveBottomGap: +gap.toFixed(1),\n          finalNeededHeight: +neededHeight.toFixed(1)\n        });\n        if (secModo === \"fijo\" && neededHeight > 0) {\n          expandFixedSection(sec, neededHeight);\n        }\n      }\n\n      if(!nodesAll.length) {\n        logReflowDecision(\"skip:noNodes\", { willApplyReflow: false });\n        finalizeSection(0, 0);\n        return;\n      }\n\n      var debugCounts = {\n        secIndex: secIndex,\n        contentObj: content ? content.querySelectorAll(\".objeto\").length : 0,\n        bleedObj: bleed ? bleed.querySelectorAll(\".objeto\").length : 0,\n        contentAbs: content ? Array.from(content.querySelectorAll(\"*\")).filter(function(el){\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\n        }).length : 0,\n        bleedAbs: bleed ? Array.from(bleed.querySelectorAll(\"*\")).filter(function(el){\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\n        }).length : 0\n      };\n      mslLog(\"section:nodeSources\", debugCounts);\n\n      if (MSL_VERBOSE) {\n        mslLog(\"section:nodesAll:raw\", {\n          secIndex: secIndex,\n          total: nodesAll.length,\n          nodes: nodesAll.map(function(n, i){\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\n            var parentCls = (n.parentElement && n.parentElement.className && typeof n.parentElement.className === \"string\")\n              ? n.parentElement.className\n              : \"\";\n            return {\n              i: i,\n              tag: (n.tagName || \"\").toLowerCase(),\n              cls: cls,\n              parentCls: parentCls,\n              top: n.style ? n.style.top : \"\",\n              left: n.style ? n.style.left : \"\",\n              pos: n.style ? n.style.position : \"\",\n              text: ((n.textContent || \"\").trim()).slice(0, 40)\n            };\n          })\n        });\n        try {\n          var flat = nodesAll.map(function(n, i){\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\n            var txt = ((n.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 60);\n            return \"#\" + i\n              + \" tag=\" + String((n.tagName || \"\").toLowerCase())\n              + \" cls=\" + cls\n              + \" pos=\" + (n.style ? n.style.position : \"\")\n              + \" top=\" + (n.style ? n.style.top : \"\")\n              + \" left=\" + (n.style ? n.style.left : \"\")\n              + \" text=\" + txt;\n          });\n          mslLog(\"section:nodesAll:flat\", \"sec=\" + secIndex + \" total=\" + nodesAll.length + \" :: \" + flat.join(\" | \"));\n        } catch(e) {}\n      }\n      var restoredCount = 0;\n      nodesAll.forEach(function(node){\n        restoredCount += restoreNodeBaseline(node);\n      });\n      mslLog(\"section:baselineRestore\", { secIndex: secIndex, nodes: nodesAll.length, restored: restoredCount });\n\n      // Rect del content (métricas reales)\n      var contentRect = content.getBoundingClientRect();\n      var contentW = contentRect.width || 0;\n      var secCurrentH = sec.getBoundingClientRect().height || 0;\n      var baseHeightAttr = \"data-msl-base-height\";\n      if (!sec.hasAttribute(baseHeightAttr)) {\n        sec.setAttribute(baseHeightAttr, String(secCurrentH));\n      }\n      var baseSecHeight = parseFloat(sec.getAttribute(baseHeightAttr) || \"\");\n      if (!isFinite(baseSecHeight) || baseSecHeight <= 0) baseSecHeight = secCurrentH;\n\n      // items (rects) en coordenadas del content (TODOS)\n      var itemsAll = nodesAll.map(function(node){\n        var rc = relRect(node, content);\n        return {\n          node: node,\n          top: rc.top,\n          left: rc.left,\n          height: rc.height,\n          width: rc.width\n        };\n      });\n      buildReflowElementsDump(itemsAll, contentW);\n      mslLog(\"section:reflow:elements\", {\n        secIndex: secIndex,\n        secModo: secModo,\n        contentW: +Number(contentW || 0).toFixed(1),\n        total: reflowElementsDump.length,\n        elements: reflowElementsDump\n      });\n      if (MSL_VERBOSE) {\n        mslLog(\"section:itemsAll\", {\n          secIndex: secIndex,\n          total: itemsAll.length,\n          items: itemsAll.map(function(it, idx){\n            return {\n              i: idx,\n              kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\n              top: +it.top.toFixed(1),\n              left: +it.left.toFixed(1),\n              w: +it.width.toFixed(1),\n              h: +it.height.toFixed(1),\n              textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\n            };\n          })\n        });\n      }\n\n      // Preservar el \"aire\" inferior original de la seccion tras el reflow.\n      var maxOriginalBottom = 0;\n      for (var ib=0; ib<itemsAll.length; ib++){\n        var itb = itemsAll[ib];\n        var btm = (itb.top || 0) + (itb.height || 0);\n        if (btm > maxOriginalBottom) maxOriginalBottom = btm;\n      }\n      var baseBottomGap = Math.max(0, baseSecHeight - maxOriginalBottom);\n\n      // Si todo mide 0 (fonts no listas), reintentamos luego\n      var anyValidAll = itemsAll.some(function(it){ return it.height > 0.5; });\n      if(!anyValidAll) {\n        logReflowDecision(\"skip:invalidRects\", {\n          willApplyReflow: false,\n          allHeightsTiny: true\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      if (!allowReflow || nodesAll.length < 2) {\n        logReflowDecision(\"skip:notEligible\", {\n          willApplyReflow: false,\n          allowReflow: allowReflow,\n          totalNodes: nodesAll.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      function detectHeroLikeCentralText(items, rootW){\n        var out = {\n          isHero: false,\n          reason: \"\",\n          textCount: 0,\n          textColumnCount: 0,\n          textColumns: [],\n          singleTextColumn: false,\n          maxTextWidthRatio: null,\n          widthRatio: null,\n          centerDelta: null,\n          centerTol: null,\n          centeredByAlign: false,\n          centeredByGeometry: false,\n          decorNear: 0,\n          decorLeft: 0,\n          decorRight: 0,\n          decorInvadingTextColumn: 0\n        };\n        if (!items || !items.length || !rootW || rootW <= 0) {\n          out.reason = \"noItemsOrWidth\";\n          return out;\n        }\n\n        var textItems = items.filter(function(it){\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\n          var tw = Number(it.width || 0);\n          var th = Number(it.height || 0);\n          return tw > 2 && th > 2;\n        });\n        out.textCount = textItems.length;\n        if (!textItems.length) {\n          out.reason = \"noText\";\n          return out;\n        }\n\n        var explicitHero = false;\n        for (var eh=0; eh<textItems.length; eh++){\n          var roleEh = (textItems[eh].node.getAttribute(\"data-mobile-role\") || \"\").toLowerCase();\n          if (roleEh === \"hero\") {\n            explicitHero = true;\n            break;\n          }\n        }\n\n        var colTol = Math.max(18, rootW * 0.14);\n        var textCols = [];\n        for (var tc=0; tc<textItems.length; tc++){\n          var txt = textItems[tc];\n          var txtCx = Number(txt.left || 0) + Number(txt.width || 0) / 2;\n          var attached = false;\n          for (var cc=0; cc<textCols.length; cc++){\n            if (Math.abs(txtCx - textCols[cc].cx) <= colTol) {\n              var nCol = textCols[cc].count + 1;\n              textCols[cc].cx = ((textCols[cc].cx * textCols[cc].count) + txtCx) / nCol;\n              textCols[cc].count = nCol;\n              textCols[cc].minLeft = Math.min(textCols[cc].minLeft, Number(txt.left || 0));\n              textCols[cc].maxRight = Math.max(textCols[cc].maxRight, Number(txt.left || 0) + Number(txt.width || 0));\n              textCols[cc].minTop = Math.min(textCols[cc].minTop, Number(txt.top || 0));\n              textCols[cc].maxBottom = Math.max(textCols[cc].maxBottom, Number(txt.top || 0) + Number(txt.height || 0));\n              attached = true;\n              break;\n            }\n          }\n          if (!attached) {\n            textCols.push({\n              cx: txtCx,\n              count: 1,\n              minLeft: Number(txt.left || 0),\n              maxRight: Number(txt.left || 0) + Number(txt.width || 0),\n              minTop: Number(txt.top || 0),\n              maxBottom: Number(txt.top || 0) + Number(txt.height || 0)\n            });\n          }\n        }\n        textCols.sort(function(a,b){ return a.cx - b.cx; });\n        out.textColumnCount = textCols.length;\n        out.singleTextColumn = textCols.length === 1;\n        out.textColumns = textCols.map(function(col){\n          return {\n            cx: +Number(col.cx || 0).toFixed(1),\n            count: col.count,\n            left: +Number(col.minLeft || 0).toFixed(1),\n            right: +Number(col.maxRight || 0).toFixed(1),\n            top: +Number(col.minTop || 0).toFixed(1),\n            bottom: +Number(col.maxBottom || 0).toFixed(1)\n          };\n        });\n        if (!out.singleTextColumn) {\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"multiTextColumns\";\n          out.isHero = explicitHero;\n          return out;\n        }\n\n        var centerX = rootW / 2;\n        var textCol = textCols[0];\n        var textCenterX = Number(textCol.cx || centerX);\n        var centerDelta = Math.abs(textCenterX - centerX);\n        var centerTol = Math.max(18, rootW * 0.12);\n        out.centerDelta = +centerDelta.toFixed(1);\n        out.centerTol = +centerTol.toFixed(1);\n\n        var centeredAlignCount = 0;\n        var maxTextWidthRatio = 0;\n        var textTop = Infinity;\n        var textBottom = -Infinity;\n        for (var tix=0; tix<textItems.length; tix++){\n          var t = textItems[tix];\n          var ta = (t.node && t.node.style && t.node.style.textAlign)\n            ? String(t.node.style.textAlign).toLowerCase()\n            : \"\";\n          if (ta === \"center\") centeredAlignCount++;\n          var wRatio = Number(t.width || 0) / Math.max(1, rootW);\n          if (wRatio > maxTextWidthRatio) maxTextWidthRatio = wRatio;\n          textTop = Math.min(textTop, Number(t.top || 0));\n          textBottom = Math.max(textBottom, Number(t.top || 0) + Number(t.height || 0));\n        }\n        out.maxTextWidthRatio = +maxTextWidthRatio.toFixed(3);\n        out.widthRatio = out.maxTextWidthRatio;\n        out.centeredByAlign = centeredAlignCount >= Math.max(1, Math.ceil(textItems.length * 0.5));\n        out.centeredByGeometry = centerDelta <= centerTol;\n        if (!out.centeredByAlign && !out.centeredByGeometry) {\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"singleTextColumnNotCentered\";\n          out.isHero = explicitHero;\n          return out;\n        }\n\n        // Evita marcar como hero textos sueltos muy chicos.\n        if (textItems.length < 2 && maxTextWidthRatio < 0.28 && !explicitHero) {\n          out.reason = \"textTooSmall\";\n          return out;\n        }\n\n        if (!isFinite(textTop) || !isFinite(textBottom) || textBottom <= textTop) {\n          textTop = 0;\n          textBottom = 0;\n        }\n        var nearTop = textTop - Math.max(28, (textBottom - textTop) * 0.2);\n        var nearBottom = textBottom + Math.max(36, (textBottom - textTop) * 0.35);\n        var invadePad = Math.max(24, rootW * 0.17);\n        var invadeLeft = textCenterX - invadePad;\n        var invadeRight = textCenterX + invadePad;\n\n        var decorNear = 0;\n        var decorLeft = 0;\n        var decorRight = 0;\n        var decorInvading = 0;\n\n        for (var iHero=0; iHero<items.length; iHero++){\n          var it = items[iHero];\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") continue;\n\n          var w = Number(it.width || 0);\n          var h = Number(it.height || 0);\n          if (w < 8 || h < 8) continue;\n\n          var top = Number(it.top || 0);\n          var bottom = top + h;\n          var inBand = !(bottom < nearTop || top > nearBottom);\n          if (!inBand) continue;\n\n          decorNear++;\n          var cx = Number(it.left || 0) + w / 2;\n          if (cx < textCenterX - 8) decorLeft++;\n          else if (cx > textCenterX + 8) decorRight++;\n\n          var left = Number(it.left || 0);\n          var right = left + w;\n          if (right > invadeLeft && left < invadeRight) decorInvading++;\n        }\n\n        out.decorNear = decorNear;\n        out.decorLeft = decorLeft;\n        out.decorRight = decorRight;\n        out.decorInvadingTextColumn = decorInvading;\n\n        var decorAround = (decorLeft > 0 && decorRight > 0) || decorNear >= 3;\n        var centeredSingleTextColumn = out.singleTextColumn && (out.centeredByAlign || out.centeredByGeometry);\n        out.isHero = explicitHero || centeredSingleTextColumn;\n        out.reason = out.isHero\n          ? (\n            explicitHero\n              ? \"explicitHeroRole\"\n              : (decorInvading > 0\n                ? \"singleCenteredTextColumnDecorInvades\"\n                : (decorAround\n                  ? \"singleCenteredTextColumnWithDecor\"\n                  : \"singleCenteredTextColumn\"))\n          )\n          : \"noHeroSignal\";\n        return out;\n      }\n\n      function detectInlinePairNoReflow(flowItems, allItems, rootW, CFG){\n        var out = {\n          skip: false,\n          reason: \"\",\n          totalFlow: flowItems ? flowItems.length : 0,\n          totalAll: allItems ? allItems.length : 0,\n          rowDelta: null,\n          rowTol: null,\n          pairSpan: null,\n          pairSpanRatio: null,\n          fitsTogether: false,\n          bothSmall: false,\n          smallWLimit: null,\n          smallHLimit: null,\n          widths: [],\n          heights: []\n        };\n        if (!flowItems || flowItems.length !== 2 || !allItems || allItems.length !== 2 || !rootW || rootW <= 0) {\n          out.reason = \"notExactPair\";\n          return out;\n        }\n\n        var a = flowItems[0];\n        var b = flowItems[1];\n        var aW = Math.max(0, Number(a.width || 0));\n        var bW = Math.max(0, Number(b.width || 0));\n        var aH = Math.max(0, Number(a.height || 0));\n        var bH = Math.max(0, Number(b.height || 0));\n        out.widths = [+aW.toFixed(1), +bW.toFixed(1)];\n        out.heights = [+aH.toFixed(1), +bH.toFixed(1)];\n\n        if (aW < 2 || bW < 2 || aH < 2 || bH < 2) {\n          out.reason = \"invalidSizes\";\n          return out;\n        }\n\n        var rowTol = Math.max(12, Number((CFG && CFG.ROW_TOL) || 28) * 1.2);\n        var rowDelta = Math.abs(Number(a.top || 0) - Number(b.top || 0));\n        out.rowTol = +rowTol.toFixed(1);\n        out.rowDelta = +rowDelta.toFixed(1);\n        if (rowDelta > rowTol) {\n          out.reason = \"notInlineRow\";\n          return out;\n        }\n\n        var smallWLimit = Math.max(74, rootW * 0.42);\n        var smallHLimit = Math.max(34, rootW * 0.2);\n        out.smallWLimit = +smallWLimit.toFixed(1);\n        out.smallHLimit = +smallHLimit.toFixed(1);\n        var bothSmall =\n          aW <= smallWLimit &&\n          bW <= smallWLimit &&\n          aH <= smallHLimit &&\n          bH <= smallHLimit;\n        out.bothSmall = bothSmall;\n        if (!bothSmall) {\n          out.reason = \"pairNotSmall\";\n          return out;\n        }\n\n        var pairLeft = Math.min(Number(a.left || 0), Number(b.left || 0));\n        var pairRight = Math.max(Number(a.left || 0) + aW, Number(b.left || 0) + bW);\n        var pairSpan = Math.max(0, pairRight - pairLeft);\n        var fitsTogether = pairSpan <= (rootW + 1);\n        out.pairSpan = +pairSpan.toFixed(1);\n        out.pairSpanRatio = +(pairSpan / Math.max(1, rootW)).toFixed(3);\n        out.fitsTogether = fitsTogether;\n\n        if (fitsTogether) {\n          out.skip = true;\n          out.reason = \"smallInlinePairFits\";\n          return out;\n        }\n\n        out.reason = \"smallInlinePairOverflow\";\n        return out;\n      }\n\n      function enforceInlinePairGap(flowItems, rootEl, rootW){\n        var out = {\n          applied: false,\n          reason: \"\",\n          minGap: 6,\n          gapBefore: null,\n          gapAfter: null,\n          need: null,\n          moveLeft: 0,\n          moveRight: 0,\n          overflowBefore: false,\n          overflowAfter: false\n        };\n        var rootPadLeft = 0;\n        if (rootEl) {\n          var rootCS = getComputedStyle(rootEl);\n          rootPadLeft = parseFloat(rootCS.paddingLeft) || 0;\n        }\n        if (!flowItems || flowItems.length !== 2 || !rootEl || !rootW || rootW <= 0) {\n          out.reason = \"notExactPair\";\n          return out;\n        }\n\n        var a = flowItems[0];\n        var b = flowItems[1];\n        if (!a || !b || !a.node || !b.node) {\n          out.reason = \"missingNodes\";\n          return out;\n        }\n\n        var leftItem = Number(a.left || 0) <= Number(b.left || 0) ? a : b;\n        var rightItem = (leftItem === a) ? b : a;\n\n        var rrL = relRect(leftItem.node, rootEl);\n        var rrR = relRect(rightItem.node, rootEl);\n        var lLeft = Number(rrL.left || 0);\n        var lW = Number(rrL.width || 0);\n        var rLeft = Number(rrR.left || 0);\n        var rW = Number(rrR.width || 0);\n        if (!isFinite(lLeft) || !isFinite(lW) || !isFinite(rLeft) || !isFinite(rW)) {\n          out.reason = \"invalidRects\";\n          return out;\n        }\n\n        var gapBefore = rLeft - (lLeft + lW);\n        out.gapBefore = +gapBefore.toFixed(2);\n        out.overflowBefore = (lLeft < -0.5) || ((rLeft + rW) > (rootW + 0.5));\n\n        var need = Math.max(0, out.minGap - gapBefore);\n        out.need = +need.toFixed(2);\n        if (need <= 0.25) {\n          out.reason = \"alreadySpaced\";\n          out.gapAfter = out.gapBefore;\n          out.overflowAfter = out.overflowBefore;\n          return out;\n        }\n\n        var availRight = Math.max(0, rootW - (rLeft + rW));\n        var availLeft = Math.max(0, lLeft);\n        var moveRight = Math.min(availRight, need);\n        var remaining = Math.max(0, need - moveRight);\n        var moveLeft = Math.min(availLeft, remaining);\n\n        if (moveRight <= 0.01 && moveLeft <= 0.01) {\n          out.reason = \"noRoomToAdjust\";\n          return out;\n        }\n\n        if (moveRight > 0.01) {\n          rightItem.node.style.left = ((Number(rightItem.left || 0) + moveRight) - rootPadLeft) + \"px\";\n          rightItem.node.style.right = \"auto\";\n          rightItem.node.style.marginLeft = \"0px\";\n        }\n        if (moveLeft > 0.01) {\n          leftItem.node.style.left = ((Number(leftItem.left || 0) - moveLeft) - rootPadLeft) + \"px\";\n          leftItem.node.style.right = \"auto\";\n          leftItem.node.style.marginLeft = \"0px\";\n        }\n\n        var rrL2 = relRect(leftItem.node, rootEl);\n        var rrR2 = relRect(rightItem.node, rootEl);\n        var lLeft2 = Number(rrL2.left || 0);\n        var lW2 = Number(rrL2.width || 0);\n        var rLeft2 = Number(rrR2.left || 0);\n        var rW2 = Number(rrR2.width || 0);\n        var gapAfter = rLeft2 - (lLeft2 + lW2);\n\n        out.moveRight = +moveRight.toFixed(2);\n        out.moveLeft = +moveLeft.toFixed(2);\n        out.gapAfter = isFinite(gapAfter) ? +gapAfter.toFixed(2) : null;\n        out.overflowAfter = (lLeft2 < -0.5) || ((rLeft2 + rW2) > (rootW + 0.5));\n        out.applied = (moveRight > 0.01 || moveLeft > 0.01);\n        out.reason = out.applied ? \"applied\" : \"noChange\";\n        if (isFinite(gapAfter) && gapAfter < -0.2) out.reason = \"appliedButStillOverlap\";\n        return out;\n      }\n\n      var prominentNonTextCount = itemsAll.filter(function(it){\n        if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return false;\n        var w = Number(it.width || 0);\n        var h = Number(it.height || 0);\n        if (w < 6 || h < 6) return false;\n        return true;\n      }).length;\n      // Si hay cualquier no-texto visible, evitamos anclar textos por heuristica.\n      // Esto impide que textos de una columna queden \"congelados\" en left original.\n      var allowHeuristicAnchors = prominentNonTextCount === 0;\n\n      // ✅ Determinar qué nodos son \"ANCHOR\" (no se reflowean)\n      // Regla: texto centrado + casi full-width => título/hero, no mover.\n      function isAnchorNode(it){\n        var node = it.node;\n\n        // opt-out explícito\n        var keepLayout = (node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n        if (keepLayout) return true;\n\n        // anchor explícito (si lo usás)\n        var role = (node.getAttribute(\"data-mobile-role\") || \"\");\n        if (role === \"anchor\") return true;\n\n        // heurística para textos\n        var isText = (node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n        if (!isText) return false;\n        if (!allowHeuristicAnchors) return false;\n\n        var ta = (node.style && node.style.textAlign) ? String(node.style.textAlign).toLowerCase() : \"\";\n        if (!ta) {\n          try {\n            ta = String(getComputedStyle(node).textAlign || \"\").toLowerCase();\n          } catch(_e) {}\n        }\n        if (ta !== \"center\") return false;\n\n        // solo si realmente ocupa casi todo el ancho usable\n        // (esto evita romper textos centrados dentro de columnas)\n        if (contentW > 0 && it.width >= contentW * 0.78) return true;\n\n        return false;\n      }\n\n      // ✅ Flow = todo lo que NO es anchor\n      var itemsFlow = itemsAll.filter(function(it){ return !isAnchorNode(it); });\n      var itemsAnchor = itemsAll.filter(function(it){ return isAnchorNode(it); });\n      mslLog(\"section:anchorSplit\", {\n        secIndex: secIndex,\n        anchors: itemsAnchor.length,\n        flow: itemsFlow.length,\n        prominentNonTextCount: prominentNonTextCount,\n        allowHeuristicAnchors: allowHeuristicAnchors,\n        anchorsDetail: itemsAnchor.map(function(it){\n          return {\n            kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\n            top: +it.top.toFixed(1),\n            left: +it.left.toFixed(1),\n            w: +it.width.toFixed(1),\n            h: +it.height.toFixed(1),\n            textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\n          };\n        })\n      });\n\n      // Si no hay suficientes elementos reflowables, no hacemos nada\n      if(itemsFlow.length < 2) {\n        logReflowDecision(\"skip:flowTooSmall\", {\n          willApplyReflow: false,\n          flowCount: itemsFlow.length,\n          anchorCount: itemsAnchor.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      // ✅ Para que \"altura necesaria\" no quede corta,\n      // medimos el bottom máximo de anchors (en coords del content)\n      var maxAnchorBottom = 0;\n      itemsAll.forEach(function(it){\n        if (!isAnchorNode(it)) return;\n        var b = (it.top || 0) + (it.height || 0);\n        if (b > maxAnchorBottom) maxAnchorBottom = b;\n      });\n\n      // ✅ 1) agrupar por solape → clusters (SOLO FLOW)\n      var clusters = buildOverlapClusters(itemsFlow);\n      mslLog(\"section:clusters\", {\n        secIndex: secIndex,\n        count: clusters.length,\n        clusters: clusters.map(function(c, idx){\n          return {\n            i: idx,\n            top: +c.top.toFixed(1),\n            left: +c.left.toFixed(1),\n            w: +c.width.toFixed(1),\n            h: +c.height.toFixed(1),\n            cx: +c.cx.toFixed(1),\n            items: c.items.length\n          };\n        })\n      });\n\n      // ✅ 2) Detectar columnas/rows (SOLO FLOW)\n      var rootW = contentW || 0;\n      var ord = orderClustersForMobile(clusters, rootW, CFG);\n      var groups = ord.groups;\n      var mode = ord.mode;\n      mslLog(\"section:ordering\", {\n        secIndex: secIndex,\n        mode: mode,\n        rootW: rootW,\n        groups: groups.map(function(grp, gi){\n          return {\n            g: gi,\n            count: grp.length,\n            tops: grp.map(function(c){ return +c.top.toFixed(1); }),\n            lefts: grp.map(function(c){ return +c.left.toFixed(1); })\n          };\n        })\n      });\n\n      var heroSignal = detectHeroLikeCentralText(itemsAll, rootW);\n      mslLog(\"section:heroCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        isHero: heroSignal.isHero,\n        reason: heroSignal.reason,\n        textCount: heroSignal.textCount,\n        textColumnCount: heroSignal.textColumnCount,\n        singleTextColumn: heroSignal.singleTextColumn,\n        textColumns: heroSignal.textColumns,\n        maxTextWidthRatio: heroSignal.maxTextWidthRatio,\n        widthRatio: heroSignal.widthRatio,\n        centerDelta: heroSignal.centerDelta,\n        centerTol: heroSignal.centerTol,\n        centeredByAlign: heroSignal.centeredByAlign,\n        centeredByGeometry: heroSignal.centeredByGeometry,\n        decorNear: heroSignal.decorNear,\n        decorLeft: heroSignal.decorLeft,\n        decorRight: heroSignal.decorRight,\n        decorInvadingTextColumn: heroSignal.decorInvadingTextColumn\n      });\n      if (heroSignal.isHero) {\n        logReflowDecision(\"skip:heroCentralText\", {\n          willApplyReflow: false,\n          mode: mode,\n          heroReason: heroSignal.reason,\n          hero: heroSignal\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      var inlinePairSignal = detectInlinePairNoReflow(itemsFlow, itemsAll, rootW, CFG);\n      mslLog(\"section:inlinePairCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        skip: inlinePairSignal.skip,\n        reason: inlinePairSignal.reason,\n        totalFlow: inlinePairSignal.totalFlow,\n        totalAll: inlinePairSignal.totalAll,\n        rowDelta: inlinePairSignal.rowDelta,\n        rowTol: inlinePairSignal.rowTol,\n        widths: inlinePairSignal.widths,\n        heights: inlinePairSignal.heights,\n        bothSmall: inlinePairSignal.bothSmall,\n        smallWLimit: inlinePairSignal.smallWLimit,\n        smallHLimit: inlinePairSignal.smallHLimit,\n        pairSpan: inlinePairSignal.pairSpan,\n        pairSpanRatio: inlinePairSignal.pairSpanRatio,\n        fitsTogether: inlinePairSignal.fitsTogether\n      });\n      if (inlinePairSignal.skip) {\n        var inlinePairAdjust = enforceInlinePairGap(itemsFlow, content, rootW);\n        mslLog(\"section:inlinePairAdjust\", {\n          secIndex: secIndex,\n          mode: mode,\n          adjust: inlinePairAdjust\n        });\n        logReflowDecision(\"skip:smallInlinePairFits\", {\n          willApplyReflow: false,\n          mode: mode,\n          inlinePair: inlinePairSignal,\n          inlinePairAdjust: inlinePairAdjust\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      // ✅ 3) Gate \"mejor de ambos mundos\":\n      // - Si es \"one\" (layout ya natural) Y además entra, NO hacemos reflow.\n      // - En cualquier otro caso (two/three/rows), hacemos reflow para lectura mobile,\n      //   incluso aunque \"entre\".\n      var fits = clustersFitInMobile(clusters, content);\n      mslLog(\"section:fitCheck\", {\n        secIndex: secIndex,\n        mode: mode,\n        fits: fits,\n        willSkip: (mode === \"one\" && fits)\n      });\n      if (mode === \"one\" && fits) {\n        logReflowDecision(\"skip:modeOneFits\", {\n          willApplyReflow: false,\n          mode: mode,\n          fits: fits,\n          clusters: clusters.length,\n          flowCount: itemsFlow.length\n        });\n        finalizeSection(0, baseBottomGap);\n        return;\n      }\n\n      logReflowDecision(\"apply:modeRequiresReflow\", {\n        willApplyReflow: true,\n        mode: mode,\n        fits: fits,\n        clusters: clusters.length,\n        flowCount: itemsFlow.length,\n        anchorCount: itemsAnchor.length,\n        groupSizes: groups.map(function(grp){ return grp.length; })\n      });\n\n      // ✅ 4) Reflow solo sobre FLOW (preserva solapes dentro de cada cluster)\n      var res = applyClusterStack(groups, content, CFG, mode);\n      mslLog(\"section:applyResult\", {\n        secIndex: secIndex,\n        changed: !!(res && res.changed),\n        neededHeight: res ? res.neededHeight : null,\n        maxAnchorBottom: +maxAnchorBottom.toFixed(1),\n        baseBottomGap: +baseBottomGap.toFixed(1)\n      });\n      logReflowDecision(\"postApply\", {\n        willApplyReflow: true,\n        changed: !!(res && res.changed),\n        neededHeight: res ? +Number(res.neededHeight || 0).toFixed(1) : null,\n        mode: mode\n      });\n\n      var neededAfterReflow = 0;\n      if (res && res.changed) {\n        // Evitar que la sección quede chica si hay anchors más abajo\n        var needed = Number(res.neededHeight || 0);\n        if (Number(maxAnchorBottom) > 0) {\n          // sumamos padding bottom para que no quede pegado\n          var anchorNeeded = Math.ceil(maxAnchorBottom + (CFG.PAD_BOT || 0));\n          if (anchorNeeded > needed) needed = anchorNeeded;\n        }\n        if (baseBottomGap > 0) {\n          needed = Math.ceil(needed + baseBottomGap);\n        }\n        if (needed > 0) neededAfterReflow = needed;\n      }\n      finalizeSection(neededAfterReflow, baseBottomGap);\n    });\n  }\n\n  function boot(){\n    mslLog(\"boot\", { cfg: CFG });\n    runOnce();\n    setTimeout(runOnce, 150);\n    setTimeout(runOnce, 600);\n    setTimeout(runOnce, 1800);\n\n    if(document.fonts && document.fonts.ready){\n      document.fonts.ready.then(function(){ runOnce(); }).catch(function(){});\n    }\n  }\n\n  window.addEventListener(\"load\", boot);\n  window.addEventListener(\"resize\", runOnce);\n\n  if(window.visualViewport){\n    window.visualViewport.addEventListener(\"resize\", runOnce);\n    window.visualViewport.addEventListener(\"scroll\", runOnce);\n  }\n\n  if(document.readyState !== \"loading\") boot();\n  else document.addEventListener(\"DOMContentLoaded\", boot);\n})();\n</script>\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFFaEI7QUFDRztBQUNBO0FBQ0E7QUFFdEMsU0FBU0ksWUFBWUMsR0FBcUI7SUFDL0MsSUFBSSxDQUFDQSxJQUFJQyxPQUFPLEVBQUUsT0FBTztJQUV6QixPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUF1R0csRUFBRUQsSUFBSUUsUUFBUSxDQUFDO2FBQ2YsRUFBRUYsSUFBSUcsUUFBUSxDQUFDO2VBQ2IsRUFBRUgsSUFBSUksUUFBUSxDQUFDOzthQUVqQixFQUFFSixJQUFJSyxZQUFZLENBQUM7YUFDbkIsRUFBRUwsSUFBSU0sZUFBZSxDQUFDOztnQkFFbkIsRUFBRU4sSUFBSU8saUJBQWlCLEdBQUcsU0FBUyxRQUFRO3lCQUNsQyxFQUFFUCxJQUFJUSxpQkFBaUIsR0FBRyxTQUFTLFFBQVE7O2FBRXZELEVBQUVSLElBQUlTLFFBQVEsQ0FBQzs7MEJBRUYsRUFBRVQsSUFBSVUsaUJBQWlCLENBQUM7bUJBQy9CLEVBQUVWLElBQUlXLGFBQWEsQ0FBQzs7NEJBRVgsRUFBRVgsSUFBSVksbUJBQW1CLENBQUM7bUJBQ25DLEVBQUVaLElBQUlhLGFBQWEsQ0FBQzs7bUJBRXBCLEVBQUViLElBQUljLFdBQVcsQ0FBQzttQkFDbEIsRUFBRWQsSUFBSWUsV0FBVyxDQUFDOzRCQUNULEVBQUVmLElBQUlnQixtQkFBbUIsQ0FBQzt3QkFDOUIsRUFBRWhCLElBQUlpQixlQUFlLENBQUM7OztFQUc1QyxFQUFFdEIsdURBQWlCQSxHQUFHOztFQUV0QixFQUFFRSwwREFBZUEsR0FBRzs7RUFFcEIsRUFBRUMsMERBQWVBLEdBQUc7O0VBRXBCLEVBQUVGLDBEQUFlQSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeTlCdEIsQ0FBQyxDQUFDc0IsSUFBSTtBQUNOIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXG1vYmlsZVNtYXJ0TGF5b3V0XFxzY3JpcHRUZW1wbGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L3NjcmlwdFRlbXBsYXRlLnRzXHJcbmltcG9ydCB7IE5vcm1hbGl6ZWRDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcbmltcG9ydCB7IGpzRG9tSGVscGVyc0Jsb2NrIH0gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQgeyBqc0ZpdFNjYWxlQmxvY2sgfSBmcm9tIFwiLi9maXRTY2FsZVwiO1xuaW1wb3J0IHsganNPcmRlcmluZ0Jsb2NrIH0gZnJvbSBcIi4vb3JkZXJpbmdcIjtcbmltcG9ydCB7IGpzU3RhY2tpbmdCbG9jayB9IGZyb20gXCIuL3N0YWNraW5nXCI7XG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2NyaXB0KGNmZzogTm9ybWFsaXplZENvbmZpZyk6IHN0cmluZyB7XHJcbiAgaWYgKCFjZmcuZW5hYmxlZCkgcmV0dXJuIFwiXCI7XHJcblxyXG4gIHJldHVybiBgXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCl7XG4gIHZhciBFTkFCTEVEID0gdHJ1ZTtcbiAgZnVuY3Rpb24gcmVhZEZsYWdGcm9tU2VhcmNoKHNlYXJjaCwgbmFtZSl7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSBcInN0cmluZ1wiIHx8ICFzZWFyY2gpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBub3JtYWxpemVkID0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiAoXCI/XCIgKyBzZWFyY2gpO1xuICAgICAgdmFyIHFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhub3JtYWxpemVkKTtcbiAgICAgIHZhciBxdiA9IHFwLmdldChuYW1lKTtcbiAgICAgIHJldHVybiBxdiA9PT0gXCIxXCIgfHwgU3RyaW5nKHF2KS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIjtcbiAgICB9IGNhdGNoKF9lMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWFkRGVidWdGbGFnKG5hbWUpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgc2VhcmNoID0gKHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uc2VhcmNoKSA/IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggOiBcIlwiO1xuICAgICAgaWYgKHJlYWRGbGFnRnJvbVNlYXJjaChzZWFyY2gsIG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKF9lMSkge31cblxuICAgIC8vIHNyY0RvYyBzYW5kYm94IHN1ZWxlIGNvbnNlcnZhciBkb2N1bWVudC5yZWZlcnJlciBjb24gbGEgVVJMIHBhZHJlLlxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVmZXJyZXIgPSAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnJlZmVycmVyKSA/IFN0cmluZyhkb2N1bWVudC5yZWZlcnJlcikgOiBcIlwiO1xuICAgICAgaWYgKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciByZWZVcmwgPSBuZXcgVVJMKHJlZmVycmVyKTtcbiAgICAgICAgaWYgKHJlYWRGbGFnRnJvbVNlYXJjaChyZWZVcmwuc2VhcmNoIHx8IFwiXCIsIG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKF9lUmVmKSB7fVxuXG4gICAgLy8gc3JjRG9jL2Fib3V0OnNyY2RvYyBubyBzdWVsZSB0ZW5lciBxdWVyeXN0cmluZy5cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5wYXJlbnQgJiYgd2luZG93LnBhcmVudCAhPT0gd2luZG93ICYmIHdpbmRvdy5wYXJlbnQubG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHBTZWFyY2ggPSB3aW5kb3cucGFyZW50LmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwiO1xuICAgICAgICBpZiAocmVhZEZsYWdGcm9tU2VhcmNoKHBTZWFyY2gsIG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKF9lMikge31cblxuICAgIHRyeSB7XG4gICAgICBpZiAod2luZG93LnRvcCAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgd2luZG93LnRvcC5sb2NhdGlvbikge1xuICAgICAgICB2YXIgdFNlYXJjaCA9IHdpbmRvdy50b3AubG9jYXRpb24uc2VhcmNoIHx8IFwiXCI7XG4gICAgICAgIGlmIChyZWFkRmxhZ0Zyb21TZWFyY2godFNlYXJjaCwgbmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2UzKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBscyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UgPyB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSkgOiBudWxsO1xuICAgICAgaWYgKGxzID09PSBcIjFcIiB8fCBTdHJpbmcobHMpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKF9lNCkge31cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgTVNMX0RFQlVHID0gcmVhZERlYnVnRmxhZyhcIm1zbERlYnVnXCIpO1xuICB2YXIgTVNMX1ZFUkJPU0UgPSByZWFkRGVidWdGbGFnKFwibXNsVmVyYm9zZVwiKTtcbiAgZnVuY3Rpb24gZGJnKGxhYmVsLCBwYXlsb2FkKXtcbiAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW01TTF0gXCIgKyBsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsICsgXCIgXCIgKyBwYXlsb2FkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByZXR0eSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHByZXR0eSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQsIG51bGwsIDIpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdHJ5IHsgcHJldHR5ID0gU3RyaW5nKHBheWxvYWQpOyB9IGNhdGNoKF8pIHsgcHJldHR5ID0gXCJbdW5zZXJpYWxpemFibGVdXCI7IH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsICsgXCJcXFxcblwiICsgcHJldHR5KTtcbiAgfVxuICBmdW5jdGlvbiBtc2xMb2coKXtcbiAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgdmFyIGxhYmVsID0gU3RyaW5nKGFyZ3NbMF0pO1xuICAgIGlmICghTVNMX1ZFUkJPU0UpIHtcbiAgICAgIHZhciBub2lzeSA9IHtcbiAgICAgICAgXCJzZWN0aW9uOm5vZGVTb3VyY2VzXCI6IDEsXG4gICAgICAgIFwic2VjdGlvbjpiYXNlbGluZVJlc3RvcmVcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmFuY2hvclNwbGl0XCI6IDEsXG4gICAgICAgIFwic2VjdGlvbjpjbHVzdGVyc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnRocmVlOmNhbmRpZGF0ZXNcIjogMSxcbiAgICAgICAgXCJvcmRlcjp0aHJlZTpzcHJlYWRcIjogMSxcbiAgICAgICAgXCJvcmRlcjp0d286Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnR3bzpzcHJlYWRcIjogMSxcbiAgICAgICAgXCJvcmRlcjpvbmU6Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnJvd3M6ZmFsbGJhY2tcIjogMVxuICAgICAgfTtcbiAgICAgIGlmIChub2lzeVtsYWJlbF0pIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBkYmcobGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGRiZyhsYWJlbCwgYXJnc1sxXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRiZyhsYWJlbCwgYXJncy5zbGljZSgxKSk7XG4gIH1cbiAgdmFyIENGRyA9IHtcbiAgICBNSU5fR0FQOiAke2NmZy5taW5HYXBQeH0sXHJcbiAgICBNQVhfR0FQOiAke2NmZy5tYXhHYXBQeH0sXHJcbiAgICBHQVBfU0NBTEU6ICR7Y2ZnLmdhcFNjYWxlfSxcclxuXHJcbiAgICBQQURfVE9QOiAke2NmZy5wYWRkaW5nVG9wUHh9LFxyXG4gICAgUEFEX0JPVDogJHtjZmcucGFkZGluZ0JvdHRvbVB4fSxcclxuXHJcbiAgICBPTkxZX0ZJWEVEOiAke2NmZy5vbmx5Rml4ZWRTZWN0aW9ucyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwifSxcclxuICAgIE9OTFlfV0hFTl9SRU9SREVSRUQ6ICR7Y2ZnLm9ubHlXaGVuUmVvcmRlcmVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9LFxyXG5cclxuICAgIFJPV19UT0w6ICR7Y2ZnLnJvd1RvbFB4fSxcclxuXHJcbiAgICBUV09fQ09MX1NQUkVBRF9SQVRJTzogJHtjZmcudHdvQ29sU3ByZWFkUmF0aW99LFxyXG4gICAgTUlOX1BFUl9DT0xfMjogJHtjZmcubWluUGVyQ29sdW1uMn0sXHJcblxyXG4gICAgVEhSRUVfQ09MX1NQUkVBRF9SQVRJTzogJHtjZmcudGhyZWVDb2xTcHJlYWRSYXRpb30sXG4gICAgTUlOX1BFUl9DT0xfMzogJHtjZmcubWluUGVyQ29sdW1uM30sXG5cbiAgICBGSVRfTUlOX1NDQUxFOiAke2NmZy5maXRNaW5TY2FsZX0sXG4gICAgRklUX01BWF9TQ0FMRTogJHtjZmcuZml0TWF4U2NhbGV9LFxuICAgIEZJVF9UQVJHRVRfV0lEVEhfUkFUSU86ICR7Y2ZnLmZpdFRhcmdldFdpZHRoUmF0aW99LFxuICAgIEZJVF9NSU5fRklMTF9SQVRJTzogJHtjZmcuZml0TWluRmlsbFJhdGlvfVxuICB9O1xuXHJcbiAgJHtqc0RvbUhlbHBlcnNCbG9jaygpfVxyXG5cclxuICAke2pzT3JkZXJpbmdCbG9jaygpfVxyXG5cclxuICAke2pzU3RhY2tpbmdCbG9jaygpfVxuXG4gICR7anNGaXRTY2FsZUJsb2NrKCl9XG5cclxuICBmdW5jdGlvbiBleHBhbmRGaXhlZFNlY3Rpb24oc2VjLCBuZWVkZWRIZWlnaHQpe1xyXG4gICAgdmFyIGN1cnJlbnRIID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCAwO1xyXG4gICAgaWYgKG5lZWRlZEhlaWdodCA+IGN1cnJlbnRIICsgMSkge1xyXG4gICAgICBzZWMuc3R5bGUuaGVpZ2h0ID0gTWF0aC5jZWlsKG5lZWRlZEhlaWdodCkgKyBcInB4XCI7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc1NlY3Rpb24oc2VjKXtcbiAgICBpZighc2VjKSByZXR1cm4gZmFsc2U7XG4gICAgaWYoIUNGRy5PTkxZX0ZJWEVEKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgbW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBtb2RvID09PSBcImZpam9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVOb2RlQmFzZWxpbmUobm9kZSl7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gMDtcbiAgICB2YXIgcmVzdG9yZWQgPSAwO1xuXG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIsIG5vZGUuc3R5bGUudG9wIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctbGVmdFwiLCBub2RlLnN0eWxlLmxlZnQgfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiLCBub2RlLnN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdGV4dC1hbGlnblwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtYWxpZ25cIiwgbm9kZS5zdHlsZS50ZXh0QWxpZ24gfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybS1vcmlnaW5cIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10cmFuc2Zvcm0tb3JpZ2luXCIsIG5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LXpvb21cIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LXpvb21cIiwgbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS10ZXh0LXpvb21cIikgfHwgXCJcIik7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdUb3AgPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIpO1xuICAgIHZhciBvcmlnTGVmdCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIpO1xuICAgIHZhciBvcmlnVHJhbnNmb3JtID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiKTtcbiAgICB2YXIgb3JpZ1RleHRBbGlnbiA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LWFsaWduXCIpO1xuICAgIHZhciBvcmlnVHJhbnNmb3JtT3JpZ2luID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybS1vcmlnaW5cIik7XG4gICAgdmFyIG9yaWdUZXh0Wm9vbSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LXpvb21cIik7XG5cbiAgICBpZiAob3JpZ1RvcCAhPSBudWxsICYmIG5vZGUuc3R5bGUudG9wICE9PSBvcmlnVG9wKSB7XG4gICAgICBub2RlLnN0eWxlLnRvcCA9IG9yaWdUb3A7XG4gICAgICByZXN0b3JlZCsrO1xuICAgIH1cbiAgICBpZiAob3JpZ0xlZnQgIT0gbnVsbCAmJiBub2RlLnN0eWxlLmxlZnQgIT09IG9yaWdMZWZ0KSB7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBvcmlnTGVmdDtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnVHJhbnNmb3JtICE9IG51bGwgJiYgbm9kZS5zdHlsZS50cmFuc2Zvcm0gIT09IG9yaWdUcmFuc2Zvcm0pIHtcbiAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gb3JpZ1RyYW5zZm9ybTtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnVGV4dEFsaWduICE9IG51bGwgJiYgbm9kZS5zdHlsZS50ZXh0QWxpZ24gIT09IG9yaWdUZXh0QWxpZ24pIHtcbiAgICAgIGlmIChvcmlnVGV4dEFsaWduKSBub2RlLnN0eWxlLnRleHRBbGlnbiA9IG9yaWdUZXh0QWxpZ247XG4gICAgICBlbHNlIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0ZXh0LWFsaWduXCIpO1xuICAgICAgcmVzdG9yZWQrKztcbiAgICB9XG4gICAgaWYgKG9yaWdUcmFuc2Zvcm1PcmlnaW4gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiAhPT0gb3JpZ1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgaWYgKG9yaWdUcmFuc2Zvcm1PcmlnaW4pIG5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ1RyYW5zZm9ybU9yaWdpbjtcbiAgICAgIGVsc2Ugbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybS1vcmlnaW5cIik7XG4gICAgICByZXN0b3JlZCsrO1xuICAgIH1cbiAgICBpZiAob3JpZ1RleHRab29tICE9IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGV4dFpvb20gPSBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLXRleHQtem9vbVwiKSB8fCBcIlwiO1xuICAgICAgaWYgKGN1cnJlbnRUZXh0Wm9vbSAhPT0gb3JpZ1RleHRab29tKSB7XG4gICAgICAgIGlmIChvcmlnVGV4dFpvb20pIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRleHQtem9vbVwiLCBvcmlnVGV4dFpvb20pO1xuICAgICAgICBlbHNlIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXRleHQtem9vbVwiKTtcbiAgICAgICAgcmVzdG9yZWQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcbiAgICByZXR1cm4gcmVzdG9yZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBydW5PbmNlKCl7XG4gICAgaWYoIUVOQUJMRUQpIHJldHVybjtcbiAgICBpZighaXNNb2JpbGUoKSkge1xuICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSkuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgICB2YXIgY29udGVudCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1jb250ZW50XCIpO1xuICAgICAgICBpZighY29udGVudCkgcmV0dXJuO1xuICAgICAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XG4gICAgICAgIHJlc2V0U2VjdGlvbkZpdFNjYWxlKHNlYywgY29udGVudCwgYmxlZWQpO1xuICAgICAgICB2YXIgbm9kZXNBbGxEZXNrdG9wID0gZ2V0T2JqTm9kZXMoc2VjKTtcbiAgICAgICAgZm9yICh2YXIgbmQ9MDsgbmQ8bm9kZXNBbGxEZXNrdG9wLmxlbmd0aDsgbmQrKykge1xuICAgICAgICAgIHJlc3RvcmVOb2RlQmFzZWxpbmUobm9kZXNBbGxEZXNrdG9wW25kXSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBcIjFcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cclxuICAgIHZhciBzZWNzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSk7XHJcbiAgICBpZighc2Vjcy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICBzZWNzLmZvckVhY2goZnVuY3Rpb24oc2VjKXtcbiAgICAgIHZhciBzZWNJbmRleCA9IHNlY3MuaW5kZXhPZihzZWMpO1xuICAgICAgdmFyIHNlY01vZG8gPSAoc2VjLmdldEF0dHJpYnV0ZShcImRhdGEtbW9kb1wiKSB8fCBcImZpam9cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBhbGxvd1JlZmxvdyA9IHNob3VsZFByb2Nlc3NTZWN0aW9uKHNlYyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOnN0YXJ0XCIsIHsgc2VjSW5kZXg6IHNlY0luZGV4LCBtb2RvOiBzZWNNb2RvLCBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3cgfSk7XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XG4gICAgICBpZighY29udGVudCkgcmV0dXJuO1xuICAgICAgdmFyIGJsZWVkID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWJsZWVkXCIpO1xuICAgICAgcmVzZXRTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCk7XG4gICAgICB2YXIgbm9kZXNBbGwgPSBnZXRPYmpOb2RlcyhzZWMpO1xuXG4gICAgICB2YXIgcmVmbG93RWxlbWVudHNEdW1wID0gW107XG4gICAgICBmdW5jdGlvbiBidWlsZFJlZmxvd0VsZW1lbnRzRHVtcChpdGVtcywgY29udGVudFdOb3cpe1xuICAgICAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgICAgICB2YXIgbGlzdCA9IChpdGVtcyB8fCBbXSk7XG4gICAgICAgIHZhciBtYXhJdGVtcyA9IDEyMDtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpRHVtcD0wOyBpRHVtcDxsaXN0Lmxlbmd0aCAmJiBpRHVtcDxtYXhJdGVtczsgaUR1bXArKyl7XG4gICAgICAgICAgdmFyIGl0RHVtcCA9IGxpc3RbaUR1bXBdO1xuICAgICAgICAgIGlmICghaXREdW1wIHx8ICFpdER1bXAubm9kZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIG5EdW1wID0gaXREdW1wLm5vZGU7XG4gICAgICAgICAgdmFyIHRleHRSYXcgPSAoKG5EdW1wLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgICAgdmFyIGlzVGV4dER1bXAgPSAobkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGNsc0R1bXAgPSAobkR1bXAuY2xhc3NOYW1lICYmIHR5cGVvZiBuRHVtcC5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbkR1bXAuY2xhc3NOYW1lIDogXCJcIjtcbiAgICAgICAgICB2YXIgcm9vdFpvbmUgPSAobkR1bXAuY2xvc2VzdCAmJiBuRHVtcC5jbG9zZXN0KFwiLnNlYy1ibGVlZFwiKSkgPyBcImJsZWVkXCIgOiBcImNvbnRlbnRcIjtcbiAgICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgICBpOiBpRHVtcCxcbiAgICAgICAgICAgIGtpbmQ6IGlzVGV4dER1bXAgPyBcInRleHRvXCIgOiBTdHJpbmcoKG5EdW1wLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICB6b25lOiByb290Wm9uZSxcbiAgICAgICAgICAgIHRvcDogK051bWJlcihpdER1bXAudG9wIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiArTnVtYmVyKGl0RHVtcC5sZWZ0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3OiArTnVtYmVyKGl0RHVtcC53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK051bWJlcihpdER1bXAuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICByaWdodDogK051bWJlcigoaXREdW1wLmxlZnQgfHwgMCkgKyAoaXREdW1wLndpZHRoIHx8IDApKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgYm90dG9tOiArTnVtYmVyKChpdER1bXAudG9wIHx8IDApICsgKGl0RHVtcC5oZWlnaHQgfHwgMCkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjeDogK051bWJlcigoaXREdW1wLmxlZnQgfHwgMCkgKyAoKGl0RHVtcC53aWR0aCB8fCAwKSAvIDIpKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgd1JhdGlvOiBjb250ZW50V05vdyA+IDEgPyArTnVtYmVyKChpdER1bXAud2lkdGggfHwgMCkgLyBjb250ZW50V05vdykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc0R1bXAsXG4gICAgICAgICAgICBtb2JpbGVMYXlvdXQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlUm9sZTogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQ2x1c3RlcjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQ2x1c3RlcklkOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyLWlkXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDZW50ZXI6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNlbnRlclwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQWxpZ246IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWFsaWduXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVGaXQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWZpdFwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAobkR1bXAuc3R5bGUgJiYgbkR1bXAuc3R5bGUudGV4dEFsaWduKSA/IG5EdW1wLnN0eWxlLnRleHRBbGlnbiA6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0U2FtcGxlOiBpc1RleHREdW1wID8gdGV4dFJhdy5zbGljZSgwLCA5MCkgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmbG93RWxlbWVudHNEdW1wID0gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2dSZWZsb3dEZWNpc2lvbihyZWFzb24sIGV4dHJhKXtcbiAgICAgICAgaWYgKCFNU0xfREVCVUcpIHJldHVybjtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHNlY01vZG86IHNlY01vZG8sXG4gICAgICAgICAgYWxsb3dSZWZsb3c6IGFsbG93UmVmbG93LFxuICAgICAgICAgIHRvdGFsTm9kZXM6IChub2Rlc0FsbCB8fCBbXSkubGVuZ3RoLFxuICAgICAgICAgIHJlYXNvbjogU3RyaW5nKHJlYXNvbiB8fCBcIlwiKSxcbiAgICAgICAgICBkZXRhaWxzOiBleHRyYSB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOnJlZmxvdzpkZWNpc2lvblwiLCBwYXlsb2FkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmluYWxpemVTZWN0aW9uKG1pbk5lZWRlZEhlaWdodCwgcHJlc2VydmVCb3R0b21HYXApe1xuICAgICAgICB2YXIgZ2FwID0gTnVtYmVyLmlzRmluaXRlKHByZXNlcnZlQm90dG9tR2FwKSA/IE1hdGgubWF4KDAsIE51bWJlcihwcmVzZXJ2ZUJvdHRvbUdhcCkpIDogMDtcbiAgICAgICAgdmFyIGZpdCA9IGFwcGx5U2VjdGlvbkZpdFNjYWxlKFxuICAgICAgICAgIHNlYyxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGJsZWVkLFxuICAgICAgICAgIG5vZGVzQWxsLFxuICAgICAgICAgIHNlY01vZG8sXG4gICAgICAgICAgQ0ZHLFxuICAgICAgICAgIHsgc2VjSW5kZXg6IHNlY0luZGV4IH0sXG4gICAgICAgICAgeyBwcmVzZXJ2ZUJvdHRvbUdhcDogZ2FwIH1cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGZpdE5lZWRlZCA9IChmaXQgJiYgTnVtYmVyLmlzRmluaXRlKGZpdC5uZWVkZWRIZWlnaHQpKSA/IE51bWJlcihmaXQubmVlZGVkSGVpZ2h0KSA6IDA7XG4gICAgICAgIHZhciBuZWVkZWRIZWlnaHQgPSBNYXRoLm1heChOdW1iZXIobWluTmVlZGVkSGVpZ2h0IHx8IDApLCBmaXROZWVkZWQpO1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOmhlaWdodEZpbmFsXCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgbW9kZTogc2VjTW9kbyxcbiAgICAgICAgICBtaW5OZWVkZWRIZWlnaHQ6ICtOdW1iZXIobWluTmVlZGVkSGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgZml0TmVlZGVkSGVpZ2h0OiArZml0TmVlZGVkLnRvRml4ZWQoMSksXG4gICAgICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtnYXAudG9GaXhlZCgxKSxcbiAgICAgICAgICBmaW5hbE5lZWRlZEhlaWdodDogK25lZWRlZEhlaWdodC50b0ZpeGVkKDEpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VjTW9kbyA9PT0gXCJmaWpvXCIgJiYgbmVlZGVkSGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGV4cGFuZEZpeGVkU2VjdGlvbihzZWMsIG5lZWRlZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIW5vZGVzQWxsLmxlbmd0aCkge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6bm9Ob2Rlc1wiLCB7IHdpbGxBcHBseVJlZmxvdzogZmFsc2UgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVidWdDb3VudHMgPSB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgY29udGVudE9iajogY29udGVudCA/IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikubGVuZ3RoIDogMCxcbiAgICAgICAgYmxlZWRPYmo6IGJsZWVkID8gYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikubGVuZ3RoIDogMCxcbiAgICAgICAgY29udGVudEFiczogY29udGVudCA/IEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYWJzb2x1dGVcIiAmJiBlbC5zdHlsZS50b3AgJiYgZWwuc3R5bGUubGVmdCk7XG4gICAgICAgIH0pLmxlbmd0aCA6IDAsXG4gICAgICAgIGJsZWVkQWJzOiBibGVlZCA/IEFycmF5LmZyb20oYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIipcIikpLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgICAgcmV0dXJuICEhKGVsICYmIGVsLnN0eWxlICYmIChlbC5zdHlsZS5wb3NpdGlvbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImFic29sdXRlXCIgJiYgZWwuc3R5bGUudG9wICYmIGVsLnN0eWxlLmxlZnQpO1xuICAgICAgICB9KS5sZW5ndGggOiAwXG4gICAgICB9O1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpub2RlU291cmNlc1wiLCBkZWJ1Z0NvdW50cyk7XG5cbiAgICAgIGlmIChNU0xfVkVSQk9TRSkge1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVzQWxsOnJhd1wiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHRvdGFsOiBub2Rlc0FsbC5sZW5ndGgsXG4gICAgICAgICAgbm9kZXM6IG5vZGVzQWxsLm1hcChmdW5jdGlvbihuLCBpKXtcbiAgICAgICAgICAgIHZhciBjbHMgPSAobi5jbGFzc05hbWUgJiYgdHlwZW9mIG4uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiKSA/IG4uY2xhc3NOYW1lIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDbHMgPSAobi5wYXJlbnRFbGVtZW50ICYmIG4ucGFyZW50RWxlbWVudC5jbGFzc05hbWUgJiYgdHlwZW9mIG4ucGFyZW50RWxlbWVudC5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgID8gbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICB0YWc6IChuLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgY2xzOiBjbHMsXG4gICAgICAgICAgICAgIHBhcmVudENsczogcGFyZW50Q2xzLFxuICAgICAgICAgICAgICB0b3A6IG4uc3R5bGUgPyBuLnN0eWxlLnRvcCA6IFwiXCIsXG4gICAgICAgICAgICAgIGxlZnQ6IG4uc3R5bGUgPyBuLnN0eWxlLmxlZnQgOiBcIlwiLFxuICAgICAgICAgICAgICBwb3M6IG4uc3R5bGUgPyBuLnN0eWxlLnBvc2l0aW9uIDogXCJcIixcbiAgICAgICAgICAgICAgdGV4dDogKChuLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkuc2xpY2UoMCwgNDApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBmbGF0ID0gbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG4sIGkpe1xuICAgICAgICAgICAgdmFyIGNscyA9IChuLmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbi5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIHR4dCA9ICgobi50ZXh0Q29udGVudCB8fCBcIlwiKS50cmltKCkpLnJlcGxhY2UoL1xcXFxzKy9nLCBcIiBcIikuc2xpY2UoMCwgNjApO1xuICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgaVxuICAgICAgICAgICAgICArIFwiIHRhZz1cIiArIFN0cmluZygobi50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICsgXCIgY2xzPVwiICsgY2xzXG4gICAgICAgICAgICAgICsgXCIgcG9zPVwiICsgKG4uc3R5bGUgPyBuLnN0eWxlLnBvc2l0aW9uIDogXCJcIilcbiAgICAgICAgICAgICAgKyBcIiB0b3A9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUudG9wIDogXCJcIilcbiAgICAgICAgICAgICAgKyBcIiBsZWZ0PVwiICsgKG4uc3R5bGUgPyBuLnN0eWxlLmxlZnQgOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIHRleHQ9XCIgKyB0eHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbXNsTG9nKFwic2VjdGlvbjpub2Rlc0FsbDpmbGF0XCIsIFwic2VjPVwiICsgc2VjSW5kZXggKyBcIiB0b3RhbD1cIiArIG5vZGVzQWxsLmxlbmd0aCArIFwiIDo6IFwiICsgZmxhdC5qb2luKFwiIHwgXCIpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgdmFyIHJlc3RvcmVkQ291bnQgPSAwO1xuICAgICAgbm9kZXNBbGwuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgcmVzdG9yZWRDb3VudCArPSByZXN0b3JlTm9kZUJhc2VsaW5lKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmJhc2VsaW5lUmVzdG9yZVwiLCB7IHNlY0luZGV4OiBzZWNJbmRleCwgbm9kZXM6IG5vZGVzQWxsLmxlbmd0aCwgcmVzdG9yZWQ6IHJlc3RvcmVkQ291bnQgfSk7XG5cbiAgICAgIC8vIFJlY3QgZGVsIGNvbnRlbnQgKG3DqXRyaWNhcyByZWFsZXMpXG4gICAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNvbnRlbnRXID0gY29udGVudFJlY3Qud2lkdGggfHwgMDtcbiAgICAgIHZhciBzZWNDdXJyZW50SCA9IHNlYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgMDtcbiAgICAgIHZhciBiYXNlSGVpZ2h0QXR0ciA9IFwiZGF0YS1tc2wtYmFzZS1oZWlnaHRcIjtcbiAgICAgIGlmICghc2VjLmhhc0F0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0cikpIHtcbiAgICAgICAgc2VjLnNldEF0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0ciwgU3RyaW5nKHNlY0N1cnJlbnRIKSk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVNlY0hlaWdodCA9IHBhcnNlRmxvYXQoc2VjLmdldEF0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0cikgfHwgXCJcIik7XG4gICAgICBpZiAoIWlzRmluaXRlKGJhc2VTZWNIZWlnaHQpIHx8IGJhc2VTZWNIZWlnaHQgPD0gMCkgYmFzZVNlY0hlaWdodCA9IHNlY0N1cnJlbnRIO1xuXHJcbiAgICAgIC8vIGl0ZW1zIChyZWN0cykgZW4gY29vcmRlbmFkYXMgZGVsIGNvbnRlbnQgKFRPRE9TKVxyXG4gICAgICB2YXIgaXRlbXNBbGwgPSBub2Rlc0FsbC5tYXAoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIHZhciByYyA9IHJlbFJlY3Qobm9kZSwgY29udGVudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICB0b3A6IHJjLnRvcCxcbiAgICAgICAgICBsZWZ0OiByYy5sZWZ0LFxyXG4gICAgICAgICAgaGVpZ2h0OiByYy5oZWlnaHQsXHJcbiAgICAgICAgICB3aWR0aDogcmMud2lkdGhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgYnVpbGRSZWZsb3dFbGVtZW50c0R1bXAoaXRlbXNBbGwsIGNvbnRlbnRXKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246cmVmbG93OmVsZW1lbnRzXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBzZWNNb2RvOiBzZWNNb2RvLFxuICAgICAgICBjb250ZW50VzogK051bWJlcihjb250ZW50VyB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICB0b3RhbDogcmVmbG93RWxlbWVudHNEdW1wLmxlbmd0aCxcbiAgICAgICAgZWxlbWVudHM6IHJlZmxvd0VsZW1lbnRzRHVtcFxuICAgICAgfSk7XG4gICAgICBpZiAoTVNMX1ZFUkJPU0UpIHtcbiAgICAgICAgbXNsTG9nKFwic2VjdGlvbjppdGVtc0FsbFwiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHRvdGFsOiBpdGVtc0FsbC5sZW5ndGgsXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zQWxsLm1hcChmdW5jdGlvbihpdCwgaWR4KXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGk6IGlkeCxcbiAgICAgICAgICAgICAga2luZDogKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIgPyBcInRleHRvXCIgOiAoaXQubm9kZS50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIHRvcDogK2l0LnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBsZWZ0OiAraXQubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICB3OiAraXQud2lkdGgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgaDogK2l0LmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICB0ZXh0QWxpZ246IChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSA/IGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduIDogXCJcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlc2VydmFyIGVsIFwiYWlyZVwiIGluZmVyaW9yIG9yaWdpbmFsIGRlIGxhIHNlY2Npb24gdHJhcyBlbCByZWZsb3cuXG4gICAgICB2YXIgbWF4T3JpZ2luYWxCb3R0b20gPSAwO1xuICAgICAgZm9yICh2YXIgaWI9MDsgaWI8aXRlbXNBbGwubGVuZ3RoOyBpYisrKXtcbiAgICAgICAgdmFyIGl0YiA9IGl0ZW1zQWxsW2liXTtcbiAgICAgICAgdmFyIGJ0bSA9IChpdGIudG9wIHx8IDApICsgKGl0Yi5oZWlnaHQgfHwgMCk7XG4gICAgICAgIGlmIChidG0gPiBtYXhPcmlnaW5hbEJvdHRvbSkgbWF4T3JpZ2luYWxCb3R0b20gPSBidG07XG4gICAgICB9XG4gICAgICB2YXIgYmFzZUJvdHRvbUdhcCA9IE1hdGgubWF4KDAsIGJhc2VTZWNIZWlnaHQgLSBtYXhPcmlnaW5hbEJvdHRvbSk7XG5cbiAgICAgIC8vIFNpIHRvZG8gbWlkZSAwIChmb250cyBubyBsaXN0YXMpLCByZWludGVudGFtb3MgbHVlZ29cbiAgICAgIHZhciBhbnlWYWxpZEFsbCA9IGl0ZW1zQWxsLnNvbWUoZnVuY3Rpb24oaXQpeyByZXR1cm4gaXQuaGVpZ2h0ID4gMC41OyB9KTtcbiAgICAgIGlmKCFhbnlWYWxpZEFsbCkge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6aW52YWxpZFJlY3RzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGFsbEhlaWdodHNUaW55OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbGxvd1JlZmxvdyB8fCBub2Rlc0FsbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpub3RFbGlnaWJsZVwiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3csXG4gICAgICAgICAgdG90YWxOb2Rlczogbm9kZXNBbGwubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0SGVyb0xpa2VDZW50cmFsVGV4dChpdGVtcywgcm9vdFcpe1xuICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgIGlzSGVybzogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIHRleHRDb3VudDogMCxcbiAgICAgICAgICB0ZXh0Q29sdW1uQ291bnQ6IDAsXG4gICAgICAgICAgdGV4dENvbHVtbnM6IFtdLFxuICAgICAgICAgIHNpbmdsZVRleHRDb2x1bW46IGZhbHNlLFxuICAgICAgICAgIG1heFRleHRXaWR0aFJhdGlvOiBudWxsLFxuICAgICAgICAgIHdpZHRoUmF0aW86IG51bGwsXG4gICAgICAgICAgY2VudGVyRGVsdGE6IG51bGwsXG4gICAgICAgICAgY2VudGVyVG9sOiBudWxsLFxuICAgICAgICAgIGNlbnRlcmVkQnlBbGlnbjogZmFsc2UsXG4gICAgICAgICAgY2VudGVyZWRCeUdlb21ldHJ5OiBmYWxzZSxcbiAgICAgICAgICBkZWNvck5lYXI6IDAsXG4gICAgICAgICAgZGVjb3JMZWZ0OiAwLFxuICAgICAgICAgIGRlY29yUmlnaHQ6IDAsXG4gICAgICAgICAgZGVjb3JJbnZhZGluZ1RleHRDb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9JdGVtc09yV2lkdGhcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICAgICAgaWYgKChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgIT09IFwiMVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgdmFyIHR3ID0gTnVtYmVyKGl0LndpZHRoIHx8IDApO1xuICAgICAgICAgIHZhciB0aCA9IE51bWJlcihpdC5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgcmV0dXJuIHR3ID4gMiAmJiB0aCA+IDI7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXQudGV4dENvdW50ID0gdGV4dEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0ZXh0SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9UZXh0XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBsaWNpdEhlcm8gPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZWg9MDsgZWg8dGV4dEl0ZW1zLmxlbmd0aDsgZWgrKyl7XG4gICAgICAgICAgdmFyIHJvbGVFaCA9ICh0ZXh0SXRlbXNbZWhdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChyb2xlRWggPT09IFwiaGVyb1wiKSB7XG4gICAgICAgICAgICBleHBsaWNpdEhlcm8gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbFRvbCA9IE1hdGgubWF4KDE4LCByb290VyAqIDAuMTQpO1xuICAgICAgICB2YXIgdGV4dENvbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdGM9MDsgdGM8dGV4dEl0ZW1zLmxlbmd0aDsgdGMrKyl7XG4gICAgICAgICAgdmFyIHR4dCA9IHRleHRJdGVtc1t0Y107XG4gICAgICAgICAgdmFyIHR4dEN4ID0gTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgdmFyIGF0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgY2M9MDsgY2M8dGV4dENvbHMubGVuZ3RoOyBjYysrKXtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0eHRDeCAtIHRleHRDb2xzW2NjXS5jeCkgPD0gY29sVG9sKSB7XG4gICAgICAgICAgICAgIHZhciBuQ29sID0gdGV4dENvbHNbY2NdLmNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLmN4ID0gKCh0ZXh0Q29sc1tjY10uY3ggKiB0ZXh0Q29sc1tjY10uY291bnQpICsgdHh0Q3gpIC8gbkNvbDtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLmNvdW50ID0gbkNvbDtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1pbkxlZnQgPSBNYXRoLm1pbih0ZXh0Q29sc1tjY10ubWluTGVmdCwgTnVtYmVyKHR4dC5sZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1heFJpZ2h0ID0gTWF0aC5tYXgodGV4dENvbHNbY2NdLm1heFJpZ2h0LCBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1pblRvcCA9IE1hdGgubWluKHRleHRDb2xzW2NjXS5taW5Ub3AsIE51bWJlcih0eHQudG9wIHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1heEJvdHRvbSA9IE1hdGgubWF4KHRleHRDb2xzW2NjXS5tYXhCb3R0b20sIE51bWJlcih0eHQudG9wIHx8IDApICsgTnVtYmVyKHR4dC5oZWlnaHQgfHwgMCkpO1xuICAgICAgICAgICAgICBhdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0ZXh0Q29scy5wdXNoKHtcbiAgICAgICAgICAgICAgY3g6IHR4dEN4LFxuICAgICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgICAgbWluTGVmdDogTnVtYmVyKHR4dC5sZWZ0IHx8IDApLFxuICAgICAgICAgICAgICBtYXhSaWdodDogTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSxcbiAgICAgICAgICAgICAgbWluVG9wOiBOdW1iZXIodHh0LnRvcCB8fCAwKSxcbiAgICAgICAgICAgICAgbWF4Qm90dG9tOiBOdW1iZXIodHh0LnRvcCB8fCAwKSArIE51bWJlcih0eHQuaGVpZ2h0IHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGV4dENvbHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5jeCAtIGIuY3g7IH0pO1xuICAgICAgICBvdXQudGV4dENvbHVtbkNvdW50ID0gdGV4dENvbHMubGVuZ3RoO1xuICAgICAgICBvdXQuc2luZ2xlVGV4dENvbHVtbiA9IHRleHRDb2xzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgb3V0LnRleHRDb2x1bW5zID0gdGV4dENvbHMubWFwKGZ1bmN0aW9uKGNvbCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiArTnVtYmVyKGNvbC5jeCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgY291bnQ6IGNvbC5jb3VudCxcbiAgICAgICAgICAgIGxlZnQ6ICtOdW1iZXIoY29sLm1pbkxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHJpZ2h0OiArTnVtYmVyKGNvbC5tYXhSaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdG9wOiArTnVtYmVyKGNvbC5taW5Ub3AgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGJvdHRvbTogK051bWJlcihjb2wubWF4Qm90dG9tIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvdXQuc2luZ2xlVGV4dENvbHVtbikge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBleHBsaWNpdEhlcm8gPyBcImV4cGxpY2l0SGVyb1JvbGVcIiA6IFwibXVsdGlUZXh0Q29sdW1uc1wiO1xuICAgICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm87XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZW50ZXJYID0gcm9vdFcgLyAyO1xuICAgICAgICB2YXIgdGV4dENvbCA9IHRleHRDb2xzWzBdO1xuICAgICAgICB2YXIgdGV4dENlbnRlclggPSBOdW1iZXIodGV4dENvbC5jeCB8fCBjZW50ZXJYKTtcbiAgICAgICAgdmFyIGNlbnRlckRlbHRhID0gTWF0aC5hYnModGV4dENlbnRlclggLSBjZW50ZXJYKTtcbiAgICAgICAgdmFyIGNlbnRlclRvbCA9IE1hdGgubWF4KDE4LCByb290VyAqIDAuMTIpO1xuICAgICAgICBvdXQuY2VudGVyRGVsdGEgPSArY2VudGVyRGVsdGEudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LmNlbnRlclRvbCA9ICtjZW50ZXJUb2wudG9GaXhlZCgxKTtcblxuICAgICAgICB2YXIgY2VudGVyZWRBbGlnbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIG1heFRleHRXaWR0aFJhdGlvID0gMDtcbiAgICAgICAgdmFyIHRleHRUb3AgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHRleHRCb3R0b20gPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIHRpeD0wOyB0aXg8dGV4dEl0ZW1zLmxlbmd0aDsgdGl4Kyspe1xuICAgICAgICAgIHZhciB0ID0gdGV4dEl0ZW1zW3RpeF07XG4gICAgICAgICAgdmFyIHRhID0gKHQubm9kZSAmJiB0Lm5vZGUuc3R5bGUgJiYgdC5ub2RlLnN0eWxlLnRleHRBbGlnbilcbiAgICAgICAgICAgID8gU3RyaW5nKHQubm9kZS5zdHlsZS50ZXh0QWxpZ24pLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICBpZiAodGEgPT09IFwiY2VudGVyXCIpIGNlbnRlcmVkQWxpZ25Db3VudCsrO1xuICAgICAgICAgIHZhciB3UmF0aW8gPSBOdW1iZXIodC53aWR0aCB8fCAwKSAvIE1hdGgubWF4KDEsIHJvb3RXKTtcbiAgICAgICAgICBpZiAod1JhdGlvID4gbWF4VGV4dFdpZHRoUmF0aW8pIG1heFRleHRXaWR0aFJhdGlvID0gd1JhdGlvO1xuICAgICAgICAgIHRleHRUb3AgPSBNYXRoLm1pbih0ZXh0VG9wLCBOdW1iZXIodC50b3AgfHwgMCkpO1xuICAgICAgICAgIHRleHRCb3R0b20gPSBNYXRoLm1heCh0ZXh0Qm90dG9tLCBOdW1iZXIodC50b3AgfHwgMCkgKyBOdW1iZXIodC5oZWlnaHQgfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIG91dC5tYXhUZXh0V2lkdGhSYXRpbyA9ICttYXhUZXh0V2lkdGhSYXRpby50b0ZpeGVkKDMpO1xuICAgICAgICBvdXQud2lkdGhSYXRpbyA9IG91dC5tYXhUZXh0V2lkdGhSYXRpbztcbiAgICAgICAgb3V0LmNlbnRlcmVkQnlBbGlnbiA9IGNlbnRlcmVkQWxpZ25Db3VudCA+PSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGV4dEl0ZW1zLmxlbmd0aCAqIDAuNSkpO1xuICAgICAgICBvdXQuY2VudGVyZWRCeUdlb21ldHJ5ID0gY2VudGVyRGVsdGEgPD0gY2VudGVyVG9sO1xuICAgICAgICBpZiAoIW91dC5jZW50ZXJlZEJ5QWxpZ24gJiYgIW91dC5jZW50ZXJlZEJ5R2VvbWV0cnkpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gZXhwbGljaXRIZXJvID8gXCJleHBsaWNpdEhlcm9Sb2xlXCIgOiBcInNpbmdsZVRleHRDb2x1bW5Ob3RDZW50ZXJlZFwiO1xuICAgICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm87XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2aXRhIG1hcmNhciBjb21vIGhlcm8gdGV4dG9zIHN1ZWx0b3MgbXV5IGNoaWNvcy5cbiAgICAgICAgaWYgKHRleHRJdGVtcy5sZW5ndGggPCAyICYmIG1heFRleHRXaWR0aFJhdGlvIDwgMC4yOCAmJiAhZXhwbGljaXRIZXJvKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwidGV4dFRvb1NtYWxsXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNGaW5pdGUodGV4dFRvcCkgfHwgIWlzRmluaXRlKHRleHRCb3R0b20pIHx8IHRleHRCb3R0b20gPD0gdGV4dFRvcCkge1xuICAgICAgICAgIHRleHRUb3AgPSAwO1xuICAgICAgICAgIHRleHRCb3R0b20gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyVG9wID0gdGV4dFRvcCAtIE1hdGgubWF4KDI4LCAodGV4dEJvdHRvbSAtIHRleHRUb3ApICogMC4yKTtcbiAgICAgICAgdmFyIG5lYXJCb3R0b20gPSB0ZXh0Qm90dG9tICsgTWF0aC5tYXgoMzYsICh0ZXh0Qm90dG9tIC0gdGV4dFRvcCkgKiAwLjM1KTtcbiAgICAgICAgdmFyIGludmFkZVBhZCA9IE1hdGgubWF4KDI0LCByb290VyAqIDAuMTcpO1xuICAgICAgICB2YXIgaW52YWRlTGVmdCA9IHRleHRDZW50ZXJYIC0gaW52YWRlUGFkO1xuICAgICAgICB2YXIgaW52YWRlUmlnaHQgPSB0ZXh0Q2VudGVyWCArIGludmFkZVBhZDtcblxuICAgICAgICB2YXIgZGVjb3JOZWFyID0gMDtcbiAgICAgICAgdmFyIGRlY29yTGVmdCA9IDA7XG4gICAgICAgIHZhciBkZWNvclJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGRlY29ySW52YWRpbmcgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlIZXJvPTA7IGlIZXJvPGl0ZW1zLmxlbmd0aDsgaUhlcm8rKyl7XG4gICAgICAgICAgdmFyIGl0ID0gaXRlbXNbaUhlcm9dO1xuICAgICAgICAgIGlmICgoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgY29udGludWU7XG5cbiAgICAgICAgICB2YXIgdyA9IE51bWJlcihpdC53aWR0aCB8fCAwKTtcbiAgICAgICAgICB2YXIgaCA9IE51bWJlcihpdC5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgaWYgKHcgPCA4IHx8IGggPCA4KSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciB0b3AgPSBOdW1iZXIoaXQudG9wIHx8IDApO1xuICAgICAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoO1xuICAgICAgICAgIHZhciBpbkJhbmQgPSAhKGJvdHRvbSA8IG5lYXJUb3AgfHwgdG9wID4gbmVhckJvdHRvbSk7XG4gICAgICAgICAgaWYgKCFpbkJhbmQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZGVjb3JOZWFyKys7XG4gICAgICAgICAgdmFyIGN4ID0gTnVtYmVyKGl0LmxlZnQgfHwgMCkgKyB3IC8gMjtcbiAgICAgICAgICBpZiAoY3ggPCB0ZXh0Q2VudGVyWCAtIDgpIGRlY29yTGVmdCsrO1xuICAgICAgICAgIGVsc2UgaWYgKGN4ID4gdGV4dENlbnRlclggKyA4KSBkZWNvclJpZ2h0Kys7XG5cbiAgICAgICAgICB2YXIgbGVmdCA9IE51bWJlcihpdC5sZWZ0IHx8IDApO1xuICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3O1xuICAgICAgICAgIGlmIChyaWdodCA+IGludmFkZUxlZnQgJiYgbGVmdCA8IGludmFkZVJpZ2h0KSBkZWNvckludmFkaW5nKys7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQuZGVjb3JOZWFyID0gZGVjb3JOZWFyO1xuICAgICAgICBvdXQuZGVjb3JMZWZ0ID0gZGVjb3JMZWZ0O1xuICAgICAgICBvdXQuZGVjb3JSaWdodCA9IGRlY29yUmlnaHQ7XG4gICAgICAgIG91dC5kZWNvckludmFkaW5nVGV4dENvbHVtbiA9IGRlY29ySW52YWRpbmc7XG5cbiAgICAgICAgdmFyIGRlY29yQXJvdW5kID0gKGRlY29yTGVmdCA+IDAgJiYgZGVjb3JSaWdodCA+IDApIHx8IGRlY29yTmVhciA+PSAzO1xuICAgICAgICB2YXIgY2VudGVyZWRTaW5nbGVUZXh0Q29sdW1uID0gb3V0LnNpbmdsZVRleHRDb2x1bW4gJiYgKG91dC5jZW50ZXJlZEJ5QWxpZ24gfHwgb3V0LmNlbnRlcmVkQnlHZW9tZXRyeSk7XG4gICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm8gfHwgY2VudGVyZWRTaW5nbGVUZXh0Q29sdW1uO1xuICAgICAgICBvdXQucmVhc29uID0gb3V0LmlzSGVyb1xuICAgICAgICAgID8gKFxuICAgICAgICAgICAgZXhwbGljaXRIZXJvXG4gICAgICAgICAgICAgID8gXCJleHBsaWNpdEhlcm9Sb2xlXCJcbiAgICAgICAgICAgICAgOiAoZGVjb3JJbnZhZGluZyA+IDBcbiAgICAgICAgICAgICAgICA/IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uRGVjb3JJbnZhZGVzXCJcbiAgICAgICAgICAgICAgICA6IChkZWNvckFyb3VuZFxuICAgICAgICAgICAgICAgICAgPyBcInNpbmdsZUNlbnRlcmVkVGV4dENvbHVtbldpdGhEZWNvclwiXG4gICAgICAgICAgICAgICAgICA6IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uXCIpKVxuICAgICAgICAgIClcbiAgICAgICAgICA6IFwibm9IZXJvU2lnbmFsXCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGVjdElubGluZVBhaXJOb1JlZmxvdyhmbG93SXRlbXMsIGFsbEl0ZW1zLCByb290VywgQ0ZHKXtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICBza2lwOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgdG90YWxGbG93OiBmbG93SXRlbXMgPyBmbG93SXRlbXMubGVuZ3RoIDogMCxcbiAgICAgICAgICB0b3RhbEFsbDogYWxsSXRlbXMgPyBhbGxJdGVtcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJvd0RlbHRhOiBudWxsLFxuICAgICAgICAgIHJvd1RvbDogbnVsbCxcbiAgICAgICAgICBwYWlyU3BhbjogbnVsbCxcbiAgICAgICAgICBwYWlyU3BhblJhdGlvOiBudWxsLFxuICAgICAgICAgIGZpdHNUb2dldGhlcjogZmFsc2UsXG4gICAgICAgICAgYm90aFNtYWxsOiBmYWxzZSxcbiAgICAgICAgICBzbWFsbFdMaW1pdDogbnVsbCxcbiAgICAgICAgICBzbWFsbEhMaW1pdDogbnVsbCxcbiAgICAgICAgICB3aWR0aHM6IFtdLFxuICAgICAgICAgIGhlaWdodHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZmxvd0l0ZW1zIHx8IGZsb3dJdGVtcy5sZW5ndGggIT09IDIgfHwgIWFsbEl0ZW1zIHx8IGFsbEl0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vdEV4YWN0UGFpclwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGZsb3dJdGVtc1swXTtcbiAgICAgICAgdmFyIGIgPSBmbG93SXRlbXNbMV07XG4gICAgICAgIHZhciBhVyA9IE1hdGgubWF4KDAsIE51bWJlcihhLndpZHRoIHx8IDApKTtcbiAgICAgICAgdmFyIGJXID0gTWF0aC5tYXgoMCwgTnVtYmVyKGIud2lkdGggfHwgMCkpO1xuICAgICAgICB2YXIgYUggPSBNYXRoLm1heCgwLCBOdW1iZXIoYS5oZWlnaHQgfHwgMCkpO1xuICAgICAgICB2YXIgYkggPSBNYXRoLm1heCgwLCBOdW1iZXIoYi5oZWlnaHQgfHwgMCkpO1xuICAgICAgICBvdXQud2lkdGhzID0gWythVy50b0ZpeGVkKDEpLCArYlcudG9GaXhlZCgxKV07XG4gICAgICAgIG91dC5oZWlnaHRzID0gWythSC50b0ZpeGVkKDEpLCArYkgudG9GaXhlZCgxKV07XG5cbiAgICAgICAgaWYgKGFXIDwgMiB8fCBiVyA8IDIgfHwgYUggPCAyIHx8IGJIIDwgMikge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcImludmFsaWRTaXplc1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93VG9sID0gTWF0aC5tYXgoMTIsIE51bWJlcigoQ0ZHICYmIENGRy5ST1dfVE9MKSB8fCAyOCkgKiAxLjIpO1xuICAgICAgICB2YXIgcm93RGVsdGEgPSBNYXRoLmFicyhOdW1iZXIoYS50b3AgfHwgMCkgLSBOdW1iZXIoYi50b3AgfHwgMCkpO1xuICAgICAgICBvdXQucm93VG9sID0gK3Jvd1RvbC50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQucm93RGVsdGEgPSArcm93RGVsdGEudG9GaXhlZCgxKTtcbiAgICAgICAgaWYgKHJvd0RlbHRhID4gcm93VG9sKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90SW5saW5lUm93XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzbWFsbFdMaW1pdCA9IE1hdGgubWF4KDc0LCByb290VyAqIDAuNDIpO1xuICAgICAgICB2YXIgc21hbGxITGltaXQgPSBNYXRoLm1heCgzNCwgcm9vdFcgKiAwLjIpO1xuICAgICAgICBvdXQuc21hbGxXTGltaXQgPSArc21hbGxXTGltaXQudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LnNtYWxsSExpbWl0ID0gK3NtYWxsSExpbWl0LnRvRml4ZWQoMSk7XG4gICAgICAgIHZhciBib3RoU21hbGwgPVxuICAgICAgICAgIGFXIDw9IHNtYWxsV0xpbWl0ICYmXG4gICAgICAgICAgYlcgPD0gc21hbGxXTGltaXQgJiZcbiAgICAgICAgICBhSCA8PSBzbWFsbEhMaW1pdCAmJlxuICAgICAgICAgIGJIIDw9IHNtYWxsSExpbWl0O1xuICAgICAgICBvdXQuYm90aFNtYWxsID0gYm90aFNtYWxsO1xuICAgICAgICBpZiAoIWJvdGhTbWFsbCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcInBhaXJOb3RTbWFsbFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFpckxlZnQgPSBNYXRoLm1pbihOdW1iZXIoYS5sZWZ0IHx8IDApLCBOdW1iZXIoYi5sZWZ0IHx8IDApKTtcbiAgICAgICAgdmFyIHBhaXJSaWdodCA9IE1hdGgubWF4KE51bWJlcihhLmxlZnQgfHwgMCkgKyBhVywgTnVtYmVyKGIubGVmdCB8fCAwKSArIGJXKTtcbiAgICAgICAgdmFyIHBhaXJTcGFuID0gTWF0aC5tYXgoMCwgcGFpclJpZ2h0IC0gcGFpckxlZnQpO1xuICAgICAgICB2YXIgZml0c1RvZ2V0aGVyID0gcGFpclNwYW4gPD0gKHJvb3RXICsgMSk7XG4gICAgICAgIG91dC5wYWlyU3BhbiA9ICtwYWlyU3Bhbi50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQucGFpclNwYW5SYXRpbyA9ICsocGFpclNwYW4gLyBNYXRoLm1heCgxLCByb290VykpLnRvRml4ZWQoMyk7XG4gICAgICAgIG91dC5maXRzVG9nZXRoZXIgPSBmaXRzVG9nZXRoZXI7XG5cbiAgICAgICAgaWYgKGZpdHNUb2dldGhlcikge1xuICAgICAgICAgIG91dC5za2lwID0gdHJ1ZTtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJzbWFsbElubGluZVBhaXJGaXRzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5yZWFzb24gPSBcInNtYWxsSW5saW5lUGFpck92ZXJmbG93XCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuZm9yY2VJbmxpbmVQYWlyR2FwKGZsb3dJdGVtcywgcm9vdEVsLCByb290Vyl7XG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgYXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIG1pbkdhcDogNixcbiAgICAgICAgICBnYXBCZWZvcmU6IG51bGwsXG4gICAgICAgICAgZ2FwQWZ0ZXI6IG51bGwsXG4gICAgICAgICAgbmVlZDogbnVsbCxcbiAgICAgICAgICBtb3ZlTGVmdDogMCxcbiAgICAgICAgICBtb3ZlUmlnaHQ6IDAsXG4gICAgICAgICAgb3ZlcmZsb3dCZWZvcmU6IGZhbHNlLFxuICAgICAgICAgIG92ZXJmbG93QWZ0ZXI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciByb290UGFkTGVmdCA9IDA7XG4gICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICB2YXIgcm9vdENTID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWwpO1xuICAgICAgICAgIHJvb3RQYWRMZWZ0ID0gcGFyc2VGbG9hdChyb290Q1MucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG93SXRlbXMgfHwgZmxvd0l0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhcm9vdEVsIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90RXhhY3RQYWlyXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gZmxvd0l0ZW1zWzBdO1xuICAgICAgICB2YXIgYiA9IGZsb3dJdGVtc1sxXTtcbiAgICAgICAgaWYgKCFhIHx8ICFiIHx8ICFhLm5vZGUgfHwgIWIubm9kZSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm1pc3NpbmdOb2Rlc1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdEl0ZW0gPSBOdW1iZXIoYS5sZWZ0IHx8IDApIDw9IE51bWJlcihiLmxlZnQgfHwgMCkgPyBhIDogYjtcbiAgICAgICAgdmFyIHJpZ2h0SXRlbSA9IChsZWZ0SXRlbSA9PT0gYSkgPyBiIDogYTtcblxuICAgICAgICB2YXIgcnJMID0gcmVsUmVjdChsZWZ0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgcnJSID0gcmVsUmVjdChyaWdodEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIGxMZWZ0ID0gTnVtYmVyKHJyTC5sZWZ0IHx8IDApO1xuICAgICAgICB2YXIgbFcgPSBOdW1iZXIocnJMLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgckxlZnQgPSBOdW1iZXIocnJSLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciByVyA9IE51bWJlcihyclIud2lkdGggfHwgMCk7XG4gICAgICAgIGlmICghaXNGaW5pdGUobExlZnQpIHx8ICFpc0Zpbml0ZShsVykgfHwgIWlzRmluaXRlKHJMZWZ0KSB8fCAhaXNGaW5pdGUoclcpKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiaW52YWxpZFJlY3RzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnYXBCZWZvcmUgPSByTGVmdCAtIChsTGVmdCArIGxXKTtcbiAgICAgICAgb3V0LmdhcEJlZm9yZSA9ICtnYXBCZWZvcmUudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0Lm92ZXJmbG93QmVmb3JlID0gKGxMZWZ0IDwgLTAuNSkgfHwgKChyTGVmdCArIHJXKSA+IChyb290VyArIDAuNSkpO1xuXG4gICAgICAgIHZhciBuZWVkID0gTWF0aC5tYXgoMCwgb3V0Lm1pbkdhcCAtIGdhcEJlZm9yZSk7XG4gICAgICAgIG91dC5uZWVkID0gK25lZWQudG9GaXhlZCgyKTtcbiAgICAgICAgaWYgKG5lZWQgPD0gMC4yNSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcImFscmVhZHlTcGFjZWRcIjtcbiAgICAgICAgICBvdXQuZ2FwQWZ0ZXIgPSBvdXQuZ2FwQmVmb3JlO1xuICAgICAgICAgIG91dC5vdmVyZmxvd0FmdGVyID0gb3V0Lm92ZXJmbG93QmVmb3JlO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXZhaWxSaWdodCA9IE1hdGgubWF4KDAsIHJvb3RXIC0gKHJMZWZ0ICsgclcpKTtcbiAgICAgICAgdmFyIGF2YWlsTGVmdCA9IE1hdGgubWF4KDAsIGxMZWZ0KTtcbiAgICAgICAgdmFyIG1vdmVSaWdodCA9IE1hdGgubWluKGF2YWlsUmlnaHQsIG5lZWQpO1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gTWF0aC5tYXgoMCwgbmVlZCAtIG1vdmVSaWdodCk7XG4gICAgICAgIHZhciBtb3ZlTGVmdCA9IE1hdGgubWluKGF2YWlsTGVmdCwgcmVtYWluaW5nKTtcblxuICAgICAgICBpZiAobW92ZVJpZ2h0IDw9IDAuMDEgJiYgbW92ZUxlZnQgPD0gMC4wMSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vUm9vbVRvQWRqdXN0XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3ZlUmlnaHQgPiAwLjAxKSB7XG4gICAgICAgICAgcmlnaHRJdGVtLm5vZGUuc3R5bGUubGVmdCA9ICgoTnVtYmVyKHJpZ2h0SXRlbS5sZWZ0IHx8IDApICsgbW92ZVJpZ2h0KSAtIHJvb3RQYWRMZWZ0KSArIFwicHhcIjtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHJpZ2h0SXRlbS5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlTGVmdCA+IDAuMDEpIHtcbiAgICAgICAgICBsZWZ0SXRlbS5ub2RlLnN0eWxlLmxlZnQgPSAoKE51bWJlcihsZWZ0SXRlbS5sZWZ0IHx8IDApIC0gbW92ZUxlZnQpIC0gcm9vdFBhZExlZnQpICsgXCJweFwiO1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICBsZWZ0SXRlbS5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJyTDIgPSByZWxSZWN0KGxlZnRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciByclIyID0gcmVsUmVjdChyaWdodEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIGxMZWZ0MiA9IE51bWJlcihyckwyLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciBsVzIgPSBOdW1iZXIocnJMMi53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIHJMZWZ0MiA9IE51bWJlcihyclIyLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciByVzIgPSBOdW1iZXIocnJSMi53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIGdhcEFmdGVyID0gckxlZnQyIC0gKGxMZWZ0MiArIGxXMik7XG5cbiAgICAgICAgb3V0Lm1vdmVSaWdodCA9ICttb3ZlUmlnaHQudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0Lm1vdmVMZWZ0ID0gK21vdmVMZWZ0LnRvRml4ZWQoMik7XG4gICAgICAgIG91dC5nYXBBZnRlciA9IGlzRmluaXRlKGdhcEFmdGVyKSA/ICtnYXBBZnRlci50b0ZpeGVkKDIpIDogbnVsbDtcbiAgICAgICAgb3V0Lm92ZXJmbG93QWZ0ZXIgPSAobExlZnQyIDwgLTAuNSkgfHwgKChyTGVmdDIgKyByVzIpID4gKHJvb3RXICsgMC41KSk7XG4gICAgICAgIG91dC5hcHBsaWVkID0gKG1vdmVSaWdodCA+IDAuMDEgfHwgbW92ZUxlZnQgPiAwLjAxKTtcbiAgICAgICAgb3V0LnJlYXNvbiA9IG91dC5hcHBsaWVkID8gXCJhcHBsaWVkXCIgOiBcIm5vQ2hhbmdlXCI7XG4gICAgICAgIGlmIChpc0Zpbml0ZShnYXBBZnRlcikgJiYgZ2FwQWZ0ZXIgPCAtMC4yKSBvdXQucmVhc29uID0gXCJhcHBsaWVkQnV0U3RpbGxPdmVybGFwXCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taW5lbnROb25UZXh0Q291bnQgPSBpdGVtc0FsbC5maWx0ZXIoZnVuY3Rpb24oaXQpe1xuICAgICAgICBpZiAoKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHcgPSBOdW1iZXIoaXQud2lkdGggfHwgMCk7XG4gICAgICAgIHZhciBoID0gTnVtYmVyKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKHcgPCA2IHx8IGggPCA2KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkubGVuZ3RoO1xuICAgICAgLy8gU2kgaGF5IGN1YWxxdWllciBuby10ZXh0byB2aXNpYmxlLCBldml0YW1vcyBhbmNsYXIgdGV4dG9zIHBvciBoZXVyaXN0aWNhLlxuICAgICAgLy8gRXN0byBpbXBpZGUgcXVlIHRleHRvcyBkZSB1bmEgY29sdW1uYSBxdWVkZW4gXCJjb25nZWxhZG9zXCIgZW4gbGVmdCBvcmlnaW5hbC5cbiAgICAgIHZhciBhbGxvd0hldXJpc3RpY0FuY2hvcnMgPSBwcm9taW5lbnROb25UZXh0Q291bnQgPT09IDA7XG5cbiAgICAgIC8vIOKchSBEZXRlcm1pbmFyIHF1w6kgbm9kb3Mgc29uIFwiQU5DSE9SXCIgKG5vIHNlIHJlZmxvd2VhbilcbiAgICAgIC8vIFJlZ2xhOiB0ZXh0byBjZW50cmFkbyArIGNhc2kgZnVsbC13aWR0aCA9PiB0w610dWxvL2hlcm8sIG5vIG1vdmVyLlxuICAgICAgZnVuY3Rpb24gaXNBbmNob3JOb2RlKGl0KXtcbiAgICAgICAgdmFyIG5vZGUgPSBpdC5ub2RlO1xuXHJcbiAgICAgICAgLy8gb3B0LW91dCBleHBsw61jaXRvXHJcbiAgICAgICAgdmFyIGtlZXBMYXlvdXQgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1sYXlvdXRcIikgfHwgXCJcIikgPT09IFwia2VlcFwiO1xyXG4gICAgICAgIGlmIChrZWVwTGF5b3V0KSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gYW5jaG9yIGV4cGzDrWNpdG8gKHNpIGxvIHVzw6FzKVxyXG4gICAgICAgIHZhciByb2xlID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiKTtcclxuICAgICAgICBpZiAocm9sZSA9PT0gXCJhbmNob3JcIikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIGhldXLDrXN0aWNhIHBhcmEgdGV4dG9zXG4gICAgICAgIHZhciBpc1RleHQgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgaWYgKCFpc1RleHQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhbGxvd0hldXJpc3RpY0FuY2hvcnMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgdGEgPSAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlLnRleHRBbGlnbikgPyBTdHJpbmcobm9kZS5zdHlsZS50ZXh0QWxpZ24pLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xuICAgICAgICBpZiAoIXRhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhID0gU3RyaW5nKGdldENvbXB1dGVkU3R5bGUobm9kZSkudGV4dEFsaWduIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfSBjYXRjaChfZSkge31cbiAgICAgICAgfVxuICAgICAgICBpZiAodGEgIT09IFwiY2VudGVyXCIpIHJldHVybiBmYWxzZTtcblxyXG4gICAgICAgIC8vIHNvbG8gc2kgcmVhbG1lbnRlIG9jdXBhIGNhc2kgdG9kbyBlbCBhbmNobyB1c2FibGVcclxuICAgICAgICAvLyAoZXN0byBldml0YSByb21wZXIgdGV4dG9zIGNlbnRyYWRvcyBkZW50cm8gZGUgY29sdW1uYXMpXHJcbiAgICAgICAgaWYgKGNvbnRlbnRXID4gMCAmJiBpdC53aWR0aCA+PSBjb250ZW50VyAqIDAuNzgpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIOKchSBGbG93ID0gdG9kbyBsbyBxdWUgTk8gZXMgYW5jaG9yXG4gICAgICB2YXIgaXRlbXNGbG93ID0gaXRlbXNBbGwuZmlsdGVyKGZ1bmN0aW9uKGl0KXsgcmV0dXJuICFpc0FuY2hvck5vZGUoaXQpOyB9KTtcbiAgICAgIHZhciBpdGVtc0FuY2hvciA9IGl0ZW1zQWxsLmZpbHRlcihmdW5jdGlvbihpdCl7IHJldHVybiBpc0FuY2hvck5vZGUoaXQpOyB9KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246YW5jaG9yU3BsaXRcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIGFuY2hvcnM6IGl0ZW1zQW5jaG9yLmxlbmd0aCxcbiAgICAgICAgZmxvdzogaXRlbXNGbG93Lmxlbmd0aCxcbiAgICAgICAgcHJvbWluZW50Tm9uVGV4dENvdW50OiBwcm9taW5lbnROb25UZXh0Q291bnQsXG4gICAgICAgIGFsbG93SGV1cmlzdGljQW5jaG9yczogYWxsb3dIZXVyaXN0aWNBbmNob3JzLFxuICAgICAgICBhbmNob3JzRGV0YWlsOiBpdGVtc0FuY2hvci5tYXAoZnVuY3Rpb24oaXQpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIiA/IFwidGV4dG9cIiA6IChpdC5ub2RlLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHRvcDogK2l0LnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgbGVmdDogK2l0LmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtpdC53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK2l0LmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAoaXQubm9kZS5zdHlsZSAmJiBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbikgPyBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbiA6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNpIG5vIGhheSBzdWZpY2llbnRlcyBlbGVtZW50b3MgcmVmbG93YWJsZXMsIG5vIGhhY2Vtb3MgbmFkYVxuICAgICAgaWYoaXRlbXNGbG93Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOmZsb3dUb29TbWFsbFwiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgICAgYW5jaG9yQ291bnQ6IGl0ZW1zQW5jaG9yLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cclxuICAgICAgLy8g4pyFIFBhcmEgcXVlIFwiYWx0dXJhIG5lY2VzYXJpYVwiIG5vIHF1ZWRlIGNvcnRhLFxyXG4gICAgICAvLyBtZWRpbW9zIGVsIGJvdHRvbSBtw6F4aW1vIGRlIGFuY2hvcnMgKGVuIGNvb3JkcyBkZWwgY29udGVudClcclxuICAgICAgdmFyIG1heEFuY2hvckJvdHRvbSA9IDA7XHJcbiAgICAgIGl0ZW1zQWxsLmZvckVhY2goZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIGlmICghaXNBbmNob3JOb2RlKGl0KSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBiID0gKGl0LnRvcCB8fCAwKSArIChpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgaWYgKGIgPiBtYXhBbmNob3JCb3R0b20pIG1heEFuY2hvckJvdHRvbSA9IGI7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8g4pyFIDEpIGFncnVwYXIgcG9yIHNvbGFwZSDihpIgY2x1c3RlcnMgKFNPTE8gRkxPVylcbiAgICAgIHZhciBjbHVzdGVycyA9IGJ1aWxkT3ZlcmxhcENsdXN0ZXJzKGl0ZW1zRmxvdyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmNsdXN0ZXJzXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjb3VudDogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubWFwKGZ1bmN0aW9uKGMsIGlkeCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGk6IGlkeCxcbiAgICAgICAgICAgIHRvcDogK2MudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiArYy5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3OiArYy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK2MuaGVpZ2h0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjeDogK2MuY3gudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGl0ZW1zOiBjLml0ZW1zLmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgLy8g4pyFIDIpIERldGVjdGFyIGNvbHVtbmFzL3Jvd3MgKFNPTE8gRkxPVylcbiAgICAgIHZhciByb290VyA9IGNvbnRlbnRXIHx8IDA7XG4gICAgICB2YXIgb3JkID0gb3JkZXJDbHVzdGVyc0Zvck1vYmlsZShjbHVzdGVycywgcm9vdFcsIENGRyk7XG4gICAgICB2YXIgZ3JvdXBzID0gb3JkLmdyb3VwcztcbiAgICAgIHZhciBtb2RlID0gb3JkLm1vZGU7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOm9yZGVyaW5nXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICByb290Vzogcm9vdFcsXG4gICAgICAgIGdyb3VwczogZ3JvdXBzLm1hcChmdW5jdGlvbihncnAsIGdpKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZzogZ2ksXG4gICAgICAgICAgICBjb3VudDogZ3JwLmxlbmd0aCxcbiAgICAgICAgICAgIHRvcHM6IGdycC5tYXAoZnVuY3Rpb24oYyl7IHJldHVybiArYy50b3AudG9GaXhlZCgxKTsgfSksXG4gICAgICAgICAgICBsZWZ0czogZ3JwLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLmxlZnQudG9GaXhlZCgxKTsgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBoZXJvU2lnbmFsID0gZGV0ZWN0SGVyb0xpa2VDZW50cmFsVGV4dChpdGVtc0FsbCwgcm9vdFcpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpoZXJvQ2hlY2tcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGlzSGVybzogaGVyb1NpZ25hbC5pc0hlcm8sXG4gICAgICAgIHJlYXNvbjogaGVyb1NpZ25hbC5yZWFzb24sXG4gICAgICAgIHRleHRDb3VudDogaGVyb1NpZ25hbC50ZXh0Q291bnQsXG4gICAgICAgIHRleHRDb2x1bW5Db3VudDogaGVyb1NpZ25hbC50ZXh0Q29sdW1uQ291bnQsXG4gICAgICAgIHNpbmdsZVRleHRDb2x1bW46IGhlcm9TaWduYWwuc2luZ2xlVGV4dENvbHVtbixcbiAgICAgICAgdGV4dENvbHVtbnM6IGhlcm9TaWduYWwudGV4dENvbHVtbnMsXG4gICAgICAgIG1heFRleHRXaWR0aFJhdGlvOiBoZXJvU2lnbmFsLm1heFRleHRXaWR0aFJhdGlvLFxuICAgICAgICB3aWR0aFJhdGlvOiBoZXJvU2lnbmFsLndpZHRoUmF0aW8sXG4gICAgICAgIGNlbnRlckRlbHRhOiBoZXJvU2lnbmFsLmNlbnRlckRlbHRhLFxuICAgICAgICBjZW50ZXJUb2w6IGhlcm9TaWduYWwuY2VudGVyVG9sLFxuICAgICAgICBjZW50ZXJlZEJ5QWxpZ246IGhlcm9TaWduYWwuY2VudGVyZWRCeUFsaWduLFxuICAgICAgICBjZW50ZXJlZEJ5R2VvbWV0cnk6IGhlcm9TaWduYWwuY2VudGVyZWRCeUdlb21ldHJ5LFxuICAgICAgICBkZWNvck5lYXI6IGhlcm9TaWduYWwuZGVjb3JOZWFyLFxuICAgICAgICBkZWNvckxlZnQ6IGhlcm9TaWduYWwuZGVjb3JMZWZ0LFxuICAgICAgICBkZWNvclJpZ2h0OiBoZXJvU2lnbmFsLmRlY29yUmlnaHQsXG4gICAgICAgIGRlY29ySW52YWRpbmdUZXh0Q29sdW1uOiBoZXJvU2lnbmFsLmRlY29ySW52YWRpbmdUZXh0Q29sdW1uXG4gICAgICB9KTtcbiAgICAgIGlmIChoZXJvU2lnbmFsLmlzSGVybykge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6aGVyb0NlbnRyYWxUZXh0XCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgaGVyb1JlYXNvbjogaGVyb1NpZ25hbC5yZWFzb24sXG4gICAgICAgICAgaGVybzogaGVyb1NpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmxpbmVQYWlyU2lnbmFsID0gZGV0ZWN0SW5saW5lUGFpck5vUmVmbG93KGl0ZW1zRmxvdywgaXRlbXNBbGwsIHJvb3RXLCBDRkcpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjppbmxpbmVQYWlyQ2hlY2tcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHNraXA6IGlubGluZVBhaXJTaWduYWwuc2tpcCxcbiAgICAgICAgcmVhc29uOiBpbmxpbmVQYWlyU2lnbmFsLnJlYXNvbixcbiAgICAgICAgdG90YWxGbG93OiBpbmxpbmVQYWlyU2lnbmFsLnRvdGFsRmxvdyxcbiAgICAgICAgdG90YWxBbGw6IGlubGluZVBhaXJTaWduYWwudG90YWxBbGwsXG4gICAgICAgIHJvd0RlbHRhOiBpbmxpbmVQYWlyU2lnbmFsLnJvd0RlbHRhLFxuICAgICAgICByb3dUb2w6IGlubGluZVBhaXJTaWduYWwucm93VG9sLFxuICAgICAgICB3aWR0aHM6IGlubGluZVBhaXJTaWduYWwud2lkdGhzLFxuICAgICAgICBoZWlnaHRzOiBpbmxpbmVQYWlyU2lnbmFsLmhlaWdodHMsXG4gICAgICAgIGJvdGhTbWFsbDogaW5saW5lUGFpclNpZ25hbC5ib3RoU21hbGwsXG4gICAgICAgIHNtYWxsV0xpbWl0OiBpbmxpbmVQYWlyU2lnbmFsLnNtYWxsV0xpbWl0LFxuICAgICAgICBzbWFsbEhMaW1pdDogaW5saW5lUGFpclNpZ25hbC5zbWFsbEhMaW1pdCxcbiAgICAgICAgcGFpclNwYW46IGlubGluZVBhaXJTaWduYWwucGFpclNwYW4sXG4gICAgICAgIHBhaXJTcGFuUmF0aW86IGlubGluZVBhaXJTaWduYWwucGFpclNwYW5SYXRpbyxcbiAgICAgICAgZml0c1RvZ2V0aGVyOiBpbmxpbmVQYWlyU2lnbmFsLmZpdHNUb2dldGhlclxuICAgICAgfSk7XG4gICAgICBpZiAoaW5saW5lUGFpclNpZ25hbC5za2lwKSB7XG4gICAgICAgIHZhciBpbmxpbmVQYWlyQWRqdXN0ID0gZW5mb3JjZUlubGluZVBhaXJHYXAoaXRlbXNGbG93LCBjb250ZW50LCByb290Vyk7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246aW5saW5lUGFpckFkanVzdFwiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgYWRqdXN0OiBpbmxpbmVQYWlyQWRqdXN0XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6c21hbGxJbmxpbmVQYWlyRml0c1wiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGlubGluZVBhaXI6IGlubGluZVBhaXJTaWduYWwsXG4gICAgICAgICAgaW5saW5lUGFpckFkanVzdDogaW5saW5lUGFpckFkanVzdFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIOKchSAzKSBHYXRlIFwibWVqb3IgZGUgYW1ib3MgbXVuZG9zXCI6XG4gICAgICAvLyAtIFNpIGVzIFwib25lXCIgKGxheW91dCB5YSBuYXR1cmFsKSBZIGFkZW3DoXMgZW50cmEsIE5PIGhhY2Vtb3MgcmVmbG93LlxuICAgICAgLy8gLSBFbiBjdWFscXVpZXIgb3RybyBjYXNvICh0d28vdGhyZWUvcm93cyksIGhhY2Vtb3MgcmVmbG93IHBhcmEgbGVjdHVyYSBtb2JpbGUsXG4gICAgICAvLyAgIGluY2x1c28gYXVucXVlIFwiZW50cmVcIi5cclxuICAgICAgdmFyIGZpdHMgPSBjbHVzdGVyc0ZpdEluTW9iaWxlKGNsdXN0ZXJzLCBjb250ZW50KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0Q2hlY2tcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGZpdHM6IGZpdHMsXG4gICAgICAgIHdpbGxTa2lwOiAobW9kZSA9PT0gXCJvbmVcIiAmJiBmaXRzKVxuICAgICAgfSk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJvbmVcIiAmJiBmaXRzKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDptb2RlT25lRml0c1wiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGZpdHM6IGZpdHMsXG4gICAgICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2dSZWZsb3dEZWNpc2lvbihcImFwcGx5Om1vZGVSZXF1aXJlc1JlZmxvd1wiLCB7XG4gICAgICAgIHdpbGxBcHBseVJlZmxvdzogdHJ1ZSxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgZmxvd0NvdW50OiBpdGVtc0Zsb3cubGVuZ3RoLFxuICAgICAgICBhbmNob3JDb3VudDogaXRlbXNBbmNob3IubGVuZ3RoLFxuICAgICAgICBncm91cFNpemVzOiBncm91cHMubWFwKGZ1bmN0aW9uKGdycCl7IHJldHVybiBncnAubGVuZ3RoOyB9KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIOKchSA0KSBSZWZsb3cgc29sbyBzb2JyZSBGTE9XIChwcmVzZXJ2YSBzb2xhcGVzIGRlbnRybyBkZSBjYWRhIGNsdXN0ZXIpXG4gICAgICB2YXIgcmVzID0gYXBwbHlDbHVzdGVyU3RhY2soZ3JvdXBzLCBjb250ZW50LCBDRkcsIG1vZGUpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjphcHBseVJlc3VsdFwiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgY2hhbmdlZDogISEocmVzICYmIHJlcy5jaGFuZ2VkKSxcbiAgICAgICAgbmVlZGVkSGVpZ2h0OiByZXMgPyByZXMubmVlZGVkSGVpZ2h0IDogbnVsbCxcbiAgICAgICAgbWF4QW5jaG9yQm90dG9tOiArbWF4QW5jaG9yQm90dG9tLnRvRml4ZWQoMSksXG4gICAgICAgIGJhc2VCb3R0b21HYXA6ICtiYXNlQm90dG9tR2FwLnRvRml4ZWQoMSlcbiAgICAgIH0pO1xuICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJwb3N0QXBwbHlcIiwge1xuICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IHRydWUsXG4gICAgICAgIGNoYW5nZWQ6ICEhKHJlcyAmJiByZXMuY2hhbmdlZCksXG4gICAgICAgIG5lZWRlZEhlaWdodDogcmVzID8gK051bWJlcihyZXMubmVlZGVkSGVpZ2h0IHx8IDApLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KTtcblxuICAgICAgdmFyIG5lZWRlZEFmdGVyUmVmbG93ID0gMDtcbiAgICAgIGlmIChyZXMgJiYgcmVzLmNoYW5nZWQpIHtcbiAgICAgICAgLy8gRXZpdGFyIHF1ZSBsYSBzZWNjacOzbiBxdWVkZSBjaGljYSBzaSBoYXkgYW5jaG9ycyBtw6FzIGFiYWpvXG4gICAgICAgIHZhciBuZWVkZWQgPSBOdW1iZXIocmVzLm5lZWRlZEhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKE51bWJlcihtYXhBbmNob3JCb3R0b20pID4gMCkge1xuICAgICAgICAgIC8vIHN1bWFtb3MgcGFkZGluZyBib3R0b20gcGFyYSBxdWUgbm8gcXVlZGUgcGVnYWRvXG4gICAgICAgICAgdmFyIGFuY2hvck5lZWRlZCA9IE1hdGguY2VpbChtYXhBbmNob3JCb3R0b20gKyAoQ0ZHLlBBRF9CT1QgfHwgMCkpO1xuICAgICAgICAgIGlmIChhbmNob3JOZWVkZWQgPiBuZWVkZWQpIG5lZWRlZCA9IGFuY2hvck5lZWRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUJvdHRvbUdhcCA+IDApIHtcbiAgICAgICAgICBuZWVkZWQgPSBNYXRoLmNlaWwobmVlZGVkICsgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRlZCA+IDApIG5lZWRlZEFmdGVyUmVmbG93ID0gbmVlZGVkO1xuICAgICAgfVxuICAgICAgZmluYWxpemVTZWN0aW9uKG5lZWRlZEFmdGVyUmVmbG93LCBiYXNlQm90dG9tR2FwKTtcbiAgICB9KTtcbiAgfVxuXHJcbiAgZnVuY3Rpb24gYm9vdCgpe1xuICAgIG1zbExvZyhcImJvb3RcIiwgeyBjZmc6IENGRyB9KTtcbiAgICBydW5PbmNlKCk7XG4gICAgc2V0VGltZW91dChydW5PbmNlLCAxNTApO1xyXG4gICAgc2V0VGltZW91dChydW5PbmNlLCA2MDApO1xyXG4gICAgc2V0VGltZW91dChydW5PbmNlLCAxODAwKTtcclxuXHJcbiAgICBpZihkb2N1bWVudC5mb250cyAmJiBkb2N1bWVudC5mb250cy5yZWFkeSl7XHJcbiAgICAgIGRvY3VtZW50LmZvbnRzLnJlYWR5LnRoZW4oZnVuY3Rpb24oKXsgcnVuT25jZSgpOyB9KS5jYXRjaChmdW5jdGlvbigpe30pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGJvb3QpO1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJ1bk9uY2UpO1xyXG5cclxuICBpZih3aW5kb3cudmlzdWFsVmlld3BvcnQpe1xyXG4gICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcnVuT25jZSk7XHJcbiAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBydW5PbmNlKTtcclxuICB9XHJcblxyXG4gIGlmKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSBib290KCk7XHJcbiAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBib290KTtcclxufSkoKTtcclxuPC9zY3JpcHQ+XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc0RvbUhlbHBlcnNCbG9jayIsImpzRml0U2NhbGVCbG9jayIsImpzT3JkZXJpbmdCbG9jayIsImpzU3RhY2tpbmdCbG9jayIsImJ1aWxkU2NyaXB0IiwiY2ZnIiwiZW5hYmxlZCIsIm1pbkdhcFB4IiwibWF4R2FwUHgiLCJnYXBTY2FsZSIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm9ubHlGaXhlZFNlY3Rpb25zIiwib25seVdoZW5SZW9yZGVyZWQiLCJyb3dUb2xQeCIsInR3b0NvbFNwcmVhZFJhdGlvIiwibWluUGVyQ29sdW1uMiIsInRocmVlQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4zIiwiZml0TWluU2NhbGUiLCJmaXRNYXhTY2FsZSIsImZpdFRhcmdldFdpZHRoUmF0aW8iLCJmaXRNaW5GaWxsUmF0aW8iLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/stacking.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsStackingBlock: () => (/* binding */ jsStackingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/stacking.ts\nfunction jsStackingBlock() {\n    return `\n  // Centro real del Ã¡rea usable (compensa padding safe-left/right)\n  function computeCenterX(rootEl){\n    var rootRect = rootEl.getBoundingClientRect();\n    var rootW = rootRect.width || 0;\n\n    var cs = getComputedStyle(rootEl);\n    var padL = parseFloat(cs.paddingLeft) || 0;\n    var padR = parseFloat(cs.paddingRight) || 0;\n\n    var usableW = Math.max(0, rootW - padL - padR);\n    var centerX = padL + usableW / 2; // centro del Ã¡rea usable\n\n    return { rootW: rootW, usableW: usableW, centerX: centerX, padL: padL, padR: padR };\n  }\n\n  function clamp(n, a, b){\n    if (!isFinite(n)) return a;\n    return Math.max(a, Math.min(b, n));\n  }\n\n  /**\n   * Apila CLUSTERS por groups (columnas/filas) y:\n   * - mueve cada cluster como bloque\n   * - preserva solape/posiciones relativas dentro del cluster\n   * - centra el cluster como bloque en el eje X (sin transform)\n   *\n   * Devuelve changed + neededHeight (para expandir secciÃ³n)\n   */\n  function applyClusterStack(groups, rootEl, CFG, mode){\n    var info = computeCenterX(rootEl);\n    var centerX = info.centerX;\n    mslLog(\"stack:start\", {\n      groupCount: groups.length,\n      groupSizes: groups.map(function(g){ return g.length; }),\n      centerX: +centerX.toFixed(1),\n      usableW: +info.usableW.toFixed(1)\n    });\n\n    var changed = false;\n    var isMultiColLayout = (mode === \"two\" || mode === \"three\");\n\n    // En multi-columna: cada columna apilada se centra por su propio bbox.\n    // AsÃ­, el centro de cada columna coincide con el centro de pantalla.\n\n    // --- Anchor global: dÃ³nde estaba â€œel bloqueâ€ originalmente ---\n    var firstGroup = groups[0] || [];\n    var anchor = Infinity;\n    for (var i=0;i<firstGroup.length;i++){\n      anchor = Math.min(anchor, firstGroup[i].top);\n    }\n    if (!isFinite(anchor)) anchor = CFG.PAD_TOP;\n    anchor = Math.max(CFG.PAD_TOP, anchor);\n\n    // Cursor global: dÃ³nde termina el contenido apilado hasta ahora\n    var globalCursor = anchor;\n\n    // SeparaciÃ³n entre columnas apiladas (izq, centro, der)\n    var GROUP_GAP = 14;\n\n    for (var g=0; g<groups.length; g++){\n      var col = groups[g] || [];\n      if (!col.length) continue;\n      var colReferenceCenterX = NaN;\n      var colSourceReferenceCenterX = NaN;\n      var narrowClusterCount = 0;\n      var wideClusterCount = 0;\n\n      // MÃ©tricas por grupo solo para debug.\n      var groupMinLeft = Infinity;\n      var groupMaxRight = -Infinity;\n      if (isMultiColLayout){\n        for (var gg=0; gg<col.length; gg++){\n          groupMinLeft = Math.min(groupMinLeft, col[gg].left);\n          groupMaxRight = Math.max(groupMaxRight, col[gg].left + col[gg].width);\n          var clusterWDbg = Number(col[gg].width || 0);\n          if (clusterWDbg <= (info.usableW * 0.72)) narrowClusterCount++;\n          if (clusterWDbg >= (info.usableW * 0.88)) wideClusterCount++;\n        }\n      }\n      var groupWidth = isMultiColLayout ? Math.max(0, groupMaxRight - groupMinLeft) : 0;\n      var groupBaseLeft = isMultiColLayout ? (centerX - groupWidth / 2) : 0;\n      var suspiciousWideSpan = isMultiColLayout &&\n        col.length > 1 &&\n        groupWidth >= (info.usableW * 0.88) &&\n        narrowClusterCount >= 1 &&\n        wideClusterCount >= 1;\n      var preserveColumnOffsets = isMultiColLayout && !suspiciousWideSpan;\n\n      // Offset vertical original de esta columna respecto del anchor\n      var colMinTop = Infinity;\n      for (var k=0;k<col.length;k++){\n        colMinTop = Math.min(colMinTop, col[k].top);\n      }\n      if (!isFinite(colMinTop)) colMinTop = anchor;\n\n      var colOffset = colMinTop - anchor;\n      var colStart = globalCursor + (g === 0 ? 0 : GROUP_GAP) + Math.max(0, colOffset);\n      mslLog(\"stack:group:start\", {\n        g: g,\n        colSize: col.length,\n        colMinTop: +colMinTop.toFixed(1),\n        colOffset: +colOffset.toFixed(1),\n        colStart: +colStart.toFixed(1),\n        globalCursor: +globalCursor.toFixed(1),\n        mode: mode,\n        groupMinLeft: isMultiColLayout ? +groupMinLeft.toFixed(1) : null,\n        groupWidth: isMultiColLayout ? +groupWidth.toFixed(1) : null,\n        groupBaseLeft: isMultiColLayout ? +groupBaseLeft.toFixed(1) : null,\n        narrowClusterCount: isMultiColLayout ? narrowClusterCount : null,\n        wideClusterCount: isMultiColLayout ? wideClusterCount : null,\n        preserveColumnOffsets: isMultiColLayout ? preserveColumnOffsets : null\n      });\n\n      // Cursor local de esta columna\n      var colCursor = colStart;\n\n      for (var j=0; j<col.length; j++){\n        var c = col[j];\n\n        // Top del cluster en el flujo mobile\n        var clusterTop;\n\n        if (j === 0) {\n          clusterTop = colCursor;\n        } else {\n          var prevC = col[j-1];\n          var prevBottom = (clusterTopPrev + prevC.height);\n\n          // âœ… Gap original entre clusters (canvas)\n          var prevBottomOrig = (prevC.top + prevC.height);\n          var gapOrig = c.top - prevBottomOrig;\n          if (!isFinite(gapOrig)) gapOrig = 0;\n\n          var overlapInSource = gapOrig < 0;\n          if ((mode === \"two\" || mode === \"three\") && overlapInSource) {\n            // Si en el original este cluster cae dentro del anterior, respetamos\n            // su top relativo para no mandarlo al final de la columna.\n            var relTopInCol = c.top - colMinTop;\n            if (!isFinite(relTopInCol)) relTopInCol = 0;\n            clusterTop = colStart + Math.max(0, relTopInCol);\n          } else {\n            // âœ… Gap â€œmobile-friendlyâ€: escalado + clamp\n            var gapWanted = clamp(gapOrig * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\n\n            // âœ… Anti-solape definitivo:\n            //   el prÃ³ximo cluster SIEMPRE empieza despuÃ©s del bottom real del anterior + gapWanted\n            clusterTop = prevBottom + gapWanted;\n\n            // En multi-columna nunca avanzamos hacia arriba respecto al flujo ya consumido.\n            if ((mode === \"two\" || mode === \"three\") && clusterTop < colCursor) {\n              clusterTop = colCursor;\n            }\n          }\n        }\n\n        // Guardamos para el prÃ³ximo loop\n        var clusterTopPrev = clusterTop;\n\n        // Â¿centrar este cluster?\n        var forceCenter = false;\n        var hasTextInCluster = false;\n        var hasNonTextInCluster = false;\n        for (var t=0; t<c.items.length; t++){\n          var isTextT = (c.items[t].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          if (isTextT) hasTextInCluster = true;\n          else hasNonTextInCluster = true;\n          if ((c.items[t].node.getAttribute(\"data-mobile-center\") || \"\") === \"force\") {\n            forceCenter = true;\n          }\n        }\n\n        // one/rows: centro por cluster (comportamiento original)\n        // two/three: apilar cada columna en la misma referencia X,\n        // preservando offsets internos de esa columna.\n        var keepCenter = forceCenter ? true : (c.width < (info.usableW * 0.95));\n        var clusterLeft = keepCenter ? (centerX - c.width / 2) : c.left;\n        var isTextOnlyCluster = hasTextInCluster && !hasNonTextInCluster;\n        var shouldCenterTextWithinCluster = false;\n        if (isMultiColLayout) {\n          // Modo lectura mobile multi-col:\n          // usar una misma referencia X para toda la columna apilada y\n          // preservar el offset horizontal original de cada cluster.\n          // Esto mantiene alineado texto/forma cuando la columna se parte\n          // en varios clusters.\n          // Si el bbox de la columna queda contaminado por un outlier ancho\n          // (tipicamente texto), centrar por offsets deja la columna pegada\n          // al borde; en ese caso centramos cada cluster individualmente.\n          if (preserveColumnOffsets) {\n            var relClusterLeft = (c.left || 0) - (groupMinLeft || 0);\n            clusterLeft = groupBaseLeft + relClusterLeft;\n          } else {\n            clusterLeft = centerX - c.width / 2;\n          }\n\n          // Permite forzar centrado por cluster si el nodo lo pide.\n          if (forceCenter) clusterLeft = centerX - c.width / 2;\n\n          // Si esta columna tiene un cluster con forma (o mixto), usamos su\n          // centro como referencia para alinear clusters solo-texto debajo.\n          var clusterRefCenterX = NaN;\n          if (hasNonTextInCluster) {\n            // Referencia basada en items no-texto (forma/icono), no en todo el\n            // cluster, para que textos largos no desplacen el centro de columna.\n            var ntMinRel = Infinity;\n            var ntMaxRel = -Infinity;\n            for (var nti=0; nti<c.items.length; nti++){\n              var ntIt = c.items[nti];\n              var ntIsText = (ntIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              if (ntIsText) continue;\n              ntMinRel = Math.min(ntMinRel, (ntIt._relLeft || 0));\n              ntMaxRel = Math.max(ntMaxRel, (ntIt._relLeft || 0) + (ntIt.width || 0));\n            }\n            var sourceClusterRefCenterX = NaN;\n            if (isFinite(ntMinRel) && isFinite(ntMaxRel) && ntMaxRel > ntMinRel) {\n              clusterRefCenterX = clusterLeft + ((ntMinRel + ntMaxRel) / 2);\n              sourceClusterRefCenterX = (c.left || 0) + ((ntMinRel + ntMaxRel) / 2);\n            } else {\n              clusterRefCenterX = clusterLeft + c.width / 2;\n              sourceClusterRefCenterX = (c.left || 0) + c.width / 2;\n            }\n\n            colReferenceCenterX = Number(clusterRefCenterX);\n            colSourceReferenceCenterX = Number(sourceClusterRefCenterX);\n            if (!isFinite(colReferenceCenterX)) colReferenceCenterX = NaN;\n            if (!isFinite(colSourceReferenceCenterX)) colSourceReferenceCenterX = NaN;\n          }\n\n          if (isTextOnlyCluster) {\n            // Mantener posicion de cluster alineada con la columna centrada\n            // sin tocar la alineacion interna del texto.\n            var centeredClusterLeft = centerX - c.width / 2;\n            if (isFinite(colReferenceCenterX)) {\n              var maxSnapDelta = Math.min(120, info.usableW * 0.35);\n              var sourceClusterCenterX = (c.left || 0) + c.width / 2;\n              var sourceDriftX = isFinite(colSourceReferenceCenterX)\n                ? (sourceClusterCenterX - colSourceReferenceCenterX)\n                : NaN;\n              if (isFinite(sourceDriftX) && Math.abs(sourceDriftX) <= maxSnapDelta) {\n                var driftedClusterLeft = (colReferenceCenterX + sourceDriftX) - c.width / 2;\n                var driftedClusterCenterX = driftedClusterLeft + c.width / 2;\n                var maxRefDrift = Math.max(12, info.usableW * 0.06);\n                if (Math.abs(driftedClusterCenterX - centerX) <= maxRefDrift) {\n                  centeredClusterLeft = driftedClusterLeft;\n                }\n              }\n            }\n            clusterLeft = centeredClusterLeft;\n            shouldCenterTextWithinCluster = false;\n          }\n\n          // Guard rail: en apilado multi-columna, un cluster no debe quedar\n          // desviado demasiado del eje central del layout mobile.\n          var clusterCenterXNow = clusterLeft + c.width / 2;\n          var maxCenterDrift = Math.max(24, info.usableW * 0.18);\n          if (Math.abs(clusterCenterXNow - centerX) > maxCenterDrift) {\n            mslLog(\"stack:cluster:centerFallback\", {\n              g: g,\n              j: j,\n              prevLeft: +clusterLeft.toFixed(1),\n              centerX: +centerX.toFixed(1),\n              clusterCenterX: +clusterCenterXNow.toFixed(1),\n              maxCenterDrift: +maxCenterDrift.toFixed(1),\n              clusterW: +(c.width || 0).toFixed(1)\n            });\n            clusterLeft = centerX - c.width / 2;\n          }\n        }\n        mslLog(\"stack:cluster\", {\n          g: g,\n          j: j,\n          origTop: +c.top.toFixed(1),\n          origLeft: +c.left.toFixed(1),\n          newTop: +clusterTop.toFixed(1),\n          newLeft: +clusterLeft.toFixed(1),\n          h: +c.height.toFixed(1),\n          w: +c.width.toFixed(1),\n          forceCenter: forceCenter,\n          keepCenter: keepCenter,\n          items: c.items.length,\n          colReferenceCenterX: (typeof colReferenceCenterX === \"number\" && isFinite(colReferenceCenterX)) ? +colReferenceCenterX.toFixed(1) : null,\n          isTextOnlyCluster: isTextOnlyCluster,\n          centerShortText: shouldCenterTextWithinCluster\n        });\n\n        var textCount = 0;\n        for (var tc=0; tc<c.items.length; tc++){\n          if ((c.items[tc].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textCount++;\n        }\n        var linearizeCluster = (mode === \"rows\" && c.items.length > 1 && textCount >= 2);\n        var clusterBottomUsed = clusterTop + c.height;\n\n        // Caso especial: en rows, si el cluster agrupa varios textos, lo\n        // convertimos a flujo vertical centrado para evitar texto lado a lado.\n        if (linearizeCluster){\n          var allItems = c.items.slice();\n          var nonText = allItems.filter(function(itx){\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\";\n          }).sort(function(a,b){\n            if (a.top !== b.top) return a.top - b.top;\n            return a.left - b.left;\n          });\n          var texts = allItems.filter(function(itx){\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n          }).sort(function(a,b){\n            if (a.top !== b.top) return a.top - b.top;\n            return a.left - b.left;\n          });\n\n          // Orden semÃ¡ntico de lectura:\n          // no-texto + texto mÃ¡s cercano (debajo y por eje X), luego remanentes.\n          var ordered = [];\n          var usedText = {};\n\n          for (var nt=0; nt<nonText.length; nt++){\n            var ntItem = nonText[nt];\n            ordered.push(ntItem);\n\n            var ntCx = (ntItem.left || 0) + (ntItem.width || 0) / 2;\n            var ntBottom = (ntItem.top || 0) + (ntItem.height || 0);\n            var bestIdxTxt = -1;\n            var bestScore = Infinity;\n\n            for (var tx=0; tx<texts.length; tx++){\n              if (usedText[tx]) continue;\n              var tItem = texts[tx];\n              var tCx = (tItem.left || 0) + (tItem.width || 0) / 2;\n              var vGapTxt = (tItem.top || 0) - ntBottom; // preferir texto debajo\n              var hDistTxt = Math.abs(tCx - ntCx);\n              var penaltyAbove = vGapTxt < -2 ? 10000 : 0;\n              var score = penaltyAbove + Math.abs(vGapTxt) * 2 + hDistTxt;\n              if (score < bestScore){\n                bestScore = score;\n                bestIdxTxt = tx;\n              }\n            }\n\n            if (bestIdxTxt >= 0){\n              ordered.push(texts[bestIdxTxt]);\n              usedText[bestIdxTxt] = true;\n            }\n          }\n\n          // Textos no emparejados\n          for (var tx2=0; tx2<texts.length; tx2++){\n            if (!usedText[tx2]) ordered.push(texts[tx2]);\n          }\n\n          // Si no hubo no-texto, fallback simple por top/left\n          if (!ordered.length) {\n            ordered = allItems.sort(function(a,b){\n              if (a.top !== b.top) return a.top - b.top;\n              return a.left - b.left;\n            });\n          }\n\n          var localCursor = clusterTop;\n          var prevIt = null;\n          var prevTopApplied = clusterTop;\n          var EXTRA_COL_BREAK_GAP = 8;\n\n          for (var li=0; li<ordered.length; li++){\n            var lit = ordered[li];\n\n            var keepLayoutLin = (lit.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n            if (keepLayoutLin) continue;\n\n            var newTopLin = localCursor;\n            if (prevIt){\n              var gapOrigLin = lit.top - (prevIt.top + prevIt.height);\n              if (!isFinite(gapOrigLin)) gapOrigLin = 0;\n              var gapWantedLin = clamp(gapOrigLin * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\n              var prevIsTextLin = (prevIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              var currIsTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n              // Al pasar de \"texto final de columna\" a \"nuevo no-texto\" agregamos aire.\n              if (prevIsTextLin && !currIsTextLin) gapWantedLin += EXTRA_COL_BREAK_GAP;\n              newTopLin = prevTopApplied + prevIt.height + gapWantedLin;\n            }\n\n            var newLeftLin = centerX - (lit.width || 0) / 2;\n            var keepAlignLin = (lit.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\n            if (keepAlignLin) newLeftLin = lit.left;\n\n            if (Math.abs(newTopLin - lit.top) > 0.5 || Math.abs(newLeftLin - lit.left) > 0.5) changed = true;\n\n            // En rows linealizado, forzamos centrado visual real de texto.\n            var isTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n            if (isTextLin && !keepAlignLin) {\n              lit.node.style.textAlign = \"center\";\n              lit.node.style.transformOrigin = \"top center\";\n              lit.node.style.setProperty(\"--text-zoom\", \"1\");\n              var tfLin = lit.node.style.transform || \"\";\n              if (tfLin.indexOf(\"translateX(\") !== -1) {\n                lit.node.style.transform = tfLin.replace(/translateX\\([^)]*\\)/, \"translateX(0px)\");\n              }\n            }\n\n            var cssLeftLin = newLeftLin - (info.padL || 0);\n            lit.node.style.top = newTopLin + \"px\";\n            lit.node.style.left = cssLeftLin + \"px\";\n            lit.node.style.right = \"auto\";\n            lit.node.style.marginLeft = \"0px\";\n\n            prevIt = lit;\n            prevTopApplied = newTopLin;\n            localCursor = newTopLin + (lit.height || 0);\n            if (localCursor > clusterBottomUsed) clusterBottomUsed = localCursor;\n          }\n\n          colCursor = Math.max(colCursor, clusterBottomUsed);\n          continue;\n        }\n\n        // Aplicar a cada item preservando offsets relativos (solape intacto)\n        for (var ii=0; ii<c.items.length; ii++){\n          var it = c.items[ii];\n          var isTextNode = (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\n\n          // Opt-out total del layout (decoraciones, etc.)\n          var keepLayout = (it.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\n          if (keepLayout) continue;\n\n          var newTop = clusterTop + (it._relTop || 0);\n          var newLeft = clusterLeft + (it._relLeft || 0);\n\n          // Opt-out de centrado (mantener left original del item)\n          var keepAlign = (it.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\n          if (keepAlign) newLeft = it.left;\n\n          // En multi-col, neutralizamos SIEMPRE translateX(...) de textos\n          // para que la posiciÃ³n left calculada sea la referencia visual real.\n          var isShortTextBox = false;\n          var shouldRecenterTextItem = false;\n          var recenterGuardBlocked = false;\n          var centerByAlign = false;\n          var targetTextCenterX = NaN;\n          if (isTextNode && isMultiColLayout) {\n            var tf = it.node.style.transform || \"\";\n            if (tf.indexOf(\"translateX(\") !== -1) {\n              it.node.style.transform = tf.replace(/translateX\\([^)]*\\)/, \"translateX(0px)\");\n            }\n            isShortTextBox = (it.width || 0) <= (info.usableW * 0.5) && (it.height || 0) <= 42;\n            var taCurrent = ((it.node.style && it.node.style.textAlign) || \"\").toLowerCase();\n            centerByAlign = taCurrent === \"center\";\n            var shouldCenterVisualText =\n              (shouldCenterTextWithinCluster || isShortTextBox || centerByAlign) &&\n              !keepAlign;\n            shouldRecenterTextItem =\n              shouldCenterVisualText &&\n              !isTextOnlyCluster &&\n              isFinite(colReferenceCenterX);\n            if (shouldRecenterTextItem) {\n              var prevLeftTxt = newLeft;\n              var currentCenterX = prevLeftTxt + (it.width || 0) / 2;\n              var sourceItemCenterX = (it.left || 0) + (it.width || 0) / 2;\n              var sourceDriftItemX = isFinite(colSourceReferenceCenterX)\n                ? (sourceItemCenterX - colSourceReferenceCenterX)\n                : NaN;\n              var targetCenterX = colReferenceCenterX;\n              // En textos centrados (o labels cortos forzados al centro),\n              // no arrastramos drift horizontal del layout original para\n              // evitar corrimientos laterales en mobile.\n              var preserveSourceDrift =\n                !centerByAlign &&\n                !shouldCenterTextWithinCluster &&\n                !isShortTextBox;\n              if (preserveSourceDrift && isFinite(sourceDriftItemX)) {\n                targetCenterX += sourceDriftItemX;\n              }\n              // Guard rail: si la recorreccion propuesta se aleja demasiado del\n              // centro ya calculado para el cluster, no la aplicamos.\n              var maxRecenterShift = Math.max(18, info.usableW * 0.08);\n              if (isFinite(currentCenterX) && isFinite(targetCenterX) && Math.abs(targetCenterX - currentCenterX) > maxRecenterShift) {\n                recenterGuardBlocked = true;\n                shouldRecenterTextItem = false;\n                targetCenterX = currentCenterX;\n              }\n              targetTextCenterX = targetCenterX;\n              newLeft = targetCenterX - (it.width || 0) / 2;\n              if (Math.abs(newLeft - prevLeftTxt) > 0.5) {\n                mslLog(\"stack:item:textRecenter\", {\n                  g: g,\n                  j: j,\n                  ii: ii,\n                  prevLeft: +prevLeftTxt.toFixed(1),\n                  newLeft: +newLeft.toFixed(1),\n                  itemW: +(it.width || 0).toFixed(1),\n                  refCenterX: +colReferenceCenterX.toFixed(1),\n                  sourceRefCenterX: (typeof colSourceReferenceCenterX === \"number\" && isFinite(colSourceReferenceCenterX)) ? +colSourceReferenceCenterX.toFixed(1) : null,\n                  sourceDriftX: isFinite(sourceDriftItemX) ? +sourceDriftItemX.toFixed(1) : null,\n                  preserveSourceDrift: preserveSourceDrift,\n                  guardBlocked: recenterGuardBlocked,\n                  shortBox: isShortTextBox,\n                  centerByAlign: centerByAlign\n                });\n              }\n            }\n            if (shouldCenterVisualText) {\n              it.node.style.textAlign = \"center\";\n              it.node.style.transformOrigin = \"top center\";\n              // Evita encogimiento horizontal heredado que desplaza el centro visual.\n              it.node.style.setProperty(\"--text-zoom\", \"1\");\n            }\n          }\n\n          var cssLeft = newLeft - (info.padL || 0);\n          it.node.style.top = newTop + \"px\";\n          it.node.style.left = cssLeft + \"px\";\n          it.node.style.right = \"auto\";\n          it.node.style.marginLeft = \"0px\";\n\n          // CorrecciÃ³n final por posiciÃ³n renderizada real del texto\n          // (fuentes/transform pueden introducir desvÃ­os visuales sub-pÃ­xel).\n          if (isTextNode && isMultiColLayout && shouldRecenterTextItem) {\n            var rrTxt = relRect(it.node, rootEl);\n            var renderedCenterX = (rrTxt.left || 0) + (rrTxt.width || 0) / 2;\n            var targetRenderCenterX = isFinite(targetTextCenterX) ? targetTextCenterX : colReferenceCenterX;\n            var renderDelta = renderedCenterX - targetRenderCenterX;\n            if (isFinite(renderDelta) && Math.abs(renderDelta) > 0.6) {\n              var correctedLeft = newLeft - renderDelta;\n              if (isFinite(correctedLeft)) {\n                mslLog(\"stack:item:textRenderAdjust\", {\n                  g: g,\n                  j: j,\n                  ii: ii,\n                  prevLeft: +newLeft.toFixed(1),\n                  correctedLeft: +correctedLeft.toFixed(1),\n                  renderedCenterX: +renderedCenterX.toFixed(1),\n                  refCenterX: +targetRenderCenterX.toFixed(1),\n                  delta: +renderDelta.toFixed(2)\n                });\n                newLeft = correctedLeft;\n                it.node.style.left = (newLeft - (info.padL || 0)) + \"px\";\n              }\n            }\n          }\n\n          if (Math.abs(newTop - it.top) > 0.5 || Math.abs(newLeft - it.left) > 0.5) changed = true;\n\n          var itemBottom = newTop + (it.height || 0);\n          if (itemBottom > clusterBottomUsed) clusterBottomUsed = itemBottom;\n        }\n\n        // Avanza el cursor local al final del cluster\n        colCursor = Math.max(colCursor, clusterBottomUsed);\n      }\n\n      // Al terminar la columna, el cursor global baja hasta donde llegÃ³ esta columna\n      globalCursor = Math.max(globalCursor, colCursor);\n    }\n\n    var needed = globalCursor + CFG.PAD_BOT;\n    mslLog(\"stack:end\", {\n      changed: changed,\n      neededHeight: +needed.toFixed(1),\n      finalCursor: +globalCursor.toFixed(1)\n    });\n    return { changed: changed, neededHeight: needed };\n  }\n`.trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStpQlYsQ0FBQyxDQUFDQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHN0YWNraW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHNcclxuZXhwb3J0IGZ1bmN0aW9uIGpzU3RhY2tpbmdCbG9jaygpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgXHJcbiAgLy8gQ2VudHJvIHJlYWwgZGVsIMODwqFyZWEgdXNhYmxlIChjb21wZW5zYSBwYWRkaW5nIHNhZmUtbGVmdC9yaWdodClcclxuICBmdW5jdGlvbiBjb21wdXRlQ2VudGVyWChyb290RWwpe1xyXG4gICAgdmFyIHJvb3RSZWN0ID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJvb3RXID0gcm9vdFJlY3Qud2lkdGggfHwgMDtcclxuXHJcbiAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbCk7XHJcbiAgICB2YXIgcGFkTCA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ0xlZnQpIHx8IDA7XHJcbiAgICB2YXIgcGFkUiA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSB8fCAwO1xyXG5cclxuICAgIHZhciB1c2FibGVXID0gTWF0aC5tYXgoMCwgcm9vdFcgLSBwYWRMIC0gcGFkUik7XHJcbiAgICB2YXIgY2VudGVyWCA9IHBhZEwgKyB1c2FibGVXIC8gMjsgLy8gY2VudHJvIGRlbCDDg8KhcmVhIHVzYWJsZVxyXG5cclxuICAgIHJldHVybiB7IHJvb3RXOiByb290VywgdXNhYmxlVzogdXNhYmxlVywgY2VudGVyWDogY2VudGVyWCwgcGFkTDogcGFkTCwgcGFkUjogcGFkUiB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xhbXAobiwgYSwgYil7XHJcbiAgICBpZiAoIWlzRmluaXRlKG4pKSByZXR1cm4gYTtcclxuICAgIHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCBuKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcGlsYSBDTFVTVEVSUyBwb3IgZ3JvdXBzIChjb2x1bW5hcy9maWxhcykgeTpcclxuICAgKiAtIG11ZXZlIGNhZGEgY2x1c3RlciBjb21vIGJsb3F1ZVxyXG4gICAqIC0gcHJlc2VydmEgc29sYXBlL3Bvc2ljaW9uZXMgcmVsYXRpdmFzIGRlbnRybyBkZWwgY2x1c3RlclxyXG4gICAqIC0gY2VudHJhIGVsIGNsdXN0ZXIgY29tbyBibG9xdWUgZW4gZWwgZWplIFggKHNpbiB0cmFuc2Zvcm0pXHJcbiAgICpcclxuICAgKiBEZXZ1ZWx2ZSBjaGFuZ2VkICsgbmVlZGVkSGVpZ2h0IChwYXJhIGV4cGFuZGlyIHNlY2Npw4PCs24pXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXBwbHlDbHVzdGVyU3RhY2soZ3JvdXBzLCByb290RWwsIENGRywgbW9kZSl7XHJcbiAgICB2YXIgaW5mbyA9IGNvbXB1dGVDZW50ZXJYKHJvb3RFbCk7XHJcbiAgICB2YXIgY2VudGVyWCA9IGluZm8uY2VudGVyWDtcclxuICAgIG1zbExvZyhcInN0YWNrOnN0YXJ0XCIsIHtcclxuICAgICAgZ3JvdXBDb3VudDogZ3JvdXBzLmxlbmd0aCxcclxuICAgICAgZ3JvdXBTaXplczogZ3JvdXBzLm1hcChmdW5jdGlvbihnKXsgcmV0dXJuIGcubGVuZ3RoOyB9KSxcclxuICAgICAgY2VudGVyWDogK2NlbnRlclgudG9GaXhlZCgxKSxcclxuICAgICAgdXNhYmxlVzogK2luZm8udXNhYmxlVy50b0ZpeGVkKDEpXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGlzTXVsdGlDb2xMYXlvdXQgPSAobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpO1xyXG5cclxuICAgIC8vIEVuIG11bHRpLWNvbHVtbmE6IGNhZGEgY29sdW1uYSBhcGlsYWRhIHNlIGNlbnRyYSBwb3Igc3UgcHJvcGlvIGJib3guXHJcbiAgICAvLyBBc8ODwq0sIGVsIGNlbnRybyBkZSBjYWRhIGNvbHVtbmEgY29pbmNpZGUgY29uIGVsIGNlbnRybyBkZSBwYW50YWxsYS5cclxuXHJcbiAgICAvLyAtLS0gQW5jaG9yIGdsb2JhbDogZMODwrNuZGUgZXN0YWJhIMOi4oKsxZNlbCBibG9xdWXDouKCrMKdIG9yaWdpbmFsbWVudGUgLS0tXHJcbiAgICB2YXIgZmlyc3RHcm91cCA9IGdyb3Vwc1swXSB8fCBbXTtcclxuICAgIHZhciBhbmNob3IgPSBJbmZpbml0eTtcclxuICAgIGZvciAodmFyIGk9MDtpPGZpcnN0R3JvdXAubGVuZ3RoO2krKyl7XHJcbiAgICAgIGFuY2hvciA9IE1hdGgubWluKGFuY2hvciwgZmlyc3RHcm91cFtpXS50b3ApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0Zpbml0ZShhbmNob3IpKSBhbmNob3IgPSBDRkcuUEFEX1RPUDtcclxuICAgIGFuY2hvciA9IE1hdGgubWF4KENGRy5QQURfVE9QLCBhbmNob3IpO1xyXG5cclxuICAgIC8vIEN1cnNvciBnbG9iYWw6IGTDg8KzbmRlIHRlcm1pbmEgZWwgY29udGVuaWRvIGFwaWxhZG8gaGFzdGEgYWhvcmFcclxuICAgIHZhciBnbG9iYWxDdXJzb3IgPSBhbmNob3I7XHJcblxyXG4gICAgLy8gU2VwYXJhY2nDg8KzbiBlbnRyZSBjb2x1bW5hcyBhcGlsYWRhcyAoaXpxLCBjZW50cm8sIGRlcilcclxuICAgIHZhciBHUk9VUF9HQVAgPSAxNDtcclxuXHJcbiAgICBmb3IgKHZhciBnPTA7IGc8Z3JvdXBzLmxlbmd0aDsgZysrKXtcclxuICAgICAgdmFyIGNvbCA9IGdyb3Vwc1tnXSB8fCBbXTtcclxuICAgICAgaWYgKCFjb2wubGVuZ3RoKSBjb250aW51ZTtcclxuICAgICAgdmFyIGNvbFJlZmVyZW5jZUNlbnRlclggPSBOYU47XHJcbiAgICAgIHZhciBjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYID0gTmFOO1xyXG4gICAgICB2YXIgbmFycm93Q2x1c3RlckNvdW50ID0gMDtcclxuICAgICAgdmFyIHdpZGVDbHVzdGVyQ291bnQgPSAwO1xyXG5cclxuICAgICAgLy8gTcODwql0cmljYXMgcG9yIGdydXBvIHNvbG8gcGFyYSBkZWJ1Zy5cclxuICAgICAgdmFyIGdyb3VwTWluTGVmdCA9IEluZmluaXR5O1xyXG4gICAgICB2YXIgZ3JvdXBNYXhSaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpe1xyXG4gICAgICAgIGZvciAodmFyIGdnPTA7IGdnPGNvbC5sZW5ndGg7IGdnKyspe1xyXG4gICAgICAgICAgZ3JvdXBNaW5MZWZ0ID0gTWF0aC5taW4oZ3JvdXBNaW5MZWZ0LCBjb2xbZ2ddLmxlZnQpO1xyXG4gICAgICAgICAgZ3JvdXBNYXhSaWdodCA9IE1hdGgubWF4KGdyb3VwTWF4UmlnaHQsIGNvbFtnZ10ubGVmdCArIGNvbFtnZ10ud2lkdGgpO1xyXG4gICAgICAgICAgdmFyIGNsdXN0ZXJXRGJnID0gTnVtYmVyKGNvbFtnZ10ud2lkdGggfHwgMCk7XHJcbiAgICAgICAgICBpZiAoY2x1c3RlcldEYmcgPD0gKGluZm8udXNhYmxlVyAqIDAuNzIpKSBuYXJyb3dDbHVzdGVyQ291bnQrKztcclxuICAgICAgICAgIGlmIChjbHVzdGVyV0RiZyA+PSAoaW5mby51c2FibGVXICogMC44OCkpIHdpZGVDbHVzdGVyQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGdyb3VwV2lkdGggPSBpc011bHRpQ29sTGF5b3V0ID8gTWF0aC5tYXgoMCwgZ3JvdXBNYXhSaWdodCAtIGdyb3VwTWluTGVmdCkgOiAwO1xyXG4gICAgICB2YXIgZ3JvdXBCYXNlTGVmdCA9IGlzTXVsdGlDb2xMYXlvdXQgPyAoY2VudGVyWCAtIGdyb3VwV2lkdGggLyAyKSA6IDA7XHJcbiAgICAgIHZhciBzdXNwaWNpb3VzV2lkZVNwYW4gPSBpc011bHRpQ29sTGF5b3V0ICYmXHJcbiAgICAgICAgY29sLmxlbmd0aCA+IDEgJiZcclxuICAgICAgICBncm91cFdpZHRoID49IChpbmZvLnVzYWJsZVcgKiAwLjg4KSAmJlxyXG4gICAgICAgIG5hcnJvd0NsdXN0ZXJDb3VudCA+PSAxICYmXHJcbiAgICAgICAgd2lkZUNsdXN0ZXJDb3VudCA+PSAxO1xyXG4gICAgICB2YXIgcHJlc2VydmVDb2x1bW5PZmZzZXRzID0gaXNNdWx0aUNvbExheW91dCAmJiAhc3VzcGljaW91c1dpZGVTcGFuO1xyXG5cclxuICAgICAgLy8gT2Zmc2V0IHZlcnRpY2FsIG9yaWdpbmFsIGRlIGVzdGEgY29sdW1uYSByZXNwZWN0byBkZWwgYW5jaG9yXHJcbiAgICAgIHZhciBjb2xNaW5Ub3AgPSBJbmZpbml0eTtcclxuICAgICAgZm9yICh2YXIgaz0wO2s8Y29sLmxlbmd0aDtrKyspe1xyXG4gICAgICAgIGNvbE1pblRvcCA9IE1hdGgubWluKGNvbE1pblRvcCwgY29sW2tdLnRvcCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc0Zpbml0ZShjb2xNaW5Ub3ApKSBjb2xNaW5Ub3AgPSBhbmNob3I7XHJcblxyXG4gICAgICB2YXIgY29sT2Zmc2V0ID0gY29sTWluVG9wIC0gYW5jaG9yO1xyXG4gICAgICB2YXIgY29sU3RhcnQgPSBnbG9iYWxDdXJzb3IgKyAoZyA9PT0gMCA/IDAgOiBHUk9VUF9HQVApICsgTWF0aC5tYXgoMCwgY29sT2Zmc2V0KTtcclxuICAgICAgbXNsTG9nKFwic3RhY2s6Z3JvdXA6c3RhcnRcIiwge1xyXG4gICAgICAgIGc6IGcsXHJcbiAgICAgICAgY29sU2l6ZTogY29sLmxlbmd0aCxcclxuICAgICAgICBjb2xNaW5Ub3A6ICtjb2xNaW5Ub3AudG9GaXhlZCgxKSxcclxuICAgICAgICBjb2xPZmZzZXQ6ICtjb2xPZmZzZXQudG9GaXhlZCgxKSxcclxuICAgICAgICBjb2xTdGFydDogK2NvbFN0YXJ0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgZ2xvYmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSksXHJcbiAgICAgICAgbW9kZTogbW9kZSxcclxuICAgICAgICBncm91cE1pbkxlZnQ6IGlzTXVsdGlDb2xMYXlvdXQgPyArZ3JvdXBNaW5MZWZ0LnRvRml4ZWQoMSkgOiBudWxsLFxyXG4gICAgICAgIGdyb3VwV2lkdGg6IGlzTXVsdGlDb2xMYXlvdXQgPyArZ3JvdXBXaWR0aC50b0ZpeGVkKDEpIDogbnVsbCxcclxuICAgICAgICBncm91cEJhc2VMZWZ0OiBpc011bHRpQ29sTGF5b3V0ID8gK2dyb3VwQmFzZUxlZnQudG9GaXhlZCgxKSA6IG51bGwsXHJcbiAgICAgICAgbmFycm93Q2x1c3RlckNvdW50OiBpc011bHRpQ29sTGF5b3V0ID8gbmFycm93Q2x1c3RlckNvdW50IDogbnVsbCxcclxuICAgICAgICB3aWRlQ2x1c3RlckNvdW50OiBpc011bHRpQ29sTGF5b3V0ID8gd2lkZUNsdXN0ZXJDb3VudCA6IG51bGwsXHJcbiAgICAgICAgcHJlc2VydmVDb2x1bW5PZmZzZXRzOiBpc011bHRpQ29sTGF5b3V0ID8gcHJlc2VydmVDb2x1bW5PZmZzZXRzIDogbnVsbFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEN1cnNvciBsb2NhbCBkZSBlc3RhIGNvbHVtbmFcclxuICAgICAgdmFyIGNvbEN1cnNvciA9IGNvbFN0YXJ0O1xyXG5cclxuICAgICAgZm9yICh2YXIgaj0wOyBqPGNvbC5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgdmFyIGMgPSBjb2xbal07XHJcblxyXG4gICAgICAgIC8vIFRvcCBkZWwgY2x1c3RlciBlbiBlbCBmbHVqbyBtb2JpbGVcclxuICAgICAgICB2YXIgY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgaWYgKGogPT09IDApIHtcclxuICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xDdXJzb3I7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBwcmV2QyA9IGNvbFtqLTFdO1xyXG4gICAgICAgICAgdmFyIHByZXZCb3R0b20gPSAoY2x1c3RlclRvcFByZXYgKyBwcmV2Qy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgIC8vIMOixZPigKYgR2FwIG9yaWdpbmFsIGVudHJlIGNsdXN0ZXJzIChjYW52YXMpXHJcbiAgICAgICAgICB2YXIgcHJldkJvdHRvbU9yaWcgPSAocHJldkMudG9wICsgcHJldkMuaGVpZ2h0KTtcclxuICAgICAgICAgIHZhciBnYXBPcmlnID0gYy50b3AgLSBwcmV2Qm90dG9tT3JpZztcclxuICAgICAgICAgIGlmICghaXNGaW5pdGUoZ2FwT3JpZykpIGdhcE9yaWcgPSAwO1xyXG5cclxuICAgICAgICAgIHZhciBvdmVybGFwSW5Tb3VyY2UgPSBnYXBPcmlnIDwgMDtcclxuICAgICAgICAgIGlmICgobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpICYmIG92ZXJsYXBJblNvdXJjZSkge1xyXG4gICAgICAgICAgICAvLyBTaSBlbiBlbCBvcmlnaW5hbCBlc3RlIGNsdXN0ZXIgY2FlIGRlbnRybyBkZWwgYW50ZXJpb3IsIHJlc3BldGFtb3NcclxuICAgICAgICAgICAgLy8gc3UgdG9wIHJlbGF0aXZvIHBhcmEgbm8gbWFuZGFybG8gYWwgZmluYWwgZGUgbGEgY29sdW1uYS5cclxuICAgICAgICAgICAgdmFyIHJlbFRvcEluQ29sID0gYy50b3AgLSBjb2xNaW5Ub3A7XHJcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUocmVsVG9wSW5Db2wpKSByZWxUb3BJbkNvbCA9IDA7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xTdGFydCArIE1hdGgubWF4KDAsIHJlbFRvcEluQ29sKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIMOixZPigKYgR2FwIMOi4oKsxZNtb2JpbGUtZnJpZW5kbHnDouKCrMKdOiBlc2NhbGFkbyArIGNsYW1wXHJcbiAgICAgICAgICAgIHZhciBnYXBXYW50ZWQgPSBjbGFtcChnYXBPcmlnICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XHJcblxyXG4gICAgICAgICAgICAvLyDDosWT4oCmIEFudGktc29sYXBlIGRlZmluaXRpdm86XHJcbiAgICAgICAgICAgIC8vICAgZWwgcHLDg8KzeGltbyBjbHVzdGVyIFNJRU1QUkUgZW1waWV6YSBkZXNwdcODwqlzIGRlbCBib3R0b20gcmVhbCBkZWwgYW50ZXJpb3IgKyBnYXBXYW50ZWRcclxuICAgICAgICAgICAgY2x1c3RlclRvcCA9IHByZXZCb3R0b20gKyBnYXBXYW50ZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBFbiBtdWx0aS1jb2x1bW5hIG51bmNhIGF2YW56YW1vcyBoYWNpYSBhcnJpYmEgcmVzcGVjdG8gYWwgZmx1am8geWEgY29uc3VtaWRvLlxyXG4gICAgICAgICAgICBpZiAoKG1vZGUgPT09IFwidHdvXCIgfHwgbW9kZSA9PT0gXCJ0aHJlZVwiKSAmJiBjbHVzdGVyVG9wIDwgY29sQ3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgY2x1c3RlclRvcCA9IGNvbEN1cnNvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR3VhcmRhbW9zIHBhcmEgZWwgcHLDg8KzeGltbyBsb29wXHJcbiAgICAgICAgdmFyIGNsdXN0ZXJUb3BQcmV2ID0gY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgLy8gw4LCv2NlbnRyYXIgZXN0ZSBjbHVzdGVyP1xyXG4gICAgICAgIHZhciBmb3JjZUNlbnRlciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBoYXNUZXh0SW5DbHVzdGVyID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGhhc05vblRleHRJbkNsdXN0ZXIgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciB0PTA7IHQ8Yy5pdGVtcy5sZW5ndGg7IHQrKyl7XHJcbiAgICAgICAgICB2YXIgaXNUZXh0VCA9IChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICBpZiAoaXNUZXh0VCkgaGFzVGV4dEluQ2x1c3RlciA9IHRydWU7XHJcbiAgICAgICAgICBlbHNlIGhhc05vblRleHRJbkNsdXN0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIpID09PSBcImZvcmNlXCIpIHtcclxuICAgICAgICAgICAgZm9yY2VDZW50ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb25lL3Jvd3M6IGNlbnRybyBwb3IgY2x1c3RlciAoY29tcG9ydGFtaWVudG8gb3JpZ2luYWwpXHJcbiAgICAgICAgLy8gdHdvL3RocmVlOiBhcGlsYXIgY2FkYSBjb2x1bW5hIGVuIGxhIG1pc21hIHJlZmVyZW5jaWEgWCxcclxuICAgICAgICAvLyBwcmVzZXJ2YW5kbyBvZmZzZXRzIGludGVybm9zIGRlIGVzYSBjb2x1bW5hLlxyXG4gICAgICAgIHZhciBrZWVwQ2VudGVyID0gZm9yY2VDZW50ZXIgPyB0cnVlIDogKGMud2lkdGggPCAoaW5mby51c2FibGVXICogMC45NSkpO1xyXG4gICAgICAgIHZhciBjbHVzdGVyTGVmdCA9IGtlZXBDZW50ZXIgPyAoY2VudGVyWCAtIGMud2lkdGggLyAyKSA6IGMubGVmdDtcclxuICAgICAgICB2YXIgaXNUZXh0T25seUNsdXN0ZXIgPSBoYXNUZXh0SW5DbHVzdGVyICYmICFoYXNOb25UZXh0SW5DbHVzdGVyO1xyXG4gICAgICAgIHZhciBzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlciA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpc011bHRpQ29sTGF5b3V0KSB7XHJcbiAgICAgICAgICAvLyBNb2RvIGxlY3R1cmEgbW9iaWxlIG11bHRpLWNvbDpcclxuICAgICAgICAgIC8vIHVzYXIgdW5hIG1pc21hIHJlZmVyZW5jaWEgWCBwYXJhIHRvZGEgbGEgY29sdW1uYSBhcGlsYWRhIHlcclxuICAgICAgICAgIC8vIHByZXNlcnZhciBlbCBvZmZzZXQgaG9yaXpvbnRhbCBvcmlnaW5hbCBkZSBjYWRhIGNsdXN0ZXIuXHJcbiAgICAgICAgICAvLyBFc3RvIG1hbnRpZW5lIGFsaW5lYWRvIHRleHRvL2Zvcm1hIGN1YW5kbyBsYSBjb2x1bW5hIHNlIHBhcnRlXHJcbiAgICAgICAgICAvLyBlbiB2YXJpb3MgY2x1c3RlcnMuXHJcbiAgICAgICAgICAvLyBTaSBlbCBiYm94IGRlIGxhIGNvbHVtbmEgcXVlZGEgY29udGFtaW5hZG8gcG9yIHVuIG91dGxpZXIgYW5jaG9cclxuICAgICAgICAgIC8vICh0aXBpY2FtZW50ZSB0ZXh0byksIGNlbnRyYXIgcG9yIG9mZnNldHMgZGVqYSBsYSBjb2x1bW5hIHBlZ2FkYVxyXG4gICAgICAgICAgLy8gYWwgYm9yZGU7IGVuIGVzZSBjYXNvIGNlbnRyYW1vcyBjYWRhIGNsdXN0ZXIgaW5kaXZpZHVhbG1lbnRlLlxyXG4gICAgICAgICAgaWYgKHByZXNlcnZlQ29sdW1uT2Zmc2V0cykge1xyXG4gICAgICAgICAgICB2YXIgcmVsQ2x1c3RlckxlZnQgPSAoYy5sZWZ0IHx8IDApIC0gKGdyb3VwTWluTGVmdCB8fCAwKTtcclxuICAgICAgICAgICAgY2x1c3RlckxlZnQgPSBncm91cEJhc2VMZWZ0ICsgcmVsQ2x1c3RlckxlZnQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQZXJtaXRlIGZvcnphciBjZW50cmFkbyBwb3IgY2x1c3RlciBzaSBlbCBub2RvIGxvIHBpZGUuXHJcbiAgICAgICAgICBpZiAoZm9yY2VDZW50ZXIpIGNsdXN0ZXJMZWZ0ID0gY2VudGVyWCAtIGMud2lkdGggLyAyO1xyXG5cclxuICAgICAgICAgIC8vIFNpIGVzdGEgY29sdW1uYSB0aWVuZSB1biBjbHVzdGVyIGNvbiBmb3JtYSAobyBtaXh0byksIHVzYW1vcyBzdVxyXG4gICAgICAgICAgLy8gY2VudHJvIGNvbW8gcmVmZXJlbmNpYSBwYXJhIGFsaW5lYXIgY2x1c3RlcnMgc29sby10ZXh0byBkZWJham8uXHJcbiAgICAgICAgICB2YXIgY2x1c3RlclJlZkNlbnRlclggPSBOYU47XHJcbiAgICAgICAgICBpZiAoaGFzTm9uVGV4dEluQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAvLyBSZWZlcmVuY2lhIGJhc2FkYSBlbiBpdGVtcyBuby10ZXh0byAoZm9ybWEvaWNvbm8pLCBubyBlbiB0b2RvIGVsXHJcbiAgICAgICAgICAgIC8vIGNsdXN0ZXIsIHBhcmEgcXVlIHRleHRvcyBsYXJnb3Mgbm8gZGVzcGxhY2VuIGVsIGNlbnRybyBkZSBjb2x1bW5hLlxyXG4gICAgICAgICAgICB2YXIgbnRNaW5SZWwgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG50TWF4UmVsID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBudGk9MDsgbnRpPGMuaXRlbXMubGVuZ3RoOyBudGkrKyl7XHJcbiAgICAgICAgICAgICAgdmFyIG50SXQgPSBjLml0ZW1zW250aV07XHJcbiAgICAgICAgICAgICAgdmFyIG50SXNUZXh0ID0gKG50SXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgICAgICBpZiAobnRJc1RleHQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIG50TWluUmVsID0gTWF0aC5taW4obnRNaW5SZWwsIChudEl0Ll9yZWxMZWZ0IHx8IDApKTtcclxuICAgICAgICAgICAgICBudE1heFJlbCA9IE1hdGgubWF4KG50TWF4UmVsLCAobnRJdC5fcmVsTGVmdCB8fCAwKSArIChudEl0LndpZHRoIHx8IDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSBOYU47XHJcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShudE1pblJlbCkgJiYgaXNGaW5pdGUobnRNYXhSZWwpICYmIG50TWF4UmVsID4gbnRNaW5SZWwpIHtcclxuICAgICAgICAgICAgICBjbHVzdGVyUmVmQ2VudGVyWCA9IGNsdXN0ZXJMZWZ0ICsgKChudE1pblJlbCArIG50TWF4UmVsKSAvIDIpO1xyXG4gICAgICAgICAgICAgIHNvdXJjZUNsdXN0ZXJSZWZDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArICgobnRNaW5SZWwgKyBudE1heFJlbCkgLyAyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjbHVzdGVyUmVmQ2VudGVyWCA9IGNsdXN0ZXJMZWZ0ICsgYy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclggPSBOdW1iZXIoY2x1c3RlclJlZkNlbnRlclgpO1xuICAgICAgICAgICAgY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCA9IE51bWJlcihzb3VyY2VDbHVzdGVyUmVmQ2VudGVyWCk7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvbFJlZmVyZW5jZUNlbnRlclgpKSBjb2xSZWZlcmVuY2VDZW50ZXJYID0gTmFOO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYKSkgY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCA9IE5hTjtcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGlzVGV4dE9ubHlDbHVzdGVyKSB7XHJcbiAgICAgICAgICAgIC8vIE1hbnRlbmVyIHBvc2ljaW9uIGRlIGNsdXN0ZXIgYWxpbmVhZGEgY29uIGxhIGNvbHVtbmEgY2VudHJhZGFcclxuICAgICAgICAgICAgLy8gc2luIHRvY2FyIGxhIGFsaW5lYWNpb24gaW50ZXJuYSBkZWwgdGV4dG8uXHJcbiAgICAgICAgICAgIHZhciBjZW50ZXJlZENsdXN0ZXJMZWZ0ID0gY2VudGVyWCAtIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpIHtcclxuICAgICAgICAgICAgICB2YXIgbWF4U25hcERlbHRhID0gTWF0aC5taW4oMTIwLCBpbmZvLnVzYWJsZVcgKiAwLjM1KTtcclxuICAgICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlckNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0WCA9IGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXHJcbiAgICAgICAgICAgICAgICA/IChzb3VyY2VDbHVzdGVyQ2VudGVyWCAtIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXHJcbiAgICAgICAgICAgICAgICA6IE5hTjtcclxuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRYKSAmJiBNYXRoLmFicyhzb3VyY2VEcmlmdFgpIDw9IG1heFNuYXBEZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyaWZ0ZWRDbHVzdGVyTGVmdCA9IChjb2xSZWZlcmVuY2VDZW50ZXJYICsgc291cmNlRHJpZnRYKSAtIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyaWZ0ZWRDbHVzdGVyQ2VudGVyWCA9IGRyaWZ0ZWRDbHVzdGVyTGVmdCArIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heFJlZkRyaWZ0ID0gTWF0aC5tYXgoMTIsIGluZm8udXNhYmxlVyAqIDAuMDYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRyaWZ0ZWRDbHVzdGVyQ2VudGVyWCAtIGNlbnRlclgpIDw9IG1heFJlZkRyaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNlbnRlcmVkQ2x1c3RlckxlZnQgPSBkcmlmdGVkQ2x1c3RlckxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsdXN0ZXJMZWZ0ID0gY2VudGVyZWRDbHVzdGVyTGVmdDtcclxuICAgICAgICAgICAgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBHdWFyZCByYWlsOiBlbiBhcGlsYWRvIG11bHRpLWNvbHVtbmEsIHVuIGNsdXN0ZXIgbm8gZGViZSBxdWVkYXJcclxuICAgICAgICAgIC8vIGRlc3ZpYWRvIGRlbWFzaWFkbyBkZWwgZWplIGNlbnRyYWwgZGVsIGxheW91dCBtb2JpbGUuXHJcbiAgICAgICAgICB2YXIgY2x1c3RlckNlbnRlclhOb3cgPSBjbHVzdGVyTGVmdCArIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgdmFyIG1heENlbnRlckRyaWZ0ID0gTWF0aC5tYXgoMjQsIGluZm8udXNhYmxlVyAqIDAuMTgpO1xyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGNsdXN0ZXJDZW50ZXJYTm93IC0gY2VudGVyWCkgPiBtYXhDZW50ZXJEcmlmdCkge1xyXG4gICAgICAgICAgICBtc2xMb2coXCJzdGFjazpjbHVzdGVyOmNlbnRlckZhbGxiYWNrXCIsIHtcclxuICAgICAgICAgICAgICBnOiBnLFxyXG4gICAgICAgICAgICAgIGo6IGosXHJcbiAgICAgICAgICAgICAgcHJldkxlZnQ6ICtjbHVzdGVyTGVmdC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgIGNlbnRlclg6ICtjZW50ZXJYLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgY2x1c3RlckNlbnRlclg6ICtjbHVzdGVyQ2VudGVyWE5vdy50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgIG1heENlbnRlckRyaWZ0OiArbWF4Q2VudGVyRHJpZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICBjbHVzdGVyVzogKyhjLndpZHRoIHx8IDApLnRvRml4ZWQoMSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJMZWZ0ID0gY2VudGVyWCAtIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtc2xMb2coXCJzdGFjazpjbHVzdGVyXCIsIHtcbiAgICAgICAgICBnOiBnLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgb3JpZ1RvcDogK2MudG9wLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBvcmlnTGVmdDogK2MubGVmdC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgbmV3VG9wOiArY2x1c3RlclRvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgbmV3TGVmdDogK2NsdXN0ZXJMZWZ0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcclxuICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBmb3JjZUNlbnRlcjogZm9yY2VDZW50ZXIsXHJcbiAgICAgICAgICBrZWVwQ2VudGVyOiBrZWVwQ2VudGVyLFxyXG4gICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgY29sUmVmZXJlbmNlQ2VudGVyWDogKHR5cGVvZiBjb2xSZWZlcmVuY2VDZW50ZXJYID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGNvbFJlZmVyZW5jZUNlbnRlclgpKSA/ICtjb2xSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgIGlzVGV4dE9ubHlDbHVzdGVyOiBpc1RleHRPbmx5Q2x1c3RlcixcbiAgICAgICAgICBjZW50ZXJTaG9ydFRleHQ6IHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyXG4gICAgICAgIH0pO1xuXHJcbiAgICAgICAgdmFyIHRleHRDb3VudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgdGM9MDsgdGM8Yy5pdGVtcy5sZW5ndGg7IHRjKyspe1xyXG4gICAgICAgICAgaWYgKChjLml0ZW1zW3RjXS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSB0ZXh0Q291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxpbmVhcml6ZUNsdXN0ZXIgPSAobW9kZSA9PT0gXCJyb3dzXCIgJiYgYy5pdGVtcy5sZW5ndGggPiAxICYmIHRleHRDb3VudCA+PSAyKTtcclxuICAgICAgICB2YXIgY2x1c3RlckJvdHRvbVVzZWQgPSBjbHVzdGVyVG9wICsgYy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIENhc28gZXNwZWNpYWw6IGVuIHJvd3MsIHNpIGVsIGNsdXN0ZXIgYWdydXBhIHZhcmlvcyB0ZXh0b3MsIGxvXHJcbiAgICAgICAgLy8gY29udmVydGltb3MgYSBmbHVqbyB2ZXJ0aWNhbCBjZW50cmFkbyBwYXJhIGV2aXRhciB0ZXh0byBsYWRvIGEgbGFkby5cclxuICAgICAgICBpZiAobGluZWFyaXplQ2x1c3Rlcil7XHJcbiAgICAgICAgICB2YXIgYWxsSXRlbXMgPSBjLml0ZW1zLnNsaWNlKCk7XHJcbiAgICAgICAgICB2YXIgbm9uVGV4dCA9IGFsbEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdHgpe1xyXG4gICAgICAgICAgICByZXR1cm4gKGl0eC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgIT09IFwiMVwiO1xyXG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdmFyIHRleHRzID0gYWxsSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0eCl7XHJcbiAgICAgICAgICAgIHJldHVybiAoaXR4Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgIGlmIChhLnRvcCAhPT0gYi50b3ApIHJldHVybiBhLnRvcCAtIGIudG9wO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gT3JkZW4gc2Vtw4PCoW50aWNvIGRlIGxlY3R1cmE6XHJcbiAgICAgICAgICAvLyBuby10ZXh0byArIHRleHRvIG3Dg8KhcyBjZXJjYW5vIChkZWJham8geSBwb3IgZWplIFgpLCBsdWVnbyByZW1hbmVudGVzLlxyXG4gICAgICAgICAgdmFyIG9yZGVyZWQgPSBbXTtcclxuICAgICAgICAgIHZhciB1c2VkVGV4dCA9IHt9O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIG50PTA7IG50PG5vblRleHQubGVuZ3RoOyBudCsrKXtcclxuICAgICAgICAgICAgdmFyIG50SXRlbSA9IG5vblRleHRbbnRdO1xyXG4gICAgICAgICAgICBvcmRlcmVkLnB1c2gobnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBudEN4ID0gKG50SXRlbS5sZWZ0IHx8IDApICsgKG50SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBudEJvdHRvbSA9IChudEl0ZW0udG9wIHx8IDApICsgKG50SXRlbS5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIHZhciBiZXN0SWR4VHh0ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBiZXN0U2NvcmUgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHR4PTA7IHR4PHRleHRzLmxlbmd0aDsgdHgrKyl7XHJcbiAgICAgICAgICAgICAgaWYgKHVzZWRUZXh0W3R4XSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgdmFyIHRJdGVtID0gdGV4dHNbdHhdO1xyXG4gICAgICAgICAgICAgIHZhciB0Q3ggPSAodEl0ZW0ubGVmdCB8fCAwKSArICh0SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHZHYXBUeHQgPSAodEl0ZW0udG9wIHx8IDApIC0gbnRCb3R0b207IC8vIHByZWZlcmlyIHRleHRvIGRlYmFqb1xyXG4gICAgICAgICAgICAgIHZhciBoRGlzdFR4dCA9IE1hdGguYWJzKHRDeCAtIG50Q3gpO1xyXG4gICAgICAgICAgICAgIHZhciBwZW5hbHR5QWJvdmUgPSB2R2FwVHh0IDwgLTIgPyAxMDAwMCA6IDA7XHJcbiAgICAgICAgICAgICAgdmFyIHNjb3JlID0gcGVuYWx0eUFib3ZlICsgTWF0aC5hYnModkdhcFR4dCkgKiAyICsgaERpc3RUeHQ7XHJcbiAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKXtcclxuICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICAgICAgYmVzdElkeFR4dCA9IHR4O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJlc3RJZHhUeHQgPj0gMCl7XHJcbiAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKHRleHRzW2Jlc3RJZHhUeHRdKTtcclxuICAgICAgICAgICAgICB1c2VkVGV4dFtiZXN0SWR4VHh0XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBUZXh0b3Mgbm8gZW1wYXJlamFkb3NcclxuICAgICAgICAgIGZvciAodmFyIHR4Mj0wOyB0eDI8dGV4dHMubGVuZ3RoOyB0eDIrKyl7XHJcbiAgICAgICAgICAgIGlmICghdXNlZFRleHRbdHgyXSkgb3JkZXJlZC5wdXNoKHRleHRzW3R4Ml0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNpIG5vIGh1Ym8gbm8tdGV4dG8sIGZhbGxiYWNrIHNpbXBsZSBwb3IgdG9wL2xlZnRcclxuICAgICAgICAgIGlmICghb3JkZXJlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgb3JkZXJlZCA9IGFsbEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgbG9jYWxDdXJzb3IgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIHByZXZJdCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgcHJldlRvcEFwcGxpZWQgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIEVYVFJBX0NPTF9CUkVBS19HQVAgPSA4O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGxpPTA7IGxpPG9yZGVyZWQubGVuZ3RoOyBsaSsrKXtcclxuICAgICAgICAgICAgdmFyIGxpdCA9IG9yZGVyZWRbbGldO1xyXG5cclxuICAgICAgICAgICAgdmFyIGtlZXBMYXlvdXRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgICAgaWYgKGtlZXBMYXlvdXRMaW4pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1RvcExpbiA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgICBpZiAocHJldkl0KXtcclxuICAgICAgICAgICAgICB2YXIgZ2FwT3JpZ0xpbiA9IGxpdC50b3AgLSAocHJldkl0LnRvcCArIHByZXZJdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZ2FwT3JpZ0xpbikpIGdhcE9yaWdMaW4gPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBnYXBXYW50ZWRMaW4gPSBjbGFtcChnYXBPcmlnTGluICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XHJcbiAgICAgICAgICAgICAgdmFyIHByZXZJc1RleHRMaW4gPSAocHJldkl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgdmFyIGN1cnJJc1RleHRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgLy8gQWwgcGFzYXIgZGUgXCJ0ZXh0byBmaW5hbCBkZSBjb2x1bW5hXCIgYSBcIm51ZXZvIG5vLXRleHRvXCIgYWdyZWdhbW9zIGFpcmUuXHJcbiAgICAgICAgICAgICAgaWYgKHByZXZJc1RleHRMaW4gJiYgIWN1cnJJc1RleHRMaW4pIGdhcFdhbnRlZExpbiArPSBFWFRSQV9DT0xfQlJFQUtfR0FQO1xyXG4gICAgICAgICAgICAgIG5ld1RvcExpbiA9IHByZXZUb3BBcHBsaWVkICsgcHJldkl0LmhlaWdodCArIGdhcFdhbnRlZExpbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ld0xlZnRMaW4gPSBjZW50ZXJYIC0gKGxpdC53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBrZWVwQWxpZ25MaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIikgPT09IFwia2VlcFwiO1xyXG4gICAgICAgICAgICBpZiAoa2VlcEFsaWduTGluKSBuZXdMZWZ0TGluID0gbGl0LmxlZnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3VG9wTGluIC0gbGl0LnRvcCkgPiAwLjUgfHwgTWF0aC5hYnMobmV3TGVmdExpbiAtIGxpdC5sZWZ0KSA+IDAuNSkgY2hhbmdlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBFbiByb3dzIGxpbmVhbGl6YWRvLCBmb3J6YW1vcyBjZW50cmFkbyB2aXN1YWwgcmVhbCBkZSB0ZXh0by5cclxuICAgICAgICAgICAgdmFyIGlzVGV4dExpbiA9IChsaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgICAgaWYgKGlzVGV4dExpbiAmJiAha2VlcEFsaWduTGluKSB7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgICB2YXIgdGZMaW4gPSBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIjtcclxuICAgICAgICAgICAgICBpZiAodGZMaW4uaW5kZXhPZihcInRyYW5zbGF0ZVgoXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gdGZMaW4ucmVwbGFjZSgvdHJhbnNsYXRlWFxcKFteKV0qXFwpLywgXCJ0cmFuc2xhdGVYKDBweClcIik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY3NzTGVmdExpbiA9IG5ld0xlZnRMaW4gLSAoaW5mby5wYWRMIHx8IDApO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50b3AgPSBuZXdUb3BMaW4gKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLmxlZnQgPSBjc3NMZWZ0TGluICsgXCJweFwiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcclxuXHJcbiAgICAgICAgICAgIHByZXZJdCA9IGxpdDtcclxuICAgICAgICAgICAgcHJldlRvcEFwcGxpZWQgPSBuZXdUb3BMaW47XHJcbiAgICAgICAgICAgIGxvY2FsQ3Vyc29yID0gbmV3VG9wTGluICsgKGxpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEN1cnNvciA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcGxpY2FyIGEgY2FkYSBpdGVtIHByZXNlcnZhbmRvIG9mZnNldHMgcmVsYXRpdm9zIChzb2xhcGUgaW50YWN0bylcbiAgICAgICAgZm9yICh2YXIgaWk9MDsgaWk8Yy5pdGVtcy5sZW5ndGg7IGlpKyspe1xuICAgICAgICAgIHZhciBpdCA9IGMuaXRlbXNbaWldO1xuICAgICAgICAgIHZhciBpc1RleHROb2RlID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG5cbiAgICAgICAgICAvLyBPcHQtb3V0IHRvdGFsIGRlbCBsYXlvdXQgKGRlY29yYWNpb25lcywgZXRjLilcbiAgICAgICAgICB2YXIga2VlcExheW91dCA9IChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBMYXlvdXQpIGNvbnRpbnVlO1xuXHJcbiAgICAgICAgICB2YXIgbmV3VG9wID0gY2x1c3RlclRvcCArIChpdC5fcmVsVG9wIHx8IDApO1xyXG4gICAgICAgICAgdmFyIG5ld0xlZnQgPSBjbHVzdGVyTGVmdCArIChpdC5fcmVsTGVmdCB8fCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IGRlIGNlbnRyYWRvIChtYW50ZW5lciBsZWZ0IG9yaWdpbmFsIGRlbCBpdGVtKVxuICAgICAgICAgIHZhciBrZWVwQWxpZ24gPSAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1hbGlnblwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBBbGlnbikgbmV3TGVmdCA9IGl0LmxlZnQ7XG5cclxuICAgICAgICAgIC8vIEVuIG11bHRpLWNvbCwgbmV1dHJhbGl6YW1vcyBTSUVNUFJFIHRyYW5zbGF0ZVgoLi4uKSBkZSB0ZXh0b3NcclxuICAgICAgICAgIC8vIHBhcmEgcXVlIGxhIHBvc2ljacODwrNuIGxlZnQgY2FsY3VsYWRhIHNlYSBsYSByZWZlcmVuY2lhIHZpc3VhbCByZWFsLlxyXG4gICAgICAgICAgdmFyIGlzU2hvcnRUZXh0Qm94ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNob3VsZFJlY2VudGVyVGV4dEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVjZW50ZXJHdWFyZEJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2VudGVyQnlBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0YXJnZXRUZXh0Q2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZSAmJiBpc011bHRpQ29sTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZiA9IGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIGlmICh0Zi5pbmRleE9mKFwidHJhbnNsYXRlWChcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0Zi5yZXBsYWNlKC90cmFuc2xhdGVYXFwoW14pXSpcXCkvLCBcInRyYW5zbGF0ZVgoMHB4KVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1Nob3J0VGV4dEJveCA9IChpdC53aWR0aCB8fCAwKSA8PSAoaW5mby51c2FibGVXICogMC41KSAmJiAoaXQuaGVpZ2h0IHx8IDApIDw9IDQyO1xyXG4gICAgICAgICAgICB2YXIgdGFDdXJyZW50ID0gKChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBjZW50ZXJCeUFsaWduID0gdGFDdXJyZW50ID09PSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2VudGVyVmlzdWFsVGV4dCA9XHJcbiAgICAgICAgICAgICAgKHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyIHx8IGlzU2hvcnRUZXh0Qm94IHx8IGNlbnRlckJ5QWxpZ24pICYmXHJcbiAgICAgICAgICAgICAgIWtlZXBBbGlnbjtcclxuICAgICAgICAgICAgc2hvdWxkUmVjZW50ZXJUZXh0SXRlbSA9XG4gICAgICAgICAgICAgIHNob3VsZENlbnRlclZpc3VhbFRleHQgJiZcbiAgICAgICAgICAgICAgIWlzVGV4dE9ubHlDbHVzdGVyICYmXG4gICAgICAgICAgICAgIGlzRmluaXRlKGNvbFJlZmVyZW5jZUNlbnRlclgpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlY2VudGVyVGV4dEl0ZW0pIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZMZWZ0VHh0ID0gbmV3TGVmdDtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDZW50ZXJYID0gcHJldkxlZnRUeHQgKyAoaXQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgICB2YXIgc291cmNlSXRlbUNlbnRlclggPSAoaXQubGVmdCB8fCAwKSArIChpdC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VEcmlmdEl0ZW1YID0gaXNGaW5pdGUoY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgICA/IChzb3VyY2VJdGVtQ2VudGVyWCAtIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXG4gICAgICAgICAgICAgICAgOiBOYU47XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRDZW50ZXJYID0gY29sUmVmZXJlbmNlQ2VudGVyWDtcbiAgICAgICAgICAgICAgLy8gRW4gdGV4dG9zIGNlbnRyYWRvcyAobyBsYWJlbHMgY29ydG9zIGZvcnphZG9zIGFsIGNlbnRybyksXHJcbiAgICAgICAgICAgICAgLy8gbm8gYXJyYXN0cmFtb3MgZHJpZnQgaG9yaXpvbnRhbCBkZWwgbGF5b3V0IG9yaWdpbmFsIHBhcmFcclxuICAgICAgICAgICAgICAvLyBldml0YXIgY29ycmltaWVudG9zIGxhdGVyYWxlcyBlbiBtb2JpbGUuXHJcbiAgICAgICAgICAgICAgdmFyIHByZXNlcnZlU291cmNlRHJpZnQgPVxyXG4gICAgICAgICAgICAgICAgIWNlbnRlckJ5QWxpZ24gJiZcclxuICAgICAgICAgICAgICAgICFzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlciAmJlxyXG4gICAgICAgICAgICAgICAgIWlzU2hvcnRUZXh0Qm94O1xyXG4gICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVNvdXJjZURyaWZ0ICYmIGlzRmluaXRlKHNvdXJjZURyaWZ0SXRlbVgpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyWCArPSBzb3VyY2VEcmlmdEl0ZW1YO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEd1YXJkIHJhaWw6IHNpIGxhIHJlY29ycmVjY2lvbiBwcm9wdWVzdGEgc2UgYWxlamEgZGVtYXNpYWRvIGRlbFxuICAgICAgICAgICAgICAvLyBjZW50cm8geWEgY2FsY3VsYWRvIHBhcmEgZWwgY2x1c3Rlciwgbm8gbGEgYXBsaWNhbW9zLlxuICAgICAgICAgICAgICB2YXIgbWF4UmVjZW50ZXJTaGlmdCA9IE1hdGgubWF4KDE4LCBpbmZvLnVzYWJsZVcgKiAwLjA4KTtcbiAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGN1cnJlbnRDZW50ZXJYKSAmJiBpc0Zpbml0ZSh0YXJnZXRDZW50ZXJYKSAmJiBNYXRoLmFicyh0YXJnZXRDZW50ZXJYIC0gY3VycmVudENlbnRlclgpID4gbWF4UmVjZW50ZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgIHJlY2VudGVyR3VhcmRCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzaG91bGRSZWNlbnRlclRleHRJdGVtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyWCA9IGN1cnJlbnRDZW50ZXJYO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldFRleHRDZW50ZXJYID0gdGFyZ2V0Q2VudGVyWDtcbiAgICAgICAgICAgICAgbmV3TGVmdCA9IHRhcmdldENlbnRlclggLSAoaXQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3TGVmdCAtIHByZXZMZWZ0VHh0KSA+IDAuNSkge1xuICAgICAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOml0ZW06dGV4dFJlY2VudGVyXCIsIHtcbiAgICAgICAgICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgICAgICAgICBqOiBqLFxyXG4gICAgICAgICAgICAgICAgICBpaTogaWksXHJcbiAgICAgICAgICAgICAgICAgIHByZXZMZWZ0OiArcHJldkxlZnRUeHQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgbmV3TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgaXRlbVc6ICsoaXQud2lkdGggfHwgMCkudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgcmVmQ2VudGVyWDogK2NvbFJlZmVyZW5jZUNlbnRlclgudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgc291cmNlUmVmQ2VudGVyWDogKHR5cGVvZiBjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpKSA/ICtjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc291cmNlRHJpZnRYOiBpc0Zpbml0ZShzb3VyY2VEcmlmdEl0ZW1YKSA/ICtzb3VyY2VEcmlmdEl0ZW1YLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcHJlc2VydmVTb3VyY2VEcmlmdDogcHJlc2VydmVTb3VyY2VEcmlmdCxcbiAgICAgICAgICAgICAgICAgIGd1YXJkQmxvY2tlZDogcmVjZW50ZXJHdWFyZEJsb2NrZWQsXG4gICAgICAgICAgICAgICAgICBzaG9ydEJveDogaXNTaG9ydFRleHRCb3gsXG4gICAgICAgICAgICAgICAgICBjZW50ZXJCeUFsaWduOiBjZW50ZXJCeUFsaWduXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRDZW50ZXJWaXN1YWxUZXh0KSB7XHJcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgLy8gRXZpdGEgZW5jb2dpbWllbnRvIGhvcml6b250YWwgaGVyZWRhZG8gcXVlIGRlc3BsYXphIGVsIGNlbnRybyB2aXN1YWwuXHJcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBjc3NMZWZ0ID0gbmV3TGVmdCAtIChpbmZvLnBhZEwgfHwgMCk7XHJcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLnRvcCA9IG5ld1RvcCArIFwicHhcIjtcclxuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IGNzc0xlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xyXG5cclxuICAgICAgICAgIC8vIENvcnJlY2Npw4PCs24gZmluYWwgcG9yIHBvc2ljacODwrNuIHJlbmRlcml6YWRhIHJlYWwgZGVsIHRleHRvXHJcbiAgICAgICAgICAvLyAoZnVlbnRlcy90cmFuc2Zvcm0gcHVlZGVuIGludHJvZHVjaXIgZGVzdsODwq1vcyB2aXN1YWxlcyBzdWItcMODwq14ZWwpLlxyXG4gICAgICAgICAgaWYgKGlzVGV4dE5vZGUgJiYgaXNNdWx0aUNvbExheW91dCAmJiBzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICB2YXIgcnJUeHQgPSByZWxSZWN0KGl0Lm5vZGUsIHJvb3RFbCk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRDZW50ZXJYID0gKHJyVHh0LmxlZnQgfHwgMCkgKyAocnJUeHQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgdmFyIHRhcmdldFJlbmRlckNlbnRlclggPSBpc0Zpbml0ZSh0YXJnZXRUZXh0Q2VudGVyWCkgPyB0YXJnZXRUZXh0Q2VudGVyWCA6IGNvbFJlZmVyZW5jZUNlbnRlclg7XG4gICAgICAgICAgICB2YXIgcmVuZGVyRGVsdGEgPSByZW5kZXJlZENlbnRlclggLSB0YXJnZXRSZW5kZXJDZW50ZXJYO1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUocmVuZGVyRGVsdGEpICYmIE1hdGguYWJzKHJlbmRlckRlbHRhKSA+IDAuNikge1xyXG4gICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRMZWZ0ID0gbmV3TGVmdCAtIHJlbmRlckRlbHRhO1xyXG4gICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb3JyZWN0ZWRMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgbXNsTG9nKFwic3RhY2s6aXRlbTp0ZXh0UmVuZGVyQWRqdXN0XCIsIHtcclxuICAgICAgICAgICAgICAgICAgZzogZyxcclxuICAgICAgICAgICAgICAgICAgajogaixcclxuICAgICAgICAgICAgICAgICAgaWk6IGlpLFxyXG4gICAgICAgICAgICAgICAgICBwcmV2TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgY29ycmVjdGVkTGVmdDogK2NvcnJlY3RlZExlZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDZW50ZXJYOiArcmVuZGVyZWRDZW50ZXJYLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgICAgIHJlZkNlbnRlclg6ICt0YXJnZXRSZW5kZXJDZW50ZXJYLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiArcmVuZGVyRGVsdGEudG9GaXhlZCgyKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBuZXdMZWZ0ID0gY29ycmVjdGVkTGVmdDtcclxuICAgICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IChuZXdMZWZ0IC0gKGluZm8ucGFkTCB8fCAwKSkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdUb3AgLSBpdC50b3ApID4gMC41IHx8IE1hdGguYWJzKG5ld0xlZnQgLSBpdC5sZWZ0KSA+IDAuNSkgY2hhbmdlZCA9IHRydWU7XG5cclxuICAgICAgICAgIHZhciBpdGVtQm90dG9tID0gbmV3VG9wICsgKGl0LmhlaWdodCB8fCAwKTtcclxuICAgICAgICAgIGlmIChpdGVtQm90dG9tID4gY2x1c3RlckJvdHRvbVVzZWQpIGNsdXN0ZXJCb3R0b21Vc2VkID0gaXRlbUJvdHRvbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF2YW56YSBlbCBjdXJzb3IgbG9jYWwgYWwgZmluYWwgZGVsIGNsdXN0ZXJcclxuICAgICAgICBjb2xDdXJzb3IgPSBNYXRoLm1heChjb2xDdXJzb3IsIGNsdXN0ZXJCb3R0b21Vc2VkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWwgdGVybWluYXIgbGEgY29sdW1uYSwgZWwgY3Vyc29yIGdsb2JhbCBiYWphIGhhc3RhIGRvbmRlIGxsZWfDg8KzIGVzdGEgY29sdW1uYVxyXG4gICAgICBnbG9iYWxDdXJzb3IgPSBNYXRoLm1heChnbG9iYWxDdXJzb3IsIGNvbEN1cnNvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5lZWRlZCA9IGdsb2JhbEN1cnNvciArIENGRy5QQURfQk9UO1xyXG4gICAgbXNsTG9nKFwic3RhY2s6ZW5kXCIsIHtcclxuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcclxuICAgICAgbmVlZGVkSGVpZ2h0OiArbmVlZGVkLnRvRml4ZWQoMSksXHJcbiAgICAgIGZpbmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSlcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgY2hhbmdlZDogY2hhbmdlZCwgbmVlZGVkSGVpZ2h0OiBuZWVkZWQgfTtcclxuICB9XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc1N0YWNraW5nQmxvY2siLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartLayout/stacking.ts\n");

/***/ }),

/***/ "(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartSectionLayout.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMobileSmartSectionLayoutScript: () => (/* binding */ buildMobileSmartSectionLayoutScript)\n/* harmony export */ });\n/* harmony import */ var _mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobileSmartLayout */ \"(pages-dir-node)/./functions/src/utils/mobileSmartLayout/index.ts\");\n// functions/src/utils/mobileSmartSectionLayout.ts\n\nfunction buildMobileSmartSectionLayoutScript(opts) {\n    const cfg = (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)(opts);\n    return (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.buildScript)(cfg);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBRWlCO0FBRTVELFNBQVNFLG9DQUFvQ0MsSUFBOEI7SUFDaEYsTUFBTUMsTUFBTUosbUVBQWVBLENBQUNHO0lBQzVCLE9BQU9GLCtEQUFXQSxDQUFDRztBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHNcclxuaW1wb3J0IHsgTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zIH0gZnJvbSBcIi4vbW9iaWxlU21hcnRMYXlvdXRcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplQ29uZmlnLCBidWlsZFNjcmlwdCB9IGZyb20gXCIuL21vYmlsZVNtYXJ0TGF5b3V0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQob3B0czogTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBjZmcgPSBub3JtYWxpemVDb25maWcob3B0cyk7XHJcbiAgcmV0dXJuIGJ1aWxkU2NyaXB0KGNmZyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUNvbmZpZyIsImJ1aWxkU2NyaXB0IiwiYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQiLCJvcHRzIiwiY2ZnIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./functions/src/utils/mobileSmartSectionLayout.ts\n");

/***/ })

};
;