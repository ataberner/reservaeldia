"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_functions_src_utils_generarHTMLDesdeSecciones_ts"],{

/***/ "(pages-dir-browser)/./functions/src/models/lineConstants.ts":
/*!***********************************************!*\
  !*** ./functions/src/models/lineConstants.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LINE_CONSTANTS: () => (/* binding */ LINE_CONSTANTS)\n/* harmony export */ });\n// functions/src/models/lineConstants.ts\n// Mismas constantes para el backend (TypeScript)\nconst LINE_CONSTANTS = {\n    STROKE_WIDTH: 2,\n    HIT_STROKE_WIDTH: 15,\n    DEFAULT_LENGTH: 100,\n    DEFAULT_COLOR: \"#000000\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvbW9kZWxzL2xpbmVDb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDMUMsTUFBTUEsaUJBQWlCO0lBQzVCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0FBQ2pCLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFxtb2RlbHNcXGxpbmVDb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy9tb2RlbHMvbGluZUNvbnN0YW50cy50c1xyXG4vLyBNaXNtYXMgY29uc3RhbnRlcyBwYXJhIGVsIGJhY2tlbmQgKFR5cGVTY3JpcHQpXHJcbmV4cG9ydCBjb25zdCBMSU5FX0NPTlNUQU5UUyA9IHtcclxuICBTVFJPS0VfV0lEVEg6IDIsXHJcbiAgSElUX1NUUk9LRV9XSURUSDogMTUsXHJcbiAgREVGQVVMVF9MRU5HVEg6IDEwMCxcclxuICBERUZBVUxUX0NPTE9SOiBcIiMwMDAwMDBcIlxyXG59OyJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsIlNUUk9LRV9XSURUSCIsIkhJVF9TVFJPS0VfV0lEVEgiLCJERUZBVUxUX0xFTkdUSCIsIkRFRkFVTFRfQ09MT1IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/models/lineConstants.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeObjetos.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeObjetos.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   generarHTMLDesdeObjetos: () => (/* binding */ generarHTMLDesdeObjetos)\n/* harmony export */ });\n/* harmony import */ var _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/lineConstants */ \"(pages-dir-browser)/./functions/src/models/lineConstants.ts\");\n\n// ✅ Escapar strings para meterlos en atributos/HTML\nfunction escHTML() {\n    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return String(str).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction escapeAttr() {\n    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction getLinkProps(obj) {\n    const raw = obj === null || obj === void 0 ? void 0 : obj.enlace;\n    if (!raw) return null;\n    if (typeof raw === \"string\") {\n        const href = escapeAttr(raw);\n        if (!href) return null;\n        return {\n            href,\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n        };\n    }\n    const href = escapeAttr(raw.href || \"\");\n    if (!href) return null;\n    const target = escapeAttr(raw.target || \"_blank\");\n    const rel = escapeAttr(raw.rel || \"noopener noreferrer\");\n    return {\n        href,\n        target,\n        rel\n    };\n}\nfunction envolverSiEnlace(htmlElemento, obj) {\n    if ((obj === null || obj === void 0 ? void 0 : obj.tipo) === \"rsvp-boton\") return htmlElemento;\n    const link = getLinkProps(obj);\n    if (!link) return htmlElemento;\n    return '<a href=\"'.concat(link.href, '\" target=\"').concat(link.target, '\" rel=\"').concat(link.rel, '\" style=\"text-decoration:none;color:inherit;display:contents\">').concat(htmlElemento, \"</a>\");\n}\nfunction escapeHTML() {\n    let texto = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return texto.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction generarHTMLDesdeObjetos(objetos, _secciones) {\n    const altoModoPorSeccion = new Map((_secciones || []).map((s)=>[\n            s.id,\n            String(s.altoModo || \"fijo\").toLowerCase()\n        ]));\n    function esSeccionPantalla(obj) {\n        const modo = altoModoPorSeccion.get(obj === null || obj === void 0 ? void 0 : obj.seccionId) || \"fijo\";\n        return modo === \"pantalla\";\n    }\n    function isFullBleed(obj) {\n        return String((obj === null || obj === void 0 ? void 0 : obj.anclaje) || \"\").toLowerCase() === \"fullbleed\";\n    }\n    /**\r\n   * ✅ Escala uniforme del CONTENIDO:\r\n   * - pantalla: var(--sfinal) (fit si hace falta)\r\n   * - fijo: var(--sx)\r\n   */ function sContenidoVar(obj) {\n        return esSeccionPantalla(obj) ? \"var(--sfinal)\" : \"var(--sx)\";\n    }\n    /**\r\n   * ✅ X scale:\r\n   * - fullBleed: var(--bx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sX(obj) {\n        return isFullBleed(obj) ? \"var(--bx)\" : sContenidoVar(obj);\n    }\n    /**\r\n   * ✅ Y scale:\r\n   * - fullBleed: var(--sx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sY(obj) {\n        return isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n    }\n    function pxX(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return \"calc(\".concat(sX(obj), \" * \").concat(n, \"px)\");\n    }\n    function pxY(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return \"calc(\".concat(sY(obj), \" * \").concat(n, \"px)\");\n    }\n    // ===========================\n    // ✅ PANTALLA: top por porcentaje\n    // ===========================\n    const ALTURA_EDITOR_PANTALLA = 500;\n    // ✅ Offsets en secciones Pantalla: ON\n    // ⚠️ IMPORTANTE: este archivo SOLO genera objetos.\n    // El valor DESKTOP/MOBILE real se controla vía CSS global con:\n    //   :root { --pantalla-y-offset: Xpx }\n    //   @media (max-width: 640px) { :root { --pantalla-y-offset: Ypx } }\n    //\n    // Acá dejamos fallback (desktop) por si la variable CSS no existe.\n    const PANTALLA_Y_OFFSET_DESKTOP_PX = -28;\n    function clamp01(n) {\n        const x = Number(n);\n        if (!Number.isFinite(x)) return null;\n        return Math.max(0, Math.min(1, x));\n    }\n    function getYPxEditor(obj) {\n        // ✅ En Pantalla ON: yNorm es la fuente de verdad (0..1)\n        const yn = clamp01(obj === null || obj === void 0 ? void 0 : obj.yNorm);\n        if (yn != null) return yn * ALTURA_EDITOR_PANTALLA;\n        // fallback: si no hay yNorm, usamos y como \"editor px\"\n        const yPx = Number(obj === null || obj === void 0 ? void 0 : obj.y);\n        if (Number.isFinite(yPx)) return yPx;\n        return 0;\n    }\n    /**\r\n   * ✅ topCSS:\r\n   * - Pantalla ON: usa var(--vh-logical) * yn\r\n   * - Texto en Pantalla ON: suma offset (CSS var) escalado por sContenidoVar\r\n   * - Fijo: pxY(obj, y)\r\n   */ function topCSS(obj) {\n        if (esSeccionPantalla(obj)) {\n            const yPxEditor = getYPxEditor(obj);\n            var _clamp01;\n            const yn = (_clamp01 = clamp01(yPxEditor / ALTURA_EDITOR_PANTALLA)) !== null && _clamp01 !== void 0 ? _clamp01 : 0;\n            // ✅ Altura “de diseño” escalada por el mismo factor que usan tamaños (sfinal)\n            const designScaledH = \"(\".concat(sContenidoVar(obj), \" * \").concat(ALTURA_EDITOR_PANTALLA, \"px)\");\n            // ✅ Centrado vertical: si el viewport lógico es más alto que el diseño escalado,\n            // agregamos un offset constante. (En desktop suele dar ~0 porque sfinal = vh/500)\n            const centerOffset = \"max(0px, calc((var(--vh-logical) - \".concat(designScaledH, \") / 2))\");\n            return \"calc(\\n  \".concat(centerOffset, \"\\n  + (\").concat(designScaledH, \" * \").concat(yn, \")\\n  + (\").concat(sContenidoVar(obj), \" * var(--pantalla-y-offset, \").concat(PANTALLA_Y_OFFSET_DESKTOP_PX, \"px))\\n)\");\n        }\n        const y = Number((obj === null || obj === void 0 ? void 0 : obj.y) || 0);\n        return pxY(obj, y);\n    }\n    /**\r\n   * ✅ Variante para cuando ya tenés yPx (en \"px editor\")\r\n   */ function topCSSFromYPx(obj, yPx) {\n        if (esSeccionPantalla(obj)) {\n            var _clamp01;\n            const yn = (_clamp01 = clamp01(yPx / ALTURA_EDITOR_PANTALLA)) !== null && _clamp01 !== void 0 ? _clamp01 : 0;\n            return \"calc((var(--vh-logical) * \".concat(yn, \") + (\").concat(sContenidoVar(obj), \" * var(--pantalla-y-offset, \").concat(PANTALLA_Y_OFFSET_DESKTOP_PX, \"px)))\");\n        }\n        return pxY(obj, yPx);\n    }\n    function stylePosBase(obj) {\n        const x = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0);\n        var _obj_rotation;\n        const rot = (_obj_rotation = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation !== void 0 ? _obj_rotation : 0;\n        var _obj_scaleX;\n        const scaleX = (_obj_scaleX = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX !== void 0 ? _obj_scaleX : 1;\n        var _obj_scaleY;\n        const scaleY = (_obj_scaleY = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY !== void 0 ? _obj_scaleY : 1;\n        const zIndex = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.zIndex) ? obj.zIndex : undefined;\n        return \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, x), \";\\ntop: \").concat(topCSS(obj), \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: top left;\\n\").concat(zIndex !== undefined ? \"z-index:\".concat(zIndex, \";\") : \"\", \"\\npointer-events: auto;\\n\").trim();\n    }\n    function styleSize(obj, w, h) {\n        const ww = Number.isFinite(w) ? w : undefined;\n        const hh = Number.isFinite(h) ? h : undefined;\n        const parts = [];\n        if (ww !== undefined) parts.push(\"width: \".concat(pxX(obj, ww), \";\"));\n        if (hh !== undefined) parts.push(\"height: \".concat(pxY(obj, hh), \";\"));\n        return parts.join(\"\\n\");\n    }\n    function renderIconoSvgNuevoInline(obj) {\n        const viewBox = obj.viewBox || \"0 0 24 24\";\n        const color = obj.color || \"#000\";\n        const paths = Array.isArray(obj.paths) ? obj.paths : [];\n        if (!paths.length) return \"\";\n        const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : 24;\n        const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : 24;\n        var _obj_rotation;\n        const rot = (_obj_rotation = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation !== void 0 ? _obj_rotation : 0;\n        var _obj_scaleX;\n        const scaleX = (_obj_scaleX = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX !== void 0 ? _obj_scaleX : 1;\n        var _obj_scaleY;\n        const scaleY = (_obj_scaleY = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY !== void 0 ? _obj_scaleY : 1;\n        const x = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0);\n        const yPx = getYPxEditor(obj);\n        const pathsHtml = paths.map((p)=>(p === null || p === void 0 ? void 0 : p.d) ? '<path d=\"'.concat(escHTML(p.d), '\" fill=\"').concat(escHTML(color), '\"></path>') : \"\").join(\"\");\n        const style = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, x), \";\\ntop: \").concat(topCSSFromYPx(obj, yPx), \";\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: top left;\\npointer-events: auto;\\n\").trim();\n        return '<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"'.concat(escHTML(viewBox), '\" style=\"').concat(style, '\">').concat(pathsHtml, \"</svg>\");\n    }\n    return objetos.map((obj)=>{\n        const tipo = obj === null || obj === void 0 ? void 0 : obj.tipo;\n        // ---------------- TEXTO ----------------\n        if (tipo === \"texto\") {\n            const align = String(obj.align || obj.textAlign || \"left\").toLowerCase();\n            const color = obj.colorTexto || obj.color || obj.fill || \"#000\";\n            const baseLineHeight = typeof obj.lineHeight === \"number\" && obj.lineHeight > 0 ? obj.lineHeight : 1.2;\n            const lineHeightFinal = baseLineHeight * 0.92;\n            const safeTexto = escHTML(obj.texto || \"\");\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const fs = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.fontSize) ? obj.fontSize : 24;\n            // ⚠️ texto fullBleed NO hace fit => escala con var(--sx)\n            const sFont = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            var _obj_rotation;\n            const rot = (_obj_rotation = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation !== void 0 ? _obj_rotation : 0;\n            var _obj_scaleX;\n            const scaleX = (_obj_scaleX = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX !== void 0 ? _obj_scaleX : 1;\n            var _obj_scaleY;\n            const scaleY = (_obj_scaleY = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY !== void 0 ? _obj_scaleY : 1;\n            const origin = align === \"center\" ? \"top center\" : align === \"right\" ? \"top right\" : \"top left\";\n            const xComp = align === \"left\" ? \"calc((1 - var(--text-zoom, 1)) * 50%)\" : align === \"right\" ? \"calc((var(--text-zoom, 1) - 1) * 50%)\" : \"0px\";\n            const style = \"\\n\".concat(baseStyle, \"\\n/* ✅ para que el zoom no “empuje” a la derecha */\\ntransform-origin: \").concat(origin, \";\\n/* ✅ compensa el corrimiento por scale */\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \") translateX(\").concat(xComp, \") scale(var(--text-zoom, 1));\\n\").concat(w !== undefined ? \"width: \".concat(pxX(obj, w), \";\") : \"\", \"\\nfont-size: calc(\").concat(sFont, \" * \").concat(fs, \"px);\\nfont-family: \").concat(obj.fontFamily || \"sans-serif\", \";\\nfont-weight: \").concat(obj.fontWeight || \"normal\", \";\\nfont-style: \").concat(obj.fontStyle || \"normal\", \";\\ntext-decoration: \").concat(obj.textDecoration || \"none\", \";\\ncolor: \").concat(color, \";\\ntext-align: \").concat(align, \";\\nwhite-space: pre-wrap;\\nline-height: \").concat(lineHeightFinal, \";\\npadding: 0;\\nmargin: 0;\\nbox-sizing: content-box;\\n\").concat(obj.stroke && obj.strokeWidth > 0 ? \"-webkit-text-stroke: \".concat(obj.strokeWidth, \"px \").concat(obj.stroke, \";\") : \"\", \"\\n\").concat(obj.shadowColor ? \"text-shadow: \".concat(obj.shadowOffsetX || 0, \"px \").concat(obj.shadowOffsetY || 0, \"px \").concat(obj.shadowBlur || 0, \"px \").concat(obj.shadowColor, \";\") : \"text-shadow: none;\", \"\\n\").trim();\n            return envolverSiEnlace('<div class=\"objeto\" data-debug-texto=\"1\" style=\"'.concat(style, '\">').concat(safeTexto, \"</div>\"), obj);\n        }\n        // ---------------- IMAGEN ----------------\n        if (tipo === \"imagen\") {\n            const src = obj.src || obj.url || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : undefined;\n            const style = \"\\n\".concat(baseStyle, \"\\n\").concat(styleSize(obj, w, h), \"\\nobject-fit: contain;\\ndisplay: block;\\n\").trim();\n            return envolverSiEnlace('<img class=\"objeto\" src=\"'.concat(escapeAttr(src), '\" style=\"').concat(style, '\" />'), obj);\n        }\n        // ---------------- ICONO (nuevo) ----------------\n        if (tipo === \"icono\") {\n            if (obj.formato === \"svg\") {\n                const svgHtml = renderIconoSvgNuevoInline(obj);\n                if (!svgHtml) return \"\";\n                return envolverSiEnlace(svgHtml, obj);\n            }\n            const src = obj.url || obj.src || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : undefined;\n            const style = \"\\n\".concat(baseStyle, \"\\n\").concat(styleSize(obj, w, h), \"\\nobject-fit: contain;\\ndisplay: block;\\n\").trim();\n            return envolverSiEnlace('<img class=\"objeto\" src=\"'.concat(escapeAttr(src), '\" style=\"').concat(style, '\" />'), obj);\n        }\n        // ---------------- ICONO LEGACY (icono-svg) ----------------\n        if (tipo === \"icono-svg\" && obj.d) {\n            const vb = obj.viewBox || \"0 0 100 100\";\n            const fill = obj.color || \"#000\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : 100;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : 100;\n            const style = \"\\n\".concat(baseStyle, \"\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\nfill: \").concat(escapeAttr(fill), \";\\n\").trim();\n            const svg = '<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"'.concat(escapeAttr(vb), '\" style=\"').concat(style, '\"><path d=\"').concat(escHTML(obj.d), '\" /></svg>');\n            return envolverSiEnlace(svg, obj);\n        }\n        // ---------------- COUNTDOWN ----------------\n        if (tipo === \"countdown\") {\n            const targetISO = obj.targetISO || obj.fechaObjetivo || obj.fechaISO || \"\";\n            var _obj_colorTexto, _ref;\n            const textColor = (_ref = (_obj_colorTexto = obj.colorTexto) !== null && _obj_colorTexto !== void 0 ? _obj_colorTexto : obj.color) !== null && _ref !== void 0 ? _ref : \"#111\";\n            const fontFamily = obj.fontFamily || \"Inter, system-ui, sans-serif\";\n            const preset = obj.presetId || obj.layout || \"pills\";\n            const isMinimal = String(preset).toLowerCase().includes(\"minimal\");\n            // ✅ ancho/alto del objeto (si existen)\n            const wObj = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? Number(obj.width) : null;\n            const hObj = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? Number(obj.height) : null;\n            // ✅ gap: si viene de Konva, respetarlo\n            const gap = Number.isFinite(obj.gap) ? Number(obj.gap) : Number.isFinite(obj.spacing) ? Number(obj.spacing) : 8;\n            // ✅ Si tu Konva guarda chipWidth / paddingX, respetalos\n            // chipWidth: ancho interno del texto (sin padding)\n            const chipWidthProp = Number.isFinite(obj.chipWidth) ? Number(obj.chipWidth) : null;\n            const paddingXProp = Number.isFinite(obj.paddingX) ? Number(obj.paddingX) : null;\n            // ✅ Derivación raíz (cuando no hay props)\n            const n = 4;\n            // chipWTotal: ancho total de cada chip (incluye padding)\n            let chipWTotal = 56; // fallback razonable\n            if (wObj && wObj > 0) {\n                chipWTotal = Math.max(40, (wObj - gap * (n - 1)) / n);\n            }\n            // paddingX derivado del chipWTotal (si no vino)\n            const paddingX = paddingXProp !== null && paddingXProp !== void 0 ? paddingXProp : Math.max(6, Math.round(chipWTotal * 0.18)); // ~18%\n            const paddingY = Math.max(5, Math.round(paddingX * 0.65));\n            // chipWidth (texto) derivado si no vino\n            const chipWidth = chipWidthProp !== null && chipWidthProp !== void 0 ? chipWidthProp : Math.max(10, Math.round(chipWTotal - paddingX * 2));\n            // ✅ font sizes: si vienen, respetar; si no, derivar desde chipWTotal\n            const valueSize = Number.isFinite(obj.fontSize) ? Number(obj.fontSize) : Math.max(14, Math.round(chipWTotal * 0.34));\n            const labelSize = Number.isFinite(obj.labelSize) ? Number(obj.labelSize) : Math.max(9, Math.round(valueSize * 0.62));\n            var _obj_labelColor;\n            const labelColor = (_obj_labelColor = obj.labelColor) !== null && _obj_labelColor !== void 0 ? _obj_labelColor : \"#6b7280\";\n            const fontWeight = Number.isFinite(obj.fontWeight) ? obj.fontWeight : 700;\n            const letterSpacing = Number.isFinite(obj.letterSpacing) ? obj.letterSpacing : 0;\n            // ✅ estilos de chip\n            const containerBgFinal = \"transparent\";\n            var _obj_chipBackground, _ref1;\n            const chipBgFinal = isMinimal ? \"transparent\" : (_ref1 = (_obj_chipBackground = obj.chipBackground) !== null && _obj_chipBackground !== void 0 ? _obj_chipBackground : obj.boxBg) !== null && _ref1 !== void 0 ? _ref1 : \"rgba(255,255,255,.75)\";\n            var _obj_chipBorder, _ref2;\n            const chipBorderColorFinal = isMinimal ? \"transparent\" : (_ref2 = (_obj_chipBorder = obj.chipBorder) !== null && _obj_chipBorder !== void 0 ? _obj_chipBorder : obj.boxBorder) !== null && _ref2 !== void 0 ? _ref2 : \"rgba(0,0,0,.08)\";\n            const containerRadius = Number.isFinite(obj.boxRadius) ? obj.boxRadius : Number.isFinite(obj.radius) ? obj.radius : 10;\n            const chipRadiusFinal = Number.isFinite(obj.chipRadius) ? obj.chipRadius : containerRadius;\n            const baseStyle = stylePosBase(obj);\n            // ✅ Escala correcta (respeta pantalla y bleed)\n            const sChip = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const containerStyle = \"\\n\".concat(baseStyle, \"\\n\").concat(wObj ? \"width: \".concat(pxX(obj, wObj), \";\") : \"\", \"\\n\").concat(hObj ? \"height: \".concat(pxY(obj, hObj), \";\") : \"\", \"\\ndisplay: flex;\\nalign-items: center;\\njustify-content: center;\\ngap: calc(\").concat(sChip, \" * \").concat(gap, \"px);\\nfont-family: \").concat(fontFamily, \";\\ncolor: \").concat(textColor, \";\\nbackground: \").concat(containerBgFinal, \";\\nborder-radius: calc(\").concat(sChip, \" * \").concat(containerRadius, \"px);\\nletter-spacing: calc(\").concat(sChip, \" * \").concat(letterSpacing, \"px);\\n\").trim();\n            const chipStyle = \"\\nwidth: calc(\".concat(sChip, \" * \").concat(Math.round(chipWTotal), \"px);\\npadding: calc(\").concat(sChip, \" * \").concat(paddingY, \"px) calc(\").concat(sChip, \" * \").concat(paddingX, \"px);\\nborder: \").concat(isMinimal ? \"0\" : \"calc(\".concat(sChip, \" * 1px) solid \").concat(chipBorderColorFinal), \";\\nborder-radius: calc(\").concat(sChip, \" * \").concat(chipRadiusFinal, \"px);\\ndisplay: flex;\\nflex-direction: column;\\nalign-items: center;\\njustify-content: center;\\nbackground: \").concat(chipBgFinal, \";\\nbox-sizing: border-box;\\n\").trim();\n            const valueStyle = \"\\nfont-weight: \".concat(fontWeight, \";\\nfont-size: calc(\").concat(sChip, \" * \").concat(valueSize, \"px);\\nline-height: 1;\\n\").trim();\n            const labelStyle = \"\\nfont-size: calc(\".concat(sChip, \" * \").concat(labelSize, \"px);\\ncolor: \").concat(labelColor, \";\\nline-height: 1.05;\\n\").trim();\n            const showLabels = obj.showLabels !== false;\n            var _obj_labels;\n            const labels = (_obj_labels = obj.labels) !== null && _obj_labels !== void 0 ? _obj_labels : {\n                dias: \"Días\",\n                horas: \"Horas\",\n                min: \"Min\",\n                seg: \"Seg\"\n            };\n            return '\\n<div class=\"objeto\"\\n  data-mobile-cluster=\"isolated\"\\n  data-mobile-center=\"force\"\\n  data-countdown\\n  data-target=\"'.concat(escapeAttr(targetISO), '\"\\n  data-preset=\"').concat(escapeAttr(preset), '\" style=\"').concat(containerStyle, '\">\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.dias), \"</span>\") : \"\", '\\n  </div>\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.horas), \"</span>\") : \"\", '\\n  </div>\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.min), \"</span>\") : \"\", '\\n  </div>\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.seg), \"</span>\") : \"\", \"\\n  </div>\\n</div>\\n\").trim();\n        }\n        // ---------------- GALERÍA ----------------\n        if (tipo === \"galeria\") {\n            const rows = Math.max(1, parseInt(obj.rows || 1, 10));\n            const cols = Math.max(1, parseInt(obj.cols || 1, 10));\n            const gapPx = Math.max(0, parseInt(obj.gap || 0, 10));\n            const radiusPx = Math.max(0, parseInt(obj.radius || 0, 10));\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : undefined;\n            const sGrid = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const styleContenedor = \"\\n\".concat(baseStyle, \"\\n\").concat(styleSize(obj, w, h), \"\\ndisplay: grid;\\ngrid-template-columns: repeat(\").concat(cols, \", 1fr);\\ngrid-template-rows: repeat(\").concat(rows, \", 1fr);\\ngap: calc(\").concat(sGrid, \" * \").concat(gapPx, \"px);\\nbox-sizing: border-box;\\n\").trim();\n            const total = rows * cols;\n            const cells = Array.from({\n                length: total\n            }, (_, i)=>{\n                const c = obj.cells && obj.cells[i] || {};\n                return {\n                    mediaUrl: c.mediaUrl || \"\",\n                    fit: c.fit === \"contain\" ? \"contain\" : \"cover\",\n                    bg: c.bg || \"#f3f4f6\"\n                };\n            });\n            const htmlCeldas = cells.map((cell, idx)=>{\n                const safeSrc = escapeAttr(cell.mediaUrl || \"\");\n                const celdaStyle = \"\\nposition: relative;\\nwidth: 100%;\\nheight: 100%;\\noverflow: hidden;\\nborder-radius: calc(\".concat(sGrid, \" * \").concat(radiusPx, \"px);\\nbackground: \").concat(cell.bg, \";\\n\").trim();\n                if (!safeSrc) {\n                    return '<div class=\"galeria-celda\" data-index=\"'.concat(idx, '\" style=\"').concat(celdaStyle, '\"></div>');\n                }\n                return '\\n<div class=\"galeria-celda galeria-celda--clickable\"\\n     data-index=\"'.concat(idx, '\"\\n     data-gallery-image=\"1\"\\n     role=\"button\"\\n     tabindex=\"0\"\\n     aria-label=\"Ver imagen en pantalla completa\"\\n     style=\"').concat(celdaStyle, '\">\\n  <img src=\"').concat(safeSrc, '\" alt=\"\" loading=\"lazy\" decoding=\"async\"\\n       style=\"width:100%;height:100%;object-fit:').concat(cell.fit, ';display:block;\" />\\n</div>\\n').trim();\n            }).join(\"\");\n            const htmlGaleria = '<div class=\"objeto galeria\" style=\"'.concat(styleContenedor, '\">').concat(htmlCeldas, \"</div>\");\n            return envolverSiEnlace(htmlGaleria, obj);\n        }\n        // ---------------- RSVP BOTÓN ----------------\n        if (tipo === \"rsvp-boton\") {\n            const texto = escapeHTML(obj.texto || \"Confirmar asistencia\");\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.ancho) ? obj.ancho : 200;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.alto) ? obj.alto : 50;\n            const color = obj.color || \"#773dbe\";\n            const colorTexto = obj.colorTexto || \"#ffffff\";\n            const fontSize = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.fontSize) ? obj.fontSize : 18;\n            const fontFamily = obj.fontFamily || \"sans-serif\";\n            const fontWeight = obj.fontWeight || \"bold\";\n            const fontStyle = obj.fontStyle || \"normal\";\n            const textDecoration = obj.textDecoration || \"none\";\n            const align = obj.align || \"center\";\n            const baseStyle = stylePosBase(obj);\n            // RSVP (contenido): si está en pantalla, fittea (sContenidoVar)\n            const sBtn = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const style = \"\\n\".concat(baseStyle, \"\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\nbackground-color: \").concat(color, \";\\ncolor: \").concat(colorTexto, \";\\nfont-size: calc(\").concat(sBtn, \" * \").concat(fontSize, \"px);\\nfont-family: \").concat(fontFamily, \";\\nfont-weight: \").concat(fontWeight, \";\\nfont-style: \").concat(fontStyle, \";\\ntext-decoration: \").concat(textDecoration, \";\\ntext-align: \").concat(align, \";\\ndisplay: flex;\\nalign-items: center;\\njustify-content: center;\\nborder-radius: calc(\").concat(sBtn, \" * 8px);\\ncursor: pointer;\\n\").trim();\n            return '\\n<div class=\"objeto is-interactive rsvp-boton\"\\n  id=\"abrirModalRSVP\"\\n  data-accion=\"abrir-rsvp\"\\n  data-rsvp-open\\n  role=\"button\"\\n  tabindex=\"0\"\\n  aria-label=\"Confirmar asistencia\"\\n  style=\"'.concat(style, '\">\\n  ').concat(texto, \"\\n</div>\\n\").trim();\n        }\n        // ---------------- FORMAS ----------------\n        if (tipo === \"forma\") {\n            const fill = obj.color || \"#000\";\n            const figura = obj.figura;\n            if (figura === \"rect\") {\n                const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : 100;\n                const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : 100;\n                const cornerRadius = obj.cornerRadius || 0;\n                const fontSize = obj.fontSize || 24;\n                const fontFamily = obj.fontFamily || \"sans-serif\";\n                const fontWeight = obj.fontWeight || \"normal\";\n                const fontStyle = obj.fontStyle || \"normal\";\n                const textDecoration = obj.textDecoration || \"none\";\n                const align = obj.align || \"center\";\n                const colorTexto = obj.colorTexto || \"#000000\";\n                const texto = escHTML(obj.texto || \"\");\n                const baseStyle = stylePosBase(obj);\n                const sRectText = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n                const style = \"\\n\".concat(baseStyle, \"\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\nbackground: \").concat(fill, \";\\nborder-radius: calc(\").concat(sRectText, \" * \").concat(cornerRadius, \"px);\\ndisplay: flex;\\nalign-items: center;\\njustify-content: \").concat(align === \"left\" ? \"flex-start\" : align === \"right\" ? \"flex-end\" : \"center\", \";\\ntext-align: \").concat(align, \";\\npadding: calc(\").concat(sRectText, \" * 4px);\\nbox-sizing: border-box;\\n\").trim();\n                const inner = '\\n<div style=\"\\n  width: 100%;\\n  font-size: calc('.concat(sRectText, \" * \").concat(fontSize, \"px);\\n  font-family: \").concat(fontFamily, \";\\n  font-weight: \").concat(fontWeight, \";\\n  font-style: \").concat(fontStyle, \";\\n  text-decoration: \").concat(textDecoration, \";\\n  color: \").concat(colorTexto, ';\\n  line-height: 1.2;\\n  white-space: pre-wrap;\\n  word-break: break-word;\\n\">').concat(texto, \"</div>\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto\" style=\"'.concat(style, '\">').concat(inner, \"</div>\"), obj);\n            }\n            if (figura === \"circle\") {\n                const radius = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.radius) ? obj.radius : 50;\n                const diameter = radius * 2;\n                const x = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0) - radius;\n                const yPxCenter = getYPxEditor(obj);\n                const yPxTopLeft = yPxCenter - radius;\n                var _obj_rotation1;\n                const rot = (_obj_rotation1 = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation1 !== void 0 ? _obj_rotation1 : 0;\n                var _obj_scaleX1;\n                const scaleX = (_obj_scaleX1 = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX1 !== void 0 ? _obj_scaleX1 : 1;\n                var _obj_scaleY1;\n                const scaleY = (_obj_scaleY1 = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY1 !== void 0 ? _obj_scaleY1 : 1;\n                const style = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, x), \";\\ntop: \").concat(topCSSFromYPx(obj, yPxTopLeft), \";\\nwidth: \").concat(pxX(obj, diameter), \";\\nheight: \").concat(pxY(obj, diameter), \";\\nborder-radius: 50%;\\nbackground: \").concat(fill, \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: center center;\\npointer-events: auto;\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto\" style=\"'.concat(style, '\"></div>'), obj);\n            }\n            if (figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH,\n                    0\n                ];\n                const x1 = parseFloat(points[0]) || 0;\n                const y1 = parseFloat(points[1]) || 0;\n                const x2 = parseFloat(points[2]) || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH;\n                const y2 = parseFloat(points[3]) || 0;\n                const strokeWidth = obj.strokeWidth || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.STROKE_WIDTH;\n                const deltaX = x2 - x1;\n                const deltaY = y2 - y1;\n                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n                const startX = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0) + x1;\n                const baseY = getYPxEditor(obj);\n                const startY = baseY + y1;\n                const totalRotation = angle + (obj.rotation || 0);\n                var _obj_scaleX2;\n                const scaleX = (_obj_scaleX2 = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX2 !== void 0 ? _obj_scaleX2 : 1;\n                var _obj_scaleY2;\n                const scaleY = (_obj_scaleY2 = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY2 !== void 0 ? _obj_scaleY2 : 1;\n                // alto de línea: usamos escala Y del objeto (contenido: sfinal/sx, bleed: sx)\n                const lineH = \"calc(\".concat(sY(obj), \" * \").concat(strokeWidth, \"px)\");\n                const style = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, startX), \";\\ntop: \").concat(topCSSFromYPx(obj, startY), \";\\nwidth: \").concat(pxX(obj, length), \";\\nheight: \").concat(lineH, \";\\nbackground: \").concat(fill, \";\\ntransform: rotate(\").concat(totalRotation, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: 0 50%;\\npointer-events: auto;\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto linea\" style=\"'.concat(style, '\"></div>'), obj);\n            }\n            if (figura === \"triangle\") {\n                const radius = obj.radius || 60;\n                const sin60 = Math.sqrt(3) / 2;\n                const cos60 = 0.5;\n                const triangleWidth = 2 * radius * sin60;\n                const triangleHeight = radius * (1 + cos60);\n                const centroidOffsetY = triangleHeight / 3;\n                const baseY = getYPxEditor(obj);\n                const topContainerPx = baseY - (triangleHeight - centroidOffsetY);\n                const leftContainer = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0) - triangleWidth / 2;\n                var _obj_rotation2, _obj_scaleX3, _obj_scaleY3;\n                const baseStyle = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, leftContainer), \";\\ntop: \").concat(topCSSFromYPx(obj, topContainerPx), \";\\nwidth: \").concat(pxX(obj, triangleWidth), \";\\nheight: \").concat(pxY(obj, triangleHeight), \";\\nbackground: \").concat(fill, \";\\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%);\\ntransform: rotate(\").concat((_obj_rotation2 = obj.rotation) !== null && _obj_rotation2 !== void 0 ? _obj_rotation2 : 0, \"deg) scale(\").concat((_obj_scaleX3 = obj.scaleX) !== null && _obj_scaleX3 !== void 0 ? _obj_scaleX3 : 1, \", \").concat((_obj_scaleY3 = obj.scaleY) !== null && _obj_scaleY3 !== void 0 ? _obj_scaleY3 : 1, \");\\ntransform-origin: center center;\\npointer-events: auto;\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto\" style=\"'.concat(baseStyle, '\"></div>'), obj);\n            }\n            return \"\";\n        }\n        return \"\";\n    }).join(\"\\n\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBRXpELG9EQUFvRDtBQUNwRCxTQUFTQztRQUFRQyxNQUFBQSxpRUFBVztJQUMxQixPQUFPQyxPQUFPRCxLQUNYRSxPQUFPLENBQUMsTUFBTSxTQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTSxVQUNkQSxPQUFPLENBQUMsTUFBTTtBQUNuQjtBQUVBLFNBQVNDO1FBQVdILE1BQUFBLGlFQUFjO0lBQ2hDLE9BQU9DLE9BQU9ELEtBQ1hFLE9BQU8sQ0FBQyxNQUFNLFNBQ2RBLE9BQU8sQ0FBQyxNQUFNLFVBQ2RBLE9BQU8sQ0FBQyxNQUFNLFFBQ2RBLE9BQU8sQ0FBQyxNQUFNO0FBQ25CO0FBRUEsU0FBU0UsYUFBYUMsR0FBUTtJQUM1QixNQUFNQyxNQUFNRCxnQkFBQUEsMEJBQUFBLElBQUtFLE1BQU07SUFDdkIsSUFBSSxDQUFDRCxLQUFLLE9BQU87SUFFakIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDM0IsTUFBTUUsT0FBT0wsV0FBV0c7UUFDeEIsSUFBSSxDQUFDRSxNQUFNLE9BQU87UUFDbEIsT0FBTztZQUFFQTtZQUFNQyxRQUFRO1lBQVVDLEtBQUs7UUFBc0I7SUFDOUQ7SUFFQSxNQUFNRixPQUFPTCxXQUFXRyxJQUFJRSxJQUFJLElBQUk7SUFDcEMsSUFBSSxDQUFDQSxNQUFNLE9BQU87SUFFbEIsTUFBTUMsU0FBU04sV0FBV0csSUFBSUcsTUFBTSxJQUFJO0lBQ3hDLE1BQU1DLE1BQU1QLFdBQVdHLElBQUlJLEdBQUcsSUFBSTtJQUNsQyxPQUFPO1FBQUVGO1FBQU1DO1FBQVFDO0lBQUk7QUFDN0I7QUFFQSxTQUFTQyxpQkFBaUJDLFlBQW9CLEVBQUVQLEdBQVE7SUFDdEQsSUFBSUEsQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJ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QkFBQUEsSUFBSXdELFFBQVEsY0FBWnhELDRCQUFBQSxpQkFBZ0IsR0FBRSxlQUFpQ0EsT0FBcEJBLENBQUFBLGVBQUFBLElBQUl5RCxNQUFNLGNBQVZ6RCwwQkFBQUEsZUFBYyxHQUFFLE1BQW9CLE9BQWhCQSxDQUFBQSxlQUFBQSxJQUFJMEQsTUFBTSxjQUFWMUQsMEJBQUFBLGVBQWMsR0FBRSxpRUFHckY2RCxJQUFJO2dCQUVJLE9BQU92RCxpQkFBaUIsOEJBQXdDLE9BQVZxRixXQUFVLGFBQVczRjtZQUM3RTtZQUVBLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVCxHQUNDcUUsSUFBSSxDQUFDO0FBQ1YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTElORV9DT05TVEFOVFMgfSBmcm9tIFwiLi4vbW9kZWxzL2xpbmVDb25zdGFudHNcIjtcclxuXHJcbi8vIOKchSBFc2NhcGFyIHN0cmluZ3MgcGFyYSBtZXRlcmxvcyBlbiBhdHJpYnV0b3MvSFRNTFxyXG5mdW5jdGlvbiBlc2NIVE1MKHN0cjogYW55ID0gXCJcIik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIFN0cmluZyhzdHIpXHJcbiAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXHJcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcclxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxyXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXNjYXBlQXR0cihzdHI6IHN0cmluZyA9IFwiXCIpOiBzdHJpbmcge1xyXG4gIHJldHVybiBTdHJpbmcoc3RyKVxyXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxyXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcclxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TGlua1Byb3BzKG9iajogYW55KSB7XHJcbiAgY29uc3QgcmF3ID0gb2JqPy5lbmxhY2U7XHJcbiAgaWYgKCFyYXcpIHJldHVybiBudWxsO1xyXG5cclxuICBpZiAodHlwZW9mIHJhdyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgY29uc3QgaHJlZiA9IGVzY2FwZUF0dHIocmF3KTtcclxuICAgIGlmICghaHJlZikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4geyBocmVmLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGhyZWYgPSBlc2NhcGVBdHRyKHJhdy5ocmVmIHx8IFwiXCIpO1xyXG4gIGlmICghaHJlZikgcmV0dXJuIG51bGw7XHJcblxyXG4gIGNvbnN0IHRhcmdldCA9IGVzY2FwZUF0dHIocmF3LnRhcmdldCB8fCBcIl9ibGFua1wiKTtcclxuICBjb25zdCByZWwgPSBlc2NhcGVBdHRyKHJhdy5yZWwgfHwgXCJub29wZW5lciBub3JlZmVycmVyXCIpO1xyXG4gIHJldHVybiB7IGhyZWYsIHRhcmdldCwgcmVsIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVudm9sdmVyU2lFbmxhY2UoaHRtbEVsZW1lbnRvOiBzdHJpbmcsIG9iajogYW55KTogc3RyaW5nIHtcclxuICBpZiAob2JqPy50aXBvID09PSBcInJzdnAtYm90b25cIikgcmV0dXJuIGh0bWxFbGVtZW50bztcclxuXHJcbiAgY29uc3QgbGluayA9IGdldExpbmtQcm9wcyhvYmopO1xyXG4gIGlmICghbGluaykgcmV0dXJuIGh0bWxFbGVtZW50bztcclxuXHJcbiAgcmV0dXJuIGA8YSBocmVmPVwiJHtsaW5rLmhyZWZ9XCIgdGFyZ2V0PVwiJHtsaW5rLnRhcmdldH1cIiByZWw9XCIke2xpbmsucmVsfVwiIHN0eWxlPVwidGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OmNvbnRlbnRzXCI+JHtodG1sRWxlbWVudG99PC9hPmA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVIVE1MKHRleHRvOiBzdHJpbmcgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gdGV4dG9cclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcclxuICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2JqZXRvczogYW55W10sIF9zZWNjaW9uZXM6IGFueVtdKTogc3RyaW5nIHtcclxuICBjb25zdCBhbHRvTW9kb1BvclNlY2Npb24gPSBuZXcgTWFwKFxyXG4gICAgKF9zZWNjaW9uZXMgfHwgW10pLm1hcCgoczogYW55KSA9PiBbcy5pZCwgU3RyaW5nKHMuYWx0b01vZG8gfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCldKVxyXG4gICk7XHJcblxyXG4gIGZ1bmN0aW9uIGVzU2VjY2lvblBhbnRhbGxhKG9iajogYW55KTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBtb2RvID0gYWx0b01vZG9Qb3JTZWNjaW9uLmdldChvYmo/LnNlY2Npb25JZCkgfHwgXCJmaWpvXCI7XHJcbiAgICByZXR1cm4gbW9kbyA9PT0gXCJwYW50YWxsYVwiO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNGdWxsQmxlZWQob2JqOiBhbnkpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBTdHJpbmcob2JqPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiZnVsbGJsZWVkXCI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgRXNjYWxhIHVuaWZvcm1lIGRlbCBDT05URU5JRE86XHJcbiAgICogLSBwYW50YWxsYTogdmFyKC0tc2ZpbmFsKSAoZml0IHNpIGhhY2UgZmFsdGEpXHJcbiAgICogLSBmaWpvOiB2YXIoLS1zeClcclxuICAgKi9cclxuICBmdW5jdGlvbiBzQ29udGVuaWRvVmFyKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgIHJldHVybiBlc1NlY2Npb25QYW50YWxsYShvYmopID8gXCJ2YXIoLS1zZmluYWwpXCIgOiBcInZhcigtLXN4KVwiO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog4pyFIFggc2NhbGU6XHJcbiAgICogLSBmdWxsQmxlZWQ6IHZhcigtLWJ4KSAoTk8gZml0KVxyXG4gICAqIC0gY29udGVuaWRvOiBzQ29udGVuaWRvVmFyIChmaXQgc2kgcGFudGFsbGEpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc1gob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLWJ4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog4pyFIFkgc2NhbGU6XHJcbiAgICogLSBmdWxsQmxlZWQ6IHZhcigtLXN4KSAoTk8gZml0KVxyXG4gICAqIC0gY29udGVuaWRvOiBzQ29udGVuaWRvVmFyIChmaXQgc2kgcGFudGFsbGEpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc1kob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHhYKG9iajogYW55LCBweDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG4gPSBOdW1iZXIuaXNGaW5pdGUocHgpID8gcHggOiAwO1xyXG4gICAgcmV0dXJuIGBjYWxjKCR7c1gob2JqKX0gKiAke259cHgpYDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB4WShvYmo6IGFueSwgcHg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCBuID0gTnVtYmVyLmlzRmluaXRlKHB4KSA/IHB4IDogMDtcclxuICAgIHJldHVybiBgY2FsYygke3NZKG9iail9ICogJHtufXB4KWA7XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyDinIUgUEFOVEFMTEE6IHRvcCBwb3IgcG9yY2VudGFqZVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIGNvbnN0IEFMVFVSQV9FRElUT1JfUEFOVEFMTEEgPSA1MDA7XHJcblxyXG4gIC8vIOKchSBPZmZzZXRzIGVuIHNlY2Npb25lcyBQYW50YWxsYTogT05cclxuICAvLyDimqDvuI8gSU1QT1JUQU5URTogZXN0ZSBhcmNoaXZvIFNPTE8gZ2VuZXJhIG9iamV0b3MuXHJcbiAgLy8gRWwgdmFsb3IgREVTS1RPUC9NT0JJTEUgcmVhbCBzZSBjb250cm9sYSB2w61hIENTUyBnbG9iYWwgY29uOlxyXG4gIC8vICAgOnJvb3QgeyAtLXBhbnRhbGxhLXktb2Zmc2V0OiBYcHggfVxyXG4gIC8vICAgQG1lZGlhIChtYXgtd2lkdGg6IDY0MHB4KSB7IDpyb290IHsgLS1wYW50YWxsYS15LW9mZnNldDogWXB4IH0gfVxyXG4gIC8vXHJcbiAgLy8gQWPDoSBkZWphbW9zIGZhbGxiYWNrIChkZXNrdG9wKSBwb3Igc2kgbGEgdmFyaWFibGUgQ1NTIG5vIGV4aXN0ZS5cclxuICBjb25zdCBQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYID0gLTI4O1xyXG5cclxuICBmdW5jdGlvbiBjbGFtcDAxKG46IGFueSk6IG51bWJlciB8IG51bGwge1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihuKTtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRZUHhFZGl0b3Iob2JqOiBhbnkpOiBudW1iZXIge1xyXG4gICAgLy8g4pyFIEVuIFBhbnRhbGxhIE9OOiB5Tm9ybSBlcyBsYSBmdWVudGUgZGUgdmVyZGFkICgwLi4xKVxyXG4gICAgY29uc3QgeW4gPSBjbGFtcDAxKG9iaj8ueU5vcm0pO1xyXG4gICAgaWYgKHluICE9IG51bGwpIHJldHVybiB5biAqIEFMVFVSQV9FRElUT1JfUEFOVEFMTEE7XHJcblxyXG4gICAgLy8gZmFsbGJhY2s6IHNpIG5vIGhheSB5Tm9ybSwgdXNhbW9zIHkgY29tbyBcImVkaXRvciBweFwiXHJcbiAgICBjb25zdCB5UHggPSBOdW1iZXIob2JqPy55KTtcclxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoeVB4KSkgcmV0dXJuIHlQeDtcclxuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOKchSB0b3BDU1M6XHJcbiAgICogLSBQYW50YWxsYSBPTjogdXNhIHZhcigtLXZoLWxvZ2ljYWwpICogeW5cclxuICAgKiAtIFRleHRvIGVuIFBhbnRhbGxhIE9OOiBzdW1hIG9mZnNldCAoQ1NTIHZhcikgZXNjYWxhZG8gcG9yIHNDb250ZW5pZG9WYXJcclxuICAgKiAtIEZpam86IHB4WShvYmosIHkpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdG9wQ1NTKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgIGlmIChlc1NlY2Npb25QYW50YWxsYShvYmopKSB7XHJcbiAgICAgIGNvbnN0IHlQeEVkaXRvciA9IGdldFlQeEVkaXRvcihvYmopO1xyXG4gICAgICBjb25zdCB5biA9IGNsYW1wMDEoeVB4RWRpdG9yIC8gQUxUVVJBX0VESVRPUl9QQU5UQUxMQSkgPz8gMDtcclxuXHJcblxyXG4gICAgICAvLyDinIUgQWx0dXJhIOKAnGRlIGRpc2XDsW/igJ0gZXNjYWxhZGEgcG9yIGVsIG1pc21vIGZhY3RvciBxdWUgdXNhbiB0YW1hw7FvcyAoc2ZpbmFsKVxyXG4gICAgICBjb25zdCBkZXNpZ25TY2FsZWRIID0gYCgke3NDb250ZW5pZG9WYXIob2JqKX0gKiAke0FMVFVSQV9FRElUT1JfUEFOVEFMTEF9cHgpYDtcclxuXHJcbiAgICAgIC8vIOKchSBDZW50cmFkbyB2ZXJ0aWNhbDogc2kgZWwgdmlld3BvcnQgbMOzZ2ljbyBlcyBtw6FzIGFsdG8gcXVlIGVsIGRpc2XDsW8gZXNjYWxhZG8sXHJcbiAgICAgIC8vIGFncmVnYW1vcyB1biBvZmZzZXQgY29uc3RhbnRlLiAoRW4gZGVza3RvcCBzdWVsZSBkYXIgfjAgcG9ycXVlIHNmaW5hbCA9IHZoLzUwMClcclxuICAgICAgY29uc3QgY2VudGVyT2Zmc2V0ID0gYG1heCgwcHgsIGNhbGMoKHZhcigtLXZoLWxvZ2ljYWwpIC0gJHtkZXNpZ25TY2FsZWRIfSkgLyAyKSlgO1xyXG5cclxuICAgICAgcmV0dXJuIGBjYWxjKFxyXG4gICR7Y2VudGVyT2Zmc2V0fVxyXG4gICsgKCR7ZGVzaWduU2NhbGVkSH0gKiAke3lufSlcclxuICArICgke3NDb250ZW5pZG9WYXIob2JqKX0gKiB2YXIoLS1wYW50YWxsYS15LW9mZnNldCwgJHtQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYfXB4KSlcclxuKWA7XHJcblxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeSA9IE51bWJlcihvYmo/LnkgfHwgMCk7XHJcbiAgICByZXR1cm4gcHhZKG9iaiwgeSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDinIUgVmFyaWFudGUgcGFyYSBjdWFuZG8geWEgdGVuw6lzIHlQeCAoZW4gXCJweCBlZGl0b3JcIilcclxuICAgKi9cclxuICBmdW5jdGlvbiB0b3BDU1NGcm9tWVB4KG9iajogYW55LCB5UHg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBpZiAoZXNTZWNjaW9uUGFudGFsbGEob2JqKSkge1xyXG4gICAgICBjb25zdCB5biA9IGNsYW1wMDEoeVB4IC8gQUxUVVJBX0VESVRPUl9QQU5UQUxMQSkgPz8gMDtcclxuXHJcblxyXG4gICAgICByZXR1cm4gYGNhbGMoKHZhcigtLXZoLWxvZ2ljYWwpICogJHt5bn0pICsgKCR7c0NvbnRlbmlkb1ZhcihcclxuICAgICAgICBvYmpcclxuICAgICAgKX0gKiB2YXIoLS1wYW50YWxsYS15LW9mZnNldCwgJHtQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYfXB4KSkpYDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHB4WShvYmosIHlQeCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdHlsZVBvc0Jhc2Uob2JqOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihvYmo/LnggfHwgMCk7XHJcblxyXG4gICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgY29uc3QgekluZGV4ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uekluZGV4KSA/IG9iai56SW5kZXggOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgcmV0dXJuIGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHgpfTtcclxudG9wOiAke3RvcENTUyhvYmopfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4ke3pJbmRleCAhPT0gdW5kZWZpbmVkID8gYHotaW5kZXg6JHt6SW5kZXh9O2AgOiBcIlwifVxyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdHlsZVNpemUob2JqOiBhbnksIHc/OiBudW1iZXIsIGg/OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgd3cgPSBOdW1iZXIuaXNGaW5pdGUodykgPyAodyBhcyBudW1iZXIpIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaGggPSBOdW1iZXIuaXNGaW5pdGUoaCkgPyAoaCBhcyBudW1iZXIpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgaWYgKHd3ICE9PSB1bmRlZmluZWQpIHBhcnRzLnB1c2goYHdpZHRoOiAke3B4WChvYmosIHd3KX07YCk7XHJcbiAgICBpZiAoaGggIT09IHVuZGVmaW5lZCkgcGFydHMucHVzaChgaGVpZ2h0OiAke3B4WShvYmosIGhoKX07YCk7XHJcbiAgICByZXR1cm4gcGFydHMuam9pbihcIlxcblwiKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbmRlckljb25vU3ZnTnVldm9JbmxpbmUob2JqOiBhbnkpIHtcclxuICAgIGNvbnN0IHZpZXdCb3ggPSBvYmoudmlld0JveCB8fCBcIjAgMCAyNCAyNFwiO1xyXG4gICAgY29uc3QgY29sb3IgPSBvYmouY29sb3IgfHwgXCIjMDAwXCI7XHJcbiAgICBjb25zdCBwYXRocyA9IEFycmF5LmlzQXJyYXkob2JqLnBhdGhzKSA/IG9iai5wYXRocyA6IFtdO1xyXG4gICAgaWYgKCFwYXRocy5sZW5ndGgpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiAyNDtcclxuICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IDI0O1xyXG5cclxuICAgIGNvbnN0IHJvdCA9IG9iaj8ucm90YXRpb24gPz8gMDtcclxuICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgIGNvbnN0IHggPSBOdW1iZXIob2JqPy54IHx8IDApO1xyXG4gICAgY29uc3QgeVB4ID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcblxyXG4gICAgY29uc3QgcGF0aHNIdG1sID0gcGF0aHNcclxuICAgICAgLm1hcCgocDogYW55KSA9PiAocD8uZCA/IGA8cGF0aCBkPVwiJHtlc2NIVE1MKHAuZCl9XCIgZmlsbD1cIiR7ZXNjSFRNTChjb2xvcil9XCI+PC9wYXRoPmAgOiBcIlwiKSlcclxuICAgICAgLmpvaW4oXCJcIik7XHJcblxyXG4gICAgY29uc3Qgc3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCB4KX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgeVB4KX07XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgcmV0dXJuIGA8c3ZnIGNsYXNzPVwib2JqZXRvXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIke2VzY0hUTUwoXHJcbiAgICAgIHZpZXdCb3hcclxuICAgICl9XCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7cGF0aHNIdG1sfTwvc3ZnPmA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqZXRvc1xyXG4gICAgLm1hcCgob2JqKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRpcG8gPSBvYmo/LnRpcG87XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIFRFWFRPIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwidGV4dG9cIikge1xyXG4gICAgICAgIGNvbnN0IGFsaWduID0gU3RyaW5nKG9iai5hbGlnbiB8fCBvYmoudGV4dEFsaWduIHx8IFwibGVmdFwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gb2JqLmNvbG9yVGV4dG8gfHwgb2JqLmNvbG9yIHx8IG9iai5maWxsIHx8IFwiIzAwMFwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlTGluZUhlaWdodCA9XHJcbiAgICAgICAgICB0eXBlb2Ygb2JqLmxpbmVIZWlnaHQgPT09IFwibnVtYmVyXCIgJiYgb2JqLmxpbmVIZWlnaHQgPiAwID8gb2JqLmxpbmVIZWlnaHQgOiAxLjI7XHJcbiAgICAgICAgY29uc3QgbGluZUhlaWdodEZpbmFsID0gYmFzZUxpbmVIZWlnaHQgKiAwLjkyO1xyXG5cclxuICAgICAgICBjb25zdCBzYWZlVGV4dG8gPSBlc2NIVE1MKG9iai50ZXh0byB8fCBcIlwiKTtcclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBmcyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmZvbnRTaXplKSA/IG9iai5mb250U2l6ZSA6IDI0O1xyXG5cclxuICAgICAgICAvLyDimqDvuI8gdGV4dG8gZnVsbEJsZWVkIE5PIGhhY2UgZml0ID0+IGVzY2FsYSBjb24gdmFyKC0tc3gpXHJcbiAgICAgICAgY29uc3Qgc0ZvbnQgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID1cclxuICAgICAgICAgIGFsaWduID09PSBcImNlbnRlclwiID8gXCJ0b3AgY2VudGVyXCIgOlxyXG4gICAgICAgICAgICAoYWxpZ24gPT09IFwicmlnaHRcIiA/IFwidG9wIHJpZ2h0XCIgOiBcInRvcCBsZWZ0XCIpO1xyXG5cclxuICAgICAgICBjb25zdCB4Q29tcCA9XHJcbiAgICAgICAgICBhbGlnbiA9PT0gXCJsZWZ0XCIgPyBcImNhbGMoKDEgLSB2YXIoLS10ZXh0LXpvb20sIDEpKSAqIDUwJSlcIiA6XHJcbiAgICAgICAgICAgIGFsaWduID09PSBcInJpZ2h0XCIgPyBcImNhbGMoKHZhcigtLXRleHQtem9vbSwgMSkgLSAxKSAqIDUwJSlcIiA6XHJcbiAgICAgICAgICAgICAgXCIwcHhcIjtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbi8qIOKchSBwYXJhIHF1ZSBlbCB6b29tIG5vIOKAnGVtcHVqZeKAnSBhIGxhIGRlcmVjaGEgKi9cclxudHJhbnNmb3JtLW9yaWdpbjogJHtvcmlnaW59O1xyXG4vKiDinIUgY29tcGVuc2EgZWwgY29ycmltaWVudG8gcG9yIHNjYWxlICovXHJcbnRyYW5zZm9ybTogcm90YXRlKCR7cm90fWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pIHRyYW5zbGF0ZVgoJHt4Q29tcH0pIHNjYWxlKHZhcigtLXRleHQtem9vbSwgMSkpO1xyXG4ke3cgIT09IHVuZGVmaW5lZCA/IGB3aWR0aDogJHtweFgob2JqLCB3KX07YCA6IFwiXCJ9XHJcbmZvbnQtc2l6ZTogY2FsYygke3NGb250fSAqICR7ZnN9cHgpO1xyXG5mb250LWZhbWlseTogJHtvYmouZm9udEZhbWlseSB8fCBcInNhbnMtc2VyaWZcIn07XHJcbmZvbnQtd2VpZ2h0OiAke29iai5mb250V2VpZ2h0IHx8IFwibm9ybWFsXCJ9O1xyXG5mb250LXN0eWxlOiAke29iai5mb250U3R5bGUgfHwgXCJub3JtYWxcIn07XHJcbnRleHQtZGVjb3JhdGlvbjogJHtvYmoudGV4dERlY29yYXRpb24gfHwgXCJub25lXCJ9O1xyXG5jb2xvcjogJHtjb2xvcn07XHJcbnRleHQtYWxpZ246ICR7YWxpZ259O1xyXG53aGl0ZS1zcGFjZTogcHJlLXdyYXA7XHJcbmxpbmUtaGVpZ2h0OiAke2xpbmVIZWlnaHRGaW5hbH07XHJcbnBhZGRpbmc6IDA7XHJcbm1hcmdpbjogMDtcclxuYm94LXNpemluZzogY29udGVudC1ib3g7XHJcbiR7b2JqLnN0cm9rZSAmJiBvYmouc3Ryb2tlV2lkdGggPiAwXHJcbiAgICAgICAgICAgID8gYC13ZWJraXQtdGV4dC1zdHJva2U6ICR7b2JqLnN0cm9rZVdpZHRofXB4ICR7b2JqLnN0cm9rZX07YFxyXG4gICAgICAgICAgICA6IFwiXCJcclxuICAgICAgICAgIH1cclxuJHtvYmouc2hhZG93Q29sb3JcclxuICAgICAgICAgICAgPyBgdGV4dC1zaGFkb3c6ICR7b2JqLnNoYWRvd09mZnNldFggfHwgMH1weCAke29iai5zaGFkb3dPZmZzZXRZIHx8IDB9cHggJHtvYmouc2hhZG93Qmx1ciB8fCAwfXB4ICR7b2JqLnNoYWRvd0NvbG9yfTtgXHJcbiAgICAgICAgICAgIDogXCJ0ZXh0LXNoYWRvdzogbm9uZTtcIlxyXG4gICAgICAgICAgfVxyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoXHJcbiAgICAgICAgICBgPGRpdiBjbGFzcz1cIm9iamV0b1wiIGRhdGEtZGVidWctdGV4dG89XCIxXCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7c2FmZVRleHRvfTwvZGl2PmAsXHJcbiAgICAgICAgICBvYmpcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBJTUFHRU4gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJpbWFnZW5cIikge1xyXG4gICAgICAgIGNvbnN0IHNyYyA9IG9iai5zcmMgfHwgb2JqLnVybCB8fCBcIlwiO1xyXG4gICAgICAgIGlmICghc3JjKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHtzdHlsZVNpemUob2JqLCB3LCBoKX1cclxub2JqZWN0LWZpdDogY29udGFpbjtcclxuZGlzcGxheTogYmxvY2s7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGltZyBjbGFzcz1cIm9iamV0b1wiIHNyYz1cIiR7ZXNjYXBlQXR0cihzcmMpfVwiIHN0eWxlPVwiJHtzdHlsZX1cIiAvPmAsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gSUNPTk8gKG51ZXZvKSAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImljb25vXCIpIHtcclxuICAgICAgICBpZiAob2JqLmZvcm1hdG8gPT09IFwic3ZnXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHN2Z0h0bWwgPSByZW5kZXJJY29ub1N2Z051ZXZvSW5saW5lKG9iaik7XHJcbiAgICAgICAgICBpZiAoIXN2Z0h0bWwpIHJldHVybiBcIlwiO1xyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2Uoc3ZnSHRtbCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNyYyA9IG9iai51cmwgfHwgb2JqLnNyYyB8fCBcIlwiO1xyXG4gICAgICAgIGlmICghc3JjKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHtzdHlsZVNpemUob2JqLCB3LCBoKX1cclxub2JqZWN0LWZpdDogY29udGFpbjtcclxuZGlzcGxheTogYmxvY2s7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGltZyBjbGFzcz1cIm9iamV0b1wiIHNyYz1cIiR7ZXNjYXBlQXR0cihzcmMpfVwiIHN0eWxlPVwiJHtzdHlsZX1cIiAvPmAsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gSUNPTk8gTEVHQUNZIChpY29uby1zdmcpIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiaWNvbm8tc3ZnXCIgJiYgb2JqLmQpIHtcclxuICAgICAgICBjb25zdCB2YiA9IG9iai52aWV3Qm94IHx8IFwiMCAwIDEwMCAxMDBcIjtcclxuICAgICAgICBjb25zdCBmaWxsID0gb2JqLmNvbG9yIHx8IFwiIzAwMFwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogMTAwO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IDEwMDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbmZpbGw6ICR7ZXNjYXBlQXR0cihmaWxsKX07XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBgPHN2ZyBjbGFzcz1cIm9iamV0b1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiJHtlc2NhcGVBdHRyKFxyXG4gICAgICAgICAgdmJcclxuICAgICAgICApfVwiIHN0eWxlPVwiJHtzdHlsZX1cIj48cGF0aCBkPVwiJHtlc2NIVE1MKG9iai5kKX1cIiAvPjwvc3ZnPmA7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKHN2Zywgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBDT1VOVERPV04gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElTTyA9IG9iai50YXJnZXRJU08gfHwgb2JqLmZlY2hhT2JqZXRpdm8gfHwgb2JqLmZlY2hhSVNPIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHRDb2xvciA9IG9iai5jb2xvclRleHRvID8/IG9iai5jb2xvciA/PyBcIiMxMTFcIjtcclxuICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHkgfHwgXCJJbnRlciwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXNldCA9IG9iai5wcmVzZXRJZCB8fCBvYmoubGF5b3V0IHx8IFwicGlsbHNcIjtcclxuICAgICAgICBjb25zdCBpc01pbmltYWwgPSBTdHJpbmcocHJlc2V0KS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibWluaW1hbFwiKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIGFuY2hvL2FsdG8gZGVsIG9iamV0byAoc2kgZXhpc3RlbilcclxuICAgICAgICBjb25zdCB3T2JqID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gTnVtYmVyKG9iai53aWR0aCkgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGhPYmogPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gTnVtYmVyKG9iai5oZWlnaHQpIDogbnVsbDtcclxuXHJcbiAgICAgICAgLy8g4pyFIGdhcDogc2kgdmllbmUgZGUgS29udmEsIHJlc3BldGFybG9cclxuICAgICAgICBjb25zdCBnYXAgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmdhcClcclxuICAgICAgICAgID8gTnVtYmVyKG9iai5nYXApXHJcbiAgICAgICAgICA6IE51bWJlci5pc0Zpbml0ZShvYmouc3BhY2luZylcclxuICAgICAgICAgICAgPyBOdW1iZXIob2JqLnNwYWNpbmcpXHJcbiAgICAgICAgICAgIDogODtcclxuXHJcbiAgICAgICAgLy8g4pyFIFNpIHR1IEtvbnZhIGd1YXJkYSBjaGlwV2lkdGggLyBwYWRkaW5nWCwgcmVzcGV0YWxvc1xyXG4gICAgICAgIC8vIGNoaXBXaWR0aDogYW5jaG8gaW50ZXJubyBkZWwgdGV4dG8gKHNpbiBwYWRkaW5nKVxyXG4gICAgICAgIGNvbnN0IGNoaXBXaWR0aFByb3AgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmNoaXBXaWR0aCkgPyBOdW1iZXIob2JqLmNoaXBXaWR0aCkgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IHBhZGRpbmdYUHJvcCA9IE51bWJlci5pc0Zpbml0ZShvYmoucGFkZGluZ1gpID8gTnVtYmVyKG9iai5wYWRkaW5nWCkgOiBudWxsO1xyXG5cclxuICAgICAgICAvLyDinIUgRGVyaXZhY2nDs24gcmHDrXogKGN1YW5kbyBubyBoYXkgcHJvcHMpXHJcbiAgICAgICAgY29uc3QgbiA9IDQ7XHJcblxyXG4gICAgICAgIC8vIGNoaXBXVG90YWw6IGFuY2hvIHRvdGFsIGRlIGNhZGEgY2hpcCAoaW5jbHV5ZSBwYWRkaW5nKVxyXG4gICAgICAgIGxldCBjaGlwV1RvdGFsID0gNTY7IC8vIGZhbGxiYWNrIHJhem9uYWJsZVxyXG4gICAgICAgIGlmICh3T2JqICYmIHdPYmogPiAwKSB7XHJcbiAgICAgICAgICBjaGlwV1RvdGFsID0gTWF0aC5tYXgoNDAsICh3T2JqIC0gZ2FwICogKG4gLSAxKSkgLyBuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBhZGRpbmdYIGRlcml2YWRvIGRlbCBjaGlwV1RvdGFsIChzaSBubyB2aW5vKVxyXG4gICAgICAgIGNvbnN0IHBhZGRpbmdYID0gcGFkZGluZ1hQcm9wID8/IE1hdGgubWF4KDYsIE1hdGgucm91bmQoY2hpcFdUb3RhbCAqIDAuMTgpKTsgLy8gfjE4JVxyXG4gICAgICAgIGNvbnN0IHBhZGRpbmdZID0gTWF0aC5tYXgoNSwgTWF0aC5yb3VuZChwYWRkaW5nWCAqIDAuNjUpKTtcclxuXHJcbiAgICAgICAgLy8gY2hpcFdpZHRoICh0ZXh0bykgZGVyaXZhZG8gc2kgbm8gdmlub1xyXG4gICAgICAgIGNvbnN0IGNoaXBXaWR0aCA9IGNoaXBXaWR0aFByb3AgPz8gTWF0aC5tYXgoMTAsIE1hdGgucm91bmQoY2hpcFdUb3RhbCAtIHBhZGRpbmdYICogMikpO1xyXG5cclxuICAgICAgICAvLyDinIUgZm9udCBzaXplczogc2kgdmllbmVuLCByZXNwZXRhcjsgc2kgbm8sIGRlcml2YXIgZGVzZGUgY2hpcFdUb3RhbFxyXG4gICAgICAgIGNvbnN0IHZhbHVlU2l6ZSA9XHJcbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2JqLmZvbnRTaXplKSA/IE51bWJlcihvYmouZm9udFNpemUpIDogTWF0aC5tYXgoMTQsIE1hdGgucm91bmQoY2hpcFdUb3RhbCAqIDAuMzQpKTtcclxuICAgICAgICBjb25zdCBsYWJlbFNpemUgPVxyXG4gICAgICAgICAgTnVtYmVyLmlzRmluaXRlKG9iai5sYWJlbFNpemUpID8gTnVtYmVyKG9iai5sYWJlbFNpemUpIDogTWF0aC5tYXgoOSwgTWF0aC5yb3VuZCh2YWx1ZVNpemUgKiAwLjYyKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsQ29sb3IgPSBvYmoubGFiZWxDb2xvciA/PyBcIiM2YjcyODBcIjtcclxuICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKG9iai5mb250V2VpZ2h0KSA/IG9iai5mb250V2VpZ2h0IDogNzAwO1xyXG4gICAgICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmxldHRlclNwYWNpbmcpID8gb2JqLmxldHRlclNwYWNpbmcgOiAwO1xyXG5cclxuICAgICAgICAvLyDinIUgZXN0aWxvcyBkZSBjaGlwXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyQmdGaW5hbCA9IFwidHJhbnNwYXJlbnRcIjtcclxuICAgICAgICBjb25zdCBjaGlwQmdGaW5hbCA9IGlzTWluaW1hbCA/IFwidHJhbnNwYXJlbnRcIiA6IG9iai5jaGlwQmFja2dyb3VuZCA/PyBvYmouYm94QmcgPz8gXCJyZ2JhKDI1NSwyNTUsMjU1LC43NSlcIjtcclxuICAgICAgICBjb25zdCBjaGlwQm9yZGVyQ29sb3JGaW5hbCA9IGlzTWluaW1hbCA/IFwidHJhbnNwYXJlbnRcIiA6IG9iai5jaGlwQm9yZGVyID8/IG9iai5ib3hCb3JkZXIgPz8gXCJyZ2JhKDAsMCwwLC4wOClcIjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKG9iai5ib3hSYWRpdXMpXHJcbiAgICAgICAgICA/IG9iai5ib3hSYWRpdXNcclxuICAgICAgICAgIDogTnVtYmVyLmlzRmluaXRlKG9iai5yYWRpdXMpXHJcbiAgICAgICAgICAgID8gb2JqLnJhZGl1c1xyXG4gICAgICAgICAgICA6IDEwO1xyXG5cclxuICAgICAgICBjb25zdCBjaGlwUmFkaXVzRmluYWwgPSBOdW1iZXIuaXNGaW5pdGUob2JqLmNoaXBSYWRpdXMpID8gb2JqLmNoaXBSYWRpdXMgOiBjb250YWluZXJSYWRpdXM7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG5cclxuICAgICAgICAvLyDinIUgRXNjYWxhIGNvcnJlY3RhIChyZXNwZXRhIHBhbnRhbGxhIHkgYmxlZWQpXHJcbiAgICAgICAgY29uc3Qgc0NoaXAgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG4ke3dPYmogPyBgd2lkdGg6ICR7cHhYKG9iaiwgd09iail9O2AgOiBcIlwifVxyXG4ke2hPYmogPyBgaGVpZ2h0OiAke3B4WShvYmosIGhPYmopfTtgIDogXCJcIn1cclxuZGlzcGxheTogZmxleDtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbmdhcDogY2FsYygke3NDaGlwfSAqICR7Z2FwfXB4KTtcclxuZm9udC1mYW1pbHk6ICR7Zm9udEZhbWlseX07XHJcbmNvbG9yOiAke3RleHRDb2xvcn07XHJcbmJhY2tncm91bmQ6ICR7Y29udGFpbmVyQmdGaW5hbH07XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzQ2hpcH0gKiAke2NvbnRhaW5lclJhZGl1c31weCk7XHJcbmxldHRlci1zcGFjaW5nOiBjYWxjKCR7c0NoaXB9ICogJHtsZXR0ZXJTcGFjaW5nfXB4KTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNoaXBTdHlsZSA9IGBcclxud2lkdGg6IGNhbGMoJHtzQ2hpcH0gKiAke01hdGgucm91bmQoY2hpcFdUb3RhbCl9cHgpO1xyXG5wYWRkaW5nOiBjYWxjKCR7c0NoaXB9ICogJHtwYWRkaW5nWX1weCkgY2FsYygke3NDaGlwfSAqICR7cGFkZGluZ1h9cHgpO1xyXG5ib3JkZXI6ICR7aXNNaW5pbWFsID8gXCIwXCIgOiBgY2FsYygke3NDaGlwfSAqIDFweCkgc29saWQgJHtjaGlwQm9yZGVyQ29sb3JGaW5hbH1gfTtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NDaGlwfSAqICR7Y2hpcFJhZGl1c0ZpbmFsfXB4KTtcclxuZGlzcGxheTogZmxleDtcclxuZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbmJhY2tncm91bmQ6ICR7Y2hpcEJnRmluYWx9O1xyXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmFsdWVTdHlsZSA9IGBcclxuZm9udC13ZWlnaHQ6ICR7Zm9udFdlaWdodH07XHJcbmZvbnQtc2l6ZTogY2FsYygke3NDaGlwfSAqICR7dmFsdWVTaXplfXB4KTtcclxubGluZS1oZWlnaHQ6IDE7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFN0eWxlID0gYFxyXG5mb250LXNpemU6IGNhbGMoJHtzQ2hpcH0gKiAke2xhYmVsU2l6ZX1weCk7XHJcbmNvbG9yOiAke2xhYmVsQ29sb3J9O1xyXG5saW5lLWhlaWdodDogMS4wNTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3dMYWJlbHMgPSBvYmouc2hvd0xhYmVscyAhPT0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gb2JqLmxhYmVscyA/PyB7IGRpYXM6IFwiRMOtYXNcIiwgaG9yYXM6IFwiSG9yYXNcIiwgbWluOiBcIk1pblwiLCBzZWc6IFwiU2VnXCIgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGBcclxuPGRpdiBjbGFzcz1cIm9iamV0b1wiXHJcbiAgZGF0YS1tb2JpbGUtY2x1c3Rlcj1cImlzb2xhdGVkXCJcclxuICBkYXRhLW1vYmlsZS1jZW50ZXI9XCJmb3JjZVwiXHJcbiAgZGF0YS1jb3VudGRvd25cclxuICBkYXRhLXRhcmdldD1cIiR7ZXNjYXBlQXR0cih0YXJnZXRJU08pfVwiXHJcbiAgZGF0YS1wcmVzZXQ9XCIke2VzY2FwZUF0dHIoXHJcbiAgICAgICAgICBwcmVzZXRcclxuICAgICAgICApfVwiIHN0eWxlPVwiJHtjb250YWluZXJTdHlsZX1cIj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5kaWFzKX08L3NwYW4+YCA6IFwiXCJ9XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImNkLWNoaXBcIiBzdHlsZT1cIiR7Y2hpcFN0eWxlfVwiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJjZC12YWxcIiBzdHlsZT1cIiR7dmFsdWVTdHlsZX1cIj4wMDwvc3Bhbj5cclxuICAgICR7c2hvd0xhYmVscyA/IGA8c3BhbiBjbGFzcz1cImNkLWxhYlwiIHN0eWxlPVwiJHtsYWJlbFN0eWxlfVwiPiR7ZXNjYXBlQXR0cihsYWJlbHMuaG9yYXMpfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5taW4pfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5zZWcpfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbmAudHJpbSgpO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBHQUxFUsONQSAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImdhbGVyaWFcIikge1xyXG4gICAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLm1heCgxLCBwYXJzZUludChvYmoucm93cyB8fCAxLCAxMCkpO1xyXG4gICAgICAgIGNvbnN0IGNvbHMgPSBNYXRoLm1heCgxLCBwYXJzZUludChvYmouY29scyB8fCAxLCAxMCkpO1xyXG4gICAgICAgIGNvbnN0IGdhcFB4ID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQob2JqLmdhcCB8fCAwLCAxMCkpO1xyXG4gICAgICAgIGNvbnN0IHJhZGl1c1B4ID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQob2JqLnJhZGl1cyB8fCAwLCAxMCkpO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5oZWlnaHQpID8gb2JqLmhlaWdodCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgc0dyaWQgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGVDb250ZW5lZG9yID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHtzdHlsZVNpemUob2JqLCB3LCBoKX1cclxuZGlzcGxheTogZ3JpZDtcclxuZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoJHtjb2xzfSwgMWZyKTtcclxuZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoJHtyb3dzfSwgMWZyKTtcclxuZ2FwOiBjYWxjKCR7c0dyaWR9ICogJHtnYXBQeH1weCk7XHJcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCB0b3RhbCA9IHJvd3MgKiBjb2xzO1xyXG4gICAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdG90YWwgfSwgKF8sIGkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGMgPSAob2JqLmNlbGxzICYmIG9iai5jZWxsc1tpXSkgfHwge307XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtZWRpYVVybDogYy5tZWRpYVVybCB8fCBcIlwiLFxyXG4gICAgICAgICAgICBmaXQ6IGMuZml0ID09PSBcImNvbnRhaW5cIiA/IFwiY29udGFpblwiIDogXCJjb3ZlclwiLFxyXG4gICAgICAgICAgICBiZzogYy5iZyB8fCBcIiNmM2Y0ZjZcIixcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWxDZWxkYXMgPSBjZWxsc1xyXG4gICAgICAgICAgLm1hcCgoY2VsbCwgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhZmVTcmMgPSBlc2NhcGVBdHRyKGNlbGwubWVkaWFVcmwgfHwgXCJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGRhU3R5bGUgPSBgXHJcbnBvc2l0aW9uOiByZWxhdGl2ZTtcclxud2lkdGg6IDEwMCU7XHJcbmhlaWdodDogMTAwJTtcclxub3ZlcmZsb3c6IGhpZGRlbjtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NHcmlkfSAqICR7cmFkaXVzUHh9cHgpO1xyXG5iYWNrZ3JvdW5kOiAke2NlbGwuYmd9O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2FmZVNyYykge1xuICAgICAgICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJnYWxlcmlhLWNlbGRhXCIgZGF0YS1pbmRleD1cIiR7aWR4fVwiIHN0eWxlPVwiJHtjZWxkYVN0eWxlfVwiPjwvZGl2PmA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBgXG48ZGl2IGNsYXNzPVwiZ2FsZXJpYS1jZWxkYSBnYWxlcmlhLWNlbGRhLS1jbGlja2FibGVcIlxuICAgICBkYXRhLWluZGV4PVwiJHtpZHh9XCJcbiAgICAgZGF0YS1nYWxsZXJ5LWltYWdlPVwiMVwiXG4gICAgIHJvbGU9XCJidXR0b25cIlxuICAgICB0YWJpbmRleD1cIjBcIlxuICAgICBhcmlhLWxhYmVsPVwiVmVyIGltYWdlbiBlbiBwYW50YWxsYSBjb21wbGV0YVwiXG4gICAgIHN0eWxlPVwiJHtjZWxkYVN0eWxlfVwiPlxuICA8aW1nIHNyYz1cIiR7c2FmZVNyY31cIiBhbHQ9XCJcIiBsb2FkaW5nPVwibGF6eVwiIGRlY29kaW5nPVwiYXN5bmNcIlxuICAgICAgIHN0eWxlPVwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvYmplY3QtZml0OiR7Y2VsbC5maXR9O2Rpc3BsYXk6YmxvY2s7XCIgLz5cbjwvZGl2PlxuYC50cmltKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuam9pbihcIlwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaHRtbEdhbGVyaWEgPSBgPGRpdiBjbGFzcz1cIm9iamV0byBnYWxlcmlhXCIgc3R5bGU9XCIke3N0eWxlQ29udGVuZWRvcn1cIj4ke2h0bWxDZWxkYXN9PC9kaXY+YDtcclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShodG1sR2FsZXJpYSwgb2JqKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLSBSU1ZQIEJPVMOTTiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcInJzdnAtYm90b25cIikge1xyXG4gICAgICAgIGNvbnN0IHRleHRvID0gZXNjYXBlSFRNTChvYmoudGV4dG8gfHwgXCJDb25maXJtYXIgYXNpc3RlbmNpYVwiKTtcclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uYW5jaG8pID8gb2JqLmFuY2hvIDogMjAwO1xyXG4gICAgICAgIGNvbnN0IGggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5hbHRvKSA/IG9iai5hbHRvIDogNTA7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gb2JqLmNvbG9yIHx8IFwiIzc3M2RiZVwiO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yVGV4dG8gPSBvYmouY29sb3JUZXh0byB8fCBcIiNmZmZmZmZcIjtcclxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmZvbnRTaXplKSA/IG9iai5mb250U2l6ZSA6IDE4O1xyXG4gICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseSB8fCBcInNhbnMtc2VyaWZcIjtcclxuICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gb2JqLmZvbnRXZWlnaHQgfHwgXCJib2xkXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFN0eWxlID0gb2JqLmZvbnRTdHlsZSB8fCBcIm5vcm1hbFwiO1xyXG4gICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9uID0gb2JqLnRleHREZWNvcmF0aW9uIHx8IFwibm9uZVwiO1xyXG4gICAgICAgIGNvbnN0IGFsaWduID0gb2JqLmFsaWduIHx8IFwiY2VudGVyXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG5cclxuICAgICAgICAvLyBSU1ZQIChjb250ZW5pZG8pOiBzaSBlc3TDoSBlbiBwYW50YWxsYSwgZml0dGVhIChzQ29udGVuaWRvVmFyKVxyXG4gICAgICAgIGNvbnN0IHNCdG4gPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbmJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9O1xyXG5jb2xvcjogJHtjb2xvclRleHRvfTtcclxuZm9udC1zaXplOiBjYWxjKCR7c0J0bn0gKiAke2ZvbnRTaXplfXB4KTtcclxuZm9udC1mYW1pbHk6ICR7Zm9udEZhbWlseX07XHJcbmZvbnQtd2VpZ2h0OiAke2ZvbnRXZWlnaHR9O1xyXG5mb250LXN0eWxlOiAke2ZvbnRTdHlsZX07XHJcbnRleHQtZGVjb3JhdGlvbjogJHt0ZXh0RGVjb3JhdGlvbn07XHJcbnRleHQtYWxpZ246ICR7YWxpZ259O1xyXG5kaXNwbGF5OiBmbGV4O1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NCdG59ICogOHB4KTtcclxuY3Vyc29yOiBwb2ludGVyO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGBcclxuPGRpdiBjbGFzcz1cIm9iamV0byBpcy1pbnRlcmFjdGl2ZSByc3ZwLWJvdG9uXCJcclxuICBpZD1cImFicmlyTW9kYWxSU1ZQXCJcclxuICBkYXRhLWFjY2lvbj1cImFicmlyLXJzdnBcIlxyXG4gIGRhdGEtcnN2cC1vcGVuXHJcbiAgcm9sZT1cImJ1dHRvblwiXHJcbiAgdGFiaW5kZXg9XCIwXCJcclxuICBhcmlhLWxhYmVsPVwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIlxyXG4gIHN0eWxlPVwiJHtzdHlsZX1cIj5cclxuICAke3RleHRvfVxyXG48L2Rpdj5cclxuYC50cmltKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gRk9STUFTIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiZm9ybWFcIikge1xyXG4gICAgICAgIGNvbnN0IGZpbGwgPSBvYmouY29sb3IgfHwgXCIjMDAwXCI7XHJcbiAgICAgICAgY29uc3QgZmlndXJhID0gb2JqLmZpZ3VyYTtcclxuXHJcbiAgICAgICAgaWYgKGZpZ3VyYSA9PT0gXCJyZWN0XCIpIHtcclxuICAgICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiAxMDA7XHJcbiAgICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiAxMDA7XHJcbiAgICAgICAgICBjb25zdCBjb3JuZXJSYWRpdXMgPSBvYmouY29ybmVyUmFkaXVzIHx8IDA7XHJcblxyXG4gICAgICAgICAgY29uc3QgZm9udFNpemUgPSBvYmouZm9udFNpemUgfHwgMjQ7XHJcbiAgICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHkgfHwgXCJzYW5zLXNlcmlmXCI7XHJcbiAgICAgICAgICBjb25zdCBmb250V2VpZ2h0ID0gb2JqLmZvbnRXZWlnaHQgfHwgXCJub3JtYWxcIjtcclxuICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IG9iai5mb250U3R5bGUgfHwgXCJub3JtYWxcIjtcclxuICAgICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9uID0gb2JqLnRleHREZWNvcmF0aW9uIHx8IFwibm9uZVwiO1xyXG4gICAgICAgICAgY29uc3QgYWxpZ24gPSBvYmouYWxpZ24gfHwgXCJjZW50ZXJcIjtcclxuICAgICAgICAgIGNvbnN0IGNvbG9yVGV4dG8gPSBvYmouY29sb3JUZXh0byB8fCBcIiMwMDAwMDBcIjtcclxuICAgICAgICAgIGNvbnN0IHRleHRvID0gZXNjSFRNTChvYmoudGV4dG8gfHwgXCJcIik7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgICBjb25zdCBzUmVjdFRleHQgPSBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbndpZHRoOiAke3B4WChvYmosIHcpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGgpfTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxuYm9yZGVyLXJhZGl1czogY2FsYygke3NSZWN0VGV4dH0gKiAke2Nvcm5lclJhZGl1c31weCk7XHJcbmRpc3BsYXk6IGZsZXg7XHJcbmFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbmp1c3RpZnktY29udGVudDogJHthbGlnbiA9PT0gXCJsZWZ0XCIgPyBcImZsZXgtc3RhcnRcIiA6IGFsaWduID09PSBcInJpZ2h0XCIgPyBcImZsZXgtZW5kXCIgOiBcImNlbnRlclwiXHJcbiAgICAgICAgICAgIH07XHJcbnRleHQtYWxpZ246ICR7YWxpZ259O1xyXG5wYWRkaW5nOiBjYWxjKCR7c1JlY3RUZXh0fSAqIDRweCk7XHJcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGlubmVyID0gYFxyXG48ZGl2IHN0eWxlPVwiXHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgZm9udC1zaXplOiBjYWxjKCR7c1JlY3RUZXh0fSAqICR7Zm9udFNpemV9cHgpO1xyXG4gIGZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xyXG4gIGZvbnQtd2VpZ2h0OiAke2ZvbnRXZWlnaHR9O1xyXG4gIGZvbnQtc3R5bGU6ICR7Zm9udFN0eWxlfTtcclxuICB0ZXh0LWRlY29yYXRpb246ICR7dGV4dERlY29yYXRpb259O1xyXG4gIGNvbG9yOiAke2NvbG9yVGV4dG99O1xyXG4gIGxpbmUtaGVpZ2h0OiAxLjI7XHJcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xyXG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XHJcblwiPiR7dGV4dG99PC9kaXY+XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7aW5uZXJ9PC9kaXY+YCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwiY2lyY2xlXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LnJhZGl1cykgPyBvYmoucmFkaXVzIDogNTA7XHJcbiAgICAgICAgICBjb25zdCBkaWFtZXRlciA9IHJhZGl1cyAqIDI7XHJcblxyXG4gICAgICAgICAgY29uc3QgeCA9IE51bWJlcihvYmo/LnggfHwgMCkgLSByYWRpdXM7XHJcbiAgICAgICAgICBjb25zdCB5UHhDZW50ZXIgPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHlQeFRvcExlZnQgPSB5UHhDZW50ZXIgLSByYWRpdXM7XHJcblxyXG4gICAgICAgICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCB4KX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgeVB4VG9wTGVmdCl9O1xyXG53aWR0aDogJHtweFgob2JqLCBkaWFtZXRlcil9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgZGlhbWV0ZXIpfTtcclxuYm9yZGVyLXJhZGl1czogNTAlO1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgc3R5bGU9XCIke3N0eWxlfVwiPjwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcImxpbmVcIikge1xyXG4gICAgICAgICAgY29uc3QgcG9pbnRzID0gb2JqLnBvaW50cyB8fCBbMCwgMCwgTElORV9DT05TVEFOVFMuREVGQVVMVF9MRU5HVEgsIDBdO1xyXG4gICAgICAgICAgY29uc3QgeDEgPSBwYXJzZUZsb2F0KHBvaW50c1swXSkgfHwgMDtcclxuICAgICAgICAgIGNvbnN0IHkxID0gcGFyc2VGbG9hdChwb2ludHNbMV0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCB4MiA9IHBhcnNlRmxvYXQocG9pbnRzWzJdKSB8fCBMSU5FX0NPTlNUQU5UUy5ERUZBVUxUX0xFTkdUSDtcclxuICAgICAgICAgIGNvbnN0IHkyID0gcGFyc2VGbG9hdChwb2ludHNbM10pIHx8IDA7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvYmouc3Ryb2tlV2lkdGggfHwgTElORV9DT05TVEFOVFMuU1RST0tFX1dJRFRIO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHgyIC0geDE7XHJcbiAgICAgICAgICBjb25zdCBkZWx0YVkgPSB5MiAtIHkxO1xyXG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XHJcbiAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpICogKDE4MCAvIE1hdGguUEkpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IE51bWJlcihvYmo/LnggfHwgMCkgKyB4MTtcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlWSA9IGdldFlQeEVkaXRvcihvYmopO1xyXG4gICAgICAgICAgY29uc3Qgc3RhcnRZID0gYmFzZVkgKyB5MTtcclxuXHJcbiAgICAgICAgICBjb25zdCB0b3RhbFJvdGF0aW9uID0gYW5nbGUgKyAob2JqLnJvdGF0aW9uIHx8IDApO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgICAgICAgLy8gYWx0byBkZSBsw61uZWE6IHVzYW1vcyBlc2NhbGEgWSBkZWwgb2JqZXRvIChjb250ZW5pZG86IHNmaW5hbC9zeCwgYmxlZWQ6IHN4KVxyXG4gICAgICAgICAgY29uc3QgbGluZUggPSBgY2FsYygke3NZKG9iail9ICogJHtzdHJva2VXaWR0aH1weClgO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgc3RhcnRYKX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgc3RhcnRZKX07XHJcbndpZHRoOiAke3B4WChvYmosIGxlbmd0aCl9O1xyXG5oZWlnaHQ6ICR7bGluZUh9O1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3RvdGFsUm90YXRpb259ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IDAgNTAlO1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxkaXYgY2xhc3M9XCJvYmpldG8gbGluZWFcIiBzdHlsZT1cIiR7c3R5bGV9XCI+PC9kaXY+YCwgb2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwidHJpYW5nbGVcIikge1xyXG4gICAgICAgICAgY29uc3QgcmFkaXVzID0gb2JqLnJhZGl1cyB8fCA2MDtcclxuXHJcbiAgICAgICAgICBjb25zdCBzaW42MCA9IE1hdGguc3FydCgzKSAvIDI7XHJcbiAgICAgICAgICBjb25zdCBjb3M2MCA9IDAuNTtcclxuXHJcbiAgICAgICAgICBjb25zdCB0cmlhbmdsZVdpZHRoID0gMiAqIHJhZGl1cyAqIHNpbjYwO1xyXG4gICAgICAgICAgY29uc3QgdHJpYW5nbGVIZWlnaHQgPSByYWRpdXMgKiAoMSArIGNvczYwKTtcclxuICAgICAgICAgIGNvbnN0IGNlbnRyb2lkT2Zmc2V0WSA9IHRyaWFuZ2xlSGVpZ2h0IC8gMztcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlWSA9IGdldFlQeEVkaXRvcihvYmopO1xyXG4gICAgICAgICAgY29uc3QgdG9wQ29udGFpbmVyUHggPSBiYXNlWSAtICh0cmlhbmdsZUhlaWdodCAtIGNlbnRyb2lkT2Zmc2V0WSk7XHJcbiAgICAgICAgICBjb25zdCBsZWZ0Q29udGFpbmVyID0gTnVtYmVyKG9iaj8ueCB8fCAwKSAtIHRyaWFuZ2xlV2lkdGggLyAyO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIGxlZnRDb250YWluZXIpfTtcclxudG9wOiAke3RvcENTU0Zyb21ZUHgob2JqLCB0b3BDb250YWluZXJQeCl9O1xyXG53aWR0aDogJHtweFgob2JqLCB0cmlhbmdsZVdpZHRoKX07XHJcbmhlaWdodDogJHtweFkob2JqLCB0cmlhbmdsZUhlaWdodCl9O1xyXG5iYWNrZ3JvdW5kOiAke2ZpbGx9O1xyXG5jbGlwLXBhdGg6IHBvbHlnb24oNTAlIDAlLCAwJSAxMDAlLCAxMDAlIDEwMCUpO1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke29iai5yb3RhdGlvbiA/PyAwfWRlZykgc2NhbGUoJHtvYmouc2NhbGVYID8/IDF9LCAke29iai5zY2FsZVkgPz8gMX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xyXG5wb2ludGVyLWV2ZW50czogYXV0bztcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxkaXYgY2xhc3M9XCJvYmpldG9cIiBzdHlsZT1cIiR7YmFzZVN0eWxlfVwiPjwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9KVxyXG4gICAgLmpvaW4oXCJcXG5cIik7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkxJTkVfQ09OU1RBTlRTIiwiZXNjSFRNTCIsInN0ciIsIlN0cmluZyIsInJlcGxhY2UiLCJlc2NhcGVBdHRyIiwiZ2V0TGlua1Byb3BzIiwib2JqIiwicmF3IiwiZW5sYWNlIiwiaHJlZiIsInRhcmdldCIsInJlbCIsImVudm9sdmVyU2lFbmxhY2UiLCJodG1sRWxlbWVudG8iLCJ0aXBvIiwibGluayIsImVzY2FwZUhUTUwiLCJ0ZXh0byIsImdlbmVyYXJIVE1MRGVzZGVPYmpldG9zIiwib2JqZXRvcyIsIl9zZWNjaW9uZXMiLCJhbHRvTW9kb1BvclNlY2Npb24iLCJNYXAiLCJtYXAiLCJzIiwiaWQiLCJhbHRvTW9kbyIsInRvTG93ZXJDYXNlIiwiZXNTZWNjaW9uUGFudGFsbGEiLCJtb2RvIiwiZ2V0Iiwic2VjY2lvbklkIiwiaXNGdWxsQmxlZWQiLCJhbmNsYWplIiwic0NvbnRlbmlkb1ZhciIsInNYIiwic1kiLCJweFgiLCJweCIsIm4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInB4WSIsIkFMVFVSQV9FRElUT1JfUEFOVEFMTEEiLCJQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYIiwiY2xhbXAwMSIsIngiLCJNYXRoIiwibWF4IiwibWluIiwiZ2V0WVB4RWRpdG9yIiwieW4iLCJ5Tm9ybSIsInlQeCIsInkiLCJ0b3BDU1MiLCJ5UHhFZGl0b3IiLCJkZXNpZ25TY2FsZWRIIiwiY2VudGVyT2Zmc2V0IiwidG9wQ1NTRnJvbVlQeCIsInN0eWxlUG9zQmFzZSIsInJvdCIsInJvdGF0aW9uIiwic2NhbGVYIiwic2NhbGVZIiwiekluZGV4IiwidW5kZWZpbmVkIiwidHJpbSIsInN0eWxlU2l6ZSIsInciLCJoIiwid3ciLCJoaCIsInBhcnRzIiwicHVzaCIsImpvaW4iLCJyZW5kZXJJY29ub1N2Z051ZXZvSW5saW5lIiwidmlld0JveCIsImNvbG9yIiwicGF0aHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ3aWR0aCIsImhlaWdodCIsInBhdGhzSHRtbCIsInAiLCJkIiwic3R5bGUiLCJhbGlnbiIsInRleHRBbGlnbiIsImNvbG9yVGV4dG8iLCJmaWxsIiwiYmFzZUxpbmVIZWlnaHQiLCJsaW5lSGVpZ2h0IiwibGluZUhlaWdodEZpbmFsIiwic2FmZVRleHRvIiwiYmFzZVN0eWxlIiwiZnMiLCJmb250U2l6ZSIsInNGb250Iiwib3JpZ2luIiwieENvbXAiLCJmb250RmFtaWx5IiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsInRleHREZWNvcmF0aW9uIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzaGFkb3dDb2xvciIsInNoYWRvd09mZnNldFgiLCJzaGFkb3dPZmZzZXRZIiwic2hhZG93Qmx1ciIsInNyYyIsInVybCIsImZvcm1hdG8iLCJzdmdIdG1sIiwidmIiLCJzdmciLCJ0YXJnZXRJU08iLCJmZWNoYU9iamV0aXZvIiwiZmVjaGFJU08iLCJ0ZXh0Q29sb3IiLCJwcmVzZXQiLCJwcmVzZXRJZCIsImxheW91dCIsImlzTWluaW1hbCIsImluY2x1ZGVzIiwid09iaiIsImhPYmoiLCJnYXAiLCJzcGFjaW5nIiwiY2hpcFdpZHRoUHJvcCIsImNoaXBXaWR0aCIsInBhZGRpbmdYUHJvcCIsInBhZGRpbmdYIiwiY2hpcFdUb3RhbCIsInJvdW5kIiwicGFkZGluZ1kiLCJ2YWx1ZVNpemUiLCJsYWJlbFNpemUiLCJsYWJlbENvbG9yIiwibGV0dGVyU3BhY2luZyIsImNvbnRhaW5lckJnRmluYWwiLCJjaGlwQmdGaW5hbCIsImNoaXBCYWNrZ3JvdW5kIiwiYm94QmciLCJjaGlwQm9yZGVyQ29sb3JGaW5hbCIsImNoaXBCb3JkZXIiLCJib3hCb3JkZXIiLCJjb250YWluZXJSYWRpdXMiLCJib3hSYWRpdXMiLCJyYWRpdXMiLCJjaGlwUmFkaXVzRmluYWwiLCJjaGlwUmFkaXVzIiwic0NoaXAiLCJjb250YWluZXJTdHlsZSIsImNoaXBTdHlsZSIsInZhbHVlU3R5bGUiLCJsYWJlbFN0eWxlIiwic2hvd0xhYmVscyIsImxhYmVscyIsImRpYXMiLCJob3JhcyIsInNlZyIsInJvd3MiLCJwYXJzZUludCIsImNvbHMiLCJnYXBQeCIsInJhZGl1c1B4Iiwic0dyaWQiLCJzdHlsZUNvbnRlbmVkb3IiLCJ0b3RhbCIsImNlbGxzIiwiZnJvbSIsIl8iLCJpIiwiYyIsIm1lZGlhVXJsIiwiZml0IiwiYmciLCJodG1sQ2VsZGFzIiwiY2VsbCIsImlkeCIsInNhZmVTcmMiLCJjZWxkYVN0eWxlIiwiaHRtbEdhbGVyaWEiLCJhbmNobyIsImFsdG8iLCJzQnRuIiwiZmlndXJhIiwiY29ybmVyUmFkaXVzIiwic1JlY3RUZXh0IiwiaW5uZXIiLCJkaWFtZXRlciIsInlQeENlbnRlciIsInlQeFRvcExlZnQiLCJwb2ludHMiLCJERUZBVUxUX0xFTkdUSCIsIngxIiwicGFyc2VGbG9hdCIsInkxIiwieDIiLCJ5MiIsIlNUUk9LRV9XSURUSCIsImRlbHRhWCIsImRlbHRhWSIsInNxcnQiLCJhbmdsZSIsImF0YW4yIiwiUEkiLCJzdGFydFgiLCJiYXNlWSIsInN0YXJ0WSIsInRvdGFsUm90YXRpb24iLCJsaW5lSCIsInNpbjYwIiwiY29zNjAiLCJ0cmlhbmdsZVdpZHRoIiwidHJpYW5nbGVIZWlnaHQiLCJjZW50cm9pZE9mZnNldFkiLCJ0b3BDb250YWluZXJQeCIsImxlZnRDb250YWluZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeObjetos.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeSecciones.ts":
/*!**********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeSecciones.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarHTMLDesdeSecciones: () => (/* binding */ generarHTMLDesdeSecciones)\n/* harmony export */ });\n/* harmony import */ var _generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generarHTMLDesdeObjetos */ \"(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeObjetos.ts\");\n/* harmony import */ var _models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/dimensionesBase */ \"(pages-dir-browser)/./functions/src/models/dimensionesBase.ts\");\n/* harmony import */ var _generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generarModalRSVP */ \"(pages-dir-browser)/./functions/src/utils/generarModalRSVP.ts\");\n/* harmony import */ var _generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generarModalGaleria */ \"(pages-dir-browser)/./functions/src/utils/generarModalGaleria.ts\");\n/* harmony import */ var _mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mobileSmartSectionLayout */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartSectionLayout.ts\");\n\n\n\n\n\nconst ENABLE_MOBILE_SMART_LAYOUT = true; // ✅ empezamos apagado\nconst EXCLUDE_FONTS = new Set([\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\",\n    \"Arial\",\n    \"Helvetica\",\n    \"Times\",\n    \"Times New Roman\",\n    \"Georgia\",\n    \"Courier New\"\n]);\nconst ALTURA_REFERENCIA_PANTALLA = 500;\n// ✅ Offsets SOLO para texto en secciones Pantalla: ON\n// - Desktop: aplica cuando vw > 767px\n// - Mobile: aplica cuando vw <= 767px\n// (Estos valores se vuelcan a CSS variables en :root)\nconst PANTALLA_Y_OFFSET_DESKTOP_PX = -28;\nconst PANTALLA_Y_OFFSET_MOBILE_PX = 0;\nfunction buildGoogleFontsLink(fonts) {\n    const familias = fonts.map((f)=>f.replace(/['\"]/g, \"\").split(\",\")[0].trim()).filter((n)=>n && !EXCLUDE_FONTS.has(n)).map((n)=>\"family=\".concat(n.replace(/ /g, \"+\"))).join(\"&\");\n    if (!familias) return \"\";\n    return '\\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\\n<link href=\"https://fonts.googleapis.com/css2?'.concat(familias, '&display=swap\" rel=\"stylesheet\">').trim();\n}\nfunction escapeAttr() {\n    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction buildFondoStyle(seccion) {\n    const fondoValue = (seccion === null || seccion === void 0 ? void 0 : seccion.fondo) || \"transparent\";\n    const esImagenFondo = (seccion === null || seccion === void 0 ? void 0 : seccion.fondoTipo) === \"imagen\" && (seccion === null || seccion === void 0 ? void 0 : seccion.fondoImagen);\n    let estilosFondo = \"\";\n    if (esImagenFondo) {\n        let imageUrl = seccion.fondoImagen;\n        if (imageUrl && imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        let backgroundPosition = \"center center\";\n        if (seccion.fondoImagenOffsetX !== undefined || seccion.fondoImagenOffsetY !== undefined) {\n            const offsetX = seccion.fondoImagenOffsetX || 0;\n            const offsetY = seccion.fondoImagenOffsetY || 0;\n            const offsetXPercent = offsetX !== 0 ? \"calc(50% - \".concat(-offsetX, \"px)\") : \"50%\";\n            const offsetYPercent = offsetY !== 0 ? \"calc(50% - \".concat(-offsetY, \"px)\") : \"50%\";\n            backgroundPosition = \"\".concat(offsetXPercent, \" \").concat(offsetYPercent);\n        }\n        estilosFondo = \"background-image: url('\".concat(imageUrl, \"'); background-size: cover; background-position: \").concat(backgroundPosition, \"; background-repeat: no-repeat;\");\n    } else if (fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\")) {\n        let imageUrl = fondoValue.replace(\"url(\", \"\").replace(\")\", \"\");\n        if (imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        estilosFondo = \"background-image: url('\".concat(imageUrl, \"'); background-size: cover; background-position: center center; background-repeat: no-repeat;\");\n    } else {\n        estilosFondo = \"background: \".concat(fondoValue, \";\");\n    }\n    return estilosFondo.replace(/\\s+/g, \" \").trim();\n}\nfunction generarHTMLDesdeSecciones(secciones, objetos, rsvp, opciones, opts) {\n    var _opciones_slug;\n    const slug = (_opciones_slug = opciones === null || opciones === void 0 ? void 0 : opciones.slug) !== null && _opciones_slug !== void 0 ? _opciones_slug : \"\";\n    var _opts_slug;\n    const slugPublica = (_opts_slug = opts === null || opts === void 0 ? void 0 : opts.slug) !== null && _opts_slug !== void 0 ? _opts_slug : \"\";\n    const fuentesUsadas = [\n        ...new Set(objetos.filter((o)=>(o.tipo === \"texto\" || o.tipo === \"countdown\") && o.fontFamily).map((o)=>o.fontFamily))\n    ];\n    const googleFontsLink = buildGoogleFontsLink(fuentesUsadas);\n    const hayRSVPEnCanvas = objetos === null || objetos === void 0 ? void 0 : objetos.some((o)=>o.tipo === \"rsvp-boton\");\n    const botonRSVP = \"\"; // (si querés agregar un botón fijo fuera del canvas, hacelo acá)\n    const modalRSVP = hayRSVPEnCanvas && (rsvp === null || rsvp === void 0 ? void 0 : rsvp.enabled) ? (0,_generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__.generarModalRSVPHTML)(rsvp) : \"\";\n    const modalGaleria = (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.hayGaleriaConImagenes)(objetos) ? (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.generarModalGaleriaHTML)() : \"\";\n    function hayCountdown(objs) {\n        return Array.isArray(objs) && objs.some((o)=>(o === null || o === void 0 ? void 0 : o.tipo) === \"countdown\");\n    }\n    const scriptCountdown = hayCountdown(objetos) ? '\\n<script>\\n(function(){\\n  function pad(n){ n=Math.floor(Math.abs(n)); return n<10 ? \"0\"+n : \"\"+n; }\\n  function diffParts(target){\\n    const now = Date.now();\\n    let ms = Math.max(0, target.getTime() - now);\\n    const d = Math.floor(ms / 86400000); ms -= d*86400000;\\n    const h = Math.floor(ms / 3600000);  ms -= h*3600000;\\n    const m = Math.floor(ms / 60000);    ms -= m*60000;\\n    const s = Math.floor(ms / 1000);\\n    return { d, h, m, s };\\n  }\\n  function tickOne(root){\\n    const iso = root.getAttribute(\"data-target\");\\n    if(!iso) return;\\n    const t = new Date(iso);\\n    if(isNaN(t.getTime())) return;\\n    const p = diffParts(t);\\n    const vals = root.querySelectorAll(\".cd-val\");\\n    if(vals && vals.length >= 4){\\n      vals[0].textContent = String(p.d).padStart(2,\"0\");\\n      vals[1].textContent = pad(p.h);\\n      vals[2].textContent = pad(p.m);\\n      vals[3].textContent = pad(p.s);\\n    }\\n  }\\n  function boot(){\\n    const roots = Array.from(document.querySelectorAll(\"[data-countdown]\"));\\n    if(!roots.length) return;\\n    roots.forEach(tickOne);\\n    setInterval(() => roots.forEach(tickOne), 1000);\\n  }\\n  if(document.readyState === \"loading\"){\\n    document.addEventListener(\"DOMContentLoaded\", boot);\\n  } else {\\n    boot();\\n  }\\n})();\\n</script>\\n'.trim() : \"\";\n    const seccionesOrdenadas = [\n        ...secciones || []\n    ].sort((a, b)=>(Number(a === null || a === void 0 ? void 0 : a.orden) || 0) - (Number(b === null || b === void 0 ? void 0 : b.orden) || 0));\n    const htmlSecciones = seccionesOrdenadas.map((seccion)=>{\n        const modo = String((seccion === null || seccion === void 0 ? void 0 : seccion.altoModo) || \"fijo\").toLowerCase();\n        const hbase = Number.isFinite(seccion === null || seccion === void 0 ? void 0 : seccion.altura) ? Number(seccion.altura) : 600;\n        const objsDeSeccion = objetos.filter((o)=>o.seccionId === seccion.id);\n        const objsBleed = objsDeSeccion.filter((o)=>String((o === null || o === void 0 ? void 0 : o.anclaje) || \"\").toLowerCase() === \"fullbleed\");\n        const objsContenido = objsDeSeccion.filter((o)=>String((o === null || o === void 0 ? void 0 : o.anclaje) || \"\").toLowerCase() !== \"fullbleed\");\n        const fondoStyle = buildFondoStyle(seccion);\n        const htmlBleed = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsBleed, seccionesOrdenadas);\n        const htmlContenido = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsContenido, seccionesOrdenadas);\n        return '\\n<section class=\"sec\" data-modo=\"'.concat(escapeAttr(modo), '\" style=\"--hbase:').concat(hbase, '\">\\n  <div class=\"sec-zoom\">\\n    <div class=\"sec-bg\" style=\"').concat(fondoStyle, '\"></div>\\n    <div class=\"sec-bleed\">').concat(htmlBleed, '</div>\\n    <div class=\"sec-content\">').concat(htmlContenido, \"</div>\\n  </div>\\n</section>\\n\").trim();\n    }).join(\"\\n\");\n    const scriptMobileSmart = (0,_mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__.buildMobileSmartSectionLayoutScript)({\n        enabled: ENABLE_MOBILE_SMART_LAYOUT,\n        minGapPx: 1,\n        paddingTopPx: 0,\n        paddingBottomPx: 2,\n        onlyFixedSections: true,\n        minPerColumn2: 1,\n        fitMinScale: 0.88,\n        fitMaxScale: 1.16,\n        fitTargetWidthRatio: 0.94,\n        fitMinFillRatio: 0.9\n    });\n    return '\\n<!DOCTYPE html>\\n<html lang=\"es\"'.concat(slug ? ' data-slug=\"'.concat(escapeAttr(slug), '\"') : \"\", '>\\n<head>\\n  <meta charset=\"UTF-8\" />\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\" />\\n  <title>Invitaci\\xf3n</title>\\n  ').concat(googleFontsLink, \"\\n  <style>\\n    * { box-sizing: border-box; margin: 0; padding: 0; }\\n\\n    html, body {\\n      width: 100%;\\n      height: 100%;\\n      background: white;\\n      overflow-x: hidden;\\n      font-family: sans-serif;\\n    }\\n\\n    /* ✅ SOLO MOBILE: evita “auto-resize / font boosting” del texto */\\n    @media (max-width: 767px){\\n      html{\\n        -webkit-text-size-adjust: 100%;\\n        text-size-adjust: 100%;\\n      }\\n      \\n        :root{ --text-zoom: 1.25; } /* prob\\xe1 1.10–1.25 */\\n    }\\n\\n    :root{\\n      --safe-top: env(safe-area-inset-top, 0px);\\n      --safe-right: env(safe-area-inset-right, 0px);\\n      --safe-bottom: env(safe-area-inset-bottom, 0px);\\n      --safe-left: env(safe-area-inset-left, 0px);\\n      --bp-mobile: 767px;\\n      \\n\\n\\n      /* Global scales */\\n      --content-w: \").concat(_models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__.CANVAS_BASE.ANCHO, \"px;\\n      --sx: 1;   /* contentW/800 */\\n      --bx: 1;   /* viewportW/800 */\\n\\n      /* vh l\\xf3gico por defecto */\\n      --vh-safe: 100vh;\\n      --vh-logical: var(--vh-safe);\\n\\n      /* ✅ Offset SOLO para texto en Pantalla: ON (desktop default) */\\n      --pantalla-y-offset: \").concat(PANTALLA_Y_OFFSET_DESKTOP_PX, \"px;\\n    }\\n\\n    /* ✅ Mobile: offset distinto SOLO para texto en Pantalla: ON */\\n    @media (max-width: 767px){\\n      :root{\\n        --pantalla-y-offset: \").concat(PANTALLA_Y_OFFSET_MOBILE_PX, 'px;\\n      }\\n    }\\n\\n    .inv{ width: 100%; background: white; }\\n\\n    .sec{\\n      position: relative;\\n      width: 100vw;\\n      left: 50%;\\n      transform: translateX(-50%);\\n      overflow: visible; /* bleed puede salirse */\\n    }\\n\\n    /* ✅ Wrapper que hace “zoom” centrado (evita corrimiento a la derecha) */\\n    .sec-zoom{\\n      position: relative;\\n      width: 100%;\\n      height: 100%;\\n      transform-origin: top center;\\n      transform: scale(var(--zoom, 1));\\n    }\\n\\n    /* ✅ Pantalla ON: recorte para que el zoom no desborde */\\n    .sec[data-modo=\"pantalla\"]{\\n      overflow: hidden;\\n      height: 100dvh;\\n      height: 100vh;\\n      padding-top: var(--safe-top);\\n      padding-bottom: var(--safe-bottom);\\n\\n      /* fallback CSS (JS lo pisa en mobile con px reales) */\\n      --vh-safe: calc(100dvh - var(--safe-top) - var(--safe-bottom));\\n\\n      /* el zoom extra va por --zoom (NO por sfinal) */\\n      --zoom: 1;\\n      --bgzoom: 1;\\n\\n      /* factor final para CONTENIDO (se setea por JS) */\\n      --sfinal: 1;\\n    }\\n\\n    .sec[data-modo=\"fijo\"]{\\n      /* altura fija escalada por ancho; JS setea --sfinal = sx */\\n      height: calc(var(--sfinal) * var(--hbase) * 1px);\\n      --zoom: 1;\\n      --bgzoom: 1;\\n    }\\n\\n    /* Fondo */\\n    .sec-bg{\\n      position: absolute;\\n      inset: 0;\\n      z-index: 0;\\n      pointer-events: none;\\n    }\\n\\n    /* ✅ Fondo agrandable solo en pantalla (acompa\\xf1a el zoom hero) */\\n    .sec[data-modo=\"pantalla\"] .sec-bg{\\n      transform: scale(var(--bgzoom, 1));\\n      transform-origin: center;\\n    }\\n\\n    .sec-bleed{\\n      position: absolute;\\n      inset: 0;\\n      z-index: 2;\\n      overflow: visible;\\n      pointer-events: none;\\n    }\\n\\n    .sec-content{\\n      position: relative;\\n      z-index: 3;\\n      width: var(--content-w);\\n      margin: 0 auto;\\n      height: 100%;\\n      pointer-events: none;\\n    }\\n\\n    /* ✅ Pantalla ON: el ancho del “content” puede crecer con la escala vertical */\\n    .sec[data-modo=\"pantalla\"] .sec-content{\\n      width: var(--content-w-pantalla, var(--content-w));\\n    }\\n\\n    @media (max-width: 767px){\\n      .sec-content{\\n        width: 100%;\\n        margin: 0;\\n        box-sizing: border-box;\\n        padding-left: var(--safe-left);\\n        padding-right: var(--safe-right);\\n      }\\n    }\\n\\n    .objeto{\\n      position: absolute;\\n      transform-origin: top left;\\n      overflow: visible;\\n      pointer-events: auto;\\n    }\\n\\n    .objeto.is-interactive{ pointer-events: auto; }\\n\\n    .cd-chip { backdrop-filter: saturate(1.1); }\\n  </style>\\n</head>\\n\\n<body data-slug=\"').concat(escapeAttr(slugPublica), '\">\\n  <div class=\"inv\">\\n    ').concat(htmlSecciones, \"\\n  </div>\\n\\n  \").concat(botonRSVP, \"\\n  \").concat(modalRSVP, \"\\n  \").concat(modalGaleria, \"\\n\\n  \").concat(scriptCountdown, '\\n\\n  <script>\\n    (function(){\\n      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }\\n\\n      function compute(){\\n        var vw = document.documentElement.clientWidth;\\n        var BASE_W = 800; // = CANVAS_BASE.ANCHO\\n\\n        // contentW (sin vw-32)\\n        var contentW = Math.min(BASE_W, vw);\\n\\n        var sx = contentW / BASE_W;\\n        var bx = vw / BASE_W;\\n\\n        document.documentElement.style.setProperty(\"--content-w\", contentW + \"px\");\\n        document.documentElement.style.setProperty(\"--sx\", String(sx));\\n        document.documentElement.style.setProperty(\"--bx\", String(bx));\\n\\n        var secs = Array.from(document.querySelectorAll(\".sec\"));\\n        var isMobile = vw <= 767;\\n\\n        // viewport real (m\\xe1s estable en mobile)\\n        var vv = window.visualViewport;\\n        var viewportH = (vv && vv.height) ? vv.height : window.innerHeight;\\n\\n        // safe areas (css env)\\n        var safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-top\")) || 0;\\n        var safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-bottom\")) || 0;\\n\\n        // dise\\xf1o base del modo \"pantalla\" (800 x 500)\\n        var DESIGN_W = BASE_W;\\n        var DESIGN_H = ').concat(ALTURA_REFERENCIA_PANTALLA, '; // = ALTURA_REFERENCIA_PANTALLA\\n        var designAR = DESIGN_H / DESIGN_W; // 0.625\\n        var deviceAR = viewportH / vw;\\n\\n        // zoom extra (solo si el device es m\\xe1s vertical que el dise\\xf1o)\\n        var zoomExtra = 1;\\n        if (isMobile && deviceAR > designAR){\\n          var k = deviceAR / designAR;\\n          zoomExtra = clamp(1 + (k - 1) * 0.18, 1, 1.35);\\n        }\\n\\n        // \\uD83D\\uDD27 Ajuste fino: cu\\xe1nto acompa\\xf1a el fondo al zoom hero (0..1.2)\\n        // 0   => el fondo NO agrega zoom extra propio (solo el zoom del wrapper)\\n        // 1   => comportamiento actual (fondo queda zoomExtra\\xb2)\\n        // 0.3 => recomendado para empezar (sutil)\\n        var BG_ZOOM_FACTOR = 0;\\n\\n        // \\uD83D\\uDD27 Ajuste fino: cu\\xe1nto acompa\\xf1a el CONTENIDO (texto/objetos) al zoom hero\\n        // 0   => comportamiento actual\\n        // 0.3 => recomendado\\n        // 1   => texto escala igual que el hero (no aconsejado)\\n        var TEXT_ZOOM_FACTOR = 0;\\n\\n\\n        secs.forEach(function(sec){\\n          var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n\\n          // defaults\\n          var zoom = 1;\\n          var bgzoom = 1;\\n\\n          // ✅ Por defecto, tama\\xf1os escalan por ancho (comportamiento actual)\\n          var sfinal = sx;\\n\\n          // limpiar custom width si no aplica\\n          sec.style.removeProperty(\"--content-w-pantalla\");\\n\\n          if (modo === \"pantalla\"){\\n            // vh-safe real en px\\n            var vhSafePx = Math.max(0, viewportH - safeTop - safeBottom);\\n            sec.style.setProperty(\"--vh-safe\", vhSafePx + \"px\");\\n\\n            // \\uD83D\\uDD25 Desktop: escalar el contenido por ALTURA (vhSafe/500)\\n            // Esto alinea el HTML publicado con lo que ves en preview\\n            if (!isMobile){\\n              var sh = vhSafePx / DESIGN_H;\\n              sfinal = sh;\\n\\n              // para que el \"content\" quede centrado y coherente con la nueva escala vertical\\n              sec.style.setProperty(\"--content-w-pantalla\", (DESIGN_W * sh) + \"px\");\\n            }\\n\\n            // ✅ Mobile: mantenemos tu comportamiento actual (zoom hero suave)\\n            if (isMobile){\\n              zoom = zoomExtra;\\n              bgzoom = 1 + (zoomExtra - 1) * BG_ZOOM_FACTOR;\\n\\n              // \\uD83D\\uDD25 NUEVO: el contenido acompa\\xf1a parcialmente el zoom\\n              sfinal = sx * (1 + (zoomExtra - 1) * TEXT_ZOOM_FACTOR);\\n            }\\n          }\\n\\n          sec.style.setProperty(\"--sfinal\", String(sfinal));\\n          sec.style.setProperty(\"--zoom\", String(zoom));\\n          sec.style.setProperty(\"--bgzoom\", String(bgzoom));\\n\\n          // ✅ Solo en mobile + pantalla: corregir el \"vh\" que despu\\xe9s se escala con zoom\\n          if (isMobile && modo === \"pantalla\") {\\n            // --vh-logical = --vh-safe / --zoom\\n            sec.style.setProperty(\"--vh-logical\", \"calc(var(--vh-safe) / var(--zoom))\");\\n          } else {\\n            // resto: se comporta como siempre\\n            sec.style.setProperty(\"--vh-logical\", \"var(--vh-safe)\");\\n          }\\n        });\\n\\n\\n      }\\n\\n      window.addEventListener(\"load\", compute);\\n      window.addEventListener(\"resize\", compute);\\n\\n      if (window.visualViewport){\\n        window.visualViewport.addEventListener(\"resize\", compute);\\n        window.visualViewport.addEventListener(\"scroll\", compute);\\n      }\\n\\n      window.addEventListener(\"orientationchange\", function(){\\n        setTimeout(compute, 50);\\n        setTimeout(compute, 250);\\n      });\\n\\n      compute();\\n    })();\\n  </script>\\n\\n    \\n\\n\\n   ').concat(scriptMobileSmart, \"\\n \\n</body>\\n</html>\\n\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0U7QUFDWjtBQUNrQztBQUNIO0FBQ047QUFFakYsTUFBTU0sNkJBQTZCLE1BQU0sc0JBQXNCO0FBRS9ELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJO0lBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsNkJBQTZCO0FBRW5DLHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxNQUFNQywrQkFBK0IsQ0FBQztBQUN0QyxNQUFNQyw4QkFBOEI7QUFFcEMsU0FBU0MscUJBQXFCQyxLQUFlO0lBQzNDLE1BQU1DLFdBQVdELE1BQ2RFLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxPQUFPLENBQUMsU0FBUyxJQUFJQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxJQUNwREMsTUFBTSxDQUFDLENBQUNDLElBQU1BLEtBQUssQ0FBQ2QsY0FBY2UsR0FBRyxDQUFDRCxJQUN0Q04sR0FBRyxDQUFDLENBQUNNLElBQU0sVUFBK0IsT0FBckJBLEVBQUVKLE9BQU8sQ0FBQyxNQUFNLE9BQ3JDTSxJQUFJLENBQUM7SUFFUixJQUFJLENBQUNULFVBQVUsT0FBTztJQUV0QixPQUFPLHlIQUVnRCxPQUFUQSxVQUFTLG9DQUFrQ0ssSUFBSTtBQUMvRjtBQU1BLFNBQVNLO1FBQVdDLE1BQUFBLGlFQUFjO0lBQ2hDLE9BQU9DLE9BQU9ELEtBQ1hSLE9BQU8sQ0FBQyxNQUFNLFNBQ2RBLE9BQU8sQ0FBQyxNQUFNLFVBQ2RBLE9BQU8sQ0FBQyxNQUFNLFFBQ2RBLE9BQU8sQ0FBQyxNQUFNO0FBQ25CO0FBRUEsU0FBU1UsZ0JBQWdCQyxPQUFZO0lBQ25DLE1BQU1DLGFB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LFdBQVdoQjtRQUNyRCxNQUFNcUIsZ0JBQWdCM0YsaUZBQXVCQSxDQUFDd0YsZUFBZWxCO1FBRzdELE9BQU8scUNBQ3lEVSxPQUFwQ3hELFdBQVdxRCxPQUFNLHFCQUVsQlksT0FGcUNULE9BQU0saUVBRy9DVSxPQURJRCxZQUFXLHlDQUViRSxPQURGRCxXQUFVLHlDQUNNLE9BQWRDLGVBQWMsa0NBRzNDeEUsSUFBSTtJQUNGLEdBQ0NJLElBQUksQ0FBQztJQUVSLE1BQU1xRSxvQkFBb0J2Riw4RkFBbUNBLENBQUM7UUFDNUQwRCxTQUFTekQ7UUFDVHVGLFVBQVU7UUFDVkMsY0FBYztRQUNkQyxpQkFBaUI7UUFDakJDLG1CQUFtQjtRQUNuQkMsZUFBZTtRQUNmQyxhQUFhO1FBQ2JDLGFBQWE7UUFDYkMscUJBQXFCO1FBQ3JCQyxpQkFBaUI7SUFDbkI7SUFFQSxPQUFPLHFDQU9MM0MsT0FMYU4sT0FBTyxlQUFnQyxPQUFqQjVCLFdBQVc0QixPQUFNLE9BQUssSUFBRyw2S0FxQzNDbkQsT0FoQ2pCeUQsaUJBQWdCLGt6QkF5Q1NoRCxPQVRSVCxnRUFBV0EsQ0FBQ3FHLEtBQUssRUFBQywrUkFlUjNGLE9BTkZELDhCQUE2QixrS0FrSHZDYyxPQTVHWWIsNkJBQTRCLDZrRkE4R3JEaUUsT0FGYXBELFdBQVc2QixjQUFhLGlDQUt2Q1EsT0FIRWUsZUFBYyxvQkFJaEJkLE9BREFELFdBQVUsUUFFVkcsT0FEQUYsV0FBVSxRQUdWTyxPQUZBTCxjQUFhLFVBbUNRdkQsT0FqQ3JCNEQsaUJBQWdCLDJ3Q0FvSWZ1QixPQW5Hb0JuRiw0QkFBMkIseWlIQW1HN0IsT0FBbEJtRixtQkFBa0I7QUFLdkIiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyB9IGZyb20gXCIuL2dlbmVyYXJIVE1MRGVzZGVPYmpldG9zXCI7XG5pbXBvcnQgeyBDQU5WQVNfQkFTRSB9IGZyb20gXCIuLi9tb2RlbHMvZGltZW5zaW9uZXNCYXNlXCI7XG5pbXBvcnQgeyBnZW5lcmFyTW9kYWxSU1ZQSFRNTCwgdHlwZSBSU1ZQQ29uZmlnIGFzIE1vZGFsQ29uZmlnIH0gZnJvbSBcIi4vZ2VuZXJhck1vZGFsUlNWUFwiO1xuaW1wb3J0IHsgZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwsIGhheUdhbGVyaWFDb25JbWFnZW5lcyB9IGZyb20gXCIuL2dlbmVyYXJNb2RhbEdhbGVyaWFcIjtcbmltcG9ydCB7IGJ1aWxkTW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0U2NyaXB0IH0gZnJvbSBcIi4vbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0XCI7XG5cclxuY29uc3QgRU5BQkxFX01PQklMRV9TTUFSVF9MQVlPVVQgPSB0cnVlOyAvLyDinIUgZW1wZXphbW9zIGFwYWdhZG9cclxuXHJcbmNvbnN0IEVYQ0xVREVfRk9OVFMgPSBuZXcgU2V0KFtcclxuICBcInNlcmlmXCIsXHJcbiAgXCJzYW5zLXNlcmlmXCIsXHJcbiAgXCJtb25vc3BhY2VcIixcclxuICBcImN1cnNpdmVcIixcclxuICBcImZhbnRhc3lcIixcclxuICBcInN5c3RlbS11aVwiLFxyXG4gIFwiQXJpYWxcIixcclxuICBcIkhlbHZldGljYVwiLFxyXG4gIFwiVGltZXNcIixcclxuICBcIlRpbWVzIE5ldyBSb21hblwiLFxyXG4gIFwiR2VvcmdpYVwiLFxyXG4gIFwiQ291cmllciBOZXdcIixcclxuXSk7XHJcblxyXG5jb25zdCBBTFRVUkFfUkVGRVJFTkNJQV9QQU5UQUxMQSA9IDUwMDtcclxuXHJcbi8vIOKchSBPZmZzZXRzIFNPTE8gcGFyYSB0ZXh0byBlbiBzZWNjaW9uZXMgUGFudGFsbGE6IE9OXHJcbi8vIC0gRGVza3RvcDogYXBsaWNhIGN1YW5kbyB2dyA+IDc2N3B4XHJcbi8vIC0gTW9iaWxlOiBhcGxpY2EgY3VhbmRvIHZ3IDw9IDc2N3B4XHJcbi8vIChFc3RvcyB2YWxvcmVzIHNlIHZ1ZWxjYW4gYSBDU1MgdmFyaWFibGVzIGVuIDpyb290KVxyXG5jb25zdCBQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYID0gLTI4O1xyXG5jb25zdCBQQU5UQUxMQV9ZX09GRlNFVF9NT0JJTEVfUFggPSAwO1xyXG5cclxuZnVuY3Rpb24gYnVpbGRHb29nbGVGb250c0xpbmsoZm9udHM6IHN0cmluZ1tdKTogc3RyaW5nIHtcclxuICBjb25zdCBmYW1pbGlhcyA9IGZvbnRzXHJcbiAgICAubWFwKChmKSA9PiBmLnJlcGxhY2UoL1snXCJdL2csIFwiXCIpLnNwbGl0KFwiLFwiKVswXS50cmltKCkpXHJcbiAgICAuZmlsdGVyKChuKSA9PiBuICYmICFFWENMVURFX0ZPTlRTLmhhcyhuKSlcclxuICAgIC5tYXAoKG4pID0+IGBmYW1pbHk9JHtuLnJlcGxhY2UoLyAvZywgXCIrXCIpfWApXHJcbiAgICAuam9pbihcIiZcIik7XHJcblxyXG4gIGlmICghZmFtaWxpYXMpIHJldHVybiBcIlwiO1xyXG5cclxuICByZXR1cm4gYFxyXG48bGluayByZWw9XCJwcmVjb25uZWN0XCIgaHJlZj1cImh0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb21cIiBjcm9zc29yaWdpbj5cclxuPGxpbmsgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj8ke2ZhbWlsaWFzfSZkaXNwbGF5PXN3YXBcIiByZWw9XCJzdHlsZXNoZWV0XCI+YC50cmltKCk7XHJcbn1cclxuXHJcbnR5cGUgR2VuZXJhckhUTUxPcGNpb25lcyA9IHtcclxuICBzbHVnPzogc3RyaW5nO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZXNjYXBlQXR0cihzdHI6IHN0cmluZyA9IFwiXCIpOiBzdHJpbmcge1xyXG4gIHJldHVybiBTdHJpbmcoc3RyKVxyXG4gICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxyXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcclxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRGb25kb1N0eWxlKHNlY2Npb246IGFueSk6IHN0cmluZyB7XHJcbiAgY29uc3QgZm9uZG9WYWx1ZSA9IHNlY2Npb24/LmZvbmRvIHx8IFwidHJhbnNwYXJlbnRcIjtcclxuICBjb25zdCBlc0ltYWdlbkZvbmRvID0gc2VjY2lvbj8uZm9uZG9UaXBvID09PSBcImltYWdlblwiICYmIHNlY2Npb24/LmZvbmRvSW1hZ2VuO1xyXG5cclxuICBsZXQgZXN0aWxvc0ZvbmRvID0gXCJcIjtcclxuXHJcbiAgaWYgKGVzSW1hZ2VuRm9uZG8pIHtcclxuICAgIGxldCBpbWFnZVVybCA9IHNlY2Npb24uZm9uZG9JbWFnZW47XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBpbWFnZVVybCAmJlxyXG4gICAgICBpbWFnZVVybC5pbmNsdWRlcyhcImZpcmViYXNlc3RvcmFnZS5nb29nbGVhcGlzLmNvbVwiKSAmJlxyXG4gICAgICAhaW1hZ2VVcmwuaW5jbHVkZXMoXCJhbHQ9bWVkaWFcIilcclxuICAgICkge1xyXG4gICAgICBpbWFnZVVybCA9IGltYWdlVXJsICsgKGltYWdlVXJsLmluY2x1ZGVzKFwiP1wiKSA/IFwiJlwiIDogXCI/XCIpICsgXCJhbHQ9bWVkaWFcIjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYmFja2dyb3VuZFBvc2l0aW9uID0gXCJjZW50ZXIgY2VudGVyXCI7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WCAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHNlY2Npb24uZm9uZG9JbWFnZW5PZmZzZXRZICE9PSB1bmRlZmluZWRcclxuICAgICkge1xyXG4gICAgICBjb25zdCBvZmZzZXRYID0gc2VjY2lvbi5mb25kb0ltYWdlbk9mZnNldFggfHwgMDtcclxuICAgICAgY29uc3Qgb2Zmc2V0WSA9IHNlY2Npb24uZm9uZG9JbWFnZW5PZmZzZXRZIHx8IDA7XHJcblxyXG4gICAgICBjb25zdCBvZmZzZXRYUGVyY2VudCA9IG9mZnNldFggIT09IDAgPyBgY2FsYyg1MCUgLSAkey1vZmZzZXRYfXB4KWAgOiBcIjUwJVwiO1xyXG4gICAgICBjb25zdCBvZmZzZXRZUGVyY2VudCA9IG9mZnNldFkgIT09IDAgPyBgY2FsYyg1MCUgLSAkey1vZmZzZXRZfXB4KWAgOiBcIjUwJVwiO1xyXG5cclxuICAgICAgYmFja2dyb3VuZFBvc2l0aW9uID0gYCR7b2Zmc2V0WFBlcmNlbnR9ICR7b2Zmc2V0WVBlcmNlbnR9YDtcclxuICAgIH1cclxuXHJcbiAgICBlc3RpbG9zRm9uZG8gPSBgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcke2ltYWdlVXJsfScpOyBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyOyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAke2JhY2tncm91bmRQb3NpdGlvbn07IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7YDtcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgZm9uZG9WYWx1ZS5zdGFydHNXaXRoKFwiaHR0cFwiKSB8fFxyXG4gICAgZm9uZG9WYWx1ZS5zdGFydHNXaXRoKFwiZGF0YTpcIikgfHxcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImJsb2I6XCIpXHJcbiAgKSB7XHJcbiAgICBsZXQgaW1hZ2VVcmwgPSBmb25kb1ZhbHVlLnJlcGxhY2UoXCJ1cmwoXCIsIFwiXCIpLnJlcGxhY2UoXCIpXCIsIFwiXCIpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgaW1hZ2VVcmwuaW5jbHVkZXMoXCJmaXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb21cIikgJiZcclxuICAgICAgIWltYWdlVXJsLmluY2x1ZGVzKFwiYWx0PW1lZGlhXCIpXHJcbiAgICApIHtcclxuICAgICAgaW1hZ2VVcmwgPSBpbWFnZVVybCArIChpbWFnZVVybC5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiKSArIFwiYWx0PW1lZGlhXCI7XHJcbiAgICB9XHJcblxyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgnJHtpbWFnZVVybH0nKTsgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjsgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjsgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtgO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlc3RpbG9zRm9uZG8gPSBgYmFja2dyb3VuZDogJHtmb25kb1ZhbHVlfTtgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVzdGlsb3NGb25kby5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKS50cmltKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFySFRNTERlc2RlU2VjY2lvbmVzKFxyXG4gIHNlY2Npb25lczogYW55W10sXHJcbiAgb2JqZXRvczogYW55W10sXHJcbiAgcnN2cD86IE1vZGFsQ29uZmlnLFxyXG4gIG9wY2lvbmVzPzogR2VuZXJhckhUTUxPcGNpb25lcyxcclxuICBvcHRzPzogeyBzbHVnPzogc3RyaW5nIH1cclxuKTogc3RyaW5nIHtcclxuICBjb25zdCBzbHVnID0gb3BjaW9uZXM/LnNsdWcgPz8gXCJcIjtcclxuICBjb25zdCBzbHVnUHVibGljYSA9IG9wdHM/LnNsdWcgPz8gXCJcIjtcclxuXHJcbiAgY29uc3QgZnVlbnRlc1VzYWRhcyA9IFtcclxuICAgIC4uLm5ldyBTZXQoXHJcbiAgICAgIG9iamV0b3NcclxuICAgICAgICAuZmlsdGVyKChvKSA9PiAoby50aXBvID09PSBcInRleHRvXCIgfHwgby50aXBvID09PSBcImNvdW50ZG93blwiKSAmJiBvLmZvbnRGYW1pbHkpXHJcbiAgICAgICAgLm1hcCgobykgPT4gby5mb250RmFtaWx5KVxyXG4gICAgKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnb29nbGVGb250c0xpbmsgPSBidWlsZEdvb2dsZUZvbnRzTGluayhmdWVudGVzVXNhZGFzKTtcclxuXHJcbiAgY29uc3QgaGF5UlNWUEVuQ2FudmFzID0gb2JqZXRvcz8uc29tZSgobykgPT4gby50aXBvID09PSBcInJzdnAtYm90b25cIik7XHJcbiAgY29uc3QgYm90b25SU1ZQID0gXCJcIjsgLy8gKHNpIHF1ZXLDqXMgYWdyZWdhciB1biBib3TDs24gZmlqbyBmdWVyYSBkZWwgY2FudmFzLCBoYWNlbG8gYWPDoSlcclxuICBjb25zdCBtb2RhbFJTVlAgPSBoYXlSU1ZQRW5DYW52YXMgJiYgcnN2cD8uZW5hYmxlZCA/IGdlbmVyYXJNb2RhbFJTVlBIVE1MKHJzdnApIDogXCJcIjtcbiAgY29uc3QgbW9kYWxHYWxlcmlhID0gaGF5R2FsZXJpYUNvbkltYWdlbmVzKG9iamV0b3MpID8gZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwoKSA6IFwiXCI7XG5cclxuICBmdW5jdGlvbiBoYXlDb3VudGRvd24ob2JqczogYW55W10pIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9ianMpICYmIG9ianMuc29tZSgobykgPT4gbz8udGlwbyA9PT0gXCJjb3VudGRvd25cIik7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzY3JpcHRDb3VudGRvd24gPSBoYXlDb3VudGRvd24ob2JqZXRvcylcclxuICAgID8gYFxyXG48c2NyaXB0PlxyXG4oZnVuY3Rpb24oKXtcclxuICBmdW5jdGlvbiBwYWQobil7IG49TWF0aC5mbG9vcihNYXRoLmFicyhuKSk7IHJldHVybiBuPDEwID8gXCIwXCIrbiA6IFwiXCIrbjsgfVxyXG4gIGZ1bmN0aW9uIGRpZmZQYXJ0cyh0YXJnZXQpe1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCBtcyA9IE1hdGgubWF4KDAsIHRhcmdldC5nZXRUaW1lKCkgLSBub3cpO1xyXG4gICAgY29uc3QgZCA9IE1hdGguZmxvb3IobXMgLyA4NjQwMDAwMCk7IG1zIC09IGQqODY0MDAwMDA7XHJcbiAgICBjb25zdCBoID0gTWF0aC5mbG9vcihtcyAvIDM2MDAwMDApOyAgbXMgLT0gaCozNjAwMDAwO1xyXG4gICAgY29uc3QgbSA9IE1hdGguZmxvb3IobXMgLyA2MDAwMCk7ICAgIG1zIC09IG0qNjAwMDA7XHJcbiAgICBjb25zdCBzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApO1xyXG4gICAgcmV0dXJuIHsgZCwgaCwgbSwgcyB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiB0aWNrT25lKHJvb3Qpe1xyXG4gICAgY29uc3QgaXNvID0gcm9vdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKTtcclxuICAgIGlmKCFpc28pIHJldHVybjtcclxuICAgIGNvbnN0IHQgPSBuZXcgRGF0ZShpc28pO1xyXG4gICAgaWYoaXNOYU4odC5nZXRUaW1lKCkpKSByZXR1cm47XHJcbiAgICBjb25zdCBwID0gZGlmZlBhcnRzKHQpO1xyXG4gICAgY29uc3QgdmFscyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbChcIi5jZC12YWxcIik7XHJcbiAgICBpZih2YWxzICYmIHZhbHMubGVuZ3RoID49IDQpe1xyXG4gICAgICB2YWxzWzBdLnRleHRDb250ZW50ID0gU3RyaW5nKHAuZCkucGFkU3RhcnQoMixcIjBcIik7XHJcbiAgICAgIHZhbHNbMV0udGV4dENvbnRlbnQgPSBwYWQocC5oKTtcclxuICAgICAgdmFsc1syXS50ZXh0Q29udGVudCA9IHBhZChwLm0pO1xyXG4gICAgICB2YWxzWzNdLnRleHRDb250ZW50ID0gcGFkKHAucyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJvb3QoKXtcclxuICAgIGNvbnN0IHJvb3RzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtY291bnRkb3duXVwiKSk7XHJcbiAgICBpZighcm9vdHMubGVuZ3RoKSByZXR1cm47XHJcbiAgICByb290cy5mb3JFYWNoKHRpY2tPbmUpO1xyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4gcm9vdHMuZm9yRWFjaCh0aWNrT25lKSwgMTAwMCk7XHJcbiAgfVxyXG4gIGlmKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiKXtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBib290KCk7XHJcbiAgfVxyXG59KSgpO1xyXG48L3NjcmlwdD5cclxuYC50cmltKClcclxuICAgIDogXCJcIjtcclxuXHJcbiAgY29uc3Qgc2VjY2lvbmVzT3JkZW5hZGFzID0gWy4uLihzZWNjaW9uZXMgfHwgW10pXS5zb3J0KFxyXG4gICAgKGEsIGIpID0+IChOdW1iZXIoYT8ub3JkZW4pIHx8IDApIC0gKE51bWJlcihiPy5vcmRlbikgfHwgMClcclxuICApO1xyXG5cclxuXHJcbiAgY29uc3QgaHRtbFNlY2Npb25lcyA9IHNlY2Npb25lc09yZGVuYWRhc1xyXG4gICAgLm1hcCgoc2VjY2lvbikgPT4ge1xyXG4gICAgICBjb25zdCBtb2RvID0gU3RyaW5nKHNlY2Npb24/LmFsdG9Nb2RvIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBjb25zdCBoYmFzZSA9IE51bWJlci5pc0Zpbml0ZShzZWNjaW9uPy5hbHR1cmEpID8gTnVtYmVyKHNlY2Npb24uYWx0dXJhKSA6IDYwMDtcclxuXHJcbiAgICAgIGNvbnN0IG9ianNEZVNlY2Npb24gPSBvYmpldG9zLmZpbHRlcigobykgPT4gby5zZWNjaW9uSWQgPT09IHNlY2Npb24uaWQpO1xyXG5cclxuICAgICAgY29uc3Qgb2Jqc0JsZWVkID0gb2Jqc0RlU2VjY2lvbi5maWx0ZXIoXHJcbiAgICAgICAgKG8pID0+IFN0cmluZyhvPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiZnVsbGJsZWVkXCJcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgb2Jqc0NvbnRlbmlkbyA9IG9ianNEZVNlY2Npb24uZmlsdGVyKFxyXG4gICAgICAgIChvKSA9PiBTdHJpbmcobz8uYW5jbGFqZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpICE9PSBcImZ1bGxibGVlZFwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBmb25kb1N0eWxlID0gYnVpbGRGb25kb1N0eWxlKHNlY2Npb24pO1xyXG5cclxuICAgICAgY29uc3QgaHRtbEJsZWVkID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0JsZWVkLCBzZWNjaW9uZXNPcmRlbmFkYXMpO1xyXG4gICAgICBjb25zdCBodG1sQ29udGVuaWRvID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0NvbnRlbmlkbywgc2VjY2lvbmVzT3JkZW5hZGFzKTtcclxuXHJcblxyXG4gICAgICByZXR1cm4gYFxyXG48c2VjdGlvbiBjbGFzcz1cInNlY1wiIGRhdGEtbW9kbz1cIiR7ZXNjYXBlQXR0cihtb2RvKX1cIiBzdHlsZT1cIi0taGJhc2U6JHtoYmFzZX1cIj5cclxuICA8ZGl2IGNsYXNzPVwic2VjLXpvb21cIj5cclxuICAgIDxkaXYgY2xhc3M9XCJzZWMtYmdcIiBzdHlsZT1cIiR7Zm9uZG9TdHlsZX1cIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJzZWMtYmxlZWRcIj4ke2h0bWxCbGVlZH08L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJzZWMtY29udGVudFwiPiR7aHRtbENvbnRlbmlkb308L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5gLnRyaW0oKTtcclxuICAgIH0pXHJcbiAgICAuam9pbihcIlxcblwiKTtcclxuXHJcbiAgY29uc3Qgc2NyaXB0TW9iaWxlU21hcnQgPSBidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCh7XG4gICAgZW5hYmxlZDogRU5BQkxFX01PQklMRV9TTUFSVF9MQVlPVVQsXG4gICAgbWluR2FwUHg6IDEsXG4gICAgcGFkZGluZ1RvcFB4OiAwLFxuICAgIHBhZGRpbmdCb3R0b21QeDogMixcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogdHJ1ZSxcbiAgICBtaW5QZXJDb2x1bW4yOiAxLFxuICAgIGZpdE1pblNjYWxlOiAwLjg4LFxuICAgIGZpdE1heFNjYWxlOiAxLjE2LFxuICAgIGZpdFRhcmdldFdpZHRoUmF0aW86IDAuOTQsXG4gICAgZml0TWluRmlsbFJhdGlvOiAwLjksXG4gIH0pO1xuXHJcbiAgcmV0dXJuIGBcclxuPCFET0NUWVBFIGh0bWw+XHJcbjxodG1sIGxhbmc9XCJlc1wiJHtzbHVnID8gYCBkYXRhLXNsdWc9XCIke2VzY2FwZUF0dHIoc2x1Zyl9XCJgIDogXCJcIn0+XHJcbjxoZWFkPlxyXG4gIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiIC8+XHJcbiAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIHZpZXdwb3J0LWZpdD1jb3ZlclwiIC8+XHJcbiAgPHRpdGxlPkludml0YWNpw7NuPC90aXRsZT5cclxuICAke2dvb2dsZUZvbnRzTGlua31cclxuICA8c3R5bGU+XHJcbiAgICAqIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyB9XHJcblxyXG4gICAgaHRtbCwgYm9keSB7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICBvdmVyZmxvdy14OiBoaWRkZW47XHJcbiAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBTT0xPIE1PQklMRTogZXZpdGEg4oCcYXV0by1yZXNpemUgLyBmb250IGJvb3N0aW5n4oCdIGRlbCB0ZXh0byAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgaHRtbHtcclxuICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XHJcbiAgICAgICAgdGV4dC1zaXplLWFkanVzdDogMTAwJTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICA6cm9vdHsgLS10ZXh0LXpvb206IDEuMjU7IH0gLyogcHJvYsOhIDEuMTDigJMxLjI1ICovXHJcbiAgICB9XHJcblxyXG4gICAgOnJvb3R7XHJcbiAgICAgIC0tc2FmZS10b3A6IGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtcmlnaHQ6IGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweCk7XHJcbiAgICAgIC0tc2FmZS1ib3R0b206IGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtbGVmdDogZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpO1xyXG4gICAgICAtLWJwLW1vYmlsZTogNzY3cHg7XHJcbiAgICAgIFxyXG5cclxuXHJcbiAgICAgIC8qIEdsb2JhbCBzY2FsZXMgKi9cclxuICAgICAgLS1jb250ZW50LXc6ICR7Q0FOVkFTX0JBU0UuQU5DSE99cHg7XHJcbiAgICAgIC0tc3g6IDE7ICAgLyogY29udGVudFcvODAwICovXHJcbiAgICAgIC0tYng6IDE7ICAgLyogdmlld3BvcnRXLzgwMCAqL1xyXG5cclxuICAgICAgLyogdmggbMOzZ2ljbyBwb3IgZGVmZWN0byAqL1xyXG4gICAgICAtLXZoLXNhZmU6IDEwMHZoO1xyXG4gICAgICAtLXZoLWxvZ2ljYWw6IHZhcigtLXZoLXNhZmUpO1xyXG5cclxuICAgICAgLyog4pyFIE9mZnNldCBTT0xPIHBhcmEgdGV4dG8gZW4gUGFudGFsbGE6IE9OIChkZXNrdG9wIGRlZmF1bHQpICovXHJcbiAgICAgIC0tcGFudGFsbGEteS1vZmZzZXQ6ICR7UEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWH1weDtcclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgTW9iaWxlOiBvZmZzZXQgZGlzdGludG8gU09MTyBwYXJhIHRleHRvIGVuIFBhbnRhbGxhOiBPTiAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgOnJvb3R7XHJcbiAgICAgICAgLS1wYW50YWxsYS15LW9mZnNldDogJHtQQU5UQUxMQV9ZX09GRlNFVF9NT0JJTEVfUFh9cHg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAuaW52eyB3aWR0aDogMTAwJTsgYmFja2dyb3VuZDogd2hpdGU7IH1cclxuXHJcbiAgICAuc2Vje1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHdpZHRoOiAxMDB2dztcclxuICAgICAgbGVmdDogNTAlO1xyXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XHJcbiAgICAgIG92ZXJmbG93OiB2aXNpYmxlOyAvKiBibGVlZCBwdWVkZSBzYWxpcnNlICovXHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFdyYXBwZXIgcXVlIGhhY2Ug4oCcem9vbeKAnSBjZW50cmFkbyAoZXZpdGEgY29ycmltaWVudG8gYSBsYSBkZXJlY2hhKSAqL1xyXG4gICAgLnNlYy16b29te1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBjZW50ZXI7XHJcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tem9vbSwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBQYW50YWxsYSBPTjogcmVjb3J0ZSBwYXJhIHF1ZSBlbCB6b29tIG5vIGRlc2JvcmRlICovXHJcbiAgICAuc2VjW2RhdGEtbW9kbz1cInBhbnRhbGxhXCJde1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICBoZWlnaHQ6IDEwMGR2aDtcclxuICAgICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgICAgcGFkZGluZy10b3A6IHZhcigtLXNhZmUtdG9wKTtcclxuICAgICAgcGFkZGluZy1ib3R0b206IHZhcigtLXNhZmUtYm90dG9tKTtcclxuXHJcbiAgICAgIC8qIGZhbGxiYWNrIENTUyAoSlMgbG8gcGlzYSBlbiBtb2JpbGUgY29uIHB4IHJlYWxlcykgKi9cclxuICAgICAgLS12aC1zYWZlOiBjYWxjKDEwMGR2aCAtIHZhcigtLXNhZmUtdG9wKSAtIHZhcigtLXNhZmUtYm90dG9tKSk7XHJcblxyXG4gICAgICAvKiBlbCB6b29tIGV4dHJhIHZhIHBvciAtLXpvb20gKE5PIHBvciBzZmluYWwpICovXHJcbiAgICAgIC0tem9vbTogMTtcclxuICAgICAgLS1iZ3pvb206IDE7XHJcblxyXG4gICAgICAvKiBmYWN0b3IgZmluYWwgcGFyYSBDT05URU5JRE8gKHNlIHNldGVhIHBvciBKUykgKi9cclxuICAgICAgLS1zZmluYWw6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJmaWpvXCJde1xyXG4gICAgICAvKiBhbHR1cmEgZmlqYSBlc2NhbGFkYSBwb3IgYW5jaG87IEpTIHNldGVhIC0tc2ZpbmFsID0gc3ggKi9cclxuICAgICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNmaW5hbCkgKiB2YXIoLS1oYmFzZSkgKiAxcHgpO1xyXG4gICAgICAtLXpvb206IDE7XHJcbiAgICAgIC0tYmd6b29tOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEZvbmRvICovXHJcbiAgICAuc2VjLWJne1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIGluc2V0OiAwO1xyXG4gICAgICB6LWluZGV4OiAwO1xyXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgRm9uZG8gYWdyYW5kYWJsZSBzb2xvIGVuIHBhbnRhbGxhIChhY29tcGHDsWEgZWwgem9vbSBoZXJvKSAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWJne1xyXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWJnem9vbSwgMSkpO1xyXG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLnNlYy1ibGVlZHtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICBpbnNldDogMDtcclxuICAgICAgei1pbmRleDogMjtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5zZWMtY29udGVudHtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICB6LWluZGV4OiAzO1xyXG4gICAgICB3aWR0aDogdmFyKC0tY29udGVudC13KTtcclxuICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiBlbCBhbmNobyBkZWwg4oCcY29udGVudOKAnSBwdWVkZSBjcmVjZXIgY29uIGxhIGVzY2FsYSB2ZXJ0aWNhbCAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWNvbnRlbnR7XHJcbiAgICAgIHdpZHRoOiB2YXIoLS1jb250ZW50LXctcGFudGFsbGEsIHZhcigtLWNvbnRlbnQtdykpO1xyXG4gICAgfVxyXG5cclxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCl7XHJcbiAgICAgIC5zZWMtY29udGVudHtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNhZmUtbGVmdCk7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2FmZS1yaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAub2JqZXRve1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0by5pcy1pbnRlcmFjdGl2ZXsgcG9pbnRlci1ldmVudHM6IGF1dG87IH1cclxuXHJcbiAgICAuY2QtY2hpcCB7IGJhY2tkcm9wLWZpbHRlcjogc2F0dXJhdGUoMS4xKTsgfVxyXG4gIDwvc3R5bGU+XHJcbjwvaGVhZD5cclxuXHJcbjxib2R5IGRhdGEtc2x1Zz1cIiR7ZXNjYXBlQXR0cihzbHVnUHVibGljYSl9XCI+XHJcbiAgPGRpdiBjbGFzcz1cImludlwiPlxyXG4gICAgJHtodG1sU2VjY2lvbmVzfVxyXG4gIDwvZGl2PlxyXG5cclxuICAke2JvdG9uUlNWUH1cbiAgJHttb2RhbFJTVlB9XG4gICR7bW9kYWxHYWxlcmlhfVxuXG4gICR7c2NyaXB0Q291bnRkb3dufVxuXHJcbiAgPHNjcmlwdD5cclxuICAgIChmdW5jdGlvbigpe1xyXG4gICAgICBmdW5jdGlvbiBjbGFtcChuLCBhLCBiKXsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIG4pKTsgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcHV0ZSgpe1xyXG4gICAgICAgIHZhciB2dyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgQkFTRV9XID0gODAwOyAvLyA9IENBTlZBU19CQVNFLkFOQ0hPXHJcblxyXG4gICAgICAgIC8vIGNvbnRlbnRXIChzaW4gdnctMzIpXHJcbiAgICAgICAgdmFyIGNvbnRlbnRXID0gTWF0aC5taW4oQkFTRV9XLCB2dyk7XHJcblxyXG4gICAgICAgIHZhciBzeCA9IGNvbnRlbnRXIC8gQkFTRV9XO1xyXG4gICAgICAgIHZhciBieCA9IHZ3IC8gQkFTRV9XO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWNvbnRlbnQtd1wiLCBjb250ZW50VyArIFwicHhcIik7XHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1zeFwiLCBTdHJpbmcoc3gpKTtcclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLWJ4XCIsIFN0cmluZyhieCkpO1xyXG5cclxuICAgICAgICB2YXIgc2VjcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zZWNcIikpO1xyXG4gICAgICAgIHZhciBpc01vYmlsZSA9IHZ3IDw9IDc2NztcclxuXHJcbiAgICAgICAgLy8gdmlld3BvcnQgcmVhbCAobcOhcyBlc3RhYmxlIGVuIG1vYmlsZSlcclxuICAgICAgICB2YXIgdnYgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0SCA9ICh2diAmJiB2di5oZWlnaHQpID8gdnYuaGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBzYWZlIGFyZWFzIChjc3MgZW52KVxyXG4gICAgICAgIHZhciBzYWZlVG9wID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tc2FmZS10b3BcIikpIHx8IDA7XHJcbiAgICAgICAgdmFyIHNhZmVCb3R0b20gPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zYWZlLWJvdHRvbVwiKSkgfHwgMDtcclxuXHJcbiAgICAgICAgLy8gZGlzZcOxbyBiYXNlIGRlbCBtb2RvIFwicGFudGFsbGFcIiAoODAwIHggNTAwKVxyXG4gICAgICAgIHZhciBERVNJR05fVyA9IEJBU0VfVztcclxuICAgICAgICB2YXIgREVTSUdOX0ggPSAke0FMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBfTsgLy8gPSBBTFRVUkFfUkVGRVJFTkNJQV9QQU5UQUxMQVxyXG4gICAgICAgIHZhciBkZXNpZ25BUiA9IERFU0lHTl9IIC8gREVTSUdOX1c7IC8vIDAuNjI1XHJcbiAgICAgICAgdmFyIGRldmljZUFSID0gdmlld3BvcnRIIC8gdnc7XHJcblxyXG4gICAgICAgIC8vIHpvb20gZXh0cmEgKHNvbG8gc2kgZWwgZGV2aWNlIGVzIG3DoXMgdmVydGljYWwgcXVlIGVsIGRpc2XDsW8pXHJcbiAgICAgICAgdmFyIHpvb21FeHRyYSA9IDE7XHJcbiAgICAgICAgaWYgKGlzTW9iaWxlICYmIGRldmljZUFSID4gZGVzaWduQVIpe1xyXG4gICAgICAgICAgdmFyIGsgPSBkZXZpY2VBUiAvIGRlc2lnbkFSO1xyXG4gICAgICAgICAgem9vbUV4dHJhID0gY2xhbXAoMSArIChrIC0gMSkgKiAwLjE4LCAxLCAxLjM1KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIPCflKcgQWp1c3RlIGZpbm86IGN1w6FudG8gYWNvbXBhw7FhIGVsIGZvbmRvIGFsIHpvb20gaGVybyAoMC4uMS4yKVxyXG4gICAgICAgIC8vIDAgICA9PiBlbCBmb25kbyBOTyBhZ3JlZ2Egem9vbSBleHRyYSBwcm9waW8gKHNvbG8gZWwgem9vbSBkZWwgd3JhcHBlcilcclxuICAgICAgICAvLyAxICAgPT4gY29tcG9ydGFtaWVudG8gYWN0dWFsIChmb25kbyBxdWVkYSB6b29tRXh0cmHCsilcclxuICAgICAgICAvLyAwLjMgPT4gcmVjb21lbmRhZG8gcGFyYSBlbXBlemFyIChzdXRpbClcclxuICAgICAgICB2YXIgQkdfWk9PTV9GQUNUT1IgPSAwO1xyXG5cclxuICAgICAgICAvLyDwn5SnIEFqdXN0ZSBmaW5vOiBjdcOhbnRvIGFjb21wYcOxYSBlbCBDT05URU5JRE8gKHRleHRvL29iamV0b3MpIGFsIHpvb20gaGVyb1xyXG4gICAgICAgIC8vIDAgICA9PiBjb21wb3J0YW1pZW50byBhY3R1YWxcclxuICAgICAgICAvLyAwLjMgPT4gcmVjb21lbmRhZG9cclxuICAgICAgICAvLyAxICAgPT4gdGV4dG8gZXNjYWxhIGlndWFsIHF1ZSBlbCBoZXJvIChubyBhY29uc2VqYWRvKVxyXG4gICAgICAgIHZhciBURVhUX1pPT01fRkFDVE9SID0gMDtcclxuXHJcblxyXG4gICAgICAgIHNlY3MuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xyXG4gICAgICAgICAgdmFyIG1vZG8gPSAoc2VjLmdldEF0dHJpYnV0ZShcImRhdGEtbW9kb1wiKSB8fCBcImZpam9cIikudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAvLyBkZWZhdWx0c1xyXG4gICAgICAgICAgdmFyIHpvb20gPSAxO1xyXG4gICAgICAgICAgdmFyIGJnem9vbSA9IDE7XHJcblxyXG4gICAgICAgICAgLy8g4pyFIFBvciBkZWZlY3RvLCB0YW1hw7FvcyBlc2NhbGFuIHBvciBhbmNobyAoY29tcG9ydGFtaWVudG8gYWN0dWFsKVxyXG4gICAgICAgICAgdmFyIHNmaW5hbCA9IHN4O1xyXG5cclxuICAgICAgICAgIC8vIGxpbXBpYXIgY3VzdG9tIHdpZHRoIHNpIG5vIGFwbGljYVxyXG4gICAgICAgICAgc2VjLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS1jb250ZW50LXctcGFudGFsbGFcIik7XHJcblxyXG4gICAgICAgICAgaWYgKG1vZG8gPT09IFwicGFudGFsbGFcIil7XHJcbiAgICAgICAgICAgIC8vIHZoLXNhZmUgcmVhbCBlbiBweFxyXG4gICAgICAgICAgICB2YXIgdmhTYWZlUHggPSBNYXRoLm1heCgwLCB2aWV3cG9ydEggLSBzYWZlVG9wIC0gc2FmZUJvdHRvbSk7XHJcbiAgICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdmgtc2FmZVwiLCB2aFNhZmVQeCArIFwicHhcIik7XHJcblxyXG4gICAgICAgICAgICAvLyDwn5SlIERlc2t0b3A6IGVzY2FsYXIgZWwgY29udGVuaWRvIHBvciBBTFRVUkEgKHZoU2FmZS81MDApXHJcbiAgICAgICAgICAgIC8vIEVzdG8gYWxpbmVhIGVsIEhUTUwgcHVibGljYWRvIGNvbiBsbyBxdWUgdmVzIGVuIHByZXZpZXdcclxuICAgICAgICAgICAgaWYgKCFpc01vYmlsZSl7XHJcbiAgICAgICAgICAgICAgdmFyIHNoID0gdmhTYWZlUHggLyBERVNJR05fSDtcclxuICAgICAgICAgICAgICBzZmluYWwgPSBzaDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gcGFyYSBxdWUgZWwgXCJjb250ZW50XCIgcXVlZGUgY2VudHJhZG8geSBjb2hlcmVudGUgY29uIGxhIG51ZXZhIGVzY2FsYSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tY29udGVudC13LXBhbnRhbGxhXCIsIChERVNJR05fVyAqIHNoKSArIFwicHhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBNb2JpbGU6IG1hbnRlbmVtb3MgdHUgY29tcG9ydGFtaWVudG8gYWN0dWFsICh6b29tIGhlcm8gc3VhdmUpXHJcbiAgICAgICAgICAgIGlmIChpc01vYmlsZSl7XHJcbiAgICAgICAgICAgICAgem9vbSA9IHpvb21FeHRyYTtcclxuICAgICAgICAgICAgICBiZ3pvb20gPSAxICsgKHpvb21FeHRyYSAtIDEpICogQkdfWk9PTV9GQUNUT1I7XHJcblxyXG4gICAgICAgICAgICAgIC8vIPCflKUgTlVFVk86IGVsIGNvbnRlbmlkbyBhY29tcGHDsWEgcGFyY2lhbG1lbnRlIGVsIHpvb21cclxuICAgICAgICAgICAgICBzZmluYWwgPSBzeCAqICgxICsgKHpvb21FeHRyYSAtIDEpICogVEVYVF9aT09NX0ZBQ1RPUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXNmaW5hbFwiLCBTdHJpbmcoc2ZpbmFsKSk7XHJcbiAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXpvb21cIiwgU3RyaW5nKHpvb20pKTtcclxuICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYmd6b29tXCIsIFN0cmluZyhiZ3pvb20pKTtcclxuXHJcbiAgICAgICAgICAvLyDinIUgU29sbyBlbiBtb2JpbGUgKyBwYW50YWxsYTogY29ycmVnaXIgZWwgXCJ2aFwiIHF1ZSBkZXNwdcOpcyBzZSBlc2NhbGEgY29uIHpvb21cclxuICAgICAgICAgIGlmIChpc01vYmlsZSAmJiBtb2RvID09PSBcInBhbnRhbGxhXCIpIHtcclxuICAgICAgICAgICAgLy8gLS12aC1sb2dpY2FsID0gLS12aC1zYWZlIC8gLS16b29tXHJcbiAgICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdmgtbG9naWNhbFwiLCBcImNhbGModmFyKC0tdmgtc2FmZSkgLyB2YXIoLS16b29tKSlcIik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZXN0bzogc2UgY29tcG9ydGEgY29tbyBzaWVtcHJlXHJcbiAgICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdmgtbG9naWNhbFwiLCBcInZhcigtLXZoLXNhZmUpXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wdXRlKTtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY29tcHV0ZSk7XHJcblxyXG4gICAgICBpZiAod2luZG93LnZpc3VhbFZpZXdwb3J0KXtcclxuICAgICAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjb21wdXRlKTtcclxuICAgICAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBjb21wdXRlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBmdW5jdGlvbigpe1xyXG4gICAgICAgIHNldFRpbWVvdXQoY29tcHV0ZSwgNTApO1xyXG4gICAgICAgIHNldFRpbWVvdXQoY29tcHV0ZSwgMjUwKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb21wdXRlKCk7XHJcbiAgICB9KSgpO1xyXG4gIDwvc2NyaXB0PlxyXG5cclxuICAgIFxyXG5cclxuXHJcbiAgICR7c2NyaXB0TW9iaWxlU21hcnR9XHJcbiBcclxuPC9ib2R5PlxyXG48L2h0bWw+XHJcbmA7XHJcbn1cclxuIl0sIm5hbWVzIjpbImdlbmVyYXJIVE1MRGVzZGVPYmpldG9zIiwiQ0FOVkFTX0JBU0UiLCJnZW5lcmFyTW9kYWxSU1ZQSFRNTCIsImdlbmVyYXJNb2RhbEdhbGVyaWFIVE1MIiwiaGF5R2FsZXJpYUNvbkltYWdlbmVzIiwiYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQiLCJFTkFCTEVfTU9CSUxFX1NNQVJUX0xBWU9VVCIsIkVYQ0xVREVfRk9OVFMiLCJTZXQiLCJBTFRVUkFfUkVGRVJFTkNJQV9QQU5UQUxMQSIsIlBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFgiLCJQQU5UQUxMQV9ZX09GRlNFVF9NT0JJTEVfUFgiLCJidWlsZEdvb2dsZUZvbnRzTGluayIsImZvbnRzIiwiZmFtaWxpYXMiLCJtYXAiLCJmIiwicmVwbGFjZSIsInNwbGl0IiwidHJpbSIsImZpbHRlciIsIm4iLCJoYXMiLCJqb2luIiwiZXNjYXBlQXR0ciIsInN0ciIsIlN0cmluZyIsImJ1aWxkRm9uZG9TdHlsZSIsInNlY2Npb24iLCJmb25kb1ZhbHVlIiwiZm9uZG8iLCJlc0ltYWdlbkZvbmRvIiwiZm9uZG9UaXBvIiwiZm9uZG9JbWFnZW4iLCJlc3RpbG9zRm9uZG8iLCJpbWFnZVVybCIsImluY2x1ZGVzIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiZm9uZG9JbWFnZW5PZmZzZXRYIiwidW5kZWZpbmVkIiwiZm9uZG9JbWFnZW5PZmZzZXRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJvZmZzZXRYUGVyY2VudCIsIm9mZnNldFlQZXJjZW50Iiwic3RhcnRzV2l0aCIsImdlbmVyYXJIVE1MRGVzZGVTZWNjaW9uZXMiLCJzZWNjaW9uZXMiLCJvYmpldG9zIiwicnN2cCIsIm9wY2lvbmVzIiwib3B0cyIsInNsdWciLCJzbHVnUHVibGljYSIsImZ1ZW50ZXNVc2FkYXMiLCJvIiwidGlwbyIsImZvbnRGYW1pbHkiLCJnb29nbGVGb250c0xpbmsiLCJoYXlSU1ZQRW5DYW52YXMiLCJzb21lIiwiYm90b25SU1ZQIiwibW9kYWxSU1ZQIiwiZW5hYmxlZCIsIm1vZGFsR2FsZXJpYSIsImhheUNvdW50ZG93biIsIm9ianMiLCJBcnJheSIsImlzQXJyYXkiLCJzY3JpcHRDb3VudGRvd24iLCJzZWNjaW9uZXNPcmRlbmFkYXMiLCJzb3J0IiwiYSIsImIiLCJOdW1iZXIiLCJvcmRlbiIsImh0bWxTZWNjaW9uZXMiLCJtb2RvIiwiYWx0b01vZG8iLCJ0b0xvd2VyQ2FzZSIsImhiYXNlIiwiaXNGaW5pdGUiLCJhbHR1cmEiLCJvYmpzRGVTZWNjaW9uIiwic2VjY2lvbklkIiwiaWQiLCJvYmpzQmxlZWQiLCJhbmNsYWplIiwib2Jqc0NvbnRlbmlkbyIsImZvbmRvU3R5bGUiLCJodG1sQmxlZWQiLCJodG1sQ29udGVuaWRvIiwic2NyaXB0TW9iaWxlU21hcnQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm9ubHlGaXhlZFNlY3Rpb25zIiwibWluUGVyQ29sdW1uMiIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGUiLCJmaXRUYXJnZXRXaWR0aFJhdGlvIiwiZml0TWluRmlsbFJhdGlvIiwiQU5DSE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeSecciones.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarModalGaleria.ts":
/*!****************************************************!*\
  !*** ./functions/src/utils/generarModalGaleria.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalGaleriaHTML: () => (/* binding */ generarModalGaleriaHTML),\n/* harmony export */   hayGaleriaConImagenes: () => (/* binding */ hayGaleriaConImagenes)\n/* harmony export */ });\nfunction hayGaleriaConImagenes() {\n    let objetos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return objetos.some((obj)=>{\n        if ((obj === null || obj === void 0 ? void 0 : obj.tipo) !== \"galeria\" || !Array.isArray(obj === null || obj === void 0 ? void 0 : obj.cells)) return false;\n        return obj.cells.some((cell)=>typeof (cell === null || cell === void 0 ? void 0 : cell.mediaUrl) === \"string\" && cell.mediaUrl.trim().length > 0);\n    });\n}\nfunction generarModalGaleriaHTML() {\n    return '\\n<style>\\n  .objeto.galeria .galeria-celda--clickable {\\n    cursor: zoom-in;\\n  }\\n\\n  .objeto.galeria .galeria-celda--clickable:focus-visible {\\n    outline: 2px solid rgba(255, 255, 255, 0.95);\\n    outline-offset: -2px;\\n  }\\n\\n  .gallery-lightbox {\\n    position: fixed;\\n    inset: 0;\\n    z-index: 11000;\\n    opacity: 0;\\n    visibility: hidden;\\n    pointer-events: none;\\n    transition: opacity 0.32s ease, visibility 0.32s ease;\\n  }\\n\\n  .gallery-lightbox.is-open {\\n    opacity: 1;\\n    visibility: visible;\\n    pointer-events: auto;\\n  }\\n\\n  .gallery-lightbox__backdrop {\\n    position: absolute;\\n    inset: 0;\\n    background:\\n      radial-gradient(circle at 50% 10%, rgba(66, 66, 75, 0.35), transparent 48%),\\n      rgba(7, 8, 11, 0.96);\\n    backdrop-filter: blur(8px);\\n  }\\n\\n  .gallery-lightbox__stage {\\n    position: relative;\\n    z-index: 1;\\n    width: min(1320px, 100vw);\\n    height: min(94vh, 920px);\\n    margin: 0 auto;\\n    padding: clamp(24px, 4vw, 44px) clamp(56px, 8vw, 120px);\\n    display: grid;\\n    grid-template-columns: minmax(0, 1fr) minmax(0, 1.65fr) minmax(0, 1fr);\\n    align-items: center;\\n    gap: clamp(10px, 2.2vw, 28px);\\n  }\\n\\n  .gallery-lightbox__slot {\\n    width: 100%;\\n    height: min(84vh, 780px);\\n    background: rgba(255, 255, 255, 0.05);\\n    border: 1px solid rgba(255, 255, 255, 0.16);\\n    border-radius: 20px;\\n    overflow: hidden;\\n    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.36);\\n    transition: opacity 0.26s ease, transform 0.26s ease, filter 0.26s ease;\\n  }\\n\\n  .gallery-lightbox__slot img {\\n    width: 100%;\\n    height: 100%;\\n    display: block;\\n    object-fit: contain;\\n  }\\n\\n  .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\\n    opacity: 0.52;\\n    transform: translateX(10%) scale(0.9);\\n    filter: saturate(0.72);\\n  }\\n\\n  .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\\n    opacity: 1;\\n    transform: scale(1);\\n    filter: none;\\n  }\\n\\n  .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\\n    opacity: 0.52;\\n    transform: translateX(-10%) scale(0.9);\\n    filter: saturate(0.72);\\n  }\\n\\n  .gallery-lightbox__slot.is-empty {\\n    opacity: 0;\\n    transform: scale(0.85);\\n    pointer-events: none;\\n  }\\n\\n  .gallery-lightbox__nav,\\n  .gallery-lightbox__close {\\n    position: absolute;\\n    z-index: 2;\\n    border: 1px solid rgba(255, 255, 255, 0.2);\\n    border-radius: 9999px;\\n    background: rgba(15, 16, 22, 0.62);\\n    color: #fff;\\n    cursor: pointer;\\n    transition: background 0.2s ease, transform 0.2s ease;\\n    backdrop-filter: blur(4px);\\n  }\\n\\n  .gallery-lightbox__nav:hover,\\n  .gallery-lightbox__close:hover {\\n    background: rgba(22, 25, 34, 0.9);\\n    transform: translateY(-1px);\\n  }\\n\\n  .gallery-lightbox__nav {\\n    top: 50%;\\n    transform: translateY(-50%);\\n    width: 52px;\\n    height: 52px;\\n    font-size: 28px;\\n    line-height: 1;\\n  }\\n\\n  .gallery-lightbox__nav--prev {\\n    left: clamp(10px, 2vw, 32px);\\n  }\\n\\n  .gallery-lightbox__nav--next {\\n    right: clamp(10px, 2vw, 32px);\\n  }\\n\\n  .gallery-lightbox__nav:disabled {\\n    opacity: 0.35;\\n    cursor: default;\\n  }\\n\\n  .gallery-lightbox__close {\\n    top: clamp(14px, 2.5vh, 26px);\\n    right: clamp(14px, 2vw, 28px);\\n    width: 44px;\\n    height: 44px;\\n    font-size: 24px;\\n    line-height: 1;\\n  }\\n\\n  .gallery-lightbox__counter {\\n    position: absolute;\\n    z-index: 2;\\n    bottom: clamp(12px, 2vh, 24px);\\n    left: 50%;\\n    transform: translateX(-50%);\\n    color: rgba(255, 255, 255, 0.9);\\n    background: rgba(14, 16, 24, 0.55);\\n    border: 1px solid rgba(255, 255, 255, 0.18);\\n    padding: 8px 14px;\\n    border-radius: 9999px;\\n    font-size: 14px;\\n    font-weight: 600;\\n    letter-spacing: 0.03em;\\n  }\\n\\n  @media (max-width: 900px) {\\n    .gallery-lightbox__stage {\\n      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.8fr) minmax(0, 0.9fr);\\n      padding: 64px 12px 66px;\\n      height: 100dvh;\\n      height: 100vh;\\n      gap: 12px;\\n    }\\n\\n    .gallery-lightbox__slot {\\n      height: min(76vh, 700px);\\n      border-radius: 16px;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\\n      opacity: 0.34;\\n      transform: translateX(22%) scale(0.84);\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\\n      opacity: 0.34;\\n      transform: translateX(-22%) scale(0.84);\\n    }\\n  }\\n\\n  @media (max-width: 640px) {\\n    .gallery-lightbox__stage {\\n      width: 100vw;\\n      max-width: 100vw;\\n      height: 100dvh;\\n      height: 100vh;\\n      grid-template-columns: minmax(0, 1fr);\\n      padding:\\n        calc(env(safe-area-inset-top, 0px) + 8px)\\n        calc(env(safe-area-inset-right, 0px) + 4px)\\n        calc(env(safe-area-inset-bottom, 0px) + 50px)\\n        calc(env(safe-area-inset-left, 0px) + 4px);\\n      gap: 0;\\n      align-items: stretch;\\n    }\\n\\n    .gallery-lightbox__slot {\\n      height: 100%;\\n      border-radius: 12px;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"],\\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\\n      display: none;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\\n      background: transparent;\\n      border: none;\\n      border-radius: 0;\\n      box-shadow: none;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] img {\\n      width: 100%;\\n      height: 100%;\\n      object-fit: contain;\\n    }\\n\\n    .gallery-lightbox__nav {\\n      width: 42px;\\n      height: 42px;\\n      font-size: 24px;\\n    }\\n\\n    .gallery-lightbox__nav--prev {\\n      left: calc(env(safe-area-inset-left, 0px) + 6px);\\n    }\\n\\n    .gallery-lightbox__nav--next {\\n      right: calc(env(safe-area-inset-right, 0px) + 6px);\\n    }\\n\\n    .gallery-lightbox__close {\\n      top: calc(env(safe-area-inset-top, 0px) + 10px);\\n      right: calc(env(safe-area-inset-right, 0px) + 10px);\\n    }\\n\\n    .gallery-lightbox__counter {\\n      bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);\\n    }\\n  }\\n</style>\\n\\n<div id=\"gallery-lightbox\" class=\"gallery-lightbox\" aria-hidden=\"true\" role=\"dialog\" aria-modal=\"true\">\\n  <div class=\"gallery-lightbox__backdrop\" data-gallery-close></div>\\n\\n  <button type=\"button\" class=\"gallery-lightbox__close\" data-gallery-close aria-label=\"Cerrar galeria\">\\n    &#10005;\\n  </button>\\n\\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--prev\" data-gallery-prev aria-label=\"Imagen anterior\">\\n    &#8249;\\n  </button>\\n\\n  <div class=\"gallery-lightbox__stage\">\\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"prev\">\\n      <img alt=\"\" />\\n    </figure>\\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"current\">\\n      <img alt=\"\" />\\n    </figure>\\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"next\">\\n      <img alt=\"\" />\\n    </figure>\\n  </div>\\n\\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--next\" data-gallery-next aria-label=\"Imagen siguiente\">\\n    &#8250;\\n  </button>\\n\\n  <div class=\"gallery-lightbox__counter\" data-gallery-counter>1 / 1</div>\\n</div>\\n\\n<script>\\n(function(){\\n  function clampIndex(index, total){\\n    if (!total) return 0;\\n    var normalized = index % total;\\n    return normalized < 0 ? normalized + total : normalized;\\n  }\\n\\n  function boot(){\\n    var modal = document.getElementById(\"gallery-lightbox\");\\n    if (!modal) return;\\n\\n    var closeEls = Array.from(modal.querySelectorAll(\"[data-gallery-close]\"));\\n    var prevBtn = modal.querySelector(\"[data-gallery-prev]\");\\n    var nextBtn = modal.querySelector(\"[data-gallery-next]\");\\n    var counter = modal.querySelector(\"[data-gallery-counter]\");\\n\\n    var prevSlot = modal.querySelector(\\'[data-gallery-slot=\"prev\"]\\');\\n    var currentSlot = modal.querySelector(\\'[data-gallery-slot=\"current\"]\\');\\n    var nextSlot = modal.querySelector(\\'[data-gallery-slot=\"next\"]\\');\\n\\n    var prevImg = prevSlot ? prevSlot.querySelector(\"img\") : null;\\n    var currentImg = currentSlot ? currentSlot.querySelector(\"img\") : null;\\n    var nextImg = nextSlot ? nextSlot.querySelector(\"img\") : null;\\n    var stage = modal.querySelector(\".gallery-lightbox__stage\");\\n\\n    var state = {\\n      images: [],\\n      index: 0,\\n      isOpen: false,\\n      originalOverflow: \"\"\\n    };\\n\\n    function setSlotImage(imgNode, src, altText){\\n      if (!imgNode) return;\\n      if (!src) {\\n        imgNode.removeAttribute(\"src\");\\n        imgNode.alt = \"\";\\n        return;\\n      }\\n      if (imgNode.getAttribute(\"src\") !== src) {\\n        imgNode.setAttribute(\"src\", src);\\n      }\\n      imgNode.alt = altText || \"\";\\n    }\\n\\n    function refresh(){\\n      var total = state.images.length;\\n      if (!total) return;\\n\\n      state.index = clampIndex(state.index, total);\\n      var currentIndex = state.index;\\n      var hasNeighbors = total > 1;\\n\\n      var prevIndex = clampIndex(currentIndex - 1, total);\\n      var nextIndex = clampIndex(currentIndex + 1, total);\\n\\n      setSlotImage(currentImg, state.images[currentIndex], \"Imagen \" + (currentIndex + 1));\\n      setSlotImage(\\n        prevImg,\\n        hasNeighbors ? state.images[prevIndex] : \"\",\\n        hasNeighbors ? \"Imagen anterior\" : \"\"\\n      );\\n      setSlotImage(\\n        nextImg,\\n        hasNeighbors ? state.images[nextIndex] : \"\",\\n        hasNeighbors ? \"Imagen siguiente\" : \"\"\\n      );\\n\\n      if (prevSlot) prevSlot.classList.toggle(\"is-empty\", !hasNeighbors);\\n      if (nextSlot) nextSlot.classList.toggle(\"is-empty\", !hasNeighbors);\\n\\n      if (counter) counter.textContent = (currentIndex + 1) + \" / \" + total;\\n      if (prevBtn) prevBtn.disabled = !hasNeighbors;\\n      if (nextBtn) nextBtn.disabled = !hasNeighbors;\\n    }\\n\\n    function open(images, startIndex){\\n      if (!Array.isArray(images) || !images.length) return;\\n      state.images = images.slice();\\n      state.index = clampIndex(Number(startIndex) || 0, state.images.length);\\n      state.isOpen = true;\\n\\n      state.originalOverflow = document.body.style.overflow || \"\";\\n      document.body.style.overflow = \"hidden\";\\n\\n      modal.setAttribute(\"aria-hidden\", \"false\");\\n      modal.classList.add(\"is-open\");\\n      refresh();\\n\\n      if (closeEls[0] && typeof closeEls[0].focus === \"function\") {\\n        closeEls[0].focus();\\n      }\\n    }\\n\\n    function close(){\\n      if (!state.isOpen) return;\\n      state.isOpen = false;\\n      modal.classList.remove(\"is-open\");\\n      modal.setAttribute(\"aria-hidden\", \"true\");\\n      document.body.style.overflow = state.originalOverflow;\\n    }\\n\\n    function navigate(step){\\n      if (!state.isOpen || state.images.length < 2) return;\\n      state.index = clampIndex(state.index + step, state.images.length);\\n      refresh();\\n    }\\n\\n    closeEls.forEach(function(el){\\n      el.addEventListener(\"click\", function(ev){\\n        ev.preventDefault();\\n        close();\\n      });\\n    });\\n\\n    if (prevBtn) {\\n      prevBtn.addEventListener(\"click\", function(ev){\\n        ev.preventDefault();\\n        navigate(-1);\\n      });\\n    }\\n\\n    if (nextBtn) {\\n      nextBtn.addEventListener(\"click\", function(ev){\\n        ev.preventDefault();\\n        navigate(1);\\n      });\\n    }\\n\\n    document.addEventListener(\"keydown\", function(ev){\\n      if (!state.isOpen) return;\\n      if (ev.key === \"Escape\") {\\n        ev.preventDefault();\\n        close();\\n        return;\\n      }\\n      if (ev.key === \"ArrowLeft\") {\\n        ev.preventDefault();\\n        navigate(-1);\\n        return;\\n      }\\n      if (ev.key === \"ArrowRight\") {\\n        ev.preventDefault();\\n        navigate(1);\\n      }\\n    });\\n\\n    if (stage) {\\n      var startX = 0;\\n      var startY = 0;\\n      var pointerDown = false;\\n\\n      stage.addEventListener(\"touchstart\", function(ev){\\n        if (!ev.touches || !ev.touches.length) return;\\n        pointerDown = true;\\n        startX = ev.touches[0].clientX;\\n        startY = ev.touches[0].clientY;\\n      }, { passive: true });\\n\\n      stage.addEventListener(\"touchend\", function(ev){\\n        if (!pointerDown || !ev.changedTouches || !ev.changedTouches.length) return;\\n        pointerDown = false;\\n        var endX = ev.changedTouches[0].clientX;\\n        var endY = ev.changedTouches[0].clientY;\\n        var dx = endX - startX;\\n        var dy = endY - startY;\\n\\n        if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {\\n          navigate(dx > 0 ? -1 : 1);\\n        }\\n      }, { passive: true });\\n    }\\n\\n    var galleries = Array.from(document.querySelectorAll(\".objeto.galeria\"));\\n    galleries.forEach(function(gallery){\\n      var cells = Array.from(\\n        gallery.querySelectorAll(\\'.galeria-celda[data-gallery-image=\"1\"]\\')\\n      );\\n      if (!cells.length) return;\\n\\n      var images = cells\\n        .map(function(cell){\\n          var img = cell.querySelector(\"img\");\\n          if (!img) return \"\";\\n          return (img.getAttribute(\"src\") || \"\").trim();\\n        })\\n        .filter(Boolean);\\n\\n      if (!images.length) return;\\n\\n      gallery.addEventListener(\"click\", function(ev){\\n        var target = ev.target;\\n        if (!(target instanceof Element)) return;\\n\\n        var cell = target.closest(\\'.galeria-celda[data-gallery-image=\"1\"]\\');\\n        if (!cell || !gallery.contains(cell)) return;\\n\\n        var index = cells.indexOf(cell);\\n        if (index < 0) return;\\n\\n        ev.preventDefault();\\n        ev.stopPropagation();\\n        open(images, index);\\n      });\\n\\n      gallery.addEventListener(\"keydown\", function(ev){\\n        if (ev.key !== \"Enter\" && ev.key !== \" \") return;\\n        var target = ev.target;\\n        if (!(target instanceof Element)) return;\\n\\n        var cell = target.closest(\\'.galeria-celda[data-gallery-image=\"1\"]\\');\\n        if (!cell || !gallery.contains(cell)) return;\\n\\n        var index = cells.indexOf(cell);\\n        if (index < 0) return;\\n\\n        ev.preventDefault();\\n        open(images, index);\\n      });\\n    });\\n  }\\n\\n  if (document.readyState === \"loading\") {\\n    document.addEventListener(\"DOMContentLoaded\", boot);\\n  } else {\\n    boot();\\n  }\\n})();\\n</script>\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsR2FsZXJpYS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQVNPLFNBQVNBO1FBQXNCQyxVQUFBQSxpRUFBaUIsRUFBRTtJQUN2RCxPQUFPQSxRQUFRQyxJQUFJLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJQUFLQyxJQUFJLE1BQUssYUFBYSxDQUFDQyxNQUFNQyxPQUFPLENBQUNILGdCQUFBQSwwQkFBQUEsSUFBS0ksS0FBSyxHQUFHLE9BQU87UUFDbEUsT0FBT0osSUFBSUksS0FBSyxDQUFDTCxJQUFJLENBQ25CLENBQUNNLE9BQVMsUUFBT0EsaUJBQUFBLDJCQUFBQSxLQUFNQyxRQUFRLE1BQUssWUFBWUQsS0FBS0MsUUFBUSxDQUFDQyxJQUFJLEdBQUdDLE1BQU0sR0FBRztJQUVsRjtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPLDJ5YkEwZlBGLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxnZW5lcmFyTW9kYWxHYWxlcmlhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgR2FsZXJpYUNlbGwgPSB7XG4gIG1lZGlhVXJsPzogc3RyaW5nIHwgbnVsbDtcbn07XG5cbnR5cGUgT2JqZXRvR2FsZXJpYSA9IHtcbiAgdGlwbz86IHN0cmluZztcbiAgY2VsbHM/OiBHYWxlcmlhQ2VsbFtdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhheUdhbGVyaWFDb25JbWFnZW5lcyhvYmpldG9zOiBhbnlbXSA9IFtdKTogYm9vbGVhbiB7XG4gIHJldHVybiBvYmpldG9zLnNvbWUoKG9iajogT2JqZXRvR2FsZXJpYSkgPT4ge1xuICAgIGlmIChvYmo/LnRpcG8gIT09IFwiZ2FsZXJpYVwiIHx8ICFBcnJheS5pc0FycmF5KG9iaj8uY2VsbHMpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG9iai5jZWxscy5zb21lKFxuICAgICAgKGNlbGwpID0+IHR5cGVvZiBjZWxsPy5tZWRpYVVybCA9PT0gXCJzdHJpbmdcIiAmJiBjZWxsLm1lZGlhVXJsLnRyaW0oKS5sZW5ndGggPiAwXG4gICAgKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxHYWxlcmlhSFRNTCgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuPHN0eWxlPlxuICAub2JqZXRvLmdhbGVyaWEgLmdhbGVyaWEtY2VsZGEtLWNsaWNrYWJsZSB7XG4gICAgY3Vyc29yOiB6b29tLWluO1xuICB9XG5cbiAgLm9iamV0by5nYWxlcmlhIC5nYWxlcmlhLWNlbGRhLS1jbGlja2FibGU6Zm9jdXMtdmlzaWJsZSB7XG4gICAgb3V0bGluZTogMnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSk7XG4gICAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGluc2V0OiAwO1xuICAgIHotaW5kZXg6IDExMDAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zMnMgZWFzZSwgdmlzaWJpbGl0eSAwLjMycyBlYXNlO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3guaXMtb3BlbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX2JhY2tkcm9wIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaW5zZXQ6IDA7XG4gICAgYmFja2dyb3VuZDpcbiAgICAgIHJhZGlhbC1ncmFkaWVudChjaXJjbGUgYXQgNTAlIDEwJSwgcmdiYSg2NiwgNjYsIDc1LCAwLjM1KSwgdHJhbnNwYXJlbnQgNDglKSxcbiAgICAgIHJnYmEoNywgOCwgMTEsIDAuOTYpO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3N0YWdlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgei1pbmRleDogMTtcbiAgICB3aWR0aDogbWluKDEzMjBweCwgMTAwdncpO1xuICAgIGhlaWdodDogbWluKDk0dmgsIDkyMHB4KTtcbiAgICBtYXJnaW46IDAgYXV0bztcbiAgICBwYWRkaW5nOiBjbGFtcCgyNHB4LCA0dncsIDQ0cHgpIGNsYW1wKDU2cHgsIDh2dywgMTIwcHgpO1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMCwgMWZyKSBtaW5tYXgoMCwgMS42NWZyKSBtaW5tYXgoMCwgMWZyKTtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogY2xhbXAoMTBweCwgMi4ydncsIDI4cHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3Qge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogbWluKDg0dmgsIDc4MHB4KTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDUpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNik7XG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGJveC1zaGFkb3c6IDAgMjRweCA2MHB4IHJnYmEoMCwgMCwgMCwgMC4zNik7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI2cyBlYXNlLCB0cmFuc2Zvcm0gMC4yNnMgZWFzZSwgZmlsdGVyIDAuMjZzIGVhc2U7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdCBpbWcge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBvYmplY3QtZml0OiBjb250YWluO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdIHtcbiAgICBvcGFjaXR5OiAwLjUyO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMCUpIHNjYWxlKDAuOSk7XG4gICAgZmlsdGVyOiBzYXR1cmF0ZSgwLjcyKTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXSB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICAgIGZpbHRlcjogbm9uZTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiXSB7XG4gICAgb3BhY2l0eTogMC41MjtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwJSkgc2NhbGUoMC45KTtcbiAgICBmaWx0ZXI6IHNhdHVyYXRlKDAuNzIpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3QuaXMtZW1wdHkge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjg1KTtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYsXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDI7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE1LCAxNiwgMjIsIDAuNjIpO1xuICAgIGNvbG9yOiAjZmZmO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMnMgZWFzZSwgdHJhbnNmb3JtIDAuMnMgZWFzZTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXY6aG92ZXIsXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyMiwgMjUsIDM0LCAwLjkpO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYge1xuICAgIHRvcDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgICB3aWR0aDogNTJweDtcbiAgICBoZWlnaHQ6IDUycHg7XG4gICAgZm9udC1zaXplOiAyOHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tcHJldiB7XG4gICAgbGVmdDogY2xhbXAoMTBweCwgMnZ3LCAzMnB4KTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLW5leHQge1xuICAgIHJpZ2h0OiBjbGFtcCgxMHB4LCAydncsIDMycHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdjpkaXNhYmxlZCB7XG4gICAgb3BhY2l0eTogMC4zNTtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fY2xvc2Uge1xuICAgIHRvcDogY2xhbXAoMTRweCwgMi41dmgsIDI2cHgpO1xuICAgIHJpZ2h0OiBjbGFtcCgxNHB4LCAydncsIDI4cHgpO1xuICAgIHdpZHRoOiA0NHB4O1xuICAgIGhlaWdodDogNDRweDtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fY291bnRlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDI7XG4gICAgYm90dG9tOiBjbGFtcCgxMnB4LCAydmgsIDI0cHgpO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE0LCAxNiwgMjQsIDAuNTUpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xOCk7XG4gICAgcGFkZGluZzogOHB4IDE0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGxldHRlci1zcGFjaW5nOiAwLjAzZW07XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogOTAwcHgpIHtcbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2Uge1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMCwgMC45ZnIpIG1pbm1heCgwLCAxLjhmcikgbWlubWF4KDAsIDAuOWZyKTtcbiAgICAgIHBhZGRpbmc6IDY0cHggMTJweCA2NnB4O1xuICAgICAgaGVpZ2h0OiAxMDBkdmg7XG4gICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgZ2FwOiAxMnB4O1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90IHtcbiAgICAgIGhlaWdodDogbWluKDc2dmgsIDcwMHB4KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDE2cHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdIHtcbiAgICAgIG9wYWNpdHk6IDAuMzQ7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjIlKSBzY2FsZSgwLjg0KTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIl0ge1xuICAgICAgb3BhY2l0eTogMC4zNDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjIlKSBzY2FsZSgwLjg0KTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNjQwcHgpIHtcbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2Uge1xuICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgbWF4LXdpZHRoOiAxMDB2dztcbiAgICAgIGhlaWdodDogMTAwZHZoO1xuICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogbWlubWF4KDAsIDFmcik7XG4gICAgICBwYWRkaW5nOlxuICAgICAgICBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpICsgOHB4KVxuICAgICAgICBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweCkgKyA0cHgpXG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20sIDBweCkgKyA1MHB4KVxuICAgICAgICBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCwgMHB4KSArIDRweCk7XG4gICAgICBnYXA6IDA7XG4gICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdCB7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwicHJldlwiXSxcbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIl0ge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIl0ge1xuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBib3JkZXItcmFkaXVzOiAwO1xuICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIl0gaW1nIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fbmF2IHtcbiAgICAgIHdpZHRoOiA0MnB4O1xuICAgICAgaGVpZ2h0OiA0MnB4O1xuICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLXByZXYge1xuICAgICAgbGVmdDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWxlZnQsIDBweCkgKyA2cHgpO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLW5leHQge1xuICAgICAgcmlnaHQ6IGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KSArIDZweCk7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX2Nsb3NlIHtcbiAgICAgIHRvcDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCwgMHB4KSArIDEwcHgpO1xuICAgICAgcmlnaHQ6IGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KSArIDEwcHgpO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19jb3VudGVyIHtcbiAgICAgIGJvdHRvbTogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSwgMHB4KSArIDhweCk7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2IGlkPVwiZ2FsbGVyeS1saWdodGJveFwiIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxuICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fYmFja2Ryb3BcIiBkYXRhLWdhbGxlcnktY2xvc2U+PC9kaXY+XG5cbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZVwiIGRhdGEtZ2FsbGVyeS1jbG9zZSBhcmlhLWxhYmVsPVwiQ2VycmFyIGdhbGVyaWFcIj5cbiAgICAmIzEwMDA1O1xuICA8L2J1dHRvbj5cblxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX25hdiBnYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLXByZXZcIiBkYXRhLWdhbGxlcnktcHJldiBhcmlhLWxhYmVsPVwiSW1hZ2VuIGFudGVyaW9yXCI+XG4gICAgJiM4MjQ5O1xuICA8L2J1dHRvbj5cblxuICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fc3RhZ2VcIj5cbiAgICA8ZmlndXJlIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fc2xvdFwiIGRhdGEtZ2FsbGVyeS1zbG90PVwicHJldlwiPlxuICAgICAgPGltZyBhbHQ9XCJcIiAvPlxuICAgIDwvZmlndXJlPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19zbG90XCIgZGF0YS1nYWxsZXJ5LXNsb3Q9XCJjdXJyZW50XCI+XG4gICAgICA8aW1nIGFsdD1cIlwiIC8+XG4gICAgPC9maWd1cmU+XG4gICAgPGZpZ3VyZSBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX3Nsb3RcIiBkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIj5cbiAgICAgIDxpbWcgYWx0PVwiXCIgLz5cbiAgICA8L2ZpZ3VyZT5cbiAgPC9kaXY+XG5cbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19uYXYgZ2FsbGVyeS1saWdodGJveF9fbmF2LS1uZXh0XCIgZGF0YS1nYWxsZXJ5LW5leHQgYXJpYS1sYWJlbD1cIkltYWdlbiBzaWd1aWVudGVcIj5cbiAgICAmIzgyNTA7XG4gIDwvYnV0dG9uPlxuXG4gIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19jb3VudGVyXCIgZGF0YS1nYWxsZXJ5LWNvdW50ZXI+MSAvIDE8L2Rpdj5cbjwvZGl2PlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgoaW5kZXgsIHRvdGFsKXtcbiAgICBpZiAoIXRvdGFsKSByZXR1cm4gMDtcbiAgICB2YXIgbm9ybWFsaXplZCA9IGluZGV4ICUgdG90YWw7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQgPCAwID8gbm9ybWFsaXplZCArIHRvdGFsIDogbm9ybWFsaXplZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJvb3QoKXtcbiAgICB2YXIgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbGxlcnktbGlnaHRib3hcIik7XG4gICAgaWYgKCFtb2RhbCkgcmV0dXJuO1xuXG4gICAgdmFyIGNsb3NlRWxzID0gQXJyYXkuZnJvbShtb2RhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZ2FsbGVyeS1jbG9zZV1cIikpO1xuICAgIHZhciBwcmV2QnRuID0gbW9kYWwucXVlcnlTZWxlY3RvcihcIltkYXRhLWdhbGxlcnktcHJldl1cIik7XG4gICAgdmFyIG5leHRCdG4gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZ2FsbGVyeS1uZXh0XVwiKTtcbiAgICB2YXIgY291bnRlciA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1nYWxsZXJ5LWNvdW50ZXJdXCIpO1xuXG4gICAgdmFyIHByZXZTbG90ID0gbW9kYWwucXVlcnlTZWxlY3RvcignW2RhdGEtZ2FsbGVyeS1zbG90PVwicHJldlwiXScpO1xuICAgIHZhciBjdXJyZW50U2xvdCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIl0nKTtcbiAgICB2YXIgbmV4dFNsb3QgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJuZXh0XCJdJyk7XG5cbiAgICB2YXIgcHJldkltZyA9IHByZXZTbG90ID8gcHJldlNsb3QucXVlcnlTZWxlY3RvcihcImltZ1wiKSA6IG51bGw7XG4gICAgdmFyIGN1cnJlbnRJbWcgPSBjdXJyZW50U2xvdCA/IGN1cnJlbnRTbG90LnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIikgOiBudWxsO1xuICAgIHZhciBuZXh0SW1nID0gbmV4dFNsb3QgPyBuZXh0U2xvdC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpIDogbnVsbDtcbiAgICB2YXIgc3RhZ2UgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKFwiLmdhbGxlcnktbGlnaHRib3hfX3N0YWdlXCIpO1xuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgaW1hZ2VzOiBbXSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgIG9yaWdpbmFsT3ZlcmZsb3c6IFwiXCJcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0U2xvdEltYWdlKGltZ05vZGUsIHNyYywgYWx0VGV4dCl7XG4gICAgICBpZiAoIWltZ05vZGUpIHJldHVybjtcbiAgICAgIGlmICghc3JjKSB7XG4gICAgICAgIGltZ05vZGUucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgICBpbWdOb2RlLmFsdCA9IFwiXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbWdOb2RlLmdldEF0dHJpYnV0ZShcInNyY1wiKSAhPT0gc3JjKSB7XG4gICAgICAgIGltZ05vZGUuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7XG4gICAgICB9XG4gICAgICBpbWdOb2RlLmFsdCA9IGFsdFRleHQgfHwgXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoKCl7XG4gICAgICB2YXIgdG90YWwgPSBzdGF0ZS5pbWFnZXMubGVuZ3RoO1xuICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuO1xuXG4gICAgICBzdGF0ZS5pbmRleCA9IGNsYW1wSW5kZXgoc3RhdGUuaW5kZXgsIHRvdGFsKTtcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICAgIHZhciBoYXNOZWlnaGJvcnMgPSB0b3RhbCA+IDE7XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBjbGFtcEluZGV4KGN1cnJlbnRJbmRleCAtIDEsIHRvdGFsKTtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGN1cnJlbnRJbmRleCArIDEsIHRvdGFsKTtcblxuICAgICAgc2V0U2xvdEltYWdlKGN1cnJlbnRJbWcsIHN0YXRlLmltYWdlc1tjdXJyZW50SW5kZXhdLCBcIkltYWdlbiBcIiArIChjdXJyZW50SW5kZXggKyAxKSk7XG4gICAgICBzZXRTbG90SW1hZ2UoXG4gICAgICAgIHByZXZJbWcsXG4gICAgICAgIGhhc05laWdoYm9ycyA/IHN0YXRlLmltYWdlc1twcmV2SW5kZXhdIDogXCJcIixcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gXCJJbWFnZW4gYW50ZXJpb3JcIiA6IFwiXCJcbiAgICAgICk7XG4gICAgICBzZXRTbG90SW1hZ2UoXG4gICAgICAgIG5leHRJbWcsXG4gICAgICAgIGhhc05laWdoYm9ycyA/IHN0YXRlLmltYWdlc1tuZXh0SW5kZXhdIDogXCJcIixcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gXCJJbWFnZW4gc2lndWllbnRlXCIgOiBcIlwiXG4gICAgICApO1xuXG4gICAgICBpZiAocHJldlNsb3QpIHByZXZTbG90LmNsYXNzTGlzdC50b2dnbGUoXCJpcy1lbXB0eVwiLCAhaGFzTmVpZ2hib3JzKTtcbiAgICAgIGlmIChuZXh0U2xvdCkgbmV4dFNsb3QuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWVtcHR5XCIsICFoYXNOZWlnaGJvcnMpO1xuXG4gICAgICBpZiAoY291bnRlcikgY291bnRlci50ZXh0Q29udGVudCA9IChjdXJyZW50SW5kZXggKyAxKSArIFwiIC8gXCIgKyB0b3RhbDtcbiAgICAgIGlmIChwcmV2QnRuKSBwcmV2QnRuLmRpc2FibGVkID0gIWhhc05laWdoYm9ycztcbiAgICAgIGlmIChuZXh0QnRuKSBuZXh0QnRuLmRpc2FibGVkID0gIWhhc05laWdoYm9ycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVuKGltYWdlcywgc3RhcnRJbmRleCl7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW1hZ2VzKSB8fCAhaW1hZ2VzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgc3RhdGUuaW1hZ2VzID0gaW1hZ2VzLnNsaWNlKCk7XG4gICAgICBzdGF0ZS5pbmRleCA9IGNsYW1wSW5kZXgoTnVtYmVyKHN0YXJ0SW5kZXgpIHx8IDAsIHN0YXRlLmltYWdlcy5sZW5ndGgpO1xuICAgICAgc3RhdGUuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgc3RhdGUub3JpZ2luYWxPdmVyZmxvdyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgfHwgXCJcIjtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXG4gICAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpO1xuICAgICAgbW9kYWwuY2xhc3NMaXN0LmFkZChcImlzLW9wZW5cIik7XG4gICAgICByZWZyZXNoKCk7XG5cbiAgICAgIGlmIChjbG9zZUVsc1swXSAmJiB0eXBlb2YgY2xvc2VFbHNbMF0uZm9jdXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjbG9zZUVsc1swXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlKCl7XG4gICAgICBpZiAoIXN0YXRlLmlzT3BlbikgcmV0dXJuO1xuICAgICAgc3RhdGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtb3BlblwiKTtcbiAgICAgIG1vZGFsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBzdGF0ZS5vcmlnaW5hbE92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKHN0ZXApe1xuICAgICAgaWYgKCFzdGF0ZS5pc09wZW4gfHwgc3RhdGUuaW1hZ2VzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgIHN0YXRlLmluZGV4ID0gY2xhbXBJbmRleChzdGF0ZS5pbmRleCArIHN0ZXAsIHN0YXRlLmltYWdlcy5sZW5ndGgpO1xuICAgICAgcmVmcmVzaCgpO1xuICAgIH1cblxuICAgIGNsb3NlRWxzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHByZXZCdG4pIHtcbiAgICAgIHByZXZCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoLTEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRCdG4pIHtcbiAgICAgIG5leHRCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihldil7XG4gICAgICBpZiAoIXN0YXRlLmlzT3BlbikgcmV0dXJuO1xuICAgICAgaWYgKGV2LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXYua2V5ID09PSBcIkFycm93TGVmdFwiKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5hdmlnYXRlKC0xKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc3RhZ2UpIHtcbiAgICAgIHZhciBzdGFydFggPSAwO1xuICAgICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgICB2YXIgcG9pbnRlckRvd24gPSBmYWxzZTtcblxuICAgICAgc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBpZiAoIWV2LnRvdWNoZXMgfHwgIWV2LnRvdWNoZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgc3RhcnRYID0gZXYudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICBzdGFydFkgPSBldi50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbihldil7XG4gICAgICAgIGlmICghcG9pbnRlckRvd24gfHwgIWV2LmNoYW5nZWRUb3VjaGVzIHx8ICFldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB2YXIgZW5kWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIHZhciBkeCA9IGVuZFggLSBzdGFydFg7XG4gICAgICAgIHZhciBkeSA9IGVuZFkgLSBzdGFydFk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IDQwICYmIE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgICAgIG5hdmlnYXRlKGR4ID4gMCA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICB2YXIgZ2FsbGVyaWVzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0by5nYWxlcmlhXCIpKTtcbiAgICBnYWxsZXJpZXMuZm9yRWFjaChmdW5jdGlvbihnYWxsZXJ5KXtcbiAgICAgIHZhciBjZWxscyA9IEFycmF5LmZyb20oXG4gICAgICAgIGdhbGxlcnkucXVlcnlTZWxlY3RvckFsbCgnLmdhbGVyaWEtY2VsZGFbZGF0YS1nYWxsZXJ5LWltYWdlPVwiMVwiXScpXG4gICAgICApO1xuICAgICAgaWYgKCFjZWxscy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgdmFyIGltYWdlcyA9IGNlbGxzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oY2VsbCl7XG4gICAgICAgICAgdmFyIGltZyA9IGNlbGwucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICAgICAgICBpZiAoIWltZykgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIChpbWcuZ2V0QXR0cmlidXRlKFwic3JjXCIpIHx8IFwiXCIpLnRyaW0oKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgaWYgKCFpbWFnZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgIGdhbGxlcnkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICB2YXIgY2VsbCA9IHRhcmdldC5jbG9zZXN0KCcuZ2FsZXJpYS1jZWxkYVtkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJdJyk7XG4gICAgICAgIGlmICghY2VsbCB8fCAhZ2FsbGVyeS5jb250YWlucyhjZWxsKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGNlbGxzLmluZGV4T2YoY2VsbCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcblxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgb3BlbihpbWFnZXMsIGluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICBnYWxsZXJ5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgaWYgKGV2LmtleSAhPT0gXCJFbnRlclwiICYmIGV2LmtleSAhPT0gXCIgXCIpIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICB2YXIgY2VsbCA9IHRhcmdldC5jbG9zZXN0KCcuZ2FsZXJpYS1jZWxkYVtkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJdJyk7XG4gICAgICAgIGlmICghY2VsbCB8fCAhZ2FsbGVyeS5jb250YWlucyhjZWxsKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGNlbGxzLmluZGV4T2YoY2VsbCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcblxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvcGVuKGltYWdlcywgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBib290KTtcbiAgfSBlbHNlIHtcbiAgICBib290KCk7XG4gIH1cbn0pKCk7XG48L3NjcmlwdD5cbmAudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbImhheUdhbGVyaWFDb25JbWFnZW5lcyIsIm9iamV0b3MiLCJzb21lIiwib2JqIiwidGlwbyIsIkFycmF5IiwiaXNBcnJheSIsImNlbGxzIiwiY2VsbCIsIm1lZGlhVXJsIiwidHJpbSIsImxlbmd0aCIsImdlbmVyYXJNb2RhbEdhbGVyaWFIVE1MIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarModalGaleria.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarModalRSVP.ts":
/*!*************************************************!*\
  !*** ./functions/src/utils/generarModalRSVP.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalRSVPHTML: () => (/* binding */ generarModalRSVPHTML)\n/* harmony export */ });\n// functions/src/utils/generarModalRSVP.ts\nfunction generarModalRSVPHTML(cfg) {\n    if (!(cfg === null || cfg === void 0 ? void 0 : cfg.enabled)) return \"\";\n    var _cfg_title;\n    const title = (_cfg_title = cfg.title) !== null && _cfg_title !== void 0 ? _cfg_title : \"Confirmar asistencia\";\n    var _cfg_subtitle;\n    const subtitle = (_cfg_subtitle = cfg.subtitle) !== null && _cfg_subtitle !== void 0 ? _cfg_subtitle : \"\";\n    var _cfg_buttonText;\n    const btnText = (_cfg_buttonText = cfg.buttonText) !== null && _cfg_buttonText !== void 0 ? _cfg_buttonText : \"Enviar\";\n    var _cfg_primaryColor;\n    const color = (_cfg_primaryColor = cfg.primaryColor) !== null && _cfg_primaryColor !== void 0 ? _cfg_primaryColor : \"#773dbe\";\n    // Nota: el botón que abre el modal debe tener [data-rsvp-open]\n    // (el listener de abajo lo busca)\n    return '\\n<div id=\"modal-rsvp\" style=\"\\n  position: fixed; inset: 0; display:none;\\n  background: rgba(0,0,0,.6); z-index: 9999;\\n  align-items: center; justify-content: center;\">\\n  <div style=\"\\n    background: #fff; width: 90%; max-width: 420px; border-radius: 10px;\\n    padding: 20px; font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,.2);\">\\n    <div style=\"display:flex; justify-content: space-between; align-items:center;\">\\n      <h2 style=\"margin:0; font-size:20px;\">'.concat(title, '</h2>\\n      <button id=\"rsvp-close\" aria-label=\"Cerrar\" style=\"border:none; background:transparent; font-size:18px; cursor:pointer;\">✕</button>\\n    </div>\\n    ').concat(subtitle ? '<p style=\"margin:8px 0 16px; color:#555;\">'.concat(subtitle, \"</p>\") : \"\", '\\n\\n    <div style=\"display:flex; flex-direction:column; gap:10px;\">\\n      <input id=\"rsvp-nombre\" placeholder=\"Tu nombre\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\\n      <input id=\"rsvp-mensaje\" placeholder=\"Mensaje (opcional)\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\\n    </div>\\n\\n     <!-- ✅ NUEVO: selector S\\xed/No con estilo segmentado -->\\n    <div style=\"margin-top:12px;\">\\n      <label style=\"display:block; font-weight:600; margin-bottom:8px;\">\\xbfConfirm\\xe1s asistencia?</label>\\n      <div id=\"rsvp-confirma\" style=\"\\n        display:inline-flex; gap:0; border:1px solid #ddd; border-radius:10px; overflow:hidden;\\n        box-shadow: inset 0 1px 0 rgba(0,0,0,0.03);\\n      \">\\n        <button type=\"button\" data-confirma=\"si\" aria-pressed=\"true\" style=\"\\n          padding:10px 14px; border:none; background:').concat(color, '; color:#fff; font-weight:600; cursor:pointer;\\n        \">S\\xed, voy</button>\\n        <button type=\"button\" data-confirma=\"no\" aria-pressed=\"false\" style=\"\\n          padding:10px 14px; border:none; background:#f6f6f6; color:#444; cursor:pointer;\\n        \">No puedo</button>\\n      </div>\\n    </div>\\n\\n    <div style=\"display:flex; justify-content:flex-end; gap:10px; margin-top:16px;\">\\n      <button id=\"rsvp-cancel\" style=\"padding:8px 12px; border-radius:6px; border:1px solid #ddd; background:#f3f3f3; cursor:pointer;\">Cancelar</button>\\n      <button id=\"rsvp-send\" style=\"padding:8px 12px; border-radius:6px; border:none; color:#fff; cursor:pointer; background:').concat(color, ';\">').concat(btnText, '</button>\\n    </div>\\n  </div>\\n</div>\\n\\n<script>\\ndocument.addEventListener(\\'DOMContentLoaded\\', function () {\\n\\nfunction getSlugDePagina() {\\n  // 0) Log de ayuda\\n  try { console.log(\"[RSVP] href:\", location.href); } catch (e) {}\\n\\n  // 1) <html data-slug=\"...\"> (si lo inyect\\xe1s en el HTML final)\\n  const ds = document.documentElement?.dataset?.slug;\\n  if (ds) {\\n    console.log(\"[RSVP] slug por data-atributo:\", ds);\\n    return ds;\\n  }\\n\\n  // 2) ?slug=... en la URL\\n  const q = new URLSearchParams(location.search).get(\"slug\");\\n  if (q) {\\n    console.log(\"[RSVP] slug por querystring:\", q);\\n    return q;\\n  }\\n\\n  // 3) /publicadas/<slug>/... en un sitio est\\xe1tico (Hosting/Proxy)\\n  const parts = location.pathname.split(\"/\").filter(Boolean);\\n  const i = parts.indexOf(\"publicadas\");\\n  if (i >= 0 && parts[i + 1]) {\\n    console.log(\"[RSVP] slug por pathname directo:\", parts[i + 1]);\\n    return parts[i + 1];\\n  }\\n\\n  // 4) URL de Firebase Storage:\\n  //    https://firebasestorage.googleapis.com/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media&token=...\\n  //    https://<bucket>.firebasestorage.app/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media\\n  try {\\n    const pathAfterO = location.pathname.split(\"/o/\")[1]; // \"publicadas%2F<slug>%2Findex.html\"\\n    if (pathAfterO) {\\n      const decoded = decodeURIComponent(pathAfterO);      // \"publicadas/<slug>/index.html\"\\n      const segs = decoded.split(\"/\").filter(Boolean);\\n      const j = segs.indexOf(\"publicadas\");\\n      if (j >= 0 && segs[j + 1]) {\\n        console.log(\"[RSVP] slug por URL de Storage:\", segs[j + 1]);\\n        return segs[j + 1];\\n      }\\n    }\\n  } catch (e) {\\n    console.warn(\"[RSVP] Error parseando URL de Storage:\", e);\\n  }\\n\\n  console.warn(\"[RSVP] No se pudo detectar slug. Fallback: sin-slug\");\\n  return \"sin-slug\";\\n}\\n\\n\\n  var modal = document.getElementById(\\'modal-rsvp\\');\\n  if (!modal) return;\\n\\n  function openModal() { \\n  modal.style.display = \\'flex\\'; \\n  // \\uD83D\\uDD01 Reset visual y estado cada vez que se abre\\n  setConfirmaUI(\"si\", ').concat(JSON.stringify(color), ');\\n}\\n\\n  function closeModal() { modal.style.display = \\'none\\'; }\\n\\n  // Botones internos\\n  var closeBtn = document.getElementById(\\'rsvp-close\\');\\n  var cancelBtn = document.getElementById(\\'rsvp-cancel\\');\\n  var sendBtn = document.getElementById(\\'rsvp-send\\');\\n\\n  if (closeBtn) closeBtn.addEventListener(\\'click\\', closeModal);\\n  if (cancelBtn) cancelBtn.addEventListener(\\'click\\', closeModal);\\n\\n  // Click fuera del cuadro\\n  modal.addEventListener(\\'click\\', function(e) {\\n    if (e.target === modal) closeModal();\\n  });\\n\\n  // Abridores: cualquier elemento con data-rsvp-open\\ndocument.querySelectorAll(\\'[data-rsvp-open], [data-accion=\"abrir-rsvp\"], .rsvp-boton\\').forEach(function(el) {\\n    el.addEventListener(\\'click\\', function(e) {\\n      e.preventDefault();\\n      openModal();\\n    });\\n  });\\n\\n\\n// Estado interno del selector S\\xed/No\\nvar confirmaValor = \"si\"; // default\\n\\nfunction setConfirmaUI(valor, color) {\\n  var cont = document.getElementById(\\'rsvp-confirma\\');\\n  if (!cont) return;\\n  var btnSi = cont.querySelector(\\'[data-confirma=\"si\"]\\');\\n  var btnNo = cont.querySelector(\\'[data-confirma=\"no\"]\\');\\n  confirmaValor = (valor === \"no\") ? \"no\" : \"si\";\\n\\n  if (btnSi && btnNo) {\\n    if (confirmaValor === \"si\") {\\n      btnSi.style.background = color;\\n      btnSi.style.color = \"#fff\";\\n      btnSi.setAttribute(\"aria-pressed\", \"true\");\\n\\n      btnNo.style.background = \"#f6f6f6\";\\n      btnNo.style.color = \"#444\";\\n      btnNo.setAttribute(\"aria-pressed\", \"false\");\\n    } else {\\n      btnNo.style.background = color;\\n      btnNo.style.color = \"#fff\";\\n      btnNo.setAttribute(\"aria-pressed\", \"true\");\\n\\n      btnSi.style.background = \"#f6f6f6\";\\n      btnSi.style.color = \"#444\";\\n      btnSi.setAttribute(\"aria-pressed\", \"false\");\\n    }\\n  }\\n}\\n\\n// \\uD83D\\uDD39 Dejar \"S\\xed\" seleccionado al cargar\\nsetConfirmaUI(\"si\", ').concat(JSON.stringify(color), \");\\n\\n// \\uD83D\\uDD39 Alternar selecci\\xf3n al click\\nvar confirmaWrap = document.getElementById('rsvp-confirma');\\nif (confirmaWrap) {\\n  confirmaWrap.addEventListener('click', function(e) {\\n    var btn = e.target.closest('[data-confirma]');\\n    if (!btn) return;\\n    var v = btn.getAttribute('data-confirma');\\n    setConfirmaUI(v, \").concat(JSON.stringify(color), \");\\n    try { console.log(\\\"[RSVP] cambia confirmaValor =\\\", v); } catch(_) {}\\n  });\\n}\\n\\n\\n\\n  // ✅ Env\\xedo con Firestore + logs\\nif (sendBtn) {\\n  sendBtn.addEventListener('click', function() {\\n    var nombre = (document.getElementById('rsvp-nombre') || {}).value || '';\\n    var mensaje = (document.getElementById('rsvp-mensaje') || {}).value || '';\\n\\n    if (!nombre.trim()) {\\n      alert('Por favor ingres\\xe1 tu nombre.');\\n      return;\\n    }\\n\\n    const confirma = (confirmaValor === \\\"si\\\"); \\n    const slug = getSlugDePagina();\\n    console.log(\\\"[RSVP] Enviando RSVP… slug =\\\", slug);\\n\\n    // (opcional) si segu\\xeds usando sheetUrl, mantenemos el POST “en paralelo”\\n    var sheetUrl = \").concat(JSON.stringify(cfg.sheetUrl || \"\"), ';\\n    if (sheetUrl) {\\n      try {\\n        fetch(sheetUrl, {\\n          method: \\'POST\\',\\n          headers: {\\'Content-Type\\':\\'application/json\\'},\\n          body: JSON.stringify({\\n            nombre: nombre.trim(),\\n            mensaje: mensaje.trim(),\\n            slug: slug,\\n            ts: Date.now()\\n          })\\n        }).catch(function(e){ console.warn(\"[RSVP] sheetUrl error:\", e); });\\n      } catch (e) {\\n        console.warn(\"[RSVP] sheetUrl throw:\", e);\\n      }\\n    }\\n\\n    // \\uD83D\\uDD0C Importar Firebase din\\xe1micamente y guardar en Firestore\\n    Promise.all([\\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js\"),\\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js\"),\\n    ])\\n    .then(([appMod, fsMod]) => {\\n      const { initializeApp } = appMod;\\n      const { getFirestore, collection, addDoc, serverTimestamp } = fsMod;\\n\\n      // ⚙️ Config m\\xednima (apiKey y projectId son suficientes para el cliente)\\n      const firebaseConfig = {\\n        apiKey: \"AIzaSyALCvU48_HRp26cXpQcTX5S33Adpwfl3z4\",\\n        authDomain: \"reservaeldia.com.ar\",\\n        projectId: \"reservaeldia-7a440\",\\n        appId: \"1:860495975406:web:3a49ad0cf55d60313534ff\"\\n      };\\n\\n      const app = initializeApp(firebaseConfig);\\n      const db  = getFirestore(app);\\n\\n      const payload = {\\n        nombre: nombre.trim(),\\n        mensaje: (mensaje && mensaje.trim()) || null,\\n        confirma,\\n        createdAt: serverTimestamp(),\\n        userAgent: navigator.userAgent.slice(0, 512)\\n      };\\n\\n      console.log(\"[RSVP] Payload keys =\", Object.keys(payload));\\n      console.log(\"[RSVP] Payload =\", JSON.stringify(payload));\\n\\n      return addDoc(collection(db, \"publicadas\", slug, \"rsvps\"), payload);\\n    })\\n    .then((docRef) => {\\n      console.log(\"[RSVP] RSVP guardado con ID:\", docRef.id, \"en /publicadas/\"+slug+\"/rsvps\");\\n      alert(\\'\\xa1Gracias por confirmar tu asistencia, \\' + nombre + \\'!\\');\\n      closeModal();\\n    })\\n    .catch((err) => {\\n      console.error(\"[RSVP] Error guardando en Firestore:\", err);\\n      alert(\\'Hubo un error al guardar tu confirmaci\\xf3n. Prob\\xe1 de nuevo.\\');\\n    });\\n  });\\n}\\n \\n  \\n\\n});\\n</script>\\n');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsUlNWUC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMENBQTBDO0FBV25DLFNBQVNBLHFCQUFxQkMsR0FBZTtJQUNoRCxJQUFJLEVBQUNBLGdCQUFBQSwwQkFBQUEsSUFBS0MsT0FBTyxHQUFFLE9BQU87UUFFWkQ7SUFBZCxNQUFNRSxRQUFRRixDQUFBQSxhQUFBQSxJQUFJRSxLQUFLLGNBQVRGLHdCQUFBQSxhQUFhO1FBQ1ZBO0lBQWpCLE1BQU1HLFdBQVdILENBQUFBLGdCQUFBQSxJQUFJRyxRQUFRLGNBQVpILDJCQUFBQSxnQkFBZ0I7UUFDakJBO0lBQWhCLE1BQU1JLFVBQVVKLENBQUFBLGtCQUFBQSxJQUFJSyxVQUFVLGNBQWRMLDZCQUFBQSxrQkFBa0I7UUFDcEJBO0lBQWQsTUFBTU0sUUFBUU4sQ0FBQUEsb0JBQUFBLElBQUlPLFlBQVksY0FBaEJQLCtCQUFBQSxvQkFBb0I7SUFFbEMsK0RBQStEO0lBQy9ELGtDQUFrQztJQUNsQyxPQUFPLGtlQVlMRyxPQUh3Q0QsT0FBTSxzS0FrQkdJLE9BZmpESCxXQUFXLDZDQUFzRCxPQUFUQSxVQUFTLFVBQVEsSUFBRyxrM0JBeUI2Q0csT0FWeEVBLE9BQU0sbXFCQVU2RUYsT0FBWEUsT0FBTSxPQStEN0dFLE9BL0RrSEosU0FBUSxtakVBMEg1SEksT0EzREVBLEtBQUtDLFNBQVMsQ0FBQ0gsUUFBTyxnMkRBb0V2QkUsT0FUREEsS0FBS0MsU0FBUyxDQUFDSCxRQUFPLHFWQWdDdkJFLE9BdkJFQSxLQUFLQyxTQUFTLENBQUNILFFBQU8seXNCQXVCVyxPQUFuQ0UsS0FBS0MsU0FBUyxDQUFDVCxJQUFJVSxRQUFRLElBQUksS0FBSTtBQW9FeEQiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vZGFsUlNWUC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL2dlbmVyYXJNb2RhbFJTVlAudHNcclxuXHJcbmV4cG9ydCB0eXBlIFJTVlBDb25maWcgPSB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG4gICAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgICBzdWJ0aXRsZT86IHN0cmluZztcclxuICAgIGJ1dHRvblRleHQ/OiBzdHJpbmc7XHJcbiAgICBwcmltYXJ5Q29sb3I/OiBzdHJpbmc7IC8vIGNvbG9yIGRlbCBib3TDs24vY2FiZWNlcmFcclxuICAgIHNoZWV0VXJsPzogc3RyaW5nOyAgICAgLy8gb3BjaW9uYWwgc2kgdmFzIGEgZW52aWFyIGEgR29vZ2xlIFNoZWV0cyBvIHNpbWlsYXJcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxSU1ZQSFRNTChjZmc6IFJTVlBDb25maWcpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFjZmc/LmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gY2ZnLnRpdGxlID8/IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIjtcclxuICAgIGNvbnN0IHN1YnRpdGxlID0gY2ZnLnN1YnRpdGxlID8/IFwiXCI7XHJcbiAgICBjb25zdCBidG5UZXh0ID0gY2ZnLmJ1dHRvblRleHQgPz8gXCJFbnZpYXJcIjtcclxuICAgIGNvbnN0IGNvbG9yID0gY2ZnLnByaW1hcnlDb2xvciA/PyBcIiM3NzNkYmVcIjtcclxuXHJcbiAgICAvLyBOb3RhOiBlbCBib3TDs24gcXVlIGFicmUgZWwgbW9kYWwgZGViZSB0ZW5lciBbZGF0YS1yc3ZwLW9wZW5dXHJcbiAgICAvLyAoZWwgbGlzdGVuZXIgZGUgYWJham8gbG8gYnVzY2EpXHJcbiAgICByZXR1cm4gYFxyXG48ZGl2IGlkPVwibW9kYWwtcnN2cFwiIHN0eWxlPVwiXHJcbiAgcG9zaXRpb246IGZpeGVkOyBpbnNldDogMDsgZGlzcGxheTpub25lO1xyXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjYpOyB6LWluZGV4OiA5OTk5O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyO1wiPlxyXG4gIDxkaXYgc3R5bGU9XCJcclxuICAgIGJhY2tncm91bmQ6ICNmZmY7IHdpZHRoOiA5MCU7IG1heC13aWR0aDogNDIwcHg7IGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICBwYWRkaW5nOiAyMHB4OyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgYm94LXNoYWRvdzogMCAxMHB4IDMwcHggcmdiYSgwLDAsMCwuMik7XCI+XHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOmNlbnRlcjtcIj5cclxuICAgICAgPGgyIHN0eWxlPVwibWFyZ2luOjA7IGZvbnQtc2l6ZToyMHB4O1wiPiR7dGl0bGV9PC9oMj5cclxuICAgICAgPGJ1dHRvbiBpZD1cInJzdnAtY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2VycmFyXCIgc3R5bGU9XCJib3JkZXI6bm9uZTsgYmFja2dyb3VuZDp0cmFuc3BhcmVudDsgZm9udC1zaXplOjE4cHg7IGN1cnNvcjpwb2ludGVyO1wiPuKclTwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICAke3N1YnRpdGxlID8gYDxwIHN0eWxlPVwibWFyZ2luOjhweCAwIDE2cHg7IGNvbG9yOiM1NTU7XCI+JHtzdWJ0aXRsZX08L3A+YCA6IFwiXCJ9XHJcblxyXG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDtcIj5cclxuICAgICAgPGlucHV0IGlkPVwicnN2cC1ub21icmVcIiBwbGFjZWhvbGRlcj1cIlR1IG5vbWJyZVwiIHN0eWxlPVwicGFkZGluZzoxMHB4OyBib3JkZXI6MXB4IHNvbGlkICNjY2M7IGJvcmRlci1yYWRpdXM6NnB4O1wiIC8+XHJcbiAgICAgIDxpbnB1dCBpZD1cInJzdnAtbWVuc2FqZVwiIHBsYWNlaG9sZGVyPVwiTWVuc2FqZSAob3BjaW9uYWwpXCIgc3R5bGU9XCJwYWRkaW5nOjEwcHg7IGJvcmRlcjoxcHggc29saWQgI2NjYzsgYm9yZGVyLXJhZGl1czo2cHg7XCIgLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgICA8IS0tIOKchSBOVUVWTzogc2VsZWN0b3IgU8OtL05vIGNvbiBlc3RpbG8gc2VnbWVudGFkbyAtLT5cclxuICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tdG9wOjEycHg7XCI+XHJcbiAgICAgIDxsYWJlbCBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IGZvbnQtd2VpZ2h0OjYwMDsgbWFyZ2luLWJvdHRvbTo4cHg7XCI+wr9Db25maXJtw6FzIGFzaXN0ZW5jaWE/PC9sYWJlbD5cclxuICAgICAgPGRpdiBpZD1cInJzdnAtY29uZmlybWFcIiBzdHlsZT1cIlxyXG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWZsZXg7IGdhcDowOyBib3JkZXI6MXB4IHNvbGlkICNkZGQ7IGJvcmRlci1yYWRpdXM6MTBweDsgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgwLDAsMCwwLjAzKTtcclxuICAgICAgXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1jb25maXJtYT1cInNpXCIgYXJpYS1wcmVzc2VkPVwidHJ1ZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6JHtjb2xvcn07IGNvbG9yOiNmZmY7IGZvbnQtd2VpZ2h0OjYwMDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+U8OtLCB2b3k8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWNvbmZpcm1hPVwibm9cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6I2Y2ZjZmNjsgY29sb3I6IzQ0NDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+Tm8gcHVlZG88L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7IGdhcDoxMHB4OyBtYXJnaW4tdG9wOjE2cHg7XCI+XHJcbiAgICAgIDxidXR0b24gaWQ9XCJyc3ZwLWNhbmNlbFwiIHN0eWxlPVwicGFkZGluZzo4cHggMTJweDsgYm9yZGVyLXJhZGl1czo2cHg7IGJvcmRlcjoxcHggc29saWQgI2RkZDsgYmFja2dyb3VuZDojZjNmM2YzOyBjdXJzb3I6cG9pbnRlcjtcIj5DYW5jZWxhcjwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGlkPVwicnN2cC1zZW5kXCIgc3R5bGU9XCJwYWRkaW5nOjhweCAxMnB4OyBib3JkZXItcmFkaXVzOjZweDsgYm9yZGVyOm5vbmU7IGNvbG9yOiNmZmY7IGN1cnNvcjpwb2ludGVyOyBiYWNrZ3JvdW5kOiR7Y29sb3J9O1wiPiR7YnRuVGV4dH08L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5mdW5jdGlvbiBnZXRTbHVnRGVQYWdpbmEoKSB7XHJcbiAgLy8gMCkgTG9nIGRlIGF5dWRhXHJcbiAgdHJ5IHsgY29uc29sZS5sb2coXCJbUlNWUF0gaHJlZjpcIiwgbG9jYXRpb24uaHJlZik7IH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIC8vIDEpIDxodG1sIGRhdGEtc2x1Zz1cIi4uLlwiPiAoc2kgbG8gaW55ZWN0w6FzIGVuIGVsIEhUTUwgZmluYWwpXHJcbiAgY29uc3QgZHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/LmRhdGFzZXQ/LnNsdWc7XHJcbiAgaWYgKGRzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBkYXRhLWF0cmlidXRvOlwiLCBkcyk7XHJcbiAgICByZXR1cm4gZHM7XHJcbiAgfVxyXG5cclxuICAvLyAyKSA/c2x1Zz0uLi4gZW4gbGEgVVJMXHJcbiAgY29uc3QgcSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKS5nZXQoXCJzbHVnXCIpO1xyXG4gIGlmIChxKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBxdWVyeXN0cmluZzpcIiwgcSk7XHJcbiAgICByZXR1cm4gcTtcclxuICB9XHJcblxyXG4gIC8vIDMpIC9wdWJsaWNhZGFzLzxzbHVnPi8uLi4gZW4gdW4gc2l0aW8gZXN0w6F0aWNvIChIb3N0aW5nL1Byb3h5KVxyXG4gIGNvbnN0IHBhcnRzID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcclxuICBjb25zdCBpID0gcGFydHMuaW5kZXhPZihcInB1YmxpY2FkYXNcIik7XHJcbiAgaWYgKGkgPj0gMCAmJiBwYXJ0c1tpICsgMV0pIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIHBhdGhuYW1lIGRpcmVjdG86XCIsIHBhcnRzW2kgKyAxXSk7XHJcbiAgICByZXR1cm4gcGFydHNbaSArIDFdO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgVVJMIGRlIEZpcmViYXNlIFN0b3JhZ2U6XHJcbiAgLy8gICAgaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYSZ0b2tlbj0uLi5cclxuICAvLyAgICBodHRwczovLzxidWNrZXQ+LmZpcmViYXNlc3RvcmFnZS5hcHAvdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXRoQWZ0ZXJPID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvby9cIilbMV07IC8vIFwicHVibGljYWRhcyUyRjxzbHVnPiUyRmluZGV4Lmh0bWxcIlxyXG4gICAgaWYgKHBhdGhBZnRlck8pIHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXRoQWZ0ZXJPKTsgICAgICAvLyBcInB1YmxpY2FkYXMvPHNsdWc+L2luZGV4Lmh0bWxcIlxyXG4gICAgICBjb25zdCBzZWdzID0gZGVjb2RlZC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICBjb25zdCBqID0gc2Vncy5pbmRleE9mKFwicHVibGljYWRhc1wiKTtcclxuICAgICAgaWYgKGogPj0gMCAmJiBzZWdzW2ogKyAxXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIFVSTCBkZSBTdG9yYWdlOlwiLCBzZWdzW2ogKyAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiW1JTVlBdIEVycm9yIHBhcnNlYW5kbyBVUkwgZGUgU3RvcmFnZTpcIiwgZSk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLndhcm4oXCJbUlNWUF0gTm8gc2UgcHVkbyBkZXRlY3RhciBzbHVnLiBGYWxsYmFjazogc2luLXNsdWdcIik7XHJcbiAgcmV0dXJuIFwic2luLXNsdWdcIjtcclxufVxyXG5cclxuXHJcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsLXJzdnAnKTtcclxuICBpZiAoIW1vZGFsKSByZXR1cm47XHJcblxyXG4gIGZ1bmN0aW9uIG9wZW5Nb2RhbCgpIHsgXHJcbiAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgXHJcbiAgLy8g8J+UgSBSZXNldCB2aXN1YWwgeSBlc3RhZG8gY2FkYSB2ZXogcXVlIHNlIGFicmVcclxuICBzZXRDb25maXJtYVVJKFwic2lcIiwgJHtKU09OLnN0cmluZ2lmeShjb2xvcil9KTtcclxufVxyXG5cclxuICBmdW5jdGlvbiBjbG9zZU1vZGFsKCkgeyBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9XHJcblxyXG4gIC8vIEJvdG9uZXMgaW50ZXJub3NcclxuICB2YXIgY2xvc2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jbG9zZScpO1xyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jYW5jZWwnKTtcclxuICB2YXIgc2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLXNlbmQnKTtcclxuXHJcbiAgaWYgKGNsb3NlQnRuKSBjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG4gIGlmIChjYW5jZWxCdG4pIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG5cclxuICAvLyBDbGljayBmdWVyYSBkZWwgY3VhZHJvXHJcbiAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgPT09IG1vZGFsKSBjbG9zZU1vZGFsKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEFicmlkb3JlczogY3VhbHF1aWVyIGVsZW1lbnRvIGNvbiBkYXRhLXJzdnAtb3BlblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yc3ZwLW9wZW5dLCBbZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJdLCAucnN2cC1ib3RvbicpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIG9wZW5Nb2RhbCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG5cclxuLy8gRXN0YWRvIGludGVybm8gZGVsIHNlbGVjdG9yIFPDrS9Ob1xyXG52YXIgY29uZmlybWFWYWxvciA9IFwic2lcIjsgLy8gZGVmYXVsdFxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlybWFVSSh2YWxvciwgY29sb3IpIHtcclxuICB2YXIgY29udCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbiAgaWYgKCFjb250KSByZXR1cm47XHJcbiAgdmFyIGJ0blNpID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cInNpXCJdJyk7XHJcbiAgdmFyIGJ0bk5vID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cIm5vXCJdJyk7XHJcbiAgY29uZmlybWFWYWxvciA9ICh2YWxvciA9PT0gXCJub1wiKSA/IFwibm9cIiA6IFwic2lcIjtcclxuXHJcbiAgaWYgKGJ0blNpICYmIGJ0bk5vKSB7XHJcbiAgICBpZiAoY29uZmlybWFWYWxvciA9PT0gXCJzaVwiKSB7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcjtcclxuICAgICAgYnRuU2kuc3R5bGUuY29sb3IgPSBcIiNmZmZcIjtcclxuICAgICAgYnRuU2kuc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKTtcclxuXHJcbiAgICAgIGJ0bk5vLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgYnRuTm8uc3R5bGUuY29sb3IgPSBcIiM0NDRcIjtcclxuICAgICAgYnRuTm8uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidG5Oby5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3I7XHJcbiAgICAgIGJ0bk5vLnN0eWxlLmNvbG9yID0gXCIjZmZmXCI7XHJcbiAgICAgIGJ0bk5vLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XHJcblxyXG4gICAgICBidG5TaS5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZjZmNmY2XCI7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmNvbG9yID0gXCIjNDQ0XCI7XHJcbiAgICAgIGJ0blNpLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+UuSBEZWphciBcIlPDrVwiIHNlbGVjY2lvbmFkbyBhbCBjYXJnYXJcclxuc2V0Q29uZmlybWFVSShcInNpXCIsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcblxyXG4vLyDwn5S5IEFsdGVybmFyIHNlbGVjY2nDs24gYWwgY2xpY2tcclxudmFyIGNvbmZpcm1hV3JhcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbmlmIChjb25maXJtYVdyYXApIHtcclxuICBjb25maXJtYVdyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgYnRuID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtY29uZmlybWFdJyk7XHJcbiAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG4gICAgdmFyIHYgPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm1hJyk7XHJcbiAgICBzZXRDb25maXJtYVVJKHYsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcbiAgICB0cnkgeyBjb25zb2xlLmxvZyhcIltSU1ZQXSBjYW1iaWEgY29uZmlybWFWYWxvciA9XCIsIHYpOyB9IGNhdGNoKF8pIHt9XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICAvLyDinIUgRW52w61vIGNvbiBGaXJlc3RvcmUgKyBsb2dzXHJcbmlmIChzZW5kQnRuKSB7XHJcbiAgc2VuZEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5vbWJyZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1ub21icmUnKSB8fCB7fSkudmFsdWUgfHwgJyc7XHJcbiAgICB2YXIgbWVuc2FqZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1tZW5zYWplJykgfHwge30pLnZhbHVlIHx8ICcnO1xyXG5cclxuICAgIGlmICghbm9tYnJlLnRyaW0oKSkge1xyXG4gICAgICBhbGVydCgnUG9yIGZhdm9yIGluZ3Jlc8OhIHR1IG5vbWJyZS4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpcm1hID0gKGNvbmZpcm1hVmFsb3IgPT09IFwic2lcIik7IFxyXG4gICAgY29uc3Qgc2x1ZyA9IGdldFNsdWdEZVBhZ2luYSgpO1xyXG4gICAgY29uc29sZS5sb2coXCJbUlNWUF0gRW52aWFuZG8gUlNWUOKApiBzbHVnID1cIiwgc2x1Zyk7XHJcblxyXG4gICAgLy8gKG9wY2lvbmFsKSBzaSBzZWd1w61zIHVzYW5kbyBzaGVldFVybCwgbWFudGVuZW1vcyBlbCBQT1NUIOKAnGVuIHBhcmFsZWxv4oCdXHJcbiAgICB2YXIgc2hlZXRVcmwgPSAke0pTT04uc3RyaW5naWZ5KGNmZy5zaGVldFVybCB8fCBcIlwiKX07XHJcbiAgICBpZiAoc2hlZXRVcmwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmZXRjaChzaGVldFVybCwge1xyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgbm9tYnJlOiBub21icmUudHJpbSgpLFxyXG4gICAgICAgICAgICBtZW5zYWplOiBtZW5zYWplLnRyaW0oKSxcclxuICAgICAgICAgICAgc2x1Zzogc2x1ZyxcclxuICAgICAgICAgICAgdHM6IERhdGUubm93KClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSl7IGNvbnNvbGUud2FybihcIltSU1ZQXSBzaGVldFVybCBlcnJvcjpcIiwgZSk7IH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1JTVlBdIHNoZWV0VXJsIHRocm93OlwiLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIPCflIwgSW1wb3J0YXIgRmlyZWJhc2UgZGluw6FtaWNhbWVudGUgeSBndWFyZGFyIGVuIEZpcmVzdG9yZVxyXG4gICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtYXBwLmpzXCIpLFxyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtZmlyZXN0b3JlLmpzXCIpLFxyXG4gICAgXSlcclxuICAgIC50aGVuKChbYXBwTW9kLCBmc01vZF0pID0+IHtcclxuICAgICAgY29uc3QgeyBpbml0aWFsaXplQXBwIH0gPSBhcHBNb2Q7XHJcbiAgICAgIGNvbnN0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCB9ID0gZnNNb2Q7XHJcblxyXG4gICAgICAvLyDimpnvuI8gQ29uZmlnIG3DrW5pbWEgKGFwaUtleSB5IHByb2plY3RJZCBzb24gc3VmaWNpZW50ZXMgcGFyYSBlbCBjbGllbnRlKVxuICAgICAgY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gICAgICAgIGFwaUtleTogXCJBSXphU3lBTEN2VTQ4X0hScDI2Y1hwUWNUWDVTMzNBZHB3ZmwzejRcIixcbiAgICAgICAgYXV0aERvbWFpbjogXCJyZXNlcnZhZWxkaWEuY29tLmFyXCIsXG4gICAgICAgIHByb2plY3RJZDogXCJyZXNlcnZhZWxkaWEtN2E0NDBcIixcbiAgICAgICAgYXBwSWQ6IFwiMTo4NjA0OTU5NzU0MDY6d2ViOjNhNDlhZDBjZjU1ZDYwMzEzNTM0ZmZcIlxuICAgICAgfTtcblxyXG4gICAgICBjb25zdCBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcclxuICAgICAgY29uc3QgZGIgID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgIG5vbWJyZTogbm9tYnJlLnRyaW0oKSxcclxuICAgICAgICBtZW5zYWplOiAobWVuc2FqZSAmJiBtZW5zYWplLnRyaW0oKSkgfHwgbnVsbCxcclxuICAgICAgICBjb25maXJtYSxcclxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudC5zbGljZSgwLCA1MTIpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBQYXlsb2FkIGtleXMgPVwiLCBPYmplY3Qua2V5cyhwYXlsb2FkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFBheWxvYWQgPVwiLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcblxyXG4gICAgICByZXR1cm4gYWRkRG9jKGNvbGxlY3Rpb24oZGIsIFwicHVibGljYWRhc1wiLCBzbHVnLCBcInJzdnBzXCIpLCBwYXlsb2FkKTtcclxuICAgIH0pXHJcbiAgICAudGhlbigoZG9jUmVmKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFJTVlAgZ3VhcmRhZG8gY29uIElEOlwiLCBkb2NSZWYuaWQsIFwiZW4gL3B1YmxpY2FkYXMvXCIrc2x1ZytcIi9yc3Zwc1wiKTtcclxuICAgICAgYWxlcnQoJ8KhR3JhY2lhcyBwb3IgY29uZmlybWFyIHR1IGFzaXN0ZW5jaWEsICcgKyBub21icmUgKyAnIScpO1xyXG4gICAgICBjbG9zZU1vZGFsKCk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltSU1ZQXSBFcnJvciBndWFyZGFuZG8gZW4gRmlyZXN0b3JlOlwiLCBlcnIpO1xyXG4gICAgICBhbGVydCgnSHVibyB1biBlcnJvciBhbCBndWFyZGFyIHR1IGNvbmZpcm1hY2nDs24uIFByb2LDoSBkZSBudWV2by4nKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbiBcclxuICBcclxuXHJcbn0pO1xyXG48L3NjcmlwdD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhck1vZGFsUlNWUEhUTUwiLCJjZmciLCJlbmFibGVkIiwidGl0bGUiLCJzdWJ0aXRsZSIsImJ0blRleHQiLCJidXR0b25UZXh0IiwiY29sb3IiLCJwcmltYXJ5Q29sb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hlZXRVcmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarModalRSVP.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/config.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/config.ts ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/config.ts\nfunction normalizeConfig(opts) {\n    const fitMinScaleRaw = Number.isFinite(opts.fitMinScale) ? Number(opts.fitMinScale) : 0.88;\n    const fitMaxScaleRaw = Number.isFinite(opts.fitMaxScale) ? Number(opts.fitMaxScale) : 1.16;\n    const fitMinScale = Math.max(0.7, Math.min(1, fitMinScaleRaw));\n    const fitMaxScale = Math.max(1, fitMaxScaleRaw);\n    const fitTargetWidthRatioRaw = Number.isFinite(opts.fitTargetWidthRatio) ? Number(opts.fitTargetWidthRatio) : 0.94;\n    const fitTargetWidthRatio = Math.max(0.75, Math.min(0.99, fitTargetWidthRatioRaw));\n    const fitMinFillRatioRaw = Number.isFinite(opts.fitMinFillRatio) ? Number(opts.fitMinFillRatio) : 0.9;\n    const fitMinFillRatio = Math.max(0.6, Math.min(fitTargetWidthRatio, fitMinFillRatioRaw));\n    return {\n        enabled: !!opts.enabled,\n        minGapPx: Number.isFinite(opts.minGapPx) ? Number(opts.minGapPx) : 8,\n        paddingTopPx: Number.isFinite(opts.paddingTopPx) ? Number(opts.paddingTopPx) : 0,\n        paddingBottomPx: Number.isFinite(opts.paddingBottomPx) ? Number(opts.paddingBottomPx) : 12,\n        maxGapPx: Number.isFinite(opts.maxGapPx) ? Number(opts.maxGapPx) : 22,\n        onlyFixedSections: opts.onlyFixedSections !== false,\n        onlyWhenReordered: opts.onlyWhenReordered !== false,\n        rowTolPx: Number.isFinite(opts.rowTolPx) ? Number(opts.rowTolPx) : 28,\n        twoColSpreadRatio: Number.isFinite(opts.twoColSpreadRatio) ? Number(opts.twoColSpreadRatio) : 0.18,\n        minPerColumn2: Number.isFinite(opts.minPerColumn2) ? Number(opts.minPerColumn2) : 2,\n        threeColSpreadRatio: Number.isFinite(opts.threeColSpreadRatio) ? Number(opts.threeColSpreadRatio) : 0.22,\n        minPerColumn3: Number.isFinite(opts.minPerColumn3) ? Number(opts.minPerColumn3) : 2,\n        gapScale: Number.isFinite(opts.gapScale) ? Number(opts.gapScale) : 0.6,\n        fitMinScale,\n        fitMaxScale,\n        fitTargetWidthRatio,\n        fitMinFillRatio\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrREFBa0Q7QUFPM0MsU0FBU0EsZ0JBQWdCQyxJQUE4QjtJQUM1RCxNQUFNQyxpQkFBaUJDLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS0ksV0FBVyxJQUFJRixPQUFPRixLQUFLSSxXQUFXLElBQUk7SUFDdEYsTUFBTUMsaUJBQWlCSCxPQUFPQyxRQUFRLENBQUNILEtBQUtNLFdBQVcsSUFBSUosT0FBT0YsS0FBS00sV0FBVyxJQUFJO0lBQ3RGLE1BQU1GLGNBQWNHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLRSxHQUFHLENBQUMsR0FBR1I7SUFDOUMsTUFBTUssY0FBY0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdIO0lBQ2hDLE1BQU1LLHlCQUF5QlIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLVyxtQkFBbUIsSUFDbkVULE9BQU9GLEtBQUtXLG1CQUFtQixJQUMvQjtJQUNKLE1BQU1BLHNCQUFzQkosS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxNQUFNQztJQUMxRCxNQUFNRSxxQkFBcUJWLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS2EsZUFBZSxJQUMzRFgsT0FBT0YsS0FBS2EsZUFBZSxJQUMzQjtJQUNKLE1BQU1BLGtCQUFrQk4sS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtFLEdBQUcsQ0FBQ0UscUJBQXFCQztJQUVwRSxPQUFPO1FBQ0xFLFNBQVMsQ0FBQyxDQUFDZCxLQUFLYyxPQUFPO1FBRXZCQyxVQUFVYixPQUFPQyxRQUFRLENBQUNILEtBQUtlLFFBQVEsSUFBSWIsT0FBT0YsS0FBS2UsUUFBUSxJQUFJO1FBQ25FQyxjQUFjZCxPQUFPQyxRQUFRLENBQUNILEtBQUtnQixZQUFZLElBQUlkLE9BQU9GLEtBQUtnQixZQUFZLElBQUk7UUFDL0VDLGlCQUFpQmYsT0FBT0MsUUFBUSxDQUFDSCxLQUFLaUIsZUFBZSxJQUFJZixPQUFPRixLQUFLaUIsZUFBZSxJQUFJO1FBQ3hGQyxVQUFVaEIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLa0IsUUFBUSxJQUFJaEIsT0FBT0YsS0FBS2tCLFFBQVEsSUFBSTtRQUVuRUMsbUJBQW1CbkIsS0FBS21CLGlCQUFpQixLQUFLO1FBQzlDQyxtQkFBbUJwQixLQUFLb0IsaUJBQWlCLEtBQUs7UUFFOUNDLFVBQVVuQixPQUFPQyxRQUFRLENBQUNILEtBQUtxQixRQUFRLElBQUluQixPQUFPRixLQUFLcUIsUUFBUSxJQUFJO1FBRW5FQyxtQkFBbUJwQixPQUFPQyxRQUFRLENBQUNILEtBQUtzQixpQkFBaUIsSUFBSXBCLE9BQU9GLEtBQUtzQixpQkFBaUIsSUFBSTtRQUM5RkMsZUFBZXJCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3VCLGFBQWEsSUFBSXJCLE9BQU9GLEtBQUt1QixhQUFhLElBQUk7UUFFbEZDLHFCQUFxQnRCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3dCLG1CQUFtQixJQUFJdEIsT0FBT0YsS0FBS3dCLG1CQUFtQixJQUFJO1FBQ3BHQyxlQUFldkIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLeUIsYUFBYSxJQUFJdkIsT0FBT0YsS0FBS3lCLGFBQWEsSUFBSTtRQUVsRkMsVUFBVXhCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBSzBCLFFBQVEsSUFBSXhCLE9BQU9GLEtBQUswQixRQUFRLElBQUk7UUFDbkV0QjtRQUNBRTtRQUNBSztRQUNBRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2NvbmZpZy50c1xyXG5pbXBvcnQgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9ybWFsaXplZENvbmZpZyA9IFJlcXVpcmVkPE9taXQ8TW9iaWxlU21hcnRMYXlvdXRPcHRpb25zLCBcImVuYWJsZWRcIj4+ICYge1xyXG4gIGVuYWJsZWQ6IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKG9wdHM6IE1vYmlsZVNtYXJ0TGF5b3V0T3B0aW9ucyk6IE5vcm1hbGl6ZWRDb25maWcge1xuICBjb25zdCBmaXRNaW5TY2FsZVJhdyA9IE51bWJlci5pc0Zpbml0ZShvcHRzLmZpdE1pblNjYWxlKSA/IE51bWJlcihvcHRzLmZpdE1pblNjYWxlKSA6IDAuODg7XG4gIGNvbnN0IGZpdE1heFNjYWxlUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0TWF4U2NhbGUpID8gTnVtYmVyKG9wdHMuZml0TWF4U2NhbGUpIDogMS4xNjtcbiAgY29uc3QgZml0TWluU2NhbGUgPSBNYXRoLm1heCgwLjcsIE1hdGgubWluKDEsIGZpdE1pblNjYWxlUmF3KSk7XG4gIGNvbnN0IGZpdE1heFNjYWxlID0gTWF0aC5tYXgoMSwgZml0TWF4U2NhbGVSYXcpO1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0VGFyZ2V0V2lkdGhSYXRpbylcbiAgICA/IE51bWJlcihvcHRzLmZpdFRhcmdldFdpZHRoUmF0aW8pXG4gICAgOiAwLjk0O1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvID0gTWF0aC5tYXgoMC43NSwgTWF0aC5taW4oMC45OSwgZml0VGFyZ2V0V2lkdGhSYXRpb1JhdykpO1xuICBjb25zdCBmaXRNaW5GaWxsUmF0aW9SYXcgPSBOdW1iZXIuaXNGaW5pdGUob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgPyBOdW1iZXIob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgOiAwLjk7XG4gIGNvbnN0IGZpdE1pbkZpbGxSYXRpbyA9IE1hdGgubWF4KDAuNiwgTWF0aC5taW4oZml0VGFyZ2V0V2lkdGhSYXRpbywgZml0TWluRmlsbFJhdGlvUmF3KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiAhIW9wdHMuZW5hYmxlZCxcblxyXG4gICAgbWluR2FwUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pbkdhcFB4KSA/IE51bWJlcihvcHRzLm1pbkdhcFB4KSA6IDgsXHJcbiAgICBwYWRkaW5nVG9wUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnBhZGRpbmdUb3BQeCkgPyBOdW1iZXIob3B0cy5wYWRkaW5nVG9wUHgpIDogMCxcclxuICAgIHBhZGRpbmdCb3R0b21QeDogTnVtYmVyLmlzRmluaXRlKG9wdHMucGFkZGluZ0JvdHRvbVB4KSA/IE51bWJlcihvcHRzLnBhZGRpbmdCb3R0b21QeCkgOiAxMixcclxuICAgIG1heEdhcFB4OiBOdW1iZXIuaXNGaW5pdGUob3B0cy5tYXhHYXBQeCkgPyBOdW1iZXIob3B0cy5tYXhHYXBQeCkgOiAyMixcclxuXHJcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogb3B0cy5vbmx5Rml4ZWRTZWN0aW9ucyAhPT0gZmFsc2UsXHJcbiAgICBvbmx5V2hlblJlb3JkZXJlZDogb3B0cy5vbmx5V2hlblJlb3JkZXJlZCAhPT0gZmFsc2UsXHJcblxyXG4gICAgcm93VG9sUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnJvd1RvbFB4KSA/IE51bWJlcihvcHRzLnJvd1RvbFB4KSA6IDI4LFxyXG5cclxuICAgIHR3b0NvbFNwcmVhZFJhdGlvOiBOdW1iZXIuaXNGaW5pdGUob3B0cy50d29Db2xTcHJlYWRSYXRpbykgPyBOdW1iZXIob3B0cy50d29Db2xTcHJlYWRSYXRpbykgOiAwLjE4LFxyXG4gICAgbWluUGVyQ29sdW1uMjogTnVtYmVyLmlzRmluaXRlKG9wdHMubWluUGVyQ29sdW1uMikgPyBOdW1iZXIob3B0cy5taW5QZXJDb2x1bW4yKSA6IDIsXHJcblxuICAgIHRocmVlQ29sU3ByZWFkUmF0aW86IE51bWJlci5pc0Zpbml0ZShvcHRzLnRocmVlQ29sU3ByZWFkUmF0aW8pID8gTnVtYmVyKG9wdHMudGhyZWVDb2xTcHJlYWRSYXRpbykgOiAwLjIyLFxuICAgIG1pblBlckNvbHVtbjM6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pblBlckNvbHVtbjMpID8gTnVtYmVyKG9wdHMubWluUGVyQ29sdW1uMykgOiAyLFxuXG4gICAgZ2FwU2NhbGU6IE51bWJlci5pc0Zpbml0ZShvcHRzLmdhcFNjYWxlKSA/IE51bWJlcihvcHRzLmdhcFNjYWxlKSA6IDAuNixcbiAgICBmaXRNaW5TY2FsZSxcbiAgICBmaXRNYXhTY2FsZSxcbiAgICBmaXRUYXJnZXRXaWR0aFJhdGlvLFxuICAgIGZpdE1pbkZpbGxSYXRpbyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVDb25maWciLCJvcHRzIiwiZml0TWluU2NhbGVSYXciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGVSYXciLCJmaXRNYXhTY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmaXRUYXJnZXRXaWR0aFJhdGlvUmF3IiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpb1JhdyIsImZpdE1pbkZpbGxSYXRpbyIsImVuYWJsZWQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm1heEdhcFB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJnYXBTY2FsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/config.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts":
/*!******************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/dom.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsDomHelpersBlock: () => (/* binding */ jsDomHelpersBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/dom.ts\nfunction jsDomHelpersBlock() {\n    return '\\n  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }\\n\\n  function isMobile(){\\n    return (document.documentElement.clientWidth || 0) <= 767;\\n  }\\n\\n  function getObjNodes(sec){\\n    if(!sec) return [];\\n    var nodes = [];\\n    var content = sec.querySelector(\".sec-content\");\\n    var bleed = sec.querySelector(\".sec-bleed\");\\n\\n    if (content) nodes = nodes.concat(Array.from(content.querySelectorAll(\".objeto\")));\\n    if (bleed) nodes = nodes.concat(Array.from(bleed.querySelectorAll(\".objeto\")));\\n\\n    // Fallback: algunos elementos exportados pueden no traer clase \".objeto\"\\n    // pero s\\xed estar posicionados como objetos absolutos.\\n    function collectAbsoluteCandidates(root){\\n      if (!root) return [];\\n      return Array.from(root.querySelectorAll(\"*\")).filter(function(el){\\n        if (!el) return false;\\n        var cs = getComputedStyle(el);\\n        var pos = (cs.position || \"\").toLowerCase();\\n        if (pos !== \"absolute\") return false;\\n\\n        var rr = el.getBoundingClientRect();\\n        if (!rr || rr.width < 1 || rr.height < 1) return false;\\n\\n        // Evitar ruido estructural del layout de secci\\xf3n\\n        if (el.classList && (\\n          el.classList.contains(\"sec\") ||\\n          el.classList.contains(\"sec-zoom\") ||\\n          el.classList.contains(\"sec-bg\") ||\\n          el.classList.contains(\"sec-content\") ||\\n          el.classList.contains(\"sec-bleed\")\\n        )) return false;\\n\\n        // Si ya est\\xe1 dentro de un \".objeto\", no lo contamos aparte.\\n        var p = el.parentElement;\\n        while (p){\\n          if (p.classList && p.classList.contains(\"objeto\")) return false;\\n          p = p.parentElement;\\n        }\\n        return true;\\n      });\\n    }\\n\\n    nodes = nodes.concat(collectAbsoluteCandidates(content));\\n    nodes = nodes.concat(collectAbsoluteCandidates(bleed));\\n\\n    // Deduplicar preservando orden de aparici\\xf3n.\\n    var seen = new Set();\\n    return nodes.filter(function(n){\\n      if (seen.has(n)) return false;\\n      seen.add(n);\\n      return true;\\n    });\\n  }\\n\\n  function relRect(el, root){\\n    var r = el.getBoundingClientRect();\\n    var rr = root.getBoundingClientRect();\\n    return {\\n      top: r.top - rr.top,\\n      left: r.left - rr.left,\\n      width: r.width,\\n      height: r.height\\n    };\\n  }\\n\\n  function percentile(sortedArr, p){\\n    if (!sortedArr.length) return 0;\\n    var idx = Math.floor(sortedArr.length * p);\\n    idx = Math.max(0, Math.min(sortedArr.length - 1, idx));\\n    return sortedArr[idx];\\n  }\\n\\n  function cx(it){ return it.left + (it.width || 0) / 2; }\\n\\n  // -------------------------\\n  // ✅ CLUSTERS POR SOLAPE\\n  // -------------------------\\n  function rectsOverlap(a, b, tol){\\n    tol = tol || 0;\\n    return !(\\n      (a.left + a.width) < (b.left + tol) ||\\n      (b.left + b.width) < (a.left + tol) ||\\n      (a.top + a.height) < (b.top + tol) ||\\n      (b.top + b.height) < (a.top + tol)\\n    );\\n  }\\n\\n  function horizontalOverlapPx(a, b){\\n    var l = Math.max(a.left, b.left);\\n    var r = Math.min(a.left + a.width, b.left + b.width);\\n    return Math.max(0, r - l);\\n  }\\n\\n  function verticalGapPx(a, b){\\n    var topAfter = Math.max(a.top, b.top);\\n    var bottomBefore = Math.min(a.top + a.height, b.top + b.height);\\n    return topAfter - bottomBefore;\\n  }\\n\\n  function buildOverlapClusters(items){\\n    var n = items.length;\\n    var parent = new Array(n);\\n    for (var i=0;i<n;i++) parent[i] = i;\\n\\n    function find(x){\\n      while(parent[x] !== x){\\n        parent[x] = parent[parent[x]];\\n        x = parent[x];\\n      }\\n      return x;\\n    }\\n\\n    function union(a,b){\\n      var ra = find(a), rb = find(b);\\n      if (ra !== rb) parent[rb] = ra;\\n    }\\n\\n    // tol peque\\xf1o para considerar “encimado” aunque sea apenas\\n    var TOL = 1;\\n    // uni\\xf3n por cercan\\xeda vertical dentro de una misma \"columna visual\"\\n    var PROX_Y = 34;\\n    var MIN_H_OVERLAP_RATIO = 0.35;\\n    var MAX_CX_DIST = 42;\\n\\n    for (var i=0;i<n;i++){\\n      for (var j=i+1;j<n;j++){\\n        var a = items[i], b = items[j];\\n\\n    var aIso = (a.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\\n    var bIso = (b.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\\n\\n    // si cualquiera es isolated, no lo unimos con nadie\\n    if (aIso || bIso) continue;\\n\\n    // opcional: cluster-id manual (si quer\\xe9s agrupar solo algunos)\\n    var aKey = a.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\\n    var bKey = b.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\\n    if (aKey && bKey && aKey !== bKey) continue;\\n\\n    var aIsText = (a.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n    var bIsText = (b.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n    var involvesText = aIsText || bIsText;\\n    var cxDist = Math.abs(cx(a) - cx(b));\\n\\n    if (rectsOverlap(a, b, TOL)) {\\n      // Evita pegar columnas distintas por cajas de texto anchas.\\n      // Si hay texto, exigimos cercania por eje X del centro.\\n      if (!involvesText || cxDist <= MAX_CX_DIST) union(i,j);\\n      continue;\\n    }\\n\\n    // Si no se solapan pero est\\xe1n muy cerca en vertical y comparten columna,\\n    // tambi\\xe9n los unimos para mantener bloque (ej: icono + texto debajo).\\n    var hov = horizontalOverlapPx(a, b);\\n    var minW = Math.max(1, Math.min(a.width || 0, b.width || 0));\\n    var hovRatio = hov / minW;\\n    // Con texto, usamos criterio m\\xe1s estricto para no cruzar columnas.\\n    var sameVisualColumn = involvesText\\n      ? (cxDist <= MAX_CX_DIST)\\n      : ((hovRatio >= MIN_H_OVERLAP_RATIO) || (cxDist <= MAX_CX_DIST));\\n    var vGap = verticalGapPx(a, b);\\n    var nearVertical = vGap >= 0 && vGap <= PROX_Y;\\n    var bothText = aIsText && bIsText;\\n\\n    // Evitar \"pegar\" p\\xe1rrafos entre s\\xed solo por cercan\\xeda vertical.\\n    // La uni\\xf3n por proximidad queda para pares mixtos (texto + no-texto),\\n    // manteniendo el caso icono/forma + texto.\\n    if (sameVisualColumn && nearVertical && !bothText) union(i,j);\\n\\n      }\\n    }\\n\\n    var map = {};\\n    for (var k=0;k<n;k++){\\n      var r = find(k);\\n      if (!map[r]) map[r] = [];\\n      map[r].push(items[k]);\\n    }\\n\\n    var clusters = [];\\n    Object.keys(map).forEach(function(key){\\n      var arr = map[key];\\n\\n      var minTop = Infinity, minLeft = Infinity, maxR = -Infinity, maxB = -Infinity;\\n      for (var i=0;i<arr.length;i++){\\n        var it = arr[i];\\n        minTop = Math.min(minTop, it.top);\\n        minLeft = Math.min(minLeft, it.left);\\n        maxR = Math.max(maxR, it.left + it.width);\\n        maxB = Math.max(maxB, it.top + it.height);\\n      }\\n\\n      // offsets relativos para preservar el solape dentro del cluster\\n      for (var i=0;i<arr.length;i++){\\n        arr[i]._relTop = arr[i].top - minTop;\\n        arr[i]._relLeft = arr[i].left - minLeft;\\n      }\\n\\n      clusters.push({\\n        items: arr,\\n        top: minTop,\\n        left: minLeft,\\n        width: maxR - minLeft,\\n        height: maxB - minTop,\\n        cx: (minLeft + maxR) / 2\\n      });\\n    });\\n\\n    // orden estable por top para consistencia\\n    clusters.sort(function(a,b){ return a.top - b.top; });\\n\\n    return clusters;\\n  }\\n\\n  // ✅ “entra” si ning\\xfan cluster se sale horizontalmente del contenedor content\\n  function clustersFitInMobile(clusters, rootEl){\\n    var rootW = rootEl.getBoundingClientRect().width || 0;\\n    if (!rootW) return true;\\n\\n    for (var i=0;i<clusters.length;i++){\\n      var c = clusters[i];\\n      if (c.left < -1) return false;\\n      if ((c.left + c.width) > (rootW + 1)) return false;\\n    }\\n    return true;\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwrQ0FBK0M7QUFDeEMsU0FBU0E7SUFDZCxPQUFPLHkvT0F3T1BDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcZG9tLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBqc0RvbUhlbHBlcnNCbG9jaygpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgXHJcbiAgZnVuY3Rpb24gY2xhbXAobixhLGIpeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYixuKSk7IH1cclxuXHJcbiAgZnVuY3Rpb24gaXNNb2JpbGUoKXtcclxuICAgIHJldHVybiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDApIDw9IDc2NztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldE9iak5vZGVzKHNlYyl7XG4gICAgaWYoIXNlYykgcmV0dXJuIFtdO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XG4gICAgdmFyIGJsZWVkID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWJsZWVkXCIpO1xuXG4gICAgaWYgKGNvbnRlbnQpIG5vZGVzID0gbm9kZXMuY29uY2F0KEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKSkpO1xuICAgIGlmIChibGVlZCkgbm9kZXMgPSBub2Rlcy5jb25jYXQoQXJyYXkuZnJvbShibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKSkpO1xuXG4gICAgLy8gRmFsbGJhY2s6IGFsZ3Vub3MgZWxlbWVudG9zIGV4cG9ydGFkb3MgcHVlZGVuIG5vIHRyYWVyIGNsYXNlIFwiLm9iamV0b1wiXG4gICAgLy8gcGVybyBzw60gZXN0YXIgcG9zaWNpb25hZG9zIGNvbW8gb2JqZXRvcyBhYnNvbHV0b3MuXG4gICAgZnVuY3Rpb24gY29sbGVjdEFic29sdXRlQ2FuZGlkYXRlcyhyb290KXtcbiAgICAgIGlmICghcm9vdCkgcmV0dXJuIFtdO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgdmFyIHBvcyA9IChjcy5wb3NpdGlvbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocG9zICE9PSBcImFic29sdXRlXCIpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgcnIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFyciB8fCByci53aWR0aCA8IDEgfHwgcnIuaGVpZ2h0IDwgMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIEV2aXRhciBydWlkbyBlc3RydWN0dXJhbCBkZWwgbGF5b3V0IGRlIHNlY2Npw7NuXG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgKFxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlY1wiKSB8fFxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy16b29tXCIpIHx8XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VjLWJnXCIpIHx8XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VjLWNvbnRlbnRcIikgfHxcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWMtYmxlZWRcIilcbiAgICAgICAgKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFNpIHlhIGVzdMOhIGRlbnRybyBkZSB1biBcIi5vYmpldG9cIiwgbm8gbG8gY29udGFtb3MgYXBhcnRlLlxuICAgICAgICB2YXIgcCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChwKXtcbiAgICAgICAgICBpZiAocC5jbGFzc0xpc3QgJiYgcC5jbGFzc0xpc3QuY29udGFpbnMoXCJvYmpldG9cIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBwID0gcC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY29sbGVjdEFic29sdXRlQ2FuZGlkYXRlcyhjb250ZW50KSk7XG4gICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY29sbGVjdEFic29sdXRlQ2FuZGlkYXRlcyhibGVlZCkpO1xuXG4gICAgLy8gRGVkdXBsaWNhciBwcmVzZXJ2YW5kbyBvcmRlbiBkZSBhcGFyaWNpw7NuLlxuICAgIHZhciBzZWVuID0gbmV3IFNldCgpO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoZnVuY3Rpb24obil7XG4gICAgICBpZiAoc2Vlbi5oYXMobikpIHJldHVybiBmYWxzZTtcbiAgICAgIHNlZW4uYWRkKG4pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxyXG4gIGZ1bmN0aW9uIHJlbFJlY3QoZWwsIHJvb3Qpe1xyXG4gICAgdmFyIHIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciByciA9IHJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IHIudG9wIC0gcnIudG9wLFxyXG4gICAgICBsZWZ0OiByLmxlZnQgLSByci5sZWZ0LFxyXG4gICAgICB3aWR0aDogci53aWR0aCxcclxuICAgICAgaGVpZ2h0OiByLmhlaWdodFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlcmNlbnRpbGUoc29ydGVkQXJyLCBwKXtcclxuICAgIGlmICghc29ydGVkQXJyLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihzb3J0ZWRBcnIubGVuZ3RoICogcCk7XHJcbiAgICBpZHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzb3J0ZWRBcnIubGVuZ3RoIC0gMSwgaWR4KSk7XHJcbiAgICByZXR1cm4gc29ydGVkQXJyW2lkeF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjeChpdCl7IHJldHVybiBpdC5sZWZ0ICsgKGl0LndpZHRoIHx8IDApIC8gMjsgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8g4pyFIENMVVNURVJTIFBPUiBTT0xBUEVcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgZnVuY3Rpb24gcmVjdHNPdmVybGFwKGEsIGIsIHRvbCl7XG4gICAgdG9sID0gdG9sIHx8IDA7XG4gICAgcmV0dXJuICEoXG4gICAgICAoYS5sZWZ0ICsgYS53aWR0aCkgPCAoYi5sZWZ0ICsgdG9sKSB8fFxuICAgICAgKGIubGVmdCArIGIud2lkdGgpIDwgKGEubGVmdCArIHRvbCkgfHxcclxuICAgICAgKGEudG9wICsgYS5oZWlnaHQpIDwgKGIudG9wICsgdG9sKSB8fFxyXG4gICAgICAoYi50b3AgKyBiLmhlaWdodCkgPCAoYS50b3AgKyB0b2wpXHJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaG9yaXpvbnRhbE92ZXJsYXBQeChhLCBiKXtcbiAgICB2YXIgbCA9IE1hdGgubWF4KGEubGVmdCwgYi5sZWZ0KTtcbiAgICB2YXIgciA9IE1hdGgubWluKGEubGVmdCArIGEud2lkdGgsIGIubGVmdCArIGIud2lkdGgpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCByIC0gbCk7XG4gIH1cblxuICBmdW5jdGlvbiB2ZXJ0aWNhbEdhcFB4KGEsIGIpe1xuICAgIHZhciB0b3BBZnRlciA9IE1hdGgubWF4KGEudG9wLCBiLnRvcCk7XG4gICAgdmFyIGJvdHRvbUJlZm9yZSA9IE1hdGgubWluKGEudG9wICsgYS5oZWlnaHQsIGIudG9wICsgYi5oZWlnaHQpO1xuICAgIHJldHVybiB0b3BBZnRlciAtIGJvdHRvbUJlZm9yZTtcbiAgfVxuXHJcbiAgZnVuY3Rpb24gYnVpbGRPdmVybGFwQ2x1c3RlcnMoaXRlbXMpe1xyXG4gICAgdmFyIG4gPSBpdGVtcy5sZW5ndGg7XHJcbiAgICB2YXIgcGFyZW50ID0gbmV3IEFycmF5KG4pO1xyXG4gICAgZm9yICh2YXIgaT0wO2k8bjtpKyspIHBhcmVudFtpXSA9IGk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZCh4KXtcclxuICAgICAgd2hpbGUocGFyZW50W3hdICE9PSB4KXtcclxuICAgICAgICBwYXJlbnRbeF0gPSBwYXJlbnRbcGFyZW50W3hdXTtcclxuICAgICAgICB4ID0gcGFyZW50W3hdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuaW9uKGEsYil7XHJcbiAgICAgIHZhciByYSA9IGZpbmQoYSksIHJiID0gZmluZChiKTtcclxuICAgICAgaWYgKHJhICE9PSByYikgcGFyZW50W3JiXSA9IHJhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvbCBwZXF1ZcOxbyBwYXJhIGNvbnNpZGVyYXIg4oCcZW5jaW1hZG/igJ0gYXVucXVlIHNlYSBhcGVuYXNcbiAgICB2YXIgVE9MID0gMTtcbiAgICAvLyB1bmnDs24gcG9yIGNlcmNhbsOtYSB2ZXJ0aWNhbCBkZW50cm8gZGUgdW5hIG1pc21hIFwiY29sdW1uYSB2aXN1YWxcIlxuICAgIHZhciBQUk9YX1kgPSAzNDtcbiAgICB2YXIgTUlOX0hfT1ZFUkxBUF9SQVRJTyA9IDAuMzU7XG4gICAgdmFyIE1BWF9DWF9ESVNUID0gNDI7XG5cclxuICAgIGZvciAodmFyIGk9MDtpPG47aSsrKXtcbiAgICAgIGZvciAodmFyIGo9aSsxO2o8bjtqKyspe1xuICAgICAgICB2YXIgYSA9IGl0ZW1zW2ldLCBiID0gaXRlbXNbal07XG5cbiAgICB2YXIgYUlzbyA9IChhLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiKSA9PT0gXCJpc29sYXRlZFwiO1xuICAgIHZhciBiSXNvID0gKGIubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyXCIpIHx8IFwiXCIpID09PSBcImlzb2xhdGVkXCI7XG5cclxuICAgIC8vIHNpIGN1YWxxdWllcmEgZXMgaXNvbGF0ZWQsIG5vIGxvIHVuaW1vcyBjb24gbmFkaWVcclxuICAgIGlmIChhSXNvIHx8IGJJc28pIGNvbnRpbnVlO1xyXG5cclxuICAgIC8vIG9wY2lvbmFsOiBjbHVzdGVyLWlkIG1hbnVhbCAoc2kgcXVlcsOpcyBhZ3J1cGFyIHNvbG8gYWxndW5vcylcclxuICAgIHZhciBhS2V5ID0gYS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXItaWRcIikgfHwgXCJcIjtcbiAgICB2YXIgYktleSA9IGIubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyLWlkXCIpIHx8IFwiXCI7XG4gICAgaWYgKGFLZXkgJiYgYktleSAmJiBhS2V5ICE9PSBiS2V5KSBjb250aW51ZTtcblxuICAgIHZhciBhSXNUZXh0ID0gKGEubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICB2YXIgYklzVGV4dCA9IChiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgdmFyIGludm9sdmVzVGV4dCA9IGFJc1RleHQgfHwgYklzVGV4dDtcbiAgICB2YXIgY3hEaXN0ID0gTWF0aC5hYnMoY3goYSkgLSBjeChiKSk7XG5cbiAgICBpZiAocmVjdHNPdmVybGFwKGEsIGIsIFRPTCkpIHtcbiAgICAgIC8vIEV2aXRhIHBlZ2FyIGNvbHVtbmFzIGRpc3RpbnRhcyBwb3IgY2FqYXMgZGUgdGV4dG8gYW5jaGFzLlxuICAgICAgLy8gU2kgaGF5IHRleHRvLCBleGlnaW1vcyBjZXJjYW5pYSBwb3IgZWplIFggZGVsIGNlbnRyby5cbiAgICAgIGlmICghaW52b2x2ZXNUZXh0IHx8IGN4RGlzdCA8PSBNQVhfQ1hfRElTVCkgdW5pb24oaSxqKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFNpIG5vIHNlIHNvbGFwYW4gcGVybyBlc3TDoW4gbXV5IGNlcmNhIGVuIHZlcnRpY2FsIHkgY29tcGFydGVuIGNvbHVtbmEsXG4gICAgLy8gdGFtYmnDqW4gbG9zIHVuaW1vcyBwYXJhIG1hbnRlbmVyIGJsb3F1ZSAoZWo6IGljb25vICsgdGV4dG8gZGViYWpvKS5cbiAgICB2YXIgaG92ID0gaG9yaXpvbnRhbE92ZXJsYXBQeChhLCBiKTtcbiAgICB2YXIgbWluVyA9IE1hdGgubWF4KDEsIE1hdGgubWluKGEud2lkdGggfHwgMCwgYi53aWR0aCB8fCAwKSk7XG4gICAgdmFyIGhvdlJhdGlvID0gaG92IC8gbWluVztcbiAgICAvLyBDb24gdGV4dG8sIHVzYW1vcyBjcml0ZXJpbyBtw6FzIGVzdHJpY3RvIHBhcmEgbm8gY3J1emFyIGNvbHVtbmFzLlxuICAgIHZhciBzYW1lVmlzdWFsQ29sdW1uID0gaW52b2x2ZXNUZXh0XG4gICAgICA/IChjeERpc3QgPD0gTUFYX0NYX0RJU1QpXG4gICAgICA6ICgoaG92UmF0aW8gPj0gTUlOX0hfT1ZFUkxBUF9SQVRJTykgfHwgKGN4RGlzdCA8PSBNQVhfQ1hfRElTVCkpO1xuICAgIHZhciB2R2FwID0gdmVydGljYWxHYXBQeChhLCBiKTtcbiAgICB2YXIgbmVhclZlcnRpY2FsID0gdkdhcCA+PSAwICYmIHZHYXAgPD0gUFJPWF9ZO1xuICAgIHZhciBib3RoVGV4dCA9IGFJc1RleHQgJiYgYklzVGV4dDtcblxuICAgIC8vIEV2aXRhciBcInBlZ2FyXCIgcMOhcnJhZm9zIGVudHJlIHPDrSBzb2xvIHBvciBjZXJjYW7DrWEgdmVydGljYWwuXG4gICAgLy8gTGEgdW5pw7NuIHBvciBwcm94aW1pZGFkIHF1ZWRhIHBhcmEgcGFyZXMgbWl4dG9zICh0ZXh0byArIG5vLXRleHRvKSxcbiAgICAvLyBtYW50ZW5pZW5kbyBlbCBjYXNvIGljb25vL2Zvcm1hICsgdGV4dG8uXG4gICAgaWYgKHNhbWVWaXN1YWxDb2x1bW4gJiYgbmVhclZlcnRpY2FsICYmICFib3RoVGV4dCkgdW5pb24oaSxqKTtcblxuICAgICAgfVxuICAgIH1cblxyXG4gICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaz0wO2s8bjtrKyspe1xyXG4gICAgICB2YXIgciA9IGZpbmQoayk7XHJcbiAgICAgIGlmICghbWFwW3JdKSBtYXBbcl0gPSBbXTtcclxuICAgICAgbWFwW3JdLnB1c2goaXRlbXNba10pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbHVzdGVycyA9IFtdO1xyXG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBhcnIgPSBtYXBba2V5XTtcclxuXHJcbiAgICAgIHZhciBtaW5Ub3AgPSBJbmZpbml0eSwgbWluTGVmdCA9IEluZmluaXR5LCBtYXhSID0gLUluZmluaXR5LCBtYXhCID0gLUluZmluaXR5O1xyXG4gICAgICBmb3IgKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgdmFyIGl0ID0gYXJyW2ldO1xyXG4gICAgICAgIG1pblRvcCA9IE1hdGgubWluKG1pblRvcCwgaXQudG9wKTtcclxuICAgICAgICBtaW5MZWZ0ID0gTWF0aC5taW4obWluTGVmdCwgaXQubGVmdCk7XHJcbiAgICAgICAgbWF4UiA9IE1hdGgubWF4KG1heFIsIGl0LmxlZnQgKyBpdC53aWR0aCk7XHJcbiAgICAgICAgbWF4QiA9IE1hdGgubWF4KG1heEIsIGl0LnRvcCArIGl0LmhlaWdodCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG9mZnNldHMgcmVsYXRpdm9zIHBhcmEgcHJlc2VydmFyIGVsIHNvbGFwZSBkZW50cm8gZGVsIGNsdXN0ZXJcclxuICAgICAgZm9yICh2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGFycltpXS5fcmVsVG9wID0gYXJyW2ldLnRvcCAtIG1pblRvcDtcclxuICAgICAgICBhcnJbaV0uX3JlbExlZnQgPSBhcnJbaV0ubGVmdCAtIG1pbkxlZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNsdXN0ZXJzLnB1c2goe1xyXG4gICAgICAgIGl0ZW1zOiBhcnIsXHJcbiAgICAgICAgdG9wOiBtaW5Ub3AsXHJcbiAgICAgICAgbGVmdDogbWluTGVmdCxcclxuICAgICAgICB3aWR0aDogbWF4UiAtIG1pbkxlZnQsXHJcbiAgICAgICAgaGVpZ2h0OiBtYXhCIC0gbWluVG9wLFxyXG4gICAgICAgIGN4OiAobWluTGVmdCArIG1heFIpIC8gMlxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG9yZGVuIGVzdGFibGUgcG9yIHRvcCBwYXJhIGNvbnNpc3RlbmNpYVxyXG4gICAgY2x1c3RlcnMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xyXG4gIH1cclxuXHJcbiAgLy8g4pyFIOKAnGVudHJh4oCdIHNpIG5pbmfDum4gY2x1c3RlciBzZSBzYWxlIGhvcml6b250YWxtZW50ZSBkZWwgY29udGVuZWRvciBjb250ZW50XHJcbiAgZnVuY3Rpb24gY2x1c3RlcnNGaXRJbk1vYmlsZShjbHVzdGVycywgcm9vdEVsKXtcclxuICAgIHZhciByb290VyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCAwO1xyXG4gICAgaWYgKCFyb290VykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgZm9yICh2YXIgaT0wO2k8Y2x1c3RlcnMubGVuZ3RoO2krKyl7XHJcbiAgICAgIHZhciBjID0gY2x1c3RlcnNbaV07XHJcbiAgICAgIGlmIChjLmxlZnQgPCAtMSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoKGMubGVmdCArIGMud2lkdGgpID4gKHJvb3RXICsgMSkpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzRG9tSGVscGVyc0Jsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/fitScale.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsFitScaleBlock: () => (/* binding */ jsFitScaleBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/fitScale.ts\nfunction jsFitScaleBlock() {\n    return '\\n  function ensureFitScaleBaseline(el){\\n    if (!el) return;\\n    if (!el.hasAttribute(\"data-msl-fit-orig-transform\")) {\\n      el.setAttribute(\"data-msl-fit-orig-transform\", el.style.transform || \"\");\\n    }\\n    if (!el.hasAttribute(\"data-msl-fit-orig-origin\")) {\\n      el.setAttribute(\"data-msl-fit-orig-origin\", el.style.transformOrigin || \"\");\\n    }\\n  }\\n\\n  function restoreFitScaleBaseline(el){\\n    if (!el) return;\\n    ensureFitScaleBaseline(el);\\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\\n    var baseOrigin = el.getAttribute(\"data-msl-fit-orig-origin\") || \"\";\\n    el.style.transform = baseTransform;\\n    if (baseOrigin) el.style.transformOrigin = baseOrigin;\\n    else el.style.removeProperty(\"transform-origin\");\\n  }\\n\\n  function applyElementFitScale(el, scale){\\n    if (!el) return;\\n    ensureFitScaleBaseline(el);\\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\\n    var next = baseTransform ? (baseTransform + \" scale(\" + scale + \")\") : (\"scale(\" + scale + \")\");\\n    el.style.transform = next;\\n    el.style.transformOrigin = \"top center\";\\n  }\\n\\n  function resetSectionFitScale(_sec, content, bleed){\\n    restoreFitScaleBaseline(content);\\n    restoreFitScaleBaseline(bleed);\\n  }\\n\\n  function computeSectionBounds(sec, nodes){\\n    if (!sec || !nodes || !nodes.length) return null;\\n    var minLeft = Infinity;\\n    var minTop = Infinity;\\n    var maxRight = -Infinity;\\n    var maxBottom = -Infinity;\\n    var valid = 0;\\n\\n    for (var i=0; i<nodes.length; i++){\\n      var node = nodes[i];\\n      if (!node) continue;\\n      var rr = relRect(node, sec);\\n      var w = Number(rr.width || 0);\\n      var h = Number(rr.height || 0);\\n      if (w <= 0.5 && h <= 0.5) continue;\\n\\n      var l = Number(rr.left || 0);\\n      var t = Number(rr.top || 0);\\n      var r = l + Math.max(0, w);\\n      var b = t + Math.max(0, h);\\n\\n      if (!isFinite(l) || !isFinite(t) || !isFinite(r) || !isFinite(b)) continue;\\n\\n      minLeft = Math.min(minLeft, l);\\n      minTop = Math.min(minTop, t);\\n      maxRight = Math.max(maxRight, r);\\n      maxBottom = Math.max(maxBottom, b);\\n      valid++;\\n    }\\n\\n    if (!valid || !isFinite(minLeft) || !isFinite(maxRight) || !isFinite(minTop) || !isFinite(maxBottom)) {\\n      return null;\\n    }\\n\\n    return {\\n      minLeft: minLeft,\\n      minTop: minTop,\\n      maxRight: maxRight,\\n      maxBottom: maxBottom,\\n      width: Math.max(0, maxRight - minLeft),\\n      height: Math.max(0, maxBottom - minTop),\\n      count: valid\\n    };\\n  }\\n\\n  function computeFitScale(sec, bounds, secModo, CFG){\\n    if (!sec || !bounds) return 1;\\n    var secRect = sec.getBoundingClientRect();\\n    var secW = Number(secRect.width || 0);\\n    var secH = Number(secRect.height || 0);\\n    if (secW <= 1) {\\n      return {\\n        scale: 1,\\n        debug: null\\n      };\\n    }\\n\\n    var targetCoverage = clamp(Number(CFG.FIT_TARGET_WIDTH_RATIO || 0.94), 0.75, 0.99);\\n    var minFillForUpscale = clamp(Number(CFG.FIT_MIN_FILL_RATIO || 0.9), 0.6, targetCoverage);\\n    var minScale = clamp(Number(CFG.FIT_MIN_SCALE || 0.88), 0.7, 1);\\n    var maxScale = Math.max(1, Number(CFG.FIT_MAX_SCALE || 1.16));\\n\\n    var contentW = Math.max(1, Number(bounds.width || 0));\\n    var coverage = contentW / secW;\\n\\n    var scale = 1;\\n    var debug = {\\n      secW: secW,\\n      secH: secH,\\n      targetCoverage: targetCoverage,\\n      minFillForUpscale: minFillForUpscale,\\n      minScale: minScale,\\n      maxScale: maxScale,\\n      coverage: coverage,\\n      initialScale: 1,\\n      maxScaleByWidth: null,\\n      maxScaleByHeight: null,\\n      scaleAfterWidthClamp: null,\\n      scaleAfterHeightClamp: null,\\n      tinyShrinkProtected: false,\\n      pantallaDownscaleBlocked: false\\n    };\\n    if (coverage < minFillForUpscale) {\\n      scale = targetCoverage / Math.max(0.01, coverage);\\n    }\\n    debug.initialScale = scale;\\n\\n    if (scale >= 1) scale = Math.min(scale, maxScale);\\n    else scale = Math.max(scale, minScale);\\n\\n    // L\\xedmite horizontal duro por centro visual.\\n    var centerX = secW / 2;\\n    var distLeft = Math.max(0, centerX - Number(bounds.minLeft || 0));\\n    var distRight = Math.max(0, Number(bounds.maxRight || 0) - centerX);\\n    var maxScaleByWidth = Infinity;\\n    if (distLeft > 0.5) {\\n      maxScaleByWidth = Math.min(maxScaleByWidth, centerX / distLeft);\\n    }\\n    if (distRight > 0.5) {\\n      maxScaleByWidth = Math.min(maxScaleByWidth, (secW - centerX) / distRight);\\n    }\\n    if (isFinite(maxScaleByWidth) && maxScaleByWidth > 0) {\\n      scale = Math.min(scale, maxScaleByWidth);\\n      debug.maxScaleByWidth = maxScaleByWidth;\\n    }\\n    debug.scaleAfterWidthClamp = scale;\\n\\n    if (secModo === \"pantalla\" && scale < 1 && scale > 0.94) {\\n      // Avoid shrinking \"pantalla\" for tiny overflows; preserve visual impact.\\n      scale = 1;\\n      debug.tinyShrinkProtected = true;\\n    }\\n\\n    // En modo pantalla no dejamos que el contenido se recorte por altura.\\n    if (secModo === \"pantalla\" && secH > 1) {\\n      var maxBottom = Number(bounds.maxBottom || 0);\\n      if (maxBottom > 1) {\\n        var maxScaleByHeight = secH / maxBottom;\\n        if (isFinite(maxScaleByHeight) && maxScaleByHeight > 0) {\\n          scale = Math.min(scale, maxScaleByHeight);\\n          debug.maxScaleByHeight = maxScaleByHeight;\\n        }\\n      }\\n    }\\n    debug.scaleAfterHeightClamp = scale;\\n\\n    if (secModo === \"pantalla\" && scale < 1) {\\n      // Pantalla sections already have their own viewport-fit logic.\\n      // Avoid additional downscale here to keep hero text readable.\\n      scale = 1;\\n      debug.pantallaDownscaleBlocked = true;\\n    }\\n\\n    if (!isFinite(scale) || scale <= 0) scale = 1;\\n    if (Math.abs(scale - 1) < 0.02) scale = 1;\\n    return {\\n      scale: scale,\\n      debug: debug\\n    };\\n  }\\n\\n  function applySectionFitScale(sec, content, bleed, nodesAll, secModo, CFG, meta, opts){\\n    if (!sec || !content) {\\n      return { scale: 1, neededHeight: 0, bounds: null };\\n    }\\n\\n    ensureFitScaleBaseline(content);\\n    ensureFitScaleBaseline(bleed);\\n    var preserveBottomGap = 0;\\n    if (opts && Number.isFinite(opts.preserveBottomGap)) {\\n      preserveBottomGap = Math.max(0, Number(opts.preserveBottomGap));\\n    }\\n\\n    var fitNodes = (nodesAll || []).filter(function(node){\\n      if (!node) return false;\\n      var fitMode = (node.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\\n      if (fitMode === \"ignore\") return false;\\n      if (node.closest && node.closest(\".sec-bleed\")) return false;\\n      return true;\\n    });\\n\\n    var bounds = computeSectionBounds(sec, fitNodes);\\n    if (!bounds) {\\n      bounds = computeSectionBounds(sec, nodesAll || []);\\n    }\\n    if (!bounds) {\\n      restoreFitScaleBaseline(content);\\n      restoreFitScaleBaseline(bleed);\\n      sec.setAttribute(\"data-msl-fit-scale\", \"1\");\\n      return { scale: 1, neededHeight: 0, bounds: null };\\n    }\\n\\n    var fitResult = computeFitScale(sec, bounds, secModo, CFG);\\n    var scale = (fitResult && Number.isFinite(fitResult.scale)) ? fitResult.scale : 1;\\n    var fitDebug = fitResult && fitResult.debug ? fitResult.debug : null;\\n    applyElementFitScale(content, scale);\\n    applyElementFitScale(bleed, scale);\\n\\n    var neededHeight = 0;\\n    if (secModo !== \"pantalla\") {\\n      var maxBottomWithGap = Number(bounds.maxBottom || 0) + preserveBottomGap;\\n      neededHeight = Math.ceil(maxBottomWithGap * scale + (CFG.PAD_BOT || 0));\\n    }\\n\\n    if (secModo === \"pantalla\") {\\n      var secRectNow = sec.getBoundingClientRect();\\n      var vv = window.visualViewport;\\n      var viewportW = (vv && vv.width) ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 0);\\n      var viewportH = (vv && vv.height) ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 0);\\n      var ua = navigator.userAgent || \"\";\\n      var mobileUA = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);\\n      var touchPoints = Number(navigator.maxTouchPoints || 0);\\n      var coarsePointer = false;\\n      if (window.matchMedia) {\\n        try { coarsePointer = window.matchMedia(\"(pointer: coarse)\").matches; } catch(_e) {}\\n      }\\n      var mobileViewport = viewportW <= 767;\\n      var desktopMobilePreview = mobileViewport && !mobileUA;\\n\\n      var boundsAll = computeSectionBounds(sec, nodesAll || []);\\n      var totalNodes = (nodesAll || []).length;\\n      var fitNodesCount = fitNodes.length;\\n      var textAll = 0;\\n      var textFit = 0;\\n      var ignoredBleed = 0;\\n      var ignoredExplicit = 0;\\n      var dominantText = null;\\n      var dominantTextH = -1;\\n      var elementRows = [];\\n\\n      for (var ni=0; ni<totalNodes; ni++){\\n        var nodeAll = nodesAll[ni];\\n        if (!nodeAll) continue;\\n\\n        var fitModeAll = (nodeAll.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\\n        if (fitModeAll === \"ignore\") ignoredExplicit++;\\n        if (nodeAll.closest && nodeAll.closest(\".sec-bleed\")) ignoredBleed++;\\n\\n        var rrNode = relRect(nodeAll, sec);\\n        var nodeW = Number(rrNode.width || 0);\\n        var nodeH = Number(rrNode.height || 0);\\n        var nodeTop = Number(rrNode.top || 0);\\n        var nodeBottom = nodeTop + nodeH;\\n        var isTextAll = (nodeAll.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n        if (isTextAll) textAll++;\\n\\n        if (nodeW > 0.5 || nodeH > 0.5) {\\n          var kindAll = isTextAll ? \"texto\" : String((nodeAll.tagName || \"\").toLowerCase());\\n          elementRows.push({\\n            kind: kindAll,\\n            width: nodeW,\\n            height: nodeH,\\n            top: nodeTop,\\n            bottom: nodeBottom,\\n            area: nodeW * nodeH,\\n            textSample: isTextAll\\n              ? ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 70)\\n              : \"\"\\n          });\\n        }\\n\\n        if (!isTextAll) continue;\\n        if (nodeH <= dominantTextH) continue;\\n        dominantTextH = nodeH;\\n        var csTxt = getComputedStyle(nodeAll);\\n        dominantText = {\\n          top: +nodeTop.toFixed(1),\\n          left: +Number(rrNode.left || 0).toFixed(1),\\n          width: +nodeW.toFixed(1),\\n          height: +nodeH.toFixed(1),\\n          bottom: +nodeBottom.toFixed(1),\\n          widthSecRatio: secRectNow.width > 1 ? +(nodeW / secRectNow.width).toFixed(3) : null,\\n          heightSecRatio: secRectNow.height > 1 ? +(nodeH / secRectNow.height).toFixed(3) : null,\\n          widthViewportRatio: viewportW > 1 ? +(nodeW / viewportW).toFixed(3) : null,\\n          heightViewportRatio: viewportH > 1 ? +(nodeH / viewportH).toFixed(3) : null,\\n          fontSize: csTxt.fontSize || \"\",\\n          lineHeight: csTxt.lineHeight || \"\",\\n          textAlign: csTxt.textAlign || \"\",\\n          transform: (nodeAll.style && nodeAll.style.transform) ? nodeAll.style.transform : \"\",\\n          textSample: ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 90)\\n        };\\n      }\\n\\n      for (var fi=0; fi<fitNodes.length; fi++){\\n        var fitNode = fitNodes[fi];\\n        if ((fitNode.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textFit++;\\n      }\\n\\n      var topElements = elementRows\\n        .sort(function(a,b){ return (b.area || 0) - (a.area || 0); })\\n        .slice(0, 6)\\n        .map(function(row){\\n          return {\\n            kind: row.kind,\\n            width: +Number(row.width || 0).toFixed(1),\\n            height: +Number(row.height || 0).toFixed(1),\\n            widthSecRatio: secRectNow.width > 1 ? +((row.width || 0) / secRectNow.width).toFixed(3) : null,\\n            heightSecRatio: secRectNow.height > 1 ? +((row.height || 0) / secRectNow.height).toFixed(3) : null,\\n            widthViewportRatio: viewportW > 1 ? +((row.width || 0) / viewportW).toFixed(3) : null,\\n            heightViewportRatio: viewportH > 1 ? +((row.height || 0) / viewportH).toFixed(3) : null,\\n            topSecRatio: secRectNow.height > 1 ? +((row.top || 0) / secRectNow.height).toFixed(3) : null,\\n            bottomSecRatio: secRectNow.height > 1 ? +((row.bottom || 0) / secRectNow.height).toFixed(3) : null,\\n            sample: row.textSample || \"\"\\n          };\\n        });\\n\\n      var coverageFit = bounds.width / Math.max(1, secRectNow.width || 0);\\n      var coverageAll = boundsAll ? (boundsAll.width / Math.max(1, secRectNow.width || 0)) : null;\\n\\n      var flatLines = [];\\n      flatLines.push(\\n        \"sec=\" + String(meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1)\\n        + \" viewport=\" + (+Number(viewportW || 0).toFixed(1)) + \"x\" + (+Number(viewportH || 0).toFixed(1))\\n        + \" sec=\" + (+Number(secRectNow.width || 0).toFixed(1)) + \"x\" + (+Number(secRectNow.height || 0).toFixed(1))\\n        + \" mobileViewport=\" + String(mobileViewport)\\n        + \" desktopMobilePreview=\" + String(desktopMobilePreview)\\n        + \" mobileUA=\" + String(mobileUA)\\n        + \" coarsePointer=\" + String(coarsePointer)\\n        + \" touchPoints=\" + String(touchPoints)\\n      );\\n      flatLines.push(\\n        \"fit scale=\" + (+Number(scale || 1).toFixed(3))\\n        + \" coverageFit=\" + (+coverageFit.toFixed(3))\\n        + \" coverageAll=\" + (coverageAll == null ? \"null\" : String(+coverageAll.toFixed(3)))\\n        + \" nodes=\" + String(fitNodesCount) + \"/\" + String(totalNodes)\\n        + \" ignoredBleed=\" + String(ignoredBleed)\\n        + \" ignoredExplicit=\" + String(ignoredExplicit)\\n        + \" tinyShrinkProtected=\" + String(!!(fitDebug && fitDebug.tinyShrinkProtected))\\n        + \" pantallaDownscaleBlocked=\" + String(!!(fitDebug && fitDebug.pantallaDownscaleBlocked))\\n      );\\n      if (dominantText) {\\n        flatLines.push(\\n          \"dominantText hSecRatio=\" + String(dominantText.heightSecRatio)\\n          + \" hViewportRatio=\" + String(dominantText.heightViewportRatio)\\n          + \" wSecRatio=\" + String(dominantText.widthSecRatio)\\n          + \" fontSize=\" + String(dominantText.fontSize || \"\")\\n          + \" lineHeight=\" + String(dominantText.lineHeight || \"\")\\n          + \" sample=\\'\" + String(dominantText.textSample || \"\") + \"\\'\"\\n        );\\n      } else {\\n        flatLines.push(\"dominantText none\");\\n      }\\n      for (var te=0; te<topElements.length; te++){\\n        var e = topElements[te];\\n        flatLines.push(\\n          \"el#\" + String(te + 1)\\n          + \" kind=\" + String(e.kind || \"\")\\n          + \" wVp=\" + String(e.widthViewportRatio)\\n          + \" hVp=\" + String(e.heightViewportRatio)\\n          + \" topSec=\" + String(e.topSecRatio)\\n          + \" bottomSec=\" + String(e.bottomSecRatio)\\n          + (e.sample ? (\" sample=\\'\" + String(e.sample) + \"\\'\") : \"\")\\n        );\\n      }\\n      mslLog(\"section:fitScale:pantalla:flat\", flatLines.join(\"\\\\n\"));\\n\\n      mslLog(\"section:fitScale:pantalla\", {\\n        secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\\n        secW: +Number(secRectNow.width || 0).toFixed(1),\\n        secH: +Number(secRectNow.height || 0).toFixed(1),\\n        viewport: {\\n          width: +Number(viewportW || 0).toFixed(1),\\n          height: +Number(viewportH || 0).toFixed(1)\\n        },\\n        displayContext: {\\n          mobileViewport: mobileViewport,\\n          desktopMobilePreview: desktopMobilePreview,\\n          mobileUA: mobileUA,\\n          coarsePointer: coarsePointer,\\n          touchPoints: touchPoints\\n        },\\n        preserveBottomGap: +preserveBottomGap.toFixed(1),\\n        totalNodes: totalNodes,\\n        fitNodes: fitNodesCount,\\n        textNodesAll: textAll,\\n        textNodesFit: textFit,\\n        ignoredBleed: ignoredBleed,\\n        ignoredExplicit: ignoredExplicit,\\n        coverageFit: +coverageFit.toFixed(3),\\n        coverageAll: coverageAll == null ? null : +coverageAll.toFixed(3),\\n        fitBounds: {\\n          width: +Number(bounds.width || 0).toFixed(1),\\n          height: +Number(bounds.height || 0).toFixed(1),\\n          maxBottom: +Number(bounds.maxBottom || 0).toFixed(1)\\n        },\\n        allBounds: boundsAll ? {\\n          width: +Number(boundsAll.width || 0).toFixed(1),\\n          height: +Number(boundsAll.height || 0).toFixed(1),\\n          maxBottom: +Number(boundsAll.maxBottom || 0).toFixed(1)\\n        } : null,\\n        fitDebug: fitDebug ? {\\n          targetCoverage: +Number(fitDebug.targetCoverage || 0).toFixed(3),\\n          minFillForUpscale: +Number(fitDebug.minFillForUpscale || 0).toFixed(3),\\n          coverage: +Number(fitDebug.coverage || 0).toFixed(3),\\n          initialScale: +Number(fitDebug.initialScale || 0).toFixed(3),\\n          maxScaleByWidth: fitDebug.maxScaleByWidth == null ? null : +Number(fitDebug.maxScaleByWidth).toFixed(3),\\n          maxScaleByHeight: fitDebug.maxScaleByHeight == null ? null : +Number(fitDebug.maxScaleByHeight).toFixed(3),\\n          scaleAfterWidthClamp: fitDebug.scaleAfterWidthClamp == null ? null : +Number(fitDebug.scaleAfterWidthClamp).toFixed(3),\\n          scaleAfterHeightClamp: fitDebug.scaleAfterHeightClamp == null ? null : +Number(fitDebug.scaleAfterHeightClamp).toFixed(3),\\n          tinyShrinkProtected: !!fitDebug.tinyShrinkProtected,\\n          pantallaDownscaleBlocked: !!fitDebug.pantallaDownscaleBlocked\\n        } : null,\\n        appliedScale: +Number(scale || 1).toFixed(3),\\n        dominantText: dominantText,\\n        topElements: topElements\\n      });\\n    }\\n\\n    sec.setAttribute(\"data-msl-fit-scale\", String(+scale.toFixed(3)));\\n    mslLog(\"section:fitScale\", {\\n      secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\\n      mode: secModo,\\n      nodes: bounds.count,\\n      coverage: +(bounds.width / Math.max(1, sec.getBoundingClientRect().width || 0)).toFixed(3),\\n      boxW: +bounds.width.toFixed(1),\\n      boxH: +bounds.height.toFixed(1),\\n      scale: +scale.toFixed(3),\\n      preserveBottomGap: +preserveBottomGap.toFixed(1),\\n      scaledBottomGap: +((preserveBottomGap || 0) * scale).toFixed(1),\\n      neededHeight: neededHeight\\n    });\\n\\n    return {\\n      scale: scale,\\n      neededHeight: neededHeight,\\n      bounds: bounds\\n    };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sMnZqQkEyYlBDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcZml0U2NhbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9maXRTY2FsZS50c1xuZXhwb3J0IGZ1bmN0aW9uIGpzRml0U2NhbGVCbG9jaygpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICBmdW5jdGlvbiBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGVsKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLXRyYW5zZm9ybVwiLCBlbC5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctb3JpZ2luXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy1vcmlnaW5cIiwgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luIHx8IFwiXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGVsKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCk7XG4gICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikgfHwgXCJcIjtcbiAgICB2YXIgYmFzZU9yaWdpbiA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLW9yaWdpblwiKSB8fCBcIlwiO1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gICAgaWYgKGJhc2VPcmlnaW4pIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGJhc2VPcmlnaW47XG4gICAgZWxzZSBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybS1vcmlnaW5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUVsZW1lbnRGaXRTY2FsZShlbCwgc2NhbGUpe1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGVsKTtcbiAgICB2YXIgYmFzZVRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLXRyYW5zZm9ybVwiKSB8fCBcIlwiO1xuICAgIHZhciBuZXh0ID0gYmFzZVRyYW5zZm9ybSA/IChiYXNlVHJhbnNmb3JtICsgXCIgc2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiKSA6IChcInNjYWxlKFwiICsgc2NhbGUgKyBcIilcIik7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtID0gbmV4dDtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U2VjdGlvbkZpdFNjYWxlKF9zZWMsIGNvbnRlbnQsIGJsZWVkKXtcbiAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShjb250ZW50KTtcbiAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShibGVlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIG5vZGVzKXtcbiAgICBpZiAoIXNlYyB8fCAhbm9kZXMgfHwgIW5vZGVzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1pbkxlZnQgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluVG9wID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFJpZ2h0ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhCb3R0b20gPSAtSW5maW5pdHk7XG4gICAgdmFyIHZhbGlkID0gMDtcblxuICAgIGZvciAodmFyIGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKCFub2RlKSBjb250aW51ZTtcbiAgICAgIHZhciByciA9IHJlbFJlY3Qobm9kZSwgc2VjKTtcbiAgICAgIHZhciB3ID0gTnVtYmVyKHJyLndpZHRoIHx8IDApO1xuICAgICAgdmFyIGggPSBOdW1iZXIocnIuaGVpZ2h0IHx8IDApO1xuICAgICAgaWYgKHcgPD0gMC41ICYmIGggPD0gMC41KSBjb250aW51ZTtcblxuICAgICAgdmFyIGwgPSBOdW1iZXIocnIubGVmdCB8fCAwKTtcbiAgICAgIHZhciB0ID0gTnVtYmVyKHJyLnRvcCB8fCAwKTtcbiAgICAgIHZhciByID0gbCArIE1hdGgubWF4KDAsIHcpO1xuICAgICAgdmFyIGIgPSB0ICsgTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAgIGlmICghaXNGaW5pdGUobCkgfHwgIWlzRmluaXRlKHQpIHx8ICFpc0Zpbml0ZShyKSB8fCAhaXNGaW5pdGUoYikpIGNvbnRpbnVlO1xuXG4gICAgICBtaW5MZWZ0ID0gTWF0aC5taW4obWluTGVmdCwgbCk7XG4gICAgICBtaW5Ub3AgPSBNYXRoLm1pbihtaW5Ub3AsIHQpO1xuICAgICAgbWF4UmlnaHQgPSBNYXRoLm1heChtYXhSaWdodCwgcik7XG4gICAgICBtYXhCb3R0b20gPSBNYXRoLm1heChtYXhCb3R0b20sIGIpO1xuICAgICAgdmFsaWQrKztcbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkIHx8ICFpc0Zpbml0ZShtaW5MZWZ0KSB8fCAhaXNGaW5pdGUobWF4UmlnaHQpIHx8ICFpc0Zpbml0ZShtaW5Ub3ApIHx8ICFpc0Zpbml0ZShtYXhCb3R0b20pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluTGVmdDogbWluTGVmdCxcbiAgICAgIG1pblRvcDogbWluVG9wLFxuICAgICAgbWF4UmlnaHQ6IG1heFJpZ2h0LFxuICAgICAgbWF4Qm90dG9tOiBtYXhCb3R0b20sXG4gICAgICB3aWR0aDogTWF0aC5tYXgoMCwgbWF4UmlnaHQgLSBtaW5MZWZ0KSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgbWF4Qm90dG9tIC0gbWluVG9wKSxcbiAgICAgIGNvdW50OiB2YWxpZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRml0U2NhbGUoc2VjLCBib3VuZHMsIHNlY01vZG8sIENGRyl7XG4gICAgaWYgKCFzZWMgfHwgIWJvdW5kcykgcmV0dXJuIDE7XG4gICAgdmFyIHNlY1JlY3QgPSBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHNlY1cgPSBOdW1iZXIoc2VjUmVjdC53aWR0aCB8fCAwKTtcbiAgICB2YXIgc2VjSCA9IE51bWJlcihzZWNSZWN0LmhlaWdodCB8fCAwKTtcbiAgICBpZiAoc2VjVyA8PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZGVidWc6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldENvdmVyYWdlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfVEFSR0VUX1dJRFRIX1JBVElPIHx8IDAuOTQpLCAwLjc1LCAwLjk5KTtcbiAgICB2YXIgbWluRmlsbEZvclVwc2NhbGUgPSBjbGFtcChOdW1iZXIoQ0ZHLkZJVF9NSU5fRklMTF9SQVRJTyB8fCAwLjkpLCAwLjYsIHRhcmdldENvdmVyYWdlKTtcbiAgICB2YXIgbWluU2NhbGUgPSBjbGFtcChOdW1iZXIoQ0ZHLkZJVF9NSU5fU0NBTEUgfHwgMC44OCksIDAuNywgMSk7XG4gICAgdmFyIG1heFNjYWxlID0gTWF0aC5tYXgoMSwgTnVtYmVyKENGRy5GSVRfTUFYX1NDQUxFIHx8IDEuMTYpKTtcblxuICAgIHZhciBjb250ZW50VyA9IE1hdGgubWF4KDEsIE51bWJlcihib3VuZHMud2lkdGggfHwgMCkpO1xuICAgIHZhciBjb3ZlcmFnZSA9IGNvbnRlbnRXIC8gc2VjVztcblxuICAgIHZhciBzY2FsZSA9IDE7XG4gICAgdmFyIGRlYnVnID0ge1xuICAgICAgc2VjVzogc2VjVyxcbiAgICAgIHNlY0g6IHNlY0gsXG4gICAgICB0YXJnZXRDb3ZlcmFnZTogdGFyZ2V0Q292ZXJhZ2UsXG4gICAgICBtaW5GaWxsRm9yVXBzY2FsZTogbWluRmlsbEZvclVwc2NhbGUsXG4gICAgICBtaW5TY2FsZTogbWluU2NhbGUsXG4gICAgICBtYXhTY2FsZTogbWF4U2NhbGUsXG4gICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG4gICAgICBpbml0aWFsU2NhbGU6IDEsXG4gICAgICBtYXhTY2FsZUJ5V2lkdGg6IG51bGwsXG4gICAgICBtYXhTY2FsZUJ5SGVpZ2h0OiBudWxsLFxuICAgICAgc2NhbGVBZnRlcldpZHRoQ2xhbXA6IG51bGwsXG4gICAgICBzY2FsZUFmdGVySGVpZ2h0Q2xhbXA6IG51bGwsXG4gICAgICB0aW55U2hyaW5rUHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgIHBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChjb3ZlcmFnZSA8IG1pbkZpbGxGb3JVcHNjYWxlKSB7XG4gICAgICBzY2FsZSA9IHRhcmdldENvdmVyYWdlIC8gTWF0aC5tYXgoMC4wMSwgY292ZXJhZ2UpO1xuICAgIH1cbiAgICBkZWJ1Zy5pbml0aWFsU2NhbGUgPSBzY2FsZTtcblxuICAgIGlmIChzY2FsZSA+PSAxKSBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZSk7XG4gICAgZWxzZSBzY2FsZSA9IE1hdGgubWF4KHNjYWxlLCBtaW5TY2FsZSk7XG5cbiAgICAvLyBMw61taXRlIGhvcml6b250YWwgZHVybyBwb3IgY2VudHJvIHZpc3VhbC5cbiAgICB2YXIgY2VudGVyWCA9IHNlY1cgLyAyO1xuICAgIHZhciBkaXN0TGVmdCA9IE1hdGgubWF4KDAsIGNlbnRlclggLSBOdW1iZXIoYm91bmRzLm1pbkxlZnQgfHwgMCkpO1xuICAgIHZhciBkaXN0UmlnaHQgPSBNYXRoLm1heCgwLCBOdW1iZXIoYm91bmRzLm1heFJpZ2h0IHx8IDApIC0gY2VudGVyWCk7XG4gICAgdmFyIG1heFNjYWxlQnlXaWR0aCA9IEluZmluaXR5O1xuICAgIGlmIChkaXN0TGVmdCA+IDAuNSkge1xuICAgICAgbWF4U2NhbGVCeVdpZHRoID0gTWF0aC5taW4obWF4U2NhbGVCeVdpZHRoLCBjZW50ZXJYIC8gZGlzdExlZnQpO1xuICAgIH1cbiAgICBpZiAoZGlzdFJpZ2h0ID4gMC41KSB7XG4gICAgICBtYXhTY2FsZUJ5V2lkdGggPSBNYXRoLm1pbihtYXhTY2FsZUJ5V2lkdGgsIChzZWNXIC0gY2VudGVyWCkgLyBkaXN0UmlnaHQpO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGUobWF4U2NhbGVCeVdpZHRoKSAmJiBtYXhTY2FsZUJ5V2lkdGggPiAwKSB7XG4gICAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZUJ5V2lkdGgpO1xuICAgICAgZGVidWcubWF4U2NhbGVCeVdpZHRoID0gbWF4U2NhbGVCeVdpZHRoO1xuICAgIH1cbiAgICBkZWJ1Zy5zY2FsZUFmdGVyV2lkdGhDbGFtcCA9IHNjYWxlO1xuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzY2FsZSA8IDEgJiYgc2NhbGUgPiAwLjk0KSB7XG4gICAgICAvLyBBdm9pZCBzaHJpbmtpbmcgXCJwYW50YWxsYVwiIGZvciB0aW55IG92ZXJmbG93czsgcHJlc2VydmUgdmlzdWFsIGltcGFjdC5cbiAgICAgIHNjYWxlID0gMTtcbiAgICAgIGRlYnVnLnRpbnlTaHJpbmtQcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEVuIG1vZG8gcGFudGFsbGEgbm8gZGVqYW1vcyBxdWUgZWwgY29udGVuaWRvIHNlIHJlY29ydGUgcG9yIGFsdHVyYS5cbiAgICBpZiAoc2VjTW9kbyA9PT0gXCJwYW50YWxsYVwiICYmIHNlY0ggPiAxKSB7XG4gICAgICB2YXIgbWF4Qm90dG9tID0gTnVtYmVyKGJvdW5kcy5tYXhCb3R0b20gfHwgMCk7XG4gICAgICBpZiAobWF4Qm90dG9tID4gMSkge1xuICAgICAgICB2YXIgbWF4U2NhbGVCeUhlaWdodCA9IHNlY0ggLyBtYXhCb3R0b207XG4gICAgICAgIGlmIChpc0Zpbml0ZShtYXhTY2FsZUJ5SGVpZ2h0KSAmJiBtYXhTY2FsZUJ5SGVpZ2h0ID4gMCkge1xuICAgICAgICAgIHNjYWxlID0gTWF0aC5taW4oc2NhbGUsIG1heFNjYWxlQnlIZWlnaHQpO1xuICAgICAgICAgIGRlYnVnLm1heFNjYWxlQnlIZWlnaHQgPSBtYXhTY2FsZUJ5SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnLnNjYWxlQWZ0ZXJIZWlnaHRDbGFtcCA9IHNjYWxlO1xuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzY2FsZSA8IDEpIHtcbiAgICAgIC8vIFBhbnRhbGxhIHNlY3Rpb25zIGFscmVhZHkgaGF2ZSB0aGVpciBvd24gdmlld3BvcnQtZml0IGxvZ2ljLlxuICAgICAgLy8gQXZvaWQgYWRkaXRpb25hbCBkb3duc2NhbGUgaGVyZSB0byBrZWVwIGhlcm8gdGV4dCByZWFkYWJsZS5cbiAgICAgIHNjYWxlID0gMTtcbiAgICAgIGRlYnVnLnBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShzY2FsZSkgfHwgc2NhbGUgPD0gMCkgc2NhbGUgPSAxO1xuICAgIGlmIChNYXRoLmFicyhzY2FsZSAtIDEpIDwgMC4wMikgc2NhbGUgPSAxO1xuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBkZWJ1ZzogZGVidWdcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCwgbm9kZXNBbGwsIHNlY01vZG8sIENGRywgbWV0YSwgb3B0cyl7XG4gICAgaWYgKCFzZWMgfHwgIWNvbnRlbnQpIHtcbiAgICAgIHJldHVybiB7IHNjYWxlOiAxLCBuZWVkZWRIZWlnaHQ6IDAsIGJvdW5kczogbnVsbCB9O1xuICAgIH1cblxuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoY29udGVudCk7XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShibGVlZCk7XG4gICAgdmFyIHByZXNlcnZlQm90dG9tR2FwID0gMDtcbiAgICBpZiAob3B0cyAmJiBOdW1iZXIuaXNGaW5pdGUob3B0cy5wcmVzZXJ2ZUJvdHRvbUdhcCkpIHtcbiAgICAgIHByZXNlcnZlQm90dG9tR2FwID0gTWF0aC5tYXgoMCwgTnVtYmVyKG9wdHMucHJlc2VydmVCb3R0b21HYXApKTtcbiAgICB9XG5cbiAgICB2YXIgZml0Tm9kZXMgPSAobm9kZXNBbGwgfHwgW10pLmZpbHRlcihmdW5jdGlvbihub2RlKXtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGZpdE1vZGUgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1maXRcIikgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChmaXRNb2RlID09PSBcImlnbm9yZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobm9kZS5jbG9zZXN0ICYmIG5vZGUuY2xvc2VzdChcIi5zZWMtYmxlZWRcIikpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgdmFyIGJvdW5kcyA9IGNvbXB1dGVTZWN0aW9uQm91bmRzKHNlYywgZml0Tm9kZXMpO1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICBib3VuZHMgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIG5vZGVzQWxsIHx8IFtdKTtcbiAgICB9XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGNvbnRlbnQpO1xuICAgICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICAgICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBcIjFcIik7XG4gICAgICByZXR1cm4geyBzY2FsZTogMSwgbmVlZGVkSGVpZ2h0OiAwLCBib3VuZHM6IG51bGwgfTtcbiAgICB9XG5cbiAgICB2YXIgZml0UmVzdWx0ID0gY29tcHV0ZUZpdFNjYWxlKHNlYywgYm91bmRzLCBzZWNNb2RvLCBDRkcpO1xuICAgIHZhciBzY2FsZSA9IChmaXRSZXN1bHQgJiYgTnVtYmVyLmlzRmluaXRlKGZpdFJlc3VsdC5zY2FsZSkpID8gZml0UmVzdWx0LnNjYWxlIDogMTtcbiAgICB2YXIgZml0RGVidWcgPSBmaXRSZXN1bHQgJiYgZml0UmVzdWx0LmRlYnVnID8gZml0UmVzdWx0LmRlYnVnIDogbnVsbDtcbiAgICBhcHBseUVsZW1lbnRGaXRTY2FsZShjb250ZW50LCBzY2FsZSk7XG4gICAgYXBwbHlFbGVtZW50Rml0U2NhbGUoYmxlZWQsIHNjYWxlKTtcblxuICAgIHZhciBuZWVkZWRIZWlnaHQgPSAwO1xuICAgIGlmIChzZWNNb2RvICE9PSBcInBhbnRhbGxhXCIpIHtcbiAgICAgIHZhciBtYXhCb3R0b21XaXRoR2FwID0gTnVtYmVyKGJvdW5kcy5tYXhCb3R0b20gfHwgMCkgKyBwcmVzZXJ2ZUJvdHRvbUdhcDtcbiAgICAgIG5lZWRlZEhlaWdodCA9IE1hdGguY2VpbChtYXhCb3R0b21XaXRoR2FwICogc2NhbGUgKyAoQ0ZHLlBBRF9CT1QgfHwgMCkpO1xuICAgIH1cblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIpIHtcbiAgICAgIHZhciBzZWNSZWN0Tm93ID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHZ2ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuICAgICAgdmFyIHZpZXdwb3J0VyA9ICh2diAmJiB2di53aWR0aCkgPyB2di53aWR0aCA6ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCk7XG4gICAgICB2YXIgdmlld3BvcnRIID0gKHZ2ICYmIHZ2LmhlaWdodCkgPyB2di5oZWlnaHQgOiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCk7XG4gICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gICAgICB2YXIgbW9iaWxlVUEgPSAvQW5kcm9pZHxpUGhvbmV8aVBhZHxpUG9kfE1vYmlsZS9pLnRlc3QodWEpO1xuICAgICAgdmFyIHRvdWNoUG9pbnRzID0gTnVtYmVyKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwKTtcbiAgICAgIHZhciBjb2Fyc2VQb2ludGVyID0gZmFsc2U7XG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgdHJ5IHsgY29hcnNlUG9pbnRlciA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlczsgfSBjYXRjaChfZSkge31cbiAgICAgIH1cbiAgICAgIHZhciBtb2JpbGVWaWV3cG9ydCA9IHZpZXdwb3J0VyA8PSA3Njc7XG4gICAgICB2YXIgZGVza3RvcE1vYmlsZVByZXZpZXcgPSBtb2JpbGVWaWV3cG9ydCAmJiAhbW9iaWxlVUE7XG5cbiAgICAgIHZhciBib3VuZHNBbGwgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIG5vZGVzQWxsIHx8IFtdKTtcbiAgICAgIHZhciB0b3RhbE5vZGVzID0gKG5vZGVzQWxsIHx8IFtdKS5sZW5ndGg7XG4gICAgICB2YXIgZml0Tm9kZXNDb3VudCA9IGZpdE5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciB0ZXh0QWxsID0gMDtcbiAgICAgIHZhciB0ZXh0Rml0ID0gMDtcbiAgICAgIHZhciBpZ25vcmVkQmxlZWQgPSAwO1xuICAgICAgdmFyIGlnbm9yZWRFeHBsaWNpdCA9IDA7XG4gICAgICB2YXIgZG9taW5hbnRUZXh0ID0gbnVsbDtcbiAgICAgIHZhciBkb21pbmFudFRleHRIID0gLTE7XG4gICAgICB2YXIgZWxlbWVudFJvd3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbmk9MDsgbmk8dG90YWxOb2RlczsgbmkrKyl7XG4gICAgICAgIHZhciBub2RlQWxsID0gbm9kZXNBbGxbbmldO1xuICAgICAgICBpZiAoIW5vZGVBbGwpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBmaXRNb2RlQWxsID0gKG5vZGVBbGwuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChmaXRNb2RlQWxsID09PSBcImlnbm9yZVwiKSBpZ25vcmVkRXhwbGljaXQrKztcbiAgICAgICAgaWYgKG5vZGVBbGwuY2xvc2VzdCAmJiBub2RlQWxsLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSBpZ25vcmVkQmxlZWQrKztcblxuICAgICAgICB2YXIgcnJOb2RlID0gcmVsUmVjdChub2RlQWxsLCBzZWMpO1xuICAgICAgICB2YXIgbm9kZVcgPSBOdW1iZXIocnJOb2RlLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgbm9kZUggPSBOdW1iZXIocnJOb2RlLmhlaWdodCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVUb3AgPSBOdW1iZXIocnJOb2RlLnRvcCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVCb3R0b20gPSBub2RlVG9wICsgbm9kZUg7XG4gICAgICAgIHZhciBpc1RleHRBbGwgPSAobm9kZUFsbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgaWYgKGlzVGV4dEFsbCkgdGV4dEFsbCsrO1xuXG4gICAgICAgIGlmIChub2RlVyA+IDAuNSB8fCBub2RlSCA+IDAuNSkge1xuICAgICAgICAgIHZhciBraW5kQWxsID0gaXNUZXh0QWxsID8gXCJ0ZXh0b1wiIDogU3RyaW5nKChub2RlQWxsLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgZWxlbWVudFJvd3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiBraW5kQWxsLFxuICAgICAgICAgICAgd2lkdGg6IG5vZGVXLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlSCxcbiAgICAgICAgICAgIHRvcDogbm9kZVRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogbm9kZUJvdHRvbSxcbiAgICAgICAgICAgIGFyZWE6IG5vZGVXICogbm9kZUgsXG4gICAgICAgICAgICB0ZXh0U2FtcGxlOiBpc1RleHRBbGxcbiAgICAgICAgICAgICAgPyAoKG5vZGVBbGwudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5yZXBsYWNlKC9cXFxccysvZywgXCIgXCIpLnNsaWNlKDAsIDcwKVxuICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUZXh0QWxsKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGVIIDw9IGRvbWluYW50VGV4dEgpIGNvbnRpbnVlO1xuICAgICAgICBkb21pbmFudFRleHRIID0gbm9kZUg7XG4gICAgICAgIHZhciBjc1R4dCA9IGdldENvbXB1dGVkU3R5bGUobm9kZUFsbCk7XG4gICAgICAgIGRvbWluYW50VGV4dCA9IHtcbiAgICAgICAgICB0b3A6ICtub2RlVG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgbGVmdDogK051bWJlcihyck5vZGUubGVmdCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIHdpZHRoOiArbm9kZVcudG9GaXhlZCgxKSxcbiAgICAgICAgICBoZWlnaHQ6ICtub2RlSC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGJvdHRvbTogK25vZGVCb3R0b20udG9GaXhlZCgxKSxcbiAgICAgICAgICB3aWR0aFNlY1JhdGlvOiBzZWNSZWN0Tm93LndpZHRoID4gMSA/ICsobm9kZVcgLyBzZWNSZWN0Tm93LndpZHRoKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICBoZWlnaHRTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKyhub2RlSCAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICB3aWR0aFZpZXdwb3J0UmF0aW86IHZpZXdwb3J0VyA+IDEgPyArKG5vZGVXIC8gdmlld3BvcnRXKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICBoZWlnaHRWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydEggPiAxID8gKyhub2RlSCAvIHZpZXdwb3J0SCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgZm9udFNpemU6IGNzVHh0LmZvbnRTaXplIHx8IFwiXCIsXG4gICAgICAgICAgbGluZUhlaWdodDogY3NUeHQubGluZUhlaWdodCB8fCBcIlwiLFxuICAgICAgICAgIHRleHRBbGlnbjogY3NUeHQudGV4dEFsaWduIHx8IFwiXCIsXG4gICAgICAgICAgdHJhbnNmb3JtOiAobm9kZUFsbC5zdHlsZSAmJiBub2RlQWxsLnN0eWxlLnRyYW5zZm9ybSkgPyBub2RlQWxsLnN0eWxlLnRyYW5zZm9ybSA6IFwiXCIsXG4gICAgICAgICAgdGV4dFNhbXBsZTogKChub2RlQWxsLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA5MClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZmk9MDsgZmk8Zml0Tm9kZXMubGVuZ3RoOyBmaSsrKXtcbiAgICAgICAgdmFyIGZpdE5vZGUgPSBmaXROb2Rlc1tmaV07XG4gICAgICAgIGlmICgoZml0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgdGV4dEZpdCsrO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9wRWxlbWVudHMgPSBlbGVtZW50Um93c1xuICAgICAgICAuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gKGIuYXJlYSB8fCAwKSAtIChhLmFyZWEgfHwgMCk7IH0pXG4gICAgICAgIC5zbGljZSgwLCA2KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHJvdyl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IHJvdy5raW5kLFxuICAgICAgICAgICAgd2lkdGg6ICtOdW1iZXIocm93LndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoZWlnaHQ6ICtOdW1iZXIocm93LmhlaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgd2lkdGhTZWNSYXRpbzogc2VjUmVjdE5vdy53aWR0aCA+IDEgPyArKChyb3cud2lkdGggfHwgMCkgLyBzZWNSZWN0Tm93LndpZHRoKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodFNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cuaGVpZ2h0IHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgd2lkdGhWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydFcgPiAxID8gKygocm93LndpZHRoIHx8IDApIC8gdmlld3BvcnRXKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodFZpZXdwb3J0UmF0aW86IHZpZXdwb3J0SCA+IDEgPyArKChyb3cuaGVpZ2h0IHx8IDApIC8gdmlld3BvcnRIKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIHRvcFNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cudG9wIHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgYm90dG9tU2VjUmF0aW86IHNlY1JlY3ROb3cuaGVpZ2h0ID4gMSA/ICsoKHJvdy5ib3R0b20gfHwgMCkgLyBzZWNSZWN0Tm93LmhlaWdodCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBzYW1wbGU6IHJvdy50ZXh0U2FtcGxlIHx8IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgdmFyIGNvdmVyYWdlRml0ID0gYm91bmRzLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjUmVjdE5vdy53aWR0aCB8fCAwKTtcbiAgICAgIHZhciBjb3ZlcmFnZUFsbCA9IGJvdW5kc0FsbCA/IChib3VuZHNBbGwud2lkdGggLyBNYXRoLm1heCgxLCBzZWNSZWN0Tm93LndpZHRoIHx8IDApKSA6IG51bGw7XG5cbiAgICAgIHZhciBmbGF0TGluZXMgPSBbXTtcbiAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICBcInNlYz1cIiArIFN0cmluZyhtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSlcbiAgICAgICAgKyBcIiB2aWV3cG9ydD1cIiArICgrTnVtYmVyKHZpZXdwb3J0VyB8fCAwKS50b0ZpeGVkKDEpKSArIFwieFwiICsgKCtOdW1iZXIodmlld3BvcnRIIHx8IDApLnRvRml4ZWQoMSkpXG4gICAgICAgICsgXCIgc2VjPVwiICsgKCtOdW1iZXIoc2VjUmVjdE5vdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpKSArIFwieFwiICsgKCtOdW1iZXIoc2VjUmVjdE5vdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSlcbiAgICAgICAgKyBcIiBtb2JpbGVWaWV3cG9ydD1cIiArIFN0cmluZyhtb2JpbGVWaWV3cG9ydClcbiAgICAgICAgKyBcIiBkZXNrdG9wTW9iaWxlUHJldmlldz1cIiArIFN0cmluZyhkZXNrdG9wTW9iaWxlUHJldmlldylcbiAgICAgICAgKyBcIiBtb2JpbGVVQT1cIiArIFN0cmluZyhtb2JpbGVVQSlcbiAgICAgICAgKyBcIiBjb2Fyc2VQb2ludGVyPVwiICsgU3RyaW5nKGNvYXJzZVBvaW50ZXIpXG4gICAgICAgICsgXCIgdG91Y2hQb2ludHM9XCIgKyBTdHJpbmcodG91Y2hQb2ludHMpXG4gICAgICApO1xuICAgICAgZmxhdExpbmVzLnB1c2goXG4gICAgICAgIFwiZml0IHNjYWxlPVwiICsgKCtOdW1iZXIoc2NhbGUgfHwgMSkudG9GaXhlZCgzKSlcbiAgICAgICAgKyBcIiBjb3ZlcmFnZUZpdD1cIiArICgrY292ZXJhZ2VGaXQudG9GaXhlZCgzKSlcbiAgICAgICAgKyBcIiBjb3ZlcmFnZUFsbD1cIiArIChjb3ZlcmFnZUFsbCA9PSBudWxsID8gXCJudWxsXCIgOiBTdHJpbmcoK2NvdmVyYWdlQWxsLnRvRml4ZWQoMykpKVxuICAgICAgICArIFwiIG5vZGVzPVwiICsgU3RyaW5nKGZpdE5vZGVzQ291bnQpICsgXCIvXCIgKyBTdHJpbmcodG90YWxOb2RlcylcbiAgICAgICAgKyBcIiBpZ25vcmVkQmxlZWQ9XCIgKyBTdHJpbmcoaWdub3JlZEJsZWVkKVxuICAgICAgICArIFwiIGlnbm9yZWRFeHBsaWNpdD1cIiArIFN0cmluZyhpZ25vcmVkRXhwbGljaXQpXG4gICAgICAgICsgXCIgdGlueVNocmlua1Byb3RlY3RlZD1cIiArIFN0cmluZyghIShmaXREZWJ1ZyAmJiBmaXREZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkKSlcbiAgICAgICAgKyBcIiBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ9XCIgKyBTdHJpbmcoISEoZml0RGVidWcgJiYgZml0RGVidWcucGFudGFsbGFEb3duc2NhbGVCbG9ja2VkKSlcbiAgICAgICk7XG4gICAgICBpZiAoZG9taW5hbnRUZXh0KSB7XG4gICAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICAgIFwiZG9taW5hbnRUZXh0IGhTZWNSYXRpbz1cIiArIFN0cmluZyhkb21pbmFudFRleHQuaGVpZ2h0U2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBoVmlld3BvcnRSYXRpbz1cIiArIFN0cmluZyhkb21pbmFudFRleHQuaGVpZ2h0Vmlld3BvcnRSYXRpbylcbiAgICAgICAgICArIFwiIHdTZWNSYXRpbz1cIiArIFN0cmluZyhkb21pbmFudFRleHQud2lkdGhTZWNSYXRpbylcbiAgICAgICAgICArIFwiIGZvbnRTaXplPVwiICsgU3RyaW5nKGRvbWluYW50VGV4dC5mb250U2l6ZSB8fCBcIlwiKVxuICAgICAgICAgICsgXCIgbGluZUhlaWdodD1cIiArIFN0cmluZyhkb21pbmFudFRleHQubGluZUhlaWdodCB8fCBcIlwiKVxuICAgICAgICAgICsgXCIgc2FtcGxlPSdcIiArIFN0cmluZyhkb21pbmFudFRleHQudGV4dFNhbXBsZSB8fCBcIlwiKSArIFwiJ1wiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0TGluZXMucHVzaChcImRvbWluYW50VGV4dCBub25lXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdGU9MDsgdGU8dG9wRWxlbWVudHMubGVuZ3RoOyB0ZSsrKXtcbiAgICAgICAgdmFyIGUgPSB0b3BFbGVtZW50c1t0ZV07XG4gICAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICAgIFwiZWwjXCIgKyBTdHJpbmcodGUgKyAxKVxuICAgICAgICAgICsgXCIga2luZD1cIiArIFN0cmluZyhlLmtpbmQgfHwgXCJcIilcbiAgICAgICAgICArIFwiIHdWcD1cIiArIFN0cmluZyhlLndpZHRoVmlld3BvcnRSYXRpbylcbiAgICAgICAgICArIFwiIGhWcD1cIiArIFN0cmluZyhlLmhlaWdodFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiB0b3BTZWM9XCIgKyBTdHJpbmcoZS50b3BTZWNSYXRpbylcbiAgICAgICAgICArIFwiIGJvdHRvbVNlYz1cIiArIFN0cmluZyhlLmJvdHRvbVNlY1JhdGlvKVxuICAgICAgICAgICsgKGUuc2FtcGxlID8gKFwiIHNhbXBsZT0nXCIgKyBTdHJpbmcoZS5zYW1wbGUpICsgXCInXCIpIDogXCJcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGU6cGFudGFsbGE6ZmxhdFwiLCBmbGF0TGluZXMuam9pbihcIlxcXFxuXCIpKTtcblxuICAgICAgbXNsTG9nKFwic2VjdGlvbjpmaXRTY2FsZTpwYW50YWxsYVwiLCB7XG4gICAgICAgIHNlY0luZGV4OiBtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSxcbiAgICAgICAgc2VjVzogK051bWJlcihzZWNSZWN0Tm93LndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHNlY0g6ICtOdW1iZXIoc2VjUmVjdE5vdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICB3aWR0aDogK051bWJlcih2aWV3cG9ydFcgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBoZWlnaHQ6ICtOdW1iZXIodmlld3BvcnRIIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheUNvbnRleHQ6IHtcbiAgICAgICAgICBtb2JpbGVWaWV3cG9ydDogbW9iaWxlVmlld3BvcnQsXG4gICAgICAgICAgZGVza3RvcE1vYmlsZVByZXZpZXc6IGRlc2t0b3BNb2JpbGVQcmV2aWV3LFxuICAgICAgICAgIG1vYmlsZVVBOiBtb2JpbGVVQSxcbiAgICAgICAgICBjb2Fyc2VQb2ludGVyOiBjb2Fyc2VQb2ludGVyLFxuICAgICAgICAgIHRvdWNoUG9pbnRzOiB0b3VjaFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBwcmVzZXJ2ZUJvdHRvbUdhcDogK3ByZXNlcnZlQm90dG9tR2FwLnRvRml4ZWQoMSksXG4gICAgICAgIHRvdGFsTm9kZXM6IHRvdGFsTm9kZXMsXG4gICAgICAgIGZpdE5vZGVzOiBmaXROb2Rlc0NvdW50LFxuICAgICAgICB0ZXh0Tm9kZXNBbGw6IHRleHRBbGwsXG4gICAgICAgIHRleHROb2Rlc0ZpdDogdGV4dEZpdCxcbiAgICAgICAgaWdub3JlZEJsZWVkOiBpZ25vcmVkQmxlZWQsXG4gICAgICAgIGlnbm9yZWRFeHBsaWNpdDogaWdub3JlZEV4cGxpY2l0LFxuICAgICAgICBjb3ZlcmFnZUZpdDogK2NvdmVyYWdlRml0LnRvRml4ZWQoMyksXG4gICAgICAgIGNvdmVyYWdlQWxsOiBjb3ZlcmFnZUFsbCA9PSBudWxsID8gbnVsbCA6ICtjb3ZlcmFnZUFsbC50b0ZpeGVkKDMpLFxuICAgICAgICBmaXRCb3VuZHM6IHtcbiAgICAgICAgICB3aWR0aDogK051bWJlcihib3VuZHMud2lkdGggfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBoZWlnaHQ6ICtOdW1iZXIoYm91bmRzLmhlaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIG1heEJvdHRvbTogK051bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgfSxcbiAgICAgICAgYWxsQm91bmRzOiBib3VuZHNBbGwgPyB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIoYm91bmRzQWxsLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKGJvdW5kc0FsbC5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBtYXhCb3R0b206ICtOdW1iZXIoYm91bmRzQWxsLm1heEJvdHRvbSB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBmaXREZWJ1ZzogZml0RGVidWcgPyB7XG4gICAgICAgICAgdGFyZ2V0Q292ZXJhZ2U6ICtOdW1iZXIoZml0RGVidWcudGFyZ2V0Q292ZXJhZ2UgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBtaW5GaWxsRm9yVXBzY2FsZTogK051bWJlcihmaXREZWJ1Zy5taW5GaWxsRm9yVXBzY2FsZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIGNvdmVyYWdlOiArTnVtYmVyKGZpdERlYnVnLmNvdmVyYWdlIHx8IDApLnRvRml4ZWQoMyksXG4gICAgICAgICAgaW5pdGlhbFNjYWxlOiArTnVtYmVyKGZpdERlYnVnLmluaXRpYWxTY2FsZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIG1heFNjYWxlQnlXaWR0aDogZml0RGVidWcubWF4U2NhbGVCeVdpZHRoID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5tYXhTY2FsZUJ5V2lkdGgpLnRvRml4ZWQoMyksXG4gICAgICAgICAgbWF4U2NhbGVCeUhlaWdodDogZml0RGVidWcubWF4U2NhbGVCeUhlaWdodCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcubWF4U2NhbGVCeUhlaWdodCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBzY2FsZUFmdGVyV2lkdGhDbGFtcDogZml0RGVidWcuc2NhbGVBZnRlcldpZHRoQ2xhbXAgPT0gbnVsbCA/IG51bGwgOiArTnVtYmVyKGZpdERlYnVnLnNjYWxlQWZ0ZXJXaWR0aENsYW1wKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIHNjYWxlQWZ0ZXJIZWlnaHRDbGFtcDogZml0RGVidWcuc2NhbGVBZnRlckhlaWdodENsYW1wID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5zY2FsZUFmdGVySGVpZ2h0Q2xhbXApLnRvRml4ZWQoMyksXG4gICAgICAgICAgdGlueVNocmlua1Byb3RlY3RlZDogISFmaXREZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkLFxuICAgICAgICAgIHBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZDogISFmaXREZWJ1Zy5wYW50YWxsYURvd25zY2FsZUJsb2NrZWRcbiAgICAgICAgfSA6IG51bGwsXG4gICAgICAgIGFwcGxpZWRTY2FsZTogK051bWJlcihzY2FsZSB8fCAxKS50b0ZpeGVkKDMpLFxuICAgICAgICBkb21pbmFudFRleHQ6IGRvbWluYW50VGV4dCxcbiAgICAgICAgdG9wRWxlbWVudHM6IHRvcEVsZW1lbnRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWMuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LXNjYWxlXCIsIFN0cmluZygrc2NhbGUudG9GaXhlZCgzKSkpO1xuICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGVcIiwge1xuICAgICAgc2VjSW5kZXg6IG1ldGEgJiYgTnVtYmVyLmlzRmluaXRlKG1ldGEuc2VjSW5kZXgpID8gbWV0YS5zZWNJbmRleCA6IC0xLFxuICAgICAgbW9kZTogc2VjTW9kbyxcbiAgICAgIG5vZGVzOiBib3VuZHMuY291bnQsXG4gICAgICBjb3ZlcmFnZTogKyhib3VuZHMud2lkdGggLyBNYXRoLm1heCgxLCBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgMCkpLnRvRml4ZWQoMyksXG4gICAgICBib3hXOiArYm91bmRzLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICBib3hIOiArYm91bmRzLmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgc2NhbGU6ICtzY2FsZS50b0ZpeGVkKDMpLFxuICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtwcmVzZXJ2ZUJvdHRvbUdhcC50b0ZpeGVkKDEpLFxuICAgICAgc2NhbGVkQm90dG9tR2FwOiArKChwcmVzZXJ2ZUJvdHRvbUdhcCB8fCAwKSAqIHNjYWxlKS50b0ZpeGVkKDEpLFxuICAgICAgbmVlZGVkSGVpZ2h0OiBuZWVkZWRIZWlnaHRcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBuZWVkZWRIZWlnaHQ6IG5lZWRlZEhlaWdodCxcbiAgICAgIGJvdW5kczogYm91bmRzXG4gICAgfTtcbiAgfVxuYC50cmltKCk7XG59XG4iXSwibmFtZXMiOlsianNGaXRTY2FsZUJsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/index.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/index.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* reexport safe */ _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__.buildScript),\n/* harmony export */   normalizeConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/config.ts\");\n/* harmony import */ var _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scriptTemplate */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\");\n// functions/src/utils/mobileSmartLayout/index.ts\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlEQUFpRDtBQUVOO0FBQ0kiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHNcclxuZXhwb3J0IHR5cGUgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5leHBvcnQgeyBub3JtYWxpemVDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcclxuZXhwb3J0IHsgYnVpbGRTY3JpcHQgfSBmcm9tIFwiLi9zY3JpcHRUZW1wbGF0ZVwiO1xyXG4iXSwibmFtZXMiOlsibm9ybWFsaXplQ29uZmlnIiwiYnVpbGRTY3JpcHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/ordering.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsOrderingBlock: () => (/* binding */ jsOrderingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/ordering.ts\nfunction jsOrderingBlock() {\n    return '\\n  /**\\n   * Ordena CLUSTERS (no items) para lectura mobile.\\n   * Devuelve groups (array de columnas/grupos) y mode.\\n   *\\n   * - three: [colL, colC, colR]\\n   * - two:   [left, right]\\n   * - rows:  [out] (fila+left)\\n   * - one:   [sortedTop]\\n   */\\n  function orderClustersForMobile(clusters, rootW, CFG){\\n    if (!rootW || rootW <= 0) {\\n      var o = clusters.slice().sort(function(a,b){ return a.top - b.top; });\\n      return { groups: [o], mode: \"one\" };\\n    }\\n\\n    function clusterHasText(c){\\n      if (!c || !c.items || !c.items.length) return false;\\n      for (var iTxt=0; iTxt<c.items.length; iTxt++){\\n        if ((c.items[iTxt].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return true;\\n      }\\n      return false;\\n    }\\n\\n    function columnHasText(col){\\n      if (!col || !col.length) return false;\\n      for (var iCol=0; iCol<col.length; iCol++){\\n        if (clusterHasText(col[iCol])) return true;\\n      }\\n      return false;\\n    }\\n\\n    // Un cluster \"invade\" una frontera si queda partido de forma significativa\\n    // entre ambos lados de la linea divisoria.\\n    function clusterInvadesDivider(c, dividerX){\\n      if (!c) return false;\\n      var left = Number(c.left || 0);\\n      var width = Math.max(0, Number(c.width || 0));\\n      var right = left + width;\\n      if (width <= 1) return false;\\n      if (right <= dividerX || left >= dividerX) return false;\\n\\n      var partLeft = dividerX - left;\\n      var partRight = right - dividerX;\\n      var minPart = Math.min(partLeft, partRight);\\n      var minRequired = Math.max(22, width * 0.22);\\n      return minPart >= minRequired;\\n    }\\n\\n    function dividerInvasionRatio(list, dividerX){\\n      if (!list || !list.length) return 0;\\n      var invaded = 0;\\n      for (var iInv=0; iInv<list.length; iInv++){\\n        if (clusterInvadesDivider(list[iInv], dividerX)) invaded++;\\n      }\\n      return invaded / Math.max(1, list.length);\\n    }\\n\\n    // -------- 0) Intentar 3 columnas claras --------\\n    var t1 = rootW / 3;\\n    var t2 = (2 * rootW) / 3;\\n\\n    var colL = [];\\n    var colC = [];\\n    var colR = [];\\n\\n    for (var i=0;i<clusters.length;i++){\\n      var c = clusters[i];\\n      var x = c.cx;\\n      if (x < t1) colL.push(c);\\n      else if (x < t2) colC.push(c);\\n      else colR.push(c);\\n    }\\n\\n    var looksThree =\\n      (colL.length >= CFG.MIN_PER_COL_3 && colC.length >= CFG.MIN_PER_COL_3 && colR.length >= CFG.MIN_PER_COL_3);\\n    var textColsThree =\\n      (columnHasText(colL) ? 1 : 0) +\\n      (columnHasText(colC) ? 1 : 0) +\\n      (columnHasText(colR) ? 1 : 0);\\n    var hasTextSignalThree = textColsThree >= 2;\\n    mslLog(\"order:three:candidates\", {\\n      rootW: rootW,\\n      total: clusters.length,\\n      colL: colL.length,\\n      colC: colC.length,\\n      colR: colR.length,\\n      minPerCol3: CFG.MIN_PER_COL_3,\\n      textColsThree: textColsThree,\\n      hasTextSignalThree: hasTextSignalThree\\n    });\\n\\n    if (looksThree) {\\n      var cxs = [];\\n      for (var j=0;j<clusters.length;j++) cxs.push(clusters[j].cx);\\n      cxs.sort(function(a,b){ return a-b; });\\n      var p20 = percentile(cxs, 0.20);\\n      var p80 = percentile(cxs, 0.80);\\n      var spread = (p80 - p20);\\n      mslLog(\"order:three:spread\", {\\n        p20: p20,\\n        p80: p80,\\n        spread: spread,\\n        minSpread: rootW * CFG.THREE_COL_SPREAD_RATIO,\\n        pass: spread >= rootW * CFG.THREE_COL_SPREAD_RATIO\\n      });\\n      if (spread < rootW * CFG.THREE_COL_SPREAD_RATIO) looksThree = false;\\n    }\\n\\n    if (looksThree) {\\n      var invadeT1 = dividerInvasionRatio(clusters, t1);\\n      var invadeT2 = dividerInvasionRatio(clusters, t2);\\n      var invadeThree = Math.max(invadeT1, invadeT2);\\n      var invasionLimitThree = hasTextSignalThree ? 0.46 : 0.34;\\n      mslLog(\"order:three:invasion\", {\\n        t1: +t1.toFixed(1),\\n        t2: +t2.toFixed(1),\\n        invadeT1: +invadeT1.toFixed(3),\\n        invadeT2: +invadeT2.toFixed(3),\\n        invadeThree: +invadeThree.toFixed(3),\\n        limit: +invasionLimitThree.toFixed(3),\\n        hasTextSignalThree: hasTextSignalThree,\\n        pass: invadeThree <= invasionLimitThree\\n      });\\n      if (invadeThree > invasionLimitThree) looksThree = false;\\n    }\\n\\n    if (looksThree) {\\n      colL.sort(function(a,b){ return a.top - b.top; });\\n      colC.sort(function(a,b){ return a.top - b.top; });\\n      colR.sort(function(a,b){ return a.top - b.top; });\\n      return { groups: [colL, colC, colR], mode: \"three\" };\\n    }\\n\\n    // -------- 1) Intentar 2 columnas claras --------\\n    var mid = rootW / 2;\\n    var left = [];\\n    var right = [];\\n\\n    for (var k=0;k<clusters.length;k++){\\n      var c2 = clusters[k];\\n      if (c2.cx < mid) left.push(c2);\\n      else right.push(c2);\\n    }\\n\\n    var looksTwo = (left.length >= CFG.MIN_PER_COL_2 && right.length >= CFG.MIN_PER_COL_2);\\n    var hasTextSignalTwo = columnHasText(left) && columnHasText(right);\\n    mslLog(\"order:two:candidates\", {\\n      rootW: rootW,\\n      total: clusters.length,\\n      left: left.length,\\n      right: right.length,\\n      minPerCol2: CFG.MIN_PER_COL_2,\\n      hasTextSignalTwo: hasTextSignalTwo\\n    });\\n\\n    // Politica para pares (2 clusters):\\n    // - par de columnas reales => mode \"two\"\\n    // - resto de casos => mode \"one\" (fitCheck decide si reflowea)\\n    if (clusters.length === 2) {\\n      var cA = clusters[0];\\n      var cB = clusters[1];\\n\\n      function pairStats(c){\\n        var text = 0;\\n        var non = 0;\\n        var force = 0;\\n        for (var q=0; q<c.items.length; q++) {\\n          var n = c.items[q].node;\\n          if ((n.getAttribute(\"data-mobile-center\") || \"\") === \"force\") force++;\\n          if ((n.getAttribute(\"data-debug-texto\") || \"\") === \"1\") text++;\\n          else non++;\\n        }\\n        return { text: text, non: non, force: force };\\n      }\\n\\n      var sA = pairStats(cA);\\n      var sB = pairStats(cB);\\n\\n      var topDelta = Math.abs((cA.top || 0) - (cB.top || 0));\\n      var xOverlap = Math.max(0, Math.min((cA.left + cA.width), (cB.left + cB.width)) - Math.max(cA.left, cB.left));\\n      var minWPair = Math.max(1, Math.min((cA.width || 0), (cB.width || 0)));\\n      var xOverlapRatio = xOverlap / minWPair;\\n      var sideBySide = topDelta <= (CFG.ROW_TOL * 1.5) && xOverlapRatio < 0.25;\\n      var pairInvasion = dividerInvasionRatio([cA, cB], mid);\\n      var pairInvasionLimit = hasTextSignalTwo ? 0.5 : 0.34;\\n\\n      var anyForceCenter = (sA.force > 0 || sB.force > 0);\\n      var bothMixed = (sA.text > 0 && sA.non > 0 && sB.text > 0 && sB.non > 0);\\n      // Se\\xf1al robusta de \"par de columnas\":\\n      // - est\\xe1n lado a lado y pasan split left/right\\n      // - y adem\\xe1s no son simplemente 2 textos sueltos en una fila\\n      var hasColumnSignal =\\n        (sA.non > 0 || sB.non > 0) ||\\n        ((cA.items && cA.items.length > 1) || (cB.items && cB.items.length > 1));\\n\\n      if (looksTwo && sideBySide && hasColumnSignal && pairInvasion <= pairInvasionLimit) {\\n        var leftPair = (cA.cx <= cB.cx) ? [cA] : [cB];\\n        var rightPair = (cA.cx <= cB.cx) ? [cB] : [cA];\\n        mslLog(\"order:two:pairPolicy\", {\\n          mode: \"two\",\\n          reason: \"pairColumns\",\\n          topDelta: +topDelta.toFixed(1),\\n          xOverlapRatio: +xOverlapRatio.toFixed(3),\\n          hasColumnSignal: hasColumnSignal,\\n          bothMixed: bothMixed,\\n          anyForceCenter: anyForceCenter,\\n          pairInvasion: +pairInvasion.toFixed(3),\\n          pairInvasionLimit: +pairInvasionLimit.toFixed(3),\\n          lefts: [+(cA.left || 0).toFixed(1), +(cB.left || 0).toFixed(1)]\\n        });\\n        return { groups: [leftPair, rightPair], mode: \"two\" };\\n      }\\n\\n      var pair = clusters.slice().sort(function(a,b){\\n        if (Math.abs(a.top - b.top) > 0.5) return a.top - b.top;\\n        return a.left - b.left;\\n      });\\n      mslLog(\"order:two:pairPolicy\", {\\n        mode: \"one\",\\n        reason: anyForceCenter ? \"forceCenterPair\" : \"pairDefault\",\\n        topDelta: +topDelta.toFixed(1),\\n        xOverlapRatio: +xOverlapRatio.toFixed(3),\\n        sideBySide: sideBySide,\\n        bothMixed: bothMixed,\\n        anyForceCenter: anyForceCenter,\\n        pairInvasion: +pairInvasion.toFixed(3),\\n        pairInvasionLimit: +pairInvasionLimit.toFixed(3),\\n        tops: pair.map(function(c){ return +c.top.toFixed(1); }),\\n        lefts: pair.map(function(c){ return +c.left.toFixed(1); })\\n      });\\n      return { groups: [pair], mode: \"one\" };\\n    }\\n    if (looksTwo) {\\n      var cxs2 = [];\\n      for (var m=0;m<clusters.length;m++) cxs2.push(clusters[m].cx);\\n      cxs2.sort(function(a,b){ return a-b; });\\n      var p25 = percentile(cxs2, 0.25);\\n      var p75 = percentile(cxs2, 0.75);\\n      var spread2 = (p75 - p25);\\n      mslLog(\"order:two:spread\", {\\n        p25: p25,\\n        p75: p75,\\n        spread: spread2,\\n        minSpread: rootW * CFG.TWO_COL_SPREAD_RATIO,\\n        pass: spread2 >= rootW * CFG.TWO_COL_SPREAD_RATIO\\n      });\\n      if (spread2 < rootW * CFG.TWO_COL_SPREAD_RATIO) looksTwo = false;\\n    }\\n\\n    if (looksTwo) {\\n      var invadeMid = dividerInvasionRatio(clusters, mid);\\n      var invasionLimitTwo = hasTextSignalTwo ? 0.48 : 0.34;\\n      mslLog(\"order:two:invasion\", {\\n        mid: +mid.toFixed(1),\\n        invadeMid: +invadeMid.toFixed(3),\\n        limit: +invasionLimitTwo.toFixed(3),\\n        hasTextSignalTwo: hasTextSignalTwo,\\n        pass: invadeMid <= invasionLimitTwo\\n      });\\n      if (invadeMid > invasionLimitTwo) looksTwo = false;\\n    }\\n\\n    if (looksTwo) {\\n      left.sort(function(a,b){ return a.top - b.top; });\\n      right.sort(function(a,b){ return a.top - b.top; });\\n      return { groups: [left, right], mode: \"two\" };\\n    }\\n\\n    // -------- 2) Guard tardio: una sola columna visual --------\\n    // Se evalua despues de two/three para evitar falsos \"one\" cuando hay\\n    // dos columnas reales con varios clusters.\\n    if (clusters.length >= 2) {\\n      var cxsOne = clusters.map(function(c){ return c.cx; }).sort(function(a,b){ return a-b; });\\n      var medianCx = percentile(cxsOne, 0.50);\\n      var maxDevCx = 0;\\n      for (var s=0; s<clusters.length; s++) {\\n        var dev = Math.abs((clusters[s].cx || 0) - medianCx);\\n        if (dev > maxDevCx) maxDevCx = dev;\\n      }\\n\\n      var singleColMaxDev = rootW * 0.18;\\n      var looksOneCol = maxDevCx <= singleColMaxDev;\\n      mslLog(\"order:one:candidates\", {\\n        rootW: rootW,\\n        total: clusters.length,\\n        medianCx: +medianCx.toFixed(1),\\n        maxDevCx: +maxDevCx.toFixed(1),\\n        maxAllowed: +singleColMaxDev.toFixed(1),\\n        pass: looksOneCol,\\n        stage: \"postTwoThree\"\\n      });\\n\\n      if (looksOneCol) {\\n        var oneCol = clusters.slice().sort(function(a,b){ return a.top - b.top; });\\n        return { groups: [oneCol], mode: \"one\" };\\n      }\\n    }\\n\\n    // -------- 3) Fallback: filas (top) y dentro por left --------\\n    var sorted = clusters.slice().sort(function(a,b){ return a.top - b.top; });\\n\\n    var rows = [];\\n    for (var r=0;r<sorted.length;r++){\\n      var c3 = sorted[r];\\n      var placed = false;\\n\\n      for (var rr=0; rr<rows.length; rr++){\\n        var row = rows[rr];\\n        if (Math.abs(c3.top - row.top) <= CFG.ROW_TOL){\\n          row.items.push(c3);\\n          row.top = (row.top * (row.items.length - 1) + c3.top) / row.items.length;\\n          placed = true;\\n          break;\\n        }\\n      }\\n\\n      if (!placed) rows.push({ top: c3.top, items: [c3] });\\n    }\\n\\n    rows.sort(function(a,b){ return a.top - b.top; });\\n    rows.forEach(function(row){\\n      row.items.sort(function(a,b){ return a.left - b.left; });\\n    });\\n\\n    function clusterIsText(c){\\n      if (!c || !c.items || !c.items.length) return false;\\n      for (var i2=0; i2<c.items.length; i2++){\\n        if ((c.items[i2].node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\\n      }\\n      return true;\\n    }\\n\\n    var out = [];\\n    var didInterleave = false;\\n    // Caso especial: dos filas simetricas (ej. iconos arriba y textos abajo).\\n    // Reordenamos por columna: top1,bottom1,top2,bottom2,...\\n    if (rows.length === 2 && rows[0].items.length === rows[1].items.length && rows[0].items.length >= 2) {\\n      var topRow = rows[0].items.slice();\\n      var botRow = rows[1].items.slice();\\n      var topHasNonText = topRow.some(function(c){ return !clusterIsText(c); });\\n      var botMostlyText = botRow.filter(function(c){ return clusterIsText(c); }).length >= Math.ceil(botRow.length / 2);\\n\\n      if (topHasNonText && botMostlyText) {\\n        var usedBottom = {};\\n        for (var tr=0; tr<topRow.length; tr++){\\n          var a = topRow[tr];\\n          out.push(a);\\n\\n          var bestIdx = -1;\\n          var bestDist = Infinity;\\n          for (var br=0; br<botRow.length; br++){\\n            if (usedBottom[br]) continue;\\n            var b = botRow[br];\\n            var d = Math.abs((a.left || 0) - (b.left || 0));\\n            if (d < bestDist) {\\n              bestDist = d;\\n              bestIdx = br;\\n            }\\n          }\\n          if (bestIdx >= 0) {\\n            out.push(botRow[bestIdx]);\\n            usedBottom[bestIdx] = true;\\n          }\\n        }\\n        for (var br2=0; br2<botRow.length; br2++){\\n          if (!usedBottom[br2]) out.push(botRow[br2]);\\n        }\\n        didInterleave = true;\\n      }\\n    }\\n\\n    if (!didInterleave) {\\n      rows.forEach(function(row){\\n        for (var z=0; z<row.items.length; z++) out.push(row.items[z]);\\n      });\\n    }\\n    mslLog(\"order:rows:fallback\", {\\n      rows: rows.map(function(r){\\n        return {\\n          top: +r.top.toFixed(1),\\n          len: r.items.length,\\n          lefts: r.items.map(function(it){ return +it.left.toFixed(1); })\\n        };\\n      }),\\n      outLen: out.length,\\n      didInterleave: didInterleave\\n    });\\n\\n    return { groups: [out], mode: \"rows\" };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvb3JkZXJpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8saXNiQXVZUEMsSUFBSTtBQUNOIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXG1vYmlsZVNtYXJ0TGF5b3V0XFxvcmRlcmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L29yZGVyaW5nLnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBqc09yZGVyaW5nQmxvY2soKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFxyXG4gIC8qKlxyXG4gICAqIE9yZGVuYSBDTFVTVEVSUyAobm8gaXRlbXMpIHBhcmEgbGVjdHVyYSBtb2JpbGUuXHJcbiAgICogRGV2dWVsdmUgZ3JvdXBzIChhcnJheSBkZSBjb2x1bW5hcy9ncnVwb3MpIHkgbW9kZS5cclxuICAgKlxyXG4gICAqIC0gdGhyZWU6IFtjb2xMLCBjb2xDLCBjb2xSXVxyXG4gICAqIC0gdHdvOiAgIFtsZWZ0LCByaWdodF1cclxuICAgKiAtIHJvd3M6ICBbb3V0XSAoZmlsYStsZWZ0KVxyXG4gICAqIC0gb25lOiAgIFtzb3J0ZWRUb3BdXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gb3JkZXJDbHVzdGVyc0Zvck1vYmlsZShjbHVzdGVycywgcm9vdFcsIENGRyl7XG4gICAgaWYgKCFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICB2YXIgbyA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtvXSwgbW9kZTogXCJvbmVcIiB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJIYXNUZXh0KGMpe1xuICAgICAgaWYgKCFjIHx8ICFjLml0ZW1zIHx8ICFjLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaVR4dD0wOyBpVHh0PGMuaXRlbXMubGVuZ3RoOyBpVHh0Kyspe1xuICAgICAgICBpZiAoKGMuaXRlbXNbaVR4dF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sdW1uSGFzVGV4dChjb2wpe1xuICAgICAgaWYgKCFjb2wgfHwgIWNvbC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGlDb2w9MDsgaUNvbDxjb2wubGVuZ3RoOyBpQ29sKyspe1xuICAgICAgICBpZiAoY2x1c3Rlckhhc1RleHQoY29sW2lDb2xdKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVW4gY2x1c3RlciBcImludmFkZVwiIHVuYSBmcm9udGVyYSBzaSBxdWVkYSBwYXJ0aWRvIGRlIGZvcm1hIHNpZ25pZmljYXRpdmFcbiAgICAvLyBlbnRyZSBhbWJvcyBsYWRvcyBkZSBsYSBsaW5lYSBkaXZpc29yaWEuXG4gICAgZnVuY3Rpb24gY2x1c3RlckludmFkZXNEaXZpZGVyKGMsIGRpdmlkZXJYKXtcbiAgICAgIGlmICghYykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGxlZnQgPSBOdW1iZXIoYy5sZWZ0IHx8IDApO1xuICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoMCwgTnVtYmVyKGMud2lkdGggfHwgMCkpO1xuICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgaWYgKHdpZHRoIDw9IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChyaWdodCA8PSBkaXZpZGVyWCB8fCBsZWZ0ID49IGRpdmlkZXJYKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBwYXJ0TGVmdCA9IGRpdmlkZXJYIC0gbGVmdDtcbiAgICAgIHZhciBwYXJ0UmlnaHQgPSByaWdodCAtIGRpdmlkZXJYO1xuICAgICAgdmFyIG1pblBhcnQgPSBNYXRoLm1pbihwYXJ0TGVmdCwgcGFydFJpZ2h0KTtcbiAgICAgIHZhciBtaW5SZXF1aXJlZCA9IE1hdGgubWF4KDIyLCB3aWR0aCAqIDAuMjIpO1xuICAgICAgcmV0dXJuIG1pblBhcnQgPj0gbWluUmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2aWRlckludmFzaW9uUmF0aW8obGlzdCwgZGl2aWRlclgpe1xuICAgICAgaWYgKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICB2YXIgaW52YWRlZCA9IDA7XG4gICAgICBmb3IgKHZhciBpSW52PTA7IGlJbnY8bGlzdC5sZW5ndGg7IGlJbnYrKyl7XG4gICAgICAgIGlmIChjbHVzdGVySW52YWRlc0RpdmlkZXIobGlzdFtpSW52XSwgZGl2aWRlclgpKSBpbnZhZGVkKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW52YWRlZCAvIE1hdGgubWF4KDEsIGxpc3QubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLSAwKSBJbnRlbnRhciAzIGNvbHVtbmFzIGNsYXJhcyAtLS0tLS0tLVxuICAgIHZhciB0MSA9IHJvb3RXIC8gMztcbiAgICB2YXIgdDIgPSAoMiAqIHJvb3RXKSAvIDM7XG5cclxuICAgIHZhciBjb2xMID0gW107XHJcbiAgICB2YXIgY29sQyA9IFtdO1xyXG4gICAgdmFyIGNvbFIgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpPTA7aTxjbHVzdGVycy5sZW5ndGg7aSsrKXtcclxuICAgICAgdmFyIGMgPSBjbHVzdGVyc1tpXTtcclxuICAgICAgdmFyIHggPSBjLmN4O1xyXG4gICAgICBpZiAoeCA8IHQxKSBjb2xMLnB1c2goYyk7XHJcbiAgICAgIGVsc2UgaWYgKHggPCB0MikgY29sQy5wdXNoKGMpO1xyXG4gICAgICBlbHNlIGNvbFIucHVzaChjKTtcclxuICAgIH1cclxuXG4gICAgdmFyIGxvb2tzVGhyZWUgPVxuICAgICAgKGNvbEwubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8zICYmIGNvbEMubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8zICYmIGNvbFIubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8zKTtcbiAgICB2YXIgdGV4dENvbHNUaHJlZSA9XG4gICAgICAoY29sdW1uSGFzVGV4dChjb2xMKSA/IDEgOiAwKSArXG4gICAgICAoY29sdW1uSGFzVGV4dChjb2xDKSA/IDEgOiAwKSArXG4gICAgICAoY29sdW1uSGFzVGV4dChjb2xSKSA/IDEgOiAwKTtcbiAgICB2YXIgaGFzVGV4dFNpZ25hbFRocmVlID0gdGV4dENvbHNUaHJlZSA+PSAyO1xuICAgIG1zbExvZyhcIm9yZGVyOnRocmVlOmNhbmRpZGF0ZXNcIiwge1xuICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgIGNvbEw6IGNvbEwubGVuZ3RoLFxuICAgICAgY29sQzogY29sQy5sZW5ndGgsXG4gICAgICBjb2xSOiBjb2xSLmxlbmd0aCxcbiAgICAgIG1pblBlckNvbDM6IENGRy5NSU5fUEVSX0NPTF8zLFxuICAgICAgdGV4dENvbHNUaHJlZTogdGV4dENvbHNUaHJlZSxcbiAgICAgIGhhc1RleHRTaWduYWxUaHJlZTogaGFzVGV4dFNpZ25hbFRocmVlXG4gICAgfSk7XG5cbiAgICBpZiAobG9va3NUaHJlZSkge1xuICAgICAgdmFyIGN4cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaj0wO2o8Y2x1c3RlcnMubGVuZ3RoO2orKykgY3hzLnB1c2goY2x1c3RlcnNbal0uY3gpO1xyXG4gICAgICBjeHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS1iOyB9KTtcclxuICAgICAgdmFyIHAyMCA9IHBlcmNlbnRpbGUoY3hzLCAwLjIwKTtcbiAgICAgIHZhciBwODAgPSBwZXJjZW50aWxlKGN4cywgMC44MCk7XG4gICAgICB2YXIgc3ByZWFkID0gKHA4MCAtIHAyMCk7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTpzcHJlYWRcIiwge1xuICAgICAgICBwMjA6IHAyMCxcbiAgICAgICAgcDgwOiBwODAsXG4gICAgICAgIHNwcmVhZDogc3ByZWFkLFxuICAgICAgICBtaW5TcHJlYWQ6IHJvb3RXICogQ0ZHLlRIUkVFX0NPTF9TUFJFQURfUkFUSU8sXG4gICAgICAgIHBhc3M6IHNwcmVhZCA+PSByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmIChzcHJlYWQgPCByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPKSBsb29rc1RocmVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIHZhciBpbnZhZGVUMSA9IGRpdmlkZXJJbnZhc2lvblJhdGlvKGNsdXN0ZXJzLCB0MSk7XG4gICAgICB2YXIgaW52YWRlVDIgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgdDIpO1xuICAgICAgdmFyIGludmFkZVRocmVlID0gTWF0aC5tYXgoaW52YWRlVDEsIGludmFkZVQyKTtcbiAgICAgIHZhciBpbnZhc2lvbkxpbWl0VGhyZWUgPSBoYXNUZXh0U2lnbmFsVGhyZWUgPyAwLjQ2IDogMC4zNDtcbiAgICAgIG1zbExvZyhcIm9yZGVyOnRocmVlOmludmFzaW9uXCIsIHtcbiAgICAgICAgdDE6ICt0MS50b0ZpeGVkKDEpLFxuICAgICAgICB0MjogK3QyLnRvRml4ZWQoMSksXG4gICAgICAgIGludmFkZVQxOiAraW52YWRlVDEudG9GaXhlZCgzKSxcbiAgICAgICAgaW52YWRlVDI6ICtpbnZhZGVUMi50b0ZpeGVkKDMpLFxuICAgICAgICBpbnZhZGVUaHJlZTogK2ludmFkZVRocmVlLnRvRml4ZWQoMyksXG4gICAgICAgIGxpbWl0OiAraW52YXNpb25MaW1pdFRocmVlLnRvRml4ZWQoMyksXG4gICAgICAgIGhhc1RleHRTaWduYWxUaHJlZTogaGFzVGV4dFNpZ25hbFRocmVlLFxuICAgICAgICBwYXNzOiBpbnZhZGVUaHJlZSA8PSBpbnZhc2lvbkxpbWl0VGhyZWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludmFkZVRocmVlID4gaW52YXNpb25MaW1pdFRocmVlKSBsb29rc1RocmVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIGNvbEwuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICBjb2xDLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgY29sUi5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbY29sTCwgY29sQywgY29sUl0sIG1vZGU6IFwidGhyZWVcIiB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tIDEpIEludGVudGFyIDIgY29sdW1uYXMgY2xhcmFzIC0tLS0tLS0tXG4gICAgdmFyIG1pZCA9IHJvb3RXIC8gMjtcclxuICAgIHZhciBsZWZ0ID0gW107XHJcbiAgICB2YXIgcmlnaHQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBrPTA7azxjbHVzdGVycy5sZW5ndGg7aysrKXtcbiAgICAgIHZhciBjMiA9IGNsdXN0ZXJzW2tdO1xuICAgICAgaWYgKGMyLmN4IDwgbWlkKSBsZWZ0LnB1c2goYzIpO1xuICAgICAgZWxzZSByaWdodC5wdXNoKGMyKTtcbiAgICB9XG5cbiAgICB2YXIgbG9va3NUd28gPSAobGVmdC5sZW5ndGggPj0gQ0ZHLk1JTl9QRVJfQ09MXzIgJiYgcmlnaHQubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8yKTtcbiAgICB2YXIgaGFzVGV4dFNpZ25hbFR3byA9IGNvbHVtbkhhc1RleHQobGVmdCkgJiYgY29sdW1uSGFzVGV4dChyaWdodCk7XG4gICAgbXNsTG9nKFwib3JkZXI6dHdvOmNhbmRpZGF0ZXNcIiwge1xuICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgIGxlZnQ6IGxlZnQubGVuZ3RoLFxuICAgICAgcmlnaHQ6IHJpZ2h0Lmxlbmd0aCxcbiAgICAgIG1pblBlckNvbDI6IENGRy5NSU5fUEVSX0NPTF8yLFxuICAgICAgaGFzVGV4dFNpZ25hbFR3bzogaGFzVGV4dFNpZ25hbFR3b1xuICAgIH0pO1xuXG4gICAgLy8gUG9saXRpY2EgcGFyYSBwYXJlcyAoMiBjbHVzdGVycyk6XG4gICAgLy8gLSBwYXIgZGUgY29sdW1uYXMgcmVhbGVzID0+IG1vZGUgXCJ0d29cIlxuICAgIC8vIC0gcmVzdG8gZGUgY2Fzb3MgPT4gbW9kZSBcIm9uZVwiIChmaXRDaGVjayBkZWNpZGUgc2kgcmVmbG93ZWEpXHJcbiAgICBpZiAoY2x1c3RlcnMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHZhciBjQSA9IGNsdXN0ZXJzWzBdO1xyXG4gICAgICB2YXIgY0IgPSBjbHVzdGVyc1sxXTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHBhaXJTdGF0cyhjKXtcclxuICAgICAgICB2YXIgdGV4dCA9IDA7XHJcbiAgICAgICAgdmFyIG5vbiA9IDA7XHJcbiAgICAgICAgdmFyIGZvcmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBxPTA7IHE8Yy5pdGVtcy5sZW5ndGg7IHErKykge1xyXG4gICAgICAgICAgdmFyIG4gPSBjLml0ZW1zW3FdLm5vZGU7XHJcbiAgICAgICAgICBpZiAoKG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIpID09PSBcImZvcmNlXCIpIGZvcmNlKys7XHJcbiAgICAgICAgICBpZiAoKG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHQrKztcclxuICAgICAgICAgIGVsc2Ugbm9uKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHRleHQ6IHRleHQsIG5vbjogbm9uLCBmb3JjZTogZm9yY2UgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNBID0gcGFpclN0YXRzKGNBKTtcclxuICAgICAgdmFyIHNCID0gcGFpclN0YXRzKGNCKTtcclxuXHJcbiAgICAgIHZhciB0b3BEZWx0YSA9IE1hdGguYWJzKChjQS50b3AgfHwgMCkgLSAoY0IudG9wIHx8IDApKTtcbiAgICAgIHZhciB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKChjQS5sZWZ0ICsgY0Eud2lkdGgpLCAoY0IubGVmdCArIGNCLndpZHRoKSkgLSBNYXRoLm1heChjQS5sZWZ0LCBjQi5sZWZ0KSk7XG4gICAgICB2YXIgbWluV1BhaXIgPSBNYXRoLm1heCgxLCBNYXRoLm1pbigoY0Eud2lkdGggfHwgMCksIChjQi53aWR0aCB8fCAwKSkpO1xuICAgICAgdmFyIHhPdmVybGFwUmF0aW8gPSB4T3ZlcmxhcCAvIG1pbldQYWlyO1xuICAgICAgdmFyIHNpZGVCeVNpZGUgPSB0b3BEZWx0YSA8PSAoQ0ZHLlJPV19UT0wgKiAxLjUpICYmIHhPdmVybGFwUmF0aW8gPCAwLjI1O1xuICAgICAgdmFyIHBhaXJJbnZhc2lvbiA9IGRpdmlkZXJJbnZhc2lvblJhdGlvKFtjQSwgY0JdLCBtaWQpO1xuICAgICAgdmFyIHBhaXJJbnZhc2lvbkxpbWl0ID0gaGFzVGV4dFNpZ25hbFR3byA/IDAuNSA6IDAuMzQ7XG5cbiAgICAgIHZhciBhbnlGb3JjZUNlbnRlciA9IChzQS5mb3JjZSA+IDAgfHwgc0IuZm9yY2UgPiAwKTtcbiAgICAgIHZhciBib3RoTWl4ZWQgPSAoc0EudGV4dCA+IDAgJiYgc0Eubm9uID4gMCAmJiBzQi50ZXh0ID4gMCAmJiBzQi5ub24gPiAwKTtcbiAgICAgIC8vIFNlw7FhbCByb2J1c3RhIGRlIFwicGFyIGRlIGNvbHVtbmFzXCI6XG4gICAgICAvLyAtIGVzdMOhbiBsYWRvIGEgbGFkbyB5IHBhc2FuIHNwbGl0IGxlZnQvcmlnaHRcbiAgICAgIC8vIC0geSBhZGVtw6FzIG5vIHNvbiBzaW1wbGVtZW50ZSAyIHRleHRvcyBzdWVsdG9zIGVuIHVuYSBmaWxhXG4gICAgICB2YXIgaGFzQ29sdW1uU2lnbmFsID1cbiAgICAgICAgKHNBLm5vbiA+IDAgfHwgc0Iubm9uID4gMCkgfHxcbiAgICAgICAgKChjQS5pdGVtcyAmJiBjQS5pdGVtcy5sZW5ndGggPiAxKSB8fCAoY0IuaXRlbXMgJiYgY0IuaXRlbXMubGVuZ3RoID4gMSkpO1xuXG4gICAgICBpZiAobG9va3NUd28gJiYgc2lkZUJ5U2lkZSAmJiBoYXNDb2x1bW5TaWduYWwgJiYgcGFpckludmFzaW9uIDw9IHBhaXJJbnZhc2lvbkxpbWl0KSB7XG4gICAgICAgIHZhciBsZWZ0UGFpciA9IChjQS5jeCA8PSBjQi5jeCkgPyBbY0FdIDogW2NCXTtcbiAgICAgICAgdmFyIHJpZ2h0UGFpciA9IChjQS5jeCA8PSBjQi5jeCkgPyBbY0JdIDogW2NBXTtcbiAgICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnBhaXJQb2xpY3lcIiwge1xuICAgICAgICAgIG1vZGU6IFwidHdvXCIsXG4gICAgICAgICAgcmVhc29uOiBcInBhaXJDb2x1bW5zXCIsXG4gICAgICAgICAgdG9wRGVsdGE6ICt0b3BEZWx0YS50b0ZpeGVkKDEpLFxuICAgICAgICAgIHhPdmVybGFwUmF0aW86ICt4T3ZlcmxhcFJhdGlvLnRvRml4ZWQoMyksXG4gICAgICAgICAgaGFzQ29sdW1uU2lnbmFsOiBoYXNDb2x1bW5TaWduYWwsXG4gICAgICAgICAgYm90aE1peGVkOiBib3RoTWl4ZWQsXG4gICAgICAgICAgYW55Rm9yY2VDZW50ZXI6IGFueUZvcmNlQ2VudGVyLFxuICAgICAgICAgIHBhaXJJbnZhc2lvbjogK3BhaXJJbnZhc2lvbi50b0ZpeGVkKDMpLFxuICAgICAgICAgIHBhaXJJbnZhc2lvbkxpbWl0OiArcGFpckludmFzaW9uTGltaXQudG9GaXhlZCgzKSxcbiAgICAgICAgICBsZWZ0czogWysoY0EubGVmdCB8fCAwKS50b0ZpeGVkKDEpLCArKGNCLmxlZnQgfHwgMCkudG9GaXhlZCgxKV1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGdyb3VwczogW2xlZnRQYWlyLCByaWdodFBhaXJdLCBtb2RlOiBcInR3b1wiIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWlyID0gY2x1c3RlcnMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGEudG9wIC0gYi50b3ApID4gMC41KSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICB9KTtcclxuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnBhaXJQb2xpY3lcIiwge1xyXG4gICAgICAgIG1vZGU6IFwib25lXCIsXHJcbiAgICAgICAgcmVhc29uOiBhbnlGb3JjZUNlbnRlciA/IFwiZm9yY2VDZW50ZXJQYWlyXCIgOiBcInBhaXJEZWZhdWx0XCIsXHJcbiAgICAgICAgdG9wRGVsdGE6ICt0b3BEZWx0YS50b0ZpeGVkKDEpLFxyXG4gICAgICAgIHhPdmVybGFwUmF0aW86ICt4T3ZlcmxhcFJhdGlvLnRvRml4ZWQoMyksXG4gICAgICAgIHNpZGVCeVNpZGU6IHNpZGVCeVNpZGUsXG4gICAgICAgIGJvdGhNaXhlZDogYm90aE1peGVkLFxuICAgICAgICBhbnlGb3JjZUNlbnRlcjogYW55Rm9yY2VDZW50ZXIsXG4gICAgICAgIHBhaXJJbnZhc2lvbjogK3BhaXJJbnZhc2lvbi50b0ZpeGVkKDMpLFxuICAgICAgICBwYWlySW52YXNpb25MaW1pdDogK3BhaXJJbnZhc2lvbkxpbWl0LnRvRml4ZWQoMyksXG4gICAgICAgIHRvcHM6IHBhaXIubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MudG9wLnRvRml4ZWQoMSk7IH0pLFxuICAgICAgICBsZWZ0czogcGFpci5tYXAoZnVuY3Rpb24oYyl7IHJldHVybiArYy5sZWZ0LnRvRml4ZWQoMSk7IH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IGdyb3VwczogW3BhaXJdLCBtb2RlOiBcIm9uZVwiIH07XG4gICAgfVxyXG4gICAgaWYgKGxvb2tzVHdvKSB7XHJcbiAgICAgIHZhciBjeHMyID0gW107XHJcbiAgICAgIGZvciAodmFyIG09MDttPGNsdXN0ZXJzLmxlbmd0aDttKyspIGN4czIucHVzaChjbHVzdGVyc1ttXS5jeCk7XHJcbiAgICAgIGN4czIuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS1iOyB9KTtcclxuICAgICAgdmFyIHAyNSA9IHBlcmNlbnRpbGUoY3hzMiwgMC4yNSk7XG4gICAgICB2YXIgcDc1ID0gcGVyY2VudGlsZShjeHMyLCAwLjc1KTtcbiAgICAgIHZhciBzcHJlYWQyID0gKHA3NSAtIHAyNSk7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0d286c3ByZWFkXCIsIHtcbiAgICAgICAgcDI1OiBwMjUsXG4gICAgICAgIHA3NTogcDc1LFxuICAgICAgICBzcHJlYWQ6IHNwcmVhZDIsXG4gICAgICAgIG1pblNwcmVhZDogcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU8sXG4gICAgICAgIHBhc3M6IHNwcmVhZDIgPj0gcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU9cbiAgICAgIH0pO1xuICAgICAgaWYgKHNwcmVhZDIgPCByb290VyAqIENGRy5UV09fQ09MX1NQUkVBRF9SQVRJTykgbG9va3NUd28gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobG9va3NUd28pIHtcbiAgICAgIHZhciBpbnZhZGVNaWQgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgbWlkKTtcbiAgICAgIHZhciBpbnZhc2lvbkxpbWl0VHdvID0gaGFzVGV4dFNpZ25hbFR3byA/IDAuNDggOiAwLjM0O1xuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOmludmFzaW9uXCIsIHtcbiAgICAgICAgbWlkOiArbWlkLnRvRml4ZWQoMSksXG4gICAgICAgIGludmFkZU1pZDogK2ludmFkZU1pZC50b0ZpeGVkKDMpLFxuICAgICAgICBsaW1pdDogK2ludmFzaW9uTGltaXRUd28udG9GaXhlZCgzKSxcbiAgICAgICAgaGFzVGV4dFNpZ25hbFR3bzogaGFzVGV4dFNpZ25hbFR3byxcbiAgICAgICAgcGFzczogaW52YWRlTWlkIDw9IGludmFzaW9uTGltaXRUd29cbiAgICAgIH0pO1xuICAgICAgaWYgKGludmFkZU1pZCA+IGludmFzaW9uTGltaXRUd28pIGxvb2tzVHdvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVHdvKSB7XG4gICAgICBsZWZ0LnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmlnaHQuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtsZWZ0LCByaWdodF0sIG1vZGU6IFwidHdvXCIgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLSAyKSBHdWFyZCB0YXJkaW86IHVuYSBzb2xhIGNvbHVtbmEgdmlzdWFsIC0tLS0tLS0tXG4gICAgLy8gU2UgZXZhbHVhIGRlc3B1ZXMgZGUgdHdvL3RocmVlIHBhcmEgZXZpdGFyIGZhbHNvcyBcIm9uZVwiIGN1YW5kbyBoYXlcbiAgICAvLyBkb3MgY29sdW1uYXMgcmVhbGVzIGNvbiB2YXJpb3MgY2x1c3RlcnMuXG4gICAgaWYgKGNsdXN0ZXJzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgY3hzT25lID0gY2x1c3RlcnMubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gYy5jeDsgfSkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS1iOyB9KTtcbiAgICAgIHZhciBtZWRpYW5DeCA9IHBlcmNlbnRpbGUoY3hzT25lLCAwLjUwKTtcbiAgICAgIHZhciBtYXhEZXZDeCA9IDA7XG4gICAgICBmb3IgKHZhciBzPTA7IHM8Y2x1c3RlcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdmFyIGRldiA9IE1hdGguYWJzKChjbHVzdGVyc1tzXS5jeCB8fCAwKSAtIG1lZGlhbkN4KTtcbiAgICAgICAgaWYgKGRldiA+IG1heERldkN4KSBtYXhEZXZDeCA9IGRldjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbmdsZUNvbE1heERldiA9IHJvb3RXICogMC4xODtcbiAgICAgIHZhciBsb29rc09uZUNvbCA9IG1heERldkN4IDw9IHNpbmdsZUNvbE1heERldjtcbiAgICAgIG1zbExvZyhcIm9yZGVyOm9uZTpjYW5kaWRhdGVzXCIsIHtcbiAgICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgICB0b3RhbDogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBtZWRpYW5DeDogK21lZGlhbkN4LnRvRml4ZWQoMSksXG4gICAgICAgIG1heERldkN4OiArbWF4RGV2Q3gudG9GaXhlZCgxKSxcbiAgICAgICAgbWF4QWxsb3dlZDogK3NpbmdsZUNvbE1heERldi50b0ZpeGVkKDEpLFxuICAgICAgICBwYXNzOiBsb29rc09uZUNvbCxcbiAgICAgICAgc3RhZ2U6IFwicG9zdFR3b1RocmVlXCJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobG9va3NPbmVDb2wpIHtcbiAgICAgICAgdmFyIG9uZUNvbCA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICAgIHJldHVybiB7IGdyb3VwczogW29uZUNvbF0sIG1vZGU6IFwib25lXCIgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLSAzKSBGYWxsYmFjazogZmlsYXMgKHRvcCkgeSBkZW50cm8gcG9yIGxlZnQgLS0tLS0tLS1cbiAgICB2YXIgc29ydGVkID0gY2x1c3RlcnMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuXHJcbiAgICB2YXIgcm93cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgcj0wO3I8c29ydGVkLmxlbmd0aDtyKyspe1xyXG4gICAgICB2YXIgYzMgPSBzb3J0ZWRbcl07XHJcbiAgICAgIHZhciBwbGFjZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAodmFyIHJyPTA7IHJyPHJvd3MubGVuZ3RoOyBycisrKXtcclxuICAgICAgICB2YXIgcm93ID0gcm93c1tycl07XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGMzLnRvcCAtIHJvdy50b3ApIDw9IENGRy5ST1dfVE9MKXtcclxuICAgICAgICAgIHJvdy5pdGVtcy5wdXNoKGMzKTtcclxuICAgICAgICAgIHJvdy50b3AgPSAocm93LnRvcCAqIChyb3cuaXRlbXMubGVuZ3RoIC0gMSkgKyBjMy50b3ApIC8gcm93Lml0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgIHBsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcGxhY2VkKSByb3dzLnB1c2goeyB0b3A6IGMzLnRvcCwgaXRlbXM6IFtjM10gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcm93cy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpe1xyXG4gICAgICByb3cuaXRlbXMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0OyB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJJc1RleHQoYyl7XG4gICAgICBpZiAoIWMgfHwgIWMuaXRlbXMgfHwgIWMuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpMj0wOyBpMjxjLml0ZW1zLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgIGlmICgoYy5pdGVtc1tpMl0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpICE9PSBcIjFcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBkaWRJbnRlcmxlYXZlID0gZmFsc2U7XG4gICAgLy8gQ2FzbyBlc3BlY2lhbDogZG9zIGZpbGFzIHNpbWV0cmljYXMgKGVqLiBpY29ub3MgYXJyaWJhIHkgdGV4dG9zIGFiYWpvKS5cbiAgICAvLyBSZW9yZGVuYW1vcyBwb3IgY29sdW1uYTogdG9wMSxib3R0b20xLHRvcDIsYm90dG9tMiwuLi5cbiAgICBpZiAocm93cy5sZW5ndGggPT09IDIgJiYgcm93c1swXS5pdGVtcy5sZW5ndGggPT09IHJvd3NbMV0uaXRlbXMubGVuZ3RoICYmIHJvd3NbMF0uaXRlbXMubGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciB0b3BSb3cgPSByb3dzWzBdLml0ZW1zLnNsaWNlKCk7XG4gICAgICB2YXIgYm90Um93ID0gcm93c1sxXS5pdGVtcy5zbGljZSgpO1xuICAgICAgdmFyIHRvcEhhc05vblRleHQgPSB0b3BSb3cuc29tZShmdW5jdGlvbihjKXsgcmV0dXJuICFjbHVzdGVySXNUZXh0KGMpOyB9KTtcbiAgICAgIHZhciBib3RNb3N0bHlUZXh0ID0gYm90Um93LmZpbHRlcihmdW5jdGlvbihjKXsgcmV0dXJuIGNsdXN0ZXJJc1RleHQoYyk7IH0pLmxlbmd0aCA+PSBNYXRoLmNlaWwoYm90Um93Lmxlbmd0aCAvIDIpO1xuXG4gICAgICBpZiAodG9wSGFzTm9uVGV4dCAmJiBib3RNb3N0bHlUZXh0KSB7XG4gICAgICAgIHZhciB1c2VkQm90dG9tID0ge307XG4gICAgICAgIGZvciAodmFyIHRyPTA7IHRyPHRvcFJvdy5sZW5ndGg7IHRyKyspe1xuICAgICAgICAgIHZhciBhID0gdG9wUm93W3RyXTtcbiAgICAgICAgICBvdXQucHVzaChhKTtcblxuICAgICAgICAgIHZhciBiZXN0SWR4ID0gLTE7XG4gICAgICAgICAgdmFyIGJlc3REaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgZm9yICh2YXIgYnI9MDsgYnI8Ym90Um93Lmxlbmd0aDsgYnIrKyl7XG4gICAgICAgICAgICBpZiAodXNlZEJvdHRvbVticl0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGIgPSBib3RSb3dbYnJdO1xuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLmFicygoYS5sZWZ0IHx8IDApIC0gKGIubGVmdCB8fCAwKSk7XG4gICAgICAgICAgICBpZiAoZCA8IGJlc3REaXN0KSB7XG4gICAgICAgICAgICAgIGJlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgYmVzdElkeCA9IGJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmVzdElkeCA+PSAwKSB7XG4gICAgICAgICAgICBvdXQucHVzaChib3RSb3dbYmVzdElkeF0pO1xuICAgICAgICAgICAgdXNlZEJvdHRvbVtiZXN0SWR4XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGJyMj0wOyBicjI8Ym90Um93Lmxlbmd0aDsgYnIyKyspe1xuICAgICAgICAgIGlmICghdXNlZEJvdHRvbVticjJdKSBvdXQucHVzaChib3RSb3dbYnIyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlkSW50ZXJsZWF2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkaWRJbnRlcmxlYXZlKSB7XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KXtcbiAgICAgICAgZm9yICh2YXIgej0wOyB6PHJvdy5pdGVtcy5sZW5ndGg7IHorKykgb3V0LnB1c2gocm93Lml0ZW1zW3pdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtc2xMb2coXCJvcmRlcjpyb3dzOmZhbGxiYWNrXCIsIHtcbiAgICAgIHJvd3M6IHJvd3MubWFwKGZ1bmN0aW9uKHIpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogK3IudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgbGVuOiByLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0czogci5pdGVtcy5tYXAoZnVuY3Rpb24oaXQpeyByZXR1cm4gK2l0LmxlZnQudG9GaXhlZCgxKTsgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgb3V0TGVuOiBvdXQubGVuZ3RoLFxuICAgICAgZGlkSW50ZXJsZWF2ZTogZGlkSW50ZXJsZWF2ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgZ3JvdXBzOiBbb3V0XSwgbW9kZTogXCJyb3dzXCIgfTtcbiAgfVxyXG5gLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsianNPcmRlcmluZ0Jsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts":
/*!*****************************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/scriptTemplate.ts ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* binding */ buildScript)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts\");\n/* harmony import */ var _fitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitScale */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts\");\n/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordering */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts\");\n/* harmony import */ var _stacking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacking */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts\");\n// functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n\n\n\n\nfunction buildScript(cfg) {\n    if (!cfg.enabled) return \"\";\n    return '\\n<script>\\n(function(){\\n  var ENABLED = true;\\n  function readDebugFlag(name){\\n    try {\\n      var search = (window.location && window.location.search) ? window.location.search : \"\";\\n      var qp = new URLSearchParams(search);\\n      var qv = qp.get(name);\\n      if (qv === \"1\" || String(qv).toLowerCase() === \"true\") return true;\\n    } catch(_e1) {}\\n\\n    // srcDoc/about:srcdoc no suele tener querystring.\\n    try {\\n      if (window.parent && window.parent !== window && window.parent.location) {\\n        var pSearch = window.parent.location.search || \"\";\\n        var pQ = new URLSearchParams(pSearch);\\n        var pV = pQ.get(name);\\n        if (pV === \"1\" || String(pV).toLowerCase() === \"true\") return true;\\n      }\\n    } catch(_e2) {}\\n\\n    try {\\n      if (window.top && window.top !== window && window.top.location) {\\n        var tSearch = window.top.location.search || \"\";\\n        var tQ = new URLSearchParams(tSearch);\\n        var tV = tQ.get(name);\\n        if (tV === \"1\" || String(tV).toLowerCase() === \"true\") return true;\\n      }\\n    } catch(_e3) {}\\n\\n    try {\\n      var ls = window.localStorage ? window.localStorage.getItem(name) : null;\\n      if (ls === \"1\" || String(ls).toLowerCase() === \"true\") return true;\\n    } catch(_e4) {}\\n\\n    return false;\\n  }\\n  var MSL_DEBUG = readDebugFlag(\"mslDebug\");\\n  var MSL_VERBOSE = readDebugFlag(\"mslVerbose\");\\n  function dbg(label, payload){\\n    if (!MSL_DEBUG) return;\\n    if (arguments.length <= 1) {\\n      console.log(\"[MSL] \" + label);\\n      return;\\n    }\\n    if (typeof payload === \"string\") {\\n      console.log(\"[MSL] \" + label + \" \" + payload);\\n      return;\\n    }\\n    var pretty = \"\";\\n    try {\\n      pretty = JSON.stringify(payload, null, 2);\\n    } catch(e) {\\n      try { pretty = String(payload); } catch(_) { pretty = \"[unserializable]\"; }\\n    }\\n    console.log(\"[MSL] \" + label + \"\\\\n\" + pretty);\\n  }\\n  function mslLog(){\\n    if (!MSL_DEBUG) return;\\n    var args = Array.prototype.slice.call(arguments);\\n    if (!args.length) return;\\n    var label = String(args[0]);\\n    if (!MSL_VERBOSE) {\\n      var noisy = {\\n        \"section:nodeSources\": 1,\\n        \"section:baselineRestore\": 1,\\n        \"section:anchorSplit\": 1,\\n        \"section:clusters\": 1,\\n        \"order:three:candidates\": 1,\\n        \"order:three:spread\": 1,\\n        \"order:two:candidates\": 1,\\n        \"order:two:spread\": 1,\\n        \"order:one:candidates\": 1,\\n        \"order:rows:fallback\": 1\\n      };\\n      if (noisy[label]) return;\\n    }\\n    if (args.length === 1) {\\n      dbg(label);\\n      return;\\n    }\\n    if (args.length === 2) {\\n      dbg(label, args[1]);\\n      return;\\n    }\\n    dbg(label, args.slice(1));\\n  }\\n\\n  var CFG = {\\n    MIN_GAP: '.concat(cfg.minGapPx, \",\\n    MAX_GAP: \").concat(cfg.maxGapPx, \",\\n    GAP_SCALE: \").concat(cfg.gapScale, \",\\n\\n    PAD_TOP: \").concat(cfg.paddingTopPx, \",\\n    PAD_BOT: \").concat(cfg.paddingBottomPx, \",\\n\\n    ONLY_FIXED: \").concat(cfg.onlyFixedSections ? \"true\" : \"false\", \",\\n    ONLY_WHEN_REORDERED: \").concat(cfg.onlyWhenReordered ? \"true\" : \"false\", \",\\n\\n    ROW_TOL: \").concat(cfg.rowTolPx, \",\\n\\n    TWO_COL_SPREAD_RATIO: \").concat(cfg.twoColSpreadRatio, \",\\n    MIN_PER_COL_2: \").concat(cfg.minPerColumn2, \",\\n\\n    THREE_COL_SPREAD_RATIO: \").concat(cfg.threeColSpreadRatio, \",\\n    MIN_PER_COL_3: \").concat(cfg.minPerColumn3, \",\\n\\n    FIT_MIN_SCALE: \").concat(cfg.fitMinScale, \",\\n    FIT_MAX_SCALE: \").concat(cfg.fitMaxScale, \",\\n    FIT_TARGET_WIDTH_RATIO: \").concat(cfg.fitTargetWidthRatio, \",\\n    FIT_MIN_FILL_RATIO: \").concat(cfg.fitMinFillRatio, \"\\n  };\\n\\n  \").concat((0,_dom__WEBPACK_IMPORTED_MODULE_0__.jsDomHelpersBlock)(), \"\\n\\n  \").concat((0,_ordering__WEBPACK_IMPORTED_MODULE_2__.jsOrderingBlock)(), \"\\n\\n  \").concat((0,_stacking__WEBPACK_IMPORTED_MODULE_3__.jsStackingBlock)(), \"\\n\\n  \").concat((0,_fitScale__WEBPACK_IMPORTED_MODULE_1__.jsFitScaleBlock)(), '\\n\\n  function expandFixedSection(sec, neededHeight){\\n    var currentH = sec.getBoundingClientRect().height || 0;\\n    if (neededHeight > currentH + 1) {\\n      sec.style.height = Math.ceil(neededHeight) + \"px\";\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function shouldProcessSection(sec){\\n    if(!sec) return false;\\n    if(!CFG.ONLY_FIXED) return true;\\n    var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n    return modo === \"fijo\";\\n  }\\n\\n  function runOnce(){\\n    if(!ENABLED) return;\\n    if(!isMobile()) {\\n      Array.from(document.querySelectorAll(\".sec\")).forEach(function(sec){\\n        var content = sec.querySelector(\".sec-content\");\\n        if(!content) return;\\n        var bleed = sec.querySelector(\".sec-bleed\");\\n        resetSectionFitScale(sec, content, bleed);\\n        sec.setAttribute(\"data-msl-fit-scale\", \"1\");\\n      });\\n      return;\\n    }\\n\\n    var secs = Array.from(document.querySelectorAll(\".sec\"));\\n    if(!secs.length) return;\\n\\n    secs.forEach(function(sec){\\n      var secIndex = secs.indexOf(sec);\\n      var secModo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n      var allowReflow = shouldProcessSection(sec);\\n      mslLog(\"section:start\", { secIndex: secIndex, modo: secModo, allowReflow: allowReflow });\\n\\n      var content = sec.querySelector(\".sec-content\");\\n      if(!content) return;\\n      var bleed = sec.querySelector(\".sec-bleed\");\\n      resetSectionFitScale(sec, content, bleed);\\n      var nodesAll = getObjNodes(sec);\\n\\n      var reflowElementsDump = [];\\n      function buildReflowElementsDump(items, contentWNow){\\n        if (!MSL_DEBUG) return;\\n        var list = (items || []);\\n        var maxItems = 120;\\n        var out = [];\\n        for (var iDump=0; iDump<list.length && iDump<maxItems; iDump++){\\n          var itDump = list[iDump];\\n          if (!itDump || !itDump.node) continue;\\n          var nDump = itDump.node;\\n          var textRaw = ((nDump.textContent || \"\").trim()).replace(/s+/g, \" \");\\n          var isTextDump = (nDump.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          var clsDump = (nDump.className && typeof nDump.className === \"string\") ? nDump.className : \"\";\\n          var rootZone = (nDump.closest && nDump.closest(\".sec-bleed\")) ? \"bleed\" : \"content\";\\n          out.push({\\n            i: iDump,\\n            kind: isTextDump ? \"texto\" : String((nDump.tagName || \"\").toLowerCase()),\\n            zone: rootZone,\\n            top: +Number(itDump.top || 0).toFixed(1),\\n            left: +Number(itDump.left || 0).toFixed(1),\\n            w: +Number(itDump.width || 0).toFixed(1),\\n            h: +Number(itDump.height || 0).toFixed(1),\\n            right: +Number((itDump.left || 0) + (itDump.width || 0)).toFixed(1),\\n            bottom: +Number((itDump.top || 0) + (itDump.height || 0)).toFixed(1),\\n            cx: +Number((itDump.left || 0) + ((itDump.width || 0) / 2)).toFixed(1),\\n            wRatio: contentWNow > 1 ? +Number((itDump.width || 0) / contentWNow).toFixed(3) : null,\\n            className: clsDump,\\n            mobileLayout: nDump.getAttribute(\"data-mobile-layout\") || \"\",\\n            mobileRole: nDump.getAttribute(\"data-mobile-role\") || \"\",\\n            mobileCluster: nDump.getAttribute(\"data-mobile-cluster\") || \"\",\\n            mobileClusterId: nDump.getAttribute(\"data-mobile-cluster-id\") || \"\",\\n            mobileCenter: nDump.getAttribute(\"data-mobile-center\") || \"\",\\n            mobileAlign: nDump.getAttribute(\"data-mobile-align\") || \"\",\\n            mobileFit: nDump.getAttribute(\"data-mobile-fit\") || \"\",\\n            textAlign: (nDump.style && nDump.style.textAlign) ? nDump.style.textAlign : \"\",\\n            textSample: isTextDump ? textRaw.slice(0, 90) : \"\"\\n          });\\n        }\\n        reflowElementsDump = out;\\n      }\\n\\n      function logReflowDecision(reason, extra){\\n        if (!MSL_DEBUG) return;\\n        var payload = {\\n          secIndex: secIndex,\\n          secModo: secModo,\\n          allowReflow: allowReflow,\\n          totalNodes: (nodesAll || []).length,\\n          reason: String(reason || \"\"),\\n          details: extra || {}\\n        };\\n        mslLog(\"section:reflow:decision\", payload);\\n      }\\n\\n      function finalizeSection(minNeededHeight, preserveBottomGap){\\n        var gap = Number.isFinite(preserveBottomGap) ? Math.max(0, Number(preserveBottomGap)) : 0;\\n        var fit = applySectionFitScale(\\n          sec,\\n          content,\\n          bleed,\\n          nodesAll,\\n          secModo,\\n          CFG,\\n          { secIndex: secIndex },\\n          { preserveBottomGap: gap }\\n        );\\n        var fitNeeded = (fit && Number.isFinite(fit.neededHeight)) ? Number(fit.neededHeight) : 0;\\n        var neededHeight = Math.max(Number(minNeededHeight || 0), fitNeeded);\\n        mslLog(\"section:heightFinal\", {\\n          secIndex: secIndex,\\n          mode: secModo,\\n          minNeededHeight: +Number(minNeededHeight || 0).toFixed(1),\\n          fitNeededHeight: +fitNeeded.toFixed(1),\\n          preserveBottomGap: +gap.toFixed(1),\\n          finalNeededHeight: +neededHeight.toFixed(1)\\n        });\\n        if (secModo === \"fijo\" && neededHeight > 0) {\\n          expandFixedSection(sec, neededHeight);\\n        }\\n      }\\n\\n      if(!nodesAll.length) {\\n        logReflowDecision(\"skip:noNodes\", { willApplyReflow: false });\\n        finalizeSection(0, 0);\\n        return;\\n      }\\n\\n      var debugCounts = {\\n        secIndex: secIndex,\\n        contentObj: content ? content.querySelectorAll(\".objeto\").length : 0,\\n        bleedObj: bleed ? bleed.querySelectorAll(\".objeto\").length : 0,\\n        contentAbs: content ? Array.from(content.querySelectorAll(\"*\")).filter(function(el){\\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\\n        }).length : 0,\\n        bleedAbs: bleed ? Array.from(bleed.querySelectorAll(\"*\")).filter(function(el){\\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\\n        }).length : 0\\n      };\\n      mslLog(\"section:nodeSources\", debugCounts);\\n\\n      if (MSL_VERBOSE) {\\n        mslLog(\"section:nodesAll:raw\", {\\n          secIndex: secIndex,\\n          total: nodesAll.length,\\n          nodes: nodesAll.map(function(n, i){\\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\\n            var parentCls = (n.parentElement && n.parentElement.className && typeof n.parentElement.className === \"string\")\\n              ? n.parentElement.className\\n              : \"\";\\n            return {\\n              i: i,\\n              tag: (n.tagName || \"\").toLowerCase(),\\n              cls: cls,\\n              parentCls: parentCls,\\n              top: n.style ? n.style.top : \"\",\\n              left: n.style ? n.style.left : \"\",\\n              pos: n.style ? n.style.position : \"\",\\n              text: ((n.textContent || \"\").trim()).slice(0, 40)\\n            };\\n          })\\n        });\\n        try {\\n          var flat = nodesAll.map(function(n, i){\\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\\n            var txt = ((n.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 60);\\n            return \"#\" + i\\n              + \" tag=\" + String((n.tagName || \"\").toLowerCase())\\n              + \" cls=\" + cls\\n              + \" pos=\" + (n.style ? n.style.position : \"\")\\n              + \" top=\" + (n.style ? n.style.top : \"\")\\n              + \" left=\" + (n.style ? n.style.left : \"\")\\n              + \" text=\" + txt;\\n          });\\n          mslLog(\"section:nodesAll:flat\", \"sec=\" + secIndex + \" total=\" + nodesAll.length + \" :: \" + flat.join(\" | \"));\\n        } catch(e) {}\\n      }\\n      var restoredCount = 0;\\n      nodesAll.forEach(function(node){\\n        var hasOrigTop = node.hasAttribute(\"data-msl-orig-top\");\\n        var hasOrigLeft = node.hasAttribute(\"data-msl-orig-left\");\\n        var hasOrigTransform = node.hasAttribute(\"data-msl-orig-transform\");\\n        if (!hasOrigTop) node.setAttribute(\"data-msl-orig-top\", node.style.top || \"\");\\n        if (!hasOrigLeft) node.setAttribute(\"data-msl-orig-left\", node.style.left || \"\");\\n        if (!hasOrigTransform) node.setAttribute(\"data-msl-orig-transform\", node.style.transform || \"\");\\n\\n        var origTop = node.getAttribute(\"data-msl-orig-top\");\\n        var origLeft = node.getAttribute(\"data-msl-orig-left\");\\n        var origTransform = node.getAttribute(\"data-msl-orig-transform\");\\n\\n        if (origTop != null && node.style.top !== origTop) {\\n          node.style.top = origTop;\\n          restoredCount++;\\n        }\\n        if (origLeft != null && node.style.left !== origLeft) {\\n          node.style.left = origLeft;\\n          restoredCount++;\\n        }\\n        if (origTransform != null && node.style.transform !== origTransform) {\\n          node.style.transform = origTransform;\\n          restoredCount++;\\n        }\\n        node.style.right = \"auto\";\\n        node.style.marginLeft = \"0px\";\\n      });\\n      mslLog(\"section:baselineRestore\", { secIndex: secIndex, nodes: nodesAll.length, restored: restoredCount });\\n\\n      // Rect del content (m\\xe9tricas reales)\\n      var contentRect = content.getBoundingClientRect();\\n      var contentW = contentRect.width || 0;\\n      var secCurrentH = sec.getBoundingClientRect().height || 0;\\n      var baseHeightAttr = \"data-msl-base-height\";\\n      if (!sec.hasAttribute(baseHeightAttr)) {\\n        sec.setAttribute(baseHeightAttr, String(secCurrentH));\\n      }\\n      var baseSecHeight = parseFloat(sec.getAttribute(baseHeightAttr) || \"\");\\n      if (!isFinite(baseSecHeight) || baseSecHeight <= 0) baseSecHeight = secCurrentH;\\n\\n      // items (rects) en coordenadas del content (TODOS)\\n      var itemsAll = nodesAll.map(function(node){\\n        var rc = relRect(node, content);\\n        return {\\n          node: node,\\n          top: rc.top,\\n          left: rc.left,\\n          height: rc.height,\\n          width: rc.width\\n        };\\n      });\\n      buildReflowElementsDump(itemsAll, contentW);\\n      mslLog(\"section:reflow:elements\", {\\n        secIndex: secIndex,\\n        secModo: secModo,\\n        contentW: +Number(contentW || 0).toFixed(1),\\n        total: reflowElementsDump.length,\\n        elements: reflowElementsDump\\n      });\\n      if (MSL_VERBOSE) {\\n        mslLog(\"section:itemsAll\", {\\n          secIndex: secIndex,\\n          total: itemsAll.length,\\n          items: itemsAll.map(function(it, idx){\\n            return {\\n              i: idx,\\n              kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\\n              top: +it.top.toFixed(1),\\n              left: +it.left.toFixed(1),\\n              w: +it.width.toFixed(1),\\n              h: +it.height.toFixed(1),\\n              textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\\n            };\\n          })\\n        });\\n      }\\n\\n      // Preservar el \"aire\" inferior original de la seccion tras el reflow.\\n      var maxOriginalBottom = 0;\\n      for (var ib=0; ib<itemsAll.length; ib++){\\n        var itb = itemsAll[ib];\\n        var btm = (itb.top || 0) + (itb.height || 0);\\n        if (btm > maxOriginalBottom) maxOriginalBottom = btm;\\n      }\\n      var baseBottomGap = Math.max(0, baseSecHeight - maxOriginalBottom);\\n\\n      // Si todo mide 0 (fonts no listas), reintentamos luego\\n      var anyValidAll = itemsAll.some(function(it){ return it.height > 0.5; });\\n      if(!anyValidAll) {\\n        logReflowDecision(\"skip:invalidRects\", {\\n          willApplyReflow: false,\\n          allHeightsTiny: true\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      if (!allowReflow || nodesAll.length < 2) {\\n        logReflowDecision(\"skip:notEligible\", {\\n          willApplyReflow: false,\\n          allowReflow: allowReflow,\\n          totalNodes: nodesAll.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      function detectHeroLikeCentralText(items, rootW){\\n        var out = {\\n          isHero: false,\\n          reason: \"\",\\n          textCount: 0,\\n          textColumnCount: 0,\\n          textColumns: [],\\n          singleTextColumn: false,\\n          maxTextWidthRatio: null,\\n          widthRatio: null,\\n          centerDelta: null,\\n          centerTol: null,\\n          centeredByAlign: false,\\n          centeredByGeometry: false,\\n          decorNear: 0,\\n          decorLeft: 0,\\n          decorRight: 0,\\n          decorInvadingTextColumn: 0\\n        };\\n        if (!items || !items.length || !rootW || rootW <= 0) {\\n          out.reason = \"noItemsOrWidth\";\\n          return out;\\n        }\\n\\n        var textItems = items.filter(function(it){\\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\\n          var tw = Number(it.width || 0);\\n          var th = Number(it.height || 0);\\n          return tw > 2 && th > 2;\\n        });\\n        out.textCount = textItems.length;\\n        if (!textItems.length) {\\n          out.reason = \"noText\";\\n          return out;\\n        }\\n\\n        var explicitHero = false;\\n        for (var eh=0; eh<textItems.length; eh++){\\n          var roleEh = (textItems[eh].node.getAttribute(\"data-mobile-role\") || \"\").toLowerCase();\\n          if (roleEh === \"hero\") {\\n            explicitHero = true;\\n            break;\\n          }\\n        }\\n\\n        var colTol = Math.max(18, rootW * 0.14);\\n        var textCols = [];\\n        for (var tc=0; tc<textItems.length; tc++){\\n          var txt = textItems[tc];\\n          var txtCx = Number(txt.left || 0) + Number(txt.width || 0) / 2;\\n          var attached = false;\\n          for (var cc=0; cc<textCols.length; cc++){\\n            if (Math.abs(txtCx - textCols[cc].cx) <= colTol) {\\n              var nCol = textCols[cc].count + 1;\\n              textCols[cc].cx = ((textCols[cc].cx * textCols[cc].count) + txtCx) / nCol;\\n              textCols[cc].count = nCol;\\n              textCols[cc].minLeft = Math.min(textCols[cc].minLeft, Number(txt.left || 0));\\n              textCols[cc].maxRight = Math.max(textCols[cc].maxRight, Number(txt.left || 0) + Number(txt.width || 0));\\n              textCols[cc].minTop = Math.min(textCols[cc].minTop, Number(txt.top || 0));\\n              textCols[cc].maxBottom = Math.max(textCols[cc].maxBottom, Number(txt.top || 0) + Number(txt.height || 0));\\n              attached = true;\\n              break;\\n            }\\n          }\\n          if (!attached) {\\n            textCols.push({\\n              cx: txtCx,\\n              count: 1,\\n              minLeft: Number(txt.left || 0),\\n              maxRight: Number(txt.left || 0) + Number(txt.width || 0),\\n              minTop: Number(txt.top || 0),\\n              maxBottom: Number(txt.top || 0) + Number(txt.height || 0)\\n            });\\n          }\\n        }\\n        textCols.sort(function(a,b){ return a.cx - b.cx; });\\n        out.textColumnCount = textCols.length;\\n        out.singleTextColumn = textCols.length === 1;\\n        out.textColumns = textCols.map(function(col){\\n          return {\\n            cx: +Number(col.cx || 0).toFixed(1),\\n            count: col.count,\\n            left: +Number(col.minLeft || 0).toFixed(1),\\n            right: +Number(col.maxRight || 0).toFixed(1),\\n            top: +Number(col.minTop || 0).toFixed(1),\\n            bottom: +Number(col.maxBottom || 0).toFixed(1)\\n          };\\n        });\\n        if (!out.singleTextColumn) {\\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"multiTextColumns\";\\n          out.isHero = explicitHero;\\n          return out;\\n        }\\n\\n        var centerX = rootW / 2;\\n        var textCol = textCols[0];\\n        var textCenterX = Number(textCol.cx || centerX);\\n        var centerDelta = Math.abs(textCenterX - centerX);\\n        var centerTol = Math.max(18, rootW * 0.12);\\n        out.centerDelta = +centerDelta.toFixed(1);\\n        out.centerTol = +centerTol.toFixed(1);\\n\\n        var centeredAlignCount = 0;\\n        var maxTextWidthRatio = 0;\\n        var textTop = Infinity;\\n        var textBottom = -Infinity;\\n        for (var tix=0; tix<textItems.length; tix++){\\n          var t = textItems[tix];\\n          var ta = (t.node && t.node.style && t.node.style.textAlign)\\n            ? String(t.node.style.textAlign).toLowerCase()\\n            : \"\";\\n          if (ta === \"center\") centeredAlignCount++;\\n          var wRatio = Number(t.width || 0) / Math.max(1, rootW);\\n          if (wRatio > maxTextWidthRatio) maxTextWidthRatio = wRatio;\\n          textTop = Math.min(textTop, Number(t.top || 0));\\n          textBottom = Math.max(textBottom, Number(t.top || 0) + Number(t.height || 0));\\n        }\\n        out.maxTextWidthRatio = +maxTextWidthRatio.toFixed(3);\\n        out.widthRatio = out.maxTextWidthRatio;\\n        out.centeredByAlign = centeredAlignCount >= Math.max(1, Math.ceil(textItems.length * 0.5));\\n        out.centeredByGeometry = centerDelta <= centerTol;\\n        if (!out.centeredByAlign && !out.centeredByGeometry) {\\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"singleTextColumnNotCentered\";\\n          out.isHero = explicitHero;\\n          return out;\\n        }\\n\\n        // Evita marcar como hero textos sueltos muy chicos.\\n        if (textItems.length < 2 && maxTextWidthRatio < 0.28 && !explicitHero) {\\n          out.reason = \"textTooSmall\";\\n          return out;\\n        }\\n\\n        if (!isFinite(textTop) || !isFinite(textBottom) || textBottom <= textTop) {\\n          textTop = 0;\\n          textBottom = 0;\\n        }\\n        var nearTop = textTop - Math.max(28, (textBottom - textTop) * 0.2);\\n        var nearBottom = textBottom + Math.max(36, (textBottom - textTop) * 0.35);\\n        var invadePad = Math.max(24, rootW * 0.17);\\n        var invadeLeft = textCenterX - invadePad;\\n        var invadeRight = textCenterX + invadePad;\\n\\n        var decorNear = 0;\\n        var decorLeft = 0;\\n        var decorRight = 0;\\n        var decorInvading = 0;\\n\\n        for (var iHero=0; iHero<items.length; iHero++){\\n          var it = items[iHero];\\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") continue;\\n\\n          var w = Number(it.width || 0);\\n          var h = Number(it.height || 0);\\n          if (w < 8 || h < 8) continue;\\n\\n          var top = Number(it.top || 0);\\n          var bottom = top + h;\\n          var inBand = !(bottom < nearTop || top > nearBottom);\\n          if (!inBand) continue;\\n\\n          decorNear++;\\n          var cx = Number(it.left || 0) + w / 2;\\n          if (cx < textCenterX - 8) decorLeft++;\\n          else if (cx > textCenterX + 8) decorRight++;\\n\\n          var left = Number(it.left || 0);\\n          var right = left + w;\\n          if (right > invadeLeft && left < invadeRight) decorInvading++;\\n        }\\n\\n        out.decorNear = decorNear;\\n        out.decorLeft = decorLeft;\\n        out.decorRight = decorRight;\\n        out.decorInvadingTextColumn = decorInvading;\\n\\n        var decorAround = (decorLeft > 0 && decorRight > 0) || decorNear >= 3;\\n        var centeredSingleTextColumn = out.singleTextColumn && (out.centeredByAlign || out.centeredByGeometry);\\n        out.isHero = explicitHero || centeredSingleTextColumn;\\n        out.reason = out.isHero\\n          ? (\\n            explicitHero\\n              ? \"explicitHeroRole\"\\n              : (decorInvading > 0\\n                ? \"singleCenteredTextColumnDecorInvades\"\\n                : (decorAround\\n                  ? \"singleCenteredTextColumnWithDecor\"\\n                  : \"singleCenteredTextColumn\"))\\n          )\\n          : \"noHeroSignal\";\\n        return out;\\n      }\\n\\n      function detectInlinePairNoReflow(flowItems, allItems, rootW, CFG){\\n        var out = {\\n          skip: false,\\n          reason: \"\",\\n          totalFlow: flowItems ? flowItems.length : 0,\\n          totalAll: allItems ? allItems.length : 0,\\n          rowDelta: null,\\n          rowTol: null,\\n          pairSpan: null,\\n          pairSpanRatio: null,\\n          fitsTogether: false,\\n          bothSmall: false,\\n          smallWLimit: null,\\n          smallHLimit: null,\\n          widths: [],\\n          heights: []\\n        };\\n        if (!flowItems || flowItems.length !== 2 || !allItems || allItems.length !== 2 || !rootW || rootW <= 0) {\\n          out.reason = \"notExactPair\";\\n          return out;\\n        }\\n\\n        var a = flowItems[0];\\n        var b = flowItems[1];\\n        var aW = Math.max(0, Number(a.width || 0));\\n        var bW = Math.max(0, Number(b.width || 0));\\n        var aH = Math.max(0, Number(a.height || 0));\\n        var bH = Math.max(0, Number(b.height || 0));\\n        out.widths = [+aW.toFixed(1), +bW.toFixed(1)];\\n        out.heights = [+aH.toFixed(1), +bH.toFixed(1)];\\n\\n        if (aW < 2 || bW < 2 || aH < 2 || bH < 2) {\\n          out.reason = \"invalidSizes\";\\n          return out;\\n        }\\n\\n        var rowTol = Math.max(12, Number((CFG && CFG.ROW_TOL) || 28) * 1.2);\\n        var rowDelta = Math.abs(Number(a.top || 0) - Number(b.top || 0));\\n        out.rowTol = +rowTol.toFixed(1);\\n        out.rowDelta = +rowDelta.toFixed(1);\\n        if (rowDelta > rowTol) {\\n          out.reason = \"notInlineRow\";\\n          return out;\\n        }\\n\\n        var smallWLimit = Math.max(74, rootW * 0.42);\\n        var smallHLimit = Math.max(34, rootW * 0.2);\\n        out.smallWLimit = +smallWLimit.toFixed(1);\\n        out.smallHLimit = +smallHLimit.toFixed(1);\\n        var bothSmall =\\n          aW <= smallWLimit &&\\n          bW <= smallWLimit &&\\n          aH <= smallHLimit &&\\n          bH <= smallHLimit;\\n        out.bothSmall = bothSmall;\\n        if (!bothSmall) {\\n          out.reason = \"pairNotSmall\";\\n          return out;\\n        }\\n\\n        var pairLeft = Math.min(Number(a.left || 0), Number(b.left || 0));\\n        var pairRight = Math.max(Number(a.left || 0) + aW, Number(b.left || 0) + bW);\\n        var pairSpan = Math.max(0, pairRight - pairLeft);\\n        var fitsTogether = pairSpan <= (rootW + 1);\\n        out.pairSpan = +pairSpan.toFixed(1);\\n        out.pairSpanRatio = +(pairSpan / Math.max(1, rootW)).toFixed(3);\\n        out.fitsTogether = fitsTogether;\\n\\n        if (fitsTogether) {\\n          out.skip = true;\\n          out.reason = \"smallInlinePairFits\";\\n          return out;\\n        }\\n\\n        out.reason = \"smallInlinePairOverflow\";\\n        return out;\\n      }\\n\\n      function enforceInlinePairGap(flowItems, rootEl, rootW){\\n        var out = {\\n          applied: false,\\n          reason: \"\",\\n          minGap: 6,\\n          gapBefore: null,\\n          gapAfter: null,\\n          need: null,\\n          moveLeft: 0,\\n          moveRight: 0,\\n          overflowBefore: false,\\n          overflowAfter: false\\n        };\\n        if (!flowItems || flowItems.length !== 2 || !rootEl || !rootW || rootW <= 0) {\\n          out.reason = \"notExactPair\";\\n          return out;\\n        }\\n\\n        var a = flowItems[0];\\n        var b = flowItems[1];\\n        if (!a || !b || !a.node || !b.node) {\\n          out.reason = \"missingNodes\";\\n          return out;\\n        }\\n\\n        var leftItem = Number(a.left || 0) <= Number(b.left || 0) ? a : b;\\n        var rightItem = (leftItem === a) ? b : a;\\n\\n        var rrL = relRect(leftItem.node, rootEl);\\n        var rrR = relRect(rightItem.node, rootEl);\\n        var lLeft = Number(rrL.left || 0);\\n        var lW = Number(rrL.width || 0);\\n        var rLeft = Number(rrR.left || 0);\\n        var rW = Number(rrR.width || 0);\\n        if (!isFinite(lLeft) || !isFinite(lW) || !isFinite(rLeft) || !isFinite(rW)) {\\n          out.reason = \"invalidRects\";\\n          return out;\\n        }\\n\\n        var gapBefore = rLeft - (lLeft + lW);\\n        out.gapBefore = +gapBefore.toFixed(2);\\n        out.overflowBefore = (lLeft < -0.5) || ((rLeft + rW) > (rootW + 0.5));\\n\\n        var need = Math.max(0, out.minGap - gapBefore);\\n        out.need = +need.toFixed(2);\\n        if (need <= 0.25) {\\n          out.reason = \"alreadySpaced\";\\n          out.gapAfter = out.gapBefore;\\n          out.overflowAfter = out.overflowBefore;\\n          return out;\\n        }\\n\\n        var availRight = Math.max(0, rootW - (rLeft + rW));\\n        var availLeft = Math.max(0, lLeft);\\n        var moveRight = Math.min(availRight, need);\\n        var remaining = Math.max(0, need - moveRight);\\n        var moveLeft = Math.min(availLeft, remaining);\\n\\n        if (moveRight <= 0.01 && moveLeft <= 0.01) {\\n          out.reason = \"noRoomToAdjust\";\\n          return out;\\n        }\\n\\n        if (moveRight > 0.01) {\\n          rightItem.node.style.left = (Number(rightItem.left || 0) + moveRight) + \"px\";\\n          rightItem.node.style.right = \"auto\";\\n          rightItem.node.style.marginLeft = \"0px\";\\n        }\\n        if (moveLeft > 0.01) {\\n          leftItem.node.style.left = (Number(leftItem.left || 0) - moveLeft) + \"px\";\\n          leftItem.node.style.right = \"auto\";\\n          leftItem.node.style.marginLeft = \"0px\";\\n        }\\n\\n        var rrL2 = relRect(leftItem.node, rootEl);\\n        var rrR2 = relRect(rightItem.node, rootEl);\\n        var lLeft2 = Number(rrL2.left || 0);\\n        var lW2 = Number(rrL2.width || 0);\\n        var rLeft2 = Number(rrR2.left || 0);\\n        var rW2 = Number(rrR2.width || 0);\\n        var gapAfter = rLeft2 - (lLeft2 + lW2);\\n\\n        out.moveRight = +moveRight.toFixed(2);\\n        out.moveLeft = +moveLeft.toFixed(2);\\n        out.gapAfter = isFinite(gapAfter) ? +gapAfter.toFixed(2) : null;\\n        out.overflowAfter = (lLeft2 < -0.5) || ((rLeft2 + rW2) > (rootW + 0.5));\\n        out.applied = (moveRight > 0.01 || moveLeft > 0.01);\\n        out.reason = out.applied ? \"applied\" : \"noChange\";\\n        if (isFinite(gapAfter) && gapAfter < -0.2) out.reason = \"appliedButStillOverlap\";\\n        return out;\\n      }\\n\\n      // ✅ Determinar qu\\xe9 nodos son \"ANCHOR\" (no se reflowean)\\n      // Regla: texto centrado + casi full-width => t\\xedtulo/hero, no mover.\\n      function isAnchorNode(it){\\n        var node = it.node;\\n\\n        // opt-out expl\\xedcito\\n        var keepLayout = (node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n        if (keepLayout) return true;\\n\\n        // anchor expl\\xedcito (si lo us\\xe1s)\\n        var role = (node.getAttribute(\"data-mobile-role\") || \"\");\\n        if (role === \"anchor\") return true;\\n\\n        // heur\\xedstica para textos\\n        var isText = (node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n        if (!isText) return false;\\n\\n        var ta = (node.style && node.style.textAlign) ? String(node.style.textAlign).toLowerCase() : \"\";\\n        if (ta !== \"center\") return false;\\n\\n        // solo si realmente ocupa casi todo el ancho usable\\n        // (esto evita romper textos centrados dentro de columnas)\\n        if (contentW > 0 && it.width >= contentW * 0.78) return true;\\n\\n        return false;\\n      }\\n\\n      // ✅ Flow = todo lo que NO es anchor\\n      var itemsFlow = itemsAll.filter(function(it){ return !isAnchorNode(it); });\\n      var itemsAnchor = itemsAll.filter(function(it){ return isAnchorNode(it); });\\n      mslLog(\"section:anchorSplit\", {\\n        secIndex: secIndex,\\n        anchors: itemsAnchor.length,\\n        flow: itemsFlow.length,\\n        anchorsDetail: itemsAnchor.map(function(it){\\n          return {\\n            kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\\n            top: +it.top.toFixed(1),\\n            left: +it.left.toFixed(1),\\n            w: +it.width.toFixed(1),\\n            h: +it.height.toFixed(1),\\n            textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\\n          };\\n        })\\n      });\\n\\n      // Si no hay suficientes elementos reflowables, no hacemos nada\\n      if(itemsFlow.length < 2) {\\n        logReflowDecision(\"skip:flowTooSmall\", {\\n          willApplyReflow: false,\\n          flowCount: itemsFlow.length,\\n          anchorCount: itemsAnchor.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      // ✅ Para que \"altura necesaria\" no quede corta,\\n      // medimos el bottom m\\xe1ximo de anchors (en coords del content)\\n      var maxAnchorBottom = 0;\\n      itemsAll.forEach(function(it){\\n        if (!isAnchorNode(it)) return;\\n        var b = (it.top || 0) + (it.height || 0);\\n        if (b > maxAnchorBottom) maxAnchorBottom = b;\\n      });\\n\\n      // ✅ 1) agrupar por solape → clusters (SOLO FLOW)\\n      var clusters = buildOverlapClusters(itemsFlow);\\n      mslLog(\"section:clusters\", {\\n        secIndex: secIndex,\\n        count: clusters.length,\\n        clusters: clusters.map(function(c, idx){\\n          return {\\n            i: idx,\\n            top: +c.top.toFixed(1),\\n            left: +c.left.toFixed(1),\\n            w: +c.width.toFixed(1),\\n            h: +c.height.toFixed(1),\\n            cx: +c.cx.toFixed(1),\\n            items: c.items.length\\n          };\\n        })\\n      });\\n\\n      // ✅ 2) Detectar columnas/rows (SOLO FLOW)\\n      var rootW = contentW || 0;\\n      var ord = orderClustersForMobile(clusters, rootW, CFG);\\n      var groups = ord.groups;\\n      var mode = ord.mode;\\n      mslLog(\"section:ordering\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        rootW: rootW,\\n        groups: groups.map(function(grp, gi){\\n          return {\\n            g: gi,\\n            count: grp.length,\\n            tops: grp.map(function(c){ return +c.top.toFixed(1); }),\\n            lefts: grp.map(function(c){ return +c.left.toFixed(1); })\\n          };\\n        })\\n      });\\n\\n      var heroSignal = detectHeroLikeCentralText(itemsAll, rootW);\\n      mslLog(\"section:heroCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        isHero: heroSignal.isHero,\\n        reason: heroSignal.reason,\\n        textCount: heroSignal.textCount,\\n        textColumnCount: heroSignal.textColumnCount,\\n        singleTextColumn: heroSignal.singleTextColumn,\\n        textColumns: heroSignal.textColumns,\\n        maxTextWidthRatio: heroSignal.maxTextWidthRatio,\\n        widthRatio: heroSignal.widthRatio,\\n        centerDelta: heroSignal.centerDelta,\\n        centerTol: heroSignal.centerTol,\\n        centeredByAlign: heroSignal.centeredByAlign,\\n        centeredByGeometry: heroSignal.centeredByGeometry,\\n        decorNear: heroSignal.decorNear,\\n        decorLeft: heroSignal.decorLeft,\\n        decorRight: heroSignal.decorRight,\\n        decorInvadingTextColumn: heroSignal.decorInvadingTextColumn\\n      });\\n      if (heroSignal.isHero) {\\n        logReflowDecision(\"skip:heroCentralText\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          heroReason: heroSignal.reason,\\n          hero: heroSignal\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      var inlinePairSignal = detectInlinePairNoReflow(itemsFlow, itemsAll, rootW, CFG);\\n      mslLog(\"section:inlinePairCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        skip: inlinePairSignal.skip,\\n        reason: inlinePairSignal.reason,\\n        totalFlow: inlinePairSignal.totalFlow,\\n        totalAll: inlinePairSignal.totalAll,\\n        rowDelta: inlinePairSignal.rowDelta,\\n        rowTol: inlinePairSignal.rowTol,\\n        widths: inlinePairSignal.widths,\\n        heights: inlinePairSignal.heights,\\n        bothSmall: inlinePairSignal.bothSmall,\\n        smallWLimit: inlinePairSignal.smallWLimit,\\n        smallHLimit: inlinePairSignal.smallHLimit,\\n        pairSpan: inlinePairSignal.pairSpan,\\n        pairSpanRatio: inlinePairSignal.pairSpanRatio,\\n        fitsTogether: inlinePairSignal.fitsTogether\\n      });\\n      if (inlinePairSignal.skip) {\\n        var inlinePairAdjust = enforceInlinePairGap(itemsFlow, content, rootW);\\n        mslLog(\"section:inlinePairAdjust\", {\\n          secIndex: secIndex,\\n          mode: mode,\\n          adjust: inlinePairAdjust\\n        });\\n        logReflowDecision(\"skip:smallInlinePairFits\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          inlinePair: inlinePairSignal,\\n          inlinePairAdjust: inlinePairAdjust\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      // ✅ 3) Gate \"mejor de ambos mundos\":\\n      // - Si es \"one\" (layout ya natural) Y adem\\xe1s entra, NO hacemos reflow.\\n      // - En cualquier otro caso (two/three/rows), hacemos reflow para lectura mobile,\\n      //   incluso aunque \"entre\".\\n      var fits = clustersFitInMobile(clusters, content);\\n      mslLog(\"section:fitCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        fits: fits,\\n        willSkip: (mode === \"one\" && fits)\\n      });\\n      if (mode === \"one\" && fits) {\\n        logReflowDecision(\"skip:modeOneFits\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          fits: fits,\\n          clusters: clusters.length,\\n          flowCount: itemsFlow.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      logReflowDecision(\"apply:modeRequiresReflow\", {\\n        willApplyReflow: true,\\n        mode: mode,\\n        fits: fits,\\n        clusters: clusters.length,\\n        flowCount: itemsFlow.length,\\n        anchorCount: itemsAnchor.length,\\n        groupSizes: groups.map(function(grp){ return grp.length; })\\n      });\\n\\n      // ✅ 4) Reflow solo sobre FLOW (preserva solapes dentro de cada cluster)\\n      var res = applyClusterStack(groups, content, CFG, mode);\\n      mslLog(\"section:applyResult\", {\\n        secIndex: secIndex,\\n        changed: !!(res && res.changed),\\n        neededHeight: res ? res.neededHeight : null,\\n        maxAnchorBottom: +maxAnchorBottom.toFixed(1),\\n        baseBottomGap: +baseBottomGap.toFixed(1)\\n      });\\n      logReflowDecision(\"postApply\", {\\n        willApplyReflow: true,\\n        changed: !!(res && res.changed),\\n        neededHeight: res ? +Number(res.neededHeight || 0).toFixed(1) : null,\\n        mode: mode\\n      });\\n\\n      var neededAfterReflow = 0;\\n      if (res && res.changed) {\\n        // Evitar que la secci\\xf3n quede chica si hay anchors m\\xe1s abajo\\n        var needed = Number(res.neededHeight || 0);\\n        if (Number(maxAnchorBottom) > 0) {\\n          // sumamos padding bottom para que no quede pegado\\n          var anchorNeeded = Math.ceil(maxAnchorBottom + (CFG.PAD_BOT || 0));\\n          if (anchorNeeded > needed) needed = anchorNeeded;\\n        }\\n        if (baseBottomGap > 0) {\\n          needed = Math.ceil(needed + baseBottomGap);\\n        }\\n        if (needed > 0) neededAfterReflow = needed;\\n      }\\n      finalizeSection(neededAfterReflow, baseBottomGap);\\n    });\\n  }\\n\\n  function boot(){\\n    mslLog(\"boot\", { cfg: CFG });\\n    runOnce();\\n    setTimeout(runOnce, 150);\\n    setTimeout(runOnce, 600);\\n    setTimeout(runOnce, 1800);\\n\\n    if(document.fonts && document.fonts.ready){\\n      document.fonts.ready.then(function(){ runOnce(); }).catch(function(){});\\n    }\\n  }\\n\\n  window.addEventListener(\"load\", boot);\\n  window.addEventListener(\"resize\", runOnce);\\n\\n  if(window.visualViewport){\\n    window.visualViewport.addEventListener(\"resize\", runOnce);\\n    window.visualViewport.addEventListener(\"scroll\", runOnce);\\n  }\\n\\n  if(document.readyState !== \"loading\") boot();\\n  else document.addEventListener(\"DOMContentLoaded\", boot);\\n})();\\n</script>\\n').trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFFaEI7QUFDRztBQUNBO0FBQ0E7QUFFdEMsU0FBU0ksWUFBWUMsR0FBcUI7SUFDL0MsSUFBSSxDQUFDQSxJQUFJQyxPQUFPLEVBQUUsT0FBTztJQUV6QixPQUFPLHNzRkEyRk1ELE9BREFBLElBQUlFLFFBQVEsRUFBQyxvQkFFWEYsT0FERkEsSUFBSUcsUUFBUSxFQUFDLHNCQUdiSCxPQUZFQSxJQUFJSSxRQUFRLEVBQUMsc0JBR2ZKLE9BREFBLElBQUlLLFlBQVksRUFBQyxvQkFHZEwsT0FGSEEsSUFBSU0sZUFBZSxFQUFDLHlCQUdSTixPQURUQSxJQUFJTyxpQkFBaUIsR0FBRyxTQUFTLFNBQVEsZ0NBRzVDUCxPQUZZQSxJQUFJUSxpQkFBaUIsR0FBRyxTQUFTLFNBQVEsc0JBSXhDUixPQUZiQSxJQUFJUyxRQUFRLEVBQUMsbUNBR1BULE9BRE9BLElBQUlVLGlCQUFpQixFQUFDLDBCQUdwQlYsT0FGVEEsSUFBSVcsYUFBYSxFQUFDLHFDQUdsQlgsT0FEU0EsSUFBSVksbUJBQW1CLEVBQUMsMEJBR2pDWixPQUZBQSxJQUFJYSxhQUFhLEVBQUMsNEJBR2xCYixPQURBQSxJQUFJYyxXQUFXLEVBQUMsMEJBRVBkLE9BRFRBLElBQUllLFdBQVcsRUFBQyxtQ0FFWGYsT0FESUEsSUFBSWdCLG1CQUFtQixFQUFDLCtCQUlsRHJCLE9BSHNCSyxJQUFJaUIsZUFBZSxFQUFDLGdCQUsxQ3BCLE9BRkFGLHVEQUFpQkEsSUFBRyxVQUlwQkcsT0FGQUQsMERBQWVBLElBQUcsVUFJbEJELE9BRkFFLDBEQUFlQSxJQUFHLFVBRUEsT0FBbEJGLDBEQUFlQSxJQUFHLGc1bENBbTVCcEJzQixJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHNjcmlwdFRlbXBsYXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHNcclxuaW1wb3J0IHsgTm9ybWFsaXplZENvbmZpZyB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsganNEb21IZWxwZXJzQmxvY2sgfSBmcm9tIFwiLi9kb21cIjtcbmltcG9ydCB7IGpzRml0U2NhbGVCbG9jayB9IGZyb20gXCIuL2ZpdFNjYWxlXCI7XG5pbXBvcnQgeyBqc09yZGVyaW5nQmxvY2sgfSBmcm9tIFwiLi9vcmRlcmluZ1wiO1xuaW1wb3J0IHsganNTdGFja2luZ0Jsb2NrIH0gZnJvbSBcIi4vc3RhY2tpbmdcIjtcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTY3JpcHQoY2ZnOiBOb3JtYWxpemVkQ29uZmlnKTogc3RyaW5nIHtcclxuICBpZiAoIWNmZy5lbmFibGVkKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgcmV0dXJuIGBcbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgdmFyIEVOQUJMRUQgPSB0cnVlO1xuICBmdW5jdGlvbiByZWFkRGVidWdGbGFnKG5hbWUpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgc2VhcmNoID0gKHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uc2VhcmNoKSA/IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggOiBcIlwiO1xuICAgICAgdmFyIHFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgICAgdmFyIHF2ID0gcXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKHF2ID09PSBcIjFcIiB8fCBTdHJpbmcocXYpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKF9lMSkge31cblxuICAgIC8vIHNyY0RvYy9hYm91dDpzcmNkb2Mgbm8gc3VlbGUgdGVuZXIgcXVlcnlzdHJpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cucGFyZW50ICYmIHdpbmRvdy5wYXJlbnQgIT09IHdpbmRvdyAmJiB3aW5kb3cucGFyZW50LmxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBwU2VhcmNoID0gd2luZG93LnBhcmVudC5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgdmFyIHBRID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwU2VhcmNoKTtcbiAgICAgICAgdmFyIHBWID0gcFEuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocFYgPT09IFwiMVwiIHx8IFN0cmluZyhwVikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2UyKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cudG9wICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB3aW5kb3cudG9wLmxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB0U2VhcmNoID0gd2luZG93LnRvcC5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgdmFyIHRRID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh0U2VhcmNoKTtcbiAgICAgICAgdmFyIHRWID0gdFEuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodFYgPT09IFwiMVwiIHx8IFN0cmluZyh0VikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2UzKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBscyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UgPyB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSkgOiBudWxsO1xuICAgICAgaWYgKGxzID09PSBcIjFcIiB8fCBTdHJpbmcobHMpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKF9lNCkge31cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgTVNMX0RFQlVHID0gcmVhZERlYnVnRmxhZyhcIm1zbERlYnVnXCIpO1xuICB2YXIgTVNMX1ZFUkJPU0UgPSByZWFkRGVidWdGbGFnKFwibXNsVmVyYm9zZVwiKTtcbiAgZnVuY3Rpb24gZGJnKGxhYmVsLCBwYXlsb2FkKXtcbiAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW01TTF0gXCIgKyBsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsICsgXCIgXCIgKyBwYXlsb2FkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByZXR0eSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHByZXR0eSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQsIG51bGwsIDIpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdHJ5IHsgcHJldHR5ID0gU3RyaW5nKHBheWxvYWQpOyB9IGNhdGNoKF8pIHsgcHJldHR5ID0gXCJbdW5zZXJpYWxpemFibGVdXCI7IH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsICsgXCJcXFxcblwiICsgcHJldHR5KTtcbiAgfVxuICBmdW5jdGlvbiBtc2xMb2coKXtcbiAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgdmFyIGxhYmVsID0gU3RyaW5nKGFyZ3NbMF0pO1xuICAgIGlmICghTVNMX1ZFUkJPU0UpIHtcbiAgICAgIHZhciBub2lzeSA9IHtcbiAgICAgICAgXCJzZWN0aW9uOm5vZGVTb3VyY2VzXCI6IDEsXG4gICAgICAgIFwic2VjdGlvbjpiYXNlbGluZVJlc3RvcmVcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmFuY2hvclNwbGl0XCI6IDEsXG4gICAgICAgIFwic2VjdGlvbjpjbHVzdGVyc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnRocmVlOmNhbmRpZGF0ZXNcIjogMSxcbiAgICAgICAgXCJvcmRlcjp0aHJlZTpzcHJlYWRcIjogMSxcbiAgICAgICAgXCJvcmRlcjp0d286Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnR3bzpzcHJlYWRcIjogMSxcbiAgICAgICAgXCJvcmRlcjpvbmU6Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnJvd3M6ZmFsbGJhY2tcIjogMVxuICAgICAgfTtcbiAgICAgIGlmIChub2lzeVtsYWJlbF0pIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBkYmcobGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGRiZyhsYWJlbCwgYXJnc1sxXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRiZyhsYWJlbCwgYXJncy5zbGljZSgxKSk7XG4gIH1cblxyXG4gIHZhciBDRkcgPSB7XHJcbiAgICBNSU5fR0FQOiAke2NmZy5taW5HYXBQeH0sXHJcbiAgICBNQVhfR0FQOiAke2NmZy5tYXhHYXBQeH0sXHJcbiAgICBHQVBfU0NBTEU6ICR7Y2ZnLmdhcFNjYWxlfSxcclxuXHJcbiAgICBQQURfVE9QOiAke2NmZy5wYWRkaW5nVG9wUHh9LFxyXG4gICAgUEFEX0JPVDogJHtjZmcucGFkZGluZ0JvdHRvbVB4fSxcclxuXHJcbiAgICBPTkxZX0ZJWEVEOiAke2NmZy5vbmx5Rml4ZWRTZWN0aW9ucyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwifSxcclxuICAgIE9OTFlfV0hFTl9SRU9SREVSRUQ6ICR7Y2ZnLm9ubHlXaGVuUmVvcmRlcmVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9LFxyXG5cclxuICAgIFJPV19UT0w6ICR7Y2ZnLnJvd1RvbFB4fSxcclxuXHJcbiAgICBUV09fQ09MX1NQUkVBRF9SQVRJTzogJHtjZmcudHdvQ29sU3ByZWFkUmF0aW99LFxyXG4gICAgTUlOX1BFUl9DT0xfMjogJHtjZmcubWluUGVyQ29sdW1uMn0sXHJcblxyXG4gICAgVEhSRUVfQ09MX1NQUkVBRF9SQVRJTzogJHtjZmcudGhyZWVDb2xTcHJlYWRSYXRpb30sXG4gICAgTUlOX1BFUl9DT0xfMzogJHtjZmcubWluUGVyQ29sdW1uM30sXG5cbiAgICBGSVRfTUlOX1NDQUxFOiAke2NmZy5maXRNaW5TY2FsZX0sXG4gICAgRklUX01BWF9TQ0FMRTogJHtjZmcuZml0TWF4U2NhbGV9LFxuICAgIEZJVF9UQVJHRVRfV0lEVEhfUkFUSU86ICR7Y2ZnLmZpdFRhcmdldFdpZHRoUmF0aW99LFxuICAgIEZJVF9NSU5fRklMTF9SQVRJTzogJHtjZmcuZml0TWluRmlsbFJhdGlvfVxuICB9O1xuXHJcbiAgJHtqc0RvbUhlbHBlcnNCbG9jaygpfVxyXG5cclxuICAke2pzT3JkZXJpbmdCbG9jaygpfVxyXG5cclxuICAke2pzU3RhY2tpbmdCbG9jaygpfVxuXG4gICR7anNGaXRTY2FsZUJsb2NrKCl9XG5cclxuICBmdW5jdGlvbiBleHBhbmRGaXhlZFNlY3Rpb24oc2VjLCBuZWVkZWRIZWlnaHQpe1xyXG4gICAgdmFyIGN1cnJlbnRIID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCAwO1xyXG4gICAgaWYgKG5lZWRlZEhlaWdodCA+IGN1cnJlbnRIICsgMSkge1xyXG4gICAgICBzZWMuc3R5bGUuaGVpZ2h0ID0gTWF0aC5jZWlsKG5lZWRlZEhlaWdodCkgKyBcInB4XCI7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc1NlY3Rpb24oc2VjKXtcclxuICAgIGlmKCFzZWMpIHJldHVybiBmYWxzZTtcclxuICAgIGlmKCFDRkcuT05MWV9GSVhFRCkgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgbW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgcmV0dXJuIG1vZG8gPT09IFwiZmlqb1wiO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcnVuT25jZSgpe1xuICAgIGlmKCFFTkFCTEVEKSByZXR1cm47XG4gICAgaWYoIWlzTW9iaWxlKCkpIHtcbiAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zZWNcIikpLmZvckVhY2goZnVuY3Rpb24oc2VjKXtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtY29udGVudFwiKTtcbiAgICAgICAgaWYoIWNvbnRlbnQpIHJldHVybjtcbiAgICAgICAgdmFyIGJsZWVkID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWJsZWVkXCIpO1xuICAgICAgICByZXNldFNlY3Rpb25GaXRTY2FsZShzZWMsIGNvbnRlbnQsIGJsZWVkKTtcbiAgICAgICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBcIjFcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cclxuICAgIHZhciBzZWNzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSk7XHJcbiAgICBpZighc2Vjcy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICBzZWNzLmZvckVhY2goZnVuY3Rpb24oc2VjKXtcbiAgICAgIHZhciBzZWNJbmRleCA9IHNlY3MuaW5kZXhPZihzZWMpO1xuICAgICAgdmFyIHNlY01vZG8gPSAoc2VjLmdldEF0dHJpYnV0ZShcImRhdGEtbW9kb1wiKSB8fCBcImZpam9cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBhbGxvd1JlZmxvdyA9IHNob3VsZFByb2Nlc3NTZWN0aW9uKHNlYyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOnN0YXJ0XCIsIHsgc2VjSW5kZXg6IHNlY0luZGV4LCBtb2RvOiBzZWNNb2RvLCBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3cgfSk7XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XG4gICAgICBpZighY29udGVudCkgcmV0dXJuO1xuICAgICAgdmFyIGJsZWVkID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWJsZWVkXCIpO1xuICAgICAgcmVzZXRTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCk7XG4gICAgICB2YXIgbm9kZXNBbGwgPSBnZXRPYmpOb2RlcyhzZWMpO1xuXG4gICAgICB2YXIgcmVmbG93RWxlbWVudHNEdW1wID0gW107XG4gICAgICBmdW5jdGlvbiBidWlsZFJlZmxvd0VsZW1lbnRzRHVtcChpdGVtcywgY29udGVudFdOb3cpe1xuICAgICAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgICAgICB2YXIgbGlzdCA9IChpdGVtcyB8fCBbXSk7XG4gICAgICAgIHZhciBtYXhJdGVtcyA9IDEyMDtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpRHVtcD0wOyBpRHVtcDxsaXN0Lmxlbmd0aCAmJiBpRHVtcDxtYXhJdGVtczsgaUR1bXArKyl7XG4gICAgICAgICAgdmFyIGl0RHVtcCA9IGxpc3RbaUR1bXBdO1xuICAgICAgICAgIGlmICghaXREdW1wIHx8ICFpdER1bXAubm9kZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIG5EdW1wID0gaXREdW1wLm5vZGU7XG4gICAgICAgICAgdmFyIHRleHRSYXcgPSAoKG5EdW1wLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgICAgdmFyIGlzVGV4dER1bXAgPSAobkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGNsc0R1bXAgPSAobkR1bXAuY2xhc3NOYW1lICYmIHR5cGVvZiBuRHVtcC5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbkR1bXAuY2xhc3NOYW1lIDogXCJcIjtcbiAgICAgICAgICB2YXIgcm9vdFpvbmUgPSAobkR1bXAuY2xvc2VzdCAmJiBuRHVtcC5jbG9zZXN0KFwiLnNlYy1ibGVlZFwiKSkgPyBcImJsZWVkXCIgOiBcImNvbnRlbnRcIjtcbiAgICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgICBpOiBpRHVtcCxcbiAgICAgICAgICAgIGtpbmQ6IGlzVGV4dER1bXAgPyBcInRleHRvXCIgOiBTdHJpbmcoKG5EdW1wLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICB6b25lOiByb290Wm9uZSxcbiAgICAgICAgICAgIHRvcDogK051bWJlcihpdER1bXAudG9wIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiArTnVtYmVyKGl0RHVtcC5sZWZ0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3OiArTnVtYmVyKGl0RHVtcC53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK051bWJlcihpdER1bXAuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICByaWdodDogK051bWJlcigoaXREdW1wLmxlZnQgfHwgMCkgKyAoaXREdW1wLndpZHRoIHx8IDApKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgYm90dG9tOiArTnVtYmVyKChpdER1bXAudG9wIHx8IDApICsgKGl0RHVtcC5oZWlnaHQgfHwgMCkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjeDogK051bWJlcigoaXREdW1wLmxlZnQgfHwgMCkgKyAoKGl0RHVtcC53aWR0aCB8fCAwKSAvIDIpKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgd1JhdGlvOiBjb250ZW50V05vdyA+IDEgPyArTnVtYmVyKChpdER1bXAud2lkdGggfHwgMCkgLyBjb250ZW50V05vdykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc0R1bXAsXG4gICAgICAgICAgICBtb2JpbGVMYXlvdXQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlUm9sZTogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQ2x1c3RlcjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQ2x1c3RlcklkOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyLWlkXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDZW50ZXI6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNlbnRlclwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQWxpZ246IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWFsaWduXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVGaXQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWZpdFwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAobkR1bXAuc3R5bGUgJiYgbkR1bXAuc3R5bGUudGV4dEFsaWduKSA/IG5EdW1wLnN0eWxlLnRleHRBbGlnbiA6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0U2FtcGxlOiBpc1RleHREdW1wID8gdGV4dFJhdy5zbGljZSgwLCA5MCkgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmbG93RWxlbWVudHNEdW1wID0gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2dSZWZsb3dEZWNpc2lvbihyZWFzb24sIGV4dHJhKXtcbiAgICAgICAgaWYgKCFNU0xfREVCVUcpIHJldHVybjtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHNlY01vZG86IHNlY01vZG8sXG4gICAgICAgICAgYWxsb3dSZWZsb3c6IGFsbG93UmVmbG93LFxuICAgICAgICAgIHRvdGFsTm9kZXM6IChub2Rlc0FsbCB8fCBbXSkubGVuZ3RoLFxuICAgICAgICAgIHJlYXNvbjogU3RyaW5nKHJlYXNvbiB8fCBcIlwiKSxcbiAgICAgICAgICBkZXRhaWxzOiBleHRyYSB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOnJlZmxvdzpkZWNpc2lvblwiLCBwYXlsb2FkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmluYWxpemVTZWN0aW9uKG1pbk5lZWRlZEhlaWdodCwgcHJlc2VydmVCb3R0b21HYXApe1xuICAgICAgICB2YXIgZ2FwID0gTnVtYmVyLmlzRmluaXRlKHByZXNlcnZlQm90dG9tR2FwKSA/IE1hdGgubWF4KDAsIE51bWJlcihwcmVzZXJ2ZUJvdHRvbUdhcCkpIDogMDtcbiAgICAgICAgdmFyIGZpdCA9IGFwcGx5U2VjdGlvbkZpdFNjYWxlKFxuICAgICAgICAgIHNlYyxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGJsZWVkLFxuICAgICAgICAgIG5vZGVzQWxsLFxuICAgICAgICAgIHNlY01vZG8sXG4gICAgICAgICAgQ0ZHLFxuICAgICAgICAgIHsgc2VjSW5kZXg6IHNlY0luZGV4IH0sXG4gICAgICAgICAgeyBwcmVzZXJ2ZUJvdHRvbUdhcDogZ2FwIH1cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGZpdE5lZWRlZCA9IChmaXQgJiYgTnVtYmVyLmlzRmluaXRlKGZpdC5uZWVkZWRIZWlnaHQpKSA/IE51bWJlcihmaXQubmVlZGVkSGVpZ2h0KSA6IDA7XG4gICAgICAgIHZhciBuZWVkZWRIZWlnaHQgPSBNYXRoLm1heChOdW1iZXIobWluTmVlZGVkSGVpZ2h0IHx8IDApLCBmaXROZWVkZWQpO1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOmhlaWdodEZpbmFsXCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgbW9kZTogc2VjTW9kbyxcbiAgICAgICAgICBtaW5OZWVkZWRIZWlnaHQ6ICtOdW1iZXIobWluTmVlZGVkSGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgZml0TmVlZGVkSGVpZ2h0OiArZml0TmVlZGVkLnRvRml4ZWQoMSksXG4gICAgICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtnYXAudG9GaXhlZCgxKSxcbiAgICAgICAgICBmaW5hbE5lZWRlZEhlaWdodDogK25lZWRlZEhlaWdodC50b0ZpeGVkKDEpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VjTW9kbyA9PT0gXCJmaWpvXCIgJiYgbmVlZGVkSGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGV4cGFuZEZpeGVkU2VjdGlvbihzZWMsIG5lZWRlZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIW5vZGVzQWxsLmxlbmd0aCkge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6bm9Ob2Rlc1wiLCB7IHdpbGxBcHBseVJlZmxvdzogZmFsc2UgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVidWdDb3VudHMgPSB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgY29udGVudE9iajogY29udGVudCA/IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikubGVuZ3RoIDogMCxcbiAgICAgICAgYmxlZWRPYmo6IGJsZWVkID8gYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikubGVuZ3RoIDogMCxcbiAgICAgICAgY29udGVudEFiczogY29udGVudCA/IEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYWJzb2x1dGVcIiAmJiBlbC5zdHlsZS50b3AgJiYgZWwuc3R5bGUubGVmdCk7XG4gICAgICAgIH0pLmxlbmd0aCA6IDAsXG4gICAgICAgIGJsZWVkQWJzOiBibGVlZCA/IEFycmF5LmZyb20oYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIipcIikpLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgICAgcmV0dXJuICEhKGVsICYmIGVsLnN0eWxlICYmIChlbC5zdHlsZS5wb3NpdGlvbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImFic29sdXRlXCIgJiYgZWwuc3R5bGUudG9wICYmIGVsLnN0eWxlLmxlZnQpO1xuICAgICAgICB9KS5sZW5ndGggOiAwXG4gICAgICB9O1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpub2RlU291cmNlc1wiLCBkZWJ1Z0NvdW50cyk7XG5cbiAgICAgIGlmIChNU0xfVkVSQk9TRSkge1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVzQWxsOnJhd1wiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHRvdGFsOiBub2Rlc0FsbC5sZW5ndGgsXG4gICAgICAgICAgbm9kZXM6IG5vZGVzQWxsLm1hcChmdW5jdGlvbihuLCBpKXtcbiAgICAgICAgICAgIHZhciBjbHMgPSAobi5jbGFzc05hbWUgJiYgdHlwZW9mIG4uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiKSA/IG4uY2xhc3NOYW1lIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDbHMgPSAobi5wYXJlbnRFbGVtZW50ICYmIG4ucGFyZW50RWxlbWVudC5jbGFzc05hbWUgJiYgdHlwZW9mIG4ucGFyZW50RWxlbWVudC5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgID8gbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICB0YWc6IChuLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgY2xzOiBjbHMsXG4gICAgICAgICAgICAgIHBhcmVudENsczogcGFyZW50Q2xzLFxuICAgICAgICAgICAgICB0b3A6IG4uc3R5bGUgPyBuLnN0eWxlLnRvcCA6IFwiXCIsXG4gICAgICAgICAgICAgIGxlZnQ6IG4uc3R5bGUgPyBuLnN0eWxlLmxlZnQgOiBcIlwiLFxuICAgICAgICAgICAgICBwb3M6IG4uc3R5bGUgPyBuLnN0eWxlLnBvc2l0aW9uIDogXCJcIixcbiAgICAgICAgICAgICAgdGV4dDogKChuLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkuc2xpY2UoMCwgNDApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBmbGF0ID0gbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG4sIGkpe1xuICAgICAgICAgICAgdmFyIGNscyA9IChuLmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbi5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIHR4dCA9ICgobi50ZXh0Q29udGVudCB8fCBcIlwiKS50cmltKCkpLnJlcGxhY2UoL1xcXFxzKy9nLCBcIiBcIikuc2xpY2UoMCwgNjApO1xuICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgaVxuICAgICAgICAgICAgICArIFwiIHRhZz1cIiArIFN0cmluZygobi50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICsgXCIgY2xzPVwiICsgY2xzXG4gICAgICAgICAgICAgICsgXCIgcG9zPVwiICsgKG4uc3R5bGUgPyBuLnN0eWxlLnBvc2l0aW9uIDogXCJcIilcbiAgICAgICAgICAgICAgKyBcIiB0b3A9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUudG9wIDogXCJcIilcbiAgICAgICAgICAgICAgKyBcIiBsZWZ0PVwiICsgKG4uc3R5bGUgPyBuLnN0eWxlLmxlZnQgOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIHRleHQ9XCIgKyB0eHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbXNsTG9nKFwic2VjdGlvbjpub2Rlc0FsbDpmbGF0XCIsIFwic2VjPVwiICsgc2VjSW5kZXggKyBcIiB0b3RhbD1cIiArIG5vZGVzQWxsLmxlbmd0aCArIFwiIDo6IFwiICsgZmxhdC5qb2luKFwiIHwgXCIpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgdmFyIHJlc3RvcmVkQ291bnQgPSAwO1xuICAgICAgbm9kZXNBbGwuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIGhhc09yaWdUb3AgPSBub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIpO1xuICAgICAgICB2YXIgaGFzT3JpZ0xlZnQgPSBub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctbGVmdFwiKTtcbiAgICAgICAgdmFyIGhhc09yaWdUcmFuc2Zvcm0gPSBub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIpO1xuICAgICAgICBpZiAoIWhhc09yaWdUb3ApIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIiwgbm9kZS5zdHlsZS50b3AgfHwgXCJcIik7XG4gICAgICAgIGlmICghaGFzT3JpZ0xlZnQpIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIsIG5vZGUuc3R5bGUubGVmdCB8fCBcIlwiKTtcbiAgICAgICAgaWYgKCFoYXNPcmlnVHJhbnNmb3JtKSBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIsIG5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCIpO1xuXG4gICAgICAgIHZhciBvcmlnVG9wID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRvcFwiKTtcbiAgICAgICAgdmFyIG9yaWdMZWZ0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLWxlZnRcIik7XG4gICAgICAgIHZhciBvcmlnVHJhbnNmb3JtID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiKTtcblxuICAgICAgICBpZiAob3JpZ1RvcCAhPSBudWxsICYmIG5vZGUuc3R5bGUudG9wICE9PSBvcmlnVG9wKSB7XG4gICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBvcmlnVG9wO1xuICAgICAgICAgIHJlc3RvcmVkQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ0xlZnQgIT0gbnVsbCAmJiBub2RlLnN0eWxlLmxlZnQgIT09IG9yaWdMZWZ0KSB7XG4gICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gb3JpZ0xlZnQ7XG4gICAgICAgICAgcmVzdG9yZWRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnVHJhbnNmb3JtICE9IG51bGwgJiYgbm9kZS5zdHlsZS50cmFuc2Zvcm0gIT09IG9yaWdUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IG9yaWdUcmFuc2Zvcm07XG4gICAgICAgICAgcmVzdG9yZWRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcbiAgICAgIH0pO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpiYXNlbGluZVJlc3RvcmVcIiwgeyBzZWNJbmRleDogc2VjSW5kZXgsIG5vZGVzOiBub2Rlc0FsbC5sZW5ndGgsIHJlc3RvcmVkOiByZXN0b3JlZENvdW50IH0pO1xuXG4gICAgICAvLyBSZWN0IGRlbCBjb250ZW50IChtw6l0cmljYXMgcmVhbGVzKVxuICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjb250ZW50VyA9IGNvbnRlbnRSZWN0LndpZHRoIHx8IDA7XG4gICAgICB2YXIgc2VjQ3VycmVudEggPSBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IDA7XG4gICAgICB2YXIgYmFzZUhlaWdodEF0dHIgPSBcImRhdGEtbXNsLWJhc2UtaGVpZ2h0XCI7XG4gICAgICBpZiAoIXNlYy5oYXNBdHRyaWJ1dGUoYmFzZUhlaWdodEF0dHIpKSB7XG4gICAgICAgIHNlYy5zZXRBdHRyaWJ1dGUoYmFzZUhlaWdodEF0dHIsIFN0cmluZyhzZWNDdXJyZW50SCkpO1xuICAgICAgfVxuICAgICAgdmFyIGJhc2VTZWNIZWlnaHQgPSBwYXJzZUZsb2F0KHNlYy5nZXRBdHRyaWJ1dGUoYmFzZUhlaWdodEF0dHIpIHx8IFwiXCIpO1xuICAgICAgaWYgKCFpc0Zpbml0ZShiYXNlU2VjSGVpZ2h0KSB8fCBiYXNlU2VjSGVpZ2h0IDw9IDApIGJhc2VTZWNIZWlnaHQgPSBzZWNDdXJyZW50SDtcblxyXG4gICAgICAvLyBpdGVtcyAocmVjdHMpIGVuIGNvb3JkZW5hZGFzIGRlbCBjb250ZW50IChUT0RPUylcclxuICAgICAgdmFyIGl0ZW1zQWxsID0gbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICB2YXIgcmMgPSByZWxSZWN0KG5vZGUsIGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgdG9wOiByYy50b3AsXG4gICAgICAgICAgbGVmdDogcmMubGVmdCxcclxuICAgICAgICAgIGhlaWdodDogcmMuaGVpZ2h0LFxyXG4gICAgICAgICAgd2lkdGg6IHJjLndpZHRoXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGJ1aWxkUmVmbG93RWxlbWVudHNEdW1wKGl0ZW1zQWxsLCBjb250ZW50Vyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOnJlZmxvdzplbGVtZW50c1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgc2VjTW9kbzogc2VjTW9kbyxcbiAgICAgICAgY29udGVudFc6ICtOdW1iZXIoY29udGVudFcgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgdG90YWw6IHJlZmxvd0VsZW1lbnRzRHVtcC5sZW5ndGgsXG4gICAgICAgIGVsZW1lbnRzOiByZWZsb3dFbGVtZW50c0R1bXBcbiAgICAgIH0pO1xuICAgICAgaWYgKE1TTF9WRVJCT1NFKSB7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246aXRlbXNBbGxcIiwge1xuICAgICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgICB0b3RhbDogaXRlbXNBbGwubGVuZ3RoLFxuICAgICAgICAgIGl0ZW1zOiBpdGVtc0FsbC5tYXAoZnVuY3Rpb24oaXQsIGlkeCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpOiBpZHgsXG4gICAgICAgICAgICAgIGtpbmQ6IChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiID8gXCJ0ZXh0b1wiIDogKGl0Lm5vZGUudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICB0b3A6ICtpdC50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgbGVmdDogK2l0LmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgdzogK2l0LndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGg6ICtpdC5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgdGV4dEFsaWduOiAoaXQubm9kZS5zdHlsZSAmJiBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbikgPyBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbiA6IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXNlcnZhciBlbCBcImFpcmVcIiBpbmZlcmlvciBvcmlnaW5hbCBkZSBsYSBzZWNjaW9uIHRyYXMgZWwgcmVmbG93LlxuICAgICAgdmFyIG1heE9yaWdpbmFsQm90dG9tID0gMDtcbiAgICAgIGZvciAodmFyIGliPTA7IGliPGl0ZW1zQWxsLmxlbmd0aDsgaWIrKyl7XG4gICAgICAgIHZhciBpdGIgPSBpdGVtc0FsbFtpYl07XG4gICAgICAgIHZhciBidG0gPSAoaXRiLnRvcCB8fCAwKSArIChpdGIuaGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAoYnRtID4gbWF4T3JpZ2luYWxCb3R0b20pIG1heE9yaWdpbmFsQm90dG9tID0gYnRtO1xuICAgICAgfVxuICAgICAgdmFyIGJhc2VCb3R0b21HYXAgPSBNYXRoLm1heCgwLCBiYXNlU2VjSGVpZ2h0IC0gbWF4T3JpZ2luYWxCb3R0b20pO1xuXG4gICAgICAvLyBTaSB0b2RvIG1pZGUgMCAoZm9udHMgbm8gbGlzdGFzKSwgcmVpbnRlbnRhbW9zIGx1ZWdvXG4gICAgICB2YXIgYW55VmFsaWRBbGwgPSBpdGVtc0FsbC5zb21lKGZ1bmN0aW9uKGl0KXsgcmV0dXJuIGl0LmhlaWdodCA+IDAuNTsgfSk7XG4gICAgICBpZighYW55VmFsaWRBbGwpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOmludmFsaWRSZWN0c1wiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBhbGxIZWlnaHRzVGlueTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYWxsb3dSZWZsb3cgfHwgbm9kZXNBbGwubGVuZ3RoIDwgMikge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6bm90RWxpZ2libGVcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dSZWZsb3c6IGFsbG93UmVmbG93LFxuICAgICAgICAgIHRvdGFsTm9kZXM6IG5vZGVzQWxsLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGVjdEhlcm9MaWtlQ2VudHJhbFRleHQoaXRlbXMsIHJvb3RXKXtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICBpc0hlcm86IGZhbHNlLFxuICAgICAgICAgIHJlYXNvbjogXCJcIixcbiAgICAgICAgICB0ZXh0Q291bnQ6IDAsXG4gICAgICAgICAgdGV4dENvbHVtbkNvdW50OiAwLFxuICAgICAgICAgIHRleHRDb2x1bW5zOiBbXSxcbiAgICAgICAgICBzaW5nbGVUZXh0Q29sdW1uOiBmYWxzZSxcbiAgICAgICAgICBtYXhUZXh0V2lkdGhSYXRpbzogbnVsbCxcbiAgICAgICAgICB3aWR0aFJhdGlvOiBudWxsLFxuICAgICAgICAgIGNlbnRlckRlbHRhOiBudWxsLFxuICAgICAgICAgIGNlbnRlclRvbDogbnVsbCxcbiAgICAgICAgICBjZW50ZXJlZEJ5QWxpZ246IGZhbHNlLFxuICAgICAgICAgIGNlbnRlcmVkQnlHZW9tZXRyeTogZmFsc2UsXG4gICAgICAgICAgZGVjb3JOZWFyOiAwLFxuICAgICAgICAgIGRlY29yTGVmdDogMCxcbiAgICAgICAgICBkZWNvclJpZ2h0OiAwLFxuICAgICAgICAgIGRlY29ySW52YWRpbmdUZXh0Q29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCB8fCAhcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vSXRlbXNPcldpZHRoXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0SXRlbXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXQpe1xuICAgICAgICAgIGlmICgoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpICE9PSBcIjFcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhciB0dyA9IE51bWJlcihpdC53aWR0aCB8fCAwKTtcbiAgICAgICAgICB2YXIgdGggPSBOdW1iZXIoaXQuaGVpZ2h0IHx8IDApO1xuICAgICAgICAgIHJldHVybiB0dyA+IDIgJiYgdGggPiAyO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0LnRleHRDb3VudCA9IHRleHRJdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmICghdGV4dEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vVGV4dFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwbGljaXRIZXJvID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGVoPTA7IGVoPHRleHRJdGVtcy5sZW5ndGg7IGVoKyspe1xuICAgICAgICAgIHZhciByb2xlRWggPSAodGV4dEl0ZW1zW2VoXS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLXJvbGVcIikgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAocm9sZUVoID09PSBcImhlcm9cIikge1xuICAgICAgICAgICAgZXhwbGljaXRIZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xUb2wgPSBNYXRoLm1heCgxOCwgcm9vdFcgKiAwLjE0KTtcbiAgICAgICAgdmFyIHRleHRDb2xzID0gW107XG4gICAgICAgIGZvciAodmFyIHRjPTA7IHRjPHRleHRJdGVtcy5sZW5ndGg7IHRjKyspe1xuICAgICAgICAgIHZhciB0eHQgPSB0ZXh0SXRlbXNbdGNdO1xuICAgICAgICAgIHZhciB0eHRDeCA9IE51bWJlcih0eHQubGVmdCB8fCAwKSArIE51bWJlcih0eHQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgIHZhciBhdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGNjPTA7IGNjPHRleHRDb2xzLmxlbmd0aDsgY2MrKyl7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModHh0Q3ggLSB0ZXh0Q29sc1tjY10uY3gpIDw9IGNvbFRvbCkge1xuICAgICAgICAgICAgICB2YXIgbkNvbCA9IHRleHRDb2xzW2NjXS5jb3VudCArIDE7XG4gICAgICAgICAgICAgIHRleHRDb2xzW2NjXS5jeCA9ICgodGV4dENvbHNbY2NdLmN4ICogdGV4dENvbHNbY2NdLmNvdW50KSArIHR4dEN4KSAvIG5Db2w7XG4gICAgICAgICAgICAgIHRleHRDb2xzW2NjXS5jb3VudCA9IG5Db2w7XG4gICAgICAgICAgICAgIHRleHRDb2xzW2NjXS5taW5MZWZ0ID0gTWF0aC5taW4odGV4dENvbHNbY2NdLm1pbkxlZnQsIE51bWJlcih0eHQubGVmdCB8fCAwKSk7XG4gICAgICAgICAgICAgIHRleHRDb2xzW2NjXS5tYXhSaWdodCA9IE1hdGgubWF4KHRleHRDb2xzW2NjXS5tYXhSaWdodCwgTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSk7XG4gICAgICAgICAgICAgIHRleHRDb2xzW2NjXS5taW5Ub3AgPSBNYXRoLm1pbih0ZXh0Q29sc1tjY10ubWluVG9wLCBOdW1iZXIodHh0LnRvcCB8fCAwKSk7XG4gICAgICAgICAgICAgIHRleHRDb2xzW2NjXS5tYXhCb3R0b20gPSBNYXRoLm1heCh0ZXh0Q29sc1tjY10ubWF4Qm90dG9tLCBOdW1iZXIodHh0LnRvcCB8fCAwKSArIE51bWJlcih0eHQuaGVpZ2h0IHx8IDApKTtcbiAgICAgICAgICAgICAgYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhdHRhY2hlZCkge1xuICAgICAgICAgICAgdGV4dENvbHMucHVzaCh7XG4gICAgICAgICAgICAgIGN4OiB0eHRDeCxcbiAgICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICAgIG1pbkxlZnQ6IE51bWJlcih0eHQubGVmdCB8fCAwKSxcbiAgICAgICAgICAgICAgbWF4UmlnaHQ6IE51bWJlcih0eHQubGVmdCB8fCAwKSArIE51bWJlcih0eHQud2lkdGggfHwgMCksXG4gICAgICAgICAgICAgIG1pblRvcDogTnVtYmVyKHR4dC50b3AgfHwgMCksXG4gICAgICAgICAgICAgIG1heEJvdHRvbTogTnVtYmVyKHR4dC50b3AgfHwgMCkgKyBOdW1iZXIodHh0LmhlaWdodCB8fCAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRleHRDb2xzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEuY3ggLSBiLmN4OyB9KTtcbiAgICAgICAgb3V0LnRleHRDb2x1bW5Db3VudCA9IHRleHRDb2xzLmxlbmd0aDtcbiAgICAgICAgb3V0LnNpbmdsZVRleHRDb2x1bW4gPSB0ZXh0Q29scy5sZW5ndGggPT09IDE7XG4gICAgICAgIG91dC50ZXh0Q29sdW1ucyA9IHRleHRDb2xzLm1hcChmdW5jdGlvbihjb2wpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjeDogK051bWJlcihjb2wuY3ggfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGNvdW50OiBjb2wuY291bnQsXG4gICAgICAgICAgICBsZWZ0OiArTnVtYmVyKGNvbC5taW5MZWZ0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICByaWdodDogK051bWJlcihjb2wubWF4UmlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHRvcDogK051bWJlcihjb2wubWluVG9wIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBib3R0b206ICtOdW1iZXIoY29sLm1heEJvdHRvbSB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3V0LnNpbmdsZVRleHRDb2x1bW4pIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gZXhwbGljaXRIZXJvID8gXCJleHBsaWNpdEhlcm9Sb2xlXCIgOiBcIm11bHRpVGV4dENvbHVtbnNcIjtcbiAgICAgICAgICBvdXQuaXNIZXJvID0gZXhwbGljaXRIZXJvO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VudGVyWCA9IHJvb3RXIC8gMjtcbiAgICAgICAgdmFyIHRleHRDb2wgPSB0ZXh0Q29sc1swXTtcbiAgICAgICAgdmFyIHRleHRDZW50ZXJYID0gTnVtYmVyKHRleHRDb2wuY3ggfHwgY2VudGVyWCk7XG4gICAgICAgIHZhciBjZW50ZXJEZWx0YSA9IE1hdGguYWJzKHRleHRDZW50ZXJYIC0gY2VudGVyWCk7XG4gICAgICAgIHZhciBjZW50ZXJUb2wgPSBNYXRoLm1heCgxOCwgcm9vdFcgKiAwLjEyKTtcbiAgICAgICAgb3V0LmNlbnRlckRlbHRhID0gK2NlbnRlckRlbHRhLnRvRml4ZWQoMSk7XG4gICAgICAgIG91dC5jZW50ZXJUb2wgPSArY2VudGVyVG9sLnRvRml4ZWQoMSk7XG5cbiAgICAgICAgdmFyIGNlbnRlcmVkQWxpZ25Db3VudCA9IDA7XG4gICAgICAgIHZhciBtYXhUZXh0V2lkdGhSYXRpbyA9IDA7XG4gICAgICAgIHZhciB0ZXh0VG9wID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB0ZXh0Qm90dG9tID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciB0aXg9MDsgdGl4PHRleHRJdGVtcy5sZW5ndGg7IHRpeCsrKXtcbiAgICAgICAgICB2YXIgdCA9IHRleHRJdGVtc1t0aXhdO1xuICAgICAgICAgIHZhciB0YSA9ICh0Lm5vZGUgJiYgdC5ub2RlLnN0eWxlICYmIHQubm9kZS5zdHlsZS50ZXh0QWxpZ24pXG4gICAgICAgICAgICA/IFN0cmluZyh0Lm5vZGUuc3R5bGUudGV4dEFsaWduKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgaWYgKHRhID09PSBcImNlbnRlclwiKSBjZW50ZXJlZEFsaWduQ291bnQrKztcbiAgICAgICAgICB2YXIgd1JhdGlvID0gTnVtYmVyKHQud2lkdGggfHwgMCkgLyBNYXRoLm1heCgxLCByb290Vyk7XG4gICAgICAgICAgaWYgKHdSYXRpbyA+IG1heFRleHRXaWR0aFJhdGlvKSBtYXhUZXh0V2lkdGhSYXRpbyA9IHdSYXRpbztcbiAgICAgICAgICB0ZXh0VG9wID0gTWF0aC5taW4odGV4dFRvcCwgTnVtYmVyKHQudG9wIHx8IDApKTtcbiAgICAgICAgICB0ZXh0Qm90dG9tID0gTWF0aC5tYXgodGV4dEJvdHRvbSwgTnVtYmVyKHQudG9wIHx8IDApICsgTnVtYmVyKHQuaGVpZ2h0IHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQubWF4VGV4dFdpZHRoUmF0aW8gPSArbWF4VGV4dFdpZHRoUmF0aW8udG9GaXhlZCgzKTtcbiAgICAgICAgb3V0LndpZHRoUmF0aW8gPSBvdXQubWF4VGV4dFdpZHRoUmF0aW87XG4gICAgICAgIG91dC5jZW50ZXJlZEJ5QWxpZ24gPSBjZW50ZXJlZEFsaWduQ291bnQgPj0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRleHRJdGVtcy5sZW5ndGggKiAwLjUpKTtcbiAgICAgICAgb3V0LmNlbnRlcmVkQnlHZW9tZXRyeSA9IGNlbnRlckRlbHRhIDw9IGNlbnRlclRvbDtcbiAgICAgICAgaWYgKCFvdXQuY2VudGVyZWRCeUFsaWduICYmICFvdXQuY2VudGVyZWRCeUdlb21ldHJ5KSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IGV4cGxpY2l0SGVybyA/IFwiZXhwbGljaXRIZXJvUm9sZVwiIDogXCJzaW5nbGVUZXh0Q29sdW1uTm90Q2VudGVyZWRcIjtcbiAgICAgICAgICBvdXQuaXNIZXJvID0gZXhwbGljaXRIZXJvO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdml0YSBtYXJjYXIgY29tbyBoZXJvIHRleHRvcyBzdWVsdG9zIG11eSBjaGljb3MuXG4gICAgICAgIGlmICh0ZXh0SXRlbXMubGVuZ3RoIDwgMiAmJiBtYXhUZXh0V2lkdGhSYXRpbyA8IDAuMjggJiYgIWV4cGxpY2l0SGVybykge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcInRleHRUb29TbWFsbFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRmluaXRlKHRleHRUb3ApIHx8ICFpc0Zpbml0ZSh0ZXh0Qm90dG9tKSB8fCB0ZXh0Qm90dG9tIDw9IHRleHRUb3ApIHtcbiAgICAgICAgICB0ZXh0VG9wID0gMDtcbiAgICAgICAgICB0ZXh0Qm90dG9tID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhclRvcCA9IHRleHRUb3AgLSBNYXRoLm1heCgyOCwgKHRleHRCb3R0b20gLSB0ZXh0VG9wKSAqIDAuMik7XG4gICAgICAgIHZhciBuZWFyQm90dG9tID0gdGV4dEJvdHRvbSArIE1hdGgubWF4KDM2LCAodGV4dEJvdHRvbSAtIHRleHRUb3ApICogMC4zNSk7XG4gICAgICAgIHZhciBpbnZhZGVQYWQgPSBNYXRoLm1heCgyNCwgcm9vdFcgKiAwLjE3KTtcbiAgICAgICAgdmFyIGludmFkZUxlZnQgPSB0ZXh0Q2VudGVyWCAtIGludmFkZVBhZDtcbiAgICAgICAgdmFyIGludmFkZVJpZ2h0ID0gdGV4dENlbnRlclggKyBpbnZhZGVQYWQ7XG5cbiAgICAgICAgdmFyIGRlY29yTmVhciA9IDA7XG4gICAgICAgIHZhciBkZWNvckxlZnQgPSAwO1xuICAgICAgICB2YXIgZGVjb3JSaWdodCA9IDA7XG4gICAgICAgIHZhciBkZWNvckludmFkaW5nID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpSGVybz0wOyBpSGVybzxpdGVtcy5sZW5ndGg7IGlIZXJvKyspe1xuICAgICAgICAgIHZhciBpdCA9IGl0ZW1zW2lIZXJvXTtcbiAgICAgICAgICBpZiAoKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgdmFyIHcgPSBOdW1iZXIoaXQud2lkdGggfHwgMCk7XG4gICAgICAgICAgdmFyIGggPSBOdW1iZXIoaXQuaGVpZ2h0IHx8IDApO1xuICAgICAgICAgIGlmICh3IDwgOCB8fCBoIDwgOCkgY29udGludWU7XG5cbiAgICAgICAgICB2YXIgdG9wID0gTnVtYmVyKGl0LnRvcCB8fCAwKTtcbiAgICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgaDtcbiAgICAgICAgICB2YXIgaW5CYW5kID0gIShib3R0b20gPCBuZWFyVG9wIHx8IHRvcCA+IG5lYXJCb3R0b20pO1xuICAgICAgICAgIGlmICghaW5CYW5kKSBjb250aW51ZTtcblxuICAgICAgICAgIGRlY29yTmVhcisrO1xuICAgICAgICAgIHZhciBjeCA9IE51bWJlcihpdC5sZWZ0IHx8IDApICsgdyAvIDI7XG4gICAgICAgICAgaWYgKGN4IDwgdGV4dENlbnRlclggLSA4KSBkZWNvckxlZnQrKztcbiAgICAgICAgICBlbHNlIGlmIChjeCA+IHRleHRDZW50ZXJYICsgOCkgZGVjb3JSaWdodCsrO1xuXG4gICAgICAgICAgdmFyIGxlZnQgPSBOdW1iZXIoaXQubGVmdCB8fCAwKTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgdztcbiAgICAgICAgICBpZiAocmlnaHQgPiBpbnZhZGVMZWZ0ICYmIGxlZnQgPCBpbnZhZGVSaWdodCkgZGVjb3JJbnZhZGluZysrO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LmRlY29yTmVhciA9IGRlY29yTmVhcjtcbiAgICAgICAgb3V0LmRlY29yTGVmdCA9IGRlY29yTGVmdDtcbiAgICAgICAgb3V0LmRlY29yUmlnaHQgPSBkZWNvclJpZ2h0O1xuICAgICAgICBvdXQuZGVjb3JJbnZhZGluZ1RleHRDb2x1bW4gPSBkZWNvckludmFkaW5nO1xuXG4gICAgICAgIHZhciBkZWNvckFyb3VuZCA9IChkZWNvckxlZnQgPiAwICYmIGRlY29yUmlnaHQgPiAwKSB8fCBkZWNvck5lYXIgPj0gMztcbiAgICAgICAgdmFyIGNlbnRlcmVkU2luZ2xlVGV4dENvbHVtbiA9IG91dC5zaW5nbGVUZXh0Q29sdW1uICYmIChvdXQuY2VudGVyZWRCeUFsaWduIHx8IG91dC5jZW50ZXJlZEJ5R2VvbWV0cnkpO1xuICAgICAgICBvdXQuaXNIZXJvID0gZXhwbGljaXRIZXJvIHx8IGNlbnRlcmVkU2luZ2xlVGV4dENvbHVtbjtcbiAgICAgICAgb3V0LnJlYXNvbiA9IG91dC5pc0hlcm9cbiAgICAgICAgICA/IChcbiAgICAgICAgICAgIGV4cGxpY2l0SGVyb1xuICAgICAgICAgICAgICA/IFwiZXhwbGljaXRIZXJvUm9sZVwiXG4gICAgICAgICAgICAgIDogKGRlY29ySW52YWRpbmcgPiAwXG4gICAgICAgICAgICAgICAgPyBcInNpbmdsZUNlbnRlcmVkVGV4dENvbHVtbkRlY29ySW52YWRlc1wiXG4gICAgICAgICAgICAgICAgOiAoZGVjb3JBcm91bmRcbiAgICAgICAgICAgICAgICAgID8gXCJzaW5nbGVDZW50ZXJlZFRleHRDb2x1bW5XaXRoRGVjb3JcIlxuICAgICAgICAgICAgICAgICAgOiBcInNpbmdsZUNlbnRlcmVkVGV4dENvbHVtblwiKSlcbiAgICAgICAgICApXG4gICAgICAgICAgOiBcIm5vSGVyb1NpZ25hbFwiO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXRlY3RJbmxpbmVQYWlyTm9SZWZsb3coZmxvd0l0ZW1zLCBhbGxJdGVtcywgcm9vdFcsIENGRyl7XG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgc2tpcDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIHRvdGFsRmxvdzogZmxvd0l0ZW1zID8gZmxvd0l0ZW1zLmxlbmd0aCA6IDAsXG4gICAgICAgICAgdG90YWxBbGw6IGFsbEl0ZW1zID8gYWxsSXRlbXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByb3dEZWx0YTogbnVsbCxcbiAgICAgICAgICByb3dUb2w6IG51bGwsXG4gICAgICAgICAgcGFpclNwYW46IG51bGwsXG4gICAgICAgICAgcGFpclNwYW5SYXRpbzogbnVsbCxcbiAgICAgICAgICBmaXRzVG9nZXRoZXI6IGZhbHNlLFxuICAgICAgICAgIGJvdGhTbWFsbDogZmFsc2UsXG4gICAgICAgICAgc21hbGxXTGltaXQ6IG51bGwsXG4gICAgICAgICAgc21hbGxITGltaXQ6IG51bGwsXG4gICAgICAgICAgd2lkdGhzOiBbXSxcbiAgICAgICAgICBoZWlnaHRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWZsb3dJdGVtcyB8fCBmbG93SXRlbXMubGVuZ3RoICE9PSAyIHx8ICFhbGxJdGVtcyB8fCBhbGxJdGVtcy5sZW5ndGggIT09IDIgfHwgIXJvb3RXIHx8IHJvb3RXIDw9IDApIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub3RFeGFjdFBhaXJcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBmbG93SXRlbXNbMF07XG4gICAgICAgIHZhciBiID0gZmxvd0l0ZW1zWzFdO1xuICAgICAgICB2YXIgYVcgPSBNYXRoLm1heCgwLCBOdW1iZXIoYS53aWR0aCB8fCAwKSk7XG4gICAgICAgIHZhciBiVyA9IE1hdGgubWF4KDAsIE51bWJlcihiLndpZHRoIHx8IDApKTtcbiAgICAgICAgdmFyIGFIID0gTWF0aC5tYXgoMCwgTnVtYmVyKGEuaGVpZ2h0IHx8IDApKTtcbiAgICAgICAgdmFyIGJIID0gTWF0aC5tYXgoMCwgTnVtYmVyKGIuaGVpZ2h0IHx8IDApKTtcbiAgICAgICAgb3V0LndpZHRocyA9IFsrYVcudG9GaXhlZCgxKSwgK2JXLnRvRml4ZWQoMSldO1xuICAgICAgICBvdXQuaGVpZ2h0cyA9IFsrYUgudG9GaXhlZCgxKSwgK2JILnRvRml4ZWQoMSldO1xuXG4gICAgICAgIGlmIChhVyA8IDIgfHwgYlcgPCAyIHx8IGFIIDwgMiB8fCBiSCA8IDIpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJpbnZhbGlkU2l6ZXNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvd1RvbCA9IE1hdGgubWF4KDEyLCBOdW1iZXIoKENGRyAmJiBDRkcuUk9XX1RPTCkgfHwgMjgpICogMS4yKTtcbiAgICAgICAgdmFyIHJvd0RlbHRhID0gTWF0aC5hYnMoTnVtYmVyKGEudG9wIHx8IDApIC0gTnVtYmVyKGIudG9wIHx8IDApKTtcbiAgICAgICAgb3V0LnJvd1RvbCA9ICtyb3dUb2wudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LnJvd0RlbHRhID0gK3Jvd0RlbHRhLnRvRml4ZWQoMSk7XG4gICAgICAgIGlmIChyb3dEZWx0YSA+IHJvd1RvbCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vdElubGluZVJvd1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc21hbGxXTGltaXQgPSBNYXRoLm1heCg3NCwgcm9vdFcgKiAwLjQyKTtcbiAgICAgICAgdmFyIHNtYWxsSExpbWl0ID0gTWF0aC5tYXgoMzQsIHJvb3RXICogMC4yKTtcbiAgICAgICAgb3V0LnNtYWxsV0xpbWl0ID0gK3NtYWxsV0xpbWl0LnRvRml4ZWQoMSk7XG4gICAgICAgIG91dC5zbWFsbEhMaW1pdCA9ICtzbWFsbEhMaW1pdC50b0ZpeGVkKDEpO1xuICAgICAgICB2YXIgYm90aFNtYWxsID1cbiAgICAgICAgICBhVyA8PSBzbWFsbFdMaW1pdCAmJlxuICAgICAgICAgIGJXIDw9IHNtYWxsV0xpbWl0ICYmXG4gICAgICAgICAgYUggPD0gc21hbGxITGltaXQgJiZcbiAgICAgICAgICBiSCA8PSBzbWFsbEhMaW1pdDtcbiAgICAgICAgb3V0LmJvdGhTbWFsbCA9IGJvdGhTbWFsbDtcbiAgICAgICAgaWYgKCFib3RoU21hbGwpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJwYWlyTm90U21hbGxcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhaXJMZWZ0ID0gTWF0aC5taW4oTnVtYmVyKGEubGVmdCB8fCAwKSwgTnVtYmVyKGIubGVmdCB8fCAwKSk7XG4gICAgICAgIHZhciBwYWlyUmlnaHQgPSBNYXRoLm1heChOdW1iZXIoYS5sZWZ0IHx8IDApICsgYVcsIE51bWJlcihiLmxlZnQgfHwgMCkgKyBiVyk7XG4gICAgICAgIHZhciBwYWlyU3BhbiA9IE1hdGgubWF4KDAsIHBhaXJSaWdodCAtIHBhaXJMZWZ0KTtcbiAgICAgICAgdmFyIGZpdHNUb2dldGhlciA9IHBhaXJTcGFuIDw9IChyb290VyArIDEpO1xuICAgICAgICBvdXQucGFpclNwYW4gPSArcGFpclNwYW4udG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LnBhaXJTcGFuUmF0aW8gPSArKHBhaXJTcGFuIC8gTWF0aC5tYXgoMSwgcm9vdFcpKS50b0ZpeGVkKDMpO1xuICAgICAgICBvdXQuZml0c1RvZ2V0aGVyID0gZml0c1RvZ2V0aGVyO1xuXG4gICAgICAgIGlmIChmaXRzVG9nZXRoZXIpIHtcbiAgICAgICAgICBvdXQuc2tpcCA9IHRydWU7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwic21hbGxJbmxpbmVQYWlyRml0c1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQucmVhc29uID0gXCJzbWFsbElubGluZVBhaXJPdmVyZmxvd1wiO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmZvcmNlSW5saW5lUGFpckdhcChmbG93SXRlbXMsIHJvb3RFbCwgcm9vdFcpe1xuICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgIGFwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAgIHJlYXNvbjogXCJcIixcbiAgICAgICAgICBtaW5HYXA6IDYsXG4gICAgICAgICAgZ2FwQmVmb3JlOiBudWxsLFxuICAgICAgICAgIGdhcEFmdGVyOiBudWxsLFxuICAgICAgICAgIG5lZWQ6IG51bGwsXG4gICAgICAgICAgbW92ZUxlZnQ6IDAsXG4gICAgICAgICAgbW92ZVJpZ2h0OiAwLFxuICAgICAgICAgIG92ZXJmbG93QmVmb3JlOiBmYWxzZSxcbiAgICAgICAgICBvdmVyZmxvd0FmdGVyOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWZsb3dJdGVtcyB8fCBmbG93SXRlbXMubGVuZ3RoICE9PSAyIHx8ICFyb290RWwgfHwgIXJvb3RXIHx8IHJvb3RXIDw9IDApIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub3RFeGFjdFBhaXJcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBmbG93SXRlbXNbMF07XG4gICAgICAgIHZhciBiID0gZmxvd0l0ZW1zWzFdO1xuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgIWEubm9kZSB8fCAhYi5ub2RlKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibWlzc2luZ05vZGVzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0SXRlbSA9IE51bWJlcihhLmxlZnQgfHwgMCkgPD0gTnVtYmVyKGIubGVmdCB8fCAwKSA/IGEgOiBiO1xuICAgICAgICB2YXIgcmlnaHRJdGVtID0gKGxlZnRJdGVtID09PSBhKSA/IGIgOiBhO1xuXG4gICAgICAgIHZhciByckwgPSByZWxSZWN0KGxlZnRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciByclIgPSByZWxSZWN0KHJpZ2h0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgbExlZnQgPSBOdW1iZXIocnJMLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciBsVyA9IE51bWJlcihyckwud2lkdGggfHwgMCk7XG4gICAgICAgIHZhciByTGVmdCA9IE51bWJlcihyclIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIHJXID0gTnVtYmVyKHJyUi53aWR0aCB8fCAwKTtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsTGVmdCkgfHwgIWlzRmluaXRlKGxXKSB8fCAhaXNGaW5pdGUockxlZnQpIHx8ICFpc0Zpbml0ZShyVykpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJpbnZhbGlkUmVjdHNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdhcEJlZm9yZSA9IHJMZWZ0IC0gKGxMZWZ0ICsgbFcpO1xuICAgICAgICBvdXQuZ2FwQmVmb3JlID0gK2dhcEJlZm9yZS50b0ZpeGVkKDIpO1xuICAgICAgICBvdXQub3ZlcmZsb3dCZWZvcmUgPSAobExlZnQgPCAtMC41KSB8fCAoKHJMZWZ0ICsgclcpID4gKHJvb3RXICsgMC41KSk7XG5cbiAgICAgICAgdmFyIG5lZWQgPSBNYXRoLm1heCgwLCBvdXQubWluR2FwIC0gZ2FwQmVmb3JlKTtcbiAgICAgICAgb3V0Lm5lZWQgPSArbmVlZC50b0ZpeGVkKDIpO1xuICAgICAgICBpZiAobmVlZCA8PSAwLjI1KSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiYWxyZWFkeVNwYWNlZFwiO1xuICAgICAgICAgIG91dC5nYXBBZnRlciA9IG91dC5nYXBCZWZvcmU7XG4gICAgICAgICAgb3V0Lm92ZXJmbG93QWZ0ZXIgPSBvdXQub3ZlcmZsb3dCZWZvcmU7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdmFpbFJpZ2h0ID0gTWF0aC5tYXgoMCwgcm9vdFcgLSAockxlZnQgKyByVykpO1xuICAgICAgICB2YXIgYXZhaWxMZWZ0ID0gTWF0aC5tYXgoMCwgbExlZnQpO1xuICAgICAgICB2YXIgbW92ZVJpZ2h0ID0gTWF0aC5taW4oYXZhaWxSaWdodCwgbmVlZCk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBNYXRoLm1heCgwLCBuZWVkIC0gbW92ZVJpZ2h0KTtcbiAgICAgICAgdmFyIG1vdmVMZWZ0ID0gTWF0aC5taW4oYXZhaWxMZWZ0LCByZW1haW5pbmcpO1xuXG4gICAgICAgIGlmIChtb3ZlUmlnaHQgPD0gMC4wMSAmJiBtb3ZlTGVmdCA8PSAwLjAxKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9Sb29tVG9BZGp1c3RcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmVSaWdodCA+IDAuMDEpIHtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5sZWZ0ID0gKE51bWJlcihyaWdodEl0ZW0ubGVmdCB8fCAwKSArIG1vdmVSaWdodCkgKyBcInB4XCI7XG4gICAgICAgICAgcmlnaHRJdGVtLm5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZUxlZnQgPiAwLjAxKSB7XG4gICAgICAgICAgbGVmdEl0ZW0ubm9kZS5zdHlsZS5sZWZ0ID0gKE51bWJlcihsZWZ0SXRlbS5sZWZ0IHx8IDApIC0gbW92ZUxlZnQpICsgXCJweFwiO1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICBsZWZ0SXRlbS5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJyTDIgPSByZWxSZWN0KGxlZnRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciByclIyID0gcmVsUmVjdChyaWdodEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIGxMZWZ0MiA9IE51bWJlcihyckwyLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciBsVzIgPSBOdW1iZXIocnJMMi53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIHJMZWZ0MiA9IE51bWJlcihyclIyLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciByVzIgPSBOdW1iZXIocnJSMi53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIGdhcEFmdGVyID0gckxlZnQyIC0gKGxMZWZ0MiArIGxXMik7XG5cbiAgICAgICAgb3V0Lm1vdmVSaWdodCA9ICttb3ZlUmlnaHQudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0Lm1vdmVMZWZ0ID0gK21vdmVMZWZ0LnRvRml4ZWQoMik7XG4gICAgICAgIG91dC5nYXBBZnRlciA9IGlzRmluaXRlKGdhcEFmdGVyKSA/ICtnYXBBZnRlci50b0ZpeGVkKDIpIDogbnVsbDtcbiAgICAgICAgb3V0Lm92ZXJmbG93QWZ0ZXIgPSAobExlZnQyIDwgLTAuNSkgfHwgKChyTGVmdDIgKyByVzIpID4gKHJvb3RXICsgMC41KSk7XG4gICAgICAgIG91dC5hcHBsaWVkID0gKG1vdmVSaWdodCA+IDAuMDEgfHwgbW92ZUxlZnQgPiAwLjAxKTtcbiAgICAgICAgb3V0LnJlYXNvbiA9IG91dC5hcHBsaWVkID8gXCJhcHBsaWVkXCIgOiBcIm5vQ2hhbmdlXCI7XG4gICAgICAgIGlmIChpc0Zpbml0ZShnYXBBZnRlcikgJiYgZ2FwQWZ0ZXIgPCAtMC4yKSBvdXQucmVhc29uID0gXCJhcHBsaWVkQnV0U3RpbGxPdmVybGFwXCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIOKchSBEZXRlcm1pbmFyIHF1w6kgbm9kb3Mgc29uIFwiQU5DSE9SXCIgKG5vIHNlIHJlZmxvd2VhbilcbiAgICAgIC8vIFJlZ2xhOiB0ZXh0byBjZW50cmFkbyArIGNhc2kgZnVsbC13aWR0aCA9PiB0w610dWxvL2hlcm8sIG5vIG1vdmVyLlxuICAgICAgZnVuY3Rpb24gaXNBbmNob3JOb2RlKGl0KXtcbiAgICAgICAgdmFyIG5vZGUgPSBpdC5ub2RlO1xyXG5cclxuICAgICAgICAvLyBvcHQtb3V0IGV4cGzDrWNpdG9cclxuICAgICAgICB2YXIga2VlcExheW91dCA9IChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XHJcbiAgICAgICAgaWYgKGtlZXBMYXlvdXQpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBhbmNob3IgZXhwbMOtY2l0byAoc2kgbG8gdXPDoXMpXHJcbiAgICAgICAgdmFyIHJvbGUgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIpO1xyXG4gICAgICAgIGlmIChyb2xlID09PSBcImFuY2hvclwiKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gaGV1csOtc3RpY2EgcGFyYSB0ZXh0b3NcclxuICAgICAgICB2YXIgaXNUZXh0ID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgaWYgKCFpc1RleHQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIHRhID0gKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZS50ZXh0QWxpZ24pID8gU3RyaW5nKG5vZGUuc3R5bGUudGV4dEFsaWduKS50b0xvd2VyQ2FzZSgpIDogXCJcIjtcclxuICAgICAgICBpZiAodGEgIT09IFwiY2VudGVyXCIpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gc29sbyBzaSByZWFsbWVudGUgb2N1cGEgY2FzaSB0b2RvIGVsIGFuY2hvIHVzYWJsZVxyXG4gICAgICAgIC8vIChlc3RvIGV2aXRhIHJvbXBlciB0ZXh0b3MgY2VudHJhZG9zIGRlbnRybyBkZSBjb2x1bW5hcylcclxuICAgICAgICBpZiAoY29udGVudFcgPiAwICYmIGl0LndpZHRoID49IGNvbnRlbnRXICogMC43OCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8g4pyFIEZsb3cgPSB0b2RvIGxvIHF1ZSBOTyBlcyBhbmNob3JcbiAgICAgIHZhciBpdGVtc0Zsb3cgPSBpdGVtc0FsbC5maWx0ZXIoZnVuY3Rpb24oaXQpeyByZXR1cm4gIWlzQW5jaG9yTm9kZShpdCk7IH0pO1xuICAgICAgdmFyIGl0ZW1zQW5jaG9yID0gaXRlbXNBbGwuZmlsdGVyKGZ1bmN0aW9uKGl0KXsgcmV0dXJuIGlzQW5jaG9yTm9kZShpdCk7IH0pO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjphbmNob3JTcGxpdFwiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgYW5jaG9yczogaXRlbXNBbmNob3IubGVuZ3RoLFxuICAgICAgICBmbG93OiBpdGVtc0Zsb3cubGVuZ3RoLFxuICAgICAgICBhbmNob3JzRGV0YWlsOiBpdGVtc0FuY2hvci5tYXAoZnVuY3Rpb24oaXQpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIiA/IFwidGV4dG9cIiA6IChpdC5ub2RlLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHRvcDogK2l0LnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgbGVmdDogK2l0LmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtpdC53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK2l0LmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAoaXQubm9kZS5zdHlsZSAmJiBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbikgPyBpdC5ub2RlLnN0eWxlLnRleHRBbGlnbiA6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cclxuICAgICAgLy8gU2kgbm8gaGF5IHN1ZmljaWVudGVzIGVsZW1lbnRvcyByZWZsb3dhYmxlcywgbm8gaGFjZW1vcyBuYWRhXG4gICAgICBpZihpdGVtc0Zsb3cubGVuZ3RoIDwgMikge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6Zmxvd1Rvb1NtYWxsXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aCxcbiAgICAgICAgICBhbmNob3JDb3VudDogaXRlbXNBbmNob3IubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxyXG4gICAgICAvLyDinIUgUGFyYSBxdWUgXCJhbHR1cmEgbmVjZXNhcmlhXCIgbm8gcXVlZGUgY29ydGEsXHJcbiAgICAgIC8vIG1lZGltb3MgZWwgYm90dG9tIG3DoXhpbW8gZGUgYW5jaG9ycyAoZW4gY29vcmRzIGRlbCBjb250ZW50KVxyXG4gICAgICB2YXIgbWF4QW5jaG9yQm90dG9tID0gMDtcclxuICAgICAgaXRlbXNBbGwuZm9yRWFjaChmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgaWYgKCFpc0FuY2hvck5vZGUoaXQpKSByZXR1cm47XHJcbiAgICAgICAgdmFyIGIgPSAoaXQudG9wIHx8IDApICsgKGl0LmhlaWdodCB8fCAwKTtcclxuICAgICAgICBpZiAoYiA+IG1heEFuY2hvckJvdHRvbSkgbWF4QW5jaG9yQm90dG9tID0gYjtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyDinIUgMSkgYWdydXBhciBwb3Igc29sYXBlIOKGkiBjbHVzdGVycyAoU09MTyBGTE9XKVxuICAgICAgdmFyIGNsdXN0ZXJzID0gYnVpbGRPdmVybGFwQ2x1c3RlcnMoaXRlbXNGbG93KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246Y2x1c3RlcnNcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIGNvdW50OiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycy5tYXAoZnVuY3Rpb24oYywgaWR4KXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTogaWR4LFxuICAgICAgICAgICAgdG9wOiArYy50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtjLmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGN4OiArYy5jeC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyDinIUgMikgRGV0ZWN0YXIgY29sdW1uYXMvcm93cyAoU09MTyBGTE9XKVxuICAgICAgdmFyIHJvb3RXID0gY29udGVudFcgfHwgMDtcbiAgICAgIHZhciBvcmQgPSBvcmRlckNsdXN0ZXJzRm9yTW9iaWxlKGNsdXN0ZXJzLCByb290VywgQ0ZHKTtcbiAgICAgIHZhciBncm91cHMgPSBvcmQuZ3JvdXBzO1xuICAgICAgdmFyIG1vZGUgPSBvcmQubW9kZTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246b3JkZXJpbmdcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHJvb3RXOiByb290VyxcbiAgICAgICAgZ3JvdXBzOiBncm91cHMubWFwKGZ1bmN0aW9uKGdycCwgZ2kpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnOiBnaSxcbiAgICAgICAgICAgIGNvdW50OiBncnAubGVuZ3RoLFxuICAgICAgICAgICAgdG9wczogZ3JwLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLnRvcC50b0ZpeGVkKDEpOyB9KSxcbiAgICAgICAgICAgIGxlZnRzOiBncnAubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MubGVmdC50b0ZpeGVkKDEpOyB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgdmFyIGhlcm9TaWduYWwgPSBkZXRlY3RIZXJvTGlrZUNlbnRyYWxUZXh0KGl0ZW1zQWxsLCByb290Vyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmhlcm9DaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgaXNIZXJvOiBoZXJvU2lnbmFsLmlzSGVybyxcbiAgICAgICAgcmVhc29uOiBoZXJvU2lnbmFsLnJlYXNvbixcbiAgICAgICAgdGV4dENvdW50OiBoZXJvU2lnbmFsLnRleHRDb3VudCxcbiAgICAgICAgdGV4dENvbHVtbkNvdW50OiBoZXJvU2lnbmFsLnRleHRDb2x1bW5Db3VudCxcbiAgICAgICAgc2luZ2xlVGV4dENvbHVtbjogaGVyb1NpZ25hbC5zaW5nbGVUZXh0Q29sdW1uLFxuICAgICAgICB0ZXh0Q29sdW1uczogaGVyb1NpZ25hbC50ZXh0Q29sdW1ucyxcbiAgICAgICAgbWF4VGV4dFdpZHRoUmF0aW86IGhlcm9TaWduYWwubWF4VGV4dFdpZHRoUmF0aW8sXG4gICAgICAgIHdpZHRoUmF0aW86IGhlcm9TaWduYWwud2lkdGhSYXRpbyxcbiAgICAgICAgY2VudGVyRGVsdGE6IGhlcm9TaWduYWwuY2VudGVyRGVsdGEsXG4gICAgICAgIGNlbnRlclRvbDogaGVyb1NpZ25hbC5jZW50ZXJUb2wsXG4gICAgICAgIGNlbnRlcmVkQnlBbGlnbjogaGVyb1NpZ25hbC5jZW50ZXJlZEJ5QWxpZ24sXG4gICAgICAgIGNlbnRlcmVkQnlHZW9tZXRyeTogaGVyb1NpZ25hbC5jZW50ZXJlZEJ5R2VvbWV0cnksXG4gICAgICAgIGRlY29yTmVhcjogaGVyb1NpZ25hbC5kZWNvck5lYXIsXG4gICAgICAgIGRlY29yTGVmdDogaGVyb1NpZ25hbC5kZWNvckxlZnQsXG4gICAgICAgIGRlY29yUmlnaHQ6IGhlcm9TaWduYWwuZGVjb3JSaWdodCxcbiAgICAgICAgZGVjb3JJbnZhZGluZ1RleHRDb2x1bW46IGhlcm9TaWduYWwuZGVjb3JJbnZhZGluZ1RleHRDb2x1bW5cbiAgICAgIH0pO1xuICAgICAgaWYgKGhlcm9TaWduYWwuaXNIZXJvKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpoZXJvQ2VudHJhbFRleHRcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBoZXJvUmVhc29uOiBoZXJvU2lnbmFsLnJlYXNvbixcbiAgICAgICAgICBoZXJvOiBoZXJvU2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlubGluZVBhaXJTaWduYWwgPSBkZXRlY3RJbmxpbmVQYWlyTm9SZWZsb3coaXRlbXNGbG93LCBpdGVtc0FsbCwgcm9vdFcsIENGRyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmlubGluZVBhaXJDaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgc2tpcDogaW5saW5lUGFpclNpZ25hbC5za2lwLFxuICAgICAgICByZWFzb246IGlubGluZVBhaXJTaWduYWwucmVhc29uLFxuICAgICAgICB0b3RhbEZsb3c6IGlubGluZVBhaXJTaWduYWwudG90YWxGbG93LFxuICAgICAgICB0b3RhbEFsbDogaW5saW5lUGFpclNpZ25hbC50b3RhbEFsbCxcbiAgICAgICAgcm93RGVsdGE6IGlubGluZVBhaXJTaWduYWwucm93RGVsdGEsXG4gICAgICAgIHJvd1RvbDogaW5saW5lUGFpclNpZ25hbC5yb3dUb2wsXG4gICAgICAgIHdpZHRoczogaW5saW5lUGFpclNpZ25hbC53aWR0aHMsXG4gICAgICAgIGhlaWdodHM6IGlubGluZVBhaXJTaWduYWwuaGVpZ2h0cyxcbiAgICAgICAgYm90aFNtYWxsOiBpbmxpbmVQYWlyU2lnbmFsLmJvdGhTbWFsbCxcbiAgICAgICAgc21hbGxXTGltaXQ6IGlubGluZVBhaXJTaWduYWwuc21hbGxXTGltaXQsXG4gICAgICAgIHNtYWxsSExpbWl0OiBpbmxpbmVQYWlyU2lnbmFsLnNtYWxsSExpbWl0LFxuICAgICAgICBwYWlyU3BhbjogaW5saW5lUGFpclNpZ25hbC5wYWlyU3BhbixcbiAgICAgICAgcGFpclNwYW5SYXRpbzogaW5saW5lUGFpclNpZ25hbC5wYWlyU3BhblJhdGlvLFxuICAgICAgICBmaXRzVG9nZXRoZXI6IGlubGluZVBhaXJTaWduYWwuZml0c1RvZ2V0aGVyXG4gICAgICB9KTtcbiAgICAgIGlmIChpbmxpbmVQYWlyU2lnbmFsLnNraXApIHtcbiAgICAgICAgdmFyIGlubGluZVBhaXJBZGp1c3QgPSBlbmZvcmNlSW5saW5lUGFpckdhcChpdGVtc0Zsb3csIGNvbnRlbnQsIHJvb3RXKTtcbiAgICAgICAgbXNsTG9nKFwic2VjdGlvbjppbmxpbmVQYWlyQWRqdXN0XCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBhZGp1c3Q6IGlubGluZVBhaXJBZGp1c3RcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpzbWFsbElubGluZVBhaXJGaXRzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgaW5saW5lUGFpcjogaW5saW5lUGFpclNpZ25hbCxcbiAgICAgICAgICBpbmxpbmVQYWlyQWRqdXN0OiBpbmxpbmVQYWlyQWRqdXN0XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8g4pyFIDMpIEdhdGUgXCJtZWpvciBkZSBhbWJvcyBtdW5kb3NcIjpcbiAgICAgIC8vIC0gU2kgZXMgXCJvbmVcIiAobGF5b3V0IHlhIG5hdHVyYWwpIFkgYWRlbcOhcyBlbnRyYSwgTk8gaGFjZW1vcyByZWZsb3cuXG4gICAgICAvLyAtIEVuIGN1YWxxdWllciBvdHJvIGNhc28gKHR3by90aHJlZS9yb3dzKSwgaGFjZW1vcyByZWZsb3cgcGFyYSBsZWN0dXJhIG1vYmlsZSxcbiAgICAgIC8vICAgaW5jbHVzbyBhdW5xdWUgXCJlbnRyZVwiLlxyXG4gICAgICB2YXIgZml0cyA9IGNsdXN0ZXJzRml0SW5Nb2JpbGUoY2x1c3RlcnMsIGNvbnRlbnQpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpmaXRDaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgd2lsbFNraXA6IChtb2RlID09PSBcIm9uZVwiICYmIGZpdHMpXG4gICAgICB9KTtcbiAgICAgIGlmIChtb2RlID09PSBcIm9uZVwiICYmIGZpdHMpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOm1vZGVPbmVGaXRzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwiYXBwbHk6bW9kZVJlcXVpcmVzUmVmbG93XCIsIHtcbiAgICAgICAgd2lsbEFwcGx5UmVmbG93OiB0cnVlLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBmaXRzOiBmaXRzLFxuICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgIGFuY2hvckNvdW50OiBpdGVtc0FuY2hvci5sZW5ndGgsXG4gICAgICAgIGdyb3VwU2l6ZXM6IGdyb3Vwcy5tYXAoZnVuY3Rpb24oZ3JwKXsgcmV0dXJuIGdycC5sZW5ndGg7IH0pXG4gICAgICB9KTtcblxuICAgICAgLy8g4pyFIDQpIFJlZmxvdyBzb2xvIHNvYnJlIEZMT1cgKHByZXNlcnZhIHNvbGFwZXMgZGVudHJvIGRlIGNhZGEgY2x1c3RlcilcbiAgICAgIHZhciByZXMgPSBhcHBseUNsdXN0ZXJTdGFjayhncm91cHMsIGNvbnRlbnQsIENGRywgbW9kZSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmFwcGx5UmVzdWx0XCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjaGFuZ2VkOiAhIShyZXMgJiYgcmVzLmNoYW5nZWQpLFxuICAgICAgICBuZWVkZWRIZWlnaHQ6IHJlcyA/IHJlcy5uZWVkZWRIZWlnaHQgOiBudWxsLFxuICAgICAgICBtYXhBbmNob3JCb3R0b206ICttYXhBbmNob3JCb3R0b20udG9GaXhlZCgxKSxcbiAgICAgICAgYmFzZUJvdHRvbUdhcDogK2Jhc2VCb3R0b21HYXAudG9GaXhlZCgxKVxuICAgICAgfSk7XG4gICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInBvc3RBcHBseVwiLCB7XG4gICAgICAgIHdpbGxBcHBseVJlZmxvdzogdHJ1ZSxcbiAgICAgICAgY2hhbmdlZDogISEocmVzICYmIHJlcy5jaGFuZ2VkKSxcbiAgICAgICAgbmVlZGVkSGVpZ2h0OiByZXMgPyArTnVtYmVyKHJlcy5uZWVkZWRIZWlnaHQgfHwgMCkudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbmVlZGVkQWZ0ZXJSZWZsb3cgPSAwO1xuICAgICAgaWYgKHJlcyAmJiByZXMuY2hhbmdlZCkge1xuICAgICAgICAvLyBFdml0YXIgcXVlIGxhIHNlY2Npw7NuIHF1ZWRlIGNoaWNhIHNpIGhheSBhbmNob3JzIG3DoXMgYWJham9cbiAgICAgICAgdmFyIG5lZWRlZCA9IE51bWJlcihyZXMubmVlZGVkSGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAoTnVtYmVyKG1heEFuY2hvckJvdHRvbSkgPiAwKSB7XG4gICAgICAgICAgLy8gc3VtYW1vcyBwYWRkaW5nIGJvdHRvbSBwYXJhIHF1ZSBubyBxdWVkZSBwZWdhZG9cbiAgICAgICAgICB2YXIgYW5jaG9yTmVlZGVkID0gTWF0aC5jZWlsKG1heEFuY2hvckJvdHRvbSArIChDRkcuUEFEX0JPVCB8fCAwKSk7XG4gICAgICAgICAgaWYgKGFuY2hvck5lZWRlZCA+IG5lZWRlZCkgbmVlZGVkID0gYW5jaG9yTmVlZGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlQm90dG9tR2FwID4gMCkge1xuICAgICAgICAgIG5lZWRlZCA9IE1hdGguY2VpbChuZWVkZWQgKyBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZGVkID4gMCkgbmVlZGVkQWZ0ZXJSZWZsb3cgPSBuZWVkZWQ7XG4gICAgICB9XG4gICAgICBmaW5hbGl6ZVNlY3Rpb24obmVlZGVkQWZ0ZXJSZWZsb3csIGJhc2VCb3R0b21HYXApO1xuICAgIH0pO1xuICB9XG5cclxuICBmdW5jdGlvbiBib290KCl7XG4gICAgbXNsTG9nKFwiYm9vdFwiLCB7IGNmZzogQ0ZHIH0pO1xuICAgIHJ1bk9uY2UoKTtcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDE1MCk7XHJcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDYwMCk7XHJcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDE4MDApO1xyXG5cclxuICAgIGlmKGRvY3VtZW50LmZvbnRzICYmIGRvY3VtZW50LmZvbnRzLnJlYWR5KXtcclxuICAgICAgZG9jdW1lbnQuZm9udHMucmVhZHkudGhlbihmdW5jdGlvbigpeyBydW5PbmNlKCk7IH0pLmNhdGNoKGZ1bmN0aW9uKCl7fSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYm9vdCk7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcnVuT25jZSk7XHJcblxyXG4gIGlmKHdpbmRvdy52aXN1YWxWaWV3cG9ydCl7XHJcbiAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBydW5PbmNlKTtcclxuICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHJ1bk9uY2UpO1xyXG4gIH1cclxuXHJcbiAgaWYoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIGJvb3QoKTtcclxuICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xyXG59KSgpO1xyXG48L3NjcmlwdD5cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzRG9tSGVscGVyc0Jsb2NrIiwianNGaXRTY2FsZUJsb2NrIiwianNPcmRlcmluZ0Jsb2NrIiwianNTdGFja2luZ0Jsb2NrIiwiYnVpbGRTY3JpcHQiLCJjZmciLCJlbmFibGVkIiwibWluR2FwUHgiLCJtYXhHYXBQeCIsImdhcFNjYWxlIiwicGFkZGluZ1RvcFB4IiwicGFkZGluZ0JvdHRvbVB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJmaXRNaW5TY2FsZSIsImZpdE1heFNjYWxlIiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpbyIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/stacking.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsStackingBlock: () => (/* binding */ jsStackingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/stacking.ts\nfunction jsStackingBlock() {\n    return '\\n  // Centro real del \\xe1rea usable (compensa padding safe-left/right)\\n  function computeCenterX(rootEl){\\n    var rootRect = rootEl.getBoundingClientRect();\\n    var rootW = rootRect.width || 0;\\n\\n    var cs = getComputedStyle(rootEl);\\n    var padL = parseFloat(cs.paddingLeft) || 0;\\n    var padR = parseFloat(cs.paddingRight) || 0;\\n\\n    var usableW = Math.max(0, rootW - padL - padR);\\n    var centerX = padL + usableW / 2; // centro del \\xe1rea usable\\n\\n    return { rootW: rootW, usableW: usableW, centerX: centerX, padL: padL, padR: padR };\\n  }\\n\\n  function clamp(n, a, b){\\n    if (!isFinite(n)) return a;\\n    return Math.max(a, Math.min(b, n));\\n  }\\n\\n  /**\\n   * Apila CLUSTERS por groups (columnas/filas) y:\\n   * - mueve cada cluster como bloque\\n   * - preserva solape/posiciones relativas dentro del cluster\\n   * - centra el cluster como bloque en el eje X (sin transform)\\n   *\\n   * Devuelve changed + neededHeight (para expandir secci\\xf3n)\\n   */\\n  function applyClusterStack(groups, rootEl, CFG, mode){\\n    var info = computeCenterX(rootEl);\\n    var centerX = info.centerX;\\n    mslLog(\"stack:start\", {\\n      groupCount: groups.length,\\n      groupSizes: groups.map(function(g){ return g.length; }),\\n      centerX: +centerX.toFixed(1),\\n      usableW: +info.usableW.toFixed(1)\\n    });\\n\\n    var changed = false;\\n    var isMultiColLayout = (mode === \"two\" || mode === \"three\");\\n\\n    // En multi-columna: cada columna apilada se centra por su propio bbox.\\n    // As\\xed, el centro de cada columna coincide con el centro de pantalla.\\n\\n    // --- Anchor global: d\\xf3nde estaba “el bloque” originalmente ---\\n    var firstGroup = groups[0] || [];\\n    var anchor = Infinity;\\n    for (var i=0;i<firstGroup.length;i++){\\n      anchor = Math.min(anchor, firstGroup[i].top);\\n    }\\n    if (!isFinite(anchor)) anchor = CFG.PAD_TOP;\\n    anchor = Math.max(CFG.PAD_TOP, anchor);\\n\\n    // Cursor global: d\\xf3nde termina el contenido apilado hasta ahora\\n    var globalCursor = anchor;\\n\\n    // Separaci\\xf3n entre columnas apiladas (izq, centro, der)\\n    var GROUP_GAP = 14;\\n\\n    for (var g=0; g<groups.length; g++){\\n      var col = groups[g] || [];\\n      if (!col.length) continue;\\n      var colReferenceCenterX = NaN;\\n      var colSourceReferenceCenterX = NaN;\\n\\n      // M\\xe9tricas por grupo solo para debug.\\n      var groupMinLeft = Infinity;\\n      var groupMaxRight = -Infinity;\\n      if (isMultiColLayout){\\n        for (var gg=0; gg<col.length; gg++){\\n          groupMinLeft = Math.min(groupMinLeft, col[gg].left);\\n          groupMaxRight = Math.max(groupMaxRight, col[gg].left + col[gg].width);\\n        }\\n      }\\n      var groupWidth = isMultiColLayout ? Math.max(0, groupMaxRight - groupMinLeft) : 0;\\n      var groupBaseLeft = isMultiColLayout ? (centerX - groupWidth / 2) : 0;\\n\\n      // Offset vertical original de esta columna respecto del anchor\\n      var colMinTop = Infinity;\\n      for (var k=0;k<col.length;k++){\\n        colMinTop = Math.min(colMinTop, col[k].top);\\n      }\\n      if (!isFinite(colMinTop)) colMinTop = anchor;\\n\\n      var colOffset = colMinTop - anchor;\\n      var colStart = globalCursor + (g === 0 ? 0 : GROUP_GAP) + Math.max(0, colOffset);\\n      mslLog(\"stack:group:start\", {\\n        g: g,\\n        colSize: col.length,\\n        colMinTop: +colMinTop.toFixed(1),\\n        colOffset: +colOffset.toFixed(1),\\n        colStart: +colStart.toFixed(1),\\n        globalCursor: +globalCursor.toFixed(1),\\n        mode: mode,\\n        groupMinLeft: isMultiColLayout ? +groupMinLeft.toFixed(1) : null,\\n        groupWidth: isMultiColLayout ? +groupWidth.toFixed(1) : null,\\n        groupBaseLeft: isMultiColLayout ? +groupBaseLeft.toFixed(1) : null\\n      });\\n\\n      // Cursor local de esta columna\\n      var colCursor = colStart;\\n\\n      for (var j=0; j<col.length; j++){\\n        var c = col[j];\\n\\n        // Top del cluster en el flujo mobile\\n        var clusterTop;\\n\\n        if (j === 0) {\\n          clusterTop = colCursor;\\n        } else {\\n          var prevC = col[j-1];\\n          var prevBottom = (clusterTopPrev + prevC.height);\\n\\n          // ✅ Gap original entre clusters (canvas)\\n          var prevBottomOrig = (prevC.top + prevC.height);\\n          var gapOrig = c.top - prevBottomOrig;\\n          if (!isFinite(gapOrig)) gapOrig = 0;\\n\\n          var overlapInSource = gapOrig < 0;\\n          if ((mode === \"two\" || mode === \"three\") && overlapInSource) {\\n            // Si en el original este cluster cae dentro del anterior, respetamos\\n            // su top relativo para no mandarlo al final de la columna.\\n            var relTopInCol = c.top - colMinTop;\\n            if (!isFinite(relTopInCol)) relTopInCol = 0;\\n            clusterTop = colStart + Math.max(0, relTopInCol);\\n          } else {\\n            // ✅ Gap “mobile-friendly”: escalado + clamp\\n            var gapWanted = clamp(gapOrig * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\\n\\n            // ✅ Anti-solape definitivo:\\n            //   el pr\\xf3ximo cluster SIEMPRE empieza despu\\xe9s del bottom real del anterior + gapWanted\\n            clusterTop = prevBottom + gapWanted;\\n\\n            // En multi-columna nunca avanzamos hacia arriba respecto al flujo ya consumido.\\n            if ((mode === \"two\" || mode === \"three\") && clusterTop < colCursor) {\\n              clusterTop = colCursor;\\n            }\\n          }\\n        }\\n\\n        // Guardamos para el pr\\xf3ximo loop\\n        var clusterTopPrev = clusterTop;\\n\\n        // \\xbfcentrar este cluster?\\n        var forceCenter = false;\\n        var hasTextInCluster = false;\\n        var hasNonTextInCluster = false;\\n        for (var t=0; t<c.items.length; t++){\\n          var isTextT = (c.items[t].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          if (isTextT) hasTextInCluster = true;\\n          else hasNonTextInCluster = true;\\n          if ((c.items[t].node.getAttribute(\"data-mobile-center\") || \"\") === \"force\") {\\n            forceCenter = true;\\n          }\\n        }\\n\\n        // one/rows: centro por cluster (comportamiento original)\\n        // two/three: apilar cada columna en la misma referencia X,\\n        // preservando offsets internos de esa columna.\\n        var keepCenter = forceCenter ? true : (c.width < (info.usableW * 0.95));\\n        var clusterLeft = keepCenter ? (centerX - c.width / 2) : c.left;\\n        var isTextOnlyCluster = hasTextInCluster && !hasNonTextInCluster;\\n        var shouldCenterTextWithinCluster = false;\\n        if (isMultiColLayout) {\\n          // Modo lectura mobile multi-col:\\n          // usar una misma referencia X para toda la columna apilada y\\n          // preservar el offset horizontal original de cada cluster.\\n          // Esto mantiene alineado texto/forma cuando la columna se parte\\n          // en varios clusters.\\n          var relClusterLeft = (c.left || 0) - (groupMinLeft || 0);\\n          clusterLeft = groupBaseLeft + relClusterLeft;\\n\\n          // Permite forzar centrado por cluster si el nodo lo pide.\\n          if (forceCenter) clusterLeft = centerX - c.width / 2;\\n\\n          // Si esta columna tiene un cluster con forma (o mixto), usamos su\\n          // centro como referencia para alinear clusters solo-texto debajo.\\n          var clusterRefCenterX = NaN;\\n          if (hasNonTextInCluster) {\\n            // Referencia basada en items no-texto (forma/icono), no en todo el\\n            // cluster, para que textos largos no desplacen el centro de columna.\\n            var ntMinRel = Infinity;\\n            var ntMaxRel = -Infinity;\\n            for (var nti=0; nti<c.items.length; nti++){\\n              var ntIt = c.items[nti];\\n              var ntIsText = (ntIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              if (ntIsText) continue;\\n              ntMinRel = Math.min(ntMinRel, (ntIt._relLeft || 0));\\n              ntMaxRel = Math.max(ntMaxRel, (ntIt._relLeft || 0) + (ntIt.width || 0));\\n            }\\n            var sourceClusterRefCenterX = NaN;\\n            if (isFinite(ntMinRel) && isFinite(ntMaxRel) && ntMaxRel > ntMinRel) {\\n              clusterRefCenterX = clusterLeft + ((ntMinRel + ntMaxRel) / 2);\\n              sourceClusterRefCenterX = (c.left || 0) + ((ntMinRel + ntMaxRel) / 2);\\n            } else {\\n              clusterRefCenterX = clusterLeft + c.width / 2;\\n              sourceClusterRefCenterX = (c.left || 0) + c.width / 2;\\n            }\\n\\n            colReferenceCenterX = clusterRefCenterX;\\n            colSourceReferenceCenterX = sourceClusterRefCenterX;\\n          }\\n\\n          if (isTextOnlyCluster && isFinite(colReferenceCenterX)) {\\n            var maxSnapDelta = Math.min(120, info.usableW * 0.35);\\n            var sourceClusterCenterX = (c.left || 0) + c.width / 2;\\n            var sourceDriftX = isFinite(colSourceReferenceCenterX)\\n              ? (sourceClusterCenterX - colSourceReferenceCenterX)\\n              : NaN;\\n            if (isFinite(sourceDriftX) && Math.abs(sourceDriftX) <= maxSnapDelta) {\\n              clusterLeft = (colReferenceCenterX + sourceDriftX) - c.width / 2;\\n            }\\n            // Para labels cortos, centrar el contenido textual dentro del box.\\n            shouldCenterTextWithinCluster = c.width <= (info.usableW * 0.65);\\n          }\\n        }\\n        mslLog(\"stack:cluster\", {\\n          g: g,\\n          j: j,\\n          origTop: +c.top.toFixed(1),\\n          origLeft: +c.left.toFixed(1),\\n          newTop: +clusterTop.toFixed(1),\\n          newLeft: +clusterLeft.toFixed(1),\\n          h: +c.height.toFixed(1),\\n          w: +c.width.toFixed(1),\\n          forceCenter: forceCenter,\\n          keepCenter: keepCenter,\\n          items: c.items.length,\\n          colReferenceCenterX: (typeof colReferenceCenterX === \"number\" && isFinite(colReferenceCenterX)) ? +colReferenceCenterX.toFixed(1) : null,\\n          isTextOnlyCluster: isTextOnlyCluster,\\n          centerShortText: shouldCenterTextWithinCluster\\n        });\\n\\n        var textCount = 0;\\n        for (var tc=0; tc<c.items.length; tc++){\\n          if ((c.items[tc].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textCount++;\\n        }\\n        var linearizeCluster = (mode === \"rows\" && c.items.length > 1 && textCount >= 2);\\n        var clusterBottomUsed = clusterTop + c.height;\\n\\n        // Caso especial: en rows, si el cluster agrupa varios textos, lo\\n        // convertimos a flujo vertical centrado para evitar texto lado a lado.\\n        if (linearizeCluster){\\n          var allItems = c.items.slice();\\n          var nonText = allItems.filter(function(itx){\\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\";\\n          }).sort(function(a,b){\\n            if (a.top !== b.top) return a.top - b.top;\\n            return a.left - b.left;\\n          });\\n          var texts = allItems.filter(function(itx){\\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          }).sort(function(a,b){\\n            if (a.top !== b.top) return a.top - b.top;\\n            return a.left - b.left;\\n          });\\n\\n          // Orden sem\\xe1ntico de lectura:\\n          // no-texto + texto m\\xe1s cercano (debajo y por eje X), luego remanentes.\\n          var ordered = [];\\n          var usedText = {};\\n\\n          for (var nt=0; nt<nonText.length; nt++){\\n            var ntItem = nonText[nt];\\n            ordered.push(ntItem);\\n\\n            var ntCx = (ntItem.left || 0) + (ntItem.width || 0) / 2;\\n            var ntBottom = (ntItem.top || 0) + (ntItem.height || 0);\\n            var bestIdxTxt = -1;\\n            var bestScore = Infinity;\\n\\n            for (var tx=0; tx<texts.length; tx++){\\n              if (usedText[tx]) continue;\\n              var tItem = texts[tx];\\n              var tCx = (tItem.left || 0) + (tItem.width || 0) / 2;\\n              var vGapTxt = (tItem.top || 0) - ntBottom; // preferir texto debajo\\n              var hDistTxt = Math.abs(tCx - ntCx);\\n              var penaltyAbove = vGapTxt < -2 ? 10000 : 0;\\n              var score = penaltyAbove + Math.abs(vGapTxt) * 2 + hDistTxt;\\n              if (score < bestScore){\\n                bestScore = score;\\n                bestIdxTxt = tx;\\n              }\\n            }\\n\\n            if (bestIdxTxt >= 0){\\n              ordered.push(texts[bestIdxTxt]);\\n              usedText[bestIdxTxt] = true;\\n            }\\n          }\\n\\n          // Textos no emparejados\\n          for (var tx2=0; tx2<texts.length; tx2++){\\n            if (!usedText[tx2]) ordered.push(texts[tx2]);\\n          }\\n\\n          // Si no hubo no-texto, fallback simple por top/left\\n          if (!ordered.length) {\\n            ordered = allItems.sort(function(a,b){\\n              if (a.top !== b.top) return a.top - b.top;\\n              return a.left - b.left;\\n            });\\n          }\\n\\n          var localCursor = clusterTop;\\n          var prevIt = null;\\n          var prevTopApplied = clusterTop;\\n          var EXTRA_COL_BREAK_GAP = 8;\\n\\n          for (var li=0; li<ordered.length; li++){\\n            var lit = ordered[li];\\n\\n            var keepLayoutLin = (lit.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n            if (keepLayoutLin) continue;\\n\\n            var newTopLin = localCursor;\\n            if (prevIt){\\n              var gapOrigLin = lit.top - (prevIt.top + prevIt.height);\\n              if (!isFinite(gapOrigLin)) gapOrigLin = 0;\\n              var gapWantedLin = clamp(gapOrigLin * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\\n              var prevIsTextLin = (prevIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              var currIsTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              // Al pasar de \"texto final de columna\" a \"nuevo no-texto\" agregamos aire.\\n              if (prevIsTextLin && !currIsTextLin) gapWantedLin += EXTRA_COL_BREAK_GAP;\\n              newTopLin = prevTopApplied + prevIt.height + gapWantedLin;\\n            }\\n\\n            var newLeftLin = centerX - (lit.width || 0) / 2;\\n            var keepAlignLin = (lit.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\\n            if (keepAlignLin) newLeftLin = lit.left;\\n\\n            if (Math.abs(newTopLin - lit.top) > 0.5 || Math.abs(newLeftLin - lit.left) > 0.5) changed = true;\\n\\n            // En rows linealizado, forzamos centrado visual real de texto.\\n            var isTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n            if (isTextLin && !keepAlignLin) {\\n              lit.node.style.textAlign = \"center\";\\n              lit.node.style.transformOrigin = \"top center\";\\n              lit.node.style.setProperty(\"--text-zoom\", \"1\");\\n              var tfLin = lit.node.style.transform || \"\";\\n              if (tfLin.indexOf(\"translateX(\") !== -1) {\\n                lit.node.style.transform = tfLin.replace(/translateX([^)]*)/, \"translateX(0px)\");\\n              }\\n            }\\n\\n            lit.node.style.top = newTopLin + \"px\";\\n            lit.node.style.left = newLeftLin + \"px\";\\n            lit.node.style.right = \"auto\";\\n            lit.node.style.marginLeft = \"0px\";\\n\\n            prevIt = lit;\\n            prevTopApplied = newTopLin;\\n            localCursor = newTopLin + (lit.height || 0);\\n            if (localCursor > clusterBottomUsed) clusterBottomUsed = localCursor;\\n          }\\n\\n          colCursor = Math.max(colCursor, clusterBottomUsed);\\n          continue;\\n        }\\n\\n        // Aplicar a cada item preservando offsets relativos (solape intacto)\\n        for (var ii=0; ii<c.items.length; ii++){\\n          var it = c.items[ii];\\n\\n          // Opt-out total del layout (decoraciones, etc.)\\n          var keepLayout = (it.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n          if (keepLayout) continue;\\n\\n          var newTop = clusterTop + (it._relTop || 0);\\n          var newLeft = clusterLeft + (it._relLeft || 0);\\n\\n          // Opt-out de centrado (mantener left original del item)\\n          var keepAlign = (it.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\\n          if (keepAlign) newLeft = it.left;\\n\\n          // En multi-col, neutralizamos SIEMPRE translateX(...) de textos\\n          // para que la posici\\xf3n left calculada sea la referencia visual real.\\n          var isTextNode = (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          var isShortTextBox = false;\\n          var shouldRecenterTextItem = false;\\n          var centerByAlign = false;\\n          var targetTextCenterX = NaN;\\n          if (isTextNode && isMultiColLayout) {\\n            var tf = it.node.style.transform || \"\";\\n            if (tf.indexOf(\"translateX(\") !== -1) {\\n              it.node.style.transform = tf.replace(/translateX([^)]*)/, \"translateX(0px)\");\\n            }\\n            isShortTextBox = (it.width || 0) <= (info.usableW * 0.5) && (it.height || 0) <= 42;\\n            var taCurrent = ((it.node.style && it.node.style.textAlign) || \"\").toLowerCase();\\n            centerByAlign = taCurrent === \"center\";\\n            var shouldCenterVisualText =\\n              (shouldCenterTextWithinCluster || isShortTextBox || centerByAlign) &&\\n              !keepAlign;\\n            shouldRecenterTextItem =\\n              shouldCenterVisualText &&\\n              isFinite(colReferenceCenterX);\\n            if (shouldRecenterTextItem) {\\n              var prevLeftTxt = newLeft;\\n              var sourceItemCenterX = (it.left || 0) + (it.width || 0) / 2;\\n              var sourceDriftItemX = isFinite(colSourceReferenceCenterX)\\n                ? (sourceItemCenterX - colSourceReferenceCenterX)\\n                : NaN;\\n              var targetCenterX = colReferenceCenterX;\\n              if (isFinite(sourceDriftItemX)) {\\n                targetCenterX += sourceDriftItemX;\\n              }\\n              targetTextCenterX = targetCenterX;\\n              newLeft = targetCenterX - (it.width || 0) / 2;\\n              if (Math.abs(newLeft - prevLeftTxt) > 0.5) {\\n                mslLog(\"stack:item:textRecenter\", {\\n                  g: g,\\n                  j: j,\\n                  ii: ii,\\n                  prevLeft: +prevLeftTxt.toFixed(1),\\n                  newLeft: +newLeft.toFixed(1),\\n                  itemW: +(it.width || 0).toFixed(1),\\n                  refCenterX: +colReferenceCenterX.toFixed(1),\\n                  sourceRefCenterX: (typeof colSourceReferenceCenterX === \"number\" && isFinite(colSourceReferenceCenterX)) ? +colSourceReferenceCenterX.toFixed(1) : null,\\n                  sourceDriftX: isFinite(sourceDriftItemX) ? +sourceDriftItemX.toFixed(1) : null,\\n                  shortBox: isShortTextBox,\\n                  centerByAlign: centerByAlign\\n                });\\n              }\\n            }\\n            if (shouldCenterVisualText) {\\n              it.node.style.textAlign = \"center\";\\n              it.node.style.transformOrigin = \"top center\";\\n              // Evita encogimiento horizontal heredado que desplaza el centro visual.\\n              it.node.style.setProperty(\"--text-zoom\", \"1\");\\n            }\\n          }\\n\\n          it.node.style.top = newTop + \"px\";\\n          it.node.style.left = newLeft + \"px\";\\n          it.node.style.right = \"auto\";\\n          it.node.style.marginLeft = \"0px\";\\n\\n          // Correcci\\xf3n final por posici\\xf3n renderizada real del texto\\n          // (fuentes/transform pueden introducir desv\\xedos visuales sub-p\\xedxel).\\n          if (isTextNode && isMultiColLayout && shouldRecenterTextItem) {\\n            var rrTxt = relRect(it.node, rootEl);\\n            var renderedCenterX = (rrTxt.left || 0) + (rrTxt.width || 0) / 2;\\n            var targetRenderCenterX = isFinite(targetTextCenterX) ? targetTextCenterX : colReferenceCenterX;\\n            var renderDelta = renderedCenterX - targetRenderCenterX;\\n            if (isFinite(renderDelta) && Math.abs(renderDelta) > 0.6) {\\n              var correctedLeft = newLeft - renderDelta;\\n              if (isFinite(correctedLeft)) {\\n                mslLog(\"stack:item:textRenderAdjust\", {\\n                  g: g,\\n                  j: j,\\n                  ii: ii,\\n                  prevLeft: +newLeft.toFixed(1),\\n                  correctedLeft: +correctedLeft.toFixed(1),\\n                  renderedCenterX: +renderedCenterX.toFixed(1),\\n                  refCenterX: +targetRenderCenterX.toFixed(1),\\n                  delta: +renderDelta.toFixed(2)\\n                });\\n                newLeft = correctedLeft;\\n                it.node.style.left = newLeft + \"px\";\\n              }\\n            }\\n          }\\n\\n          if (Math.abs(newTop - it.top) > 0.5 || Math.abs(newLeft - it.left) > 0.5) changed = true;\\n\\n          var itemBottom = newTop + (it.height || 0);\\n          if (itemBottom > clusterBottomUsed) clusterBottomUsed = itemBottom;\\n        }\\n\\n        // Avanza el cursor local al final del cluster\\n        colCursor = Math.max(colCursor, clusterBottomUsed);\\n      }\\n\\n      // Al terminar la columna, el cursor global baja hasta donde lleg\\xf3 esta columna\\n      globalCursor = Math.max(globalCursor, colCursor);\\n    }\\n\\n    var needed = globalCursor + CFG.PAD_BOT;\\n    mslLog(\"stack:end\", {\\n      changed: changed,\\n      neededHeight: +needed.toFixed(1),\\n      finalCursor: +globalCursor.toFixed(1)\\n    });\\n    return { changed: changed, neededHeight: needed };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sODhwQkF1ZVBDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcc3RhY2tpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9zdGFja2luZy50c1xyXG5leHBvcnQgZnVuY3Rpb24ganNTdGFja2luZ0Jsb2NrKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBcclxuICAvLyBDZW50cm8gcmVhbCBkZWwgw6FyZWEgdXNhYmxlIChjb21wZW5zYSBwYWRkaW5nIHNhZmUtbGVmdC9yaWdodClcclxuICBmdW5jdGlvbiBjb21wdXRlQ2VudGVyWChyb290RWwpe1xyXG4gICAgdmFyIHJvb3RSZWN0ID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJvb3RXID0gcm9vdFJlY3Qud2lkdGggfHwgMDtcclxuXHJcbiAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbCk7XHJcbiAgICB2YXIgcGFkTCA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ0xlZnQpIHx8IDA7XHJcbiAgICB2YXIgcGFkUiA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSB8fCAwO1xyXG5cclxuICAgIHZhciB1c2FibGVXID0gTWF0aC5tYXgoMCwgcm9vdFcgLSBwYWRMIC0gcGFkUik7XHJcbiAgICB2YXIgY2VudGVyWCA9IHBhZEwgKyB1c2FibGVXIC8gMjsgLy8gY2VudHJvIGRlbCDDoXJlYSB1c2FibGVcclxuXHJcbiAgICByZXR1cm4geyByb290Vzogcm9vdFcsIHVzYWJsZVc6IHVzYWJsZVcsIGNlbnRlclg6IGNlbnRlclgsIHBhZEw6IHBhZEwsIHBhZFI6IHBhZFIgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsYW1wKG4sIGEsIGIpe1xyXG4gICAgaWYgKCFpc0Zpbml0ZShuKSkgcmV0dXJuIGE7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgbikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBpbGEgQ0xVU1RFUlMgcG9yIGdyb3VwcyAoY29sdW1uYXMvZmlsYXMpIHk6XHJcbiAgICogLSBtdWV2ZSBjYWRhIGNsdXN0ZXIgY29tbyBibG9xdWVcclxuICAgKiAtIHByZXNlcnZhIHNvbGFwZS9wb3NpY2lvbmVzIHJlbGF0aXZhcyBkZW50cm8gZGVsIGNsdXN0ZXJcclxuICAgKiAtIGNlbnRyYSBlbCBjbHVzdGVyIGNvbW8gYmxvcXVlIGVuIGVsIGVqZSBYIChzaW4gdHJhbnNmb3JtKVxyXG4gICAqXHJcbiAgICogRGV2dWVsdmUgY2hhbmdlZCArIG5lZWRlZEhlaWdodCAocGFyYSBleHBhbmRpciBzZWNjacOzbilcclxuICAgKi9cclxuICBmdW5jdGlvbiBhcHBseUNsdXN0ZXJTdGFjayhncm91cHMsIHJvb3RFbCwgQ0ZHLCBtb2RlKXtcclxuICAgIHZhciBpbmZvID0gY29tcHV0ZUNlbnRlclgocm9vdEVsKTtcclxuICAgIHZhciBjZW50ZXJYID0gaW5mby5jZW50ZXJYO1xyXG4gICAgbXNsTG9nKFwic3RhY2s6c3RhcnRcIiwge1xyXG4gICAgICBncm91cENvdW50OiBncm91cHMubGVuZ3RoLFxyXG4gICAgICBncm91cFNpemVzOiBncm91cHMubWFwKGZ1bmN0aW9uKGcpeyByZXR1cm4gZy5sZW5ndGg7IH0pLFxyXG4gICAgICBjZW50ZXJYOiArY2VudGVyWC50b0ZpeGVkKDEpLFxyXG4gICAgICB1c2FibGVXOiAraW5mby51c2FibGVXLnRvRml4ZWQoMSlcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgaXNNdWx0aUNvbExheW91dCA9IChtb2RlID09PSBcInR3b1wiIHx8IG1vZGUgPT09IFwidGhyZWVcIik7XHJcblxyXG4gICAgLy8gRW4gbXVsdGktY29sdW1uYTogY2FkYSBjb2x1bW5hIGFwaWxhZGEgc2UgY2VudHJhIHBvciBzdSBwcm9waW8gYmJveC5cbiAgICAvLyBBc8OtLCBlbCBjZW50cm8gZGUgY2FkYSBjb2x1bW5hIGNvaW5jaWRlIGNvbiBlbCBjZW50cm8gZGUgcGFudGFsbGEuXG5cclxuICAgIC8vIC0tLSBBbmNob3IgZ2xvYmFsOiBkw7NuZGUgZXN0YWJhIOKAnGVsIGJsb3F1ZeKAnSBvcmlnaW5hbG1lbnRlIC0tLVxyXG4gICAgdmFyIGZpcnN0R3JvdXAgPSBncm91cHNbMF0gfHwgW107XHJcbiAgICB2YXIgYW5jaG9yID0gSW5maW5pdHk7XHJcbiAgICBmb3IgKHZhciBpPTA7aTxmaXJzdEdyb3VwLmxlbmd0aDtpKyspe1xyXG4gICAgICBhbmNob3IgPSBNYXRoLm1pbihhbmNob3IsIGZpcnN0R3JvdXBbaV0udG9wKTtcclxuICAgIH1cclxuICAgIGlmICghaXNGaW5pdGUoYW5jaG9yKSkgYW5jaG9yID0gQ0ZHLlBBRF9UT1A7XHJcbiAgICBhbmNob3IgPSBNYXRoLm1heChDRkcuUEFEX1RPUCwgYW5jaG9yKTtcclxuXHJcbiAgICAvLyBDdXJzb3IgZ2xvYmFsOiBkw7NuZGUgdGVybWluYSBlbCBjb250ZW5pZG8gYXBpbGFkbyBoYXN0YSBhaG9yYVxyXG4gICAgdmFyIGdsb2JhbEN1cnNvciA9IGFuY2hvcjtcclxuXHJcbiAgICAvLyBTZXBhcmFjacOzbiBlbnRyZSBjb2x1bW5hcyBhcGlsYWRhcyAoaXpxLCBjZW50cm8sIGRlcilcclxuICAgIHZhciBHUk9VUF9HQVAgPSAxNDtcclxuXHJcbiAgICBmb3IgKHZhciBnPTA7IGc8Z3JvdXBzLmxlbmd0aDsgZysrKXtcbiAgICAgIHZhciBjb2wgPSBncm91cHNbZ10gfHwgW107XG4gICAgICBpZiAoIWNvbC5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgdmFyIGNvbFJlZmVyZW5jZUNlbnRlclggPSBOYU47XG4gICAgICB2YXIgY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCA9IE5hTjtcblxyXG4gICAgICAvLyBNw6l0cmljYXMgcG9yIGdydXBvIHNvbG8gcGFyYSBkZWJ1Zy5cclxuICAgICAgdmFyIGdyb3VwTWluTGVmdCA9IEluZmluaXR5O1xyXG4gICAgICB2YXIgZ3JvdXBNYXhSaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpe1xyXG4gICAgICAgIGZvciAodmFyIGdnPTA7IGdnPGNvbC5sZW5ndGg7IGdnKyspe1xyXG4gICAgICAgICAgZ3JvdXBNaW5MZWZ0ID0gTWF0aC5taW4oZ3JvdXBNaW5MZWZ0LCBjb2xbZ2ddLmxlZnQpO1xyXG4gICAgICAgICAgZ3JvdXBNYXhSaWdodCA9IE1hdGgubWF4KGdyb3VwTWF4UmlnaHQsIGNvbFtnZ10ubGVmdCArIGNvbFtnZ10ud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgZ3JvdXBXaWR0aCA9IGlzTXVsdGlDb2xMYXlvdXQgPyBNYXRoLm1heCgwLCBncm91cE1heFJpZ2h0IC0gZ3JvdXBNaW5MZWZ0KSA6IDA7XHJcbiAgICAgIHZhciBncm91cEJhc2VMZWZ0ID0gaXNNdWx0aUNvbExheW91dCA/IChjZW50ZXJYIC0gZ3JvdXBXaWR0aCAvIDIpIDogMDtcclxuXHJcbiAgICAgIC8vIE9mZnNldCB2ZXJ0aWNhbCBvcmlnaW5hbCBkZSBlc3RhIGNvbHVtbmEgcmVzcGVjdG8gZGVsIGFuY2hvclxyXG4gICAgICB2YXIgY29sTWluVG9wID0gSW5maW5pdHk7XHJcbiAgICAgIGZvciAodmFyIGs9MDtrPGNvbC5sZW5ndGg7aysrKXtcclxuICAgICAgICBjb2xNaW5Ub3AgPSBNYXRoLm1pbihjb2xNaW5Ub3AsIGNvbFtrXS50b3ApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNGaW5pdGUoY29sTWluVG9wKSkgY29sTWluVG9wID0gYW5jaG9yO1xyXG5cclxuICAgICAgdmFyIGNvbE9mZnNldCA9IGNvbE1pblRvcCAtIGFuY2hvcjtcclxuICAgICAgdmFyIGNvbFN0YXJ0ID0gZ2xvYmFsQ3Vyc29yICsgKGcgPT09IDAgPyAwIDogR1JPVVBfR0FQKSArIE1hdGgubWF4KDAsIGNvbE9mZnNldCk7XHJcbiAgICAgIG1zbExvZyhcInN0YWNrOmdyb3VwOnN0YXJ0XCIsIHtcclxuICAgICAgICBnOiBnLFxyXG4gICAgICAgIGNvbFNpemU6IGNvbC5sZW5ndGgsXHJcbiAgICAgICAgY29sTWluVG9wOiArY29sTWluVG9wLnRvRml4ZWQoMSksXHJcbiAgICAgICAgY29sT2Zmc2V0OiArY29sT2Zmc2V0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgY29sU3RhcnQ6ICtjb2xTdGFydC50b0ZpeGVkKDEpLFxuICAgICAgICBnbG9iYWxDdXJzb3I6ICtnbG9iYWxDdXJzb3IudG9GaXhlZCgxKSxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZ3JvdXBNaW5MZWZ0OiBpc011bHRpQ29sTGF5b3V0ID8gK2dyb3VwTWluTGVmdC50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgZ3JvdXBXaWR0aDogaXNNdWx0aUNvbExheW91dCA/ICtncm91cFdpZHRoLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICBncm91cEJhc2VMZWZ0OiBpc011bHRpQ29sTGF5b3V0ID8gK2dyb3VwQmFzZUxlZnQudG9GaXhlZCgxKSA6IG51bGxcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQ3Vyc29yIGxvY2FsIGRlIGVzdGEgY29sdW1uYVxyXG4gICAgICB2YXIgY29sQ3Vyc29yID0gY29sU3RhcnQ7XHJcblxyXG4gICAgICBmb3IgKHZhciBqPTA7IGo8Y29sLmxlbmd0aDsgaisrKXtcclxuICAgICAgICB2YXIgYyA9IGNvbFtqXTtcclxuXHJcbiAgICAgICAgLy8gVG9wIGRlbCBjbHVzdGVyIGVuIGVsIGZsdWpvIG1vYmlsZVxyXG4gICAgICAgIHZhciBjbHVzdGVyVG9wO1xyXG5cclxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xDdXJzb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZDID0gY29sW2otMV07XG4gICAgICAgICAgdmFyIHByZXZCb3R0b20gPSAoY2x1c3RlclRvcFByZXYgKyBwcmV2Qy5oZWlnaHQpO1xuXG4gICAgICAgICAgLy8g4pyFIEdhcCBvcmlnaW5hbCBlbnRyZSBjbHVzdGVycyAoY2FudmFzKVxuICAgICAgICAgIHZhciBwcmV2Qm90dG9tT3JpZyA9IChwcmV2Qy50b3AgKyBwcmV2Qy5oZWlnaHQpO1xuICAgICAgICAgIHZhciBnYXBPcmlnID0gYy50b3AgLSBwcmV2Qm90dG9tT3JpZztcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGdhcE9yaWcpKSBnYXBPcmlnID0gMDtcblxuICAgICAgICAgIHZhciBvdmVybGFwSW5Tb3VyY2UgPSBnYXBPcmlnIDwgMDtcbiAgICAgICAgICBpZiAoKG1vZGUgPT09IFwidHdvXCIgfHwgbW9kZSA9PT0gXCJ0aHJlZVwiKSAmJiBvdmVybGFwSW5Tb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIFNpIGVuIGVsIG9yaWdpbmFsIGVzdGUgY2x1c3RlciBjYWUgZGVudHJvIGRlbCBhbnRlcmlvciwgcmVzcGV0YW1vc1xuICAgICAgICAgICAgLy8gc3UgdG9wIHJlbGF0aXZvIHBhcmEgbm8gbWFuZGFybG8gYWwgZmluYWwgZGUgbGEgY29sdW1uYS5cbiAgICAgICAgICAgIHZhciByZWxUb3BJbkNvbCA9IGMudG9wIC0gY29sTWluVG9wO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShyZWxUb3BJbkNvbCkpIHJlbFRvcEluQ29sID0gMDtcbiAgICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xTdGFydCArIE1hdGgubWF4KDAsIHJlbFRvcEluQ29sKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g4pyFIEdhcCDigJxtb2JpbGUtZnJpZW5kbHnigJ06IGVzY2FsYWRvICsgY2xhbXBcbiAgICAgICAgICAgIHZhciBnYXBXYW50ZWQgPSBjbGFtcChnYXBPcmlnICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XG5cbiAgICAgICAgICAgIC8vIOKchSBBbnRpLXNvbGFwZSBkZWZpbml0aXZvOlxuICAgICAgICAgICAgLy8gICBlbCBwcsOzeGltbyBjbHVzdGVyIFNJRU1QUkUgZW1waWV6YSBkZXNwdcOpcyBkZWwgYm90dG9tIHJlYWwgZGVsIGFudGVyaW9yICsgZ2FwV2FudGVkXG4gICAgICAgICAgICBjbHVzdGVyVG9wID0gcHJldkJvdHRvbSArIGdhcFdhbnRlZDtcblxuICAgICAgICAgICAgLy8gRW4gbXVsdGktY29sdW1uYSBudW5jYSBhdmFuemFtb3MgaGFjaWEgYXJyaWJhIHJlc3BlY3RvIGFsIGZsdWpvIHlhIGNvbnN1bWlkby5cbiAgICAgICAgICAgIGlmICgobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpICYmIGNsdXN0ZXJUb3AgPCBjb2xDdXJzb3IpIHtcbiAgICAgICAgICAgICAgY2x1c3RlclRvcCA9IGNvbEN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxyXG4gICAgICAgIC8vIEd1YXJkYW1vcyBwYXJhIGVsIHByw7N4aW1vIGxvb3BcclxuICAgICAgICB2YXIgY2x1c3RlclRvcFByZXYgPSBjbHVzdGVyVG9wO1xyXG5cclxuICAgICAgICAvLyDCv2NlbnRyYXIgZXN0ZSBjbHVzdGVyP1xuICAgICAgICB2YXIgZm9yY2VDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc1RleHRJbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc05vblRleHRJbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgdD0wOyB0PGMuaXRlbXMubGVuZ3RoOyB0Kyspe1xuICAgICAgICAgIHZhciBpc1RleHRUID0gKGMuaXRlbXNbdF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgICBpZiAoaXNUZXh0VCkgaGFzVGV4dEluQ2x1c3RlciA9IHRydWU7XG4gICAgICAgICAgZWxzZSBoYXNOb25UZXh0SW5DbHVzdGVyID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoKGMuaXRlbXNbdF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jZW50ZXJcIikgfHwgXCJcIikgPT09IFwiZm9yY2VcIikge1xuICAgICAgICAgICAgZm9yY2VDZW50ZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXHJcbiAgICAgICAgLy8gb25lL3Jvd3M6IGNlbnRybyBwb3IgY2x1c3RlciAoY29tcG9ydGFtaWVudG8gb3JpZ2luYWwpXHJcbiAgICAgICAgLy8gdHdvL3RocmVlOiBhcGlsYXIgY2FkYSBjb2x1bW5hIGVuIGxhIG1pc21hIHJlZmVyZW5jaWEgWCxcclxuICAgICAgICAvLyBwcmVzZXJ2YW5kbyBvZmZzZXRzIGludGVybm9zIGRlIGVzYSBjb2x1bW5hLlxyXG4gICAgICAgIHZhciBrZWVwQ2VudGVyID0gZm9yY2VDZW50ZXIgPyB0cnVlIDogKGMud2lkdGggPCAoaW5mby51c2FibGVXICogMC45NSkpO1xuICAgICAgICB2YXIgY2x1c3RlckxlZnQgPSBrZWVwQ2VudGVyID8gKGNlbnRlclggLSBjLndpZHRoIC8gMikgOiBjLmxlZnQ7XG4gICAgICAgIHZhciBpc1RleHRPbmx5Q2x1c3RlciA9IGhhc1RleHRJbkNsdXN0ZXIgJiYgIWhhc05vblRleHRJbkNsdXN0ZXI7XG4gICAgICAgIHZhciBzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlciA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNNdWx0aUNvbExheW91dCkge1xuICAgICAgICAgIC8vIE1vZG8gbGVjdHVyYSBtb2JpbGUgbXVsdGktY29sOlxuICAgICAgICAgIC8vIHVzYXIgdW5hIG1pc21hIHJlZmVyZW5jaWEgWCBwYXJhIHRvZGEgbGEgY29sdW1uYSBhcGlsYWRhIHlcbiAgICAgICAgICAvLyBwcmVzZXJ2YXIgZWwgb2Zmc2V0IGhvcml6b250YWwgb3JpZ2luYWwgZGUgY2FkYSBjbHVzdGVyLlxuICAgICAgICAgIC8vIEVzdG8gbWFudGllbmUgYWxpbmVhZG8gdGV4dG8vZm9ybWEgY3VhbmRvIGxhIGNvbHVtbmEgc2UgcGFydGVcbiAgICAgICAgICAvLyBlbiB2YXJpb3MgY2x1c3RlcnMuXG4gICAgICAgICAgdmFyIHJlbENsdXN0ZXJMZWZ0ID0gKGMubGVmdCB8fCAwKSAtIChncm91cE1pbkxlZnQgfHwgMCk7XG4gICAgICAgICAgY2x1c3RlckxlZnQgPSBncm91cEJhc2VMZWZ0ICsgcmVsQ2x1c3RlckxlZnQ7XG5cbiAgICAgICAgICAvLyBQZXJtaXRlIGZvcnphciBjZW50cmFkbyBwb3IgY2x1c3RlciBzaSBlbCBub2RvIGxvIHBpZGUuXG4gICAgICAgICAgaWYgKGZvcmNlQ2VudGVyKSBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcblxuICAgICAgICAgIC8vIFNpIGVzdGEgY29sdW1uYSB0aWVuZSB1biBjbHVzdGVyIGNvbiBmb3JtYSAobyBtaXh0byksIHVzYW1vcyBzdVxuICAgICAgICAgIC8vIGNlbnRybyBjb21vIHJlZmVyZW5jaWEgcGFyYSBhbGluZWFyIGNsdXN0ZXJzIHNvbG8tdGV4dG8gZGViYWpvLlxuICAgICAgICAgIHZhciBjbHVzdGVyUmVmQ2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaGFzTm9uVGV4dEluQ2x1c3Rlcikge1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNpYSBiYXNhZGEgZW4gaXRlbXMgbm8tdGV4dG8gKGZvcm1hL2ljb25vKSwgbm8gZW4gdG9kbyBlbFxuICAgICAgICAgICAgLy8gY2x1c3RlciwgcGFyYSBxdWUgdGV4dG9zIGxhcmdvcyBubyBkZXNwbGFjZW4gZWwgY2VudHJvIGRlIGNvbHVtbmEuXG4gICAgICAgICAgICB2YXIgbnRNaW5SZWwgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBudE1heFJlbCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIG50aT0wOyBudGk8Yy5pdGVtcy5sZW5ndGg7IG50aSsrKXtcbiAgICAgICAgICAgICAgdmFyIG50SXQgPSBjLml0ZW1zW250aV07XG4gICAgICAgICAgICAgIHZhciBudElzVGV4dCA9IChudEl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgICAgIGlmIChudElzVGV4dCkgY29udGludWU7XG4gICAgICAgICAgICAgIG50TWluUmVsID0gTWF0aC5taW4obnRNaW5SZWwsIChudEl0Ll9yZWxMZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgbnRNYXhSZWwgPSBNYXRoLm1heChudE1heFJlbCwgKG50SXQuX3JlbExlZnQgfHwgMCkgKyAobnRJdC53aWR0aCB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUobnRNaW5SZWwpICYmIGlzRmluaXRlKG50TWF4UmVsKSAmJiBudE1heFJlbCA+IG50TWluUmVsKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyAoKG50TWluUmVsICsgbnRNYXhSZWwpIC8gMik7XG4gICAgICAgICAgICAgIHNvdXJjZUNsdXN0ZXJSZWZDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArICgobnRNaW5SZWwgKyBudE1heFJlbCkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyBjLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclggPSBjbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICAgIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPSBzb3VyY2VDbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUZXh0T25seUNsdXN0ZXIgJiYgaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpIHtcbiAgICAgICAgICAgIHZhciBtYXhTbmFwRGVsdGEgPSBNYXRoLm1pbigxMjAsIGluZm8udXNhYmxlVyAqIDAuMzUpO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUNsdXN0ZXJDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0WCA9IGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXG4gICAgICAgICAgICAgID8gKHNvdXJjZUNsdXN0ZXJDZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgOiBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRYKSAmJiBNYXRoLmFicyhzb3VyY2VEcmlmdFgpIDw9IG1heFNuYXBEZWx0YSkge1xuICAgICAgICAgICAgICBjbHVzdGVyTGVmdCA9IChjb2xSZWZlcmVuY2VDZW50ZXJYICsgc291cmNlRHJpZnRYKSAtIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyYSBsYWJlbHMgY29ydG9zLCBjZW50cmFyIGVsIGNvbnRlbmlkbyB0ZXh0dWFsIGRlbnRybyBkZWwgYm94LlxuICAgICAgICAgICAgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBjLndpZHRoIDw9IChpbmZvLnVzYWJsZVcgKiAwLjY1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXNsTG9nKFwic3RhY2s6Y2x1c3RlclwiLCB7XG4gICAgICAgICAgZzogZyxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIG9yaWdUb3A6ICtjLnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIG9yaWdMZWZ0OiArYy5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgbmV3VG9wOiArY2x1c3RlclRvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgbmV3TGVmdDogK2NsdXN0ZXJMZWZ0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcclxuICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgZm9yY2VDZW50ZXI6IGZvcmNlQ2VudGVyLFxuICAgICAgICAgIGtlZXBDZW50ZXI6IGtlZXBDZW50ZXIsXG4gICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclg6ICh0eXBlb2YgY29sUmVmZXJlbmNlQ2VudGVyWCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShjb2xSZWZlcmVuY2VDZW50ZXJYKSkgPyArY29sUmVmZXJlbmNlQ2VudGVyWC50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgICBpc1RleHRPbmx5Q2x1c3RlcjogaXNUZXh0T25seUNsdXN0ZXIsXG4gICAgICAgICAgY2VudGVyU2hvcnRUZXh0OiBzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlclxuICAgICAgICB9KTtcblxyXG4gICAgICAgIHZhciB0ZXh0Q291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIHRjPTA7IHRjPGMuaXRlbXMubGVuZ3RoOyB0YysrKXtcclxuICAgICAgICAgIGlmICgoYy5pdGVtc1t0Y10ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgdGV4dENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaW5lYXJpemVDbHVzdGVyID0gKG1vZGUgPT09IFwicm93c1wiICYmIGMuaXRlbXMubGVuZ3RoID4gMSAmJiB0ZXh0Q291bnQgPj0gMik7XHJcbiAgICAgICAgdmFyIGNsdXN0ZXJCb3R0b21Vc2VkID0gY2x1c3RlclRvcCArIGMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDYXNvIGVzcGVjaWFsOiBlbiByb3dzLCBzaSBlbCBjbHVzdGVyIGFncnVwYSB2YXJpb3MgdGV4dG9zLCBsb1xyXG4gICAgICAgIC8vIGNvbnZlcnRpbW9zIGEgZmx1am8gdmVydGljYWwgY2VudHJhZG8gcGFyYSBldml0YXIgdGV4dG8gbGFkbyBhIGxhZG8uXHJcbiAgICAgICAgaWYgKGxpbmVhcml6ZUNsdXN0ZXIpe1xyXG4gICAgICAgICAgdmFyIGFsbEl0ZW1zID0gYy5pdGVtcy5zbGljZSgpO1xyXG4gICAgICAgICAgdmFyIG5vblRleHQgPSBhbGxJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXR4KXtcclxuICAgICAgICAgICAgcmV0dXJuIChpdHgubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpICE9PSBcIjFcIjtcclxuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgaWYgKGEudG9wICE9PSBiLnRvcCkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHZhciB0ZXh0cyA9IGFsbEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdHgpe1xyXG4gICAgICAgICAgICByZXR1cm4gKGl0eC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIE9yZGVuIHNlbcOhbnRpY28gZGUgbGVjdHVyYTpcclxuICAgICAgICAgIC8vIG5vLXRleHRvICsgdGV4dG8gbcOhcyBjZXJjYW5vIChkZWJham8geSBwb3IgZWplIFgpLCBsdWVnbyByZW1hbmVudGVzLlxyXG4gICAgICAgICAgdmFyIG9yZGVyZWQgPSBbXTtcclxuICAgICAgICAgIHZhciB1c2VkVGV4dCA9IHt9O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIG50PTA7IG50PG5vblRleHQubGVuZ3RoOyBudCsrKXtcclxuICAgICAgICAgICAgdmFyIG50SXRlbSA9IG5vblRleHRbbnRdO1xyXG4gICAgICAgICAgICBvcmRlcmVkLnB1c2gobnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBudEN4ID0gKG50SXRlbS5sZWZ0IHx8IDApICsgKG50SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBudEJvdHRvbSA9IChudEl0ZW0udG9wIHx8IDApICsgKG50SXRlbS5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIHZhciBiZXN0SWR4VHh0ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBiZXN0U2NvcmUgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHR4PTA7IHR4PHRleHRzLmxlbmd0aDsgdHgrKyl7XHJcbiAgICAgICAgICAgICAgaWYgKHVzZWRUZXh0W3R4XSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgdmFyIHRJdGVtID0gdGV4dHNbdHhdO1xyXG4gICAgICAgICAgICAgIHZhciB0Q3ggPSAodEl0ZW0ubGVmdCB8fCAwKSArICh0SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHZHYXBUeHQgPSAodEl0ZW0udG9wIHx8IDApIC0gbnRCb3R0b207IC8vIHByZWZlcmlyIHRleHRvIGRlYmFqb1xyXG4gICAgICAgICAgICAgIHZhciBoRGlzdFR4dCA9IE1hdGguYWJzKHRDeCAtIG50Q3gpO1xyXG4gICAgICAgICAgICAgIHZhciBwZW5hbHR5QWJvdmUgPSB2R2FwVHh0IDwgLTIgPyAxMDAwMCA6IDA7XHJcbiAgICAgICAgICAgICAgdmFyIHNjb3JlID0gcGVuYWx0eUFib3ZlICsgTWF0aC5hYnModkdhcFR4dCkgKiAyICsgaERpc3RUeHQ7XHJcbiAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKXtcclxuICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICAgICAgYmVzdElkeFR4dCA9IHR4O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJlc3RJZHhUeHQgPj0gMCl7XHJcbiAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKHRleHRzW2Jlc3RJZHhUeHRdKTtcclxuICAgICAgICAgICAgICB1c2VkVGV4dFtiZXN0SWR4VHh0XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBUZXh0b3Mgbm8gZW1wYXJlamFkb3NcclxuICAgICAgICAgIGZvciAodmFyIHR4Mj0wOyB0eDI8dGV4dHMubGVuZ3RoOyB0eDIrKyl7XHJcbiAgICAgICAgICAgIGlmICghdXNlZFRleHRbdHgyXSkgb3JkZXJlZC5wdXNoKHRleHRzW3R4Ml0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNpIG5vIGh1Ym8gbm8tdGV4dG8sIGZhbGxiYWNrIHNpbXBsZSBwb3IgdG9wL2xlZnRcclxuICAgICAgICAgIGlmICghb3JkZXJlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgb3JkZXJlZCA9IGFsbEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgbG9jYWxDdXJzb3IgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIHByZXZJdCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgcHJldlRvcEFwcGxpZWQgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIEVYVFJBX0NPTF9CUkVBS19HQVAgPSA4O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGxpPTA7IGxpPG9yZGVyZWQubGVuZ3RoOyBsaSsrKXtcclxuICAgICAgICAgICAgdmFyIGxpdCA9IG9yZGVyZWRbbGldO1xyXG5cclxuICAgICAgICAgICAgdmFyIGtlZXBMYXlvdXRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgICAgaWYgKGtlZXBMYXlvdXRMaW4pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1RvcExpbiA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgICBpZiAocHJldkl0KXtcclxuICAgICAgICAgICAgICB2YXIgZ2FwT3JpZ0xpbiA9IGxpdC50b3AgLSAocHJldkl0LnRvcCArIHByZXZJdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZ2FwT3JpZ0xpbikpIGdhcE9yaWdMaW4gPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBnYXBXYW50ZWRMaW4gPSBjbGFtcChnYXBPcmlnTGluICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XHJcbiAgICAgICAgICAgICAgdmFyIHByZXZJc1RleHRMaW4gPSAocHJldkl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgdmFyIGN1cnJJc1RleHRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgLy8gQWwgcGFzYXIgZGUgXCJ0ZXh0byBmaW5hbCBkZSBjb2x1bW5hXCIgYSBcIm51ZXZvIG5vLXRleHRvXCIgYWdyZWdhbW9zIGFpcmUuXHJcbiAgICAgICAgICAgICAgaWYgKHByZXZJc1RleHRMaW4gJiYgIWN1cnJJc1RleHRMaW4pIGdhcFdhbnRlZExpbiArPSBFWFRSQV9DT0xfQlJFQUtfR0FQO1xyXG4gICAgICAgICAgICAgIG5ld1RvcExpbiA9IHByZXZUb3BBcHBsaWVkICsgcHJldkl0LmhlaWdodCArIGdhcFdhbnRlZExpbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ld0xlZnRMaW4gPSBjZW50ZXJYIC0gKGxpdC53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBrZWVwQWxpZ25MaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIikgPT09IFwia2VlcFwiO1xyXG4gICAgICAgICAgICBpZiAoa2VlcEFsaWduTGluKSBuZXdMZWZ0TGluID0gbGl0LmxlZnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3VG9wTGluIC0gbGl0LnRvcCkgPiAwLjUgfHwgTWF0aC5hYnMobmV3TGVmdExpbiAtIGxpdC5sZWZ0KSA+IDAuNSkgY2hhbmdlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBFbiByb3dzIGxpbmVhbGl6YWRvLCBmb3J6YW1vcyBjZW50cmFkbyB2aXN1YWwgcmVhbCBkZSB0ZXh0by5cclxuICAgICAgICAgICAgdmFyIGlzVGV4dExpbiA9IChsaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgICAgaWYgKGlzVGV4dExpbiAmJiAha2VlcEFsaWduTGluKSB7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgICB2YXIgdGZMaW4gPSBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIjtcclxuICAgICAgICAgICAgICBpZiAodGZMaW4uaW5kZXhPZihcInRyYW5zbGF0ZVgoXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gdGZMaW4ucmVwbGFjZSgvdHJhbnNsYXRlWFxcKFteKV0qXFwpLywgXCJ0cmFuc2xhdGVYKDBweClcIik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50b3AgPSBuZXdUb3BMaW4gKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLmxlZnQgPSBuZXdMZWZ0TGluICsgXCJweFwiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcclxuXHJcbiAgICAgICAgICAgIHByZXZJdCA9IGxpdDtcclxuICAgICAgICAgICAgcHJldlRvcEFwcGxpZWQgPSBuZXdUb3BMaW47XHJcbiAgICAgICAgICAgIGxvY2FsQ3Vyc29yID0gbmV3VG9wTGluICsgKGxpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEN1cnNvciA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcGxpY2FyIGEgY2FkYSBpdGVtIHByZXNlcnZhbmRvIG9mZnNldHMgcmVsYXRpdm9zIChzb2xhcGUgaW50YWN0bylcclxuICAgICAgICBmb3IgKHZhciBpaT0wOyBpaTxjLml0ZW1zLmxlbmd0aDsgaWkrKyl7XHJcbiAgICAgICAgICB2YXIgaXQgPSBjLml0ZW1zW2lpXTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IHRvdGFsIGRlbCBsYXlvdXQgKGRlY29yYWNpb25lcywgZXRjLilcclxuICAgICAgICAgIHZhciBrZWVwTGF5b3V0ID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgIGlmIChrZWVwTGF5b3V0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICB2YXIgbmV3VG9wID0gY2x1c3RlclRvcCArIChpdC5fcmVsVG9wIHx8IDApO1xyXG4gICAgICAgICAgdmFyIG5ld0xlZnQgPSBjbHVzdGVyTGVmdCArIChpdC5fcmVsTGVmdCB8fCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IGRlIGNlbnRyYWRvIChtYW50ZW5lciBsZWZ0IG9yaWdpbmFsIGRlbCBpdGVtKVxuICAgICAgICAgIHZhciBrZWVwQWxpZ24gPSAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1hbGlnblwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBBbGlnbikgbmV3TGVmdCA9IGl0LmxlZnQ7XG5cbiAgICAgICAgICAvLyBFbiBtdWx0aS1jb2wsIG5ldXRyYWxpemFtb3MgU0lFTVBSRSB0cmFuc2xhdGVYKC4uLikgZGUgdGV4dG9zXG4gICAgICAgICAgLy8gcGFyYSBxdWUgbGEgcG9zaWNpw7NuIGxlZnQgY2FsY3VsYWRhIHNlYSBsYSByZWZlcmVuY2lhIHZpc3VhbCByZWFsLlxuICAgICAgICAgIHZhciBpc1RleHROb2RlID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGlzU2hvcnRUZXh0Qm94ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNob3VsZFJlY2VudGVyVGV4dEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2VudGVyQnlBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0YXJnZXRUZXh0Q2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZSAmJiBpc011bHRpQ29sTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgdGYgPSBpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRmLmluZGV4T2YoXCJ0cmFuc2xhdGVYKFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0Zi5yZXBsYWNlKC90cmFuc2xhdGVYXFwoW14pXSpcXCkvLCBcInRyYW5zbGF0ZVgoMHB4KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzU2hvcnRUZXh0Qm94ID0gKGl0LndpZHRoIHx8IDApIDw9IChpbmZvLnVzYWJsZVcgKiAwLjUpICYmIChpdC5oZWlnaHQgfHwgMCkgPD0gNDI7XG4gICAgICAgICAgICB2YXIgdGFDdXJyZW50ID0gKChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2VudGVyQnlBbGlnbiA9IHRhQ3VycmVudCA9PT0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIHZhciBzaG91bGRDZW50ZXJWaXN1YWxUZXh0ID1cbiAgICAgICAgICAgICAgKHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyIHx8IGlzU2hvcnRUZXh0Qm94IHx8IGNlbnRlckJ5QWxpZ24pICYmXG4gICAgICAgICAgICAgICFrZWVwQWxpZ247XG4gICAgICAgICAgICBzaG91bGRSZWNlbnRlclRleHRJdGVtID1cbiAgICAgICAgICAgICAgc2hvdWxkQ2VudGVyVmlzdWFsVGV4dCAmJlxuICAgICAgICAgICAgICBpc0Zpbml0ZShjb2xSZWZlcmVuY2VDZW50ZXJYKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2TGVmdFR4dCA9IG5ld0xlZnQ7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VJdGVtQ2VudGVyWCA9IChpdC5sZWZ0IHx8IDApICsgKGl0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0SXRlbVggPSBpc0Zpbml0ZShjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYKVxuICAgICAgICAgICAgICAgID8gKHNvdXJjZUl0ZW1DZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgICA6IE5hTjtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldENlbnRlclggPSBjb2xSZWZlcmVuY2VDZW50ZXJYO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRJdGVtWCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXJYICs9IHNvdXJjZURyaWZ0SXRlbVg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0VGV4dENlbnRlclggPSB0YXJnZXRDZW50ZXJYO1xuICAgICAgICAgICAgICBuZXdMZWZ0ID0gdGFyZ2V0Q2VudGVyWCAtIChpdC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdMZWZ0IC0gcHJldkxlZnRUeHQpID4gMC41KSB7XG4gICAgICAgICAgICAgICAgbXNsTG9nKFwic3RhY2s6aXRlbTp0ZXh0UmVjZW50ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgZzogZyxcbiAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICBpaTogaWksXG4gICAgICAgICAgICAgICAgICBwcmV2TGVmdDogK3ByZXZMZWZ0VHh0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICBuZXdMZWZ0OiArbmV3TGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgaXRlbVc6ICsoaXQud2lkdGggfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIHJlZkNlbnRlclg6ICtjb2xSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICBzb3VyY2VSZWZDZW50ZXJYOiAodHlwZW9mIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCkpID8gK2NvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VEcmlmdFg6IGlzRmluaXRlKHNvdXJjZURyaWZ0SXRlbVgpID8gK3NvdXJjZURyaWZ0SXRlbVgudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzaG9ydEJveDogaXNTaG9ydFRleHRCb3gsXG4gICAgICAgICAgICAgICAgICBjZW50ZXJCeUFsaWduOiBjZW50ZXJCeUFsaWduXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRDZW50ZXJWaXN1YWxUZXh0KSB7XG4gICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcbiAgICAgICAgICAgICAgLy8gRXZpdGEgZW5jb2dpbWllbnRvIGhvcml6b250YWwgaGVyZWRhZG8gcXVlIGRlc3BsYXphIGVsIGNlbnRybyB2aXN1YWwuXG4gICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRleHQtem9vbVwiLCBcIjFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXQubm9kZS5zdHlsZS50b3AgPSBuZXdUb3AgKyBcInB4XCI7XG4gICAgICAgICAgaXQubm9kZS5zdHlsZS5sZWZ0ID0gbmV3TGVmdCArIFwicHhcIjtcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgaXQubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcblxuICAgICAgICAgIC8vIENvcnJlY2Npw7NuIGZpbmFsIHBvciBwb3NpY2nDs24gcmVuZGVyaXphZGEgcmVhbCBkZWwgdGV4dG9cbiAgICAgICAgICAvLyAoZnVlbnRlcy90cmFuc2Zvcm0gcHVlZGVuIGludHJvZHVjaXIgZGVzdsOtb3MgdmlzdWFsZXMgc3ViLXDDrXhlbCkuXG4gICAgICAgICAgaWYgKGlzVGV4dE5vZGUgJiYgaXNNdWx0aUNvbExheW91dCAmJiBzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICB2YXIgcnJUeHQgPSByZWxSZWN0KGl0Lm5vZGUsIHJvb3RFbCk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRDZW50ZXJYID0gKHJyVHh0LmxlZnQgfHwgMCkgKyAocnJUeHQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgdmFyIHRhcmdldFJlbmRlckNlbnRlclggPSBpc0Zpbml0ZSh0YXJnZXRUZXh0Q2VudGVyWCkgPyB0YXJnZXRUZXh0Q2VudGVyWCA6IGNvbFJlZmVyZW5jZUNlbnRlclg7XG4gICAgICAgICAgICB2YXIgcmVuZGVyRGVsdGEgPSByZW5kZXJlZENlbnRlclggLSB0YXJnZXRSZW5kZXJDZW50ZXJYO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKHJlbmRlckRlbHRhKSAmJiBNYXRoLmFicyhyZW5kZXJEZWx0YSkgPiAwLjYpIHtcbiAgICAgICAgICAgICAgdmFyIGNvcnJlY3RlZExlZnQgPSBuZXdMZWZ0IC0gcmVuZGVyRGVsdGE7XG4gICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb3JyZWN0ZWRMZWZ0KSkge1xuICAgICAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOml0ZW06dGV4dFJlbmRlckFkanVzdFwiLCB7XG4gICAgICAgICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICAgIGlpOiBpaSxcbiAgICAgICAgICAgICAgICAgIHByZXZMZWZ0OiArbmV3TGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgY29ycmVjdGVkTGVmdDogK2NvcnJlY3RlZExlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2VudGVyWDogK3JlbmRlcmVkQ2VudGVyWC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgcmVmQ2VudGVyWDogK3RhcmdldFJlbmRlckNlbnRlclgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiArcmVuZGVyRGVsdGEudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld0xlZnQgPSBjb3JyZWN0ZWRMZWZ0O1xuICAgICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IG5ld0xlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3VG9wIC0gaXQudG9wKSA+IDAuNSB8fCBNYXRoLmFicyhuZXdMZWZ0IC0gaXQubGVmdCkgPiAwLjUpIGNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGl0ZW1Cb3R0b20gPSBuZXdUb3AgKyAoaXQuaGVpZ2h0IHx8IDApO1xuICAgICAgICAgIGlmIChpdGVtQm90dG9tID4gY2x1c3RlckJvdHRvbVVzZWQpIGNsdXN0ZXJCb3R0b21Vc2VkID0gaXRlbUJvdHRvbTtcbiAgICAgICAgfVxuXHJcbiAgICAgICAgLy8gQXZhbnphIGVsIGN1cnNvciBsb2NhbCBhbCBmaW5hbCBkZWwgY2x1c3RlclxyXG4gICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbCB0ZXJtaW5hciBsYSBjb2x1bW5hLCBlbCBjdXJzb3IgZ2xvYmFsIGJhamEgaGFzdGEgZG9uZGUgbGxlZ8OzIGVzdGEgY29sdW1uYVxyXG4gICAgICBnbG9iYWxDdXJzb3IgPSBNYXRoLm1heChnbG9iYWxDdXJzb3IsIGNvbEN1cnNvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5lZWRlZCA9IGdsb2JhbEN1cnNvciArIENGRy5QQURfQk9UO1xyXG4gICAgbXNsTG9nKFwic3RhY2s6ZW5kXCIsIHtcclxuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcclxuICAgICAgbmVlZGVkSGVpZ2h0OiArbmVlZGVkLnRvRml4ZWQoMSksXHJcbiAgICAgIGZpbmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSlcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgY2hhbmdlZDogY2hhbmdlZCwgbmVlZGVkSGVpZ2h0OiBuZWVkZWQgfTtcclxuICB9XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc1N0YWNraW5nQmxvY2siLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartSectionLayout.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartSectionLayout.ts ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMobileSmartSectionLayoutScript: () => (/* binding */ buildMobileSmartSectionLayoutScript)\n/* harmony export */ });\n/* harmony import */ var _mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobileSmartLayout */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/index.ts\");\n// functions/src/utils/mobileSmartSectionLayout.ts\n\nfunction buildMobileSmartSectionLayoutScript(opts) {\n    const cfg = (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)(opts);\n    return (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.buildScript)(cfg);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBRWlCO0FBRTVELFNBQVNFLG9DQUFvQ0MsSUFBOEI7SUFDaEYsTUFBTUMsTUFBTUosbUVBQWVBLENBQUNHO0lBQzVCLE9BQU9GLCtEQUFXQSxDQUFDRztBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHNcclxuaW1wb3J0IHsgTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zIH0gZnJvbSBcIi4vbW9iaWxlU21hcnRMYXlvdXRcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplQ29uZmlnLCBidWlsZFNjcmlwdCB9IGZyb20gXCIuL21vYmlsZVNtYXJ0TGF5b3V0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQob3B0czogTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBjZmcgPSBub3JtYWxpemVDb25maWcob3B0cyk7XHJcbiAgcmV0dXJuIGJ1aWxkU2NyaXB0KGNmZyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUNvbmZpZyIsImJ1aWxkU2NyaXB0IiwiYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQiLCJvcHRzIiwiY2ZnIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartSectionLayout.ts\n"));

/***/ })

}]);