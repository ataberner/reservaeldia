"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_functions_src_utils_generarHTMLDesdeSecciones_ts"],{

/***/ "(pages-dir-browser)/./functions/src/models/lineConstants.ts":
/*!***********************************************!*\
  !*** ./functions/src/models/lineConstants.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LINE_CONSTANTS: () => (/* binding */ LINE_CONSTANTS)\n/* harmony export */ });\n// functions/src/models/lineConstants.ts\n// Mismas constantes para el backend (TypeScript)\nconst LINE_CONSTANTS = {\n    STROKE_WIDTH: 2,\n    HIT_STROKE_WIDTH: 15,\n    DEFAULT_LENGTH: 100,\n    DEFAULT_COLOR: \"#000000\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvbW9kZWxzL2xpbmVDb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDMUMsTUFBTUEsaUJBQWlCO0lBQzVCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0FBQ2pCLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFxtb2RlbHNcXGxpbmVDb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy9tb2RlbHMvbGluZUNvbnN0YW50cy50c1xyXG4vLyBNaXNtYXMgY29uc3RhbnRlcyBwYXJhIGVsIGJhY2tlbmQgKFR5cGVTY3JpcHQpXHJcbmV4cG9ydCBjb25zdCBMSU5FX0NPTlNUQU5UUyA9IHtcclxuICBTVFJPS0VfV0lEVEg6IDIsXHJcbiAgSElUX1NUUk9LRV9XSURUSDogMTUsXHJcbiAgREVGQVVMVF9MRU5HVEg6IDEwMCxcclxuICBERUZBVUxUX0NPTE9SOiBcIiMwMDAwMDBcIlxyXG59OyJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsIlNUUk9LRV9XSURUSCIsIkhJVF9TVFJPS0VfV0lEVEgiLCJERUZBVUxUX0xFTkdUSCIsIkRFRkFVTFRfQ09MT1IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/models/lineConstants.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeObjetos.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeObjetos.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   generarHTMLDesdeObjetos: () => (/* binding */ generarHTMLDesdeObjetos)\n/* harmony export */ });\n/* harmony import */ var _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/lineConstants */ \"(pages-dir-browser)/./functions/src/models/lineConstants.ts\");\n\n// ✅ Escapar strings para meterlos en atributos/HTML\nfunction escHTML() {\n    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return String(str).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction escapeAttr() {\n    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nconst MOTION_EFFECT_VALUES = new Set([\n    \"none\",\n    \"reveal\",\n    \"draw\",\n    \"zoom\",\n    \"hover\",\n    \"pulse\"\n]);\nfunction sanitizeMotionEffect(value) {\n    const normalized = String(value || \"\").trim().toLowerCase();\n    return MOTION_EFFECT_VALUES.has(normalized) ? normalized : \"none\";\n}\nfunction normalizeRoleValue(value) {\n    return String(value || \"\").trim().toLowerCase();\n}\nfunction mapObjToDataType(obj) {\n    const tipo = normalizeRoleValue(obj === null || obj === void 0 ? void 0 : obj.tipo);\n    const figura = normalizeRoleValue(obj === null || obj === void 0 ? void 0 : obj.figura);\n    if (tipo === \"texto\" || tipo === \"text\") return \"text\";\n    if (tipo === \"imagen\" || tipo === \"image\") return \"image\";\n    if (tipo === \"icono\" || tipo === \"icono-svg\" || tipo === \"icon\") return \"icon\";\n    if (tipo === \"galeria\" || tipo === \"gallery\") return \"gallery\";\n    if (tipo === \"countdown\") return \"countdown\";\n    if (tipo === \"rsvp-boton\" || tipo === \"rsvp\") return \"rsvp\";\n    if (tipo === \"button\" || tipo === \"boton\") return \"button\";\n    if (tipo === \"line\" || tipo === \"divider\") return \"divider\";\n    if (tipo === \"forma\" && figura === \"line\") return \"divider\";\n    if (tipo === \"forma\") return \"shape\";\n    return \"unknown\";\n}\nfunction inferDataRole(obj) {\n    const explicitRole = normalizeRoleValue((obj === null || obj === void 0 ? void 0 : obj.role) || (obj === null || obj === void 0 ? void 0 : obj.rol));\n    if (explicitRole) return explicitRole;\n    const type = mapObjToDataType(obj);\n    if (type === \"text\") {\n        const fontSize = Number(obj === null || obj === void 0 ? void 0 : obj.fontSize);\n        if (Number.isFinite(fontSize) && fontSize >= 30) return \"title\";\n        if (Number.isFinite(fontSize) && fontSize >= 22) return \"subtitle\";\n        return \"body\";\n    }\n    if (type === \"divider\") return \"divider\";\n    if (type === \"image\") return \"image\";\n    if (type === \"icon\") return \"icon\";\n    if (type === \"gallery\") return \"gallery\";\n    if (type === \"countdown\") return \"countdown\";\n    if (type === \"rsvp\" || type === \"button\") return \"cta\";\n    if (type === \"shape\") return \"decorative\";\n    return \"content\";\n}\nfunction buildMotionDataAttrs(obj) {\n    const dataType = escapeAttr(mapObjToDataType(obj));\n    const dataRole = escapeAttr(inferDataRole(obj));\n    const dataMotion = escapeAttr(sanitizeMotionEffect(obj === null || obj === void 0 ? void 0 : obj.motionEffect));\n    return 'data-type=\"'.concat(dataType, '\" data-role=\"').concat(dataRole, '\" data-motion=\"').concat(dataMotion, '\"');\n}\nfunction appendMotionDataAttrs(htmlElemento, obj) {\n    if (!htmlElemento || typeof htmlElemento !== \"string\") return htmlElemento;\n    const attrs = buildMotionDataAttrs(obj);\n    return htmlElemento.replace(/(<(?:div|img|svg)\\b[^>]*\\bclass=\"[^\"]*\\bobjeto\\b[^\"]*\")/i, \"$1 \".concat(attrs));\n}\nfunction getLinkProps(obj) {\n    const raw = obj === null || obj === void 0 ? void 0 : obj.enlace;\n    if (!raw) return null;\n    if (typeof raw === \"string\") {\n        const href = escapeAttr(raw);\n        if (!href) return null;\n        return {\n            href,\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n        };\n    }\n    const href = escapeAttr(raw.href || \"\");\n    if (!href) return null;\n    const target = escapeAttr(raw.target || \"_blank\");\n    const rel = escapeAttr(raw.rel || \"noopener noreferrer\");\n    return {\n        href,\n        target,\n        rel\n    };\n}\nfunction envolverSiEnlace(htmlElemento, obj) {\n    const htmlConData = appendMotionDataAttrs(htmlElemento, obj);\n    if ((obj === null || obj === void 0 ? void 0 : obj.tipo) === \"rsvp-boton\") return htmlConData;\n    const link = getLinkProps(obj);\n    if (!link) return htmlConData;\n    return '<a href=\"'.concat(link.href, '\" target=\"').concat(link.target, '\" rel=\"').concat(link.rel, '\" style=\"text-decoration:none;color:inherit;display:contents\">').concat(htmlConData, \"</a>\");\n}\nfunction escapeHTML() {\n    let texto = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return texto.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\nfunction generarHTMLDesdeObjetos(objetos, _secciones) {\n    const altoModoPorSeccion = new Map((_secciones || []).map((s)=>[\n            s.id,\n            String(s.altoModo || \"fijo\").toLowerCase()\n        ]));\n    function esSeccionPantalla(obj) {\n        const modo = altoModoPorSeccion.get(obj === null || obj === void 0 ? void 0 : obj.seccionId) || \"fijo\";\n        return modo === \"pantalla\";\n    }\n    function isFullBleed(obj) {\n        return String((obj === null || obj === void 0 ? void 0 : obj.anclaje) || \"\").toLowerCase() === \"fullbleed\";\n    }\n    /**\r\n   * ✅ Escala uniforme del CONTENIDO:\r\n   * - pantalla: var(--sfinal) (fit si hace falta)\r\n   * - fijo: var(--sx)\r\n   */ function sContenidoVar(obj) {\n        return esSeccionPantalla(obj) ? \"var(--sfinal)\" : \"var(--sx)\";\n    }\n    /**\r\n   * ✅ X scale:\r\n   * - fullBleed: var(--bx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sX(obj) {\n        return isFullBleed(obj) ? \"var(--bx)\" : sContenidoVar(obj);\n    }\n    /**\r\n   * ✅ Y scale:\r\n   * - fullBleed: var(--sx) (NO fit)\r\n   * - contenido: sContenidoVar (fit si pantalla)\r\n   */ function sY(obj) {\n        return isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n    }\n    function pxX(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return \"calc(\".concat(sX(obj), \" * \").concat(n, \"px)\");\n    }\n    function pxY(obj, px) {\n        const n = Number.isFinite(px) ? px : 0;\n        return \"calc(\".concat(sY(obj), \" * \").concat(n, \"px)\");\n    }\n    // ===========================\n    // ✅ PANTALLA: top por porcentaje\n    // ===========================\n    const ALTURA_EDITOR_PANTALLA = 500;\n    // ✅ Offsets en secciones Pantalla: ON\n    // ⚠️ IMPORTANTE: este archivo SOLO genera objetos.\n    // El valor DESKTOP/MOBILE real se controla vía CSS global con:\n    //   :root { --pantalla-y-offset: Xpx }\n    //   @media (max-width: 640px) { :root { --pantalla-y-offset: Ypx } }\n    //\n    // Acá dejamos fallback (desktop) por si la variable CSS no existe.\n    const PANTALLA_Y_OFFSET_DESKTOP_PX = 0;\n    function clamp01(n) {\n        const x = Number(n);\n        if (!Number.isFinite(x)) return null;\n        return Math.max(0, Math.min(1, x));\n    }\n    function getYPxEditor(obj) {\n        // ✅ En Pantalla ON: yNorm es la fuente de verdad (0..1)\n        const yn = clamp01(obj === null || obj === void 0 ? void 0 : obj.yNorm);\n        if (yn != null) return yn * ALTURA_EDITOR_PANTALLA;\n        // fallback: si no hay yNorm, usamos y como \"editor px\"\n        const yPx = Number(obj === null || obj === void 0 ? void 0 : obj.y);\n        if (Number.isFinite(yPx)) return yPx;\n        return 0;\n    }\n    function topPantallaCSS(obj, ynRaw) {\n        var _clamp01;\n        const yn = (_clamp01 = clamp01(ynRaw)) !== null && _clamp01 !== void 0 ? _clamp01 : 0;\n        const yBloqueDisenio = \"calc(\".concat(sContenidoVar(obj), \" * \").concat(ALTURA_EDITOR_PANTALLA, \"px)\");\n        const yBasePantalla = \"var(--pantalla-y-base, 0px)\";\n        const ynCompactado = \"calc(0.5 + ((\".concat(yn, \") - 0.5) * (1 - var(--pantalla-y-compact, 0)))\");\n        return \"calc(\\n  \".concat(yBasePantalla, \"\\n  + (\").concat(yBloqueDisenio, \" * \").concat(ynCompactado, \")\\n  + (\").concat(sContenidoVar(obj), \" * var(--pantalla-y-offset, \").concat(PANTALLA_Y_OFFSET_DESKTOP_PX, \"px))\\n)\");\n    }\n    /**\n   * ✅ topCSS:\n   * - Pantalla ON: usa bloque de diseño escalado (500px * sfinal) + offset base uniforme\n   * - Texto en Pantalla ON: suma offset (CSS var) escalado por sContenidoVar\n   * - Fijo: pxY(obj, y)\n   */ function topCSS(obj) {\n        if (esSeccionPantalla(obj)) {\n            const yPxEditor = getYPxEditor(obj);\n            var _clamp01;\n            const yn = (_clamp01 = clamp01(yPxEditor / ALTURA_EDITOR_PANTALLA)) !== null && _clamp01 !== void 0 ? _clamp01 : 0;\n            return topPantallaCSS(obj, yn);\n        }\n        const y = Number((obj === null || obj === void 0 ? void 0 : obj.y) || 0);\n        return pxY(obj, y);\n    }\n    /**\r\n   * ✅ Variante para cuando ya tenés yPx (en \"px editor\")\r\n   */ function topCSSFromYPx(obj, yPx) {\n        if (esSeccionPantalla(obj)) {\n            var _clamp01;\n            const yn = (_clamp01 = clamp01(yPx / ALTURA_EDITOR_PANTALLA)) !== null && _clamp01 !== void 0 ? _clamp01 : 0;\n            return topPantallaCSS(obj, yn);\n        }\n        return pxY(obj, yPx);\n    }\n    function stylePosBase(obj) {\n        const x = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0);\n        var _obj_rotation;\n        const rot = (_obj_rotation = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation !== void 0 ? _obj_rotation : 0;\n        var _obj_scaleX;\n        const scaleX = (_obj_scaleX = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX !== void 0 ? _obj_scaleX : 1;\n        var _obj_scaleY;\n        const scaleY = (_obj_scaleY = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY !== void 0 ? _obj_scaleY : 1;\n        const zIndex = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.zIndex) ? obj.zIndex : undefined;\n        return \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, x), \";\\ntop: \").concat(topCSS(obj), \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: top left;\\n\").concat(zIndex !== undefined ? \"z-index:\".concat(zIndex, \";\") : \"\", \"\\npointer-events: auto;\\n\").trim();\n    }\n    function styleSize(obj, w, h) {\n        const ww = Number.isFinite(w) ? w : undefined;\n        const hh = Number.isFinite(h) ? h : undefined;\n        const parts = [];\n        if (ww !== undefined) parts.push(\"width: \".concat(pxX(obj, ww), \";\"));\n        if (hh !== undefined) parts.push(\"height: \".concat(pxY(obj, hh), \";\"));\n        return parts.join(\"\\n\");\n    }\n    function renderIconoSvgNuevoInline(obj) {\n        const viewBox = obj.viewBox || \"0 0 24 24\";\n        const color = obj.color || \"#000\";\n        const paths = Array.isArray(obj.paths) ? obj.paths : [];\n        if (!paths.length) return \"\";\n        const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : 24;\n        const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : 24;\n        var _obj_rotation;\n        const rot = (_obj_rotation = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation !== void 0 ? _obj_rotation : 0;\n        var _obj_scaleX;\n        const scaleX = (_obj_scaleX = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX !== void 0 ? _obj_scaleX : 1;\n        var _obj_scaleY;\n        const scaleY = (_obj_scaleY = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY !== void 0 ? _obj_scaleY : 1;\n        const x = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0);\n        const yPx = getYPxEditor(obj);\n        const pathsHtml = paths.map((p)=>(p === null || p === void 0 ? void 0 : p.d) ? '<path d=\"'.concat(escHTML(p.d), '\" fill=\"').concat(escHTML(color), '\"></path>') : \"\").join(\"\");\n        const style = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, x), \";\\ntop: \").concat(topCSSFromYPx(obj, yPx), \";\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: top left;\\npointer-events: auto;\\n\").trim();\n        return '<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"'.concat(escHTML(viewBox), '\" style=\"').concat(style, '\">').concat(pathsHtml, \"</svg>\");\n    }\n    return objetos.map((obj)=>{\n        const tipo = obj === null || obj === void 0 ? void 0 : obj.tipo;\n        // ---------------- TEXTO ----------------\n        if (tipo === \"texto\") {\n            const align = String(obj.align || obj.textAlign || \"left\").toLowerCase();\n            const color = obj.colorTexto || obj.color || obj.fill || \"#000\";\n            const baseLineHeight = typeof obj.lineHeight === \"number\" && obj.lineHeight > 0 ? obj.lineHeight : 1.2;\n            const lineHeightFinal = baseLineHeight * 0.92;\n            const safeTexto = escHTML(obj.texto || \"\");\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const fs = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.fontSize) ? obj.fontSize : 24;\n            // ⚠️ texto fullBleed NO hace fit => escala con var(--sx)\n            const sFont = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            var _obj_rotation;\n            const rot = (_obj_rotation = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation !== void 0 ? _obj_rotation : 0;\n            var _obj_scaleX;\n            const scaleX = (_obj_scaleX = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX !== void 0 ? _obj_scaleX : 1;\n            var _obj_scaleY;\n            const scaleY = (_obj_scaleY = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY !== void 0 ? _obj_scaleY : 1;\n            const origin = align === \"center\" ? \"top center\" : align === \"right\" ? \"top right\" : \"top left\";\n            const style = \"\\n\".concat(baseStyle, \"\\n/* ✅ mantener geometr\\xeda estable y escalar tipograf\\xeda por font-size (no por transform). */\\ntransform-origin: \").concat(origin, \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\n\").concat(w !== undefined ? \"width: \".concat(pxX(obj, w), \";\") : \"\", \"\\nfont-size: calc(\").concat(sFont, \" * \").concat(fs, \"px * var(--text-zoom, 1));\\nfont-family: \").concat(obj.fontFamily || \"sans-serif\", \";\\nfont-weight: \").concat(obj.fontWeight || \"normal\", \";\\nfont-style: \").concat(obj.fontStyle || \"normal\", \";\\ntext-decoration: \").concat(obj.textDecoration || \"none\", \";\\ncolor: \").concat(color, \";\\ntext-align: \").concat(align, \";\\nwhite-space: pre-wrap;\\nline-height: \").concat(lineHeightFinal, \";\\npadding: 0;\\nmargin: 0;\\nbox-sizing: content-box;\\n\").concat(obj.stroke && obj.strokeWidth > 0 ? \"-webkit-text-stroke: \".concat(obj.strokeWidth, \"px \").concat(obj.stroke, \";\") : \"\", \"\\n\").concat(obj.shadowColor ? \"text-shadow: \".concat(obj.shadowOffsetX || 0, \"px \").concat(obj.shadowOffsetY || 0, \"px \").concat(obj.shadowBlur || 0, \"px \").concat(obj.shadowColor, \";\") : \"text-shadow: none;\", \"\\n\").trim();\n            return envolverSiEnlace('<div class=\"objeto\" data-debug-texto=\"1\" style=\"'.concat(style, '\">').concat(safeTexto, \"</div>\"), obj);\n        }\n        // ---------------- IMAGEN ----------------\n        if (tipo === \"imagen\") {\n            const src = obj.src || obj.url || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : undefined;\n            const style = \"\\n\".concat(baseStyle, \"\\n\").concat(styleSize(obj, w, h), \"\\nobject-fit: contain;\\ndisplay: block;\\n\").trim();\n            return envolverSiEnlace('<img class=\"objeto\" src=\"'.concat(escapeAttr(src), '\" style=\"').concat(style, '\" />'), obj);\n        }\n        // ---------------- ICONO (nuevo) ----------------\n        if (tipo === \"icono\") {\n            if (obj.formato === \"svg\") {\n                const svgHtml = renderIconoSvgNuevoInline(obj);\n                if (!svgHtml) return \"\";\n                return envolverSiEnlace(svgHtml, obj);\n            }\n            const src = obj.url || obj.src || \"\";\n            if (!src) return \"\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : undefined;\n            const style = \"\\n\".concat(baseStyle, \"\\n\").concat(styleSize(obj, w, h), \"\\nobject-fit: contain;\\ndisplay: block;\\n\").trim();\n            return envolverSiEnlace('<img class=\"objeto\" src=\"'.concat(escapeAttr(src), '\" style=\"').concat(style, '\" />'), obj);\n        }\n        // ---------------- ICONO LEGACY (icono-svg) ----------------\n        if (tipo === \"icono-svg\" && obj.d) {\n            const vb = obj.viewBox || \"0 0 100 100\";\n            const fill = obj.color || \"#000\";\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : 100;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : 100;\n            const style = \"\\n\".concat(baseStyle, \"\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\nfill: \").concat(escapeAttr(fill), \";\\n\").trim();\n            const svg = '<svg class=\"objeto\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"'.concat(escapeAttr(vb), '\" style=\"').concat(style, '\"><path d=\"').concat(escHTML(obj.d), '\" /></svg>');\n            return envolverSiEnlace(svg, obj);\n        }\n        // ---------------- COUNTDOWN ----------------\n        if (tipo === \"countdown\") {\n            const targetISO = obj.targetISO || obj.fechaObjetivo || obj.fechaISO || \"\";\n            var _obj_colorTexto, _ref;\n            const textColor = (_ref = (_obj_colorTexto = obj.colorTexto) !== null && _obj_colorTexto !== void 0 ? _obj_colorTexto : obj.color) !== null && _ref !== void 0 ? _ref : \"#111\";\n            const fontFamily = obj.fontFamily || \"Inter, system-ui, sans-serif\";\n            const preset = obj.presetId || obj.layout || \"pills\";\n            const isMinimal = String(preset).toLowerCase().includes(\"minimal\");\n            // ✅ ancho/alto del objeto (si existen)\n            const wObj = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? Number(obj.width) : null;\n            const hObj = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? Number(obj.height) : null;\n            // ✅ gap: si viene de Konva, respetarlo\n            const gap = Number.isFinite(obj.gap) ? Number(obj.gap) : Number.isFinite(obj.spacing) ? Number(obj.spacing) : 8;\n            // ✅ Si tu Konva guarda chipWidth / paddingX, respetalos\n            // chipWidth: ancho interno del texto (sin padding)\n            const chipWidthProp = Number.isFinite(obj.chipWidth) ? Number(obj.chipWidth) : null;\n            const paddingXProp = Number.isFinite(obj.paddingX) ? Number(obj.paddingX) : null;\n            // ✅ Derivación raíz (cuando no hay props)\n            const n = 4;\n            // chipWTotal: ancho total de cada chip (incluye padding)\n            let chipWTotal = 56; // fallback razonable\n            if (wObj && wObj > 0) {\n                chipWTotal = Math.max(40, (wObj - gap * (n - 1)) / n);\n            }\n            // paddingX derivado del chipWTotal (si no vino)\n            const paddingX = paddingXProp !== null && paddingXProp !== void 0 ? paddingXProp : Math.max(6, Math.round(chipWTotal * 0.18)); // ~18%\n            const paddingY = Math.max(5, Math.round(paddingX * 0.65));\n            // chipWidth (texto) derivado si no vino\n            const chipWidth = chipWidthProp !== null && chipWidthProp !== void 0 ? chipWidthProp : Math.max(10, Math.round(chipWTotal - paddingX * 2));\n            // ✅ font sizes: si vienen, respetar; si no, derivar desde chipWTotal\n            const valueSize = Number.isFinite(obj.fontSize) ? Number(obj.fontSize) : Math.max(14, Math.round(chipWTotal * 0.34));\n            const labelSize = Number.isFinite(obj.labelSize) ? Number(obj.labelSize) : Math.max(9, Math.round(valueSize * 0.62));\n            var _obj_labelColor;\n            const labelColor = (_obj_labelColor = obj.labelColor) !== null && _obj_labelColor !== void 0 ? _obj_labelColor : \"#6b7280\";\n            const fontWeight = Number.isFinite(obj.fontWeight) ? obj.fontWeight : 700;\n            const letterSpacing = Number.isFinite(obj.letterSpacing) ? obj.letterSpacing : 0;\n            // ✅ estilos de chip\n            const containerBgFinal = \"transparent\";\n            var _obj_chipBackground, _ref1;\n            const chipBgFinal = isMinimal ? \"transparent\" : (_ref1 = (_obj_chipBackground = obj.chipBackground) !== null && _obj_chipBackground !== void 0 ? _obj_chipBackground : obj.boxBg) !== null && _ref1 !== void 0 ? _ref1 : \"rgba(255,255,255,.75)\";\n            var _obj_chipBorder, _ref2;\n            const chipBorderColorFinal = isMinimal ? \"transparent\" : (_ref2 = (_obj_chipBorder = obj.chipBorder) !== null && _obj_chipBorder !== void 0 ? _obj_chipBorder : obj.boxBorder) !== null && _ref2 !== void 0 ? _ref2 : \"rgba(0,0,0,.08)\";\n            const containerRadius = Number.isFinite(obj.boxRadius) ? obj.boxRadius : Number.isFinite(obj.radius) ? obj.radius : 10;\n            const chipRadiusFinal = Number.isFinite(obj.chipRadius) ? obj.chipRadius : containerRadius;\n            const baseStyle = stylePosBase(obj);\n            // ✅ Escala correcta (respeta pantalla y bleed)\n            const sChip = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const containerStyle = \"\\n\".concat(baseStyle, \"\\n\").concat(wObj ? \"width: \".concat(pxX(obj, wObj), \";\") : \"\", \"\\n\").concat(hObj ? \"height: \".concat(pxY(obj, hObj), \";\") : \"\", \"\\ndisplay: flex;\\nalign-items: center;\\njustify-content: center;\\ngap: calc(\").concat(sChip, \" * \").concat(gap, \"px);\\nfont-family: \").concat(fontFamily, \";\\ncolor: \").concat(textColor, \";\\nbackground: \").concat(containerBgFinal, \";\\nborder-radius: calc(\").concat(sChip, \" * \").concat(containerRadius, \"px);\\nletter-spacing: calc(\").concat(sChip, \" * \").concat(letterSpacing, \"px);\\n\").trim();\n            const chipStyle = \"\\nwidth: calc(\".concat(sChip, \" * \").concat(Math.round(chipWTotal), \"px);\\npadding: calc(\").concat(sChip, \" * \").concat(paddingY, \"px) calc(\").concat(sChip, \" * \").concat(paddingX, \"px);\\nborder: \").concat(isMinimal ? \"0\" : \"calc(\".concat(sChip, \" * 1px) solid \").concat(chipBorderColorFinal), \";\\nborder-radius: calc(\").concat(sChip, \" * \").concat(chipRadiusFinal, \"px);\\ndisplay: flex;\\nflex-direction: column;\\nalign-items: center;\\njustify-content: center;\\nbackground: \").concat(chipBgFinal, \";\\nbox-sizing: border-box;\\n\").trim();\n            const valueStyle = \"\\nfont-weight: \".concat(fontWeight, \";\\nfont-size: calc(\").concat(sChip, \" * \").concat(valueSize, \"px);\\nline-height: 1;\\n\").trim();\n            const labelStyle = \"\\nfont-size: calc(\".concat(sChip, \" * \").concat(labelSize, \"px);\\ncolor: \").concat(labelColor, \";\\nline-height: 1.05;\\n\").trim();\n            const showLabels = obj.showLabels !== false;\n            var _obj_labels;\n            const labels = (_obj_labels = obj.labels) !== null && _obj_labels !== void 0 ? _obj_labels : {\n                dias: \"Días\",\n                horas: \"Horas\",\n                min: \"Min\",\n                seg: \"Seg\"\n            };\n            const htmlCountdown = '\\n<div class=\"objeto\"\\n  data-mobile-cluster=\"isolated\"\\n  data-mobile-center=\"force\"\\n  data-countdown\\n  data-target=\"'.concat(escapeAttr(targetISO), '\"\\n  data-preset=\"').concat(escapeAttr(preset), '\" style=\"').concat(containerStyle, '\">\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.dias), \"</span>\") : \"\", '\\n  </div>\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.horas), \"</span>\") : \"\", '\\n  </div>\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.min), \"</span>\") : \"\", '\\n  </div>\\n  <div class=\"cd-chip\" style=\"').concat(chipStyle, '\">\\n    <span class=\"cd-val\" style=\"').concat(valueStyle, '\">00</span>\\n    ').concat(showLabels ? '<span class=\"cd-lab\" style=\"'.concat(labelStyle, '\">').concat(escapeAttr(labels.seg), \"</span>\") : \"\", \"\\n  </div>\\n</div>\\n\").trim();\n            return appendMotionDataAttrs(htmlCountdown, obj);\n        }\n        // ---------------- GALERÍA ----------------\n        if (tipo === \"galeria\") {\n            const rows = Math.max(1, parseInt(obj.rows || 1, 10));\n            const cols = Math.max(1, parseInt(obj.cols || 1, 10));\n            const gapPx = Math.max(0, parseInt(obj.gap || 0, 10));\n            const radiusPx = Math.max(0, parseInt(obj.radius || 0, 10));\n            const baseStyle = stylePosBase(obj);\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : undefined;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : undefined;\n            const sGrid = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const styleContenedor = \"\\n\".concat(baseStyle, \"\\n\").concat(styleSize(obj, w, h), \"\\ndisplay: grid;\\ngrid-template-columns: repeat(\").concat(cols, \", 1fr);\\ngrid-template-rows: repeat(\").concat(rows, \", 1fr);\\ngap: calc(\").concat(sGrid, \" * \").concat(gapPx, \"px);\\nbox-sizing: border-box;\\n\").trim();\n            const total = rows * cols;\n            const cells = Array.from({\n                length: total\n            }, (_, i)=>{\n                const c = obj.cells && obj.cells[i] || {};\n                return {\n                    mediaUrl: c.mediaUrl || \"\",\n                    fit: c.fit === \"contain\" ? \"contain\" : \"cover\",\n                    bg: c.bg || \"#f3f4f6\"\n                };\n            });\n            const htmlCeldas = cells.map((cell, idx)=>{\n                const safeSrc = escapeAttr(cell.mediaUrl || \"\");\n                const celdaStyle = \"\\nposition: relative;\\nwidth: 100%;\\nheight: 100%;\\noverflow: hidden;\\nborder-radius: calc(\".concat(sGrid, \" * \").concat(radiusPx, \"px);\\nbackground: \").concat(cell.bg, \";\\n\").trim();\n                if (!safeSrc) {\n                    return '<div class=\"galeria-celda\" data-index=\"'.concat(idx, '\" style=\"').concat(celdaStyle, '\"></div>');\n                }\n                return '\\n<div class=\"galeria-celda galeria-celda--clickable\"\\n     data-index=\"'.concat(idx, '\"\\n     data-gallery-image=\"1\"\\n     role=\"button\"\\n     tabindex=\"0\"\\n     aria-label=\"Ver imagen en pantalla completa\"\\n     style=\"').concat(celdaStyle, '\">\\n  <img src=\"').concat(safeSrc, '\" alt=\"\" loading=\"lazy\" decoding=\"async\"\\n       style=\"width:100%;height:100%;object-fit:').concat(cell.fit, ';display:block;\" />\\n</div>\\n').trim();\n            }).join(\"\");\n            const htmlGaleria = '<div class=\"objeto galeria\" style=\"'.concat(styleContenedor, '\">').concat(htmlCeldas, \"</div>\");\n            return envolverSiEnlace(htmlGaleria, obj);\n        }\n        // ---------------- RSVP BOTÓN ----------------\n        if (tipo === \"rsvp-boton\") {\n            const texto = escapeHTML(obj.texto || \"Confirmar asistencia\");\n            const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.ancho) ? obj.ancho : 200;\n            const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.alto) ? obj.alto : 50;\n            const color = obj.color || \"#773dbe\";\n            const colorTexto = obj.colorTexto || \"#ffffff\";\n            const fontSize = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.fontSize) ? obj.fontSize : 18;\n            const fontFamily = obj.fontFamily || \"sans-serif\";\n            const fontWeight = obj.fontWeight || \"bold\";\n            const fontStyle = obj.fontStyle || \"normal\";\n            const textDecoration = obj.textDecoration || \"none\";\n            const align = obj.align || \"center\";\n            const baseStyle = stylePosBase(obj);\n            // RSVP (contenido): si está en pantalla, fittea (sContenidoVar)\n            const sBtn = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n            const style = \"\\n\".concat(baseStyle, \"\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\nbackground-color: \").concat(color, \";\\ncolor: \").concat(colorTexto, \";\\nfont-size: calc(\").concat(sBtn, \" * \").concat(fontSize, \"px);\\nfont-family: \").concat(fontFamily, \";\\nfont-weight: \").concat(fontWeight, \";\\nfont-style: \").concat(fontStyle, \";\\ntext-decoration: \").concat(textDecoration, \";\\ntext-align: \").concat(align, \";\\ndisplay: flex;\\nalign-items: center;\\njustify-content: center;\\nborder-radius: calc(\").concat(sBtn, \" * 8px);\\ncursor: pointer;\\n\").trim();\n            const htmlRsvp = '\\n<div class=\"objeto is-interactive rsvp-boton\"\\n  id=\"abrirModalRSVP\"\\n  data-accion=\"abrir-rsvp\"\\n  data-rsvp-open\\n  role=\"button\"\\n  tabindex=\"0\"\\n  aria-label=\"Confirmar asistencia\"\\n  style=\"'.concat(style, '\">\\n  ').concat(texto, \"\\n</div>\\n\").trim();\n            return appendMotionDataAttrs(htmlRsvp, obj);\n        }\n        // ---------------- FORMAS ----------------\n        if (tipo === \"forma\") {\n            const fill = obj.color || \"#000\";\n            const figura = obj.figura;\n            if (figura === \"rect\") {\n                const w = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.width) ? obj.width : 100;\n                const h = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.height) ? obj.height : 100;\n                const cornerRadius = obj.cornerRadius || 0;\n                const fontSize = obj.fontSize || 24;\n                const fontFamily = obj.fontFamily || \"sans-serif\";\n                const fontWeight = obj.fontWeight || \"normal\";\n                const fontStyle = obj.fontStyle || \"normal\";\n                const textDecoration = obj.textDecoration || \"none\";\n                const align = obj.align || \"center\";\n                const colorTexto = obj.colorTexto || \"#000000\";\n                const texto = escHTML(obj.texto || \"\");\n                const baseStyle = stylePosBase(obj);\n                const sRectText = isFullBleed(obj) ? \"var(--sx)\" : sContenidoVar(obj);\n                const style = \"\\n\".concat(baseStyle, \"\\nwidth: \").concat(pxX(obj, w), \";\\nheight: \").concat(pxY(obj, h), \";\\nbackground: \").concat(fill, \";\\nborder-radius: calc(\").concat(sRectText, \" * \").concat(cornerRadius, \"px);\\ndisplay: flex;\\nalign-items: center;\\njustify-content: \").concat(align === \"left\" ? \"flex-start\" : align === \"right\" ? \"flex-end\" : \"center\", \";\\ntext-align: \").concat(align, \";\\npadding: calc(\").concat(sRectText, \" * 4px);\\nbox-sizing: border-box;\\n\").trim();\n                const inner = '\\n<div style=\"\\n  width: 100%;\\n  font-size: calc('.concat(sRectText, \" * \").concat(fontSize, \"px);\\n  font-family: \").concat(fontFamily, \";\\n  font-weight: \").concat(fontWeight, \";\\n  font-style: \").concat(fontStyle, \";\\n  text-decoration: \").concat(textDecoration, \";\\n  color: \").concat(colorTexto, ';\\n  line-height: 1.2;\\n  white-space: pre-wrap;\\n  word-break: break-word;\\n\">').concat(texto, \"</div>\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto\" style=\"'.concat(style, '\">').concat(inner, \"</div>\"), obj);\n            }\n            if (figura === \"circle\") {\n                const radius = Number.isFinite(obj === null || obj === void 0 ? void 0 : obj.radius) ? obj.radius : 50;\n                const diameter = radius * 2;\n                const x = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0) - radius;\n                const yPxCenter = getYPxEditor(obj);\n                const yPxTopLeft = yPxCenter - radius;\n                var _obj_rotation1;\n                const rot = (_obj_rotation1 = obj === null || obj === void 0 ? void 0 : obj.rotation) !== null && _obj_rotation1 !== void 0 ? _obj_rotation1 : 0;\n                var _obj_scaleX1;\n                const scaleX = (_obj_scaleX1 = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX1 !== void 0 ? _obj_scaleX1 : 1;\n                var _obj_scaleY1;\n                const scaleY = (_obj_scaleY1 = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY1 !== void 0 ? _obj_scaleY1 : 1;\n                const style = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, x), \";\\ntop: \").concat(topCSSFromYPx(obj, yPxTopLeft), \";\\nwidth: \").concat(pxX(obj, diameter), \";\\nheight: \").concat(pxY(obj, diameter), \";\\nborder-radius: 50%;\\nbackground: \").concat(fill, \";\\ntransform: rotate(\").concat(rot, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: center center;\\npointer-events: auto;\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto\" style=\"'.concat(style, '\"></div>'), obj);\n            }\n            if (figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH,\n                    0\n                ];\n                const x1 = parseFloat(points[0]) || 0;\n                const y1 = parseFloat(points[1]) || 0;\n                const x2 = parseFloat(points[2]) || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.DEFAULT_LENGTH;\n                const y2 = parseFloat(points[3]) || 0;\n                const strokeWidth = obj.strokeWidth || _models_lineConstants__WEBPACK_IMPORTED_MODULE_0__.LINE_CONSTANTS.STROKE_WIDTH;\n                const deltaX = x2 - x1;\n                const deltaY = y2 - y1;\n                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n                const startX = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0) + x1;\n                const baseY = getYPxEditor(obj);\n                const startY = baseY + y1;\n                const totalRotation = angle + (obj.rotation || 0);\n                var _obj_scaleX2;\n                const scaleX = (_obj_scaleX2 = obj === null || obj === void 0 ? void 0 : obj.scaleX) !== null && _obj_scaleX2 !== void 0 ? _obj_scaleX2 : 1;\n                var _obj_scaleY2;\n                const scaleY = (_obj_scaleY2 = obj === null || obj === void 0 ? void 0 : obj.scaleY) !== null && _obj_scaleY2 !== void 0 ? _obj_scaleY2 : 1;\n                // alto de línea: usamos escala Y del objeto (contenido: sfinal/sx, bleed: sx)\n                const lineH = \"calc(\".concat(sY(obj), \" * \").concat(strokeWidth, \"px)\");\n                const style = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, startX), \";\\ntop: \").concat(topCSSFromYPx(obj, startY), \";\\nwidth: \").concat(pxX(obj, length), \";\\nheight: \").concat(lineH, \";\\nbackground: \").concat(fill, \";\\ntransform: rotate(\").concat(totalRotation, \"deg) scale(\").concat(scaleX, \", \").concat(scaleY, \");\\ntransform-origin: 0 50%;\\npointer-events: auto;\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto linea\" style=\"'.concat(style, '\"></div>'), obj);\n            }\n            if (figura === \"triangle\") {\n                const radius = obj.radius || 60;\n                const sin60 = Math.sqrt(3) / 2;\n                const cos60 = 0.5;\n                const triangleWidth = 2 * radius * sin60;\n                const triangleHeight = radius * (1 + cos60);\n                const centroidOffsetY = triangleHeight / 3;\n                const baseY = getYPxEditor(obj);\n                const topContainerPx = baseY - (triangleHeight - centroidOffsetY);\n                const leftContainer = Number((obj === null || obj === void 0 ? void 0 : obj.x) || 0) - triangleWidth / 2;\n                var _obj_rotation2, _obj_scaleX3, _obj_scaleY3;\n                const baseStyle = \"\\nposition: absolute;\\nleft: \".concat(pxX(obj, leftContainer), \";\\ntop: \").concat(topCSSFromYPx(obj, topContainerPx), \";\\nwidth: \").concat(pxX(obj, triangleWidth), \";\\nheight: \").concat(pxY(obj, triangleHeight), \";\\nbackground: \").concat(fill, \";\\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%);\\ntransform: rotate(\").concat((_obj_rotation2 = obj.rotation) !== null && _obj_rotation2 !== void 0 ? _obj_rotation2 : 0, \"deg) scale(\").concat((_obj_scaleX3 = obj.scaleX) !== null && _obj_scaleX3 !== void 0 ? _obj_scaleX3 : 1, \", \").concat((_obj_scaleY3 = obj.scaleY) !== null && _obj_scaleY3 !== void 0 ? _obj_scaleY3 : 1, \");\\ntransform-origin: center center;\\npointer-events: auto;\\n\").trim();\n                return envolverSiEnlace('<div class=\"objeto\" style=\"'.concat(baseStyle, '\"></div>'), obj);\n            }\n            return \"\";\n        }\n        return \"\";\n    }).join(\"\\n\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBRXpELG9EQUFvRDtBQUNwRCxTQUFTQztRQUFRQyxNQUFBQSxpRUFBVztJQUMxQixPQUFPQyxPQUFPRCxLQUNYRSxPQUFPLENBQUMsTUFBTSxTQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTSxVQUNkQSxPQUFPLENBQUMsTUFBTTtBQUNuQjtBQUVBLFNBQVNDO1FBQVdILE1BQUFBLGlFQUFjO0lBQ2hDLE9BQU9DLE9BQU9ELEtBQ1hFLE9BQU8sQ0FBQyxNQUFNLFNBQ2RBLE9BQU8sQ0FBQyxNQUFNLFVBQ2RBLE9BQU8sQ0FBQyxNQUFNLFFBQ2RBLE9BQU8sQ0FBQyxNQUFNO0FBQ25CO0FBRUEsTUFBTUUsdUJBQXVCLElBQUlDLElBQUk7SUFBQztJQUFRO0lBQVU7SUFBUTtJQUFRO0lBQVM7Q0FBUTtBQUV6RixTQUFTQyxxQkFBcUJDLEtBQVU7SUFDdEMsTUFBTUMsYUFBYVAsT0FBT00sU0FBUyxJQUFJRSxJQUFJLEdBQUdDLFdBQVc7SUFDekQsT0FBT04scUJBQXFCTyxHQUFHLENBQUNILGNBQWNBLGFBQWE7QUFDN0Q7QUFFQSxTQUFTSSxtQkFBbUJMLEtBQVU7SUFDcEMsT0FBT04sT0FBT00sU0FBUyxJQUFJRSxJQUFJLEdBQUdDLFdBQVc7QUFDL0M7QUFFQSxTQUFTRyxpQkFBaUJDLEdBQVE7SUFDaEMsTUFBTUMsT0FBT0gsbUJBQW1CRSxnQkFBQUEsMEJBQUFBLElBQUtDLElBQUk7SUFDekMsTUFBTUMsU0FBU0osbUJBQW1CRSxnQkFBQUEsMEJBQUFBLElBQUtFLE1BQU07SUFFN0MsSUFBSUQsU0FBUyxXQUFXQSxTQUFTLFFBQVEsT0FBTztJQUNoRCxJQUFJQSxTQUFTLFlBQVlBLFNBQVMsU0FBUyxPQUFPO0lBQ2xELElBQUlB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QkFBQUEsSUFBSTBFLFFBQVEsY0FBWjFFLDRCQUFBQSxpQkFBZ0IsR0FBRSxlQUFpQ0EsT0FBcEJBLENBQUFBLGVBQUFBLElBQUkyRSxNQUFNLGNBQVYzRSwwQkFBQUEsZUFBYyxHQUFFLE1BQW9CLE9BQWhCQSxDQUFBQSxlQUFBQSxJQUFJNEUsTUFBTSxjQUFWNUUsMEJBQUFBLGVBQWMsR0FBRSxpRUFHckZMLElBQUk7Z0JBRUksT0FBTzhCLGlCQUFpQiw4QkFBd0MsT0FBVm1GLFdBQVUsYUFBVzVHO1lBQzdFO1lBRUEsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNULEdBQ0NzRixJQUFJLENBQUM7QUFDViIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxnZW5lcmFySFRNTERlc2RlT2JqZXRvcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMSU5FX0NPTlNUQU5UUyB9IGZyb20gXCIuLi9tb2RlbHMvbGluZUNvbnN0YW50c1wiO1xyXG5cclxuLy8g4pyFIEVzY2FwYXIgc3RyaW5ncyBwYXJhIG1ldGVybG9zIGVuIGF0cmlidXRvcy9IVE1MXHJcbmZ1bmN0aW9uIGVzY0hUTUwoc3RyOiBhbnkgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gU3RyaW5nKHN0cilcclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxyXG4gICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcclxuICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHN0cjogc3RyaW5nID0gXCJcIik6IHN0cmluZyB7XG4gIHJldHVybiBTdHJpbmcoc3RyKVxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG59XG5cbmNvbnN0IE1PVElPTl9FRkZFQ1RfVkFMVUVTID0gbmV3IFNldChbXCJub25lXCIsIFwicmV2ZWFsXCIsIFwiZHJhd1wiLCBcInpvb21cIiwgXCJob3ZlclwiLCBcInB1bHNlXCJdKTtcblxuZnVuY3Rpb24gc2FuaXRpemVNb3Rpb25FZmZlY3QodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBTdHJpbmcodmFsdWUgfHwgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBNT1RJT05fRUZGRUNUX1ZBTFVFUy5oYXMobm9ybWFsaXplZCkgPyBub3JtYWxpemVkIDogXCJub25lXCI7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvbGVWYWx1ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSB8fCBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbWFwT2JqVG9EYXRhVHlwZShvYmo6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IHRpcG8gPSBub3JtYWxpemVSb2xlVmFsdWUob2JqPy50aXBvKTtcbiAgY29uc3QgZmlndXJhID0gbm9ybWFsaXplUm9sZVZhbHVlKG9iaj8uZmlndXJhKTtcblxuICBpZiAodGlwbyA9PT0gXCJ0ZXh0b1wiIHx8IHRpcG8gPT09IFwidGV4dFwiKSByZXR1cm4gXCJ0ZXh0XCI7XG4gIGlmICh0aXBvID09PSBcImltYWdlblwiIHx8IHRpcG8gPT09IFwiaW1hZ2VcIikgcmV0dXJuIFwiaW1hZ2VcIjtcbiAgaWYgKHRpcG8gPT09IFwiaWNvbm9cIiB8fCB0aXBvID09PSBcImljb25vLXN2Z1wiIHx8IHRpcG8gPT09IFwiaWNvblwiKSByZXR1cm4gXCJpY29uXCI7XG4gIGlmICh0aXBvID09PSBcImdhbGVyaWFcIiB8fCB0aXBvID09PSBcImdhbGxlcnlcIikgcmV0dXJuIFwiZ2FsbGVyeVwiO1xuICBpZiAodGlwbyA9PT0gXCJjb3VudGRvd25cIikgcmV0dXJuIFwiY291bnRkb3duXCI7XG4gIGlmICh0aXBvID09PSBcInJzdnAtYm90b25cIiB8fCB0aXBvID09PSBcInJzdnBcIikgcmV0dXJuIFwicnN2cFwiO1xuICBpZiAodGlwbyA9PT0gXCJidXR0b25cIiB8fCB0aXBvID09PSBcImJvdG9uXCIpIHJldHVybiBcImJ1dHRvblwiO1xuICBpZiAodGlwbyA9PT0gXCJsaW5lXCIgfHwgdGlwbyA9PT0gXCJkaXZpZGVyXCIpIHJldHVybiBcImRpdmlkZXJcIjtcbiAgaWYgKHRpcG8gPT09IFwiZm9ybWFcIiAmJiBmaWd1cmEgPT09IFwibGluZVwiKSByZXR1cm4gXCJkaXZpZGVyXCI7XG4gIGlmICh0aXBvID09PSBcImZvcm1hXCIpIHJldHVybiBcInNoYXBlXCI7XG5cbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuXG5mdW5jdGlvbiBpbmZlckRhdGFSb2xlKG9iajogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgZXhwbGljaXRSb2xlID0gbm9ybWFsaXplUm9sZVZhbHVlKG9iaj8ucm9sZSB8fCBvYmo/LnJvbCk7XG4gIGlmIChleHBsaWNpdFJvbGUpIHJldHVybiBleHBsaWNpdFJvbGU7XG5cbiAgY29uc3QgdHlwZSA9IG1hcE9ialRvRGF0YVR5cGUob2JqKTtcbiAgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSBOdW1iZXIob2JqPy5mb250U2l6ZSk7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmb250U2l6ZSkgJiYgZm9udFNpemUgPj0gMzApIHJldHVybiBcInRpdGxlXCI7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmb250U2l6ZSkgJiYgZm9udFNpemUgPj0gMjIpIHJldHVybiBcInN1YnRpdGxlXCI7XG4gICAgcmV0dXJuIFwiYm9keVwiO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFwiZGl2aWRlclwiKSByZXR1cm4gXCJkaXZpZGVyXCI7XG4gIGlmICh0eXBlID09PSBcImltYWdlXCIpIHJldHVybiBcImltYWdlXCI7XG4gIGlmICh0eXBlID09PSBcImljb25cIikgcmV0dXJuIFwiaWNvblwiO1xuICBpZiAodHlwZSA9PT0gXCJnYWxsZXJ5XCIpIHJldHVybiBcImdhbGxlcnlcIjtcbiAgaWYgKHR5cGUgPT09IFwiY291bnRkb3duXCIpIHJldHVybiBcImNvdW50ZG93blwiO1xuICBpZiAodHlwZSA9PT0gXCJyc3ZwXCIgfHwgdHlwZSA9PT0gXCJidXR0b25cIikgcmV0dXJuIFwiY3RhXCI7XG4gIGlmICh0eXBlID09PSBcInNoYXBlXCIpIHJldHVybiBcImRlY29yYXRpdmVcIjtcblxuICByZXR1cm4gXCJjb250ZW50XCI7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTW90aW9uRGF0YUF0dHJzKG9iajogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgZGF0YVR5cGUgPSBlc2NhcGVBdHRyKG1hcE9ialRvRGF0YVR5cGUob2JqKSk7XG4gIGNvbnN0IGRhdGFSb2xlID0gZXNjYXBlQXR0cihpbmZlckRhdGFSb2xlKG9iaikpO1xuICBjb25zdCBkYXRhTW90aW9uID0gZXNjYXBlQXR0cihzYW5pdGl6ZU1vdGlvbkVmZmVjdChvYmo/Lm1vdGlvbkVmZmVjdCkpO1xuICByZXR1cm4gYGRhdGEtdHlwZT1cIiR7ZGF0YVR5cGV9XCIgZGF0YS1yb2xlPVwiJHtkYXRhUm9sZX1cIiBkYXRhLW1vdGlvbj1cIiR7ZGF0YU1vdGlvbn1cImA7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZE1vdGlvbkRhdGFBdHRycyhodG1sRWxlbWVudG86IHN0cmluZywgb2JqOiBhbnkpOiBzdHJpbmcge1xuICBpZiAoIWh0bWxFbGVtZW50byB8fCB0eXBlb2YgaHRtbEVsZW1lbnRvICE9PSBcInN0cmluZ1wiKSByZXR1cm4gaHRtbEVsZW1lbnRvO1xuXG4gIGNvbnN0IGF0dHJzID0gYnVpbGRNb3Rpb25EYXRhQXR0cnMob2JqKTtcbiAgcmV0dXJuIGh0bWxFbGVtZW50by5yZXBsYWNlKFxuICAgIC8oPCg/OmRpdnxpbWd8c3ZnKVxcYltePl0qXFxiY2xhc3M9XCJbXlwiXSpcXGJvYmpldG9cXGJbXlwiXSpcIikvaSxcbiAgICBgJDEgJHthdHRyc31gXG4gICk7XG59XG5cclxuZnVuY3Rpb24gZ2V0TGlua1Byb3BzKG9iajogYW55KSB7XHJcbiAgY29uc3QgcmF3ID0gb2JqPy5lbmxhY2U7XHJcbiAgaWYgKCFyYXcpIHJldHVybiBudWxsO1xyXG5cclxuICBpZiAodHlwZW9mIHJhdyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgY29uc3QgaHJlZiA9IGVzY2FwZUF0dHIocmF3KTtcclxuICAgIGlmICghaHJlZikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4geyBocmVmLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGhyZWYgPSBlc2NhcGVBdHRyKHJhdy5ocmVmIHx8IFwiXCIpO1xyXG4gIGlmICghaHJlZikgcmV0dXJuIG51bGw7XHJcblxyXG4gIGNvbnN0IHRhcmdldCA9IGVzY2FwZUF0dHIocmF3LnRhcmdldCB8fCBcIl9ibGFua1wiKTtcclxuICBjb25zdCByZWwgPSBlc2NhcGVBdHRyKHJhdy5yZWwgfHwgXCJub29wZW5lciBub3JlZmVycmVyXCIpO1xyXG4gIHJldHVybiB7IGhyZWYsIHRhcmdldCwgcmVsIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVudm9sdmVyU2lFbmxhY2UoaHRtbEVsZW1lbnRvOiBzdHJpbmcsIG9iajogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgaHRtbENvbkRhdGEgPSBhcHBlbmRNb3Rpb25EYXRhQXR0cnMoaHRtbEVsZW1lbnRvLCBvYmopO1xuICBpZiAob2JqPy50aXBvID09PSBcInJzdnAtYm90b25cIikgcmV0dXJuIGh0bWxDb25EYXRhO1xuXG4gIGNvbnN0IGxpbmsgPSBnZXRMaW5rUHJvcHMob2JqKTtcbiAgaWYgKCFsaW5rKSByZXR1cm4gaHRtbENvbkRhdGE7XG5cbiAgcmV0dXJuIGA8YSBocmVmPVwiJHtsaW5rLmhyZWZ9XCIgdGFyZ2V0PVwiJHtsaW5rLnRhcmdldH1cIiByZWw9XCIke2xpbmsucmVsfVwiIHN0eWxlPVwidGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OmNvbnRlbnRzXCI+JHtodG1sQ29uRGF0YX08L2E+YDtcbn1cblxyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlSFRNTCh0ZXh0bzogc3RyaW5nID0gXCJcIik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHRleHRvXHJcbiAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXHJcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcclxuICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxyXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXHJcbiAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJIVE1MRGVzZGVPYmpldG9zKG9iamV0b3M6IGFueVtdLCBfc2VjY2lvbmVzOiBhbnlbXSk6IHN0cmluZyB7XHJcbiAgY29uc3QgYWx0b01vZG9Qb3JTZWNjaW9uID0gbmV3IE1hcChcclxuICAgIChfc2VjY2lvbmVzIHx8IFtdKS5tYXAoKHM6IGFueSkgPT4gW3MuaWQsIFN0cmluZyhzLmFsdG9Nb2RvIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpXSlcclxuICApO1xyXG5cclxuICBmdW5jdGlvbiBlc1NlY2Npb25QYW50YWxsYShvYmo6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgbW9kbyA9IGFsdG9Nb2RvUG9yU2VjY2lvbi5nZXQob2JqPy5zZWNjaW9uSWQpIHx8IFwiZmlqb1wiO1xyXG4gICAgcmV0dXJuIG1vZG8gPT09IFwicGFudGFsbGFcIjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRnVsbEJsZWVkKG9iajogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gU3RyaW5nKG9iaj8uYW5jbGFqZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImZ1bGxibGVlZFwiO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog4pyFIEVzY2FsYSB1bmlmb3JtZSBkZWwgQ09OVEVOSURPOlxyXG4gICAqIC0gcGFudGFsbGE6IHZhcigtLXNmaW5hbCkgKGZpdCBzaSBoYWNlIGZhbHRhKVxyXG4gICAqIC0gZmlqbzogdmFyKC0tc3gpXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc0NvbnRlbmlkb1ZhcihvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gZXNTZWNjaW9uUGFudGFsbGEob2JqKSA/IFwidmFyKC0tc2ZpbmFsKVwiIDogXCJ2YXIoLS1zeClcIjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOKchSBYIHNjYWxlOlxyXG4gICAqIC0gZnVsbEJsZWVkOiB2YXIoLS1ieCkgKE5PIGZpdClcclxuICAgKiAtIGNvbnRlbmlkbzogc0NvbnRlbmlkb1ZhciAoZml0IHNpIHBhbnRhbGxhKVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNYKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgIHJldHVybiBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1ieClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOKchSBZIHNjYWxlOlxyXG4gICAqIC0gZnVsbEJsZWVkOiB2YXIoLS1zeCkgKE5PIGZpdClcclxuICAgKiAtIGNvbnRlbmlkbzogc0NvbnRlbmlkb1ZhciAoZml0IHNpIHBhbnRhbGxhKVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNZKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgIHJldHVybiBpc0Z1bGxCbGVlZChvYmopID8gXCJ2YXIoLS1zeClcIiA6IHNDb250ZW5pZG9WYXIob2JqKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB4WChvYmo6IGFueSwgcHg6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCBuID0gTnVtYmVyLmlzRmluaXRlKHB4KSA/IHB4IDogMDtcclxuICAgIHJldHVybiBgY2FsYygke3NYKG9iail9ICogJHtufXB4KWA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBweFkob2JqOiBhbnksIHB4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbiA9IE51bWJlci5pc0Zpbml0ZShweCkgPyBweCA6IDA7XHJcbiAgICByZXR1cm4gYGNhbGMoJHtzWShvYmopfSAqICR7bn1weClgO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8g4pyFIFBBTlRBTExBOiB0b3AgcG9yIHBvcmNlbnRhamVcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICBjb25zdCBBTFRVUkFfRURJVE9SX1BBTlRBTExBID0gNTAwO1xyXG5cclxuICAvLyDinIUgT2Zmc2V0cyBlbiBzZWNjaW9uZXMgUGFudGFsbGE6IE9OXHJcbiAgLy8g4pqg77iPIElNUE9SVEFOVEU6IGVzdGUgYXJjaGl2byBTT0xPIGdlbmVyYSBvYmpldG9zLlxyXG4gIC8vIEVsIHZhbG9yIERFU0tUT1AvTU9CSUxFIHJlYWwgc2UgY29udHJvbGEgdsOtYSBDU1MgZ2xvYmFsIGNvbjpcclxuICAvLyAgIDpyb290IHsgLS1wYW50YWxsYS15LW9mZnNldDogWHB4IH1cclxuICAvLyAgIEBtZWRpYSAobWF4LXdpZHRoOiA2NDBweCkgeyA6cm9vdCB7IC0tcGFudGFsbGEteS1vZmZzZXQ6IFlweCB9IH1cclxuICAvL1xyXG4gIC8vIEFjw6EgZGVqYW1vcyBmYWxsYmFjayAoZGVza3RvcCkgcG9yIHNpIGxhIHZhcmlhYmxlIENTUyBubyBleGlzdGUuXHJcbiAgY29uc3QgUEFOVEFMTEFfWV9PRkZTRVRfREVTS1RPUF9QWCA9IDA7XG5cclxuICBmdW5jdGlvbiBjbGFtcDAxKG46IGFueSk6IG51bWJlciB8IG51bGwge1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihuKTtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRZUHhFZGl0b3Iob2JqOiBhbnkpOiBudW1iZXIge1xuICAgIC8vIOKchSBFbiBQYW50YWxsYSBPTjogeU5vcm0gZXMgbGEgZnVlbnRlIGRlIHZlcmRhZCAoMC4uMSlcclxuICAgIGNvbnN0IHluID0gY2xhbXAwMShvYmo/LnlOb3JtKTtcclxuICAgIGlmICh5biAhPSBudWxsKSByZXR1cm4geW4gKiBBTFRVUkFfRURJVE9SX1BBTlRBTExBO1xyXG5cclxuICAgIC8vIGZhbGxiYWNrOiBzaSBubyBoYXkgeU5vcm0sIHVzYW1vcyB5IGNvbW8gXCJlZGl0b3IgcHhcIlxyXG4gICAgY29uc3QgeVB4ID0gTnVtYmVyKG9iaj8ueSk7XHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHlQeCkpIHJldHVybiB5UHg7XHJcblxyXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiB0b3BQYW50YWxsYUNTUyhvYmo6IGFueSwgeW5SYXc6IGFueSk6IHN0cmluZyB7XG4gICAgY29uc3QgeW4gPSBjbGFtcDAxKHluUmF3KSA/PyAwO1xuICAgIGNvbnN0IHlCbG9xdWVEaXNlbmlvID0gYGNhbGMoJHtzQ29udGVuaWRvVmFyKG9iail9ICogJHtBTFRVUkFfRURJVE9SX1BBTlRBTExBfXB4KWA7XG4gICAgY29uc3QgeUJhc2VQYW50YWxsYSA9IGB2YXIoLS1wYW50YWxsYS15LWJhc2UsIDBweClgO1xuICAgIGNvbnN0IHluQ29tcGFjdGFkbyA9IGBjYWxjKDAuNSArICgoJHt5bn0pIC0gMC41KSAqICgxIC0gdmFyKC0tcGFudGFsbGEteS1jb21wYWN0LCAwKSkpYDtcbiAgICByZXR1cm4gYGNhbGMoXG4gICR7eUJhc2VQYW50YWxsYX1cbiAgKyAoJHt5QmxvcXVlRGlzZW5pb30gKiAke3luQ29tcGFjdGFkb30pXG4gICsgKCR7c0NvbnRlbmlkb1ZhcihvYmopfSAqIHZhcigtLXBhbnRhbGxhLXktb2Zmc2V0LCAke1BBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFh9cHgpKVxuKWA7XG4gIH1cblxuICAvKipcbiAgICog4pyFIHRvcENTUzpcbiAgICogLSBQYW50YWxsYSBPTjogdXNhIGJsb3F1ZSBkZSBkaXNlw7FvIGVzY2FsYWRvICg1MDBweCAqIHNmaW5hbCkgKyBvZmZzZXQgYmFzZSB1bmlmb3JtZVxuICAgKiAtIFRleHRvIGVuIFBhbnRhbGxhIE9OOiBzdW1hIG9mZnNldCAoQ1NTIHZhcikgZXNjYWxhZG8gcG9yIHNDb250ZW5pZG9WYXJcbiAgICogLSBGaWpvOiBweFkob2JqLCB5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9wQ1NTKG9iajogYW55KTogc3RyaW5nIHtcbiAgICBpZiAoZXNTZWNjaW9uUGFudGFsbGEob2JqKSkge1xuICAgICAgY29uc3QgeVB4RWRpdG9yID0gZ2V0WVB4RWRpdG9yKG9iaik7XG4gICAgICBjb25zdCB5biA9IGNsYW1wMDEoeVB4RWRpdG9yIC8gQUxUVVJBX0VESVRPUl9QQU5UQUxMQSkgPz8gMDtcbiAgICAgIHJldHVybiB0b3BQYW50YWxsYUNTUyhvYmosIHluKTtcbiAgICB9XG5cbiAgICBjb25zdCB5ID0gTnVtYmVyKG9iaj8ueSB8fCAwKTtcbiAgICByZXR1cm4gcHhZKG9iaiwgeSk7XG4gIH1cblxyXG4gIC8qKlxyXG4gICAqIOKchSBWYXJpYW50ZSBwYXJhIGN1YW5kbyB5YSB0ZW7DqXMgeVB4IChlbiBcInB4IGVkaXRvclwiKVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRvcENTU0Zyb21ZUHgob2JqOiBhbnksIHlQeDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoZXNTZWNjaW9uUGFudGFsbGEob2JqKSkge1xuICAgICAgY29uc3QgeW4gPSBjbGFtcDAxKHlQeCAvIEFMVFVSQV9FRElUT1JfUEFOVEFMTEEpID8/IDA7XG4gICAgICByZXR1cm4gdG9wUGFudGFsbGFDU1Mob2JqLCB5bik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB4WShvYmosIHlQeCk7XG4gIH1cblxyXG4gIGZ1bmN0aW9uIHN0eWxlUG9zQmFzZShvYmo6IGFueSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCB4ID0gTnVtYmVyKG9iaj8ueCB8fCAwKTtcclxuXHJcbiAgICBjb25zdCByb3QgPSBvYmo/LnJvdGF0aW9uID8/IDA7XHJcbiAgICBjb25zdCBzY2FsZVggPSBvYmo/LnNjYWxlWCA/PyAxO1xyXG4gICAgY29uc3Qgc2NhbGVZID0gb2JqPy5zY2FsZVkgPz8gMTtcclxuXHJcbiAgICBjb25zdCB6SW5kZXggPSBOdW1iZXIuaXNGaW5pdGUob2JqPy56SW5kZXgpID8gb2JqLnpJbmRleCA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICByZXR1cm4gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgeCl9O1xyXG50b3A6ICR7dG9wQ1NTKG9iail9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XHJcbiR7ekluZGV4ICE9PSB1bmRlZmluZWQgPyBgei1pbmRleDoke3pJbmRleH07YCA6IFwiXCJ9XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0eWxlU2l6ZShvYmo6IGFueSwgdz86IG51bWJlciwgaD86IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCB3dyA9IE51bWJlci5pc0Zpbml0ZSh3KSA/ICh3IGFzIG51bWJlcikgOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBoaCA9IE51bWJlci5pc0Zpbml0ZShoKSA/IChoIGFzIG51bWJlcikgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XHJcbiAgICBpZiAod3cgIT09IHVuZGVmaW5lZCkgcGFydHMucHVzaChgd2lkdGg6ICR7cHhYKG9iaiwgd3cpfTtgKTtcclxuICAgIGlmIChoaCAhPT0gdW5kZWZpbmVkKSBwYXJ0cy5wdXNoKGBoZWlnaHQ6ICR7cHhZKG9iaiwgaGgpfTtgKTtcclxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVySWNvbm9TdmdOdWV2b0lubGluZShvYmo6IGFueSkge1xyXG4gICAgY29uc3Qgdmlld0JveCA9IG9iai52aWV3Qm94IHx8IFwiMCAwIDI0IDI0XCI7XHJcbiAgICBjb25zdCBjb2xvciA9IG9iai5jb2xvciB8fCBcIiMwMDBcIjtcclxuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShvYmoucGF0aHMpID8gb2JqLnBhdGhzIDogW107XHJcbiAgICBpZiAoIXBhdGhzLmxlbmd0aCkgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IDI0O1xyXG4gICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogMjQ7XHJcblxyXG4gICAgY29uc3Qgcm90ID0gb2JqPy5yb3RhdGlvbiA/PyAwO1xyXG4gICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgIGNvbnN0IHNjYWxlWSA9IG9iaj8uc2NhbGVZID8/IDE7XHJcblxyXG4gICAgY29uc3QgeCA9IE51bWJlcihvYmo/LnggfHwgMCk7XHJcbiAgICBjb25zdCB5UHggPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuXHJcbiAgICBjb25zdCBwYXRoc0h0bWwgPSBwYXRoc1xyXG4gICAgICAubWFwKChwOiBhbnkpID0+IChwPy5kID8gYDxwYXRoIGQ9XCIke2VzY0hUTUwocC5kKX1cIiBmaWxsPVwiJHtlc2NIVE1MKGNvbG9yKX1cIj48L3BhdGg+YCA6IFwiXCIpKVxyXG4gICAgICAuam9pbihcIlwiKTtcclxuXHJcbiAgICBjb25zdCBzdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHgpfTtcclxudG9wOiAke3RvcENTU0Zyb21ZUHgob2JqLCB5UHgpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgdyl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgaCl9O1xyXG50cmFuc2Zvcm06IHJvdGF0ZSgke3JvdH1kZWcpIHNjYWxlKCR7c2NhbGVYfSwgJHtzY2FsZVl9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICByZXR1cm4gYDxzdmcgY2xhc3M9XCJvYmpldG9cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIiR7ZXNjSFRNTChcclxuICAgICAgdmlld0JveFxyXG4gICAgKX1cIiBzdHlsZT1cIiR7c3R5bGV9XCI+JHtwYXRoc0h0bWx9PC9zdmc+YDtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYmpldG9zXHJcbiAgICAubWFwKChvYmopID0+IHtcclxuICAgICAgY29uc3QgdGlwbyA9IG9iaj8udGlwbztcclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gVEVYVE8gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJ0ZXh0b1wiKSB7XHJcbiAgICAgICAgY29uc3QgYWxpZ24gPSBTdHJpbmcob2JqLmFsaWduIHx8IG9iai50ZXh0QWxpZ24gfHwgXCJsZWZ0XCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBvYmouY29sb3JUZXh0byB8fCBvYmouY29sb3IgfHwgb2JqLmZpbGwgfHwgXCIjMDAwXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VMaW5lSGVpZ2h0ID1cclxuICAgICAgICAgIHR5cGVvZiBvYmoubGluZUhlaWdodCA9PT0gXCJudW1iZXJcIiAmJiBvYmoubGluZUhlaWdodCA+IDAgPyBvYmoubGluZUhlaWdodCA6IDEuMjtcclxuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0RmluYWwgPSBiYXNlTGluZUhlaWdodCAqIDAuOTI7XHJcblxyXG4gICAgICAgIGNvbnN0IHNhZmVUZXh0byA9IGVzY0hUTUwob2JqLnRleHRvIHx8IFwiXCIpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG5cclxuICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGZzID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uZm9udFNpemUpID8gb2JqLmZvbnRTaXplIDogMjQ7XHJcblxyXG4gICAgICAgIC8vIOKaoO+4jyB0ZXh0byBmdWxsQmxlZWQgTk8gaGFjZSBmaXQgPT4gZXNjYWxhIGNvbiB2YXIoLS1zeClcclxuICAgICAgICBjb25zdCBzRm9udCA9IGlzRnVsbEJsZWVkKG9iaikgPyBcInZhcigtLXN4KVwiIDogc0NvbnRlbmlkb1ZhcihvYmopO1xyXG5cclxuICAgICAgICBjb25zdCByb3QgPSBvYmo/LnJvdGF0aW9uID8/IDA7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gb2JqPy5zY2FsZVggPz8gMTtcclxuICAgICAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgICAgICBjb25zdCBvcmlnaW4gPVxyXG4gICAgICAgICAgYWxpZ24gPT09IFwiY2VudGVyXCIgPyBcInRvcCBjZW50ZXJcIiA6XHJcbiAgICAgICAgICAgIChhbGlnbiA9PT0gXCJyaWdodFwiID8gXCJ0b3AgcmlnaHRcIiA6IFwidG9wIGxlZnRcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxuJHtiYXNlU3R5bGV9XG4vKiDinIUgbWFudGVuZXIgZ2VvbWV0csOtYSBlc3RhYmxlIHkgZXNjYWxhciB0aXBvZ3JhZsOtYSBwb3IgZm9udC1zaXplIChubyBwb3IgdHJhbnNmb3JtKS4gKi9cbnRyYW5zZm9ybS1vcmlnaW46ICR7b3JpZ2lufTtcbnRyYW5zZm9ybTogcm90YXRlKCR7cm90fWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pO1xuJHt3ICE9PSB1bmRlZmluZWQgPyBgd2lkdGg6ICR7cHhYKG9iaiwgdyl9O2AgOiBcIlwifVxuZm9udC1zaXplOiBjYWxjKCR7c0ZvbnR9ICogJHtmc31weCAqIHZhcigtLXRleHQtem9vbSwgMSkpO1xuZm9udC1mYW1pbHk6ICR7b2JqLmZvbnRGYW1pbHkgfHwgXCJzYW5zLXNlcmlmXCJ9O1xuZm9udC13ZWlnaHQ6ICR7b2JqLmZvbnRXZWlnaHQgfHwgXCJub3JtYWxcIn07XG5mb250LXN0eWxlOiAke29iai5mb250U3R5bGUgfHwgXCJub3JtYWxcIn07XG50ZXh0LWRlY29yYXRpb246ICR7b2JqLnRleHREZWNvcmF0aW9uIHx8IFwibm9uZVwifTtcclxuY29sb3I6ICR7Y29sb3J9O1xyXG50ZXh0LWFsaWduOiAke2FsaWdufTtcclxud2hpdGUtc3BhY2U6IHByZS13cmFwO1xyXG5saW5lLWhlaWdodDogJHtsaW5lSGVpZ2h0RmluYWx9O1xyXG5wYWRkaW5nOiAwO1xyXG5tYXJnaW46IDA7XHJcbmJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xyXG4ke29iai5zdHJva2UgJiYgb2JqLnN0cm9rZVdpZHRoID4gMFxyXG4gICAgICAgICAgICA/IGAtd2Via2l0LXRleHQtc3Ryb2tlOiAke29iai5zdHJva2VXaWR0aH1weCAke29iai5zdHJva2V9O2BcclxuICAgICAgICAgICAgOiBcIlwiXHJcbiAgICAgICAgICB9XHJcbiR7b2JqLnNoYWRvd0NvbG9yXHJcbiAgICAgICAgICAgID8gYHRleHQtc2hhZG93OiAke29iai5zaGFkb3dPZmZzZXRYIHx8IDB9cHggJHtvYmouc2hhZG93T2Zmc2V0WSB8fCAwfXB4ICR7b2JqLnNoYWRvd0JsdXIgfHwgMH1weCAke29iai5zaGFkb3dDb2xvcn07YFxyXG4gICAgICAgICAgICA6IFwidGV4dC1zaGFkb3c6IG5vbmU7XCJcclxuICAgICAgICAgIH1cclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKFxyXG4gICAgICAgICAgYDxkaXYgY2xhc3M9XCJvYmpldG9cIiBkYXRhLWRlYnVnLXRleHRvPVwiMVwiIHN0eWxlPVwiJHtzdHlsZX1cIj4ke3NhZmVUZXh0b308L2Rpdj5gLFxyXG4gICAgICAgICAgb2JqXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gSU1BR0VOIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiaW1hZ2VuXCIpIHtcclxuICAgICAgICBjb25zdCBzcmMgPSBvYmouc3JjIHx8IG9iai51cmwgfHwgXCJcIjtcclxuICAgICAgICBpZiAoIXNyYykgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbiR7c3R5bGVTaXplKG9iaiwgdywgaCl9XHJcbm9iamVjdC1maXQ6IGNvbnRhaW47XHJcbmRpc3BsYXk6IGJsb2NrO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxpbWcgY2xhc3M9XCJvYmpldG9cIiBzcmM9XCIke2VzY2FwZUF0dHIoc3JjKX1cIiBzdHlsZT1cIiR7c3R5bGV9XCIgLz5gLCBvYmopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIElDT05PIChudWV2bykgLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJpY29ub1wiKSB7XHJcbiAgICAgICAgaWYgKG9iai5mb3JtYXRvID09PSBcInN2Z1wiKSB7XHJcbiAgICAgICAgICBjb25zdCBzdmdIdG1sID0gcmVuZGVySWNvbm9TdmdOdWV2b0lubGluZShvYmopO1xyXG4gICAgICAgICAgaWYgKCFzdmdIdG1sKSByZXR1cm4gXCJcIjtcclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKHN2Z0h0bWwsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzcmMgPSBvYmoudXJsIHx8IG9iai5zcmMgfHwgXCJcIjtcclxuICAgICAgICBpZiAoIXNyYykgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgIGNvbnN0IHcgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy53aWR0aCkgPyBvYmoud2lkdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbiR7c3R5bGVTaXplKG9iaiwgdywgaCl9XHJcbm9iamVjdC1maXQ6IGNvbnRhaW47XHJcbmRpc3BsYXk6IGJsb2NrO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoYDxpbWcgY2xhc3M9XCJvYmpldG9cIiBzcmM9XCIke2VzY2FwZUF0dHIoc3JjKX1cIiBzdHlsZT1cIiR7c3R5bGV9XCIgLz5gLCBvYmopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIElDT05PIExFR0FDWSAoaWNvbm8tc3ZnKSAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImljb25vLXN2Z1wiICYmIG9iai5kKSB7XHJcbiAgICAgICAgY29uc3QgdmIgPSBvYmoudmlld0JveCB8fCBcIjAgMCAxMDAgMTAwXCI7XHJcbiAgICAgICAgY29uc3QgZmlsbCA9IG9iai5jb2xvciB8fCBcIiMwMDBcIjtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IDEwMDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiAxMDA7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxud2lkdGg6ICR7cHhYKG9iaiwgdyl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgaCl9O1xyXG5maWxsOiAke2VzY2FwZUF0dHIoZmlsbCl9O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gYDxzdmcgY2xhc3M9XCJvYmpldG9cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIiR7ZXNjYXBlQXR0cihcclxuICAgICAgICAgIHZiXHJcbiAgICAgICAgKX1cIiBzdHlsZT1cIiR7c3R5bGV9XCI+PHBhdGggZD1cIiR7ZXNjSFRNTChvYmouZCl9XCIgLz48L3N2Zz5gO1xyXG5cclxuICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShzdmcsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gQ09VTlRET1dOIC0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgaWYgKHRpcG8gPT09IFwiY291bnRkb3duXCIpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRJU08gPSBvYmoudGFyZ2V0SVNPIHx8IG9iai5mZWNoYU9iamV0aXZvIHx8IG9iai5mZWNoYUlTTyB8fCBcIlwiO1xyXG5cclxuICAgICAgICBjb25zdCB0ZXh0Q29sb3IgPSBvYmouY29sb3JUZXh0byA/PyBvYmouY29sb3IgPz8gXCIjMTExXCI7XHJcbiAgICAgICAgY29uc3QgZm9udEZhbWlseSA9IG9iai5mb250RmFtaWx5IHx8IFwiSW50ZXIsIHN5c3RlbS11aSwgc2Fucy1zZXJpZlwiO1xyXG5cclxuICAgICAgICBjb25zdCBwcmVzZXQgPSBvYmoucHJlc2V0SWQgfHwgb2JqLmxheW91dCB8fCBcInBpbGxzXCI7XHJcbiAgICAgICAgY29uc3QgaXNNaW5pbWFsID0gU3RyaW5nKHByZXNldCkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIm1pbmltYWxcIik7XHJcblxyXG4gICAgICAgIC8vIOKchSBhbmNoby9hbHRvIGRlbCBvYmpldG8gKHNpIGV4aXN0ZW4pXHJcbiAgICAgICAgY29uc3Qgd09iaiA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IE51bWJlcihvYmoud2lkdGgpIDogbnVsbDtcclxuICAgICAgICBjb25zdCBoT2JqID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IE51bWJlcihvYmouaGVpZ2h0KSA6IG51bGw7XHJcblxyXG4gICAgICAgIC8vIOKchSBnYXA6IHNpIHZpZW5lIGRlIEtvbnZhLCByZXNwZXRhcmxvXHJcbiAgICAgICAgY29uc3QgZ2FwID0gTnVtYmVyLmlzRmluaXRlKG9iai5nYXApXHJcbiAgICAgICAgICA/IE51bWJlcihvYmouZ2FwKVxyXG4gICAgICAgICAgOiBOdW1iZXIuaXNGaW5pdGUob2JqLnNwYWNpbmcpXHJcbiAgICAgICAgICAgID8gTnVtYmVyKG9iai5zcGFjaW5nKVxyXG4gICAgICAgICAgICA6IDg7XHJcblxyXG4gICAgICAgIC8vIOKchSBTaSB0dSBLb252YSBndWFyZGEgY2hpcFdpZHRoIC8gcGFkZGluZ1gsIHJlc3BldGFsb3NcclxuICAgICAgICAvLyBjaGlwV2lkdGg6IGFuY2hvIGludGVybm8gZGVsIHRleHRvIChzaW4gcGFkZGluZylcclxuICAgICAgICBjb25zdCBjaGlwV2lkdGhQcm9wID0gTnVtYmVyLmlzRmluaXRlKG9iai5jaGlwV2lkdGgpID8gTnVtYmVyKG9iai5jaGlwV2lkdGgpIDogbnVsbDtcclxuICAgICAgICBjb25zdCBwYWRkaW5nWFByb3AgPSBOdW1iZXIuaXNGaW5pdGUob2JqLnBhZGRpbmdYKSA/IE51bWJlcihvYmoucGFkZGluZ1gpIDogbnVsbDtcclxuXHJcbiAgICAgICAgLy8g4pyFIERlcml2YWNpw7NuIHJhw616IChjdWFuZG8gbm8gaGF5IHByb3BzKVxyXG4gICAgICAgIGNvbnN0IG4gPSA0O1xyXG5cclxuICAgICAgICAvLyBjaGlwV1RvdGFsOiBhbmNobyB0b3RhbCBkZSBjYWRhIGNoaXAgKGluY2x1eWUgcGFkZGluZylcclxuICAgICAgICBsZXQgY2hpcFdUb3RhbCA9IDU2OyAvLyBmYWxsYmFjayByYXpvbmFibGVcclxuICAgICAgICBpZiAod09iaiAmJiB3T2JqID4gMCkge1xyXG4gICAgICAgICAgY2hpcFdUb3RhbCA9IE1hdGgubWF4KDQwLCAod09iaiAtIGdhcCAqIChuIC0gMSkpIC8gbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwYWRkaW5nWCBkZXJpdmFkbyBkZWwgY2hpcFdUb3RhbCAoc2kgbm8gdmlubylcclxuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IHBhZGRpbmdYUHJvcCA/PyBNYXRoLm1heCg2LCBNYXRoLnJvdW5kKGNoaXBXVG90YWwgKiAwLjE4KSk7IC8vIH4xOCVcclxuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IE1hdGgubWF4KDUsIE1hdGgucm91bmQocGFkZGluZ1ggKiAwLjY1KSk7XHJcblxyXG4gICAgICAgIC8vIGNoaXBXaWR0aCAodGV4dG8pIGRlcml2YWRvIHNpIG5vIHZpbm9cclxuICAgICAgICBjb25zdCBjaGlwV2lkdGggPSBjaGlwV2lkdGhQcm9wID8/IE1hdGgubWF4KDEwLCBNYXRoLnJvdW5kKGNoaXBXVG90YWwgLSBwYWRkaW5nWCAqIDIpKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIGZvbnQgc2l6ZXM6IHNpIHZpZW5lbiwgcmVzcGV0YXI7IHNpIG5vLCBkZXJpdmFyIGRlc2RlIGNoaXBXVG90YWxcclxuICAgICAgICBjb25zdCB2YWx1ZVNpemUgPVxyXG4gICAgICAgICAgTnVtYmVyLmlzRmluaXRlKG9iai5mb250U2l6ZSkgPyBOdW1iZXIob2JqLmZvbnRTaXplKSA6IE1hdGgubWF4KDE0LCBNYXRoLnJvdW5kKGNoaXBXVG90YWwgKiAwLjM0KSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWxTaXplID1cclxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShvYmoubGFiZWxTaXplKSA/IE51bWJlcihvYmoubGFiZWxTaXplKSA6IE1hdGgubWF4KDksIE1hdGgucm91bmQodmFsdWVTaXplICogMC42MikpO1xyXG5cclxuICAgICAgICBjb25zdCBsYWJlbENvbG9yID0gb2JqLmxhYmVsQ29sb3IgPz8gXCIjNmI3MjgwXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IE51bWJlci5pc0Zpbml0ZShvYmouZm9udFdlaWdodCkgPyBvYmouZm9udFdlaWdodCA6IDcwMDtcclxuICAgICAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gTnVtYmVyLmlzRmluaXRlKG9iai5sZXR0ZXJTcGFjaW5nKSA/IG9iai5sZXR0ZXJTcGFjaW5nIDogMDtcclxuXHJcbiAgICAgICAgLy8g4pyFIGVzdGlsb3MgZGUgY2hpcFxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckJnRmluYWwgPSBcInRyYW5zcGFyZW50XCI7XHJcbiAgICAgICAgY29uc3QgY2hpcEJnRmluYWwgPSBpc01pbmltYWwgPyBcInRyYW5zcGFyZW50XCIgOiBvYmouY2hpcEJhY2tncm91bmQgPz8gb2JqLmJveEJnID8/IFwicmdiYSgyNTUsMjU1LDI1NSwuNzUpXCI7XHJcbiAgICAgICAgY29uc3QgY2hpcEJvcmRlckNvbG9yRmluYWwgPSBpc01pbmltYWwgPyBcInRyYW5zcGFyZW50XCIgOiBvYmouY2hpcEJvcmRlciA/PyBvYmouYm94Qm9yZGVyID8/IFwicmdiYSgwLDAsMCwuMDgpXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJhZGl1cyA9IE51bWJlci5pc0Zpbml0ZShvYmouYm94UmFkaXVzKVxyXG4gICAgICAgICAgPyBvYmouYm94UmFkaXVzXHJcbiAgICAgICAgICA6IE51bWJlci5pc0Zpbml0ZShvYmoucmFkaXVzKVxyXG4gICAgICAgICAgICA/IG9iai5yYWRpdXNcclxuICAgICAgICAgICAgOiAxMDtcclxuXHJcbiAgICAgICAgY29uc3QgY2hpcFJhZGl1c0ZpbmFsID0gTnVtYmVyLmlzRmluaXRlKG9iai5jaGlwUmFkaXVzKSA/IG9iai5jaGlwUmFkaXVzIDogY29udGFpbmVyUmFkaXVzO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIEVzY2FsYSBjb3JyZWN0YSAocmVzcGV0YSBwYW50YWxsYSB5IGJsZWVkKVxyXG4gICAgICAgIGNvbnN0IHNDaGlwID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxuJHt3T2JqID8gYHdpZHRoOiAke3B4WChvYmosIHdPYmopfTtgIDogXCJcIn1cclxuJHtoT2JqID8gYGhlaWdodDogJHtweFkob2JqLCBoT2JqKX07YCA6IFwiXCJ9XHJcbmRpc3BsYXk6IGZsZXg7XHJcbmFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbmp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG5nYXA6IGNhbGMoJHtzQ2hpcH0gKiAke2dhcH1weCk7XHJcbmZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xyXG5jb2xvcjogJHt0ZXh0Q29sb3J9O1xyXG5iYWNrZ3JvdW5kOiAke2NvbnRhaW5lckJnRmluYWx9O1xyXG5ib3JkZXItcmFkaXVzOiBjYWxjKCR7c0NoaXB9ICogJHtjb250YWluZXJSYWRpdXN9cHgpO1xyXG5sZXR0ZXItc3BhY2luZzogY2FsYygke3NDaGlwfSAqICR7bGV0dGVyU3BhY2luZ31weCk7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBjaGlwU3R5bGUgPSBgXHJcbndpZHRoOiBjYWxjKCR7c0NoaXB9ICogJHtNYXRoLnJvdW5kKGNoaXBXVG90YWwpfXB4KTtcclxucGFkZGluZzogY2FsYygke3NDaGlwfSAqICR7cGFkZGluZ1l9cHgpIGNhbGMoJHtzQ2hpcH0gKiAke3BhZGRpbmdYfXB4KTtcclxuYm9yZGVyOiAke2lzTWluaW1hbCA/IFwiMFwiIDogYGNhbGMoJHtzQ2hpcH0gKiAxcHgpIHNvbGlkICR7Y2hpcEJvcmRlckNvbG9yRmluYWx9YH07XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzQ2hpcH0gKiAke2NoaXBSYWRpdXNGaW5hbH1weCk7XHJcbmRpc3BsYXk6IGZsZXg7XHJcbmZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbmFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbmp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG5iYWNrZ3JvdW5kOiAke2NoaXBCZ0ZpbmFsfTtcclxuYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZhbHVlU3R5bGUgPSBgXHJcbmZvbnQtd2VpZ2h0OiAke2ZvbnRXZWlnaHR9O1xyXG5mb250LXNpemU6IGNhbGMoJHtzQ2hpcH0gKiAke3ZhbHVlU2l6ZX1weCk7XHJcbmxpbmUtaGVpZ2h0OiAxO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWxTdHlsZSA9IGBcclxuZm9udC1zaXplOiBjYWxjKCR7c0NoaXB9ICogJHtsYWJlbFNpemV9cHgpO1xyXG5jb2xvcjogJHtsYWJlbENvbG9yfTtcclxubGluZS1oZWlnaHQ6IDEuMDU7XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICBjb25zdCBzaG93TGFiZWxzID0gb2JqLnNob3dMYWJlbHMgIT09IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IG9iai5sYWJlbHMgPz8geyBkaWFzOiBcIkTDrWFzXCIsIGhvcmFzOiBcIkhvcmFzXCIsIG1pbjogXCJNaW5cIiwgc2VnOiBcIlNlZ1wiIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWxDb3VudGRvd24gPSBgXG48ZGl2IGNsYXNzPVwib2JqZXRvXCJcbiAgZGF0YS1tb2JpbGUtY2x1c3Rlcj1cImlzb2xhdGVkXCJcbiAgZGF0YS1tb2JpbGUtY2VudGVyPVwiZm9yY2VcIlxuICBkYXRhLWNvdW50ZG93blxyXG4gIGRhdGEtdGFyZ2V0PVwiJHtlc2NhcGVBdHRyKHRhcmdldElTTyl9XCJcclxuICBkYXRhLXByZXNldD1cIiR7ZXNjYXBlQXR0cihcclxuICAgICAgICAgIHByZXNldFxyXG4gICAgICAgICl9XCIgc3R5bGU9XCIke2NvbnRhaW5lclN0eWxlfVwiPlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLmRpYXMpfTwvc3Bhbj5gIDogXCJcIn1cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzPVwiY2QtY2hpcFwiIHN0eWxlPVwiJHtjaGlwU3R5bGV9XCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImNkLXZhbFwiIHN0eWxlPVwiJHt2YWx1ZVN0eWxlfVwiPjAwPC9zcGFuPlxyXG4gICAgJHtzaG93TGFiZWxzID8gYDxzcGFuIGNsYXNzPVwiY2QtbGFiXCIgc3R5bGU9XCIke2xhYmVsU3R5bGV9XCI+JHtlc2NhcGVBdHRyKGxhYmVscy5ob3Jhcyl9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLm1pbil9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJjZC1jaGlwXCIgc3R5bGU9XCIke2NoaXBTdHlsZX1cIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiY2QtdmFsXCIgc3R5bGU9XCIke3ZhbHVlU3R5bGV9XCI+MDA8L3NwYW4+XHJcbiAgICAke3Nob3dMYWJlbHMgPyBgPHNwYW4gY2xhc3M9XCJjZC1sYWJcIiBzdHlsZT1cIiR7bGFiZWxTdHlsZX1cIj4ke2VzY2FwZUF0dHIobGFiZWxzLnNlZyl9PC9zcGFuPmAgOiBcIlwifVxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cbmAudHJpbSgpO1xuICAgICAgICByZXR1cm4gYXBwZW5kTW90aW9uRGF0YUF0dHJzKGh0bWxDb3VudGRvd24sIG9iaik7XG4gICAgICB9XG5cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gR0FMRVLDjUEgLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJnYWxlcmlhXCIpIHtcclxuICAgICAgICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgcGFyc2VJbnQob2JqLnJvd3MgfHwgMSwgMTApKTtcclxuICAgICAgICBjb25zdCBjb2xzID0gTWF0aC5tYXgoMSwgcGFyc2VJbnQob2JqLmNvbHMgfHwgMSwgMTApKTtcclxuICAgICAgICBjb25zdCBnYXBQeCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KG9iai5nYXAgfHwgMCwgMTApKTtcclxuICAgICAgICBjb25zdCByYWRpdXNQeCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KG9iai5yYWRpdXMgfHwgMCwgMTApKTtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gc3R5bGVQb3NCYXNlKG9iaik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LndpZHRoKSA/IG9iai53aWR0aCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uaGVpZ2h0KSA/IG9iai5oZWlnaHQgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHNHcmlkID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlQ29udGVuZWRvciA9IGBcclxuJHtiYXNlU3R5bGV9XHJcbiR7c3R5bGVTaXplKG9iaiwgdywgaCl9XHJcbmRpc3BsYXk6IGdyaWQ7XHJcbmdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KCR7Y29sc30sIDFmcik7XHJcbmdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KCR7cm93c30sIDFmcik7XHJcbmdhcDogY2FsYygke3NHcmlkfSAqICR7Z2FwUHh9cHgpO1xyXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG90YWwgPSByb3dzICogY29scztcclxuICAgICAgICBjb25zdCBjZWxscyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRvdGFsIH0sIChfLCBpKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjID0gKG9iai5jZWxscyAmJiBvYmouY2VsbHNbaV0pIHx8IHt9O1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWVkaWFVcmw6IGMubWVkaWFVcmwgfHwgXCJcIixcclxuICAgICAgICAgICAgZml0OiBjLmZpdCA9PT0gXCJjb250YWluXCIgPyBcImNvbnRhaW5cIiA6IFwiY292ZXJcIixcclxuICAgICAgICAgICAgYmc6IGMuYmcgfHwgXCIjZjNmNGY2XCIsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBodG1sQ2VsZGFzID0gY2VsbHNcclxuICAgICAgICAgIC5tYXAoKGNlbGwsIGlkeCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzYWZlU3JjID0gZXNjYXBlQXR0cihjZWxsLm1lZGlhVXJsIHx8IFwiXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBjZWxkYVN0eWxlID0gYFxyXG5wb3NpdGlvbjogcmVsYXRpdmU7XHJcbndpZHRoOiAxMDAlO1xyXG5oZWlnaHQ6IDEwMCU7XHJcbm92ZXJmbG93OiBoaWRkZW47XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzR3JpZH0gKiAke3JhZGl1c1B4fXB4KTtcclxuYmFja2dyb3VuZDogJHtjZWxsLmJnfTtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNhZmVTcmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiZ2FsZXJpYS1jZWxkYVwiIGRhdGEtaW5kZXg9XCIke2lkeH1cIiBzdHlsZT1cIiR7Y2VsZGFTdHlsZX1cIj48L2Rpdj5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYFxuPGRpdiBjbGFzcz1cImdhbGVyaWEtY2VsZGEgZ2FsZXJpYS1jZWxkYS0tY2xpY2thYmxlXCJcbiAgICAgZGF0YS1pbmRleD1cIiR7aWR4fVwiXG4gICAgIGRhdGEtZ2FsbGVyeS1pbWFnZT1cIjFcIlxuICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgYXJpYS1sYWJlbD1cIlZlciBpbWFnZW4gZW4gcGFudGFsbGEgY29tcGxldGFcIlxuICAgICBzdHlsZT1cIiR7Y2VsZGFTdHlsZX1cIj5cbiAgPGltZyBzcmM9XCIke3NhZmVTcmN9XCIgYWx0PVwiXCIgbG9hZGluZz1cImxhenlcIiBkZWNvZGluZz1cImFzeW5jXCJcbiAgICAgICBzdHlsZT1cIndpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b2JqZWN0LWZpdDoke2NlbGwuZml0fTtkaXNwbGF5OmJsb2NrO1wiIC8+XG48L2Rpdj5cbmAudHJpbSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWxHYWxlcmlhID0gYDxkaXYgY2xhc3M9XCJvYmpldG8gZ2FsZXJpYVwiIHN0eWxlPVwiJHtzdHlsZUNvbnRlbmVkb3J9XCI+JHtodG1sQ2VsZGFzfTwvZGl2PmA7XHJcbiAgICAgICAgcmV0dXJuIGVudm9sdmVyU2lFbmxhY2UoaHRtbEdhbGVyaWEsIG9iaik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0gUlNWUCBCT1TDk04gLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICBpZiAodGlwbyA9PT0gXCJyc3ZwLWJvdG9uXCIpIHtcclxuICAgICAgICBjb25zdCB0ZXh0byA9IGVzY2FwZUhUTUwob2JqLnRleHRvIHx8IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIik7XHJcbiAgICAgICAgY29uc3QgdyA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmFuY2hvKSA/IG9iai5hbmNobyA6IDIwMDtcclxuICAgICAgICBjb25zdCBoID0gTnVtYmVyLmlzRmluaXRlKG9iaj8uYWx0bykgPyBvYmouYWx0byA6IDUwO1xyXG5cclxuICAgICAgICBjb25zdCBjb2xvciA9IG9iai5jb2xvciB8fCBcIiM3NzNkYmVcIjtcclxuICAgICAgICBjb25zdCBjb2xvclRleHRvID0gb2JqLmNvbG9yVGV4dG8gfHwgXCIjZmZmZmZmXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5mb250U2l6ZSkgPyBvYmouZm9udFNpemUgOiAxODtcclxuICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHkgfHwgXCJzYW5zLXNlcmlmXCI7XHJcbiAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IG9iai5mb250V2VpZ2h0IHx8IFwiYm9sZFwiO1xyXG4gICAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IG9iai5mb250U3R5bGUgfHwgXCJub3JtYWxcIjtcclxuICAgICAgICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IG9iai50ZXh0RGVjb3JhdGlvbiB8fCBcIm5vbmVcIjtcclxuICAgICAgICBjb25zdCBhbGlnbiA9IG9iai5hbGlnbiB8fCBcImNlbnRlclwiO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBzdHlsZVBvc0Jhc2Uob2JqKTtcclxuXHJcbiAgICAgICAgLy8gUlNWUCAoY29udGVuaWRvKTogc2kgZXN0w6EgZW4gcGFudGFsbGEsIGZpdHRlYSAoc0NvbnRlbmlkb1ZhcilcclxuICAgICAgICBjb25zdCBzQnRuID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG4ke2Jhc2VTdHlsZX1cclxud2lkdGg6ICR7cHhYKG9iaiwgdyl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgaCl9O1xyXG5iYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yfTtcclxuY29sb3I6ICR7Y29sb3JUZXh0b307XHJcbmZvbnQtc2l6ZTogY2FsYygke3NCdG59ICogJHtmb250U2l6ZX1weCk7XHJcbmZvbnQtZmFtaWx5OiAke2ZvbnRGYW1pbHl9O1xyXG5mb250LXdlaWdodDogJHtmb250V2VpZ2h0fTtcclxuZm9udC1zdHlsZTogJHtmb250U3R5bGV9O1xyXG50ZXh0LWRlY29yYXRpb246ICR7dGV4dERlY29yYXRpb259O1xyXG50ZXh0LWFsaWduOiAke2FsaWdufTtcclxuZGlzcGxheTogZmxleDtcclxuYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzQnRufSAqIDhweCk7XHJcbmN1cnNvcjogcG9pbnRlcjtcclxuYC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGh0bWxSc3ZwID0gYFxuPGRpdiBjbGFzcz1cIm9iamV0byBpcy1pbnRlcmFjdGl2ZSByc3ZwLWJvdG9uXCJcbiAgaWQ9XCJhYnJpck1vZGFsUlNWUFwiXG4gIGRhdGEtYWNjaW9uPVwiYWJyaXItcnN2cFwiXG4gIGRhdGEtcnN2cC1vcGVuXHJcbiAgcm9sZT1cImJ1dHRvblwiXHJcbiAgdGFiaW5kZXg9XCIwXCJcclxuICBhcmlhLWxhYmVsPVwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIlxyXG4gIHN0eWxlPVwiJHtzdHlsZX1cIj5cclxuICAke3RleHRvfVxuPC9kaXY+XG5gLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGFwcGVuZE1vdGlvbkRhdGFBdHRycyhodG1sUnN2cCwgb2JqKTtcbiAgICAgIH1cblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tIEZPUk1BUyAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGlmICh0aXBvID09PSBcImZvcm1hXCIpIHtcclxuICAgICAgICBjb25zdCBmaWxsID0gb2JqLmNvbG9yIHx8IFwiIzAwMFwiO1xyXG4gICAgICAgIGNvbnN0IGZpZ3VyYSA9IG9iai5maWd1cmE7XHJcblxyXG4gICAgICAgIGlmIChmaWd1cmEgPT09IFwicmVjdFwiKSB7XHJcbiAgICAgICAgICBjb25zdCB3ID0gTnVtYmVyLmlzRmluaXRlKG9iaj8ud2lkdGgpID8gb2JqLndpZHRoIDogMTAwO1xyXG4gICAgICAgICAgY29uc3QgaCA9IE51bWJlci5pc0Zpbml0ZShvYmo/LmhlaWdodCkgPyBvYmouaGVpZ2h0IDogMTAwO1xyXG4gICAgICAgICAgY29uc3QgY29ybmVyUmFkaXVzID0gb2JqLmNvcm5lclJhZGl1cyB8fCAwO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gb2JqLmZvbnRTaXplIHx8IDI0O1xyXG4gICAgICAgICAgY29uc3QgZm9udEZhbWlseSA9IG9iai5mb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwiO1xyXG4gICAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IG9iai5mb250V2VpZ2h0IHx8IFwibm9ybWFsXCI7XHJcbiAgICAgICAgICBjb25zdCBmb250U3R5bGUgPSBvYmouZm9udFN0eWxlIHx8IFwibm9ybWFsXCI7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IG9iai50ZXh0RGVjb3JhdGlvbiB8fCBcIm5vbmVcIjtcclxuICAgICAgICAgIGNvbnN0IGFsaWduID0gb2JqLmFsaWduIHx8IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICBjb25zdCBjb2xvclRleHRvID0gb2JqLmNvbG9yVGV4dG8gfHwgXCIjMDAwMDAwXCI7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0byA9IGVzY0hUTUwob2JqLnRleHRvIHx8IFwiXCIpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IHN0eWxlUG9zQmFzZShvYmopO1xyXG4gICAgICAgICAgY29uc3Qgc1JlY3RUZXh0ID0gaXNGdWxsQmxlZWQob2JqKSA/IFwidmFyKC0tc3gpXCIgOiBzQ29udGVuaWRvVmFyKG9iaik7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBgXHJcbiR7YmFzZVN0eWxlfVxyXG53aWR0aDogJHtweFgob2JqLCB3KX07XHJcbmhlaWdodDogJHtweFkob2JqLCBoKX07XHJcbmJhY2tncm91bmQ6ICR7ZmlsbH07XHJcbmJvcmRlci1yYWRpdXM6IGNhbGMoJHtzUmVjdFRleHR9ICogJHtjb3JuZXJSYWRpdXN9cHgpO1xyXG5kaXNwbGF5OiBmbGV4O1xyXG5hbGlnbi1pdGVtczogY2VudGVyO1xyXG5qdXN0aWZ5LWNvbnRlbnQ6ICR7YWxpZ24gPT09IFwibGVmdFwiID8gXCJmbGV4LXN0YXJ0XCIgOiBhbGlnbiA9PT0gXCJyaWdodFwiID8gXCJmbGV4LWVuZFwiIDogXCJjZW50ZXJcIlxyXG4gICAgICAgICAgICB9O1xyXG50ZXh0LWFsaWduOiAke2FsaWdufTtcclxucGFkZGluZzogY2FsYygke3NSZWN0VGV4dH0gKiA0cHgpO1xyXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBpbm5lciA9IGBcclxuPGRpdiBzdHlsZT1cIlxyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIGZvbnQtc2l6ZTogY2FsYygke3NSZWN0VGV4dH0gKiAke2ZvbnRTaXplfXB4KTtcclxuICBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTtcclxuICBmb250LXdlaWdodDogJHtmb250V2VpZ2h0fTtcclxuICBmb250LXN0eWxlOiAke2ZvbnRTdHlsZX07XHJcbiAgdGV4dC1kZWNvcmF0aW9uOiAke3RleHREZWNvcmF0aW9ufTtcclxuICBjb2xvcjogJHtjb2xvclRleHRvfTtcclxuICBsaW5lLWhlaWdodDogMS4yO1xyXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcclxuICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xyXG5cIj4ke3RleHRvfTwvZGl2PlxyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGRpdiBjbGFzcz1cIm9iamV0b1wiIHN0eWxlPVwiJHtzdHlsZX1cIj4ke2lubmVyfTwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcImNpcmNsZVwiKSB7XHJcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUob2JqPy5yYWRpdXMpID8gb2JqLnJhZGl1cyA6IDUwO1xyXG4gICAgICAgICAgY29uc3QgZGlhbWV0ZXIgPSByYWRpdXMgKiAyO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHggPSBOdW1iZXIob2JqPy54IHx8IDApIC0gcmFkaXVzO1xyXG4gICAgICAgICAgY29uc3QgeVB4Q2VudGVyID0gZ2V0WVB4RWRpdG9yKG9iaik7XHJcbiAgICAgICAgICBjb25zdCB5UHhUb3BMZWZ0ID0geVB4Q2VudGVyIC0gcmFkaXVzO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJvdCA9IG9iaj8ucm90YXRpb24gPz8gMDtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gYFxyXG5wb3NpdGlvbjogYWJzb2x1dGU7XHJcbmxlZnQ6ICR7cHhYKG9iaiwgeCl9O1xyXG50b3A6ICR7dG9wQ1NTRnJvbVlQeChvYmosIHlQeFRvcExlZnQpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgZGlhbWV0ZXIpfTtcclxuaGVpZ2h0OiAke3B4WShvYmosIGRpYW1ldGVyKX07XHJcbmJvcmRlci1yYWRpdXM6IDUwJTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtyb3R9ZGVnKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSk7XHJcbnRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XHJcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xyXG5gLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZW52b2x2ZXJTaUVubGFjZShgPGRpdiBjbGFzcz1cIm9iamV0b1wiIHN0eWxlPVwiJHtzdHlsZX1cIj48L2Rpdj5gLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZpZ3VyYSA9PT0gXCJsaW5lXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHBvaW50cyA9IG9iai5wb2ludHMgfHwgWzAsIDAsIExJTkVfQ09OU1RBTlRTLkRFRkFVTFRfTEVOR1RILCAwXTtcclxuICAgICAgICAgIGNvbnN0IHgxID0gcGFyc2VGbG9hdChwb2ludHNbMF0pIHx8IDA7XHJcbiAgICAgICAgICBjb25zdCB5MSA9IHBhcnNlRmxvYXQocG9pbnRzWzFdKSB8fCAwO1xyXG4gICAgICAgICAgY29uc3QgeDIgPSBwYXJzZUZsb2F0KHBvaW50c1syXSkgfHwgTElORV9DT05TVEFOVFMuREVGQVVMVF9MRU5HVEg7XHJcbiAgICAgICAgICBjb25zdCB5MiA9IHBhcnNlRmxvYXQocG9pbnRzWzNdKSB8fCAwO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb2JqLnN0cm9rZVdpZHRoIHx8IExJTkVfQ09OU1RBTlRTLlNUUk9LRV9XSURUSDtcclxuXHJcbiAgICAgICAgICBjb25zdCBkZWx0YVggPSB4MiAtIHgxO1xyXG4gICAgICAgICAgY29uc3QgZGVsdGFZID0geTIgLSB5MTtcclxuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xyXG4gICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGRlbHRhWSwgZGVsdGFYKSAqICgxODAgLyBNYXRoLlBJKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdGFydFggPSBOdW1iZXIob2JqPy54IHx8IDApICsgeDE7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVkgPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGJhc2VZICsgeTE7XHJcblxyXG4gICAgICAgICAgY29uc3QgdG90YWxSb3RhdGlvbiA9IGFuZ2xlICsgKG9iai5yb3RhdGlvbiB8fCAwKTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IG9iaj8uc2NhbGVYID8/IDE7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBvYmo/LnNjYWxlWSA/PyAxO1xyXG5cclxuICAgICAgICAgIC8vIGFsdG8gZGUgbMOtbmVhOiB1c2Ftb3MgZXNjYWxhIFkgZGVsIG9iamV0byAoY29udGVuaWRvOiBzZmluYWwvc3gsIGJsZWVkOiBzeClcclxuICAgICAgICAgIGNvbnN0IGxpbmVIID0gYGNhbGMoJHtzWShvYmopfSAqICR7c3Ryb2tlV2lkdGh9cHgpYDtcclxuXHJcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGBcclxucG9zaXRpb246IGFic29sdXRlO1xyXG5sZWZ0OiAke3B4WChvYmosIHN0YXJ0WCl9O1xyXG50b3A6ICR7dG9wQ1NTRnJvbVlQeChvYmosIHN0YXJ0WSl9O1xyXG53aWR0aDogJHtweFgob2JqLCBsZW5ndGgpfTtcclxuaGVpZ2h0OiAke2xpbmVIfTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHt0b3RhbFJvdGF0aW9ufWRlZykgc2NhbGUoJHtzY2FsZVh9LCAke3NjYWxlWX0pO1xyXG50cmFuc2Zvcm0tb3JpZ2luOiAwIDUwJTtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvIGxpbmVhXCIgc3R5bGU9XCIke3N0eWxlfVwiPjwvZGl2PmAsIG9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlndXJhID09PSBcInRyaWFuZ2xlXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IG9iai5yYWRpdXMgfHwgNjA7XHJcblxyXG4gICAgICAgICAgY29uc3Qgc2luNjAgPSBNYXRoLnNxcnQoMykgLyAyO1xyXG4gICAgICAgICAgY29uc3QgY29zNjAgPSAwLjU7XHJcblxyXG4gICAgICAgICAgY29uc3QgdHJpYW5nbGVXaWR0aCA9IDIgKiByYWRpdXMgKiBzaW42MDtcclxuICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlSGVpZ2h0ID0gcmFkaXVzICogKDEgKyBjb3M2MCk7XHJcbiAgICAgICAgICBjb25zdCBjZW50cm9pZE9mZnNldFkgPSB0cmlhbmdsZUhlaWdodCAvIDM7XHJcblxyXG4gICAgICAgICAgY29uc3QgYmFzZVkgPSBnZXRZUHhFZGl0b3Iob2JqKTtcclxuICAgICAgICAgIGNvbnN0IHRvcENvbnRhaW5lclB4ID0gYmFzZVkgLSAodHJpYW5nbGVIZWlnaHQgLSBjZW50cm9pZE9mZnNldFkpO1xyXG4gICAgICAgICAgY29uc3QgbGVmdENvbnRhaW5lciA9IE51bWJlcihvYmo/LnggfHwgMCkgLSB0cmlhbmdsZVdpZHRoIC8gMjtcclxuXHJcbiAgICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBgXHJcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcclxubGVmdDogJHtweFgob2JqLCBsZWZ0Q29udGFpbmVyKX07XHJcbnRvcDogJHt0b3BDU1NGcm9tWVB4KG9iaiwgdG9wQ29udGFpbmVyUHgpfTtcclxud2lkdGg6ICR7cHhYKG9iaiwgdHJpYW5nbGVXaWR0aCl9O1xyXG5oZWlnaHQ6ICR7cHhZKG9iaiwgdHJpYW5nbGVIZWlnaHQpfTtcclxuYmFja2dyb3VuZDogJHtmaWxsfTtcclxuY2xpcC1wYXRoOiBwb2x5Z29uKDUwJSAwJSwgMCUgMTAwJSwgMTAwJSAxMDAlKTtcclxudHJhbnNmb3JtOiByb3RhdGUoJHtvYmoucm90YXRpb24gPz8gMH1kZWcpIHNjYWxlKCR7b2JqLnNjYWxlWCA/PyAxfSwgJHtvYmouc2NhbGVZID8/IDF9KTtcclxudHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcclxucG9pbnRlci1ldmVudHM6IGF1dG87XHJcbmAudHJpbSgpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBlbnZvbHZlclNpRW5sYWNlKGA8ZGl2IGNsYXNzPVwib2JqZXRvXCIgc3R5bGU9XCIke2Jhc2VTdHlsZX1cIj48L2Rpdj5gLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfSlcclxuICAgIC5qb2luKFwiXFxuXCIpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJMSU5FX0NPTlNUQU5UUyIsImVzY0hUTUwiLCJzdHIiLCJTdHJpbmciLCJyZXBsYWNlIiwiZXNjYXBlQXR0ciIsIk1PVElPTl9FRkZFQ1RfVkFMVUVTIiwiU2V0Iiwic2FuaXRpemVNb3Rpb25FZmZlY3QiLCJ2YWx1ZSIsIm5vcm1hbGl6ZWQiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJoYXMiLCJub3JtYWxpemVSb2xlVmFsdWUiLCJtYXBPYmpUb0RhdGFUeXBlIiwib2JqIiwidGlwbyIsImZpZ3VyYSIsImluZmVyRGF0YVJvbGUiLCJleHBsaWNpdFJvbGUiLCJyb2xlIiwicm9sIiwidHlwZSIsImZvbnRTaXplIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJidWlsZE1vdGlvbkRhdGFBdHRycyIsImRhdGFUeXBlIiwiZGF0YVJvbGUiLCJkYXRhTW90aW9uIiwibW90aW9uRWZmZWN0IiwiYXBwZW5kTW90aW9uRGF0YUF0dHJzIiwiaHRtbEVsZW1lbnRvIiwiYXR0cnMiLCJnZXRMaW5rUHJvcHMiLCJyYXciLCJlbmxhY2UiLCJocmVmIiwidGFyZ2V0IiwicmVsIiwiZW52b2x2ZXJTaUVubGFjZSIsImh0bWxDb25EYXRhIiwibGluayIsImVzY2FwZUhUTUwiLCJ0ZXh0byIsImdlbmVyYXJIVE1MRGVzZGVPYmpldG9zIiwib2JqZXRvcyIsIl9zZWNjaW9uZXMiLCJhbHRvTW9kb1BvclNlY2Npb24iLCJNYXAiLCJtYXAiLCJzIiwiaWQiLCJhbHRvTW9kbyIsImVzU2VjY2lvblBhbnRhbGxhIiwibW9kbyIsImdldCIsInNlY2Npb25JZCIsImlzRnVsbEJsZWVkIiwiYW5jbGFqZSIsInNDb250ZW5pZG9WYXIiLCJzWCIsInNZIiwicHhYIiwicHgiLCJuIiwicHhZIiwiQUxUVVJBX0VESVRPUl9QQU5UQUxMQSIsIlBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFgiLCJjbGFtcDAxIiwieCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJnZXRZUHhFZGl0b3IiLCJ5biIsInlOb3JtIiwieVB4IiwieSIsInRvcFBhbnRhbGxhQ1NTIiwieW5SYXciLCJ5QmxvcXVlRGlzZW5pbyIsInlCYXNlUGFudGFsbGEiLCJ5bkNvbXBhY3RhZG8iLCJ0b3BDU1MiLCJ5UHhFZGl0b3IiLCJ0b3BDU1NGcm9tWVB4Iiwic3R5bGVQb3NCYXNlIiwicm90Iiwicm90YXRpb24iLCJzY2FsZVgiLCJzY2FsZVkiLCJ6SW5kZXgiLCJ1bmRlZmluZWQiLCJzdHlsZVNpemUiLCJ3IiwiaCIsInd3IiwiaGgiLCJwYXJ0cyIsInB1c2giLCJqb2luIiwicmVuZGVySWNvbm9TdmdOdWV2b0lubGluZSIsInZpZXdCb3giLCJjb2xvciIsInBhdGhzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwid2lkdGgiLCJoZWlnaHQiLCJwYXRoc0h0bWwiLCJwIiwiZCIsInN0eWxlIiwiYWxpZ24iLCJ0ZXh0QWxpZ24iLCJjb2xvclRleHRvIiwiZmlsbCIsImJhc2VMaW5lSGVpZ2h0IiwibGluZUhlaWdodCIsImxpbmVIZWlnaHRGaW5hbCIsInNhZmVUZXh0byIsImJhc2VTdHlsZSIsImZzIiwic0ZvbnQiLCJvcmlnaW4iLCJmb250RmFtaWx5IiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsInRleHREZWNvcmF0aW9uIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzaGFkb3dDb2xvciIsInNoYWRvd09mZnNldFgiLCJzaGFkb3dPZmZzZXRZIiwic2hhZG93Qmx1ciIsInNyYyIsInVybCIsImZvcm1hdG8iLCJzdmdIdG1sIiwidmIiLCJzdmciLCJ0YXJnZXRJU08iLCJmZWNoYU9iamV0aXZvIiwiZmVjaGFJU08iLCJ0ZXh0Q29sb3IiLCJwcmVzZXQiLCJwcmVzZXRJZCIsImxheW91dCIsImlzTWluaW1hbCIsImluY2x1ZGVzIiwid09iaiIsImhPYmoiLCJnYXAiLCJzcGFjaW5nIiwiY2hpcFdpZHRoUHJvcCIsImNoaXBXaWR0aCIsInBhZGRpbmdYUHJvcCIsInBhZGRpbmdYIiwiY2hpcFdUb3RhbCIsInJvdW5kIiwicGFkZGluZ1kiLCJ2YWx1ZVNpemUiLCJsYWJlbFNpemUiLCJsYWJlbENvbG9yIiwibGV0dGVyU3BhY2luZyIsImNvbnRhaW5lckJnRmluYWwiLCJjaGlwQmdGaW5hbCIsImNoaXBCYWNrZ3JvdW5kIiwiYm94QmciLCJjaGlwQm9yZGVyQ29sb3JGaW5hbCIsImNoaXBCb3JkZXIiLCJib3hCb3JkZXIiLCJjb250YWluZXJSYWRpdXMiLCJib3hSYWRpdXMiLCJyYWRpdXMiLCJjaGlwUmFkaXVzRmluYWwiLCJjaGlwUmFkaXVzIiwic0NoaXAiLCJjb250YWluZXJTdHlsZSIsImNoaXBTdHlsZSIsInZhbHVlU3R5bGUiLCJsYWJlbFN0eWxlIiwic2hvd0xhYmVscyIsImxhYmVscyIsImRpYXMiLCJob3JhcyIsInNlZyIsImh0bWxDb3VudGRvd24iLCJyb3dzIiwicGFyc2VJbnQiLCJjb2xzIiwiZ2FwUHgiLCJyYWRpdXNQeCIsInNHcmlkIiwic3R5bGVDb250ZW5lZG9yIiwidG90YWwiLCJjZWxscyIsImZyb20iLCJfIiwiaSIsImMiLCJtZWRpYVVybCIsImZpdCIsImJnIiwiaHRtbENlbGRhcyIsImNlbGwiLCJpZHgiLCJzYWZlU3JjIiwiY2VsZGFTdHlsZSIsImh0bWxHYWxlcmlhIiwiYW5jaG8iLCJhbHRvIiwic0J0biIsImh0bWxSc3ZwIiwiY29ybmVyUmFkaXVzIiwic1JlY3RUZXh0IiwiaW5uZXIiLCJkaWFtZXRlciIsInlQeENlbnRlciIsInlQeFRvcExlZnQiLCJwb2ludHMiLCJERUZBVUxUX0xFTkdUSCIsIngxIiwicGFyc2VGbG9hdCIsInkxIiwieDIiLCJ5MiIsIlNUUk9LRV9XSURUSCIsImRlbHRhWCIsImRlbHRhWSIsInNxcnQiLCJhbmdsZSIsImF0YW4yIiwiUEkiLCJzdGFydFgiLCJiYXNlWSIsInN0YXJ0WSIsInRvdGFsUm90YXRpb24iLCJsaW5lSCIsInNpbjYwIiwiY29zNjAiLCJ0cmlhbmdsZVdpZHRoIiwidHJpYW5nbGVIZWlnaHQiLCJjZW50cm9pZE9mZnNldFkiLCJ0b3BDb250YWluZXJQeCIsImxlZnRDb250YWluZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeObjetos.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeSecciones.ts":
/*!**********************************************************!*\
  !*** ./functions/src/utils/generarHTMLDesdeSecciones.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarHTMLDesdeSecciones: () => (/* binding */ generarHTMLDesdeSecciones)\n/* harmony export */ });\n/* harmony import */ var _generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generarHTMLDesdeObjetos */ \"(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeObjetos.ts\");\n/* harmony import */ var _models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/dimensionesBase */ \"(pages-dir-browser)/./functions/src/models/dimensionesBase.ts\");\n/* harmony import */ var _generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generarModalRSVP */ \"(pages-dir-browser)/./functions/src/utils/generarModalRSVP.ts\");\n/* harmony import */ var _generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generarModalGaleria */ \"(pages-dir-browser)/./functions/src/utils/generarModalGaleria.ts\");\n/* harmony import */ var _mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mobileSmartSectionLayout */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartSectionLayout.ts\");\n/* harmony import */ var _generarMotionEffectsRuntime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generarMotionEffectsRuntime */ \"(pages-dir-browser)/./functions/src/utils/generarMotionEffectsRuntime.ts\");\n/* harmony import */ var _generarInvitationLoaderRuntime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./generarInvitationLoaderRuntime */ \"(pages-dir-browser)/./functions/src/utils/generarInvitationLoaderRuntime.ts\");\n\n\n\n\n\n\n\nconst ENABLE_MOBILE_SMART_LAYOUT = true; // ✅ empezamos apagado\nconst EXCLUDE_FONTS = new Set([\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\",\n    \"Arial\",\n    \"Helvetica\",\n    \"Times\",\n    \"Times New Roman\",\n    \"Georgia\",\n    \"Courier New\"\n]);\nconst ALTURA_REFERENCIA_PANTALLA = 500;\n// ✅ Offsets SOLO para texto en secciones Pantalla: ON\n// - Desktop: aplica cuando vw > 767px\n// - Mobile: aplica cuando vw <= 767px\n// (Estos valores se vuelcan a CSS variables en :root)\nconst PANTALLA_Y_OFFSET_DESKTOP_PX = 0;\nconst PANTALLA_Y_OFFSET_MOBILE_PX = 0;\nfunction buildGoogleFontsLink(fonts) {\n    const familias = fonts.map((f)=>f.replace(/['\"]/g, \"\").split(\",\")[0].trim()).filter((n)=>n && !EXCLUDE_FONTS.has(n)).map((n)=>\"family=\".concat(n.replace(/ /g, \"+\"))).join(\"&\");\n    if (!familias) return \"\";\n    return '\\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\\n<link href=\"https://fonts.googleapis.com/css2?'.concat(familias, '&display=swap\" rel=\"stylesheet\">').trim();\n}\nfunction escapeAttr() {\n    let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    return String(str).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction buildFondoStyle(seccion) {\n    const fondoValue = (seccion === null || seccion === void 0 ? void 0 : seccion.fondo) || \"transparent\";\n    const esImagenFondo = (seccion === null || seccion === void 0 ? void 0 : seccion.fondoTipo) === \"imagen\" && (seccion === null || seccion === void 0 ? void 0 : seccion.fondoImagen);\n    let estilosFondo = \"\";\n    if (esImagenFondo) {\n        let imageUrl = seccion.fondoImagen;\n        if (imageUrl && imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        let backgroundPosition = \"center center\";\n        if (seccion.fondoImagenOffsetX !== undefined || seccion.fondoImagenOffsetY !== undefined) {\n            const offsetX = seccion.fondoImagenOffsetX || 0;\n            const offsetY = seccion.fondoImagenOffsetY || 0;\n            const offsetXPercent = offsetX !== 0 ? \"calc(50% - \".concat(-offsetX, \"px)\") : \"50%\";\n            const offsetYPercent = offsetY !== 0 ? \"calc(50% - \".concat(-offsetY, \"px)\") : \"50%\";\n            backgroundPosition = \"\".concat(offsetXPercent, \" \").concat(offsetYPercent);\n        }\n        estilosFondo = \"background-image: url('\".concat(imageUrl, \"'); background-size: cover; background-position: \").concat(backgroundPosition, \"; background-repeat: no-repeat;\");\n    } else if (fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\")) {\n        let imageUrl = fondoValue.replace(\"url(\", \"\").replace(\")\", \"\");\n        if (imageUrl.includes(\"firebasestorage.googleapis.com\") && !imageUrl.includes(\"alt=media\")) {\n            imageUrl = imageUrl + (imageUrl.includes(\"?\") ? \"&\" : \"?\") + \"alt=media\";\n        }\n        estilosFondo = \"background-image: url('\".concat(imageUrl, \"'); background-size: cover; background-position: center center; background-repeat: no-repeat;\");\n    } else {\n        estilosFondo = \"background: \".concat(fondoValue, \";\");\n    }\n    return estilosFondo.replace(/\\s+/g, \" \").trim();\n}\nfunction hasImageBackground(seccion) {\n    if ((seccion === null || seccion === void 0 ? void 0 : seccion.fondoTipo) === \"imagen\" && (seccion === null || seccion === void 0 ? void 0 : seccion.fondoImagen)) return true;\n    const fondoValue = typeof (seccion === null || seccion === void 0 ? void 0 : seccion.fondo) === \"string\" ? seccion.fondo.trim() : \"\";\n    return fondoValue.startsWith(\"http\") || fondoValue.startsWith(\"data:\") || fondoValue.startsWith(\"blob:\");\n}\nfunction generarHTMLDesdeSecciones(secciones, objetos, rsvp, opciones, opts) {\n    var _opciones_slug;\n    const slug = (_opciones_slug = opciones === null || opciones === void 0 ? void 0 : opciones.slug) !== null && _opciones_slug !== void 0 ? _opciones_slug : \"\";\n    var _opts_slug;\n    const slugPublica = (_opts_slug = opts === null || opts === void 0 ? void 0 : opts.slug) !== null && _opts_slug !== void 0 ? _opts_slug : \"\";\n    const fuentesUsadas = [\n        ...new Set(objetos.filter((o)=>(o.tipo === \"texto\" || o.tipo === \"countdown\") && o.fontFamily).map((o)=>o.fontFamily))\n    ];\n    const googleFontsLink = buildGoogleFontsLink(fuentesUsadas);\n    const hayRSVPEnCanvas = objetos === null || objetos === void 0 ? void 0 : objetos.some((o)=>o.tipo === \"rsvp-boton\");\n    const botonRSVP = \"\"; // (si querés agregar un botón fijo fuera del canvas, hacelo acá)\n    const modalRSVP = hayRSVPEnCanvas && (rsvp === null || rsvp === void 0 ? void 0 : rsvp.enabled) ? (0,_generarModalRSVP__WEBPACK_IMPORTED_MODULE_2__.generarModalRSVPHTML)(rsvp) : \"\";\n    const modalGaleria = (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.hayGaleriaConImagenes)(objetos) ? (0,_generarModalGaleria__WEBPACK_IMPORTED_MODULE_3__.generarModalGaleriaHTML)() : \"\";\n    const invitationLoaderRuntime = (0,_generarInvitationLoaderRuntime__WEBPACK_IMPORTED_MODULE_6__.generarInvitationLoaderRuntimeHTML)();\n    const motionEffectsRuntime = (0,_generarMotionEffectsRuntime__WEBPACK_IMPORTED_MODULE_5__.generarMotionEffectsRuntimeHTML)();\n    function hayCountdown(objs) {\n        return Array.isArray(objs) && objs.some((o)=>(o === null || o === void 0 ? void 0 : o.tipo) === \"countdown\");\n    }\n    const scriptCountdown = hayCountdown(objetos) ? '\\n<script>\\n(function(){\\n  function pad(n){ n=Math.floor(Math.abs(n)); return n<10 ? \"0\"+n : \"\"+n; }\\n  function diffParts(target){\\n    const now = Date.now();\\n    let ms = Math.max(0, target.getTime() - now);\\n    const d = Math.floor(ms / 86400000); ms -= d*86400000;\\n    const h = Math.floor(ms / 3600000);  ms -= h*3600000;\\n    const m = Math.floor(ms / 60000);    ms -= m*60000;\\n    const s = Math.floor(ms / 1000);\\n    return { d, h, m, s };\\n  }\\n  function tickOne(root){\\n    const iso = root.getAttribute(\"data-target\");\\n    if(!iso) return;\\n    const t = new Date(iso);\\n    if(isNaN(t.getTime())) return;\\n    const p = diffParts(t);\\n    const vals = root.querySelectorAll(\".cd-val\");\\n    if(vals && vals.length >= 4){\\n      vals[0].textContent = String(p.d).padStart(2,\"0\");\\n      vals[1].textContent = pad(p.h);\\n      vals[2].textContent = pad(p.m);\\n      vals[3].textContent = pad(p.s);\\n    }\\n  }\\n  function boot(){\\n    const roots = Array.from(document.querySelectorAll(\"[data-countdown]\"));\\n    if(!roots.length) return;\\n    roots.forEach(tickOne);\\n    setInterval(() => roots.forEach(tickOne), 1000);\\n  }\\n  if(document.readyState === \"loading\"){\\n    document.addEventListener(\"DOMContentLoaded\", boot);\\n  } else {\\n    boot();\\n  }\\n})();\\n</script>\\n'.trim() : \"\";\n    const seccionesOrdenadas = [\n        ...secciones || []\n    ].sort((a, b)=>(Number(a === null || a === void 0 ? void 0 : a.orden) || 0) - (Number(b === null || b === void 0 ? void 0 : b.orden) || 0));\n    const htmlSecciones = seccionesOrdenadas.map((seccion)=>{\n        const modo = String((seccion === null || seccion === void 0 ? void 0 : seccion.altoModo) || \"fijo\").toLowerCase();\n        const hbase = Number.isFinite(seccion === null || seccion === void 0 ? void 0 : seccion.altura) ? Number(seccion.altura) : 600;\n        const fondoEsImagen = hasImageBackground(seccion);\n        const objsDeSeccion = objetos.filter((o)=>o.seccionId === seccion.id);\n        const objsBleed = objsDeSeccion.filter((o)=>String((o === null || o === void 0 ? void 0 : o.anclaje) || \"\").toLowerCase() === \"fullbleed\");\n        const objsContenido = objsDeSeccion.filter((o)=>String((o === null || o === void 0 ? void 0 : o.anclaje) || \"\").toLowerCase() !== \"fullbleed\");\n        const fondoStyle = buildFondoStyle(seccion);\n        const htmlBleed = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsBleed, seccionesOrdenadas);\n        const htmlContenido = (0,_generarHTMLDesdeObjetos__WEBPACK_IMPORTED_MODULE_0__.generarHTMLDesdeObjetos)(objsContenido, seccionesOrdenadas);\n        return '\\n<section class=\"sec\" data-modo=\"'.concat(escapeAttr(modo), '\" data-fondo=\"').concat(fondoEsImagen ? \"imagen\" : \"color\", '\" style=\"--hbase:').concat(hbase, '\">\\n  <div class=\"sec-zoom\">\\n    <div class=\"sec-bg\" style=\"').concat(fondoStyle, '\"></div>\\n    <div class=\"sec-bleed\">').concat(htmlBleed, '</div>\\n    <div class=\"sec-content\">').concat(htmlContenido, \"</div>\\n  </div>\\n</section>\\n\").trim();\n    }).join(\"\\n\");\n    const scriptMobileSmart = (0,_mobileSmartSectionLayout__WEBPACK_IMPORTED_MODULE_4__.buildMobileSmartSectionLayoutScript)({\n        enabled: ENABLE_MOBILE_SMART_LAYOUT,\n        minGapPx: 1,\n        paddingTopPx: 0,\n        paddingBottomPx: 2,\n        onlyFixedSections: true,\n        minPerColumn2: 1,\n        fitMinScale: 0.88,\n        fitMaxScale: 1.16,\n        fitTargetWidthRatio: 0.94,\n        fitMinFillRatio: 0.9\n    });\n    return '\\n<!DOCTYPE html>\\n<html lang=\"es\"'.concat(slug ? ' data-slug=\"'.concat(escapeAttr(slug), '\"') : \"\", '>\\n<head>\\n  <meta charset=\"UTF-8\" />\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\" />\\n  <title>Invitaci\\xf3n</title>\\n  ').concat(googleFontsLink, \"\\n  <style>\\n    * { box-sizing: border-box; margin: 0; padding: 0; }\\n\\n    html, body {\\n      width: 100%;\\n      height: 100%;\\n      background: white;\\n      overflow-x: hidden;\\n      font-family: sans-serif;\\n    }\\n\\n    /* ✅ SOLO MOBILE: evita “auto-resize / font boosting” del texto */\\n    @media (max-width: 767px){\\n      html{\\n        -webkit-text-size-adjust: 100%;\\n        text-size-adjust: 100%;\\n      }\\n      \\n        :root{ --text-zoom: 1; }\\n    }\\n\\n    :root{\\n      --safe-top: env(safe-area-inset-top, 0px);\\n      --safe-right: env(safe-area-inset-right, 0px);\\n      --safe-bottom: env(safe-area-inset-bottom, 0px);\\n      --safe-left: env(safe-area-inset-left, 0px);\\n      --bp-mobile: 767px;\\n      \\n\\n\\n      /* Global scales */\\n      --content-w: \").concat(_models_dimensionesBase__WEBPACK_IMPORTED_MODULE_1__.CANVAS_BASE.ANCHO, \"px;\\n      --sx: 1;   /* contentW/800 */\\n      --bx: 1;   /* viewportW/800 */\\n\\n      /* vh l\\xf3gico por defecto */\\n      --vh-safe: 100vh;\\n      --vh-logical: var(--vh-safe);\\n      --pantalla-y-compact: 0;\\n      --pantalla-y-base: 0px;\\n\\n      /* ✅ Offset SOLO para texto en Pantalla: ON (desktop default) */\\n      --pantalla-y-offset: \").concat(PANTALLA_Y_OFFSET_DESKTOP_PX, \"px;\\n    }\\n\\n    /* ✅ Mobile: offset distinto SOLO para texto en Pantalla: ON */\\n    @media (max-width: 767px){\\n      :root{\\n        --pantalla-y-offset: \").concat(PANTALLA_Y_OFFSET_MOBILE_PX, 'px;\\n      }\\n    }\\n\\n    .inv{ width: 100%; background: white; }\\n\\n    .sec{\\n      position: relative;\\n      width: 100vw;\\n      left: 50%;\\n      transform: translateX(-50%);\\n      overflow: visible; /* bleed puede salirse */\\n    }\\n\\n    /* ✅ Wrapper que hace “zoom” centrado (evita corrimiento a la derecha) */\\n    .sec-zoom{\\n      position: relative;\\n      width: 100%;\\n      height: 100%;\\n      transform-origin: top center;\\n      transform: scale(var(--zoom, 1));\\n    }\\n\\n    /* ✅ Pantalla ON: recorte para que el zoom no desborde */\\n    .sec[data-modo=\"pantalla\"]{\\n      overflow: hidden;\\n      height: 100dvh;\\n      height: 100vh;\\n      padding-top: var(--safe-top);\\n      padding-bottom: var(--safe-bottom);\\n\\n      /* fallback CSS (JS lo pisa en mobile con px reales) */\\n      --vh-safe: calc(100dvh - var(--safe-top) - var(--safe-bottom));\\n\\n      /* el zoom extra va por --zoom (NO por sfinal) */\\n      --zoom: 1;\\n      --bgzoom: 1;\\n\\n      /* factor final para CONTENIDO (se setea por JS) */\\n      --sfinal: 1;\\n    }\\n\\n    .sec[data-modo=\"fijo\"]{\\n      /* altura fija escalada por ancho; JS setea --sfinal = sx */\\n      height: calc(var(--sfinal) * var(--hbase) * 1px);\\n      --zoom: 1;\\n      --bgzoom: 1;\\n    }\\n\\n    /* Fondo */\\n    .sec-bg{\\n      position: absolute;\\n      inset: 0;\\n      z-index: 0;\\n      pointer-events: none;\\n    }\\n\\n    /* ✅ Fondo agrandable solo en pantalla (acompa\\xf1a el zoom hero) */\\n    .sec[data-modo=\"pantalla\"] .sec-bg{\\n      transform: scale(var(--bgzoom, 1));\\n      transform-origin: center;\\n    }\\n\\n    /* ✅ En fondos de imagen, compensamos desde el mismo origen que el wrapper */\\n    .sec[data-modo=\"pantalla\"][data-fondo=\"imagen\"] .sec-bg{\\n      transform-origin: top center;\\n    }\\n\\n    .sec-bleed{\\n      position: absolute;\\n      inset: 0;\\n      z-index: 2;\\n      overflow: visible;\\n      pointer-events: none;\\n    }\\n\\n    .sec-content{\\n      position: relative;\\n      z-index: 3;\\n      width: var(--content-w);\\n      margin: 0 auto;\\n      height: 100%;\\n      pointer-events: none;\\n    }\\n\\n    /* ✅ Pantalla ON: el ancho del “content” puede crecer con la escala vertical */\\n    .sec[data-modo=\"pantalla\"] .sec-content{\\n      width: var(--content-w-pantalla, var(--content-w));\\n    }\\n\\n    @media (max-width: 767px){\\n      .sec-content{\\n        width: 100%;\\n        margin: 0;\\n        box-sizing: border-box;\\n        padding-left: var(--safe-left);\\n        padding-right: var(--safe-right);\\n      }\\n    }\\n\\n    .objeto{\\n      position: absolute;\\n      transform-origin: top left;\\n      overflow: visible;\\n      pointer-events: auto;\\n    }\\n\\n    .objeto[data-debug-texto=\"1\"]{\\n      -webkit-font-smoothing: antialiased;\\n      text-rendering: optimizeLegibility;\\n    }\\n\\n    .objeto.is-interactive{ pointer-events: auto; }\\n\\n    .cd-chip { backdrop-filter: saturate(1.1); }\\n  </style>\\n</head>\\n\\n<body data-loader-ready=\"0\" data-slug=\"').concat(escapeAttr(slugPublica), '\">\\n  ').concat(invitationLoaderRuntime, '\\n  <div class=\"inv\">\\n    ').concat(htmlSecciones, \"\\n  </div>\\n\\n  \").concat(botonRSVP, \"\\n  \").concat(modalRSVP, \"\\n  \").concat(modalGaleria, \"\\n  \").concat(motionEffectsRuntime, \"\\n\\n  \").concat(scriptCountdown, '\\n\\n  <script>\\n    (function(){\\n      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }\\n\\n      function compute(){\\n        var vw = document.documentElement.clientWidth;\\n        var BASE_W = 800; // = CANVAS_BASE.ANCHO\\n\\n        // contentW (sin vw-32)\\n        var contentW = Math.min(BASE_W, vw);\\n\\n        var sx = contentW / BASE_W;\\n        var bx = vw / BASE_W;\\n\\n        document.documentElement.style.setProperty(\"--content-w\", contentW + \"px\");\\n        document.documentElement.style.setProperty(\"--sx\", String(sx));\\n        document.documentElement.style.setProperty(\"--bx\", String(bx));\\n\\n        var secs = Array.from(document.querySelectorAll(\".sec\"));\\n        var isMobile = vw <= 767;\\n\\n        // viewport real (m\\xe1s estable en mobile)\\n        var vv = window.visualViewport;\\n        var viewportH = (vv && vv.height) ? vv.height : window.innerHeight;\\n\\n        // safe areas (css env)\\n        var safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-top\")) || 0;\\n        var safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--safe-bottom\")) || 0;\\n\\n        // dise\\xf1o base del modo \"pantalla\" (800 x 500)\\n        var DESIGN_W = BASE_W;\\n        var DESIGN_H = ').concat(ALTURA_REFERENCIA_PANTALLA, '; // = ALTURA_REFERENCIA_PANTALLA\\n        var designAR = DESIGN_H / DESIGN_W; // 0.625\\n        var deviceAR = viewportH / vw;\\n\\n        // zoom extra (solo si el device es m\\xe1s vertical que el dise\\xf1o)\\n        var zoomExtra = 1;\\n        if (isMobile && deviceAR > designAR){\\n          var k = deviceAR / designAR;\\n          zoomExtra = clamp(1 + (k - 1) * 0.18, 1, 1.35);\\n        }\\n\\n        // \\uD83D\\uDD27 Ajuste fino: cu\\xe1nto mantiene el zoom visual del fondo en mobile/pantalla.\\n        // 0   => el fondo se compensa para verse similar a desktop.\\n        // 1   => comportamiento anterior (fondo acompa\\xf1a completo el zoom del hero).\\n        // 0.3 => compensaci\\xf3n parcial.\\n        var BG_ZOOM_FACTOR = 0;\\n\\n        // \\uD83D\\uDD27 Ajuste fino: cu\\xe1nto acompa\\xf1a el CONTENIDO (texto/objetos) al zoom hero\\n        // 0   => comportamiento actual\\n        // 0.3 => recomendado\\n        // 1   => texto escala igual que el hero (no aconsejado)\\n        var TEXT_ZOOM_FACTOR = 0;\\n\\n\\n        secs.forEach(function(sec){\\n          var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n          var fondoTipo = (sec.getAttribute(\"data-fondo\") || \"color\").toLowerCase();\\n\\n          // defaults\\n          var zoom = 1;\\n          var bgzoom = 1;\\n\\n          // ✅ Por defecto, tama\\xf1os escalan por ancho (comportamiento actual)\\n          var sfinal = sx;\\n          var pantallaYCompact = 0;\\n          var pantallaYBasePx = 0;\\n\\n          // limpiar custom width si no aplica\\n          sec.style.removeProperty(\"--content-w-pantalla\");\\n\\n          if (modo === \"pantalla\"){\\n            // vh-safe real en px\\n            var vhSafePx = Math.max(0, viewportH - safeTop - safeBottom);\\n            sec.style.setProperty(\"--vh-safe\", vhSafePx + \"px\");\\n\\n            // \\uD83D\\uDD25 Desktop: escalar el contenido por ALTURA (vhSafe/500)\\n            // Esto alinea el HTML publicado con lo que ves en preview\\n            if (!isMobile){\\n              var sh = vhSafePx / DESIGN_H;\\n              sfinal = sh;\\n\\n              // para que el \"content\" quede centrado y coherente con la nueva escala vertical\\n              sec.style.setProperty(\"--content-w-pantalla\", (DESIGN_W * sh) + \"px\");\\n            }\\n\\n            // ✅ Mobile: mantenemos tu comportamiento actual (zoom hero suave)\\n            if (isMobile){\\n              zoom = zoomExtra;\\n              var bgVisualZoom = 1 + (zoomExtra - 1) * BG_ZOOM_FACTOR;\\n              if (fondoTipo === \"imagen\") {\\n                bgzoom = bgVisualZoom / Math.max(0.01, zoom);\\n              } else {\\n                bgzoom = bgVisualZoom;\\n              }\\n\\n              // \\uD83D\\uDD25 NUEVO: el contenido acompa\\xf1a parcialmente el zoom\\n              sfinal = sx * (1 + (zoomExtra - 1) * TEXT_ZOOM_FACTOR);\\n\\n              // ✅ Fidelity de dise\\xf1o en Pantalla:ON:\\n              // no compactamos distancias verticales para respetar posiciones\\n              // intencionales (incluyendo textos encimados o muy cercanos).\\n              pantallaYCompact = 0;\\n\\n              // ✅ Ajuste de posici\\xf3n vertical global (uniforme):\\n              // desplazamos TODO el bloque por igual para no alterar posiciones relativas.\\n              var vhLogicalPx = vhSafePx / Math.max(0.01, zoom || 1);\\n              var designScaledHPx = sfinal * DESIGN_H;\\n              var spareVerticalPx = Math.max(0, vhLogicalPx - designScaledHPx);\\n              pantallaYBasePx = spareVerticalPx * 0.36;\\n            }\\n          }\\n\\n          sec.style.setProperty(\"--sfinal\", String(sfinal));\\n          sec.style.setProperty(\"--zoom\", String(zoom));\\n          sec.style.setProperty(\"--bgzoom\", String(bgzoom));\\n\\n          // ✅ Solo en mobile + pantalla: corregir el \"vh\" que despu\\xe9s se escala con zoom\\n          if (isMobile && modo === \"pantalla\") {\\n            // --vh-logical = --vh-safe / --zoom\\n            sec.style.setProperty(\"--vh-logical\", \"calc(var(--vh-safe) / var(--zoom))\");\\n          } else {\\n            // resto: se comporta como siempre\\n            sec.style.setProperty(\"--vh-logical\", \"var(--vh-safe)\");\\n          }\\n          sec.style.setProperty(\"--pantalla-y-compact\", String(pantallaYCompact));\\n          sec.style.setProperty(\"--pantalla-y-base\", pantallaYBasePx + \"px\");\\n        });\\n\\n\\n      }\\n\\n      window.addEventListener(\"load\", compute);\\n      window.addEventListener(\"resize\", compute);\\n\\n      if (window.visualViewport){\\n        window.visualViewport.addEventListener(\"resize\", compute);\\n        window.visualViewport.addEventListener(\"scroll\", compute);\\n      }\\n\\n      window.addEventListener(\"orientationchange\", function(){\\n        setTimeout(compute, 50);\\n        setTimeout(compute, 250);\\n      });\\n\\n      compute();\\n    })();\\n  </script>\\n\\n    \\n\\n\\n   ').concat(scriptMobileSmart, \"\\n \\n</body>\\n</html>\\n\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvRTtBQUNaO0FBQ2tDO0FBQ0g7QUFDTjtBQUNEO0FBQ007QUFFdEYsTUFBTVEsNkJBQTZCLE1BQU0sc0JBQXNCO0FBRS9ELE1BQU1DLGdCQUFnQixJQUFJQyxJQUFJO0lBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsNkJBQTZCO0FBRW5DLHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxNQUFNQywrQkFBK0I7QUFDckMsTUFBTUMsOEJBQThCO0FBRXBDLFNBQVNDLHFCQUFxQkMsS0FBZTtJQUMzQyxNQUFNQyxXQUFXRCxNQUNkRSxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsT0FBTyxDQUFDLFNBQVMsSUFBSUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLElBQUksSUFDcERDLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxLQUFLLENBQUNkLGNBQWNlLEdBQUcsQ0FBQ0QsSUFDdENOLEdBQUcsQ0FBQyxDQUFDTSxJQUFNLFVBQStCLE9BQXJCQSxFQUFFSixPQUFPLENBQUMsTUFBTSxPQUNyQ00sSUFBSSxDQUFDO0lBRVIsSUFBSSxDQUFDVCxVQUFVLE9BQU87SUFFdEIsT0FBTyx5SEFFZ0QsT0FBVEEsVUFBUyxvQ0FBa0NLLElBQUk7QUFDL0Y7QUFNQSxTQUFTSztRQUFXQyxNQUFBQSxpRUFBYztJQUNoQyxPQUFPQyxPQUFPRCxLQUNYUixPQUFPLENBQUMsTUFBTSxTQUNkQSxPQUFPLENBQUMsTUFBTSxVQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTTtBQUNuQjtBQUVBLFNBQVNVLGdCQUFnQkMsT0FBWTtJQUNuQyxN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RyxLQUFLLEVBQUMsOFZBaUJSL0YsT0FORkQsOEJBQTZCLGtLQTRIakJjLE9BdEhWYiw2QkFBNEIsczZGQXVIdkR1RCxPQURxQzFDLFdBQVc4QixjQUFhLFVBRzNEeUIsT0FGRmIseUJBQXdCLCtCQUt4QkosT0FIRWlCLGVBQWMsb0JBSWhCaEIsT0FEQUQsV0FBVSxRQUVWRyxPQURBRixXQUFVLFFBRVZJLE9BREFGLGNBQWEsUUFHYk8sT0FGQUwsc0JBQXFCLFVBbUNBMUQsT0FqQ3JCK0QsaUJBQWdCLDJ3Q0EwSmZ3QixPQXpIb0J2Riw0QkFBMkIsMHVKQXlIN0IsT0FBbEJ1RixtQkFBa0I7QUFLdkIiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhckhUTUxEZXNkZVNlY2Npb25lcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmFySFRNTERlc2RlT2JqZXRvcyB9IGZyb20gXCIuL2dlbmVyYXJIVE1MRGVzZGVPYmpldG9zXCI7XHJcbmltcG9ydCB7IENBTlZBU19CQVNFIH0gZnJvbSBcIi4uL21vZGVscy9kaW1lbnNpb25lc0Jhc2VcIjtcclxuaW1wb3J0IHsgZ2VuZXJhck1vZGFsUlNWUEhUTUwsIHR5cGUgUlNWUENvbmZpZyBhcyBNb2RhbENvbmZpZyB9IGZyb20gXCIuL2dlbmVyYXJNb2RhbFJTVlBcIjtcclxuaW1wb3J0IHsgZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwsIGhheUdhbGVyaWFDb25JbWFnZW5lcyB9IGZyb20gXCIuL2dlbmVyYXJNb2RhbEdhbGVyaWFcIjtcclxuaW1wb3J0IHsgYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQgfSBmcm9tIFwiLi9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRcIjtcclxuaW1wb3J0IHsgZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lSFRNTCB9IGZyb20gXCIuL2dlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZVwiO1xyXG5pbXBvcnQgeyBnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIH0gZnJvbSBcIi4vZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lXCI7XHJcblxyXG5jb25zdCBFTkFCTEVfTU9CSUxFX1NNQVJUX0xBWU9VVCA9IHRydWU7IC8vIOKchSBlbXBlemFtb3MgYXBhZ2Fkb1xyXG5cclxuY29uc3QgRVhDTFVERV9GT05UUyA9IG5ldyBTZXQoW1xyXG4gIFwic2VyaWZcIixcclxuICBcInNhbnMtc2VyaWZcIixcclxuICBcIm1vbm9zcGFjZVwiLFxyXG4gIFwiY3Vyc2l2ZVwiLFxyXG4gIFwiZmFudGFzeVwiLFxyXG4gIFwic3lzdGVtLXVpXCIsXHJcbiAgXCJBcmlhbFwiLFxyXG4gIFwiSGVsdmV0aWNhXCIsXHJcbiAgXCJUaW1lc1wiLFxyXG4gIFwiVGltZXMgTmV3IFJvbWFuXCIsXHJcbiAgXCJHZW9yZ2lhXCIsXHJcbiAgXCJDb3VyaWVyIE5ld1wiLFxyXG5dKTtcclxuXHJcbmNvbnN0IEFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBID0gNTAwO1xyXG5cclxuLy8g4pyFIE9mZnNldHMgU09MTyBwYXJhIHRleHRvIGVuIHNlY2Npb25lcyBQYW50YWxsYTogT05cclxuLy8gLSBEZXNrdG9wOiBhcGxpY2EgY3VhbmRvIHZ3ID4gNzY3cHhcclxuLy8gLSBNb2JpbGU6IGFwbGljYSBjdWFuZG8gdncgPD0gNzY3cHhcclxuLy8gKEVzdG9zIHZhbG9yZXMgc2UgdnVlbGNhbiBhIENTUyB2YXJpYWJsZXMgZW4gOnJvb3QpXHJcbmNvbnN0IFBBTlRBTExBX1lfT0ZGU0VUX0RFU0tUT1BfUFggPSAwO1xuY29uc3QgUEFOVEFMTEFfWV9PRkZTRVRfTU9CSUxFX1BYID0gMDtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlRm9udHNMaW5rKGZvbnRzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgY29uc3QgZmFtaWxpYXMgPSBmb250c1xyXG4gICAgLm1hcCgoZikgPT4gZi5yZXBsYWNlKC9bJ1wiXS9nLCBcIlwiKS5zcGxpdChcIixcIilbMF0udHJpbSgpKVxyXG4gICAgLmZpbHRlcigobikgPT4gbiAmJiAhRVhDTFVERV9GT05UUy5oYXMobikpXHJcbiAgICAubWFwKChuKSA9PiBgZmFtaWx5PSR7bi5yZXBsYWNlKC8gL2csIFwiK1wiKX1gKVxyXG4gICAgLmpvaW4oXCImXCIpO1xyXG5cclxuICBpZiAoIWZhbWlsaWFzKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgcmV0dXJuIGBcclxuPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tXCIgY3Jvc3NvcmlnaW4+XHJcbjxsaW5rIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/JHtmYW1pbGlhc30mZGlzcGxheT1zd2FwXCIgcmVsPVwic3R5bGVzaGVldFwiPmAudHJpbSgpO1xyXG59XHJcblxyXG50eXBlIEdlbmVyYXJIVE1MT3BjaW9uZXMgPSB7XG4gIHNsdWc/OiBzdHJpbmc7XG59O1xuXHJcbmZ1bmN0aW9uIGVzY2FwZUF0dHIoc3RyOiBzdHJpbmcgPSBcIlwiKTogc3RyaW5nIHtcclxuICByZXR1cm4gU3RyaW5nKHN0cilcclxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcclxuICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxyXG4gICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkRm9uZG9TdHlsZShzZWNjaW9uOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBmb25kb1ZhbHVlID0gc2VjY2lvbj8uZm9uZG8gfHwgXCJ0cmFuc3BhcmVudFwiO1xuICBjb25zdCBlc0ltYWdlbkZvbmRvID0gc2VjY2lvbj8uZm9uZG9UaXBvID09PSBcImltYWdlblwiICYmIHNlY2Npb24/LmZvbmRvSW1hZ2VuO1xuXHJcbiAgbGV0IGVzdGlsb3NGb25kbyA9IFwiXCI7XHJcblxyXG4gIGlmIChlc0ltYWdlbkZvbmRvKSB7XHJcbiAgICBsZXQgaW1hZ2VVcmwgPSBzZWNjaW9uLmZvbmRvSW1hZ2VuO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgaW1hZ2VVcmwgJiZcclxuICAgICAgaW1hZ2VVcmwuaW5jbHVkZXMoXCJmaXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb21cIikgJiZcclxuICAgICAgIWltYWdlVXJsLmluY2x1ZGVzKFwiYWx0PW1lZGlhXCIpXHJcbiAgICApIHtcclxuICAgICAgaW1hZ2VVcmwgPSBpbWFnZVVybCArIChpbWFnZVVybC5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiKSArIFwiYWx0PW1lZGlhXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGJhY2tncm91bmRQb3NpdGlvbiA9IFwiY2VudGVyIGNlbnRlclwiO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgc2VjY2lvbi5mb25kb0ltYWdlbk9mZnNldFggIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WSAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IHNlY2Npb24uZm9uZG9JbWFnZW5PZmZzZXRYIHx8IDA7XHJcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBzZWNjaW9uLmZvbmRvSW1hZ2VuT2Zmc2V0WSB8fCAwO1xyXG5cclxuICAgICAgY29uc3Qgb2Zmc2V0WFBlcmNlbnQgPSBvZmZzZXRYICE9PSAwID8gYGNhbGMoNTAlIC0gJHstb2Zmc2V0WH1weClgIDogXCI1MCVcIjtcclxuICAgICAgY29uc3Qgb2Zmc2V0WVBlcmNlbnQgPSBvZmZzZXRZICE9PSAwID8gYGNhbGMoNTAlIC0gJHstb2Zmc2V0WX1weClgIDogXCI1MCVcIjtcclxuXHJcbiAgICAgIGJhY2tncm91bmRQb3NpdGlvbiA9IGAke29mZnNldFhQZXJjZW50fSAke29mZnNldFlQZXJjZW50fWA7XHJcbiAgICB9XHJcblxyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgnJHtpbWFnZVVybH0nKTsgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjsgYmFja2dyb3VuZC1wb3NpdGlvbjogJHtiYWNrZ3JvdW5kUG9zaXRpb259OyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O2A7XHJcbiAgfSBlbHNlIGlmIChcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImh0dHBcIikgfHxcclxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImRhdGE6XCIpIHx8XHJcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJibG9iOlwiKVxyXG4gICkge1xyXG4gICAgbGV0IGltYWdlVXJsID0gZm9uZG9WYWx1ZS5yZXBsYWNlKFwidXJsKFwiLCBcIlwiKS5yZXBsYWNlKFwiKVwiLCBcIlwiKTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIGltYWdlVXJsLmluY2x1ZGVzKFwiZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tXCIpICYmXHJcbiAgICAgICFpbWFnZVVybC5pbmNsdWRlcyhcImFsdD1tZWRpYVwiKVxyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlVXJsID0gaW1hZ2VVcmwgKyAoaW1hZ2VVcmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIikgKyBcImFsdD1tZWRpYVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGVzdGlsb3NGb25kbyA9IGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJyR7aW1hZ2VVcmx9Jyk7IGJhY2tncm91bmQtc2l6ZTogY292ZXI7IGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7YDtcclxuICB9IGVsc2Uge1xyXG4gICAgZXN0aWxvc0ZvbmRvID0gYGJhY2tncm91bmQ6ICR7Zm9uZG9WYWx1ZX07YDtcclxuICB9XHJcblxuICByZXR1cm4gZXN0aWxvc0ZvbmRvLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gaGFzSW1hZ2VCYWNrZ3JvdW5kKHNlY2Npb246IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoc2VjY2lvbj8uZm9uZG9UaXBvID09PSBcImltYWdlblwiICYmIHNlY2Npb24/LmZvbmRvSW1hZ2VuKSByZXR1cm4gdHJ1ZTtcblxuICBjb25zdCBmb25kb1ZhbHVlID0gdHlwZW9mIHNlY2Npb24/LmZvbmRvID09PSBcInN0cmluZ1wiID8gc2VjY2lvbi5mb25kby50cmltKCkgOiBcIlwiO1xuICByZXR1cm4gKFxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImh0dHBcIikgfHxcbiAgICBmb25kb1ZhbHVlLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fFxuICAgIGZvbmRvVmFsdWUuc3RhcnRzV2l0aChcImJsb2I6XCIpXG4gICk7XG59XG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJIVE1MRGVzZGVTZWNjaW9uZXMoXG4gIHNlY2Npb25lczogYW55W10sXG4gIG9iamV0b3M6IGFueVtdLFxuICByc3ZwPzogTW9kYWxDb25maWcsXG4gIG9wY2lvbmVzPzogR2VuZXJhckhUTUxPcGNpb25lcyxcclxuICBvcHRzPzogeyBzbHVnPzogc3RyaW5nIH1cclxuKTogc3RyaW5nIHtcbiAgY29uc3Qgc2x1ZyA9IG9wY2lvbmVzPy5zbHVnID8/IFwiXCI7XG4gIGNvbnN0IHNsdWdQdWJsaWNhID0gb3B0cz8uc2x1ZyA/PyBcIlwiO1xuXHJcbiAgY29uc3QgZnVlbnRlc1VzYWRhcyA9IFtcclxuICAgIC4uLm5ldyBTZXQoXHJcbiAgICAgIG9iamV0b3NcclxuICAgICAgICAuZmlsdGVyKChvKSA9PiAoby50aXBvID09PSBcInRleHRvXCIgfHwgby50aXBvID09PSBcImNvdW50ZG93blwiKSAmJiBvLmZvbnRGYW1pbHkpXHJcbiAgICAgICAgLm1hcCgobykgPT4gby5mb250RmFtaWx5KVxyXG4gICAgKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnb29nbGVGb250c0xpbmsgPSBidWlsZEdvb2dsZUZvbnRzTGluayhmdWVudGVzVXNhZGFzKTtcclxuXHJcbiAgY29uc3QgaGF5UlNWUEVuQ2FudmFzID0gb2JqZXRvcz8uc29tZSgobykgPT4gby50aXBvID09PSBcInJzdnAtYm90b25cIik7XHJcbiAgY29uc3QgYm90b25SU1ZQID0gXCJcIjsgLy8gKHNpIHF1ZXLDqXMgYWdyZWdhciB1biBib3TDs24gZmlqbyBmdWVyYSBkZWwgY2FudmFzLCBoYWNlbG8gYWPDoSlcclxuICBjb25zdCBtb2RhbFJTVlAgPSBoYXlSU1ZQRW5DYW52YXMgJiYgcnN2cD8uZW5hYmxlZCA/IGdlbmVyYXJNb2RhbFJTVlBIVE1MKHJzdnApIDogXCJcIjtcclxuICBjb25zdCBtb2RhbEdhbGVyaWEgPSBoYXlHYWxlcmlhQ29uSW1hZ2VuZXMob2JqZXRvcykgPyBnZW5lcmFyTW9kYWxHYWxlcmlhSFRNTCgpIDogXCJcIjtcclxuICBjb25zdCBpbnZpdGF0aW9uTG9hZGVyUnVudGltZSA9IGdlbmVyYXJJbnZpdGF0aW9uTG9hZGVyUnVudGltZUhUTUwoKTtcclxuICBjb25zdCBtb3Rpb25FZmZlY3RzUnVudGltZSA9IGdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwoKTtcclxuXHJcbiAgZnVuY3Rpb24gaGF5Q291bnRkb3duKG9ianM6IGFueVtdKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmpzKSAmJiBvYmpzLnNvbWUoKG8pID0+IG8/LnRpcG8gPT09IFwiY291bnRkb3duXCIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2NyaXB0Q291bnRkb3duID0gaGF5Q291bnRkb3duKG9iamV0b3MpXHJcbiAgICA/IGBcclxuPHNjcmlwdD5cclxuKGZ1bmN0aW9uKCl7XHJcbiAgZnVuY3Rpb24gcGFkKG4peyBuPU1hdGguZmxvb3IoTWF0aC5hYnMobikpOyByZXR1cm4gbjwxMCA/IFwiMFwiK24gOiBcIlwiK247IH1cclxuICBmdW5jdGlvbiBkaWZmUGFydHModGFyZ2V0KXtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgbXMgPSBNYXRoLm1heCgwLCB0YXJnZXQuZ2V0VGltZSgpIC0gbm93KTtcclxuICAgIGNvbnN0IGQgPSBNYXRoLmZsb29yKG1zIC8gODY0MDAwMDApOyBtcyAtPSBkKjg2NDAwMDAwO1xyXG4gICAgY29uc3QgaCA9IE1hdGguZmxvb3IobXMgLyAzNjAwMDAwKTsgIG1zIC09IGgqMzYwMDAwMDtcclxuICAgIGNvbnN0IG0gPSBNYXRoLmZsb29yKG1zIC8gNjAwMDApOyAgICBtcyAtPSBtKjYwMDAwO1xyXG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IobXMgLyAxMDAwKTtcclxuICAgIHJldHVybiB7IGQsIGgsIG0sIHMgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdGlja09uZShyb290KXtcclxuICAgIGNvbnN0IGlzbyA9IHJvb3QuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIik7XHJcbiAgICBpZighaXNvKSByZXR1cm47XHJcbiAgICBjb25zdCB0ID0gbmV3IERhdGUoaXNvKTtcclxuICAgIGlmKGlzTmFOKHQuZ2V0VGltZSgpKSkgcmV0dXJuO1xyXG4gICAgY29uc3QgcCA9IGRpZmZQYXJ0cyh0KTtcclxuICAgIGNvbnN0IHZhbHMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2QtdmFsXCIpO1xyXG4gICAgaWYodmFscyAmJiB2YWxzLmxlbmd0aCA+PSA0KXtcclxuICAgICAgdmFsc1swXS50ZXh0Q29udGVudCA9IFN0cmluZyhwLmQpLnBhZFN0YXJ0KDIsXCIwXCIpO1xyXG4gICAgICB2YWxzWzFdLnRleHRDb250ZW50ID0gcGFkKHAuaCk7XHJcbiAgICAgIHZhbHNbMl0udGV4dENvbnRlbnQgPSBwYWQocC5tKTtcclxuICAgICAgdmFsc1szXS50ZXh0Q29udGVudCA9IHBhZChwLnMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBib290KCl7XHJcbiAgICBjb25zdCByb290cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNvdW50ZG93bl1cIikpO1xyXG4gICAgaWYoIXJvb3RzLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgcm9vdHMuZm9yRWFjaCh0aWNrT25lKTtcclxuICAgIHNldEludGVydmFsKCgpID0+IHJvb3RzLmZvckVhY2godGlja09uZSksIDEwMDApO1xyXG4gIH1cclxuICBpZihkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIil7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBib290KTtcclxuICB9IGVsc2Uge1xyXG4gICAgYm9vdCgpO1xyXG4gIH1cclxufSkoKTtcclxuPC9zY3JpcHQ+XHJcbmAudHJpbSgpXHJcbiAgICA6IFwiXCI7XHJcblxyXG4gIGNvbnN0IHNlY2Npb25lc09yZGVuYWRhcyA9IFsuLi4oc2VjY2lvbmVzIHx8IFtdKV0uc29ydChcclxuICAgIChhLCBiKSA9PiAoTnVtYmVyKGE/Lm9yZGVuKSB8fCAwKSAtIChOdW1iZXIoYj8ub3JkZW4pIHx8IDApXHJcbiAgKTtcclxuXHJcblxyXG4gIGNvbnN0IGh0bWxTZWNjaW9uZXMgPSBzZWNjaW9uZXNPcmRlbmFkYXNcbiAgICAubWFwKChzZWNjaW9uKSA9PiB7XG4gICAgICBjb25zdCBtb2RvID0gU3RyaW5nKHNlY2Npb24/LmFsdG9Nb2RvIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaGJhc2UgPSBOdW1iZXIuaXNGaW5pdGUoc2VjY2lvbj8uYWx0dXJhKSA/IE51bWJlcihzZWNjaW9uLmFsdHVyYSkgOiA2MDA7XG4gICAgICBjb25zdCBmb25kb0VzSW1hZ2VuID0gaGFzSW1hZ2VCYWNrZ3JvdW5kKHNlY2Npb24pO1xuXHJcbiAgICAgIGNvbnN0IG9ianNEZVNlY2Npb24gPSBvYmpldG9zLmZpbHRlcigobykgPT4gby5zZWNjaW9uSWQgPT09IHNlY2Npb24uaWQpO1xyXG5cclxuICAgICAgY29uc3Qgb2Jqc0JsZWVkID0gb2Jqc0RlU2VjY2lvbi5maWx0ZXIoXHJcbiAgICAgICAgKG8pID0+IFN0cmluZyhvPy5hbmNsYWplIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiZnVsbGJsZWVkXCJcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgb2Jqc0NvbnRlbmlkbyA9IG9ianNEZVNlY2Npb24uZmlsdGVyKFxyXG4gICAgICAgIChvKSA9PiBTdHJpbmcobz8uYW5jbGFqZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpICE9PSBcImZ1bGxibGVlZFwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBmb25kb1N0eWxlID0gYnVpbGRGb25kb1N0eWxlKHNlY2Npb24pO1xyXG5cclxuICAgICAgY29uc3QgaHRtbEJsZWVkID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0JsZWVkLCBzZWNjaW9uZXNPcmRlbmFkYXMpO1xyXG4gICAgICBjb25zdCBodG1sQ29udGVuaWRvID0gZ2VuZXJhckhUTUxEZXNkZU9iamV0b3Mob2Jqc0NvbnRlbmlkbywgc2VjY2lvbmVzT3JkZW5hZGFzKTtcclxuXHJcblxuICAgICAgcmV0dXJuIGBcbjxzZWN0aW9uIGNsYXNzPVwic2VjXCIgZGF0YS1tb2RvPVwiJHtlc2NhcGVBdHRyKG1vZG8pfVwiIGRhdGEtZm9uZG89XCIke2ZvbmRvRXNJbWFnZW4gPyBcImltYWdlblwiIDogXCJjb2xvclwifVwiIHN0eWxlPVwiLS1oYmFzZToke2hiYXNlfVwiPlxuICA8ZGl2IGNsYXNzPVwic2VjLXpvb21cIj5cbiAgICA8ZGl2IGNsYXNzPVwic2VjLWJnXCIgc3R5bGU9XCIke2ZvbmRvU3R5bGV9XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNlYy1ibGVlZFwiPiR7aHRtbEJsZWVkfTwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzZWMtY29udGVudFwiPiR7aHRtbENvbnRlbmlkb308L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5gLnRyaW0oKTtcclxuICAgIH0pXHJcbiAgICAuam9pbihcIlxcblwiKTtcclxuXHJcbiAgY29uc3Qgc2NyaXB0TW9iaWxlU21hcnQgPSBidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCh7XHJcbiAgICBlbmFibGVkOiBFTkFCTEVfTU9CSUxFX1NNQVJUX0xBWU9VVCxcclxuICAgIG1pbkdhcFB4OiAxLFxyXG4gICAgcGFkZGluZ1RvcFB4OiAwLFxyXG4gICAgcGFkZGluZ0JvdHRvbVB4OiAyLFxyXG4gICAgb25seUZpeGVkU2VjdGlvbnM6IHRydWUsXHJcbiAgICBtaW5QZXJDb2x1bW4yOiAxLFxyXG4gICAgZml0TWluU2NhbGU6IDAuODgsXHJcbiAgICBmaXRNYXhTY2FsZTogMS4xNixcclxuICAgIGZpdFRhcmdldFdpZHRoUmF0aW86IDAuOTQsXHJcbiAgICBmaXRNaW5GaWxsUmF0aW86IDAuOSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGBcclxuPCFET0NUWVBFIGh0bWw+XG48aHRtbCBsYW5nPVwiZXNcIiR7c2x1ZyA/IGAgZGF0YS1zbHVnPVwiJHtlc2NhcGVBdHRyKHNsdWcpfVwiYCA6IFwiXCJ9PlxuPGhlYWQ+XG4gIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiIC8+XHJcbiAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAsIHZpZXdwb3J0LWZpdD1jb3ZlclwiIC8+XHJcbiAgPHRpdGxlPkludml0YWNpw7NuPC90aXRsZT5cclxuICAke2dvb2dsZUZvbnRzTGlua31cclxuICA8c3R5bGU+XHJcbiAgICAqIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyB9XHJcblxyXG4gICAgaHRtbCwgYm9keSB7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgICBvdmVyZmxvdy14OiBoaWRkZW47XHJcbiAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBTT0xPIE1PQklMRTogZXZpdGEg4oCcYXV0by1yZXNpemUgLyBmb250IGJvb3N0aW5n4oCdIGRlbCB0ZXh0byAqL1xyXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KXtcclxuICAgICAgaHRtbHtcclxuICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XHJcbiAgICAgICAgdGV4dC1zaXplLWFkanVzdDogMTAwJTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICA6cm9vdHsgLS10ZXh0LXpvb206IDE7IH1cbiAgICB9XHJcblxyXG4gICAgOnJvb3R7XHJcbiAgICAgIC0tc2FmZS10b3A6IGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtcmlnaHQ6IGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweCk7XHJcbiAgICAgIC0tc2FmZS1ib3R0b206IGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpO1xyXG4gICAgICAtLXNhZmUtbGVmdDogZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpO1xyXG4gICAgICAtLWJwLW1vYmlsZTogNzY3cHg7XHJcbiAgICAgIFxyXG5cclxuXHJcbiAgICAgIC8qIEdsb2JhbCBzY2FsZXMgKi9cclxuICAgICAgLS1jb250ZW50LXc6ICR7Q0FOVkFTX0JBU0UuQU5DSE99cHg7XHJcbiAgICAgIC0tc3g6IDE7ICAgLyogY29udGVudFcvODAwICovXHJcbiAgICAgIC0tYng6IDE7ICAgLyogdmlld3BvcnRXLzgwMCAqL1xyXG5cclxuICAgICAgLyogdmggbMOzZ2ljbyBwb3IgZGVmZWN0byAqL1xyXG4gICAgICAtLXZoLXNhZmU6IDEwMHZoO1xuICAgICAgLS12aC1sb2dpY2FsOiB2YXIoLS12aC1zYWZlKTtcbiAgICAgIC0tcGFudGFsbGEteS1jb21wYWN0OiAwO1xuICAgICAgLS1wYW50YWxsYS15LWJhc2U6IDBweDtcblxyXG4gICAgICAvKiDinIUgT2Zmc2V0IFNPTE8gcGFyYSB0ZXh0byBlbiBQYW50YWxsYTogT04gKGRlc2t0b3AgZGVmYXVsdCkgKi9cclxuICAgICAgLS1wYW50YWxsYS15LW9mZnNldDogJHtQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYfXB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBNb2JpbGU6IG9mZnNldCBkaXN0aW50byBTT0xPIHBhcmEgdGV4dG8gZW4gUGFudGFsbGE6IE9OICovXHJcbiAgICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpe1xyXG4gICAgICA6cm9vdHtcclxuICAgICAgICAtLXBhbnRhbGxhLXktb2Zmc2V0OiAke1BBTlRBTExBX1lfT0ZGU0VUX01PQklMRV9QWH1weDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC5pbnZ7IHdpZHRoOiAxMDAlOyBiYWNrZ3JvdW5kOiB3aGl0ZTsgfVxyXG5cclxuICAgIC5zZWN7XHJcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgd2lkdGg6IDEwMHZ3O1xyXG4gICAgICBsZWZ0OiA1MCU7XHJcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIGJsZWVkIHB1ZWRlIHNhbGlyc2UgKi9cclxuICAgIH1cclxuXHJcbiAgICAvKiDinIUgV3JhcHBlciBxdWUgaGFjZSDigJx6b29t4oCdIGNlbnRyYWRvIChldml0YSBjb3JyaW1pZW50byBhIGxhIGRlcmVjaGEpICovXHJcbiAgICAuc2VjLXpvb217XHJcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIGNlbnRlcjtcclxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS16b29tLCAxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiByZWNvcnRlIHBhcmEgcXVlIGVsIHpvb20gbm8gZGVzYm9yZGUgKi9cclxuICAgIC5zZWNbZGF0YS1tb2RvPVwicGFudGFsbGFcIl17XHJcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgIGhlaWdodDogMTAwZHZoO1xyXG4gICAgICBoZWlnaHQ6IDEwMHZoO1xyXG4gICAgICBwYWRkaW5nLXRvcDogdmFyKC0tc2FmZS10b3ApO1xyXG4gICAgICBwYWRkaW5nLWJvdHRvbTogdmFyKC0tc2FmZS1ib3R0b20pO1xyXG5cclxuICAgICAgLyogZmFsbGJhY2sgQ1NTIChKUyBsbyBwaXNhIGVuIG1vYmlsZSBjb24gcHggcmVhbGVzKSAqL1xyXG4gICAgICAtLXZoLXNhZmU6IGNhbGMoMTAwZHZoIC0gdmFyKC0tc2FmZS10b3ApIC0gdmFyKC0tc2FmZS1ib3R0b20pKTtcclxuXHJcbiAgICAgIC8qIGVsIHpvb20gZXh0cmEgdmEgcG9yIC0tem9vbSAoTk8gcG9yIHNmaW5hbCkgKi9cclxuICAgICAgLS16b29tOiAxO1xyXG4gICAgICAtLWJnem9vbTogMTtcclxuXHJcbiAgICAgIC8qIGZhY3RvciBmaW5hbCBwYXJhIENPTlRFTklETyAoc2Ugc2V0ZWEgcG9yIEpTKSAqL1xyXG4gICAgICAtLXNmaW5hbDogMTtcclxuICAgIH1cclxuXHJcbiAgICAuc2VjW2RhdGEtbW9kbz1cImZpam9cIl17XHJcbiAgICAgIC8qIGFsdHVyYSBmaWphIGVzY2FsYWRhIHBvciBhbmNobzsgSlMgc2V0ZWEgLS1zZmluYWwgPSBzeCAqL1xyXG4gICAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2ZpbmFsKSAqIHZhcigtLWhiYXNlKSAqIDFweCk7XHJcbiAgICAgIC0tem9vbTogMTtcclxuICAgICAgLS1iZ3pvb206IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyogRm9uZG8gKi9cclxuICAgIC5zZWMtYmd7XHJcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgaW5zZXQ6IDA7XHJcbiAgICAgIHotaW5kZXg6IDA7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIOKchSBGb25kbyBhZ3JhbmRhYmxlIHNvbG8gZW4gcGFudGFsbGEgKGFjb21wYcOxYSBlbCB6b29tIGhlcm8pICovXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWJne1xuICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1iZ3pvb20sIDEpKTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgICB9XG5cbiAgICAvKiDinIUgRW4gZm9uZG9zIGRlIGltYWdlbiwgY29tcGVuc2Ftb3MgZGVzZGUgZWwgbWlzbW8gb3JpZ2VuIHF1ZSBlbCB3cmFwcGVyICovXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXVtkYXRhLWZvbmRvPVwiaW1hZ2VuXCJdIC5zZWMtYmd7XG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgY2VudGVyO1xuICAgIH1cblxyXG4gICAgLnNlYy1ibGVlZHtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICBpbnNldDogMDtcclxuICAgICAgei1pbmRleDogMjtcclxuICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5zZWMtY29udGVudHtcclxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICB6LWluZGV4OiAzO1xyXG4gICAgICB3aWR0aDogdmFyKC0tY29udGVudC13KTtcclxuICAgICAgbWFyZ2luOiAwIGF1dG87XHJcbiAgICAgIGhlaWdodDogMTAwJTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyog4pyFIFBhbnRhbGxhIE9OOiBlbCBhbmNobyBkZWwg4oCcY29udGVudOKAnSBwdWVkZSBjcmVjZXIgY29uIGxhIGVzY2FsYSB2ZXJ0aWNhbCAqL1xyXG4gICAgLnNlY1tkYXRhLW1vZG89XCJwYW50YWxsYVwiXSAuc2VjLWNvbnRlbnR7XHJcbiAgICAgIHdpZHRoOiB2YXIoLS1jb250ZW50LXctcGFudGFsbGEsIHZhcigtLWNvbnRlbnQtdykpO1xyXG4gICAgfVxyXG5cclxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCl7XHJcbiAgICAgIC5zZWMtY29udGVudHtcclxuICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICBtYXJnaW46IDA7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNhZmUtbGVmdCk7XHJcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2FmZS1yaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAub2JqZXRve1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0b1tkYXRhLWRlYnVnLXRleHRvPVwiMVwiXXtcclxuICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XHJcbiAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLm9iamV0by5pcy1pbnRlcmFjdGl2ZXsgcG9pbnRlci1ldmVudHM6IGF1dG87IH1cclxuXHJcbiAgICAuY2QtY2hpcCB7IGJhY2tkcm9wLWZpbHRlcjogc2F0dXJhdGUoMS4xKTsgfVxyXG4gIDwvc3R5bGU+XHJcbjwvaGVhZD5cclxuXHJcbjxib2R5IGRhdGEtbG9hZGVyLXJlYWR5PVwiMFwiIGRhdGEtc2x1Zz1cIiR7ZXNjYXBlQXR0cihzbHVnUHVibGljYSl9XCI+XHJcbiAgJHtpbnZpdGF0aW9uTG9hZGVyUnVudGltZX1cclxuICA8ZGl2IGNsYXNzPVwiaW52XCI+XHJcbiAgICAke2h0bWxTZWNjaW9uZXN9XHJcbiAgPC9kaXY+XHJcblxyXG4gICR7Ym90b25SU1ZQfVxyXG4gICR7bW9kYWxSU1ZQfVxyXG4gICR7bW9kYWxHYWxlcmlhfVxyXG4gICR7bW90aW9uRWZmZWN0c1J1bnRpbWV9XHJcblxyXG4gICR7c2NyaXB0Q291bnRkb3dufVxyXG5cclxuICA8c2NyaXB0PlxyXG4gICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZ1bmN0aW9uIGNsYW1wKG4sIGEsIGIpeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgbikpOyB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wdXRlKCl7XHJcbiAgICAgICAgdmFyIHZ3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBCQVNFX1cgPSA4MDA7IC8vID0gQ0FOVkFTX0JBU0UuQU5DSE9cclxuXHJcbiAgICAgICAgLy8gY29udGVudFcgKHNpbiB2dy0zMilcclxuICAgICAgICB2YXIgY29udGVudFcgPSBNYXRoLm1pbihCQVNFX1csIHZ3KTtcclxuXHJcbiAgICAgICAgdmFyIHN4ID0gY29udGVudFcgLyBCQVNFX1c7XHJcbiAgICAgICAgdmFyIGJ4ID0gdncgLyBCQVNFX1c7XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tY29udGVudC13XCIsIGNvbnRlbnRXICsgXCJweFwiKTtcclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXN4XCIsIFN0cmluZyhzeCkpO1xyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYnhcIiwgU3RyaW5nKGJ4KSk7XHJcblxyXG4gICAgICAgIHZhciBzZWNzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSk7XHJcbiAgICAgICAgdmFyIGlzTW9iaWxlID0gdncgPD0gNzY3O1xyXG5cclxuICAgICAgICAvLyB2aWV3cG9ydCByZWFsIChtw6FzIGVzdGFibGUgZW4gbW9iaWxlKVxyXG4gICAgICAgIHZhciB2diA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcclxuICAgICAgICB2YXIgdmlld3BvcnRIID0gKHZ2ICYmIHZ2LmhlaWdodCkgPyB2di5oZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHNhZmUgYXJlYXMgKGNzcyBlbnYpXHJcbiAgICAgICAgdmFyIHNhZmVUb3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zYWZlLXRvcFwiKSkgfHwgMDtcclxuICAgICAgICB2YXIgc2FmZUJvdHRvbSA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoXCItLXNhZmUtYm90dG9tXCIpKSB8fCAwO1xyXG5cclxuICAgICAgICAvLyBkaXNlw7FvIGJhc2UgZGVsIG1vZG8gXCJwYW50YWxsYVwiICg4MDAgeCA1MDApXHJcbiAgICAgICAgdmFyIERFU0lHTl9XID0gQkFTRV9XO1xyXG4gICAgICAgIHZhciBERVNJR05fSCA9ICR7QUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEF9OyAvLyA9IEFMVFVSQV9SRUZFUkVOQ0lBX1BBTlRBTExBXHJcbiAgICAgICAgdmFyIGRlc2lnbkFSID0gREVTSUdOX0ggLyBERVNJR05fVzsgLy8gMC42MjVcclxuICAgICAgICB2YXIgZGV2aWNlQVIgPSB2aWV3cG9ydEggLyB2dztcclxuXHJcbiAgICAgICAgLy8gem9vbSBleHRyYSAoc29sbyBzaSBlbCBkZXZpY2UgZXMgbcOhcyB2ZXJ0aWNhbCBxdWUgZWwgZGlzZcOxbylcclxuICAgICAgICB2YXIgem9vbUV4dHJhID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGUgJiYgZGV2aWNlQVIgPiBkZXNpZ25BUil7XHJcbiAgICAgICAgICB2YXIgayA9IGRldmljZUFSIC8gZGVzaWduQVI7XHJcbiAgICAgICAgICB6b29tRXh0cmEgPSBjbGFtcCgxICsgKGsgLSAxKSAqIDAuMTgsIDEsIDEuMzUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g8J+UpyBBanVzdGUgZmlubzogY3XDoW50byBtYW50aWVuZSBlbCB6b29tIHZpc3VhbCBkZWwgZm9uZG8gZW4gbW9iaWxlL3BhbnRhbGxhLlxuICAgICAgICAvLyAwICAgPT4gZWwgZm9uZG8gc2UgY29tcGVuc2EgcGFyYSB2ZXJzZSBzaW1pbGFyIGEgZGVza3RvcC5cbiAgICAgICAgLy8gMSAgID0+IGNvbXBvcnRhbWllbnRvIGFudGVyaW9yIChmb25kbyBhY29tcGHDsWEgY29tcGxldG8gZWwgem9vbSBkZWwgaGVybykuXG4gICAgICAgIC8vIDAuMyA9PiBjb21wZW5zYWNpw7NuIHBhcmNpYWwuXG4gICAgICAgIHZhciBCR19aT09NX0ZBQ1RPUiA9IDA7XG5cclxuICAgICAgICAvLyDwn5SnIEFqdXN0ZSBmaW5vOiBjdcOhbnRvIGFjb21wYcOxYSBlbCBDT05URU5JRE8gKHRleHRvL29iamV0b3MpIGFsIHpvb20gaGVyb1xyXG4gICAgICAgIC8vIDAgICA9PiBjb21wb3J0YW1pZW50byBhY3R1YWxcclxuICAgICAgICAvLyAwLjMgPT4gcmVjb21lbmRhZG9cclxuICAgICAgICAvLyAxICAgPT4gdGV4dG8gZXNjYWxhIGlndWFsIHF1ZSBlbCBoZXJvIChubyBhY29uc2VqYWRvKVxyXG4gICAgICAgIHZhciBURVhUX1pPT01fRkFDVE9SID0gMDtcclxuXHJcblxyXG4gICAgICAgIHNlY3MuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgICAgIHZhciBtb2RvID0gKHNlYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZG9cIikgfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGZvbmRvVGlwbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1mb25kb1wiKSB8fCBcImNvbG9yXCIpLnRvTG93ZXJDYXNlKCk7XG5cclxuICAgICAgICAgIC8vIGRlZmF1bHRzXHJcbiAgICAgICAgICB2YXIgem9vbSA9IDE7XHJcbiAgICAgICAgICB2YXIgYmd6b29tID0gMTtcclxuXHJcbiAgICAgICAgICAvLyDinIUgUG9yIGRlZmVjdG8sIHRhbWHDsW9zIGVzY2FsYW4gcG9yIGFuY2hvIChjb21wb3J0YW1pZW50byBhY3R1YWwpXG4gICAgICAgICAgdmFyIHNmaW5hbCA9IHN4O1xuICAgICAgICAgIHZhciBwYW50YWxsYVlDb21wYWN0ID0gMDtcbiAgICAgICAgICB2YXIgcGFudGFsbGFZQmFzZVB4ID0gMDtcblxyXG4gICAgICAgICAgLy8gbGltcGlhciBjdXN0b20gd2lkdGggc2kgbm8gYXBsaWNhXHJcbiAgICAgICAgICBzZWMuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLWNvbnRlbnQtdy1wYW50YWxsYVwiKTtcclxuXHJcbiAgICAgICAgICBpZiAobW9kbyA9PT0gXCJwYW50YWxsYVwiKXtcclxuICAgICAgICAgICAgLy8gdmgtc2FmZSByZWFsIGVuIHB4XHJcbiAgICAgICAgICAgIHZhciB2aFNhZmVQeCA9IE1hdGgubWF4KDAsIHZpZXdwb3J0SCAtIHNhZmVUb3AgLSBzYWZlQm90dG9tKTtcclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1zYWZlXCIsIHZoU2FmZVB4ICsgXCJweFwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIPCflKUgRGVza3RvcDogZXNjYWxhciBlbCBjb250ZW5pZG8gcG9yIEFMVFVSQSAodmhTYWZlLzUwMClcclxuICAgICAgICAgICAgLy8gRXN0byBhbGluZWEgZWwgSFRNTCBwdWJsaWNhZG8gY29uIGxvIHF1ZSB2ZXMgZW4gcHJldmlld1xyXG4gICAgICAgICAgICBpZiAoIWlzTW9iaWxlKXtcclxuICAgICAgICAgICAgICB2YXIgc2ggPSB2aFNhZmVQeCAvIERFU0lHTl9IO1xyXG4gICAgICAgICAgICAgIHNmaW5hbCA9IHNoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwYXJhIHF1ZSBlbCBcImNvbnRlbnRcIiBxdWVkZSBjZW50cmFkbyB5IGNvaGVyZW50ZSBjb24gbGEgbnVldmEgZXNjYWxhIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1jb250ZW50LXctcGFudGFsbGFcIiwgKERFU0lHTl9XICogc2gpICsgXCJweFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIE1vYmlsZTogbWFudGVuZW1vcyB0dSBjb21wb3J0YW1pZW50byBhY3R1YWwgKHpvb20gaGVybyBzdWF2ZSlcbiAgICAgICAgICAgIGlmIChpc01vYmlsZSl7XG4gICAgICAgICAgICAgIHpvb20gPSB6b29tRXh0cmE7XG4gICAgICAgICAgICAgIHZhciBiZ1Zpc3VhbFpvb20gPSAxICsgKHpvb21FeHRyYSAtIDEpICogQkdfWk9PTV9GQUNUT1I7XG4gICAgICAgICAgICAgIGlmIChmb25kb1RpcG8gPT09IFwiaW1hZ2VuXCIpIHtcbiAgICAgICAgICAgICAgICBiZ3pvb20gPSBiZ1Zpc3VhbFpvb20gLyBNYXRoLm1heCgwLjAxLCB6b29tKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZ3pvb20gPSBiZ1Zpc3VhbFpvb207XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyDwn5SlIE5VRVZPOiBlbCBjb250ZW5pZG8gYWNvbXBhw7FhIHBhcmNpYWxtZW50ZSBlbCB6b29tXG4gICAgICAgICAgICAgIHNmaW5hbCA9IHN4ICogKDEgKyAoem9vbUV4dHJhIC0gMSkgKiBURVhUX1pPT01fRkFDVE9SKTtcblxyXG4gICAgICAgICAgICAgIC8vIOKchSBGaWRlbGl0eSBkZSBkaXNlw7FvIGVuIFBhbnRhbGxhOk9OOlxuICAgICAgICAgICAgICAvLyBubyBjb21wYWN0YW1vcyBkaXN0YW5jaWFzIHZlcnRpY2FsZXMgcGFyYSByZXNwZXRhciBwb3NpY2lvbmVzXG4gICAgICAgICAgICAgIC8vIGludGVuY2lvbmFsZXMgKGluY2x1eWVuZG8gdGV4dG9zIGVuY2ltYWRvcyBvIG11eSBjZXJjYW5vcykuXG4gICAgICAgICAgICAgIHBhbnRhbGxhWUNvbXBhY3QgPSAwO1xuXG4gICAgICAgICAgICAgIC8vIOKchSBBanVzdGUgZGUgcG9zaWNpw7NuIHZlcnRpY2FsIGdsb2JhbCAodW5pZm9ybWUpOlxuICAgICAgICAgICAgICAvLyBkZXNwbGF6YW1vcyBUT0RPIGVsIGJsb3F1ZSBwb3IgaWd1YWwgcGFyYSBubyBhbHRlcmFyIHBvc2ljaW9uZXMgcmVsYXRpdmFzLlxuICAgICAgICAgICAgICB2YXIgdmhMb2dpY2FsUHggPSB2aFNhZmVQeCAvIE1hdGgubWF4KDAuMDEsIHpvb20gfHwgMSk7XG4gICAgICAgICAgICAgIHZhciBkZXNpZ25TY2FsZWRIUHggPSBzZmluYWwgKiBERVNJR05fSDtcbiAgICAgICAgICAgICAgdmFyIHNwYXJlVmVydGljYWxQeCA9IE1hdGgubWF4KDAsIHZoTG9naWNhbFB4IC0gZGVzaWduU2NhbGVkSFB4KTtcbiAgICAgICAgICAgICAgcGFudGFsbGFZQmFzZVB4ID0gc3BhcmVWZXJ0aWNhbFB4ICogMC4zNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cclxuICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tc2ZpbmFsXCIsIFN0cmluZyhzZmluYWwpKTtcclxuICAgICAgICAgIHNlYy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tem9vbVwiLCBTdHJpbmcoem9vbSkpO1xyXG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1iZ3pvb21cIiwgU3RyaW5nKGJnem9vbSkpO1xyXG5cclxuICAgICAgICAgIC8vIOKchSBTb2xvIGVuIG1vYmlsZSArIHBhbnRhbGxhOiBjb3JyZWdpciBlbCBcInZoXCIgcXVlIGRlc3B1w6lzIHNlIGVzY2FsYSBjb24gem9vbVxyXG4gICAgICAgICAgaWYgKGlzTW9iaWxlICYmIG1vZG8gPT09IFwicGFudGFsbGFcIikge1xyXG4gICAgICAgICAgICAvLyAtLXZoLWxvZ2ljYWwgPSAtLXZoLXNhZmUgLyAtLXpvb21cclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1sb2dpY2FsXCIsIFwiY2FsYyh2YXIoLS12aC1zYWZlKSAvIHZhcigtLXpvb20pKVwiKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlc3RvOiBzZSBjb21wb3J0YSBjb21vIHNpZW1wcmVcclxuICAgICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS12aC1sb2dpY2FsXCIsIFwidmFyKC0tdmgtc2FmZSlcIik7XHJcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1wYW50YWxsYS15LWNvbXBhY3RcIiwgU3RyaW5nKHBhbnRhbGxhWUNvbXBhY3QpKTtcbiAgICAgICAgICBzZWMuc3R5bGUuc2V0UHJvcGVydHkoXCItLXBhbnRhbGxhLXktYmFzZVwiLCBwYW50YWxsYVlCYXNlUHggKyBcInB4XCIpO1xuICAgICAgICB9KTtcblxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXB1dGUpO1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjb21wdXRlKTtcclxuXHJcbiAgICAgIGlmICh3aW5kb3cudmlzdWFsVmlld3BvcnQpe1xyXG4gICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNvbXB1dGUpO1xyXG4gICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGNvbXB1dGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgc2V0VGltZW91dChjb21wdXRlLCA1MCk7XHJcbiAgICAgICAgc2V0VGltZW91dChjb21wdXRlLCAyNTApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbXB1dGUoKTtcclxuICAgIH0pKCk7XHJcbiAgPC9zY3JpcHQ+XHJcblxyXG4gICAgXHJcblxyXG5cclxuICAgJHtzY3JpcHRNb2JpbGVTbWFydH1cclxuIFxyXG48L2JvZHk+XHJcbjwvaHRtbD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhckhUTUxEZXNkZU9iamV0b3MiLCJDQU5WQVNfQkFTRSIsImdlbmVyYXJNb2RhbFJTVlBIVE1MIiwiZ2VuZXJhck1vZGFsR2FsZXJpYUhUTUwiLCJoYXlHYWxlcmlhQ29uSW1hZ2VuZXMiLCJidWlsZE1vYmlsZVNtYXJ0U2VjdGlvbkxheW91dFNjcmlwdCIsImdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwiLCJnZW5lcmFySW52aXRhdGlvbkxvYWRlclJ1bnRpbWVIVE1MIiwiRU5BQkxFX01PQklMRV9TTUFSVF9MQVlPVVQiLCJFWENMVURFX0ZPTlRTIiwiU2V0IiwiQUxUVVJBX1JFRkVSRU5DSUFfUEFOVEFMTEEiLCJQQU5UQUxMQV9ZX09GRlNFVF9ERVNLVE9QX1BYIiwiUEFOVEFMTEFfWV9PRkZTRVRfTU9CSUxFX1BYIiwiYnVpbGRHb29nbGVGb250c0xpbmsiLCJmb250cyIsImZhbWlsaWFzIiwibWFwIiwiZiIsInJlcGxhY2UiLCJzcGxpdCIsInRyaW0iLCJmaWx0ZXIiLCJuIiwiaGFzIiwiam9pbiIsImVzY2FwZUF0dHIiLCJzdHIiLCJTdHJpbmciLCJidWlsZEZvbmRvU3R5bGUiLCJzZWNjaW9uIiwiZm9uZG9WYWx1ZSIsImZvbmRvIiwiZXNJbWFnZW5Gb25kbyIsImZvbmRvVGlwbyIsImZvbmRvSW1hZ2VuIiwiZXN0aWxvc0ZvbmRvIiwiaW1hZ2VVcmwiLCJpbmNsdWRlcyIsImJhY2tncm91bmRQb3NpdGlvbiIsImZvbmRvSW1hZ2VuT2Zmc2V0WCIsInVuZGVmaW5lZCIsImZvbmRvSW1hZ2VuT2Zmc2V0WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwib2Zmc2V0WFBlcmNlbnQiLCJvZmZzZXRZUGVyY2VudCIsInN0YXJ0c1dpdGgiLCJoYXNJbWFnZUJhY2tncm91bmQiLCJnZW5lcmFySFRNTERlc2RlU2VjY2lvbmVzIiwic2VjY2lvbmVzIiwib2JqZXRvcyIsInJzdnAiLCJvcGNpb25lcyIsIm9wdHMiLCJzbHVnIiwic2x1Z1B1YmxpY2EiLCJmdWVudGVzVXNhZGFzIiwibyIsInRpcG8iLCJmb250RmFtaWx5IiwiZ29vZ2xlRm9udHNMaW5rIiwiaGF5UlNWUEVuQ2FudmFzIiwic29tZSIsImJvdG9uUlNWUCIsIm1vZGFsUlNWUCIsImVuYWJsZWQiLCJtb2RhbEdhbGVyaWEiLCJpbnZpdGF0aW9uTG9hZGVyUnVudGltZSIsIm1vdGlvbkVmZmVjdHNSdW50aW1lIiwiaGF5Q291bnRkb3duIiwib2JqcyIsIkFycmF5IiwiaXNBcnJheSIsInNjcmlwdENvdW50ZG93biIsInNlY2Npb25lc09yZGVuYWRhcyIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm9yZGVuIiwiaHRtbFNlY2Npb25lcyIsIm1vZG8iLCJhbHRvTW9kbyIsInRvTG93ZXJDYXNlIiwiaGJhc2UiLCJpc0Zpbml0ZSIsImFsdHVyYSIsImZvbmRvRXNJbWFnZW4iLCJvYmpzRGVTZWNjaW9uIiwic2VjY2lvbklkIiwiaWQiLCJvYmpzQmxlZWQiLCJhbmNsYWplIiwib2Jqc0NvbnRlbmlkbyIsImZvbmRvU3R5bGUiLCJodG1sQmxlZWQiLCJodG1sQ29udGVuaWRvIiwic2NyaXB0TW9iaWxlU21hcnQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm9ubHlGaXhlZFNlY3Rpb25zIiwibWluUGVyQ29sdW1uMiIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGUiLCJmaXRUYXJnZXRXaWR0aFJhdGlvIiwiZml0TWluRmlsbFJhdGlvIiwiQU5DSE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarHTMLDesdeSecciones.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarInvitationLoaderRuntime.ts":
/*!***************************************************************!*\
  !*** ./functions/src/utils/generarInvitationLoaderRuntime.ts ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarInvitationLoaderRuntimeHTML: () => (/* binding */ generarInvitationLoaderRuntimeHTML)\n/* harmony export */ });\nfunction generarInvitationLoaderRuntimeHTML() {\n    return '\\n<style>\\n  body[data-loader-ready=\"0\"] {\\n    overflow: hidden;\\n  }\\n\\n  body[data-loader-ready=\"0\"] .inv {\\n    opacity: 0;\\n  }\\n\\n  body[data-loader-ready=\"1\"] .inv {\\n    opacity: 1;\\n    transition: opacity 360ms ease;\\n  }\\n\\n  .inv-loader {\\n    position: fixed;\\n    inset: 0;\\n    z-index: 9999;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    gap: 18px;\\n    background:\\n      radial-gradient(120% 90% at 80% 20%, rgba(255, 223, 236, 0.42) 0%, rgba(255, 223, 236, 0) 62%),\\n      radial-gradient(120% 90% at 14% 82%, rgba(239, 208, 255, 0.34) 0%, rgba(239, 208, 255, 0) 66%),\\n      linear-gradient(180deg, #fffafc 0%, #fff 100%);\\n    transition: opacity 420ms ease, visibility 420ms ease;\\n  }\\n\\n  .inv-loader--exit {\\n    opacity: 0;\\n    visibility: hidden;\\n    pointer-events: none;\\n  }\\n\\n  .inv-loader__stage {\\n    position: relative;\\n    width: 112px;\\n    height: 112px;\\n    display: grid;\\n    place-items: center;\\n  }\\n\\n  .inv-loader__halo {\\n    position: absolute;\\n    inset: 10px;\\n    border-radius: 999px;\\n    background: radial-gradient(circle, rgba(255, 255, 255, 0.98) 0%, rgba(249, 206, 224, 0.74) 56%, rgba(244, 175, 204, 0.28) 100%);\\n    box-shadow:\\n      0 12px 30px rgba(230, 123, 168, 0.24),\\n      inset 0 0 0 1px rgba(255, 255, 255, 0.64);\\n    animation: invLoaderHalo 2.3s ease-in-out infinite;\\n  }\\n\\n  .inv-loader__ring {\\n    position: absolute;\\n    inset: 0;\\n    border-radius: 999px;\\n    border: 2px solid rgba(221, 126, 165, 0.2);\\n    border-top-color: rgba(211, 70, 130, 0.84);\\n    border-right-color: rgba(233, 145, 179, 0.58);\\n    animation: invLoaderSpin 1.15s linear infinite;\\n  }\\n\\n  .inv-loader__heart {\\n    width: 34px;\\n    height: 34px;\\n    display: block;\\n    animation: invLoaderBeat 1.4s ease-in-out infinite;\\n  }\\n\\n  .inv-loader__heart-svg {\\n    width: 100%;\\n    height: 100%;\\n    display: block;\\n  }\\n\\n  .inv-loader__heart-path {\\n    fill: none;\\n    stroke: #cf4f89;\\n    stroke-width: 2.15;\\n    stroke-linecap: round;\\n    stroke-linejoin: round;\\n    filter: drop-shadow(0 3px 8px rgba(216, 61, 124, 0.18));\\n  }\\n\\n  .inv-loader__label {\\n    margin: 0;\\n    font-family: \"Playfair Display\", Georgia, serif;\\n    font-size: 16px;\\n    letter-spacing: 0.2px;\\n    color: #6d2a53;\\n    text-align: center;\\n  }\\n\\n  @keyframes invLoaderSpin {\\n    to {\\n      transform: rotate(360deg);\\n    }\\n  }\\n\\n  @keyframes invLoaderHalo {\\n    0%, 100% {\\n      transform: scale(0.98);\\n      opacity: 0.86;\\n    }\\n    50% {\\n      transform: scale(1.02);\\n      opacity: 1;\\n    }\\n  }\\n\\n  @keyframes invLoaderBeat {\\n    0%, 100% {\\n      transform: rotate(-45deg) scale(1);\\n    }\\n    42% {\\n      transform: rotate(-45deg) scale(1.12);\\n    }\\n    64% {\\n      transform: rotate(-45deg) scale(0.98);\\n    }\\n  }\\n\\n  @media (max-width: 767px) {\\n    .inv-loader__stage {\\n      width: 96px;\\n      height: 96px;\\n    }\\n\\n    .inv-loader__heart {\\n      width: 30px;\\n      height: 30px;\\n    }\\n\\n    .inv-loader__label {\\n      font-size: 14px;\\n    }\\n  }\\n\\n  @media (prefers-reduced-motion: reduce) {\\n    .inv-loader__halo,\\n    .inv-loader__ring,\\n    .inv-loader__heart {\\n      animation: none !important;\\n    }\\n  }\\n</style>\\n\\n<div id=\"inv-loader\" class=\"inv-loader\" role=\"status\" aria-live=\"polite\" aria-label=\"Cargando invitacion\">\\n  <div class=\"inv-loader__stage\">\\n    <span class=\"inv-loader__halo\" aria-hidden=\"true\"></span>\\n    <span class=\"inv-loader__ring\" aria-hidden=\"true\"></span>\\n    <span class=\"inv-loader__heart\" aria-hidden=\"true\">\\n      <svg class=\"inv-loader__heart-svg\" viewBox=\"0 0 24 24\" aria-hidden=\"true\" focusable=\"false\">\\n        <path\\n          class=\"inv-loader__heart-path\"\\n          d=\"M12 20.2c-.2 0-.4-.1-.5-.2C8.5 17.4 3 13.3 3 8.5 3 5.8 5.1 3.8 7.7 3.8c1.6 0 3.1.8 4.1 2.2 1-1.4 2.5-2.2 4.1-2.2C18.5 3.8 20.6 5.8 20.6 8.5c0 4.8-5.5 8.9-8.5 11.5-.1.1-.3.2-.5.2z\"\\n        />\\n      </svg>\\n    </span>\\n  </div>\\n  <p class=\"inv-loader__label\">Preparando invitacion...</p>\\n</div>\\n\\n<script>\\n(function(){\\n  var RUNTIME_READY_EVENT = \"invitation-runtime-ready\";\\n  var RUNTIME_FAIL_EVENT = \"invitation-runtime-failed\";\\n  var LOADER_HIDDEN_EVENT = \"invitation-loader-hidden\";\\n  var MAX_WAIT_MS = 10000;\\n  var closed = false;\\n\\n  function dispatchLoaderEvent(name){\\n    try {\\n      window.dispatchEvent(new CustomEvent(name));\\n    } catch (_error) {\\n      // noop\\n    }\\n  }\\n\\n  function closeLoader(){\\n    if (closed) return;\\n    closed = true;\\n\\n    if (document.body) {\\n      document.body.setAttribute(\"data-loader-ready\", \"1\");\\n    }\\n\\n    var loader = document.getElementById(\"inv-loader\");\\n    if (!loader) return;\\n\\n    loader.classList.add(\"inv-loader--exit\");\\n    window.setTimeout(function(){\\n      if (loader.parentNode) {\\n        loader.parentNode.removeChild(loader);\\n      }\\n      dispatchLoaderEvent(LOADER_HIDDEN_EVENT);\\n    }, 520);\\n  }\\n\\n  function armEvents(){\\n    if (document.body) {\\n      document.body.setAttribute(\"data-loader-ready\", \"0\");\\n    }\\n\\n    window.addEventListener(RUNTIME_READY_EVENT, closeLoader, { once: true });\\n    window.addEventListener(RUNTIME_FAIL_EVENT, closeLoader, { once: true });\\n\\n    window.setTimeout(closeLoader, MAX_WAIT_MS);\\n  }\\n\\n  if (document.readyState === \"loading\") {\\n    document.addEventListener(\"DOMContentLoaded\", armEvents, { once: true });\\n  } else {\\n    armEvents();\\n  }\\n})();\\n</script>\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE9BQU8sMDRLQTZOUEMsSUFBSTtBQUNOIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXGdlbmVyYXJJbnZpdGF0aW9uTG9hZGVyUnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lSFRNTCgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuPHN0eWxlPlxuICBib2R5W2RhdGEtbG9hZGVyLXJlYWR5PVwiMFwiXSB7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgfVxuXG4gIGJvZHlbZGF0YS1sb2FkZXItcmVhZHk9XCIwXCJdIC5pbnYge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cblxuICBib2R5W2RhdGEtbG9hZGVyLXJlYWR5PVwiMVwiXSAuaW52IHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMzYwbXMgZWFzZTtcbiAgfVxuXG4gIC5pbnYtbG9hZGVyIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgaW5zZXQ6IDA7XG4gICAgei1pbmRleDogOTk5OTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBnYXA6IDE4cHg7XG4gICAgYmFja2dyb3VuZDpcbiAgICAgIHJhZGlhbC1ncmFkaWVudCgxMjAlIDkwJSBhdCA4MCUgMjAlLCByZ2JhKDI1NSwgMjIzLCAyMzYsIDAuNDIpIDAlLCByZ2JhKDI1NSwgMjIzLCAyMzYsIDApIDYyJSksXG4gICAgICByYWRpYWwtZ3JhZGllbnQoMTIwJSA5MCUgYXQgMTQlIDgyJSwgcmdiYSgyMzksIDIwOCwgMjU1LCAwLjM0KSAwJSwgcmdiYSgyMzksIDIwOCwgMjU1LCAwKSA2NiUpLFxuICAgICAgbGluZWFyLWdyYWRpZW50KDE4MGRlZywgI2ZmZmFmYyAwJSwgI2ZmZiAxMDAlKTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDQyMG1zIGVhc2UsIHZpc2liaWxpdHkgNDIwbXMgZWFzZTtcbiAgfVxuXG4gIC5pbnYtbG9hZGVyLS1leGl0IHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuXG4gIC5pbnYtbG9hZGVyX19zdGFnZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMTJweDtcbiAgICBoZWlnaHQ6IDExMnB4O1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcbiAgfVxuXG4gIC5pbnYtbG9hZGVyX19oYWxvIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaW5zZXQ6IDEwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5cHg7XG4gICAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk4KSAwJSwgcmdiYSgyNDksIDIwNiwgMjI0LCAwLjc0KSA1NiUsIHJnYmEoMjQ0LCAxNzUsIDIwNCwgMC4yOCkgMTAwJSk7XG4gICAgYm94LXNoYWRvdzpcbiAgICAgIDAgMTJweCAzMHB4IHJnYmEoMjMwLCAxMjMsIDE2OCwgMC4yNCksXG4gICAgICBpbnNldCAwIDAgMCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY0KTtcbiAgICBhbmltYXRpb246IGludkxvYWRlckhhbG8gMi4zcyBlYXNlLWluLW91dCBpbmZpbml0ZTtcbiAgfVxuXG4gIC5pbnYtbG9hZGVyX19yaW5nIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaW5zZXQ6IDA7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5cHg7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSgyMjEsIDEyNiwgMTY1LCAwLjIpO1xuICAgIGJvcmRlci10b3AtY29sb3I6IHJnYmEoMjExLCA3MCwgMTMwLCAwLjg0KTtcbiAgICBib3JkZXItcmlnaHQtY29sb3I6IHJnYmEoMjMzLCAxNDUsIDE3OSwgMC41OCk7XG4gICAgYW5pbWF0aW9uOiBpbnZMb2FkZXJTcGluIDEuMTVzIGxpbmVhciBpbmZpbml0ZTtcbiAgfVxuXG4gIC5pbnYtbG9hZGVyX19oZWFydCB7XG4gICAgd2lkdGg6IDM0cHg7XG4gICAgaGVpZ2h0OiAzNHB4O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIGFuaW1hdGlvbjogaW52TG9hZGVyQmVhdCAxLjRzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2hlYXJ0LXN2ZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2hlYXJ0LXBhdGgge1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlOiAjY2Y0Zjg5O1xuICAgIHN0cm9rZS13aWR0aDogMi4xNTtcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcbiAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KDAgM3B4IDhweCByZ2JhKDIxNiwgNjEsIDEyNCwgMC4xOCkpO1xuICB9XG5cbiAgLmludi1sb2FkZXJfX2xhYmVsIHtcbiAgICBtYXJnaW46IDA7XG4gICAgZm9udC1mYW1pbHk6IFwiUGxheWZhaXIgRGlzcGxheVwiLCBHZW9yZ2lhLCBzZXJpZjtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGV0dGVyLXNwYWNpbmc6IDAuMnB4O1xuICAgIGNvbG9yOiAjNmQyYTUzO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuXG4gIEBrZXlmcmFtZXMgaW52TG9hZGVyU3BpbiB7XG4gICAgdG8ge1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIGludkxvYWRlckhhbG8ge1xuICAgIDAlLCAxMDAlIHtcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45OCk7XG4gICAgICBvcGFjaXR5OiAwLjg2O1xuICAgIH1cbiAgICA1MCUge1xuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjAyKTtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuICB9XG5cbiAgQGtleWZyYW1lcyBpbnZMb2FkZXJCZWF0IHtcbiAgICAwJSwgMTAwJSB7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpIHNjYWxlKDEpO1xuICAgIH1cbiAgICA0MiUge1xuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKSBzY2FsZSgxLjEyKTtcbiAgICB9XG4gICAgNjQlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZykgc2NhbGUoMC45OCk7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgLmludi1sb2FkZXJfX3N0YWdlIHtcbiAgICAgIHdpZHRoOiA5NnB4O1xuICAgICAgaGVpZ2h0OiA5NnB4O1xuICAgIH1cblxuICAgIC5pbnYtbG9hZGVyX19oZWFydCB7XG4gICAgICB3aWR0aDogMzBweDtcbiAgICAgIGhlaWdodDogMzBweDtcbiAgICB9XG5cbiAgICAuaW52LWxvYWRlcl9fbGFiZWwge1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKSB7XG4gICAgLmludi1sb2FkZXJfX2hhbG8sXG4gICAgLmludi1sb2FkZXJfX3JpbmcsXG4gICAgLmludi1sb2FkZXJfX2hlYXJ0IHtcbiAgICAgIGFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgIH1cbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBpZD1cImludi1sb2FkZXJcIiBjbGFzcz1cImludi1sb2FkZXJcIiByb2xlPVwic3RhdHVzXCIgYXJpYS1saXZlPVwicG9saXRlXCIgYXJpYS1sYWJlbD1cIkNhcmdhbmRvIGludml0YWNpb25cIj5cbiAgPGRpdiBjbGFzcz1cImludi1sb2FkZXJfX3N0YWdlXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJpbnYtbG9hZGVyX19oYWxvXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaW52LWxvYWRlcl9fcmluZ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cImludi1sb2FkZXJfX2hlYXJ0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8c3ZnIGNsYXNzPVwiaW52LWxvYWRlcl9faGVhcnQtc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3M9XCJpbnYtbG9hZGVyX19oZWFydC1wYXRoXCJcbiAgICAgICAgICBkPVwiTTEyIDIwLjJjLS4yIDAtLjQtLjEtLjUtLjJDOC41IDE3LjQgMyAxMy4zIDMgOC41IDMgNS44IDUuMSAzLjggNy43IDMuOGMxLjYgMCAzLjEuOCA0LjEgMi4yIDEtMS40IDIuNS0yLjIgNC4xLTIuMkMxOC41IDMuOCAyMC42IDUuOCAyMC42IDguNWMwIDQuOC01LjUgOC45LTguNSAxMS41LS4xLjEtLjMuMi0uNS4yelwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L3NwYW4+XG4gIDwvZGl2PlxuICA8cCBjbGFzcz1cImludi1sb2FkZXJfX2xhYmVsXCI+UHJlcGFyYW5kbyBpbnZpdGFjaW9uLi4uPC9wPlxuPC9kaXY+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgdmFyIFJVTlRJTUVfUkVBRFlfRVZFTlQgPSBcImludml0YXRpb24tcnVudGltZS1yZWFkeVwiO1xuICB2YXIgUlVOVElNRV9GQUlMX0VWRU5UID0gXCJpbnZpdGF0aW9uLXJ1bnRpbWUtZmFpbGVkXCI7XG4gIHZhciBMT0FERVJfSElEREVOX0VWRU5UID0gXCJpbnZpdGF0aW9uLWxvYWRlci1oaWRkZW5cIjtcbiAgdmFyIE1BWF9XQUlUX01TID0gMTAwMDA7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkaXNwYXRjaExvYWRlckV2ZW50KG5hbWUpe1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSkpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlTG9hZGVyKCl7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGNsb3NlZCA9IHRydWU7XG5cbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWxvYWRlci1yZWFkeVwiLCBcIjFcIik7XG4gICAgfVxuXG4gICAgdmFyIGxvYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW52LWxvYWRlclwiKTtcbiAgICBpZiAoIWxvYWRlcikgcmV0dXJuO1xuXG4gICAgbG9hZGVyLmNsYXNzTGlzdC5hZGQoXCJpbnYtbG9hZGVyLS1leGl0XCIpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAobG9hZGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbG9hZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobG9hZGVyKTtcbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoTG9hZGVyRXZlbnQoTE9BREVSX0hJRERFTl9FVkVOVCk7XG4gICAgfSwgNTIwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFybUV2ZW50cygpe1xuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShcImRhdGEtbG9hZGVyLXJlYWR5XCIsIFwiMFwiKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihSVU5USU1FX1JFQURZX0VWRU5ULCBjbG9zZUxvYWRlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFJVTlRJTUVfRkFJTF9FVkVOVCwgY2xvc2VMb2FkZXIsIHsgb25jZTogdHJ1ZSB9KTtcblxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNsb3NlTG9hZGVyLCBNQVhfV0FJVF9NUyk7XG4gIH1cblxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBhcm1FdmVudHMsIHsgb25jZTogdHJ1ZSB9KTtcbiAgfSBlbHNlIHtcbiAgICBhcm1FdmVudHMoKTtcbiAgfVxufSkoKTtcbjwvc2NyaXB0PlxuYC50cmltKCk7XG59XG4iXSwibmFtZXMiOlsiZ2VuZXJhckludml0YXRpb25Mb2FkZXJSdW50aW1lSFRNTCIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarInvitationLoaderRuntime.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarModalGaleria.ts":
/*!****************************************************!*\
  !*** ./functions/src/utils/generarModalGaleria.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalGaleriaHTML: () => (/* binding */ generarModalGaleriaHTML),\n/* harmony export */   hayGaleriaConImagenes: () => (/* binding */ hayGaleriaConImagenes)\n/* harmony export */ });\nfunction hayGaleriaConImagenes() {\n    let objetos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return objetos.some((obj)=>{\n        if ((obj === null || obj === void 0 ? void 0 : obj.tipo) !== \"galeria\" || !Array.isArray(obj === null || obj === void 0 ? void 0 : obj.cells)) return false;\n        return obj.cells.some((cell)=>typeof (cell === null || cell === void 0 ? void 0 : cell.mediaUrl) === \"string\" && cell.mediaUrl.trim().length > 0);\n    });\n}\nfunction generarModalGaleriaHTML() {\n    return '\\n<style>\\n  .objeto.galeria .galeria-celda--clickable {\\n    cursor: zoom-in;\\n  }\\n\\n  .objeto.galeria .galeria-celda--clickable:focus-visible {\\n    outline: 2px solid rgba(255, 255, 255, 0.95);\\n    outline-offset: -2px;\\n  }\\n\\n  .gallery-lightbox {\\n    position: fixed;\\n    inset: 0;\\n    z-index: 11000;\\n    opacity: 0;\\n    visibility: hidden;\\n    pointer-events: none;\\n    transition: opacity 0.32s ease, visibility 0.32s ease;\\n  }\\n\\n  .gallery-lightbox.is-open {\\n    opacity: 1;\\n    visibility: visible;\\n    pointer-events: auto;\\n  }\\n\\n  .gallery-lightbox__backdrop {\\n    position: absolute;\\n    inset: 0;\\n    background:\\n      radial-gradient(circle at 50% 10%, rgba(66, 66, 75, 0.35), transparent 48%),\\n      rgba(7, 8, 11, 0.96);\\n    backdrop-filter: blur(8px);\\n  }\\n\\n  .gallery-lightbox__stage {\\n    position: relative;\\n    z-index: 1;\\n    width: min(1320px, 100vw);\\n    height: min(94vh, 920px);\\n    margin: 0 auto;\\n    padding: clamp(24px, 4vw, 44px) clamp(56px, 8vw, 120px);\\n    display: grid;\\n    grid-template-columns: minmax(0, 1fr) minmax(0, 1.65fr) minmax(0, 1fr);\\n    align-items: center;\\n    gap: clamp(10px, 2.2vw, 28px);\\n  }\\n\\n  .gallery-lightbox__slot {\\n    width: 100%;\\n    height: min(84vh, 780px);\\n    background: rgba(255, 255, 255, 0.05);\\n    border: 1px solid rgba(255, 255, 255, 0.16);\\n    border-radius: 20px;\\n    overflow: hidden;\\n    box-shadow: 0 24px 60px rgba(0, 0, 0, 0.36);\\n    transition: opacity 0.26s ease, transform 0.26s ease, filter 0.26s ease;\\n  }\\n\\n  .gallery-lightbox__slot img {\\n    width: 100%;\\n    height: 100%;\\n    display: block;\\n    object-fit: contain;\\n  }\\n\\n  .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\\n    opacity: 0.52;\\n    transform: translateX(10%) scale(0.9);\\n    filter: saturate(0.72);\\n  }\\n\\n  .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\\n    opacity: 1;\\n    transform: scale(1);\\n    filter: none;\\n  }\\n\\n  .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\\n    opacity: 0.52;\\n    transform: translateX(-10%) scale(0.9);\\n    filter: saturate(0.72);\\n  }\\n\\n  .gallery-lightbox__slot.is-empty {\\n    opacity: 0;\\n    transform: scale(0.85);\\n    pointer-events: none;\\n  }\\n\\n  .gallery-lightbox__nav,\\n  .gallery-lightbox__close {\\n    position: absolute;\\n    z-index: 2;\\n    border: 1px solid rgba(255, 255, 255, 0.2);\\n    border-radius: 9999px;\\n    background: rgba(15, 16, 22, 0.62);\\n    color: #fff;\\n    cursor: pointer;\\n    transition: background 0.2s ease, transform 0.2s ease;\\n    backdrop-filter: blur(4px);\\n  }\\n\\n  .gallery-lightbox__nav:hover,\\n  .gallery-lightbox__close:hover {\\n    background: rgba(22, 25, 34, 0.9);\\n    transform: translateY(-1px);\\n  }\\n\\n  .gallery-lightbox__nav {\\n    top: 50%;\\n    transform: translateY(-50%);\\n    width: 52px;\\n    height: 52px;\\n    font-size: 28px;\\n    line-height: 1;\\n  }\\n\\n  .gallery-lightbox__nav--prev {\\n    left: clamp(10px, 2vw, 32px);\\n  }\\n\\n  .gallery-lightbox__nav--next {\\n    right: clamp(10px, 2vw, 32px);\\n  }\\n\\n  .gallery-lightbox__nav:disabled {\\n    opacity: 0.35;\\n    cursor: default;\\n  }\\n\\n  .gallery-lightbox__close {\\n    top: clamp(14px, 2.5vh, 26px);\\n    right: clamp(14px, 2vw, 28px);\\n    width: 44px;\\n    height: 44px;\\n    font-size: 24px;\\n    line-height: 1;\\n  }\\n\\n  .gallery-lightbox__counter {\\n    position: absolute;\\n    z-index: 2;\\n    bottom: clamp(12px, 2vh, 24px);\\n    left: 50%;\\n    transform: translateX(-50%);\\n    color: rgba(255, 255, 255, 0.9);\\n    background: rgba(14, 16, 24, 0.55);\\n    border: 1px solid rgba(255, 255, 255, 0.18);\\n    padding: 8px 14px;\\n    border-radius: 9999px;\\n    font-size: 14px;\\n    font-weight: 600;\\n    letter-spacing: 0.03em;\\n  }\\n\\n  @media (max-width: 900px) {\\n    .gallery-lightbox__stage {\\n      grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.8fr) minmax(0, 0.9fr);\\n      padding: 64px 12px 66px;\\n      height: 100dvh;\\n      height: 100vh;\\n      gap: 12px;\\n    }\\n\\n    .gallery-lightbox__slot {\\n      height: min(76vh, 700px);\\n      border-radius: 16px;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"] {\\n      opacity: 0.34;\\n      transform: translateX(22%) scale(0.84);\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\\n      opacity: 0.34;\\n      transform: translateX(-22%) scale(0.84);\\n    }\\n  }\\n\\n  @media (max-width: 640px) {\\n    .gallery-lightbox__stage {\\n      width: 100vw;\\n      max-width: 100vw;\\n      height: 100dvh;\\n      height: 100vh;\\n      grid-template-columns: minmax(0, 1fr);\\n      padding:\\n        calc(env(safe-area-inset-top, 0px) + 8px)\\n        calc(env(safe-area-inset-right, 0px) + 4px)\\n        calc(env(safe-area-inset-bottom, 0px) + 50px)\\n        calc(env(safe-area-inset-left, 0px) + 4px);\\n      gap: 0;\\n      align-items: stretch;\\n    }\\n\\n    .gallery-lightbox__slot {\\n      height: 100%;\\n      border-radius: 12px;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"prev\"],\\n    .gallery-lightbox__slot[data-gallery-slot=\"next\"] {\\n      display: none;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] {\\n      background: transparent;\\n      border: none;\\n      border-radius: 0;\\n      box-shadow: none;\\n    }\\n\\n    .gallery-lightbox__slot[data-gallery-slot=\"current\"] img {\\n      width: 100%;\\n      height: 100%;\\n      object-fit: contain;\\n    }\\n\\n    .gallery-lightbox__nav {\\n      width: 42px;\\n      height: 42px;\\n      font-size: 24px;\\n    }\\n\\n    .gallery-lightbox__nav--prev {\\n      left: calc(env(safe-area-inset-left, 0px) + 6px);\\n    }\\n\\n    .gallery-lightbox__nav--next {\\n      right: calc(env(safe-area-inset-right, 0px) + 6px);\\n    }\\n\\n    .gallery-lightbox__close {\\n      top: calc(env(safe-area-inset-top, 0px) + 10px);\\n      right: calc(env(safe-area-inset-right, 0px) + 10px);\\n    }\\n\\n    .gallery-lightbox__counter {\\n      bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);\\n    }\\n  }\\n</style>\\n\\n<div id=\"gallery-lightbox\" class=\"gallery-lightbox\" aria-hidden=\"true\" role=\"dialog\" aria-modal=\"true\">\\n  <div class=\"gallery-lightbox__backdrop\" data-gallery-close></div>\\n\\n  <button type=\"button\" class=\"gallery-lightbox__close\" data-gallery-close aria-label=\"Cerrar galeria\">\\n    &#10005;\\n  </button>\\n\\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--prev\" data-gallery-prev aria-label=\"Imagen anterior\">\\n    &#8249;\\n  </button>\\n\\n  <div class=\"gallery-lightbox__stage\">\\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"prev\">\\n      <img alt=\"\" />\\n    </figure>\\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"current\">\\n      <img alt=\"\" />\\n    </figure>\\n    <figure class=\"gallery-lightbox__slot\" data-gallery-slot=\"next\">\\n      <img alt=\"\" />\\n    </figure>\\n  </div>\\n\\n  <button type=\"button\" class=\"gallery-lightbox__nav gallery-lightbox__nav--next\" data-gallery-next aria-label=\"Imagen siguiente\">\\n    &#8250;\\n  </button>\\n\\n  <div class=\"gallery-lightbox__counter\" data-gallery-counter>1 / 1</div>\\n</div>\\n\\n<script>\\n(function(){\\n  function clampIndex(index, total){\\n    if (!total) return 0;\\n    var normalized = index % total;\\n    return normalized < 0 ? normalized + total : normalized;\\n  }\\n\\n  function boot(){\\n    var modal = document.getElementById(\"gallery-lightbox\");\\n    if (!modal) return;\\n\\n    var closeEls = Array.from(modal.querySelectorAll(\"[data-gallery-close]\"));\\n    var prevBtn = modal.querySelector(\"[data-gallery-prev]\");\\n    var nextBtn = modal.querySelector(\"[data-gallery-next]\");\\n    var counter = modal.querySelector(\"[data-gallery-counter]\");\\n\\n    var prevSlot = modal.querySelector(\\'[data-gallery-slot=\"prev\"]\\');\\n    var currentSlot = modal.querySelector(\\'[data-gallery-slot=\"current\"]\\');\\n    var nextSlot = modal.querySelector(\\'[data-gallery-slot=\"next\"]\\');\\n\\n    var prevImg = prevSlot ? prevSlot.querySelector(\"img\") : null;\\n    var currentImg = currentSlot ? currentSlot.querySelector(\"img\") : null;\\n    var nextImg = nextSlot ? nextSlot.querySelector(\"img\") : null;\\n    var stage = modal.querySelector(\".gallery-lightbox__stage\");\\n\\n    var state = {\\n      images: [],\\n      index: 0,\\n      isOpen: false,\\n      originalOverflow: \"\"\\n    };\\n\\n    function setSlotImage(imgNode, src, altText){\\n      if (!imgNode) return;\\n      if (!src) {\\n        imgNode.removeAttribute(\"src\");\\n        imgNode.alt = \"\";\\n        return;\\n      }\\n      if (imgNode.getAttribute(\"src\") !== src) {\\n        imgNode.setAttribute(\"src\", src);\\n      }\\n      imgNode.alt = altText || \"\";\\n    }\\n\\n    function refresh(){\\n      var total = state.images.length;\\n      if (!total) return;\\n\\n      state.index = clampIndex(state.index, total);\\n      var currentIndex = state.index;\\n      var hasNeighbors = total > 1;\\n\\n      var prevIndex = clampIndex(currentIndex - 1, total);\\n      var nextIndex = clampIndex(currentIndex + 1, total);\\n\\n      setSlotImage(currentImg, state.images[currentIndex], \"Imagen \" + (currentIndex + 1));\\n      setSlotImage(\\n        prevImg,\\n        hasNeighbors ? state.images[prevIndex] : \"\",\\n        hasNeighbors ? \"Imagen anterior\" : \"\"\\n      );\\n      setSlotImage(\\n        nextImg,\\n        hasNeighbors ? state.images[nextIndex] : \"\",\\n        hasNeighbors ? \"Imagen siguiente\" : \"\"\\n      );\\n\\n      if (prevSlot) prevSlot.classList.toggle(\"is-empty\", !hasNeighbors);\\n      if (nextSlot) nextSlot.classList.toggle(\"is-empty\", !hasNeighbors);\\n\\n      if (counter) counter.textContent = (currentIndex + 1) + \" / \" + total;\\n      if (prevBtn) prevBtn.disabled = !hasNeighbors;\\n      if (nextBtn) nextBtn.disabled = !hasNeighbors;\\n    }\\n\\n    function open(images, startIndex){\\n      if (!Array.isArray(images) || !images.length) return;\\n      state.images = images.slice();\\n      state.index = clampIndex(Number(startIndex) || 0, state.images.length);\\n      state.isOpen = true;\\n\\n      state.originalOverflow = document.body.style.overflow || \"\";\\n      document.body.style.overflow = \"hidden\";\\n\\n      modal.setAttribute(\"aria-hidden\", \"false\");\\n      modal.classList.add(\"is-open\");\\n      refresh();\\n\\n      if (closeEls[0] && typeof closeEls[0].focus === \"function\") {\\n        closeEls[0].focus();\\n      }\\n    }\\n\\n    function close(){\\n      if (!state.isOpen) return;\\n      state.isOpen = false;\\n      modal.classList.remove(\"is-open\");\\n      modal.setAttribute(\"aria-hidden\", \"true\");\\n      document.body.style.overflow = state.originalOverflow;\\n    }\\n\\n    function navigate(step){\\n      if (!state.isOpen || state.images.length < 2) return;\\n      state.index = clampIndex(state.index + step, state.images.length);\\n      refresh();\\n    }\\n\\n    closeEls.forEach(function(el){\\n      el.addEventListener(\"click\", function(ev){\\n        ev.preventDefault();\\n        close();\\n      });\\n    });\\n\\n    if (prevBtn) {\\n      prevBtn.addEventListener(\"click\", function(ev){\\n        ev.preventDefault();\\n        navigate(-1);\\n      });\\n    }\\n\\n    if (nextBtn) {\\n      nextBtn.addEventListener(\"click\", function(ev){\\n        ev.preventDefault();\\n        navigate(1);\\n      });\\n    }\\n\\n    document.addEventListener(\"keydown\", function(ev){\\n      if (!state.isOpen) return;\\n      if (ev.key === \"Escape\") {\\n        ev.preventDefault();\\n        close();\\n        return;\\n      }\\n      if (ev.key === \"ArrowLeft\") {\\n        ev.preventDefault();\\n        navigate(-1);\\n        return;\\n      }\\n      if (ev.key === \"ArrowRight\") {\\n        ev.preventDefault();\\n        navigate(1);\\n      }\\n    });\\n\\n    if (stage) {\\n      var startX = 0;\\n      var startY = 0;\\n      var pointerDown = false;\\n\\n      stage.addEventListener(\"touchstart\", function(ev){\\n        if (!ev.touches || !ev.touches.length) return;\\n        pointerDown = true;\\n        startX = ev.touches[0].clientX;\\n        startY = ev.touches[0].clientY;\\n      }, { passive: true });\\n\\n      stage.addEventListener(\"touchend\", function(ev){\\n        if (!pointerDown || !ev.changedTouches || !ev.changedTouches.length) return;\\n        pointerDown = false;\\n        var endX = ev.changedTouches[0].clientX;\\n        var endY = ev.changedTouches[0].clientY;\\n        var dx = endX - startX;\\n        var dy = endY - startY;\\n\\n        if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {\\n          navigate(dx > 0 ? -1 : 1);\\n        }\\n      }, { passive: true });\\n    }\\n\\n    var galleries = Array.from(document.querySelectorAll(\".objeto.galeria\"));\\n    galleries.forEach(function(gallery){\\n      var cells = Array.from(\\n        gallery.querySelectorAll(\\'.galeria-celda[data-gallery-image=\"1\"]\\')\\n      );\\n      if (!cells.length) return;\\n\\n      var images = cells\\n        .map(function(cell){\\n          var img = cell.querySelector(\"img\");\\n          if (!img) return \"\";\\n          return (img.getAttribute(\"src\") || \"\").trim();\\n        })\\n        .filter(Boolean);\\n\\n      if (!images.length) return;\\n\\n      gallery.addEventListener(\"click\", function(ev){\\n        var target = ev.target;\\n        if (!(target instanceof Element)) return;\\n\\n        var cell = target.closest(\\'.galeria-celda[data-gallery-image=\"1\"]\\');\\n        if (!cell || !gallery.contains(cell)) return;\\n\\n        var index = cells.indexOf(cell);\\n        if (index < 0) return;\\n\\n        ev.preventDefault();\\n        ev.stopPropagation();\\n        open(images, index);\\n      });\\n\\n      gallery.addEventListener(\"keydown\", function(ev){\\n        if (ev.key !== \"Enter\" && ev.key !== \" \") return;\\n        var target = ev.target;\\n        if (!(target instanceof Element)) return;\\n\\n        var cell = target.closest(\\'.galeria-celda[data-gallery-image=\"1\"]\\');\\n        if (!cell || !gallery.contains(cell)) return;\\n\\n        var index = cells.indexOf(cell);\\n        if (index < 0) return;\\n\\n        ev.preventDefault();\\n        open(images, index);\\n      });\\n    });\\n  }\\n\\n  if (document.readyState === \"loading\") {\\n    document.addEventListener(\"DOMContentLoaded\", boot);\\n  } else {\\n    boot();\\n  }\\n})();\\n</script>\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsR2FsZXJpYS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQVNPLFNBQVNBO1FBQXNCQyxVQUFBQSxpRUFBaUIsRUFBRTtJQUN2RCxPQUFPQSxRQUFRQyxJQUFJLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJQUFLQyxJQUFJLE1BQUssYUFBYSxDQUFDQyxNQUFNQyxPQUFPLENBQUNILGdCQUFBQSwwQkFBQUEsSUFBS0ksS0FBSyxHQUFHLE9BQU87UUFDbEUsT0FBT0osSUFBSUksS0FBSyxDQUFDTCxJQUFJLENBQ25CLENBQUNNLE9BQVMsUUFBT0EsaUJBQUFBLDJCQUFBQSxLQUFNQyxRQUFRLE1BQUssWUFBWUQsS0FBS0MsUUFBUSxDQUFDQyxJQUFJLEdBQUdDLE1BQU0sR0FBRztJQUVsRjtBQUNGO0FBRU8sU0FBU0M7SUFDZCxPQUFPLDJ5YkEwZlBGLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxnZW5lcmFyTW9kYWxHYWxlcmlhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgR2FsZXJpYUNlbGwgPSB7XG4gIG1lZGlhVXJsPzogc3RyaW5nIHwgbnVsbDtcbn07XG5cbnR5cGUgT2JqZXRvR2FsZXJpYSA9IHtcbiAgdGlwbz86IHN0cmluZztcbiAgY2VsbHM/OiBHYWxlcmlhQ2VsbFtdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhheUdhbGVyaWFDb25JbWFnZW5lcyhvYmpldG9zOiBhbnlbXSA9IFtdKTogYm9vbGVhbiB7XG4gIHJldHVybiBvYmpldG9zLnNvbWUoKG9iajogT2JqZXRvR2FsZXJpYSkgPT4ge1xuICAgIGlmIChvYmo/LnRpcG8gIT09IFwiZ2FsZXJpYVwiIHx8ICFBcnJheS5pc0FycmF5KG9iaj8uY2VsbHMpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG9iai5jZWxscy5zb21lKFxuICAgICAgKGNlbGwpID0+IHR5cGVvZiBjZWxsPy5tZWRpYVVybCA9PT0gXCJzdHJpbmdcIiAmJiBjZWxsLm1lZGlhVXJsLnRyaW0oKS5sZW5ndGggPiAwXG4gICAgKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxHYWxlcmlhSFRNTCgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuPHN0eWxlPlxuICAub2JqZXRvLmdhbGVyaWEgLmdhbGVyaWEtY2VsZGEtLWNsaWNrYWJsZSB7XG4gICAgY3Vyc29yOiB6b29tLWluO1xuICB9XG5cbiAgLm9iamV0by5nYWxlcmlhIC5nYWxlcmlhLWNlbGRhLS1jbGlja2FibGU6Zm9jdXMtdmlzaWJsZSB7XG4gICAgb3V0bGluZTogMnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSk7XG4gICAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGluc2V0OiAwO1xuICAgIHotaW5kZXg6IDExMDAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zMnMgZWFzZSwgdmlzaWJpbGl0eSAwLjMycyBlYXNlO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3guaXMtb3BlbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX2JhY2tkcm9wIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgaW5zZXQ6IDA7XG4gICAgYmFja2dyb3VuZDpcbiAgICAgIHJhZGlhbC1ncmFkaWVudChjaXJjbGUgYXQgNTAlIDEwJSwgcmdiYSg2NiwgNjYsIDc1LCAwLjM1KSwgdHJhbnNwYXJlbnQgNDglKSxcbiAgICAgIHJnYmEoNywgOCwgMTEsIDAuOTYpO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3N0YWdlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgei1pbmRleDogMTtcbiAgICB3aWR0aDogbWluKDEzMjBweCwgMTAwdncpO1xuICAgIGhlaWdodDogbWluKDk0dmgsIDkyMHB4KTtcbiAgICBtYXJnaW46IDAgYXV0bztcbiAgICBwYWRkaW5nOiBjbGFtcCgyNHB4LCA0dncsIDQ0cHgpIGNsYW1wKDU2cHgsIDh2dywgMTIwcHgpO1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMCwgMWZyKSBtaW5tYXgoMCwgMS42NWZyKSBtaW5tYXgoMCwgMWZyKTtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogY2xhbXAoMTBweCwgMi4ydncsIDI4cHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3Qge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogbWluKDg0dmgsIDc4MHB4KTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDUpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNik7XG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGJveC1zaGFkb3c6IDAgMjRweCA2MHB4IHJnYmEoMCwgMCwgMCwgMC4zNik7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI2cyBlYXNlLCB0cmFuc2Zvcm0gMC4yNnMgZWFzZSwgZmlsdGVyIDAuMjZzIGVhc2U7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdCBpbWcge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBvYmplY3QtZml0OiBjb250YWluO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdIHtcbiAgICBvcGFjaXR5OiAwLjUyO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMCUpIHNjYWxlKDAuOSk7XG4gICAgZmlsdGVyOiBzYXR1cmF0ZSgwLjcyKTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwiY3VycmVudFwiXSB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICAgIGZpbHRlcjogbm9uZTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwibmV4dFwiXSB7XG4gICAgb3BhY2l0eTogMC41MjtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwJSkgc2NhbGUoMC45KTtcbiAgICBmaWx0ZXI6IHNhdHVyYXRlKDAuNzIpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3QuaXMtZW1wdHkge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjg1KTtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYsXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDI7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE1LCAxNiwgMjIsIDAuNjIpO1xuICAgIGNvbG9yOiAjZmZmO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMnMgZWFzZSwgdHJhbnNmb3JtIDAuMnMgZWFzZTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXY6aG92ZXIsXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyMiwgMjUsIDM0LCAwLjkpO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYge1xuICAgIHRvcDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgICB3aWR0aDogNTJweDtcbiAgICBoZWlnaHQ6IDUycHg7XG4gICAgZm9udC1zaXplOiAyOHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdi0tcHJldiB7XG4gICAgbGVmdDogY2xhbXAoMTBweCwgMnZ3LCAzMnB4KTtcbiAgfVxuXG4gIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLW5leHQge1xuICAgIHJpZ2h0OiBjbGFtcCgxMHB4LCAydncsIDMycHgpO1xuICB9XG5cbiAgLmdhbGxlcnktbGlnaHRib3hfX25hdjpkaXNhYmxlZCB7XG4gICAgb3BhY2l0eTogMC4zNTtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fY2xvc2Uge1xuICAgIHRvcDogY2xhbXAoMTRweCwgMi41dmgsIDI2cHgpO1xuICAgIHJpZ2h0OiBjbGFtcCgxNHB4LCAydncsIDI4cHgpO1xuICAgIHdpZHRoOiA0NHB4O1xuICAgIGhlaWdodDogNDRweDtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuZ2FsbGVyeS1saWdodGJveF9fY291bnRlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDI7XG4gICAgYm90dG9tOiBjbGFtcCgxMnB4LCAydmgsIDI0cHgpO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE0LCAxNiwgMjQsIDAuNTUpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xOCk7XG4gICAgcGFkZGluZzogOHB4IDE0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGxldHRlci1zcGFjaW5nOiAwLjAzZW07XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogOTAwcHgpIHtcbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2Uge1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMCwgMC45ZnIpIG1pbm1heCgwLCAxLjhmcikgbWlubWF4KDAsIDAuOWZyKTtcbiAgICAgIHBhZGRpbmc6IDY0cHggMTJweCA2NnB4O1xuICAgICAgaGVpZ2h0OiAxMDBkdmg7XG4gICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgZ2FwOiAxMnB4O1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90IHtcbiAgICAgIGhlaWdodDogbWluKDc2dmgsIDcwMHB4KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDE2cHg7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX3Nsb3RbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJwcmV2XCJdIHtcbiAgICAgIG9wYWNpdHk6IDAuMzQ7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjIlKSBzY2FsZSgwLjg0KTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIl0ge1xuICAgICAgb3BhY2l0eTogMC4zNDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMjIlKSBzY2FsZSgwLjg0KTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNjQwcHgpIHtcbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc3RhZ2Uge1xuICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgbWF4LXdpZHRoOiAxMDB2dztcbiAgICAgIGhlaWdodDogMTAwZHZoO1xuICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogbWlubWF4KDAsIDFmcik7XG4gICAgICBwYWRkaW5nOlxuICAgICAgICBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpICsgOHB4KVxuICAgICAgICBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweCkgKyA0cHgpXG4gICAgICAgIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20sIDBweCkgKyA1MHB4KVxuICAgICAgICBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtbGVmdCwgMHB4KSArIDRweCk7XG4gICAgICBnYXA6IDA7XG4gICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdCB7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19zbG90W2RhdGEtZ2FsbGVyeS1zbG90PVwicHJldlwiXSxcbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIl0ge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIl0ge1xuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBib3JkZXItcmFkaXVzOiAwO1xuICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fc2xvdFtkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIl0gaW1nIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICB9XG5cbiAgICAuZ2FsbGVyeS1saWdodGJveF9fbmF2IHtcbiAgICAgIHdpZHRoOiA0MnB4O1xuICAgICAgaGVpZ2h0OiA0MnB4O1xuICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLXByZXYge1xuICAgICAgbGVmdDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWxlZnQsIDBweCkgKyA2cHgpO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLW5leHQge1xuICAgICAgcmlnaHQ6IGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KSArIDZweCk7XG4gICAgfVxuXG4gICAgLmdhbGxlcnktbGlnaHRib3hfX2Nsb3NlIHtcbiAgICAgIHRvcDogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCwgMHB4KSArIDEwcHgpO1xuICAgICAgcmlnaHQ6IGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodCwgMHB4KSArIDEwcHgpO1xuICAgIH1cblxuICAgIC5nYWxsZXJ5LWxpZ2h0Ym94X19jb3VudGVyIHtcbiAgICAgIGJvdHRvbTogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSwgMHB4KSArIDhweCk7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2IGlkPVwiZ2FsbGVyeS1saWdodGJveFwiIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxuICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fYmFja2Ryb3BcIiBkYXRhLWdhbGxlcnktY2xvc2U+PC9kaXY+XG5cbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19jbG9zZVwiIGRhdGEtZ2FsbGVyeS1jbG9zZSBhcmlhLWxhYmVsPVwiQ2VycmFyIGdhbGVyaWFcIj5cbiAgICAmIzEwMDA1O1xuICA8L2J1dHRvbj5cblxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX25hdiBnYWxsZXJ5LWxpZ2h0Ym94X19uYXYtLXByZXZcIiBkYXRhLWdhbGxlcnktcHJldiBhcmlhLWxhYmVsPVwiSW1hZ2VuIGFudGVyaW9yXCI+XG4gICAgJiM4MjQ5O1xuICA8L2J1dHRvbj5cblxuICA8ZGl2IGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fc3RhZ2VcIj5cbiAgICA8ZmlndXJlIGNsYXNzPVwiZ2FsbGVyeS1saWdodGJveF9fc2xvdFwiIGRhdGEtZ2FsbGVyeS1zbG90PVwicHJldlwiPlxuICAgICAgPGltZyBhbHQ9XCJcIiAvPlxuICAgIDwvZmlndXJlPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19zbG90XCIgZGF0YS1nYWxsZXJ5LXNsb3Q9XCJjdXJyZW50XCI+XG4gICAgICA8aW1nIGFsdD1cIlwiIC8+XG4gICAgPC9maWd1cmU+XG4gICAgPGZpZ3VyZSBjbGFzcz1cImdhbGxlcnktbGlnaHRib3hfX3Nsb3RcIiBkYXRhLWdhbGxlcnktc2xvdD1cIm5leHRcIj5cbiAgICAgIDxpbWcgYWx0PVwiXCIgLz5cbiAgICA8L2ZpZ3VyZT5cbiAgPC9kaXY+XG5cbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19uYXYgZ2FsbGVyeS1saWdodGJveF9fbmF2LS1uZXh0XCIgZGF0YS1nYWxsZXJ5LW5leHQgYXJpYS1sYWJlbD1cIkltYWdlbiBzaWd1aWVudGVcIj5cbiAgICAmIzgyNTA7XG4gIDwvYnV0dG9uPlxuXG4gIDxkaXYgY2xhc3M9XCJnYWxsZXJ5LWxpZ2h0Ym94X19jb3VudGVyXCIgZGF0YS1nYWxsZXJ5LWNvdW50ZXI+MSAvIDE8L2Rpdj5cbjwvZGl2PlxuXG48c2NyaXB0PlxuKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgoaW5kZXgsIHRvdGFsKXtcbiAgICBpZiAoIXRvdGFsKSByZXR1cm4gMDtcbiAgICB2YXIgbm9ybWFsaXplZCA9IGluZGV4ICUgdG90YWw7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQgPCAwID8gbm9ybWFsaXplZCArIHRvdGFsIDogbm9ybWFsaXplZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJvb3QoKXtcbiAgICB2YXIgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbGxlcnktbGlnaHRib3hcIik7XG4gICAgaWYgKCFtb2RhbCkgcmV0dXJuO1xuXG4gICAgdmFyIGNsb3NlRWxzID0gQXJyYXkuZnJvbShtb2RhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZ2FsbGVyeS1jbG9zZV1cIikpO1xuICAgIHZhciBwcmV2QnRuID0gbW9kYWwucXVlcnlTZWxlY3RvcihcIltkYXRhLWdhbGxlcnktcHJldl1cIik7XG4gICAgdmFyIG5leHRCdG4gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZ2FsbGVyeS1uZXh0XVwiKTtcbiAgICB2YXIgY291bnRlciA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1nYWxsZXJ5LWNvdW50ZXJdXCIpO1xuXG4gICAgdmFyIHByZXZTbG90ID0gbW9kYWwucXVlcnlTZWxlY3RvcignW2RhdGEtZ2FsbGVyeS1zbG90PVwicHJldlwiXScpO1xuICAgIHZhciBjdXJyZW50U2xvdCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWdhbGxlcnktc2xvdD1cImN1cnJlbnRcIl0nKTtcbiAgICB2YXIgbmV4dFNsb3QgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1nYWxsZXJ5LXNsb3Q9XCJuZXh0XCJdJyk7XG5cbiAgICB2YXIgcHJldkltZyA9IHByZXZTbG90ID8gcHJldlNsb3QucXVlcnlTZWxlY3RvcihcImltZ1wiKSA6IG51bGw7XG4gICAgdmFyIGN1cnJlbnRJbWcgPSBjdXJyZW50U2xvdCA/IGN1cnJlbnRTbG90LnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIikgOiBudWxsO1xuICAgIHZhciBuZXh0SW1nID0gbmV4dFNsb3QgPyBuZXh0U2xvdC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpIDogbnVsbDtcbiAgICB2YXIgc3RhZ2UgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKFwiLmdhbGxlcnktbGlnaHRib3hfX3N0YWdlXCIpO1xuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgaW1hZ2VzOiBbXSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgIG9yaWdpbmFsT3ZlcmZsb3c6IFwiXCJcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0U2xvdEltYWdlKGltZ05vZGUsIHNyYywgYWx0VGV4dCl7XG4gICAgICBpZiAoIWltZ05vZGUpIHJldHVybjtcbiAgICAgIGlmICghc3JjKSB7XG4gICAgICAgIGltZ05vZGUucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgICBpbWdOb2RlLmFsdCA9IFwiXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbWdOb2RlLmdldEF0dHJpYnV0ZShcInNyY1wiKSAhPT0gc3JjKSB7XG4gICAgICAgIGltZ05vZGUuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7XG4gICAgICB9XG4gICAgICBpbWdOb2RlLmFsdCA9IGFsdFRleHQgfHwgXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoKCl7XG4gICAgICB2YXIgdG90YWwgPSBzdGF0ZS5pbWFnZXMubGVuZ3RoO1xuICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuO1xuXG4gICAgICBzdGF0ZS5pbmRleCA9IGNsYW1wSW5kZXgoc3RhdGUuaW5kZXgsIHRvdGFsKTtcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICAgIHZhciBoYXNOZWlnaGJvcnMgPSB0b3RhbCA+IDE7XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBjbGFtcEluZGV4KGN1cnJlbnRJbmRleCAtIDEsIHRvdGFsKTtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGN1cnJlbnRJbmRleCArIDEsIHRvdGFsKTtcblxuICAgICAgc2V0U2xvdEltYWdlKGN1cnJlbnRJbWcsIHN0YXRlLmltYWdlc1tjdXJyZW50SW5kZXhdLCBcIkltYWdlbiBcIiArIChjdXJyZW50SW5kZXggKyAxKSk7XG4gICAgICBzZXRTbG90SW1hZ2UoXG4gICAgICAgIHByZXZJbWcsXG4gICAgICAgIGhhc05laWdoYm9ycyA/IHN0YXRlLmltYWdlc1twcmV2SW5kZXhdIDogXCJcIixcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gXCJJbWFnZW4gYW50ZXJpb3JcIiA6IFwiXCJcbiAgICAgICk7XG4gICAgICBzZXRTbG90SW1hZ2UoXG4gICAgICAgIG5leHRJbWcsXG4gICAgICAgIGhhc05laWdoYm9ycyA/IHN0YXRlLmltYWdlc1tuZXh0SW5kZXhdIDogXCJcIixcbiAgICAgICAgaGFzTmVpZ2hib3JzID8gXCJJbWFnZW4gc2lndWllbnRlXCIgOiBcIlwiXG4gICAgICApO1xuXG4gICAgICBpZiAocHJldlNsb3QpIHByZXZTbG90LmNsYXNzTGlzdC50b2dnbGUoXCJpcy1lbXB0eVwiLCAhaGFzTmVpZ2hib3JzKTtcbiAgICAgIGlmIChuZXh0U2xvdCkgbmV4dFNsb3QuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWVtcHR5XCIsICFoYXNOZWlnaGJvcnMpO1xuXG4gICAgICBpZiAoY291bnRlcikgY291bnRlci50ZXh0Q29udGVudCA9IChjdXJyZW50SW5kZXggKyAxKSArIFwiIC8gXCIgKyB0b3RhbDtcbiAgICAgIGlmIChwcmV2QnRuKSBwcmV2QnRuLmRpc2FibGVkID0gIWhhc05laWdoYm9ycztcbiAgICAgIGlmIChuZXh0QnRuKSBuZXh0QnRuLmRpc2FibGVkID0gIWhhc05laWdoYm9ycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVuKGltYWdlcywgc3RhcnRJbmRleCl7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW1hZ2VzKSB8fCAhaW1hZ2VzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgc3RhdGUuaW1hZ2VzID0gaW1hZ2VzLnNsaWNlKCk7XG4gICAgICBzdGF0ZS5pbmRleCA9IGNsYW1wSW5kZXgoTnVtYmVyKHN0YXJ0SW5kZXgpIHx8IDAsIHN0YXRlLmltYWdlcy5sZW5ndGgpO1xuICAgICAgc3RhdGUuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgc3RhdGUub3JpZ2luYWxPdmVyZmxvdyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgfHwgXCJcIjtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXG4gICAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpO1xuICAgICAgbW9kYWwuY2xhc3NMaXN0LmFkZChcImlzLW9wZW5cIik7XG4gICAgICByZWZyZXNoKCk7XG5cbiAgICAgIGlmIChjbG9zZUVsc1swXSAmJiB0eXBlb2YgY2xvc2VFbHNbMF0uZm9jdXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjbG9zZUVsc1swXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlKCl7XG4gICAgICBpZiAoIXN0YXRlLmlzT3BlbikgcmV0dXJuO1xuICAgICAgc3RhdGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtb3BlblwiKTtcbiAgICAgIG1vZGFsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBzdGF0ZS5vcmlnaW5hbE92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKHN0ZXApe1xuICAgICAgaWYgKCFzdGF0ZS5pc09wZW4gfHwgc3RhdGUuaW1hZ2VzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgIHN0YXRlLmluZGV4ID0gY2xhbXBJbmRleChzdGF0ZS5pbmRleCArIHN0ZXAsIHN0YXRlLmltYWdlcy5sZW5ndGgpO1xuICAgICAgcmVmcmVzaCgpO1xuICAgIH1cblxuICAgIGNsb3NlRWxzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHByZXZCdG4pIHtcbiAgICAgIHByZXZCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoLTEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRCdG4pIHtcbiAgICAgIG5leHRCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihldil7XG4gICAgICBpZiAoIXN0YXRlLmlzT3BlbikgcmV0dXJuO1xuICAgICAgaWYgKGV2LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXYua2V5ID09PSBcIkFycm93TGVmdFwiKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5hdmlnYXRlKC0xKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbmF2aWdhdGUoMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc3RhZ2UpIHtcbiAgICAgIHZhciBzdGFydFggPSAwO1xuICAgICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgICB2YXIgcG9pbnRlckRvd24gPSBmYWxzZTtcblxuICAgICAgc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24oZXYpe1xuICAgICAgICBpZiAoIWV2LnRvdWNoZXMgfHwgIWV2LnRvdWNoZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgc3RhcnRYID0gZXYudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICBzdGFydFkgPSBldi50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbihldil7XG4gICAgICAgIGlmICghcG9pbnRlckRvd24gfHwgIWV2LmNoYW5nZWRUb3VjaGVzIHx8ICFldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB2YXIgZW5kWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIHZhciBkeCA9IGVuZFggLSBzdGFydFg7XG4gICAgICAgIHZhciBkeSA9IGVuZFkgLSBzdGFydFk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IDQwICYmIE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgICAgIG5hdmlnYXRlKGR4ID4gMCA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICB2YXIgZ2FsbGVyaWVzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0by5nYWxlcmlhXCIpKTtcbiAgICBnYWxsZXJpZXMuZm9yRWFjaChmdW5jdGlvbihnYWxsZXJ5KXtcbiAgICAgIHZhciBjZWxscyA9IEFycmF5LmZyb20oXG4gICAgICAgIGdhbGxlcnkucXVlcnlTZWxlY3RvckFsbCgnLmdhbGVyaWEtY2VsZGFbZGF0YS1nYWxsZXJ5LWltYWdlPVwiMVwiXScpXG4gICAgICApO1xuICAgICAgaWYgKCFjZWxscy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgdmFyIGltYWdlcyA9IGNlbGxzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oY2VsbCl7XG4gICAgICAgICAgdmFyIGltZyA9IGNlbGwucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICAgICAgICBpZiAoIWltZykgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIChpbWcuZ2V0QXR0cmlidXRlKFwic3JjXCIpIHx8IFwiXCIpLnRyaW0oKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgaWYgKCFpbWFnZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgIGdhbGxlcnkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICB2YXIgY2VsbCA9IHRhcmdldC5jbG9zZXN0KCcuZ2FsZXJpYS1jZWxkYVtkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJdJyk7XG4gICAgICAgIGlmICghY2VsbCB8fCAhZ2FsbGVyeS5jb250YWlucyhjZWxsKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGNlbGxzLmluZGV4T2YoY2VsbCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcblxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgb3BlbihpbWFnZXMsIGluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICBnYWxsZXJ5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgaWYgKGV2LmtleSAhPT0gXCJFbnRlclwiICYmIGV2LmtleSAhPT0gXCIgXCIpIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICB2YXIgY2VsbCA9IHRhcmdldC5jbG9zZXN0KCcuZ2FsZXJpYS1jZWxkYVtkYXRhLWdhbGxlcnktaW1hZ2U9XCIxXCJdJyk7XG4gICAgICAgIGlmICghY2VsbCB8fCAhZ2FsbGVyeS5jb250YWlucyhjZWxsKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGNlbGxzLmluZGV4T2YoY2VsbCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcblxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvcGVuKGltYWdlcywgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBib290KTtcbiAgfSBlbHNlIHtcbiAgICBib290KCk7XG4gIH1cbn0pKCk7XG48L3NjcmlwdD5cbmAudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbImhheUdhbGVyaWFDb25JbWFnZW5lcyIsIm9iamV0b3MiLCJzb21lIiwib2JqIiwidGlwbyIsIkFycmF5IiwiaXNBcnJheSIsImNlbGxzIiwiY2VsbCIsIm1lZGlhVXJsIiwidHJpbSIsImxlbmd0aCIsImdlbmVyYXJNb2RhbEdhbGVyaWFIVE1MIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarModalGaleria.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarModalRSVP.ts":
/*!*************************************************!*\
  !*** ./functions/src/utils/generarModalRSVP.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarModalRSVPHTML: () => (/* binding */ generarModalRSVPHTML)\n/* harmony export */ });\n// functions/src/utils/generarModalRSVP.ts\nfunction generarModalRSVPHTML(cfg) {\n    if (!(cfg === null || cfg === void 0 ? void 0 : cfg.enabled)) return \"\";\n    var _cfg_title;\n    const title = (_cfg_title = cfg.title) !== null && _cfg_title !== void 0 ? _cfg_title : \"Confirmar asistencia\";\n    var _cfg_subtitle;\n    const subtitle = (_cfg_subtitle = cfg.subtitle) !== null && _cfg_subtitle !== void 0 ? _cfg_subtitle : \"\";\n    var _cfg_buttonText;\n    const btnText = (_cfg_buttonText = cfg.buttonText) !== null && _cfg_buttonText !== void 0 ? _cfg_buttonText : \"Enviar\";\n    var _cfg_primaryColor;\n    const color = (_cfg_primaryColor = cfg.primaryColor) !== null && _cfg_primaryColor !== void 0 ? _cfg_primaryColor : \"#773dbe\";\n    // Nota: el botón que abre el modal debe tener [data-rsvp-open]\n    // (el listener de abajo lo busca)\n    return '\\n<div id=\"modal-rsvp\" style=\"\\n  position: fixed; inset: 0; display:none;\\n  background: rgba(0,0,0,.6); z-index: 9999;\\n  align-items: center; justify-content: center;\">\\n  <div style=\"\\n    background: #fff; width: 90%; max-width: 420px; border-radius: 10px;\\n    padding: 20px; font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,.2);\">\\n    <div style=\"display:flex; justify-content: space-between; align-items:center;\">\\n      <h2 style=\"margin:0; font-size:20px;\">'.concat(title, '</h2>\\n      <button id=\"rsvp-close\" aria-label=\"Cerrar\" style=\"border:none; background:transparent; font-size:18px; cursor:pointer;\">✕</button>\\n    </div>\\n    ').concat(subtitle ? '<p style=\"margin:8px 0 16px; color:#555;\">'.concat(subtitle, \"</p>\") : \"\", '\\n\\n    <div style=\"display:flex; flex-direction:column; gap:10px;\">\\n      <input id=\"rsvp-nombre\" placeholder=\"Tu nombre\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\\n      <input id=\"rsvp-mensaje\" placeholder=\"Mensaje (opcional)\" style=\"padding:10px; border:1px solid #ccc; border-radius:6px;\" />\\n    </div>\\n\\n     <!-- ✅ NUEVO: selector S\\xed/No con estilo segmentado -->\\n    <div style=\"margin-top:12px;\">\\n      <label style=\"display:block; font-weight:600; margin-bottom:8px;\">\\xbfConfirm\\xe1s asistencia?</label>\\n      <div id=\"rsvp-confirma\" style=\"\\n        display:inline-flex; gap:0; border:1px solid #ddd; border-radius:10px; overflow:hidden;\\n        box-shadow: inset 0 1px 0 rgba(0,0,0,0.03);\\n      \">\\n        <button type=\"button\" data-confirma=\"si\" aria-pressed=\"true\" style=\"\\n          padding:10px 14px; border:none; background:').concat(color, '; color:#fff; font-weight:600; cursor:pointer;\\n        \">S\\xed, voy</button>\\n        <button type=\"button\" data-confirma=\"no\" aria-pressed=\"false\" style=\"\\n          padding:10px 14px; border:none; background:#f6f6f6; color:#444; cursor:pointer;\\n        \">No puedo</button>\\n      </div>\\n    </div>\\n\\n    <div style=\"display:flex; justify-content:flex-end; gap:10px; margin-top:16px;\">\\n      <button id=\"rsvp-cancel\" style=\"padding:8px 12px; border-radius:6px; border:1px solid #ddd; background:#f3f3f3; cursor:pointer;\">Cancelar</button>\\n      <button id=\"rsvp-send\" style=\"padding:8px 12px; border-radius:6px; border:none; color:#fff; cursor:pointer; background:').concat(color, ';\">').concat(btnText, '</button>\\n    </div>\\n  </div>\\n</div>\\n\\n<script>\\ndocument.addEventListener(\\'DOMContentLoaded\\', function () {\\n\\nfunction getSlugDePagina() {\\n  // 0) Log de ayuda\\n  try { console.log(\"[RSVP] href:\", location.href); } catch (e) {}\\n\\n  // 1) <html data-slug=\"...\"> (si lo inyect\\xe1s en el HTML final)\\n  const ds = document.documentElement?.dataset?.slug;\\n  if (ds) {\\n    console.log(\"[RSVP] slug por data-atributo:\", ds);\\n    return ds;\\n  }\\n\\n  // 2) ?slug=... en la URL\\n  const q = new URLSearchParams(location.search).get(\"slug\");\\n  if (q) {\\n    console.log(\"[RSVP] slug por querystring:\", q);\\n    return q;\\n  }\\n\\n  // 3) /publicadas/<slug>/... en un sitio est\\xe1tico (Hosting/Proxy)\\n  const parts = location.pathname.split(\"/\").filter(Boolean);\\n  const i = parts.indexOf(\"publicadas\");\\n  if (i >= 0 && parts[i + 1]) {\\n    console.log(\"[RSVP] slug por pathname directo:\", parts[i + 1]);\\n    return parts[i + 1];\\n  }\\n\\n  // 4) URL de Firebase Storage:\\n  //    https://firebasestorage.googleapis.com/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media&token=...\\n  //    https://<bucket>.firebasestorage.app/v0/b/<bucket>/o/publicadas%2F<slug>%2Findex.html?alt=media\\n  try {\\n    const pathAfterO = location.pathname.split(\"/o/\")[1]; // \"publicadas%2F<slug>%2Findex.html\"\\n    if (pathAfterO) {\\n      const decoded = decodeURIComponent(pathAfterO);      // \"publicadas/<slug>/index.html\"\\n      const segs = decoded.split(\"/\").filter(Boolean);\\n      const j = segs.indexOf(\"publicadas\");\\n      if (j >= 0 && segs[j + 1]) {\\n        console.log(\"[RSVP] slug por URL de Storage:\", segs[j + 1]);\\n        return segs[j + 1];\\n      }\\n    }\\n  } catch (e) {\\n    console.warn(\"[RSVP] Error parseando URL de Storage:\", e);\\n  }\\n\\n  console.warn(\"[RSVP] No se pudo detectar slug. Fallback: sin-slug\");\\n  return \"sin-slug\";\\n}\\n\\n\\n  var modal = document.getElementById(\\'modal-rsvp\\');\\n  if (!modal) return;\\n\\n  function openModal() { \\n  modal.style.display = \\'flex\\'; \\n  // \\uD83D\\uDD01 Reset visual y estado cada vez que se abre\\n  setConfirmaUI(\"si\", ').concat(JSON.stringify(color), ');\\n}\\n\\n  function closeModal() { modal.style.display = \\'none\\'; }\\n\\n  // Botones internos\\n  var closeBtn = document.getElementById(\\'rsvp-close\\');\\n  var cancelBtn = document.getElementById(\\'rsvp-cancel\\');\\n  var sendBtn = document.getElementById(\\'rsvp-send\\');\\n\\n  if (closeBtn) closeBtn.addEventListener(\\'click\\', closeModal);\\n  if (cancelBtn) cancelBtn.addEventListener(\\'click\\', closeModal);\\n\\n  // Click fuera del cuadro\\n  modal.addEventListener(\\'click\\', function(e) {\\n    if (e.target === modal) closeModal();\\n  });\\n\\n  // Abridores: cualquier elemento con data-rsvp-open\\ndocument.querySelectorAll(\\'[data-rsvp-open], [data-accion=\"abrir-rsvp\"], .rsvp-boton\\').forEach(function(el) {\\n    el.addEventListener(\\'click\\', function(e) {\\n      e.preventDefault();\\n      openModal();\\n    });\\n  });\\n\\n\\n// Estado interno del selector S\\xed/No\\nvar confirmaValor = \"si\"; // default\\n\\nfunction setConfirmaUI(valor, color) {\\n  var cont = document.getElementById(\\'rsvp-confirma\\');\\n  if (!cont) return;\\n  var btnSi = cont.querySelector(\\'[data-confirma=\"si\"]\\');\\n  var btnNo = cont.querySelector(\\'[data-confirma=\"no\"]\\');\\n  confirmaValor = (valor === \"no\") ? \"no\" : \"si\";\\n\\n  if (btnSi && btnNo) {\\n    if (confirmaValor === \"si\") {\\n      btnSi.style.background = color;\\n      btnSi.style.color = \"#fff\";\\n      btnSi.setAttribute(\"aria-pressed\", \"true\");\\n\\n      btnNo.style.background = \"#f6f6f6\";\\n      btnNo.style.color = \"#444\";\\n      btnNo.setAttribute(\"aria-pressed\", \"false\");\\n    } else {\\n      btnNo.style.background = color;\\n      btnNo.style.color = \"#fff\";\\n      btnNo.setAttribute(\"aria-pressed\", \"true\");\\n\\n      btnSi.style.background = \"#f6f6f6\";\\n      btnSi.style.color = \"#444\";\\n      btnSi.setAttribute(\"aria-pressed\", \"false\");\\n    }\\n  }\\n}\\n\\n// \\uD83D\\uDD39 Dejar \"S\\xed\" seleccionado al cargar\\nsetConfirmaUI(\"si\", ').concat(JSON.stringify(color), \");\\n\\n// \\uD83D\\uDD39 Alternar selecci\\xf3n al click\\nvar confirmaWrap = document.getElementById('rsvp-confirma');\\nif (confirmaWrap) {\\n  confirmaWrap.addEventListener('click', function(e) {\\n    var btn = e.target.closest('[data-confirma]');\\n    if (!btn) return;\\n    var v = btn.getAttribute('data-confirma');\\n    setConfirmaUI(v, \").concat(JSON.stringify(color), \");\\n    try { console.log(\\\"[RSVP] cambia confirmaValor =\\\", v); } catch(_) {}\\n  });\\n}\\n\\n\\n\\n  // ✅ Env\\xedo con Firestore + logs\\nif (sendBtn) {\\n  sendBtn.addEventListener('click', function() {\\n    var nombre = (document.getElementById('rsvp-nombre') || {}).value || '';\\n    var mensaje = (document.getElementById('rsvp-mensaje') || {}).value || '';\\n\\n    if (!nombre.trim()) {\\n      alert('Por favor ingres\\xe1 tu nombre.');\\n      return;\\n    }\\n\\n    const confirma = (confirmaValor === \\\"si\\\"); \\n    const slug = getSlugDePagina();\\n    console.log(\\\"[RSVP] Enviando RSVP… slug =\\\", slug);\\n\\n    // (opcional) si segu\\xeds usando sheetUrl, mantenemos el POST “en paralelo”\\n    var sheetUrl = \").concat(JSON.stringify(cfg.sheetUrl || \"\"), ';\\n    if (sheetUrl) {\\n      try {\\n        fetch(sheetUrl, {\\n          method: \\'POST\\',\\n          headers: {\\'Content-Type\\':\\'application/json\\'},\\n          body: JSON.stringify({\\n            nombre: nombre.trim(),\\n            mensaje: mensaje.trim(),\\n            slug: slug,\\n            ts: Date.now()\\n          })\\n        }).catch(function(e){ console.warn(\"[RSVP] sheetUrl error:\", e); });\\n      } catch (e) {\\n        console.warn(\"[RSVP] sheetUrl throw:\", e);\\n      }\\n    }\\n\\n    // \\uD83D\\uDD0C Importar Firebase din\\xe1micamente y guardar en Firestore\\n    Promise.all([\\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js\"),\\n      import(\"https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js\"),\\n    ])\\n    .then(([appMod, fsMod]) => {\\n      const { initializeApp } = appMod;\\n      const { getFirestore, collection, addDoc, serverTimestamp } = fsMod;\\n\\n      // ⚙️ Config m\\xednima (apiKey y projectId son suficientes para el cliente)\\n      const firebaseConfig = {\\n        apiKey: \"AIzaSyALCvU48_HRp26cXpQcTX5S33Adpwfl3z4\",\\n        authDomain: \"reservaeldia.com.ar\",\\n        projectId: \"reservaeldia-7a440\",\\n        appId: \"1:860495975406:web:3a49ad0cf55d60313534ff\"\\n      };\\n\\n      const app = initializeApp(firebaseConfig);\\n      const db  = getFirestore(app);\\n\\n      const payload = {\\n        nombre: nombre.trim(),\\n        mensaje: (mensaje && mensaje.trim()) || null,\\n        confirma,\\n        createdAt: serverTimestamp(),\\n        userAgent: navigator.userAgent.slice(0, 512)\\n      };\\n\\n      console.log(\"[RSVP] Payload keys =\", Object.keys(payload));\\n      console.log(\"[RSVP] Payload =\", JSON.stringify(payload));\\n\\n      return addDoc(collection(db, \"publicadas\", slug, \"rsvps\"), payload);\\n    })\\n    .then((docRef) => {\\n      console.log(\"[RSVP] RSVP guardado con ID:\", docRef.id, \"en /publicadas/\"+slug+\"/rsvps\");\\n      alert(\\'\\xa1Gracias por confirmar tu asistencia, \\' + nombre + \\'!\\');\\n      closeModal();\\n    })\\n    .catch((err) => {\\n      console.error(\"[RSVP] Error guardando en Firestore:\", err);\\n      alert(\\'Hubo un error al guardar tu confirmaci\\xf3n. Prob\\xe1 de nuevo.\\');\\n    });\\n  });\\n}\\n \\n  \\n\\n});\\n</script>\\n');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vZGFsUlNWUC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMENBQTBDO0FBV25DLFNBQVNBLHFCQUFxQkMsR0FBZTtJQUNoRCxJQUFJLEVBQUNBLGdCQUFBQSwwQkFBQUEsSUFBS0MsT0FBTyxHQUFFLE9BQU87UUFFWkQ7SUFBZCxNQUFNRSxRQUFRRixDQUFBQSxhQUFBQSxJQUFJRSxLQUFLLGNBQVRGLHdCQUFBQSxhQUFhO1FBQ1ZBO0lBQWpCLE1BQU1HLFdBQVdILENBQUFBLGdCQUFBQSxJQUFJRyxRQUFRLGNBQVpILDJCQUFBQSxnQkFBZ0I7UUFDakJBO0lBQWhCLE1BQU1JLFVBQVVKLENBQUFBLGtCQUFBQSxJQUFJSyxVQUFVLGNBQWRMLDZCQUFBQSxrQkFBa0I7UUFDcEJBO0lBQWQsTUFBTU0sUUFBUU4sQ0FBQUEsb0JBQUFBLElBQUlPLFlBQVksY0FBaEJQLCtCQUFBQSxvQkFBb0I7SUFFbEMsK0RBQStEO0lBQy9ELGtDQUFrQztJQUNsQyxPQUFPLGtlQVlMRyxPQUh3Q0QsT0FBTSxzS0FrQkdJLE9BZmpESCxXQUFXLDZDQUFzRCxPQUFUQSxVQUFTLFVBQVEsSUFBRyxrM0JBeUI2Q0csT0FWeEVBLE9BQU0sbXFCQVU2RUYsT0FBWEUsT0FBTSxPQStEN0dFLE9BL0RrSEosU0FBUSxtakVBMEg1SEksT0EzREVBLEtBQUtDLFNBQVMsQ0FBQ0gsUUFBTyxnMkRBb0V2QkUsT0FUREEsS0FBS0MsU0FBUyxDQUFDSCxRQUFPLHFWQWdDdkJFLE9BdkJFQSxLQUFLQyxTQUFTLENBQUNILFFBQU8seXNCQXVCVyxPQUFuQ0UsS0FBS0MsU0FBUyxDQUFDVCxJQUFJVSxRQUFRLElBQUksS0FBSTtBQW9FeEQiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcZ2VuZXJhck1vZGFsUlNWUC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL2dlbmVyYXJNb2RhbFJTVlAudHNcclxuXHJcbmV4cG9ydCB0eXBlIFJTVlBDb25maWcgPSB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG4gICAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgICBzdWJ0aXRsZT86IHN0cmluZztcclxuICAgIGJ1dHRvblRleHQ/OiBzdHJpbmc7XHJcbiAgICBwcmltYXJ5Q29sb3I/OiBzdHJpbmc7IC8vIGNvbG9yIGRlbCBib3TDs24vY2FiZWNlcmFcclxuICAgIHNoZWV0VXJsPzogc3RyaW5nOyAgICAgLy8gb3BjaW9uYWwgc2kgdmFzIGEgZW52aWFyIGEgR29vZ2xlIFNoZWV0cyBvIHNpbWlsYXJcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmFyTW9kYWxSU1ZQSFRNTChjZmc6IFJTVlBDb25maWcpOiBzdHJpbmcge1xyXG4gICAgaWYgKCFjZmc/LmVuYWJsZWQpIHJldHVybiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IHRpdGxlID0gY2ZnLnRpdGxlID8/IFwiQ29uZmlybWFyIGFzaXN0ZW5jaWFcIjtcclxuICAgIGNvbnN0IHN1YnRpdGxlID0gY2ZnLnN1YnRpdGxlID8/IFwiXCI7XHJcbiAgICBjb25zdCBidG5UZXh0ID0gY2ZnLmJ1dHRvblRleHQgPz8gXCJFbnZpYXJcIjtcclxuICAgIGNvbnN0IGNvbG9yID0gY2ZnLnByaW1hcnlDb2xvciA/PyBcIiM3NzNkYmVcIjtcclxuXHJcbiAgICAvLyBOb3RhOiBlbCBib3TDs24gcXVlIGFicmUgZWwgbW9kYWwgZGViZSB0ZW5lciBbZGF0YS1yc3ZwLW9wZW5dXHJcbiAgICAvLyAoZWwgbGlzdGVuZXIgZGUgYWJham8gbG8gYnVzY2EpXHJcbiAgICByZXR1cm4gYFxyXG48ZGl2IGlkPVwibW9kYWwtcnN2cFwiIHN0eWxlPVwiXHJcbiAgcG9zaXRpb246IGZpeGVkOyBpbnNldDogMDsgZGlzcGxheTpub25lO1xyXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsLjYpOyB6LWluZGV4OiA5OTk5O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyO1wiPlxyXG4gIDxkaXYgc3R5bGU9XCJcclxuICAgIGJhY2tncm91bmQ6ICNmZmY7IHdpZHRoOiA5MCU7IG1heC13aWR0aDogNDIwcHg7IGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICBwYWRkaW5nOiAyMHB4OyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgYm94LXNoYWRvdzogMCAxMHB4IDMwcHggcmdiYSgwLDAsMCwuMik7XCI+XHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOmNlbnRlcjtcIj5cclxuICAgICAgPGgyIHN0eWxlPVwibWFyZ2luOjA7IGZvbnQtc2l6ZToyMHB4O1wiPiR7dGl0bGV9PC9oMj5cclxuICAgICAgPGJ1dHRvbiBpZD1cInJzdnAtY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2VycmFyXCIgc3R5bGU9XCJib3JkZXI6bm9uZTsgYmFja2dyb3VuZDp0cmFuc3BhcmVudDsgZm9udC1zaXplOjE4cHg7IGN1cnNvcjpwb2ludGVyO1wiPuKclTwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICAke3N1YnRpdGxlID8gYDxwIHN0eWxlPVwibWFyZ2luOjhweCAwIDE2cHg7IGNvbG9yOiM1NTU7XCI+JHtzdWJ0aXRsZX08L3A+YCA6IFwiXCJ9XHJcblxyXG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6ZmxleDsgZmxleC1kaXJlY3Rpb246Y29sdW1uOyBnYXA6MTBweDtcIj5cclxuICAgICAgPGlucHV0IGlkPVwicnN2cC1ub21icmVcIiBwbGFjZWhvbGRlcj1cIlR1IG5vbWJyZVwiIHN0eWxlPVwicGFkZGluZzoxMHB4OyBib3JkZXI6MXB4IHNvbGlkICNjY2M7IGJvcmRlci1yYWRpdXM6NnB4O1wiIC8+XHJcbiAgICAgIDxpbnB1dCBpZD1cInJzdnAtbWVuc2FqZVwiIHBsYWNlaG9sZGVyPVwiTWVuc2FqZSAob3BjaW9uYWwpXCIgc3R5bGU9XCJwYWRkaW5nOjEwcHg7IGJvcmRlcjoxcHggc29saWQgI2NjYzsgYm9yZGVyLXJhZGl1czo2cHg7XCIgLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgICA8IS0tIOKchSBOVUVWTzogc2VsZWN0b3IgU8OtL05vIGNvbiBlc3RpbG8gc2VnbWVudGFkbyAtLT5cclxuICAgIDxkaXYgc3R5bGU9XCJtYXJnaW4tdG9wOjEycHg7XCI+XHJcbiAgICAgIDxsYWJlbCBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IGZvbnQtd2VpZ2h0OjYwMDsgbWFyZ2luLWJvdHRvbTo4cHg7XCI+wr9Db25maXJtw6FzIGFzaXN0ZW5jaWE/PC9sYWJlbD5cclxuICAgICAgPGRpdiBpZD1cInJzdnAtY29uZmlybWFcIiBzdHlsZT1cIlxyXG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWZsZXg7IGdhcDowOyBib3JkZXI6MXB4IHNvbGlkICNkZGQ7IGJvcmRlci1yYWRpdXM6MTBweDsgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgwLDAsMCwwLjAzKTtcclxuICAgICAgXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1jb25maXJtYT1cInNpXCIgYXJpYS1wcmVzc2VkPVwidHJ1ZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6JHtjb2xvcn07IGNvbG9yOiNmZmY7IGZvbnQtd2VpZ2h0OjYwMDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+U8OtLCB2b3k8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWNvbmZpcm1hPVwibm9cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIHN0eWxlPVwiXHJcbiAgICAgICAgICBwYWRkaW5nOjEwcHggMTRweDsgYm9yZGVyOm5vbmU7IGJhY2tncm91bmQ6I2Y2ZjZmNjsgY29sb3I6IzQ0NDsgY3Vyc29yOnBvaW50ZXI7XHJcbiAgICAgICAgXCI+Tm8gcHVlZG88L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTpmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7IGdhcDoxMHB4OyBtYXJnaW4tdG9wOjE2cHg7XCI+XHJcbiAgICAgIDxidXR0b24gaWQ9XCJyc3ZwLWNhbmNlbFwiIHN0eWxlPVwicGFkZGluZzo4cHggMTJweDsgYm9yZGVyLXJhZGl1czo2cHg7IGJvcmRlcjoxcHggc29saWQgI2RkZDsgYmFja2dyb3VuZDojZjNmM2YzOyBjdXJzb3I6cG9pbnRlcjtcIj5DYW5jZWxhcjwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGlkPVwicnN2cC1zZW5kXCIgc3R5bGU9XCJwYWRkaW5nOjhweCAxMnB4OyBib3JkZXItcmFkaXVzOjZweDsgYm9yZGVyOm5vbmU7IGNvbG9yOiNmZmY7IGN1cnNvcjpwb2ludGVyOyBiYWNrZ3JvdW5kOiR7Y29sb3J9O1wiPiR7YnRuVGV4dH08L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5mdW5jdGlvbiBnZXRTbHVnRGVQYWdpbmEoKSB7XHJcbiAgLy8gMCkgTG9nIGRlIGF5dWRhXHJcbiAgdHJ5IHsgY29uc29sZS5sb2coXCJbUlNWUF0gaHJlZjpcIiwgbG9jYXRpb24uaHJlZik7IH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIC8vIDEpIDxodG1sIGRhdGEtc2x1Zz1cIi4uLlwiPiAoc2kgbG8gaW55ZWN0w6FzIGVuIGVsIEhUTUwgZmluYWwpXHJcbiAgY29uc3QgZHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/LmRhdGFzZXQ/LnNsdWc7XHJcbiAgaWYgKGRzKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBkYXRhLWF0cmlidXRvOlwiLCBkcyk7XHJcbiAgICByZXR1cm4gZHM7XHJcbiAgfVxyXG5cclxuICAvLyAyKSA/c2x1Zz0uLi4gZW4gbGEgVVJMXHJcbiAgY29uc3QgcSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKS5nZXQoXCJzbHVnXCIpO1xyXG4gIGlmIChxKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBzbHVnIHBvciBxdWVyeXN0cmluZzpcIiwgcSk7XHJcbiAgICByZXR1cm4gcTtcclxuICB9XHJcblxyXG4gIC8vIDMpIC9wdWJsaWNhZGFzLzxzbHVnPi8uLi4gZW4gdW4gc2l0aW8gZXN0w6F0aWNvIChIb3N0aW5nL1Byb3h5KVxyXG4gIGNvbnN0IHBhcnRzID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcclxuICBjb25zdCBpID0gcGFydHMuaW5kZXhPZihcInB1YmxpY2FkYXNcIik7XHJcbiAgaWYgKGkgPj0gMCAmJiBwYXJ0c1tpICsgMV0pIHtcclxuICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIHBhdGhuYW1lIGRpcmVjdG86XCIsIHBhcnRzW2kgKyAxXSk7XHJcbiAgICByZXR1cm4gcGFydHNbaSArIDFdO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgVVJMIGRlIEZpcmViYXNlIFN0b3JhZ2U6XHJcbiAgLy8gICAgaHR0cHM6Ly9maXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYSZ0b2tlbj0uLi5cclxuICAvLyAgICBodHRwczovLzxidWNrZXQ+LmZpcmViYXNlc3RvcmFnZS5hcHAvdjAvYi88YnVja2V0Pi9vL3B1YmxpY2FkYXMlMkY8c2x1Zz4lMkZpbmRleC5odG1sP2FsdD1tZWRpYVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXRoQWZ0ZXJPID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvby9cIilbMV07IC8vIFwicHVibGljYWRhcyUyRjxzbHVnPiUyRmluZGV4Lmh0bWxcIlxyXG4gICAgaWYgKHBhdGhBZnRlck8pIHtcclxuICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChwYXRoQWZ0ZXJPKTsgICAgICAvLyBcInB1YmxpY2FkYXMvPHNsdWc+L2luZGV4Lmh0bWxcIlxyXG4gICAgICBjb25zdCBzZWdzID0gZGVjb2RlZC5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgICBjb25zdCBqID0gc2Vncy5pbmRleE9mKFwicHVibGljYWRhc1wiKTtcclxuICAgICAgaWYgKGogPj0gMCAmJiBzZWdzW2ogKyAxXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIHNsdWcgcG9yIFVSTCBkZSBTdG9yYWdlOlwiLCBzZWdzW2ogKyAxXSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiW1JTVlBdIEVycm9yIHBhcnNlYW5kbyBVUkwgZGUgU3RvcmFnZTpcIiwgZSk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLndhcm4oXCJbUlNWUF0gTm8gc2UgcHVkbyBkZXRlY3RhciBzbHVnLiBGYWxsYmFjazogc2luLXNsdWdcIik7XHJcbiAgcmV0dXJuIFwic2luLXNsdWdcIjtcclxufVxyXG5cclxuXHJcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsLXJzdnAnKTtcclxuICBpZiAoIW1vZGFsKSByZXR1cm47XHJcblxyXG4gIGZ1bmN0aW9uIG9wZW5Nb2RhbCgpIHsgXHJcbiAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgXHJcbiAgLy8g8J+UgSBSZXNldCB2aXN1YWwgeSBlc3RhZG8gY2FkYSB2ZXogcXVlIHNlIGFicmVcclxuICBzZXRDb25maXJtYVVJKFwic2lcIiwgJHtKU09OLnN0cmluZ2lmeShjb2xvcil9KTtcclxufVxyXG5cclxuICBmdW5jdGlvbiBjbG9zZU1vZGFsKCkgeyBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9XHJcblxyXG4gIC8vIEJvdG9uZXMgaW50ZXJub3NcclxuICB2YXIgY2xvc2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jbG9zZScpO1xyXG4gIHZhciBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1jYW5jZWwnKTtcclxuICB2YXIgc2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLXNlbmQnKTtcclxuXHJcbiAgaWYgKGNsb3NlQnRuKSBjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG4gIGlmIChjYW5jZWxCdG4pIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTW9kYWwpO1xyXG5cclxuICAvLyBDbGljayBmdWVyYSBkZWwgY3VhZHJvXHJcbiAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQgPT09IG1vZGFsKSBjbG9zZU1vZGFsKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIEFicmlkb3JlczogY3VhbHF1aWVyIGVsZW1lbnRvIGNvbiBkYXRhLXJzdnAtb3BlblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1yc3ZwLW9wZW5dLCBbZGF0YS1hY2Npb249XCJhYnJpci1yc3ZwXCJdLCAucnN2cC1ib3RvbicpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIG9wZW5Nb2RhbCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG5cclxuLy8gRXN0YWRvIGludGVybm8gZGVsIHNlbGVjdG9yIFPDrS9Ob1xyXG52YXIgY29uZmlybWFWYWxvciA9IFwic2lcIjsgLy8gZGVmYXVsdFxyXG5cclxuZnVuY3Rpb24gc2V0Q29uZmlybWFVSSh2YWxvciwgY29sb3IpIHtcclxuICB2YXIgY29udCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbiAgaWYgKCFjb250KSByZXR1cm47XHJcbiAgdmFyIGJ0blNpID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cInNpXCJdJyk7XHJcbiAgdmFyIGJ0bk5vID0gY29udC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb25maXJtYT1cIm5vXCJdJyk7XHJcbiAgY29uZmlybWFWYWxvciA9ICh2YWxvciA9PT0gXCJub1wiKSA/IFwibm9cIiA6IFwic2lcIjtcclxuXHJcbiAgaWYgKGJ0blNpICYmIGJ0bk5vKSB7XHJcbiAgICBpZiAoY29uZmlybWFWYWxvciA9PT0gXCJzaVwiKSB7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcjtcclxuICAgICAgYnRuU2kuc3R5bGUuY29sb3IgPSBcIiNmZmZcIjtcclxuICAgICAgYnRuU2kuc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKTtcclxuXHJcbiAgICAgIGJ0bk5vLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgYnRuTm8uc3R5bGUuY29sb3IgPSBcIiM0NDRcIjtcclxuICAgICAgYnRuTm8uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBidG5Oby5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3I7XHJcbiAgICAgIGJ0bk5vLnN0eWxlLmNvbG9yID0gXCIjZmZmXCI7XHJcbiAgICAgIGJ0bk5vLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XHJcblxyXG4gICAgICBidG5TaS5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZjZmNmY2XCI7XHJcbiAgICAgIGJ0blNpLnN0eWxlLmNvbG9yID0gXCIjNDQ0XCI7XHJcbiAgICAgIGJ0blNpLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+UuSBEZWphciBcIlPDrVwiIHNlbGVjY2lvbmFkbyBhbCBjYXJnYXJcclxuc2V0Q29uZmlybWFVSShcInNpXCIsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcblxyXG4vLyDwn5S5IEFsdGVybmFyIHNlbGVjY2nDs24gYWwgY2xpY2tcclxudmFyIGNvbmZpcm1hV3JhcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyc3ZwLWNvbmZpcm1hJyk7XHJcbmlmIChjb25maXJtYVdyYXApIHtcclxuICBjb25maXJtYVdyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgYnRuID0gZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtY29uZmlybWFdJyk7XHJcbiAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG4gICAgdmFyIHYgPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbmZpcm1hJyk7XHJcbiAgICBzZXRDb25maXJtYVVJKHYsICR7SlNPTi5zdHJpbmdpZnkoY29sb3IpfSk7XHJcbiAgICB0cnkgeyBjb25zb2xlLmxvZyhcIltSU1ZQXSBjYW1iaWEgY29uZmlybWFWYWxvciA9XCIsIHYpOyB9IGNhdGNoKF8pIHt9XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuICAvLyDinIUgRW52w61vIGNvbiBGaXJlc3RvcmUgKyBsb2dzXHJcbmlmIChzZW5kQnRuKSB7XHJcbiAgc2VuZEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5vbWJyZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1ub21icmUnKSB8fCB7fSkudmFsdWUgfHwgJyc7XHJcbiAgICB2YXIgbWVuc2FqZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnN2cC1tZW5zYWplJykgfHwge30pLnZhbHVlIHx8ICcnO1xyXG5cclxuICAgIGlmICghbm9tYnJlLnRyaW0oKSkge1xyXG4gICAgICBhbGVydCgnUG9yIGZhdm9yIGluZ3Jlc8OhIHR1IG5vbWJyZS4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpcm1hID0gKGNvbmZpcm1hVmFsb3IgPT09IFwic2lcIik7IFxyXG4gICAgY29uc3Qgc2x1ZyA9IGdldFNsdWdEZVBhZ2luYSgpO1xyXG4gICAgY29uc29sZS5sb2coXCJbUlNWUF0gRW52aWFuZG8gUlNWUOKApiBzbHVnID1cIiwgc2x1Zyk7XHJcblxyXG4gICAgLy8gKG9wY2lvbmFsKSBzaSBzZWd1w61zIHVzYW5kbyBzaGVldFVybCwgbWFudGVuZW1vcyBlbCBQT1NUIOKAnGVuIHBhcmFsZWxv4oCdXHJcbiAgICB2YXIgc2hlZXRVcmwgPSAke0pTT04uc3RyaW5naWZ5KGNmZy5zaGVldFVybCB8fCBcIlwiKX07XHJcbiAgICBpZiAoc2hlZXRVcmwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmZXRjaChzaGVldFVybCwge1xyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgbm9tYnJlOiBub21icmUudHJpbSgpLFxyXG4gICAgICAgICAgICBtZW5zYWplOiBtZW5zYWplLnRyaW0oKSxcclxuICAgICAgICAgICAgc2x1Zzogc2x1ZyxcclxuICAgICAgICAgICAgdHM6IERhdGUubm93KClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSl7IGNvbnNvbGUud2FybihcIltSU1ZQXSBzaGVldFVybCBlcnJvcjpcIiwgZSk7IH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1JTVlBdIHNoZWV0VXJsIHRocm93OlwiLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIPCflIwgSW1wb3J0YXIgRmlyZWJhc2UgZGluw6FtaWNhbWVudGUgeSBndWFyZGFyIGVuIEZpcmVzdG9yZVxyXG4gICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtYXBwLmpzXCIpLFxyXG4gICAgICBpbXBvcnQoXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9maXJlYmFzZWpzLzEwLjEyLjQvZmlyZWJhc2UtZmlyZXN0b3JlLmpzXCIpLFxyXG4gICAgXSlcclxuICAgIC50aGVuKChbYXBwTW9kLCBmc01vZF0pID0+IHtcclxuICAgICAgY29uc3QgeyBpbml0aWFsaXplQXBwIH0gPSBhcHBNb2Q7XHJcbiAgICAgIGNvbnN0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCB9ID0gZnNNb2Q7XHJcblxyXG4gICAgICAvLyDimpnvuI8gQ29uZmlnIG3DrW5pbWEgKGFwaUtleSB5IHByb2plY3RJZCBzb24gc3VmaWNpZW50ZXMgcGFyYSBlbCBjbGllbnRlKVxuICAgICAgY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gICAgICAgIGFwaUtleTogXCJBSXphU3lBTEN2VTQ4X0hScDI2Y1hwUWNUWDVTMzNBZHB3ZmwzejRcIixcbiAgICAgICAgYXV0aERvbWFpbjogXCJyZXNlcnZhZWxkaWEuY29tLmFyXCIsXG4gICAgICAgIHByb2plY3RJZDogXCJyZXNlcnZhZWxkaWEtN2E0NDBcIixcbiAgICAgICAgYXBwSWQ6IFwiMTo4NjA0OTU5NzU0MDY6d2ViOjNhNDlhZDBjZjU1ZDYwMzEzNTM0ZmZcIlxuICAgICAgfTtcblxyXG4gICAgICBjb25zdCBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcclxuICAgICAgY29uc3QgZGIgID0gZ2V0RmlyZXN0b3JlKGFwcCk7XHJcblxyXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgIG5vbWJyZTogbm9tYnJlLnRyaW0oKSxcclxuICAgICAgICBtZW5zYWplOiAobWVuc2FqZSAmJiBtZW5zYWplLnRyaW0oKSkgfHwgbnVsbCxcclxuICAgICAgICBjb25maXJtYSxcclxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudC5zbGljZSgwLCA1MTIpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIltSU1ZQXSBQYXlsb2FkIGtleXMgPVwiLCBPYmplY3Qua2V5cyhwYXlsb2FkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFBheWxvYWQgPVwiLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcblxyXG4gICAgICByZXR1cm4gYWRkRG9jKGNvbGxlY3Rpb24oZGIsIFwicHVibGljYWRhc1wiLCBzbHVnLCBcInJzdnBzXCIpLCBwYXlsb2FkKTtcclxuICAgIH0pXHJcbiAgICAudGhlbigoZG9jUmVmKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiW1JTVlBdIFJTVlAgZ3VhcmRhZG8gY29uIElEOlwiLCBkb2NSZWYuaWQsIFwiZW4gL3B1YmxpY2FkYXMvXCIrc2x1ZytcIi9yc3Zwc1wiKTtcclxuICAgICAgYWxlcnQoJ8KhR3JhY2lhcyBwb3IgY29uZmlybWFyIHR1IGFzaXN0ZW5jaWEsICcgKyBub21icmUgKyAnIScpO1xyXG4gICAgICBjbG9zZU1vZGFsKCk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIltSU1ZQXSBFcnJvciBndWFyZGFuZG8gZW4gRmlyZXN0b3JlOlwiLCBlcnIpO1xyXG4gICAgICBhbGVydCgnSHVibyB1biBlcnJvciBhbCBndWFyZGFyIHR1IGNvbmZpcm1hY2nDs24uIFByb2LDoSBkZSBudWV2by4nKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbiBcclxuICBcclxuXHJcbn0pO1xyXG48L3NjcmlwdD5cclxuYDtcclxufVxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhck1vZGFsUlNWUEhUTUwiLCJjZmciLCJlbmFibGVkIiwidGl0bGUiLCJzdWJ0aXRsZSIsImJ0blRleHQiLCJidXR0b25UZXh0IiwiY29sb3IiLCJwcmltYXJ5Q29sb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hlZXRVcmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarModalRSVP.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/generarMotionEffectsRuntime.ts":
/*!************************************************************!*\
  !*** ./functions/src/utils/generarMotionEffectsRuntime.ts ***!
  \************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generarMotionEffectsRuntimeHTML: () => (/* binding */ generarMotionEffectsRuntimeHTML)\n/* harmony export */ });\nfunction generarMotionEffectsRuntimeHTML() {\n    return '\\n<style>\\n  .mefx-preparing .mefx-reveal-init,\\n  .mefx-preparing .mefx-zoom-init,\\n  .mefx-preparing .mefx-draw-init,\\n  .mefx-preparing .mefx-stagger-item {\\n    transition: none !important;\\n  }\\n\\n  .mefx-reveal-init {\\n    opacity: 0;\\n    translate: 0 14px;\\n    will-change: opacity, translate;\\n    transition:\\n      opacity 640ms cubic-bezier(0.22, 1, 0.36, 1),\\n      translate 640ms cubic-bezier(0.22, 1, 0.36, 1);\\n  }\\n\\n  .mefx-reveal-on {\\n    opacity: 1;\\n    translate: 0 0;\\n  }\\n\\n  .mefx-zoom-init {\\n    opacity: 0;\\n    scale: 0.98;\\n    transform-origin: center center;\\n    will-change: opacity, scale;\\n    transition:\\n      opacity 620ms cubic-bezier(0.22, 1, 0.36, 1),\\n      scale 760ms cubic-bezier(0.22, 1, 0.36, 1);\\n  }\\n\\n  .mefx-zoom-on {\\n    opacity: 1;\\n    scale: 1;\\n  }\\n\\n  .mefx-draw-init {\\n    opacity: 0.95;\\n    scale: 0 1;\\n    transform-origin: left center;\\n    will-change: scale;\\n    transition:\\n      opacity 520ms ease,\\n      scale 800ms cubic-bezier(0.2, 0.8, 0.2, 1);\\n  }\\n\\n  .mefx-draw-on {\\n    opacity: 1;\\n    scale: 1 1;\\n  }\\n\\n  .mefx-hover {\\n    cursor: pointer;\\n    transform-origin: center center;\\n    will-change: scale, opacity;\\n    transition:\\n      scale 230ms ease,\\n      opacity 230ms ease;\\n  }\\n\\n  .mefx-hover:hover {\\n    scale: 1.01;\\n  }\\n\\n  .mefx-hover:active {\\n    scale: 0.99;\\n  }\\n\\n  .mefx-hover:focus-visible {\\n    outline: 2px solid rgba(119, 61, 190, 0.34);\\n    outline-offset: 2px;\\n  }\\n\\n  @keyframes mefxPulse {\\n    0%, 100% {\\n      opacity: 1;\\n      filter: none;\\n    }\\n    50% {\\n      opacity: 0.9;\\n      filter: saturate(1.03);\\n    }\\n  }\\n\\n  @keyframes mefxPulseCountdownChip {\\n    0%, 100% {\\n      transform: translateY(0) scale(1);\\n      box-shadow: 0 0 0 rgba(17, 24, 39, 0);\\n    }\\n    50% {\\n      transform: translateY(-1px) scale(1.018);\\n      box-shadow: 0 8px 16px rgba(17, 24, 39, 0.14);\\n    }\\n  }\\n\\n  .mefx-pulse {\\n    animation: mefxPulse 2.6s ease-in-out infinite;\\n  }\\n\\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip {\\n    animation: mefxPulseCountdownChip 2.6s ease-in-out infinite;\\n    transform-origin: center center;\\n    will-change: transform, box-shadow;\\n  }\\n\\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(1) {\\n    animation-delay: 0ms;\\n  }\\n\\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(2) {\\n    animation-delay: 90ms;\\n  }\\n\\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(3) {\\n    animation-delay: 180ms;\\n  }\\n\\n  .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip:nth-child(4) {\\n    animation-delay: 270ms;\\n  }\\n\\n  .mefx-stagger-item {\\n    opacity: 0;\\n    translate: 0 10px;\\n    will-change: translate, opacity;\\n    transition:\\n      opacity 620ms cubic-bezier(0.22, 1, 0.36, 1),\\n      translate 620ms cubic-bezier(0.22, 1, 0.36, 1);\\n    transition-delay: var(--mefx-stagger-delay, 0ms);\\n  }\\n\\n  .mefx-stagger-item.mefx-stagger-on {\\n    opacity: 1;\\n    translate: 0 0;\\n  }\\n\\n  @keyframes mefxRevealMobileIn {\\n    from {\\n      opacity: 0;\\n      translate: 0 10px;\\n    }\\n    to {\\n      opacity: 1;\\n      translate: 0 0;\\n    }\\n  }\\n\\n  @keyframes mefxZoomMobileIn {\\n    from {\\n      opacity: 0;\\n      scale: 0.99;\\n    }\\n    to {\\n      opacity: 1;\\n      scale: 1;\\n    }\\n  }\\n\\n  @keyframes mefxDrawMobileIn {\\n    from {\\n      opacity: 0.95;\\n      scale: 0 1;\\n    }\\n    to {\\n      opacity: 1;\\n      scale: 1 1;\\n    }\\n  }\\n\\n  @media (max-width: 767px) {\\n    .mefx-reveal-init {\\n      translate: 0 10px;\\n      transition-duration: 540ms;\\n    }\\n\\n    .mefx-zoom-init {\\n      scale: 0.99;\\n      transition-duration: 580ms;\\n    }\\n\\n    .mefx-draw-init {\\n      transition-duration: 640ms;\\n    }\\n\\n    .mefx-stagger-item {\\n      transition-duration: 540ms;\\n    }\\n\\n    /* Fallback robusto mobile: cuando se agrega \"on\", forzamos keyframes */\\n    .mefx-reveal-on {\\n      animation: mefxRevealMobileIn 540ms cubic-bezier(0.22, 1, 0.36, 1) both;\\n    }\\n\\n    .mefx-zoom-on {\\n      animation: mefxZoomMobileIn 580ms cubic-bezier(0.22, 1, 0.36, 1) both;\\n    }\\n\\n    .mefx-draw-on {\\n      animation: mefxDrawMobileIn 640ms cubic-bezier(0.2, 0.8, 0.2, 1) both;\\n    }\\n\\n    .mefx-stagger-item.mefx-stagger-on {\\n      animation: mefxRevealMobileIn 540ms cubic-bezier(0.22, 1, 0.36, 1) both;\\n      animation-delay: var(--mefx-stagger-delay, 0ms);\\n    }\\n  }\\n\\n  @media (prefers-reduced-motion: reduce) {\\n    .mefx-reveal-init,\\n    .mefx-zoom-init,\\n    .mefx-draw-init,\\n    .mefx-stagger-item {\\n      opacity: 1 !important;\\n      translate: 0 0 !important;\\n      scale: 1 !important;\\n      transition: none !important;\\n    }\\n\\n    .mefx-pulse {\\n      animation: none !important;\\n    }\\n\\n    .objeto[data-type=\"countdown\"].mefx-pulse .cd-chip {\\n      animation: none !important;\\n      transform: none !important;\\n      box-shadow: none !important;\\n    }\\n  }\\n</style>\\n\\n<script>\\n(function(){\\n  var VALID_EFFECTS = { none: 1, reveal: 1, draw: 1, zoom: 1, hover: 1, pulse: 1 };\\n  var OBSERVED_EFFECTS = { reveal: 1, draw: 1, zoom: 1 };\\n  var STAGGER_SELECTOR = \".galeria-celda\";\\n  var PREPARING_CLASS = \"mefx-preparing\";\\n  var RUNTIME_READY_EVENT = \"invitation-runtime-ready\";\\n  var RUNTIME_FAIL_EVENT = \"invitation-runtime-failed\";\\n  var LOADER_HIDDEN_EVENT = \"invitation-loader-hidden\";\\n  var LOADER_WAIT_TIMEOUT_MS = 2400;\\n  var READY_TIMEOUT_MS = 2600;\\n  var FONTS_TIMEOUT_MS = 1200;\\n  var bootStarted = false;\\n\\n  function normalizeEffect(value){\\n    var normalized = String(value || \"\").trim().toLowerCase();\\n    return VALID_EFFECTS[normalized] ? normalized : \"none\";\\n  }\\n\\n  function normalizeType(value){\\n    return String(value || \"\").trim().toLowerCase();\\n  }\\n\\n  function setPreparingState(active){\\n    if (!document.body || !document.body.classList) return;\\n    if (active) {\\n      document.body.classList.add(PREPARING_CLASS);\\n      return;\\n    }\\n    document.body.classList.remove(PREPARING_CLASS);\\n  }\\n\\n  function dispatchRuntimeEvent(name, detail){\\n    try {\\n      window.dispatchEvent(new CustomEvent(name, { detail: detail || {} }));\\n    } catch (_error) {\\n      // noop\\n    }\\n  }\\n\\n  function isReducedMotion(){\\n    try {\\n      return !!(window.matchMedia && window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches);\\n    } catch (_error) {\\n      return false;\\n    }\\n  }\\n\\n  function waitForWindowLoad(maxWaitMs){\\n    return new Promise(function(resolve){\\n      if (document.readyState === \"complete\") {\\n        resolve();\\n        return;\\n      }\\n\\n      var finished = false;\\n      var onLoad = function(){\\n        if (finished) return;\\n        finished = true;\\n        resolve();\\n      };\\n\\n      window.addEventListener(\"load\", onLoad, { once: true });\\n      window.setTimeout(function(){\\n        if (finished) return;\\n        finished = true;\\n        resolve();\\n      }, maxWaitMs);\\n    });\\n  }\\n\\n  function waitForFonts(maxWaitMs){\\n    if (!document.fonts || !document.fonts.ready) {\\n      return Promise.resolve();\\n    }\\n\\n    return Promise.race([\\n      document.fonts.ready.catch(function(){ return null; }),\\n      new Promise(function(resolve){\\n        window.setTimeout(resolve, maxWaitMs);\\n      })\\n    ]).then(function(){ return null; });\\n  }\\n\\n  function waitForRuntimeReady(){\\n    return Promise.all([\\n      waitForWindowLoad(READY_TIMEOUT_MS),\\n      waitForFonts(FONTS_TIMEOUT_MS)\\n    ]).then(function(){ return null; });\\n  }\\n\\n  function extractFirstUrl(value){\\n    var raw = String(value || \"\");\\n    if (!raw || raw === \"none\") return \"\";\\n    var match = raw.match(/url(([\\'\"]?)(.*?)\\\\1)/i);\\n    if (!match || !match[2]) return \"\";\\n    return match[2].trim();\\n  }\\n\\n  function getFirstSectionBackgroundUrl(){\\n    var firstSection = document.querySelector(\".sec\");\\n    if (!firstSection) return \"\";\\n    var bgNode = firstSection.querySelector(\".sec-bg\");\\n    if (!bgNode) return \"\";\\n\\n    var inlineUrl = extractFirstUrl(bgNode.getAttribute(\"style\"));\\n    if (inlineUrl) return inlineUrl;\\n\\n    try {\\n      var computedUrl = extractFirstUrl(window.getComputedStyle(bgNode).backgroundImage);\\n      return computedUrl;\\n    } catch (_error) {\\n      return \"\";\\n    }\\n  }\\n\\n  function loadImage(url){\\n    return new Promise(function(resolve){\\n      if (!url) {\\n        resolve(true);\\n        return;\\n      }\\n\\n      var img = new Image();\\n      img.decoding = \"async\";\\n      img.loading = \"eager\";\\n\\n      img.onload = function(){\\n        resolve(true);\\n      };\\n\\n      img.onerror = function(){\\n        resolve(false);\\n      };\\n\\n      img.src = url;\\n\\n      if (img.complete && img.naturalWidth > 0) {\\n        resolve(true);\\n      }\\n    });\\n  }\\n\\n  function waitForFirstSectionBackground(){\\n    var backgroundUrl = getFirstSectionBackgroundUrl();\\n    return loadImage(backgroundUrl);\\n  }\\n\\n  function waitForLoaderHidden(){\\n    return new Promise(function(resolve){\\n      var loaderNode = document.getElementById(\"inv-loader\");\\n      if (!loaderNode) {\\n        resolve();\\n        return;\\n      }\\n\\n      var finished = false;\\n      function done(){\\n        if (finished) return;\\n        finished = true;\\n        resolve();\\n      }\\n\\n      window.addEventListener(LOADER_HIDDEN_EVENT, done, { once: true });\\n      window.setTimeout(done, LOADER_WAIT_TIMEOUT_MS);\\n    });\\n  }\\n\\n  function prepareGalleryStagger(element){\\n    var cells = Array.from(element.querySelectorAll(STAGGER_SELECTOR));\\n    if (!cells.length) return [];\\n\\n    cells.forEach(function(cell, index){\\n      var delayMs = Math.min(index, 11) * 70;\\n      cell.style.setProperty(\"--mefx-stagger-delay\", delayMs + \"ms\");\\n      cell.classList.add(\"mefx-stagger-item\");\\n    });\\n\\n    return cells;\\n  }\\n\\n  function prepareElement(element){\\n    var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\\n    var type = normalizeType(element.getAttribute(\"data-type\"));\\n    element.setAttribute(\"data-motion\", effect);\\n\\n    if (effect === \"hover\") {\\n      element.classList.add(\"mefx-hover\");\\n    }\\n\\n    if (effect === \"pulse\" && (type === \"countdown\" || type === \"rsvp\")) {\\n      element.classList.add(\"mefx-pulse\");\\n    }\\n\\n    if (effect === \"reveal\") element.classList.add(\"mefx-reveal-init\");\\n    if (effect === \"zoom\") element.classList.add(\"mefx-zoom-init\");\\n    if (effect === \"draw\") element.classList.add(\"mefx-draw-init\");\\n\\n    if (type === \"gallery\" && effect === \"reveal\") {\\n      prepareGalleryStagger(element);\\n    }\\n  }\\n\\n  function activateElement(element){\\n    var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\\n    var type = normalizeType(element.getAttribute(\"data-type\"));\\n\\n    if (effect === \"reveal\") element.classList.add(\"mefx-reveal-on\");\\n    if (effect === \"zoom\") element.classList.add(\"mefx-zoom-on\");\\n    if (effect === \"draw\") element.classList.add(\"mefx-draw-on\");\\n\\n    if (type === \"gallery\" && effect === \"reveal\") {\\n      var staggerItems = Array.from(element.querySelectorAll(STAGGER_SELECTOR + \".mefx-stagger-item\"));\\n      staggerItems.forEach(function(cell){\\n        cell.classList.add(\"mefx-stagger-on\");\\n      });\\n    }\\n  }\\n\\n  function boot(elements){\\n    var list = Array.isArray(elements) ? elements : [];\\n    if (!list.length) {\\n      list = Array.from(document.querySelectorAll(\".objeto[data-motion]\"));\\n    }\\n\\n    var elementsToAnimate = list;\\n    if (!elementsToAnimate.length) return;\\n\\n    var reducedMotion = isReducedMotion();\\n    if (reducedMotion || typeof IntersectionObserver === \"undefined\") {\\n      setPreparingState(false);\\n      elementsToAnimate.forEach(activateElement);\\n      return;\\n    }\\n\\n    // En mobile algunos navegadores colapsan \"quitar preparing + activar on\" en el mismo layout.\\n    // Damos un frame para reactivar transiciones antes de observar/activar.\\n    setPreparingState(false);\\n    requestAnimationFrame(function(){\\n      var queuedById = Object.create(null);\\n      var queuedElements = [];\\n      var activationReady = false;\\n\\n      function enqueueActivation(element){\\n        if (!element || !element.getAttribute) return;\\n        var key = element.getAttribute(\"data-motion-id\") || element.id || \"\";\\n        if (!key) key = \"idx-\" + queuedElements.length;\\n        if (queuedById[key]) return;\\n        queuedById[key] = true;\\n        queuedElements.push(element);\\n      }\\n\\n      function activateOrQueue(element){\\n        if (activationReady) {\\n          activateElement(element);\\n          return;\\n        }\\n        enqueueActivation(element);\\n      }\\n\\n      var observer = new IntersectionObserver(\\n        function(entries){\\n          entries.forEach(function(entry){\\n            if (!entry.isIntersecting) return;\\n            activateOrQueue(entry.target);\\n            observer.unobserve(entry.target);\\n          });\\n        },\\n        {\\n          root: null,\\n          threshold: 0.16,\\n          rootMargin: \"0px 0px -8% 0px\"\\n        }\\n      );\\n\\n      elementsToAnimate.forEach(function(element){\\n        var effect = normalizeEffect(element.getAttribute(\"data-motion\"));\\n        if (OBSERVED_EFFECTS[effect]) {\\n          observer.observe(element);\\n          return;\\n        }\\n        activateOrQueue(element);\\n      });\\n\\n      requestAnimationFrame(function(){\\n        requestAnimationFrame(function(){\\n          activationReady = true;\\n          queuedElements.forEach(activateElement);\\n          queuedElements = [];\\n        });\\n      });\\n    });\\n  }\\n\\n  function prepareAllElements(){\\n    var elements = Array.from(document.querySelectorAll(\".objeto[data-motion]\"));\\n    if (!elements.length) return;\\n\\n    setPreparingState(true);\\n    elements.forEach(prepareElement);\\n    return elements;\\n  }\\n\\n  function startBoot(){\\n    if (bootStarted) return;\\n    bootStarted = true;\\n\\n    waitForRuntimeReady().then(function(){\\n      waitForFirstSectionBackground().then(function(backgroundReady){\\n        if (!backgroundReady) {\\n          dispatchRuntimeEvent(RUNTIME_FAIL_EVENT, { reason: \"first-background-failed\" });\\n          return;\\n        }\\n\\n        var preparedElements = prepareAllElements() || [];\\n        dispatchRuntimeEvent(RUNTIME_READY_EVENT, { source: \"motion-effects-runtime\" });\\n        waitForLoaderHidden().then(function(){\\n          requestAnimationFrame(function(){\\n            requestAnimationFrame(function(){\\n              boot(preparedElements);\\n            });\\n          });\\n        });\\n      });\\n    });\\n  }\\n\\n  startBoot();\\n})();\\n</script>\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvZ2VuZXJhck1vdGlvbkVmZmVjdHNSdW50aW1lLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQTtJQUNkLE9BQU8sczBjQWtqQlBDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxnZW5lcmFyTW90aW9uRWZmZWN0c1J1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbjxzdHlsZT5cbiAgLm1lZngtcHJlcGFyaW5nIC5tZWZ4LXJldmVhbC1pbml0LFxuICAubWVmeC1wcmVwYXJpbmcgLm1lZngtem9vbS1pbml0LFxuICAubWVmeC1wcmVwYXJpbmcgLm1lZngtZHJhdy1pbml0LFxuICAubWVmeC1wcmVwYXJpbmcgLm1lZngtc3RhZ2dlci1pdGVtIHtcbiAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICAubWVmeC1yZXZlYWwtaW5pdCB7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2xhdGU6IDAgMTRweDtcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eSwgdHJhbnNsYXRlO1xuICAgIHRyYW5zaXRpb246XG4gICAgICBvcGFjaXR5IDY0MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSxcbiAgICAgIHRyYW5zbGF0ZSA2NDBtcyBjdWJpYy1iZXppZXIoMC4yMiwgMSwgMC4zNiwgMSk7XG4gIH1cblxuICAubWVmeC1yZXZlYWwtb24ge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgdHJhbnNsYXRlOiAwIDA7XG4gIH1cblxuICAubWVmeC16b29tLWluaXQge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgc2NhbGU6IDAuOTg7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcbiAgICB3aWxsLWNoYW5nZTogb3BhY2l0eSwgc2NhbGU7XG4gICAgdHJhbnNpdGlvbjpcbiAgICAgIG9wYWNpdHkgNjIwbXMgY3ViaWMtYmV6aWVyKDAuMjIsIDEsIDAuMzYsIDEpLFxuICAgICAgc2NhbGUgNzYwbXMgY3ViaWMtYmV6aWVyKDAuMjIsIDEsIDAuMzYsIDEpO1xuICB9XG5cbiAgLm1lZngtem9vbS1vbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBzY2FsZTogMTtcbiAgfVxuXG4gIC5tZWZ4LWRyYXctaW5pdCB7XG4gICAgb3BhY2l0eTogMC45NTtcbiAgICBzY2FsZTogMCAxO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGxlZnQgY2VudGVyO1xuICAgIHdpbGwtY2hhbmdlOiBzY2FsZTtcbiAgICB0cmFuc2l0aW9uOlxuICAgICAgb3BhY2l0eSA1MjBtcyBlYXNlLFxuICAgICAgc2NhbGUgODAwbXMgY3ViaWMtYmV6aWVyKDAuMiwgMC44LCAwLjIsIDEpO1xuICB9XG5cbiAgLm1lZngtZHJhdy1vbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBzY2FsZTogMSAxO1xuICB9XG5cbiAgLm1lZngtaG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuICAgIHdpbGwtY2hhbmdlOiBzY2FsZSwgb3BhY2l0eTtcbiAgICB0cmFuc2l0aW9uOlxuICAgICAgc2NhbGUgMjMwbXMgZWFzZSxcbiAgICAgIG9wYWNpdHkgMjMwbXMgZWFzZTtcbiAgfVxuXG4gIC5tZWZ4LWhvdmVyOmhvdmVyIHtcbiAgICBzY2FsZTogMS4wMTtcbiAgfVxuXG4gIC5tZWZ4LWhvdmVyOmFjdGl2ZSB7XG4gICAgc2NhbGU6IDAuOTk7XG4gIH1cblxuICAubWVmeC1ob3Zlcjpmb2N1cy12aXNpYmxlIHtcbiAgICBvdXRsaW5lOiAycHggc29saWQgcmdiYSgxMTksIDYxLCAxOTAsIDAuMzQpO1xuICAgIG91dGxpbmUtb2Zmc2V0OiAycHg7XG4gIH1cblxuICBAa2V5ZnJhbWVzIG1lZnhQdWxzZSB7XG4gICAgMCUsIDEwMCUge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIGZpbHRlcjogbm9uZTtcbiAgICB9XG4gICAgNTAlIHtcbiAgICAgIG9wYWNpdHk6IDAuOTtcbiAgICAgIGZpbHRlcjogc2F0dXJhdGUoMS4wMyk7XG4gICAgfVxuICB9XG5cbiAgQGtleWZyYW1lcyBtZWZ4UHVsc2VDb3VudGRvd25DaGlwIHtcbiAgICAwJSwgMTAwJSB7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCkgc2NhbGUoMSk7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMCByZ2JhKDE3LCAyNCwgMzksIDApO1xuICAgIH1cbiAgICA1MCUge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xcHgpIHNjYWxlKDEuMDE4KTtcbiAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDE2cHggcmdiYSgxNywgMjQsIDM5LCAwLjE0KTtcbiAgICB9XG4gIH1cblxuICAubWVmeC1wdWxzZSB7XG4gICAgYW5pbWF0aW9uOiBtZWZ4UHVsc2UgMi42cyBlYXNlLWluLW91dCBpbmZpbml0ZTtcbiAgfVxuXG4gIC5vYmpldG9bZGF0YS10eXBlPVwiY291bnRkb3duXCJdLm1lZngtcHVsc2UgLmNkLWNoaXAge1xuICAgIGFuaW1hdGlvbjogbWVmeFB1bHNlQ291bnRkb3duQ2hpcCAyLjZzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybSwgYm94LXNoYWRvdztcbiAgfVxuXG4gIC5vYmpldG9bZGF0YS10eXBlPVwiY291bnRkb3duXCJdLm1lZngtcHVsc2UgLmNkLWNoaXA6bnRoLWNoaWxkKDEpIHtcbiAgICBhbmltYXRpb24tZGVsYXk6IDBtcztcbiAgfVxuXG4gIC5vYmpldG9bZGF0YS10eXBlPVwiY291bnRkb3duXCJdLm1lZngtcHVsc2UgLmNkLWNoaXA6bnRoLWNoaWxkKDIpIHtcbiAgICBhbmltYXRpb24tZGVsYXk6IDkwbXM7XG4gIH1cblxuICAub2JqZXRvW2RhdGEtdHlwZT1cImNvdW50ZG93blwiXS5tZWZ4LXB1bHNlIC5jZC1jaGlwOm50aC1jaGlsZCgzKSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAxODBtcztcbiAgfVxuXG4gIC5vYmpldG9bZGF0YS10eXBlPVwiY291bnRkb3duXCJdLm1lZngtcHVsc2UgLmNkLWNoaXA6bnRoLWNoaWxkKDQpIHtcbiAgICBhbmltYXRpb24tZGVsYXk6IDI3MG1zO1xuICB9XG5cbiAgLm1lZngtc3RhZ2dlci1pdGVtIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHRyYW5zbGF0ZTogMCAxMHB4O1xuICAgIHdpbGwtY2hhbmdlOiB0cmFuc2xhdGUsIG9wYWNpdHk7XG4gICAgdHJhbnNpdGlvbjpcbiAgICAgIG9wYWNpdHkgNjIwbXMgY3ViaWMtYmV6aWVyKDAuMjIsIDEsIDAuMzYsIDEpLFxuICAgICAgdHJhbnNsYXRlIDYyMG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKTtcbiAgICB0cmFuc2l0aW9uLWRlbGF5OiB2YXIoLS1tZWZ4LXN0YWdnZXItZGVsYXksIDBtcyk7XG4gIH1cblxuICAubWVmeC1zdGFnZ2VyLWl0ZW0ubWVmeC1zdGFnZ2VyLW9uIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zbGF0ZTogMCAwO1xuICB9XG5cbiAgQGtleWZyYW1lcyBtZWZ4UmV2ZWFsTW9iaWxlSW4ge1xuICAgIGZyb20ge1xuICAgICAgb3BhY2l0eTogMDtcbiAgICAgIHRyYW5zbGF0ZTogMCAxMHB4O1xuICAgIH1cbiAgICB0byB7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgdHJhbnNsYXRlOiAwIDA7XG4gICAgfVxuICB9XG5cbiAgQGtleWZyYW1lcyBtZWZ4Wm9vbU1vYmlsZUluIHtcbiAgICBmcm9tIHtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgICBzY2FsZTogMC45OTtcbiAgICB9XG4gICAgdG8ge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIHNjYWxlOiAxO1xuICAgIH1cbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWVmeERyYXdNb2JpbGVJbiB7XG4gICAgZnJvbSB7XG4gICAgICBvcGFjaXR5OiAwLjk1O1xuICAgICAgc2NhbGU6IDAgMTtcbiAgICB9XG4gICAgdG8ge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIHNjYWxlOiAxIDE7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgLm1lZngtcmV2ZWFsLWluaXQge1xuICAgICAgdHJhbnNsYXRlOiAwIDEwcHg7XG4gICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiA1NDBtcztcbiAgICB9XG5cbiAgICAubWVmeC16b29tLWluaXQge1xuICAgICAgc2NhbGU6IDAuOTk7XG4gICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiA1ODBtcztcbiAgICB9XG5cbiAgICAubWVmeC1kcmF3LWluaXQge1xuICAgICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNjQwbXM7XG4gICAgfVxuXG4gICAgLm1lZngtc3RhZ2dlci1pdGVtIHtcbiAgICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDU0MG1zO1xuICAgIH1cblxuICAgIC8qIEZhbGxiYWNrIHJvYnVzdG8gbW9iaWxlOiBjdWFuZG8gc2UgYWdyZWdhIFwib25cIiwgZm9yemFtb3Mga2V5ZnJhbWVzICovXG4gICAgLm1lZngtcmV2ZWFsLW9uIHtcbiAgICAgIGFuaW1hdGlvbjogbWVmeFJldmVhbE1vYmlsZUluIDU0MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSBib3RoO1xuICAgIH1cblxuICAgIC5tZWZ4LXpvb20tb24ge1xuICAgICAgYW5pbWF0aW9uOiBtZWZ4Wm9vbU1vYmlsZUluIDU4MG1zIGN1YmljLWJlemllcigwLjIyLCAxLCAwLjM2LCAxKSBib3RoO1xuICAgIH1cblxuICAgIC5tZWZ4LWRyYXctb24ge1xuICAgICAgYW5pbWF0aW9uOiBtZWZ4RHJhd01vYmlsZUluIDY0MG1zIGN1YmljLWJlemllcigwLjIsIDAuOCwgMC4yLCAxKSBib3RoO1xuICAgIH1cblxuICAgIC5tZWZ4LXN0YWdnZXItaXRlbS5tZWZ4LXN0YWdnZXItb24ge1xuICAgICAgYW5pbWF0aW9uOiBtZWZ4UmV2ZWFsTW9iaWxlSW4gNTQwbXMgY3ViaWMtYmV6aWVyKDAuMjIsIDEsIDAuMzYsIDEpIGJvdGg7XG4gICAgICBhbmltYXRpb24tZGVsYXk6IHZhcigtLW1lZngtc3RhZ2dlci1kZWxheSwgMG1zKTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSkge1xuICAgIC5tZWZ4LXJldmVhbC1pbml0LFxuICAgIC5tZWZ4LXpvb20taW5pdCxcbiAgICAubWVmeC1kcmF3LWluaXQsXG4gICAgLm1lZngtc3RhZ2dlci1pdGVtIHtcbiAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgIHRyYW5zbGF0ZTogMCAwICFpbXBvcnRhbnQ7XG4gICAgICBzY2FsZTogMSAhaW1wb3J0YW50O1xuICAgICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5tZWZ4LXB1bHNlIHtcbiAgICAgIGFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5vYmpldG9bZGF0YS10eXBlPVwiY291bnRkb3duXCJdLm1lZngtcHVsc2UgLmNkLWNoaXAge1xuICAgICAgYW5pbWF0aW9uOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB0cmFuc2Zvcm06IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgdmFyIFZBTElEX0VGRkVDVFMgPSB7IG5vbmU6IDEsIHJldmVhbDogMSwgZHJhdzogMSwgem9vbTogMSwgaG92ZXI6IDEsIHB1bHNlOiAxIH07XG4gIHZhciBPQlNFUlZFRF9FRkZFQ1RTID0geyByZXZlYWw6IDEsIGRyYXc6IDEsIHpvb206IDEgfTtcbiAgdmFyIFNUQUdHRVJfU0VMRUNUT1IgPSBcIi5nYWxlcmlhLWNlbGRhXCI7XG4gIHZhciBQUkVQQVJJTkdfQ0xBU1MgPSBcIm1lZngtcHJlcGFyaW5nXCI7XG4gIHZhciBSVU5USU1FX1JFQURZX0VWRU5UID0gXCJpbnZpdGF0aW9uLXJ1bnRpbWUtcmVhZHlcIjtcbiAgdmFyIFJVTlRJTUVfRkFJTF9FVkVOVCA9IFwiaW52aXRhdGlvbi1ydW50aW1lLWZhaWxlZFwiO1xuICB2YXIgTE9BREVSX0hJRERFTl9FVkVOVCA9IFwiaW52aXRhdGlvbi1sb2FkZXItaGlkZGVuXCI7XG4gIHZhciBMT0FERVJfV0FJVF9USU1FT1VUX01TID0gMjQwMDtcbiAgdmFyIFJFQURZX1RJTUVPVVRfTVMgPSAyNjAwO1xuICB2YXIgRk9OVFNfVElNRU9VVF9NUyA9IDEyMDA7XG4gIHZhciBib290U3RhcnRlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUVmZmVjdCh2YWx1ZSl7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBTdHJpbmcodmFsdWUgfHwgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIFZBTElEX0VGRkVDVFNbbm9ybWFsaXplZF0gPyBub3JtYWxpemVkIDogXCJub25lXCI7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVUeXBlKHZhbHVlKXtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlIHx8IFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlcGFyaW5nU3RhdGUoYWN0aXZlKXtcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkgfHwgIWRvY3VtZW50LmJvZHkuY2xhc3NMaXN0KSByZXR1cm47XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFBSRVBBUklOR19DTEFTUyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShQUkVQQVJJTkdfQ0xBU1MpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hSdW50aW1lRXZlbnQobmFtZSwgZGV0YWlsKXtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIHsgZGV0YWlsOiBkZXRhaWwgfHwge30gfSkpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVkdWNlZE1vdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISEod2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yV2luZG93TG9hZChtYXhXYWl0TXMpe1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKXtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgdmFyIG9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIG1heFdhaXRNcyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yRm9udHMobWF4V2FpdE1zKXtcbiAgICBpZiAoIWRvY3VtZW50LmZvbnRzIHx8ICFkb2N1bWVudC5mb250cy5yZWFkeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgZG9jdW1lbnQuZm9udHMucmVhZHkuY2F0Y2goZnVuY3Rpb24oKXsgcmV0dXJuIG51bGw7IH0pLFxuICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSl7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHJlc29sdmUsIG1heFdhaXRNcyk7XG4gICAgICB9KVxuICAgIF0pLnRoZW4oZnVuY3Rpb24oKXsgcmV0dXJuIG51bGw7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclJ1bnRpbWVSZWFkeSgpe1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB3YWl0Rm9yV2luZG93TG9hZChSRUFEWV9USU1FT1VUX01TKSxcbiAgICAgIHdhaXRGb3JGb250cyhGT05UU19USU1FT1VUX01TKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24oKXsgcmV0dXJuIG51bGw7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdEZpcnN0VXJsKHZhbHVlKXtcbiAgICB2YXIgcmF3ID0gU3RyaW5nKHZhbHVlIHx8IFwiXCIpO1xuICAgIGlmICghcmF3IHx8IHJhdyA9PT0gXCJub25lXCIpIHJldHVybiBcIlwiO1xuICAgIHZhciBtYXRjaCA9IHJhdy5tYXRjaCgvdXJsXFwoKFsnXCJdPykoLio/KVxcXFwxXFwpL2kpO1xuICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzJdKSByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gbWF0Y2hbMl0udHJpbSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RTZWN0aW9uQmFja2dyb3VuZFVybCgpe1xuICAgIHZhciBmaXJzdFNlY3Rpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNlY1wiKTtcbiAgICBpZiAoIWZpcnN0U2VjdGlvbikgcmV0dXJuIFwiXCI7XG4gICAgdmFyIGJnTm9kZSA9IGZpcnN0U2VjdGlvbi5xdWVyeVNlbGVjdG9yKFwiLnNlYy1iZ1wiKTtcbiAgICBpZiAoIWJnTm9kZSkgcmV0dXJuIFwiXCI7XG5cbiAgICB2YXIgaW5saW5lVXJsID0gZXh0cmFjdEZpcnN0VXJsKGJnTm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSk7XG4gICAgaWYgKGlubGluZVVybCkgcmV0dXJuIGlubGluZVVybDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgY29tcHV0ZWRVcmwgPSBleHRyYWN0Rmlyc3RVcmwod2luZG93LmdldENvbXB1dGVkU3R5bGUoYmdOb2RlKS5iYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXJsO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZEltYWdlKHVybCl7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuZGVjb2RpbmcgPSBcImFzeW5jXCI7XG4gICAgICBpbWcubG9hZGluZyA9IFwiZWFnZXJcIjtcblxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfTtcblxuICAgICAgaW1nLnNyYyA9IHVybDtcblxuICAgICAgaWYgKGltZy5jb21wbGV0ZSAmJiBpbWcubmF0dXJhbFdpZHRoID4gMCkge1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvckZpcnN0U2VjdGlvbkJhY2tncm91bmQoKXtcbiAgICB2YXIgYmFja2dyb3VuZFVybCA9IGdldEZpcnN0U2VjdGlvbkJhY2tncm91bmRVcmwoKTtcbiAgICByZXR1cm4gbG9hZEltYWdlKGJhY2tncm91bmRVcmwpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvckxvYWRlckhpZGRlbigpe1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKXtcbiAgICAgIHZhciBsb2FkZXJOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnYtbG9hZGVyXCIpO1xuICAgICAgaWYgKCFsb2FkZXJOb2RlKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICAgICAgaWYgKGZpbmlzaGVkKSByZXR1cm47XG4gICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihMT0FERVJfSElEREVOX0VWRU5ULCBkb25lLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChkb25lLCBMT0FERVJfV0FJVF9USU1FT1VUX01TKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVHYWxsZXJ5U3RhZ2dlcihlbGVtZW50KXtcbiAgICB2YXIgY2VsbHMgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChTVEFHR0VSX1NFTEVDVE9SKSk7XG4gICAgaWYgKCFjZWxscy5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaW5kZXgpe1xuICAgICAgdmFyIGRlbGF5TXMgPSBNYXRoLm1pbihpbmRleCwgMTEpICogNzA7XG4gICAgICBjZWxsLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tZWZ4LXN0YWdnZXItZGVsYXlcIiwgZGVsYXlNcyArIFwibXNcIik7XG4gICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXN0YWdnZXItaXRlbVwiKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjZWxscztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVFbGVtZW50KGVsZW1lbnQpe1xuICAgIHZhciBlZmZlY3QgPSBub3JtYWxpemVFZmZlY3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vdGlvblwiKSk7XG4gICAgdmFyIHR5cGUgPSBub3JtYWxpemVUeXBlKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbW90aW9uXCIsIGVmZmVjdCk7XG5cbiAgICBpZiAoZWZmZWN0ID09PSBcImhvdmVyXCIpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtaG92ZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdCA9PT0gXCJwdWxzZVwiICYmICh0eXBlID09PSBcImNvdW50ZG93blwiIHx8IHR5cGUgPT09IFwicnN2cFwiKSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC1wdWxzZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0ID09PSBcInJldmVhbFwiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXJldmVhbC1pbml0XCIpO1xuICAgIGlmIChlZmZlY3QgPT09IFwiem9vbVwiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXpvb20taW5pdFwiKTtcbiAgICBpZiAoZWZmZWN0ID09PSBcImRyYXdcIikgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWVmeC1kcmF3LWluaXRcIik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJnYWxsZXJ5XCIgJiYgZWZmZWN0ID09PSBcInJldmVhbFwiKSB7XG4gICAgICBwcmVwYXJlR2FsbGVyeVN0YWdnZXIoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGVFbGVtZW50KGVsZW1lbnQpe1xuICAgIHZhciBlZmZlY3QgPSBub3JtYWxpemVFZmZlY3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vdGlvblwiKSk7XG4gICAgdmFyIHR5cGUgPSBub3JtYWxpemVUeXBlKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpKTtcblxuICAgIGlmIChlZmZlY3QgPT09IFwicmV2ZWFsXCIpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtcmV2ZWFsLW9uXCIpO1xuICAgIGlmIChlZmZlY3QgPT09IFwiem9vbVwiKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtZWZ4LXpvb20tb25cIik7XG4gICAgaWYgKGVmZmVjdCA9PT0gXCJkcmF3XCIpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1lZngtZHJhdy1vblwiKTtcblxuICAgIGlmICh0eXBlID09PSBcImdhbGxlcnlcIiAmJiBlZmZlY3QgPT09IFwicmV2ZWFsXCIpIHtcbiAgICAgIHZhciBzdGFnZ2VySXRlbXMgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChTVEFHR0VSX1NFTEVDVE9SICsgXCIubWVmeC1zdGFnZ2VyLWl0ZW1cIikpO1xuICAgICAgc3RhZ2dlckl0ZW1zLmZvckVhY2goZnVuY3Rpb24oY2VsbCl7XG4gICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZChcIm1lZngtc3RhZ2dlci1vblwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJvb3QoZWxlbWVudHMpe1xuICAgIHZhciBsaXN0ID0gQXJyYXkuaXNBcnJheShlbGVtZW50cykgPyBlbGVtZW50cyA6IFtdO1xuICAgIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICAgIGxpc3QgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIub2JqZXRvW2RhdGEtbW90aW9uXVwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzVG9BbmltYXRlID0gbGlzdDtcbiAgICBpZiAoIWVsZW1lbnRzVG9BbmltYXRlLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdmFyIHJlZHVjZWRNb3Rpb24gPSBpc1JlZHVjZWRNb3Rpb24oKTtcbiAgICBpZiAocmVkdWNlZE1vdGlvbiB8fCB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHNldFByZXBhcmluZ1N0YXRlKGZhbHNlKTtcbiAgICAgIGVsZW1lbnRzVG9BbmltYXRlLmZvckVhY2goYWN0aXZhdGVFbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbiBtb2JpbGUgYWxndW5vcyBuYXZlZ2Fkb3JlcyBjb2xhcHNhbiBcInF1aXRhciBwcmVwYXJpbmcgKyBhY3RpdmFyIG9uXCIgZW4gZWwgbWlzbW8gbGF5b3V0LlxuICAgIC8vIERhbW9zIHVuIGZyYW1lIHBhcmEgcmVhY3RpdmFyIHRyYW5zaWNpb25lcyBhbnRlcyBkZSBvYnNlcnZhci9hY3RpdmFyLlxuICAgIHNldFByZXBhcmluZ1N0YXRlKGZhbHNlKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBxdWV1ZWRCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBxdWV1ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGFjdGl2YXRpb25SZWFkeSA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBlbnF1ZXVlQWN0aXZhdGlvbihlbGVtZW50KXtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmdldEF0dHJpYnV0ZSkgcmV0dXJuO1xuICAgICAgICB2YXIga2V5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vdGlvbi1pZFwiKSB8fCBlbGVtZW50LmlkIHx8IFwiXCI7XG4gICAgICAgIGlmICgha2V5KSBrZXkgPSBcImlkeC1cIiArIHF1ZXVlZEVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKHF1ZXVlZEJ5SWRba2V5XSkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWRCeUlkW2tleV0gPSB0cnVlO1xuICAgICAgICBxdWV1ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhY3RpdmF0ZU9yUXVldWUoZWxlbWVudCl7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uUmVhZHkpIHtcbiAgICAgICAgICBhY3RpdmF0ZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWVBY3RpdmF0aW9uKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgIGZ1bmN0aW9uKGVudHJpZXMpe1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSl7XG4gICAgICAgICAgICBpZiAoIWVudHJ5LmlzSW50ZXJzZWN0aW5nKSByZXR1cm47XG4gICAgICAgICAgICBhY3RpdmF0ZU9yUXVldWUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMTYsXG4gICAgICAgICAgcm9vdE1hcmdpbjogXCIwcHggMHB4IC04JSAwcHhcIlxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBlbGVtZW50c1RvQW5pbWF0ZS5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICB2YXIgZWZmZWN0ID0gbm9ybWFsaXplRWZmZWN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb3Rpb25cIikpO1xuICAgICAgICBpZiAoT0JTRVJWRURfRUZGRUNUU1tlZmZlY3RdKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGVPclF1ZXVlKGVsZW1lbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICBhY3RpdmF0aW9uUmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHF1ZXVlZEVsZW1lbnRzLmZvckVhY2goYWN0aXZhdGVFbGVtZW50KTtcbiAgICAgICAgICBxdWV1ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZUFsbEVsZW1lbnRzKCl7XG4gICAgdmFyIGVsZW1lbnRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1tkYXRhLW1vdGlvbl1cIikpO1xuICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICBzZXRQcmVwYXJpbmdTdGF0ZSh0cnVlKTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKHByZXBhcmVFbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEJvb3QoKXtcbiAgICBpZiAoYm9vdFN0YXJ0ZWQpIHJldHVybjtcbiAgICBib290U3RhcnRlZCA9IHRydWU7XG5cbiAgICB3YWl0Rm9yUnVudGltZVJlYWR5KCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgd2FpdEZvckZpcnN0U2VjdGlvbkJhY2tncm91bmQoKS50aGVuKGZ1bmN0aW9uKGJhY2tncm91bmRSZWFkeSl7XG4gICAgICAgIGlmICghYmFja2dyb3VuZFJlYWR5KSB7XG4gICAgICAgICAgZGlzcGF0Y2hSdW50aW1lRXZlbnQoUlVOVElNRV9GQUlMX0VWRU5ULCB7IHJlYXNvbjogXCJmaXJzdC1iYWNrZ3JvdW5kLWZhaWxlZFwiIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVwYXJlZEVsZW1lbnRzID0gcHJlcGFyZUFsbEVsZW1lbnRzKCkgfHwgW107XG4gICAgICAgIGRpc3BhdGNoUnVudGltZUV2ZW50KFJVTlRJTUVfUkVBRFlfRVZFTlQsIHsgc291cmNlOiBcIm1vdGlvbi1lZmZlY3RzLXJ1bnRpbWVcIiB9KTtcbiAgICAgICAgd2FpdEZvckxvYWRlckhpZGRlbigpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBib290KHByZXBhcmVkRWxlbWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydEJvb3QoKTtcbn0pKCk7XG48L3NjcmlwdD5cbmAudHJpbSgpO1xufVxuIl0sIm5hbWVzIjpbImdlbmVyYXJNb3Rpb25FZmZlY3RzUnVudGltZUhUTUwiLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/generarMotionEffectsRuntime.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/config.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/config.ts ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/config.ts\nfunction normalizeConfig(opts) {\n    const fitMinScaleRaw = Number.isFinite(opts.fitMinScale) ? Number(opts.fitMinScale) : 0.88;\n    const fitMaxScaleRaw = Number.isFinite(opts.fitMaxScale) ? Number(opts.fitMaxScale) : 1.16;\n    const fitMinScale = Math.max(0.7, Math.min(1, fitMinScaleRaw));\n    const fitMaxScale = Math.max(1, fitMaxScaleRaw);\n    const fitTargetWidthRatioRaw = Number.isFinite(opts.fitTargetWidthRatio) ? Number(opts.fitTargetWidthRatio) : 0.94;\n    const fitTargetWidthRatio = Math.max(0.75, Math.min(0.99, fitTargetWidthRatioRaw));\n    const fitMinFillRatioRaw = Number.isFinite(opts.fitMinFillRatio) ? Number(opts.fitMinFillRatio) : 0.9;\n    const fitMinFillRatio = Math.max(0.6, Math.min(fitTargetWidthRatio, fitMinFillRatioRaw));\n    return {\n        enabled: !!opts.enabled,\n        minGapPx: Number.isFinite(opts.minGapPx) ? Number(opts.minGapPx) : 8,\n        paddingTopPx: Number.isFinite(opts.paddingTopPx) ? Number(opts.paddingTopPx) : 0,\n        paddingBottomPx: Number.isFinite(opts.paddingBottomPx) ? Number(opts.paddingBottomPx) : 12,\n        maxGapPx: Number.isFinite(opts.maxGapPx) ? Number(opts.maxGapPx) : 22,\n        onlyFixedSections: opts.onlyFixedSections !== false,\n        onlyWhenReordered: opts.onlyWhenReordered !== false,\n        rowTolPx: Number.isFinite(opts.rowTolPx) ? Number(opts.rowTolPx) : 28,\n        twoColSpreadRatio: Number.isFinite(opts.twoColSpreadRatio) ? Number(opts.twoColSpreadRatio) : 0.18,\n        minPerColumn2: Number.isFinite(opts.minPerColumn2) ? Number(opts.minPerColumn2) : 2,\n        threeColSpreadRatio: Number.isFinite(opts.threeColSpreadRatio) ? Number(opts.threeColSpreadRatio) : 0.22,\n        minPerColumn3: Number.isFinite(opts.minPerColumn3) ? Number(opts.minPerColumn3) : 2,\n        gapScale: Number.isFinite(opts.gapScale) ? Number(opts.gapScale) : 0.6,\n        fitMinScale,\n        fitMaxScale,\n        fitTargetWidthRatio,\n        fitMinFillRatio\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrREFBa0Q7QUFPM0MsU0FBU0EsZ0JBQWdCQyxJQUE4QjtJQUM1RCxNQUFNQyxpQkFBaUJDLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS0ksV0FBVyxJQUFJRixPQUFPRixLQUFLSSxXQUFXLElBQUk7SUFDdEYsTUFBTUMsaUJBQWlCSCxPQUFPQyxRQUFRLENBQUNILEtBQUtNLFdBQVcsSUFBSUosT0FBT0YsS0FBS00sV0FBVyxJQUFJO0lBQ3RGLE1BQU1GLGNBQWNHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLRSxHQUFHLENBQUMsR0FBR1I7SUFDOUMsTUFBTUssY0FBY0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdIO0lBQ2hDLE1BQU1LLHlCQUF5QlIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLVyxtQkFBbUIsSUFDbkVULE9BQU9GLEtBQUtXLG1CQUFtQixJQUMvQjtJQUNKLE1BQU1BLHNCQUFzQkosS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxNQUFNQztJQUMxRCxNQUFNRSxxQkFBcUJWLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS2EsZUFBZSxJQUMzRFgsT0FBT0YsS0FBS2EsZUFBZSxJQUMzQjtJQUNKLE1BQU1BLGtCQUFrQk4sS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtFLEdBQUcsQ0FBQ0UscUJBQXFCQztJQUVwRSxPQUFPO1FBQ0xFLFNBQVMsQ0FBQyxDQUFDZCxLQUFLYyxPQUFPO1FBRXZCQyxVQUFVYixPQUFPQyxRQUFRLENBQUNILEtBQUtlLFFBQVEsSUFBSWIsT0FBT0YsS0FBS2UsUUFBUSxJQUFJO1FBQ25FQyxjQUFjZCxPQUFPQyxRQUFRLENBQUNILEtBQUtnQixZQUFZLElBQUlkLE9BQU9GLEtBQUtnQixZQUFZLElBQUk7UUFDL0VDLGlCQUFpQmYsT0FBT0MsUUFBUSxDQUFDSCxLQUFLaUIsZUFBZSxJQUFJZixPQUFPRixLQUFLaUIsZUFBZSxJQUFJO1FBQ3hGQyxVQUFVaEIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLa0IsUUFBUSxJQUFJaEIsT0FBT0YsS0FBS2tCLFFBQVEsSUFBSTtRQUVuRUMsbUJBQW1CbkIsS0FBS21CLGlCQUFpQixLQUFLO1FBQzlDQyxtQkFBbUJwQixLQUFLb0IsaUJBQWlCLEtBQUs7UUFFOUNDLFVBQVVuQixPQUFPQyxRQUFRLENBQUNILEtBQUtxQixRQUFRLElBQUluQixPQUFPRixLQUFLcUIsUUFBUSxJQUFJO1FBRW5FQyxtQkFBbUJwQixPQUFPQyxRQUFRLENBQUNILEtBQUtzQixpQkFBaUIsSUFBSXBCLE9BQU9GLEtBQUtzQixpQkFBaUIsSUFBSTtRQUM5RkMsZUFBZXJCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3VCLGFBQWEsSUFBSXJCLE9BQU9GLEtBQUt1QixhQUFhLElBQUk7UUFFbEZDLHFCQUFxQnRCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS3dCLG1CQUFtQixJQUFJdEIsT0FBT0YsS0FBS3dCLG1CQUFtQixJQUFJO1FBQ3BHQyxlQUFldkIsT0FBT0MsUUFBUSxDQUFDSCxLQUFLeUIsYUFBYSxJQUFJdkIsT0FBT0YsS0FBS3lCLGFBQWEsSUFBSTtRQUVsRkMsVUFBVXhCLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBSzBCLFFBQVEsSUFBSXhCLE9BQU9GLEtBQUswQixRQUFRLElBQUk7UUFDbkV0QjtRQUNBRTtRQUNBSztRQUNBRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L2NvbmZpZy50c1xyXG5pbXBvcnQgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgTm9ybWFsaXplZENvbmZpZyA9IFJlcXVpcmVkPE9taXQ8TW9iaWxlU21hcnRMYXlvdXRPcHRpb25zLCBcImVuYWJsZWRcIj4+ICYge1xyXG4gIGVuYWJsZWQ6IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKG9wdHM6IE1vYmlsZVNtYXJ0TGF5b3V0T3B0aW9ucyk6IE5vcm1hbGl6ZWRDb25maWcge1xuICBjb25zdCBmaXRNaW5TY2FsZVJhdyA9IE51bWJlci5pc0Zpbml0ZShvcHRzLmZpdE1pblNjYWxlKSA/IE51bWJlcihvcHRzLmZpdE1pblNjYWxlKSA6IDAuODg7XG4gIGNvbnN0IGZpdE1heFNjYWxlUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0TWF4U2NhbGUpID8gTnVtYmVyKG9wdHMuZml0TWF4U2NhbGUpIDogMS4xNjtcbiAgY29uc3QgZml0TWluU2NhbGUgPSBNYXRoLm1heCgwLjcsIE1hdGgubWluKDEsIGZpdE1pblNjYWxlUmF3KSk7XG4gIGNvbnN0IGZpdE1heFNjYWxlID0gTWF0aC5tYXgoMSwgZml0TWF4U2NhbGVSYXcpO1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvUmF3ID0gTnVtYmVyLmlzRmluaXRlKG9wdHMuZml0VGFyZ2V0V2lkdGhSYXRpbylcbiAgICA/IE51bWJlcihvcHRzLmZpdFRhcmdldFdpZHRoUmF0aW8pXG4gICAgOiAwLjk0O1xuICBjb25zdCBmaXRUYXJnZXRXaWR0aFJhdGlvID0gTWF0aC5tYXgoMC43NSwgTWF0aC5taW4oMC45OSwgZml0VGFyZ2V0V2lkdGhSYXRpb1JhdykpO1xuICBjb25zdCBmaXRNaW5GaWxsUmF0aW9SYXcgPSBOdW1iZXIuaXNGaW5pdGUob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgPyBOdW1iZXIob3B0cy5maXRNaW5GaWxsUmF0aW8pXG4gICAgOiAwLjk7XG4gIGNvbnN0IGZpdE1pbkZpbGxSYXRpbyA9IE1hdGgubWF4KDAuNiwgTWF0aC5taW4oZml0VGFyZ2V0V2lkdGhSYXRpbywgZml0TWluRmlsbFJhdGlvUmF3KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiAhIW9wdHMuZW5hYmxlZCxcblxyXG4gICAgbWluR2FwUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pbkdhcFB4KSA/IE51bWJlcihvcHRzLm1pbkdhcFB4KSA6IDgsXHJcbiAgICBwYWRkaW5nVG9wUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnBhZGRpbmdUb3BQeCkgPyBOdW1iZXIob3B0cy5wYWRkaW5nVG9wUHgpIDogMCxcclxuICAgIHBhZGRpbmdCb3R0b21QeDogTnVtYmVyLmlzRmluaXRlKG9wdHMucGFkZGluZ0JvdHRvbVB4KSA/IE51bWJlcihvcHRzLnBhZGRpbmdCb3R0b21QeCkgOiAxMixcclxuICAgIG1heEdhcFB4OiBOdW1iZXIuaXNGaW5pdGUob3B0cy5tYXhHYXBQeCkgPyBOdW1iZXIob3B0cy5tYXhHYXBQeCkgOiAyMixcclxuXHJcbiAgICBvbmx5Rml4ZWRTZWN0aW9uczogb3B0cy5vbmx5Rml4ZWRTZWN0aW9ucyAhPT0gZmFsc2UsXHJcbiAgICBvbmx5V2hlblJlb3JkZXJlZDogb3B0cy5vbmx5V2hlblJlb3JkZXJlZCAhPT0gZmFsc2UsXHJcblxyXG4gICAgcm93VG9sUHg6IE51bWJlci5pc0Zpbml0ZShvcHRzLnJvd1RvbFB4KSA/IE51bWJlcihvcHRzLnJvd1RvbFB4KSA6IDI4LFxyXG5cclxuICAgIHR3b0NvbFNwcmVhZFJhdGlvOiBOdW1iZXIuaXNGaW5pdGUob3B0cy50d29Db2xTcHJlYWRSYXRpbykgPyBOdW1iZXIob3B0cy50d29Db2xTcHJlYWRSYXRpbykgOiAwLjE4LFxyXG4gICAgbWluUGVyQ29sdW1uMjogTnVtYmVyLmlzRmluaXRlKG9wdHMubWluUGVyQ29sdW1uMikgPyBOdW1iZXIob3B0cy5taW5QZXJDb2x1bW4yKSA6IDIsXHJcblxuICAgIHRocmVlQ29sU3ByZWFkUmF0aW86IE51bWJlci5pc0Zpbml0ZShvcHRzLnRocmVlQ29sU3ByZWFkUmF0aW8pID8gTnVtYmVyKG9wdHMudGhyZWVDb2xTcHJlYWRSYXRpbykgOiAwLjIyLFxuICAgIG1pblBlckNvbHVtbjM6IE51bWJlci5pc0Zpbml0ZShvcHRzLm1pblBlckNvbHVtbjMpID8gTnVtYmVyKG9wdHMubWluUGVyQ29sdW1uMykgOiAyLFxuXG4gICAgZ2FwU2NhbGU6IE51bWJlci5pc0Zpbml0ZShvcHRzLmdhcFNjYWxlKSA/IE51bWJlcihvcHRzLmdhcFNjYWxlKSA6IDAuNixcbiAgICBmaXRNaW5TY2FsZSxcbiAgICBmaXRNYXhTY2FsZSxcbiAgICBmaXRUYXJnZXRXaWR0aFJhdGlvLFxuICAgIGZpdE1pbkZpbGxSYXRpbyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVDb25maWciLCJvcHRzIiwiZml0TWluU2NhbGVSYXciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZpdE1pblNjYWxlIiwiZml0TWF4U2NhbGVSYXciLCJmaXRNYXhTY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmaXRUYXJnZXRXaWR0aFJhdGlvUmF3IiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpb1JhdyIsImZpdE1pbkZpbGxSYXRpbyIsImVuYWJsZWQiLCJtaW5HYXBQeCIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm1heEdhcFB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJnYXBTY2FsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/config.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts":
/*!******************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/dom.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsDomHelpersBlock: () => (/* binding */ jsDomHelpersBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/dom.ts\nfunction jsDomHelpersBlock() {\n    return '\\n  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }\\n\\n  function isMobile(){\\n    return (document.documentElement.clientWidth || 0) <= 767;\\n  }\\n\\n  function getObjNodes(sec){\\n    if(!sec) return [];\\n    var nodes = [];\\n    var content = sec.querySelector(\".sec-content\");\\n    var bleed = sec.querySelector(\".sec-bleed\");\\n\\n    if (content) nodes = nodes.concat(Array.from(content.querySelectorAll(\".objeto\")));\\n    if (bleed) nodes = nodes.concat(Array.from(bleed.querySelectorAll(\".objeto\")));\\n\\n    // Fallback: algunos elementos exportados pueden no traer clase \".objeto\"\\n    // pero s\\xed estar posicionados como objetos absolutos.\\n    function collectAbsoluteCandidates(root){\\n      if (!root) return [];\\n      return Array.from(root.querySelectorAll(\"*\")).filter(function(el){\\n        if (!el) return false;\\n        var cs = getComputedStyle(el);\\n        var pos = (cs.position || \"\").toLowerCase();\\n        if (pos !== \"absolute\") return false;\\n\\n        var rr = el.getBoundingClientRect();\\n        if (!rr || rr.width < 1 || rr.height < 1) return false;\\n\\n        // Evitar ruido estructural del layout de secci\\xf3n\\n        if (el.classList && (\\n          el.classList.contains(\"sec\") ||\\n          el.classList.contains(\"sec-zoom\") ||\\n          el.classList.contains(\"sec-bg\") ||\\n          el.classList.contains(\"sec-content\") ||\\n          el.classList.contains(\"sec-bleed\")\\n        )) return false;\\n\\n        // Si ya est\\xe1 dentro de un \".objeto\", no lo contamos aparte.\\n        var p = el.parentElement;\\n        while (p){\\n          if (p.classList && p.classList.contains(\"objeto\")) return false;\\n          p = p.parentElement;\\n        }\\n        return true;\\n      });\\n    }\\n\\n    nodes = nodes.concat(collectAbsoluteCandidates(content));\\n    nodes = nodes.concat(collectAbsoluteCandidates(bleed));\\n\\n    // Deduplicar preservando orden de aparici\\xf3n.\\n    var seen = new Set();\\n    return nodes.filter(function(n){\\n      if (seen.has(n)) return false;\\n      seen.add(n);\\n      return true;\\n    });\\n  }\\n\\n  function relRect(el, root){\\n    var r = el.getBoundingClientRect();\\n    var rr = root.getBoundingClientRect();\\n    return {\\n      top: r.top - rr.top,\\n      left: r.left - rr.left,\\n      width: r.width,\\n      height: r.height\\n    };\\n  }\\n\\n  function percentile(sortedArr, p){\\n    if (!sortedArr.length) return 0;\\n    var idx = Math.floor(sortedArr.length * p);\\n    idx = Math.max(0, Math.min(sortedArr.length - 1, idx));\\n    return sortedArr[idx];\\n  }\\n\\n  function cx(it){ return it.left + (it.width || 0) / 2; }\\n\\n  // -------------------------\\n  // ✅ CLUSTERS POR SOLAPE\\n  // -------------------------\\n  function rectsOverlap(a, b, tol){\\n    tol = tol || 0;\\n    return !(\\n      (a.left + a.width) < (b.left + tol) ||\\n      (b.left + b.width) < (a.left + tol) ||\\n      (a.top + a.height) < (b.top + tol) ||\\n      (b.top + b.height) < (a.top + tol)\\n    );\\n  }\\n\\n  function horizontalOverlapPx(a, b){\\n    var l = Math.max(a.left, b.left);\\n    var r = Math.min(a.left + a.width, b.left + b.width);\\n    return Math.max(0, r - l);\\n  }\\n\\n  function verticalGapPx(a, b){\\n    var topAfter = Math.max(a.top, b.top);\\n    var bottomBefore = Math.min(a.top + a.height, b.top + b.height);\\n    return topAfter - bottomBefore;\\n  }\\n\\n  function buildOverlapClusters(items){\\n    var n = items.length;\\n    var parent = new Array(n);\\n    for (var i=0;i<n;i++) parent[i] = i;\\n\\n    function find(x){\\n      while(parent[x] !== x){\\n        parent[x] = parent[parent[x]];\\n        x = parent[x];\\n      }\\n      return x;\\n    }\\n\\n    function union(a,b){\\n      var ra = find(a), rb = find(b);\\n      if (ra !== rb) parent[rb] = ra;\\n    }\\n\\n    // tol peque\\xf1o para considerar “encimado” aunque sea apenas\\n    var TOL = 1;\\n    // uni\\xf3n por cercan\\xeda vertical dentro de una misma \"columna visual\"\\n    var PROX_Y = 34;\\n    var MIN_H_OVERLAP_RATIO = 0.35;\\n    var MAX_CX_DIST = 42;\\n\\n    for (var i=0;i<n;i++){\\n      for (var j=i+1;j<n;j++){\\n        var a = items[i], b = items[j];\\n\\n    var aIso = (a.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\\n    var bIso = (b.node.getAttribute(\"data-mobile-cluster\") || \"\") === \"isolated\";\\n\\n    // si cualquiera es isolated, no lo unimos con nadie\\n    if (aIso || bIso) continue;\\n\\n    // opcional: cluster-id manual (si quer\\xe9s agrupar solo algunos)\\n    var aKey = a.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\\n    var bKey = b.node.getAttribute(\"data-mobile-cluster-id\") || \"\";\\n    if (aKey && bKey && aKey !== bKey) continue;\\n\\n    var aIsText = (a.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n    var bIsText = (b.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n    var involvesText = aIsText || bIsText;\\n    var cxDist = Math.abs(cx(a) - cx(b));\\n\\n    if (rectsOverlap(a, b, TOL)) {\\n      // Evita pegar columnas distintas por cajas de texto anchas.\\n      // Si hay texto, exigimos cercania por eje X del centro.\\n      if (!involvesText || cxDist <= MAX_CX_DIST) union(i,j);\\n      continue;\\n    }\\n\\n    // Si no se solapan pero est\\xe1n muy cerca en vertical y comparten columna,\\n    // tambi\\xe9n los unimos para mantener bloque (ej: icono + texto debajo).\\n    var hov = horizontalOverlapPx(a, b);\\n    var minW = Math.max(1, Math.min(a.width || 0, b.width || 0));\\n    var hovRatio = hov / minW;\\n    // Con texto, usamos criterio m\\xe1s estricto para no cruzar columnas.\\n    var sameVisualColumn = involvesText\\n      ? (cxDist <= MAX_CX_DIST)\\n      : ((hovRatio >= MIN_H_OVERLAP_RATIO) || (cxDist <= MAX_CX_DIST));\\n    var vGap = verticalGapPx(a, b);\\n    var nearVertical = vGap >= 0 && vGap <= PROX_Y;\\n    var bothText = aIsText && bIsText;\\n\\n    // Evitar \"pegar\" p\\xe1rrafos entre s\\xed solo por cercan\\xeda vertical.\\n    // La uni\\xf3n por proximidad queda para pares mixtos (texto + no-texto),\\n    // manteniendo el caso icono/forma + texto.\\n    if (sameVisualColumn && nearVertical && !bothText) union(i,j);\\n\\n      }\\n    }\\n\\n    var map = {};\\n    for (var k=0;k<n;k++){\\n      var r = find(k);\\n      if (!map[r]) map[r] = [];\\n      map[r].push(items[k]);\\n    }\\n\\n    var clusters = [];\\n    Object.keys(map).forEach(function(key){\\n      var arr = map[key];\\n\\n      var minTop = Infinity, minLeft = Infinity, maxR = -Infinity, maxB = -Infinity;\\n      for (var i=0;i<arr.length;i++){\\n        var it = arr[i];\\n        minTop = Math.min(minTop, it.top);\\n        minLeft = Math.min(minLeft, it.left);\\n        maxR = Math.max(maxR, it.left + it.width);\\n        maxB = Math.max(maxB, it.top + it.height);\\n      }\\n\\n      // offsets relativos para preservar el solape dentro del cluster\\n      for (var i=0;i<arr.length;i++){\\n        arr[i]._relTop = arr[i].top - minTop;\\n        arr[i]._relLeft = arr[i].left - minLeft;\\n      }\\n\\n      clusters.push({\\n        items: arr,\\n        top: minTop,\\n        left: minLeft,\\n        width: maxR - minLeft,\\n        height: maxB - minTop,\\n        cx: (minLeft + maxR) / 2\\n      });\\n    });\\n\\n    // orden estable por top para consistencia\\n    clusters.sort(function(a,b){ return a.top - b.top; });\\n\\n    return clusters;\\n  }\\n\\n  // ✅ “entra” si ning\\xfan cluster se sale horizontalmente del contenedor content\\n  function clustersFitInMobile(clusters, rootEl){\\n    var rootW = rootEl.getBoundingClientRect().width || 0;\\n    if (!rootW) return true;\\n\\n    for (var i=0;i<clusters.length;i++){\\n      var c = clusters[i];\\n      if (c.left < -1) return false;\\n      if ((c.left + c.width) > (rootW + 1)) return false;\\n    }\\n    return true;\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwrQ0FBK0M7QUFDeEMsU0FBU0E7SUFDZCxPQUFPLHkvT0F3T1BDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcZG9tLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZG9tLnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBqc0RvbUhlbHBlcnNCbG9jaygpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgXHJcbiAgZnVuY3Rpb24gY2xhbXAobixhLGIpeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYixuKSk7IH1cclxuXHJcbiAgZnVuY3Rpb24gaXNNb2JpbGUoKXtcclxuICAgIHJldHVybiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDApIDw9IDc2NztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldE9iak5vZGVzKHNlYyl7XHJcbiAgICBpZighc2VjKSByZXR1cm4gW107XHJcbiAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XHJcbiAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XHJcblxyXG4gICAgaWYgKGNvbnRlbnQpIG5vZGVzID0gbm9kZXMuY29uY2F0KEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKSkpO1xyXG4gICAgaWYgKGJsZWVkKSBub2RlcyA9IG5vZGVzLmNvbmNhdChBcnJheS5mcm9tKGJsZWVkLnF1ZXJ5U2VsZWN0b3JBbGwoXCIub2JqZXRvXCIpKSk7XHJcblxyXG4gICAgLy8gRmFsbGJhY2s6IGFsZ3Vub3MgZWxlbWVudG9zIGV4cG9ydGFkb3MgcHVlZGVuIG5vIHRyYWVyIGNsYXNlIFwiLm9iamV0b1wiXHJcbiAgICAvLyBwZXJvIHPDrSBlc3RhciBwb3NpY2lvbmFkb3MgY29tbyBvYmpldG9zIGFic29sdXRvcy5cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMocm9vdCl7XHJcbiAgICAgIGlmICghcm9vdCkgcmV0dXJuIFtdO1xyXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShyb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5maWx0ZXIoZnVuY3Rpb24oZWwpe1xyXG4gICAgICAgIGlmICghZWwpIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgICAgICB2YXIgcG9zID0gKGNzLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHBvcyAhPT0gXCJhYnNvbHV0ZVwiKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciByciA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmICghcnIgfHwgcnIud2lkdGggPCAxIHx8IHJyLmhlaWdodCA8IDEpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gRXZpdGFyIHJ1aWRvIGVzdHJ1Y3R1cmFsIGRlbCBsYXlvdXQgZGUgc2VjY2nDs25cclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0ICYmIChcclxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlY1wiKSB8fFxyXG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VjLXpvb21cIikgfHxcclxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1iZ1wiKSB8fFxyXG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VjLWNvbnRlbnRcIikgfHxcclxuICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhcInNlYy1ibGVlZFwiKVxyXG4gICAgICAgICkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gU2kgeWEgZXN0w6EgZGVudHJvIGRlIHVuIFwiLm9iamV0b1wiLCBubyBsbyBjb250YW1vcyBhcGFydGUuXHJcbiAgICAgICAgdmFyIHAgPSBlbC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIHdoaWxlIChwKXtcclxuICAgICAgICAgIGlmIChwLmNsYXNzTGlzdCAmJiBwLmNsYXNzTGlzdC5jb250YWlucyhcIm9iamV0b1wiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgcCA9IHAucGFyZW50RWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNvbGxlY3RBYnNvbHV0ZUNhbmRpZGF0ZXMoY29udGVudCkpO1xyXG4gICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY29sbGVjdEFic29sdXRlQ2FuZGlkYXRlcyhibGVlZCkpO1xyXG5cclxuICAgIC8vIERlZHVwbGljYXIgcHJlc2VydmFuZG8gb3JkZW4gZGUgYXBhcmljacOzbi5cclxuICAgIHZhciBzZWVuID0gbmV3IFNldCgpO1xyXG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcihmdW5jdGlvbihuKXtcclxuICAgICAgaWYgKHNlZW4uaGFzKG4pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHNlZW4uYWRkKG4pO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVsUmVjdChlbCwgcm9vdCl7XHJcbiAgICB2YXIgciA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJyID0gcm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogci50b3AgLSByci50b3AsXHJcbiAgICAgIGxlZnQ6IHIubGVmdCAtIHJyLmxlZnQsXHJcbiAgICAgIHdpZHRoOiByLndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHIuaGVpZ2h0XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVyY2VudGlsZShzb3J0ZWRBcnIsIHApe1xyXG4gICAgaWYgKCFzb3J0ZWRBcnIubGVuZ3RoKSByZXR1cm4gMDtcclxuICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHNvcnRlZEFyci5sZW5ndGggKiBwKTtcclxuICAgIGlkeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNvcnRlZEFyci5sZW5ndGggLSAxLCBpZHgpKTtcclxuICAgIHJldHVybiBzb3J0ZWRBcnJbaWR4XTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGN4KGl0KXsgcmV0dXJuIGl0LmxlZnQgKyAoaXQud2lkdGggfHwgMCkgLyAyOyB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyDinIUgQ0xVU1RFUlMgUE9SIFNPTEFQRVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBmdW5jdGlvbiByZWN0c092ZXJsYXAoYSwgYiwgdG9sKXtcclxuICAgIHRvbCA9IHRvbCB8fCAwO1xyXG4gICAgcmV0dXJuICEoXHJcbiAgICAgIChhLmxlZnQgKyBhLndpZHRoKSA8IChiLmxlZnQgKyB0b2wpIHx8XHJcbiAgICAgIChiLmxlZnQgKyBiLndpZHRoKSA8IChhLmxlZnQgKyB0b2wpIHx8XHJcbiAgICAgIChhLnRvcCArIGEuaGVpZ2h0KSA8IChiLnRvcCArIHRvbCkgfHxcclxuICAgICAgKGIudG9wICsgYi5oZWlnaHQpIDwgKGEudG9wICsgdG9sKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhvcml6b250YWxPdmVybGFwUHgoYSwgYil7XHJcbiAgICB2YXIgbCA9IE1hdGgubWF4KGEubGVmdCwgYi5sZWZ0KTtcclxuICAgIHZhciByID0gTWF0aC5taW4oYS5sZWZ0ICsgYS53aWR0aCwgYi5sZWZ0ICsgYi53aWR0aCk7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgciAtIGwpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmVydGljYWxHYXBQeChhLCBiKXtcclxuICAgIHZhciB0b3BBZnRlciA9IE1hdGgubWF4KGEudG9wLCBiLnRvcCk7XHJcbiAgICB2YXIgYm90dG9tQmVmb3JlID0gTWF0aC5taW4oYS50b3AgKyBhLmhlaWdodCwgYi50b3AgKyBiLmhlaWdodCk7XHJcbiAgICByZXR1cm4gdG9wQWZ0ZXIgLSBib3R0b21CZWZvcmU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBidWlsZE92ZXJsYXBDbHVzdGVycyhpdGVtcyl7XHJcbiAgICB2YXIgbiA9IGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBwYXJlbnQgPSBuZXcgQXJyYXkobik7XHJcbiAgICBmb3IgKHZhciBpPTA7aTxuO2krKykgcGFyZW50W2ldID0gaTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kKHgpe1xyXG4gICAgICB3aGlsZShwYXJlbnRbeF0gIT09IHgpe1xyXG4gICAgICAgIHBhcmVudFt4XSA9IHBhcmVudFtwYXJlbnRbeF1dO1xyXG4gICAgICAgIHggPSBwYXJlbnRbeF07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW5pb24oYSxiKXtcclxuICAgICAgdmFyIHJhID0gZmluZChhKSwgcmIgPSBmaW5kKGIpO1xyXG4gICAgICBpZiAocmEgIT09IHJiKSBwYXJlbnRbcmJdID0gcmE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdG9sIHBlcXVlw7FvIHBhcmEgY29uc2lkZXJhciDigJxlbmNpbWFkb+KAnSBhdW5xdWUgc2VhIGFwZW5hc1xyXG4gICAgdmFyIFRPTCA9IDE7XHJcbiAgICAvLyB1bmnDs24gcG9yIGNlcmNhbsOtYSB2ZXJ0aWNhbCBkZW50cm8gZGUgdW5hIG1pc21hIFwiY29sdW1uYSB2aXN1YWxcIlxyXG4gICAgdmFyIFBST1hfWSA9IDM0O1xyXG4gICAgdmFyIE1JTl9IX09WRVJMQVBfUkFUSU8gPSAwLjM1O1xyXG4gICAgdmFyIE1BWF9DWF9ESVNUID0gNDI7XHJcblxyXG4gICAgZm9yICh2YXIgaT0wO2k8bjtpKyspe1xyXG4gICAgICBmb3IgKHZhciBqPWkrMTtqPG47aisrKXtcclxuICAgICAgICB2YXIgYSA9IGl0ZW1zW2ldLCBiID0gaXRlbXNbal07XHJcblxyXG4gICAgdmFyIGFJc28gPSAoYS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXJcIikgfHwgXCJcIikgPT09IFwiaXNvbGF0ZWRcIjtcclxuICAgIHZhciBiSXNvID0gKGIubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyXCIpIHx8IFwiXCIpID09PSBcImlzb2xhdGVkXCI7XHJcblxyXG4gICAgLy8gc2kgY3VhbHF1aWVyYSBlcyBpc29sYXRlZCwgbm8gbG8gdW5pbW9zIGNvbiBuYWRpZVxyXG4gICAgaWYgKGFJc28gfHwgYklzbykgY29udGludWU7XHJcblxyXG4gICAgLy8gb3BjaW9uYWw6IGNsdXN0ZXItaWQgbWFudWFsIChzaSBxdWVyw6lzIGFncnVwYXIgc29sbyBhbGd1bm9zKVxyXG4gICAgdmFyIGFLZXkgPSBhLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3Rlci1pZFwiKSB8fCBcIlwiO1xyXG4gICAgdmFyIGJLZXkgPSBiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3Rlci1pZFwiKSB8fCBcIlwiO1xyXG4gICAgaWYgKGFLZXkgJiYgYktleSAmJiBhS2V5ICE9PSBiS2V5KSBjb250aW51ZTtcclxuXHJcbiAgICB2YXIgYUlzVGV4dCA9IChhLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICB2YXIgYklzVGV4dCA9IChiLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICB2YXIgaW52b2x2ZXNUZXh0ID0gYUlzVGV4dCB8fCBiSXNUZXh0O1xyXG4gICAgdmFyIGN4RGlzdCA9IE1hdGguYWJzKGN4KGEpIC0gY3goYikpO1xyXG5cclxuICAgIGlmIChyZWN0c092ZXJsYXAoYSwgYiwgVE9MKSkge1xyXG4gICAgICAvLyBFdml0YSBwZWdhciBjb2x1bW5hcyBkaXN0aW50YXMgcG9yIGNhamFzIGRlIHRleHRvIGFuY2hhcy5cclxuICAgICAgLy8gU2kgaGF5IHRleHRvLCBleGlnaW1vcyBjZXJjYW5pYSBwb3IgZWplIFggZGVsIGNlbnRyby5cclxuICAgICAgaWYgKCFpbnZvbHZlc1RleHQgfHwgY3hEaXN0IDw9IE1BWF9DWF9ESVNUKSB1bmlvbihpLGopO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaSBubyBzZSBzb2xhcGFuIHBlcm8gZXN0w6FuIG11eSBjZXJjYSBlbiB2ZXJ0aWNhbCB5IGNvbXBhcnRlbiBjb2x1bW5hLFxyXG4gICAgLy8gdGFtYmnDqW4gbG9zIHVuaW1vcyBwYXJhIG1hbnRlbmVyIGJsb3F1ZSAoZWo6IGljb25vICsgdGV4dG8gZGViYWpvKS5cclxuICAgIHZhciBob3YgPSBob3Jpem9udGFsT3ZlcmxhcFB4KGEsIGIpO1xyXG4gICAgdmFyIG1pblcgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihhLndpZHRoIHx8IDAsIGIud2lkdGggfHwgMCkpO1xyXG4gICAgdmFyIGhvdlJhdGlvID0gaG92IC8gbWluVztcclxuICAgIC8vIENvbiB0ZXh0bywgdXNhbW9zIGNyaXRlcmlvIG3DoXMgZXN0cmljdG8gcGFyYSBubyBjcnV6YXIgY29sdW1uYXMuXHJcbiAgICB2YXIgc2FtZVZpc3VhbENvbHVtbiA9IGludm9sdmVzVGV4dFxyXG4gICAgICA/IChjeERpc3QgPD0gTUFYX0NYX0RJU1QpXHJcbiAgICAgIDogKChob3ZSYXRpbyA+PSBNSU5fSF9PVkVSTEFQX1JBVElPKSB8fCAoY3hEaXN0IDw9IE1BWF9DWF9ESVNUKSk7XHJcbiAgICB2YXIgdkdhcCA9IHZlcnRpY2FsR2FwUHgoYSwgYik7XHJcbiAgICB2YXIgbmVhclZlcnRpY2FsID0gdkdhcCA+PSAwICYmIHZHYXAgPD0gUFJPWF9ZO1xyXG4gICAgdmFyIGJvdGhUZXh0ID0gYUlzVGV4dCAmJiBiSXNUZXh0O1xyXG5cclxuICAgIC8vIEV2aXRhciBcInBlZ2FyXCIgcMOhcnJhZm9zIGVudHJlIHPDrSBzb2xvIHBvciBjZXJjYW7DrWEgdmVydGljYWwuXHJcbiAgICAvLyBMYSB1bmnDs24gcG9yIHByb3hpbWlkYWQgcXVlZGEgcGFyYSBwYXJlcyBtaXh0b3MgKHRleHRvICsgbm8tdGV4dG8pLFxyXG4gICAgLy8gbWFudGVuaWVuZG8gZWwgY2FzbyBpY29uby9mb3JtYSArIHRleHRvLlxyXG4gICAgaWYgKHNhbWVWaXN1YWxDb2x1bW4gJiYgbmVhclZlcnRpY2FsICYmICFib3RoVGV4dCkgdW5pb24oaSxqKTtcclxuXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFwID0ge307XHJcbiAgICBmb3IgKHZhciBrPTA7azxuO2srKyl7XHJcbiAgICAgIHZhciByID0gZmluZChrKTtcclxuICAgICAgaWYgKCFtYXBbcl0pIG1hcFtyXSA9IFtdO1xyXG4gICAgICBtYXBbcl0ucHVzaChpdGVtc1trXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNsdXN0ZXJzID0gW107XHJcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIGFyciA9IG1hcFtrZXldO1xyXG5cclxuICAgICAgdmFyIG1pblRvcCA9IEluZmluaXR5LCBtaW5MZWZ0ID0gSW5maW5pdHksIG1heFIgPSAtSW5maW5pdHksIG1heEIgPSAtSW5maW5pdHk7XHJcbiAgICAgIGZvciAodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtcclxuICAgICAgICB2YXIgaXQgPSBhcnJbaV07XHJcbiAgICAgICAgbWluVG9wID0gTWF0aC5taW4obWluVG9wLCBpdC50b3ApO1xyXG4gICAgICAgIG1pbkxlZnQgPSBNYXRoLm1pbihtaW5MZWZ0LCBpdC5sZWZ0KTtcclxuICAgICAgICBtYXhSID0gTWF0aC5tYXgobWF4UiwgaXQubGVmdCArIGl0LndpZHRoKTtcclxuICAgICAgICBtYXhCID0gTWF0aC5tYXgobWF4QiwgaXQudG9wICsgaXQuaGVpZ2h0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gb2Zmc2V0cyByZWxhdGl2b3MgcGFyYSBwcmVzZXJ2YXIgZWwgc29sYXBlIGRlbnRybyBkZWwgY2x1c3RlclxyXG4gICAgICBmb3IgKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgYXJyW2ldLl9yZWxUb3AgPSBhcnJbaV0udG9wIC0gbWluVG9wO1xyXG4gICAgICAgIGFycltpXS5fcmVsTGVmdCA9IGFycltpXS5sZWZ0IC0gbWluTGVmdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2x1c3RlcnMucHVzaCh7XHJcbiAgICAgICAgaXRlbXM6IGFycixcclxuICAgICAgICB0b3A6IG1pblRvcCxcclxuICAgICAgICBsZWZ0OiBtaW5MZWZ0LFxyXG4gICAgICAgIHdpZHRoOiBtYXhSIC0gbWluTGVmdCxcclxuICAgICAgICBoZWlnaHQ6IG1heEIgLSBtaW5Ub3AsXHJcbiAgICAgICAgY3g6IChtaW5MZWZ0ICsgbWF4UikgLyAyXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gb3JkZW4gZXN0YWJsZSBwb3IgdG9wIHBhcmEgY29uc2lzdGVuY2lhXHJcbiAgICBjbHVzdGVycy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuXHJcbiAgICByZXR1cm4gY2x1c3RlcnM7XHJcbiAgfVxyXG5cclxuICAvLyDinIUg4oCcZW50cmHigJ0gc2kgbmluZ8O6biBjbHVzdGVyIHNlIHNhbGUgaG9yaXpvbnRhbG1lbnRlIGRlbCBjb250ZW5lZG9yIGNvbnRlbnRcclxuICBmdW5jdGlvbiBjbHVzdGVyc0ZpdEluTW9iaWxlKGNsdXN0ZXJzLCByb290RWwpe1xyXG4gICAgdmFyIHJvb3RXID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IDA7XHJcbiAgICBpZiAoIXJvb3RXKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBmb3IgKHZhciBpPTA7aTxjbHVzdGVycy5sZW5ndGg7aSsrKXtcclxuICAgICAgdmFyIGMgPSBjbHVzdGVyc1tpXTtcclxuICAgICAgaWYgKGMubGVmdCA8IC0xKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICgoYy5sZWZ0ICsgYy53aWR0aCkgPiAocm9vdFcgKyAxKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5gLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsianNEb21IZWxwZXJzQmxvY2siLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/fitScale.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsFitScaleBlock: () => (/* binding */ jsFitScaleBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/fitScale.ts\nfunction jsFitScaleBlock() {\n    return '\\n  function ensureFitScaleBaseline(el){\\n    if (!el) return;\\n    if (!el.hasAttribute(\"data-msl-fit-orig-transform\")) {\\n      el.setAttribute(\"data-msl-fit-orig-transform\", el.style.transform || \"\");\\n    }\\n    if (!el.hasAttribute(\"data-msl-fit-orig-origin\")) {\\n      el.setAttribute(\"data-msl-fit-orig-origin\", el.style.transformOrigin || \"\");\\n    }\\n  }\\n\\n  function restoreFitScaleBaseline(el){\\n    if (!el) return;\\n    ensureFitScaleBaseline(el);\\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\\n    var baseOrigin = el.getAttribute(\"data-msl-fit-orig-origin\") || \"\";\\n    el.style.transform = baseTransform;\\n    if (baseOrigin) el.style.transformOrigin = baseOrigin;\\n    else el.style.removeProperty(\"transform-origin\");\\n  }\\n\\n  function applyElementFitScale(el, scale){\\n    if (!el) return;\\n    ensureFitScaleBaseline(el);\\n    var baseTransform = el.getAttribute(\"data-msl-fit-orig-transform\") || \"\";\\n    var next = baseTransform ? (baseTransform + \" scale(\" + scale + \")\") : (\"scale(\" + scale + \")\");\\n    el.style.transform = next;\\n    el.style.transformOrigin = \"top center\";\\n  }\\n\\n  function resetSectionFitScale(_sec, content, bleed){\\n    restoreFitScaleBaseline(content);\\n    restoreFitScaleBaseline(bleed);\\n  }\\n\\n  function computeSectionBounds(sec, nodes){\\n    if (!sec || !nodes || !nodes.length) return null;\\n    var minLeft = Infinity;\\n    var minTop = Infinity;\\n    var maxRight = -Infinity;\\n    var maxBottom = -Infinity;\\n    var valid = 0;\\n\\n    for (var i=0; i<nodes.length; i++){\\n      var node = nodes[i];\\n      if (!node) continue;\\n      var rr = relRect(node, sec);\\n      var w = Number(rr.width || 0);\\n      var h = Number(rr.height || 0);\\n      if (w <= 0.5 && h <= 0.5) continue;\\n\\n      var l = Number(rr.left || 0);\\n      var t = Number(rr.top || 0);\\n      var r = l + Math.max(0, w);\\n      var b = t + Math.max(0, h);\\n\\n      if (!isFinite(l) || !isFinite(t) || !isFinite(r) || !isFinite(b)) continue;\\n\\n      minLeft = Math.min(minLeft, l);\\n      minTop = Math.min(minTop, t);\\n      maxRight = Math.max(maxRight, r);\\n      maxBottom = Math.max(maxBottom, b);\\n      valid++;\\n    }\\n\\n    if (!valid || !isFinite(minLeft) || !isFinite(maxRight) || !isFinite(minTop) || !isFinite(maxBottom)) {\\n      return null;\\n    }\\n\\n    return {\\n      minLeft: minLeft,\\n      minTop: minTop,\\n      maxRight: maxRight,\\n      maxBottom: maxBottom,\\n      width: Math.max(0, maxRight - minLeft),\\n      height: Math.max(0, maxBottom - minTop),\\n      count: valid\\n    };\\n  }\\n\\n  function computeFitScale(sec, bounds, secModo, CFG){\\n    if (!sec || !bounds) return 1;\\n    var secRect = sec.getBoundingClientRect();\\n    var secW = Number(secRect.width || 0);\\n    var secH = Number(secRect.height || 0);\\n    if (secW <= 1) {\\n      return {\\n        scale: 1,\\n        debug: null\\n      };\\n    }\\n\\n    var targetCoverage = clamp(Number(CFG.FIT_TARGET_WIDTH_RATIO || 0.94), 0.75, 0.99);\\n    var minFillForUpscale = clamp(Number(CFG.FIT_MIN_FILL_RATIO || 0.9), 0.6, targetCoverage);\\n    var minScale = clamp(Number(CFG.FIT_MIN_SCALE || 0.88), 0.7, 1);\\n    var maxScale = Math.max(1, Number(CFG.FIT_MAX_SCALE || 1.16));\\n\\n    var contentW = Math.max(1, Number(bounds.width || 0));\\n    var coverage = contentW / secW;\\n\\n    var scale = 1;\\n    var debug = {\\n      secW: secW,\\n      secH: secH,\\n      targetCoverage: targetCoverage,\\n      minFillForUpscale: minFillForUpscale,\\n      minScale: minScale,\\n      maxScale: maxScale,\\n      coverage: coverage,\\n      initialScale: 1,\\n      maxScaleByWidth: null,\\n      maxScaleByHeight: null,\\n      scaleAfterWidthClamp: null,\\n      scaleAfterHeightClamp: null,\\n      tinyShrinkProtected: false,\\n      pantallaDownscaleBlocked: false\\n    };\\n    if (coverage < minFillForUpscale) {\\n      scale = targetCoverage / Math.max(0.01, coverage);\\n    }\\n    debug.initialScale = scale;\\n\\n    if (scale >= 1) scale = Math.min(scale, maxScale);\\n    else scale = Math.max(scale, minScale);\\n\\n    // L\\xedmite horizontal duro por centro visual.\\n    var centerX = secW / 2;\\n    var distLeft = Math.max(0, centerX - Number(bounds.minLeft || 0));\\n    var distRight = Math.max(0, Number(bounds.maxRight || 0) - centerX);\\n    var maxScaleByWidth = Infinity;\\n    if (distLeft > 0.5) {\\n      maxScaleByWidth = Math.min(maxScaleByWidth, centerX / distLeft);\\n    }\\n    if (distRight > 0.5) {\\n      maxScaleByWidth = Math.min(maxScaleByWidth, (secW - centerX) / distRight);\\n    }\\n    if (isFinite(maxScaleByWidth) && maxScaleByWidth > 0) {\\n      scale = Math.min(scale, maxScaleByWidth);\\n      debug.maxScaleByWidth = maxScaleByWidth;\\n    }\\n    debug.scaleAfterWidthClamp = scale;\\n\\n    if (secModo === \"pantalla\" && scale < 1 && scale > 0.94) {\\n      // Avoid shrinking \"pantalla\" for tiny overflows; preserve visual impact.\\n      scale = 1;\\n      debug.tinyShrinkProtected = true;\\n    }\\n\\n    // En modo pantalla no dejamos que el contenido se recorte por altura.\\n    if (secModo === \"pantalla\" && secH > 1) {\\n      var maxBottom = Number(bounds.maxBottom || 0);\\n      if (maxBottom > 1) {\\n        var maxScaleByHeight = secH / maxBottom;\\n        if (isFinite(maxScaleByHeight) && maxScaleByHeight > 0) {\\n          scale = Math.min(scale, maxScaleByHeight);\\n          debug.maxScaleByHeight = maxScaleByHeight;\\n        }\\n      }\\n    }\\n    debug.scaleAfterHeightClamp = scale;\\n\\n    if (secModo === \"pantalla\" && scale < 1) {\\n      // Pantalla sections already have their own viewport-fit logic.\\n      // Avoid additional downscale here to keep hero text readable.\\n      scale = 1;\\n      debug.pantallaDownscaleBlocked = true;\\n    }\\n\\n    if (!isFinite(scale) || scale <= 0) scale = 1;\\n    if (Math.abs(scale - 1) < 0.02) scale = 1;\\n    return {\\n      scale: scale,\\n      debug: debug\\n    };\\n  }\\n\\n  function applySectionFitScale(sec, content, bleed, nodesAll, secModo, CFG, meta, opts){\\n    if (!sec || !content) {\\n      return { scale: 1, neededHeight: 0, bounds: null };\\n    }\\n\\n    ensureFitScaleBaseline(content);\\n    ensureFitScaleBaseline(bleed);\\n    var preserveBottomGap = 0;\\n    if (opts && Number.isFinite(opts.preserveBottomGap)) {\\n      preserveBottomGap = Math.max(0, Number(opts.preserveBottomGap));\\n    }\\n\\n    var fitNodes = (nodesAll || []).filter(function(node){\\n      if (!node) return false;\\n      var fitMode = (node.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\\n      if (fitMode === \"ignore\") return false;\\n      if (node.closest && node.closest(\".sec-bleed\")) return false;\\n      return true;\\n    });\\n\\n    var bounds = computeSectionBounds(sec, fitNodes);\\n    if (!bounds) {\\n      bounds = computeSectionBounds(sec, nodesAll || []);\\n    }\\n    if (!bounds) {\\n      restoreFitScaleBaseline(content);\\n      restoreFitScaleBaseline(bleed);\\n      sec.setAttribute(\"data-msl-fit-scale\", \"1\");\\n      return { scale: 1, neededHeight: 0, bounds: null };\\n    }\\n\\n    var fitResult = computeFitScale(sec, bounds, secModo, CFG);\\n    var scale = (fitResult && Number.isFinite(fitResult.scale)) ? fitResult.scale : 1;\\n    var fitDebug = fitResult && fitResult.debug ? fitResult.debug : null;\\n    applyElementFitScale(content, scale);\\n    applyElementFitScale(bleed, scale);\\n\\n    var neededHeight = 0;\\n    if (secModo !== \"pantalla\") {\\n      var maxBottomWithGap = Number(bounds.maxBottom || 0) + preserveBottomGap;\\n      neededHeight = Math.ceil(maxBottomWithGap * scale + (CFG.PAD_BOT || 0));\\n    }\\n\\n    if (secModo === \"pantalla\") {\\n      var secRectNow = sec.getBoundingClientRect();\\n      var vv = window.visualViewport;\\n      var viewportW = (vv && vv.width) ? vv.width : (window.innerWidth || document.documentElement.clientWidth || 0);\\n      var viewportH = (vv && vv.height) ? vv.height : (window.innerHeight || document.documentElement.clientHeight || 0);\\n      var ua = navigator.userAgent || \"\";\\n      var mobileUA = /Android|iPhone|iPad|iPod|Mobile/i.test(ua);\\n      var touchPoints = Number(navigator.maxTouchPoints || 0);\\n      var coarsePointer = false;\\n      if (window.matchMedia) {\\n        try { coarsePointer = window.matchMedia(\"(pointer: coarse)\").matches; } catch(_e) {}\\n      }\\n      var mobileViewport = viewportW <= 767;\\n      var desktopMobilePreview = mobileViewport && !mobileUA;\\n\\n      var boundsAll = computeSectionBounds(sec, nodesAll || []);\\n      var totalNodes = (nodesAll || []).length;\\n      var fitNodesCount = fitNodes.length;\\n      var textAll = 0;\\n      var textFit = 0;\\n      var ignoredBleed = 0;\\n      var ignoredExplicit = 0;\\n      var dominantText = null;\\n      var dominantTextH = -1;\\n      var elementRows = [];\\n\\n      for (var ni=0; ni<totalNodes; ni++){\\n        var nodeAll = nodesAll[ni];\\n        if (!nodeAll) continue;\\n\\n        var fitModeAll = (nodeAll.getAttribute(\"data-mobile-fit\") || \"\").toLowerCase();\\n        if (fitModeAll === \"ignore\") ignoredExplicit++;\\n        if (nodeAll.closest && nodeAll.closest(\".sec-bleed\")) ignoredBleed++;\\n\\n        var rrNode = relRect(nodeAll, sec);\\n        var nodeW = Number(rrNode.width || 0);\\n        var nodeH = Number(rrNode.height || 0);\\n        var nodeTop = Number(rrNode.top || 0);\\n        var nodeBottom = nodeTop + nodeH;\\n        var isTextAll = (nodeAll.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n        if (isTextAll) textAll++;\\n\\n        if (nodeW > 0.5 || nodeH > 0.5) {\\n          var kindAll = isTextAll ? \"texto\" : String((nodeAll.tagName || \"\").toLowerCase());\\n          elementRows.push({\\n            kind: kindAll,\\n            width: nodeW,\\n            height: nodeH,\\n            top: nodeTop,\\n            bottom: nodeBottom,\\n            area: nodeW * nodeH,\\n            textSample: isTextAll\\n              ? ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 70)\\n              : \"\"\\n          });\\n        }\\n\\n        if (!isTextAll) continue;\\n        if (nodeH <= dominantTextH) continue;\\n        dominantTextH = nodeH;\\n        var csTxt = getComputedStyle(nodeAll);\\n        dominantText = {\\n          top: +nodeTop.toFixed(1),\\n          left: +Number(rrNode.left || 0).toFixed(1),\\n          width: +nodeW.toFixed(1),\\n          height: +nodeH.toFixed(1),\\n          bottom: +nodeBottom.toFixed(1),\\n          widthSecRatio: secRectNow.width > 1 ? +(nodeW / secRectNow.width).toFixed(3) : null,\\n          heightSecRatio: secRectNow.height > 1 ? +(nodeH / secRectNow.height).toFixed(3) : null,\\n          widthViewportRatio: viewportW > 1 ? +(nodeW / viewportW).toFixed(3) : null,\\n          heightViewportRatio: viewportH > 1 ? +(nodeH / viewportH).toFixed(3) : null,\\n          fontSize: csTxt.fontSize || \"\",\\n          lineHeight: csTxt.lineHeight || \"\",\\n          textAlign: csTxt.textAlign || \"\",\\n          transform: (nodeAll.style && nodeAll.style.transform) ? nodeAll.style.transform : \"\",\\n          textSample: ((nodeAll.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 90)\\n        };\\n      }\\n\\n      for (var fi=0; fi<fitNodes.length; fi++){\\n        var fitNode = fitNodes[fi];\\n        if ((fitNode.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textFit++;\\n      }\\n\\n      var topElements = elementRows\\n        .sort(function(a,b){ return (b.area || 0) - (a.area || 0); })\\n        .slice(0, 6)\\n        .map(function(row){\\n          return {\\n            kind: row.kind,\\n            width: +Number(row.width || 0).toFixed(1),\\n            height: +Number(row.height || 0).toFixed(1),\\n            widthSecRatio: secRectNow.width > 1 ? +((row.width || 0) / secRectNow.width).toFixed(3) : null,\\n            heightSecRatio: secRectNow.height > 1 ? +((row.height || 0) / secRectNow.height).toFixed(3) : null,\\n            widthViewportRatio: viewportW > 1 ? +((row.width || 0) / viewportW).toFixed(3) : null,\\n            heightViewportRatio: viewportH > 1 ? +((row.height || 0) / viewportH).toFixed(3) : null,\\n            topSecRatio: secRectNow.height > 1 ? +((row.top || 0) / secRectNow.height).toFixed(3) : null,\\n            bottomSecRatio: secRectNow.height > 1 ? +((row.bottom || 0) / secRectNow.height).toFixed(3) : null,\\n            sample: row.textSample || \"\"\\n          };\\n        });\\n\\n      var coverageFit = bounds.width / Math.max(1, secRectNow.width || 0);\\n      var coverageAll = boundsAll ? (boundsAll.width / Math.max(1, secRectNow.width || 0)) : null;\\n\\n      var flatLines = [];\\n      flatLines.push(\\n        \"sec=\" + String(meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1)\\n        + \" viewport=\" + (+Number(viewportW || 0).toFixed(1)) + \"x\" + (+Number(viewportH || 0).toFixed(1))\\n        + \" sec=\" + (+Number(secRectNow.width || 0).toFixed(1)) + \"x\" + (+Number(secRectNow.height || 0).toFixed(1))\\n        + \" mobileViewport=\" + String(mobileViewport)\\n        + \" desktopMobilePreview=\" + String(desktopMobilePreview)\\n        + \" mobileUA=\" + String(mobileUA)\\n        + \" coarsePointer=\" + String(coarsePointer)\\n        + \" touchPoints=\" + String(touchPoints)\\n      );\\n      flatLines.push(\\n        \"fit scale=\" + (+Number(scale || 1).toFixed(3))\\n        + \" coverageFit=\" + (+coverageFit.toFixed(3))\\n        + \" coverageAll=\" + (coverageAll == null ? \"null\" : String(+coverageAll.toFixed(3)))\\n        + \" nodes=\" + String(fitNodesCount) + \"/\" + String(totalNodes)\\n        + \" ignoredBleed=\" + String(ignoredBleed)\\n        + \" ignoredExplicit=\" + String(ignoredExplicit)\\n        + \" tinyShrinkProtected=\" + String(!!(fitDebug && fitDebug.tinyShrinkProtected))\\n        + \" pantallaDownscaleBlocked=\" + String(!!(fitDebug && fitDebug.pantallaDownscaleBlocked))\\n      );\\n      if (dominantText) {\\n        flatLines.push(\\n          \"dominantText hSecRatio=\" + String(dominantText.heightSecRatio)\\n          + \" hViewportRatio=\" + String(dominantText.heightViewportRatio)\\n          + \" wSecRatio=\" + String(dominantText.widthSecRatio)\\n          + \" fontSize=\" + String(dominantText.fontSize || \"\")\\n          + \" lineHeight=\" + String(dominantText.lineHeight || \"\")\\n          + \" sample=\\'\" + String(dominantText.textSample || \"\") + \"\\'\"\\n        );\\n      } else {\\n        flatLines.push(\"dominantText none\");\\n      }\\n      for (var te=0; te<topElements.length; te++){\\n        var e = topElements[te];\\n        flatLines.push(\\n          \"el#\" + String(te + 1)\\n          + \" kind=\" + String(e.kind || \"\")\\n          + \" wVp=\" + String(e.widthViewportRatio)\\n          + \" hVp=\" + String(e.heightViewportRatio)\\n          + \" topSec=\" + String(e.topSecRatio)\\n          + \" bottomSec=\" + String(e.bottomSecRatio)\\n          + (e.sample ? (\" sample=\\'\" + String(e.sample) + \"\\'\") : \"\")\\n        );\\n      }\\n      mslLog(\"section:fitScale:pantalla:flat\", flatLines.join(\"\\\\n\"));\\n\\n      mslLog(\"section:fitScale:pantalla\", {\\n        secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\\n        secW: +Number(secRectNow.width || 0).toFixed(1),\\n        secH: +Number(secRectNow.height || 0).toFixed(1),\\n        viewport: {\\n          width: +Number(viewportW || 0).toFixed(1),\\n          height: +Number(viewportH || 0).toFixed(1)\\n        },\\n        displayContext: {\\n          mobileViewport: mobileViewport,\\n          desktopMobilePreview: desktopMobilePreview,\\n          mobileUA: mobileUA,\\n          coarsePointer: coarsePointer,\\n          touchPoints: touchPoints\\n        },\\n        preserveBottomGap: +preserveBottomGap.toFixed(1),\\n        totalNodes: totalNodes,\\n        fitNodes: fitNodesCount,\\n        textNodesAll: textAll,\\n        textNodesFit: textFit,\\n        ignoredBleed: ignoredBleed,\\n        ignoredExplicit: ignoredExplicit,\\n        coverageFit: +coverageFit.toFixed(3),\\n        coverageAll: coverageAll == null ? null : +coverageAll.toFixed(3),\\n        fitBounds: {\\n          width: +Number(bounds.width || 0).toFixed(1),\\n          height: +Number(bounds.height || 0).toFixed(1),\\n          maxBottom: +Number(bounds.maxBottom || 0).toFixed(1)\\n        },\\n        allBounds: boundsAll ? {\\n          width: +Number(boundsAll.width || 0).toFixed(1),\\n          height: +Number(boundsAll.height || 0).toFixed(1),\\n          maxBottom: +Number(boundsAll.maxBottom || 0).toFixed(1)\\n        } : null,\\n        fitDebug: fitDebug ? {\\n          targetCoverage: +Number(fitDebug.targetCoverage || 0).toFixed(3),\\n          minFillForUpscale: +Number(fitDebug.minFillForUpscale || 0).toFixed(3),\\n          coverage: +Number(fitDebug.coverage || 0).toFixed(3),\\n          initialScale: +Number(fitDebug.initialScale || 0).toFixed(3),\\n          maxScaleByWidth: fitDebug.maxScaleByWidth == null ? null : +Number(fitDebug.maxScaleByWidth).toFixed(3),\\n          maxScaleByHeight: fitDebug.maxScaleByHeight == null ? null : +Number(fitDebug.maxScaleByHeight).toFixed(3),\\n          scaleAfterWidthClamp: fitDebug.scaleAfterWidthClamp == null ? null : +Number(fitDebug.scaleAfterWidthClamp).toFixed(3),\\n          scaleAfterHeightClamp: fitDebug.scaleAfterHeightClamp == null ? null : +Number(fitDebug.scaleAfterHeightClamp).toFixed(3),\\n          tinyShrinkProtected: !!fitDebug.tinyShrinkProtected,\\n          pantallaDownscaleBlocked: !!fitDebug.pantallaDownscaleBlocked\\n        } : null,\\n        appliedScale: +Number(scale || 1).toFixed(3),\\n        dominantText: dominantText,\\n        topElements: topElements\\n      });\\n    }\\n\\n    sec.setAttribute(\"data-msl-fit-scale\", String(+scale.toFixed(3)));\\n    mslLog(\"section:fitScale\", {\\n      secIndex: meta && Number.isFinite(meta.secIndex) ? meta.secIndex : -1,\\n      mode: secModo,\\n      nodes: bounds.count,\\n      coverage: +(bounds.width / Math.max(1, sec.getBoundingClientRect().width || 0)).toFixed(3),\\n      boxW: +bounds.width.toFixed(1),\\n      boxH: +bounds.height.toFixed(1),\\n      scale: +scale.toFixed(3),\\n      preserveBottomGap: +preserveBottomGap.toFixed(1),\\n      scaledBottomGap: +((preserveBottomGap || 0) * scale).toFixed(1),\\n      neededHeight: neededHeight\\n    });\\n\\n    return {\\n      scale: scale,\\n      neededHeight: neededHeight,\\n      bounds: bounds\\n    };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvZml0U2NhbGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sMnZqQkEyYlBDLElBQUk7QUFDTiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydExheW91dFxcZml0U2NhbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydExheW91dC9maXRTY2FsZS50c1xuZXhwb3J0IGZ1bmN0aW9uIGpzRml0U2NhbGVCbG9jaygpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICBmdW5jdGlvbiBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGVsKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLXRyYW5zZm9ybVwiLCBlbC5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LW9yaWctb3JpZ2luXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy1vcmlnaW5cIiwgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luIHx8IFwiXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGVsKXtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShlbCk7XG4gICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1maXQtb3JpZy10cmFuc2Zvcm1cIikgfHwgXCJcIjtcbiAgICB2YXIgYmFzZU9yaWdpbiA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLW9yaWdpblwiKSB8fCBcIlwiO1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gICAgaWYgKGJhc2VPcmlnaW4pIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGJhc2VPcmlnaW47XG4gICAgZWxzZSBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybS1vcmlnaW5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUVsZW1lbnRGaXRTY2FsZShlbCwgc2NhbGUpe1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBlbnN1cmVGaXRTY2FsZUJhc2VsaW5lKGVsKTtcbiAgICB2YXIgYmFzZVRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1vcmlnLXRyYW5zZm9ybVwiKSB8fCBcIlwiO1xuICAgIHZhciBuZXh0ID0gYmFzZVRyYW5zZm9ybSA/IChiYXNlVHJhbnNmb3JtICsgXCIgc2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiKSA6IChcInNjYWxlKFwiICsgc2NhbGUgKyBcIilcIik7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtID0gbmV4dDtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U2VjdGlvbkZpdFNjYWxlKF9zZWMsIGNvbnRlbnQsIGJsZWVkKXtcbiAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShjb250ZW50KTtcbiAgICByZXN0b3JlRml0U2NhbGVCYXNlbGluZShibGVlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIG5vZGVzKXtcbiAgICBpZiAoIXNlYyB8fCAhbm9kZXMgfHwgIW5vZGVzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1pbkxlZnQgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluVG9wID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFJpZ2h0ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhCb3R0b20gPSAtSW5maW5pdHk7XG4gICAgdmFyIHZhbGlkID0gMDtcblxuICAgIGZvciAodmFyIGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKCFub2RlKSBjb250aW51ZTtcbiAgICAgIHZhciByciA9IHJlbFJlY3Qobm9kZSwgc2VjKTtcbiAgICAgIHZhciB3ID0gTnVtYmVyKHJyLndpZHRoIHx8IDApO1xuICAgICAgdmFyIGggPSBOdW1iZXIocnIuaGVpZ2h0IHx8IDApO1xuICAgICAgaWYgKHcgPD0gMC41ICYmIGggPD0gMC41KSBjb250aW51ZTtcblxuICAgICAgdmFyIGwgPSBOdW1iZXIocnIubGVmdCB8fCAwKTtcbiAgICAgIHZhciB0ID0gTnVtYmVyKHJyLnRvcCB8fCAwKTtcbiAgICAgIHZhciByID0gbCArIE1hdGgubWF4KDAsIHcpO1xuICAgICAgdmFyIGIgPSB0ICsgTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAgIGlmICghaXNGaW5pdGUobCkgfHwgIWlzRmluaXRlKHQpIHx8ICFpc0Zpbml0ZShyKSB8fCAhaXNGaW5pdGUoYikpIGNvbnRpbnVlO1xuXG4gICAgICBtaW5MZWZ0ID0gTWF0aC5taW4obWluTGVmdCwgbCk7XG4gICAgICBtaW5Ub3AgPSBNYXRoLm1pbihtaW5Ub3AsIHQpO1xuICAgICAgbWF4UmlnaHQgPSBNYXRoLm1heChtYXhSaWdodCwgcik7XG4gICAgICBtYXhCb3R0b20gPSBNYXRoLm1heChtYXhCb3R0b20sIGIpO1xuICAgICAgdmFsaWQrKztcbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkIHx8ICFpc0Zpbml0ZShtaW5MZWZ0KSB8fCAhaXNGaW5pdGUobWF4UmlnaHQpIHx8ICFpc0Zpbml0ZShtaW5Ub3ApIHx8ICFpc0Zpbml0ZShtYXhCb3R0b20pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluTGVmdDogbWluTGVmdCxcbiAgICAgIG1pblRvcDogbWluVG9wLFxuICAgICAgbWF4UmlnaHQ6IG1heFJpZ2h0LFxuICAgICAgbWF4Qm90dG9tOiBtYXhCb3R0b20sXG4gICAgICB3aWR0aDogTWF0aC5tYXgoMCwgbWF4UmlnaHQgLSBtaW5MZWZ0KSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgbWF4Qm90dG9tIC0gbWluVG9wKSxcbiAgICAgIGNvdW50OiB2YWxpZFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRml0U2NhbGUoc2VjLCBib3VuZHMsIHNlY01vZG8sIENGRyl7XG4gICAgaWYgKCFzZWMgfHwgIWJvdW5kcykgcmV0dXJuIDE7XG4gICAgdmFyIHNlY1JlY3QgPSBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHNlY1cgPSBOdW1iZXIoc2VjUmVjdC53aWR0aCB8fCAwKTtcbiAgICB2YXIgc2VjSCA9IE51bWJlcihzZWNSZWN0LmhlaWdodCB8fCAwKTtcbiAgICBpZiAoc2VjVyA8PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZGVidWc6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldENvdmVyYWdlID0gY2xhbXAoTnVtYmVyKENGRy5GSVRfVEFSR0VUX1dJRFRIX1JBVElPIHx8IDAuOTQpLCAwLjc1LCAwLjk5KTtcbiAgICB2YXIgbWluRmlsbEZvclVwc2NhbGUgPSBjbGFtcChOdW1iZXIoQ0ZHLkZJVF9NSU5fRklMTF9SQVRJTyB8fCAwLjkpLCAwLjYsIHRhcmdldENvdmVyYWdlKTtcbiAgICB2YXIgbWluU2NhbGUgPSBjbGFtcChOdW1iZXIoQ0ZHLkZJVF9NSU5fU0NBTEUgfHwgMC44OCksIDAuNywgMSk7XG4gICAgdmFyIG1heFNjYWxlID0gTWF0aC5tYXgoMSwgTnVtYmVyKENGRy5GSVRfTUFYX1NDQUxFIHx8IDEuMTYpKTtcblxuICAgIHZhciBjb250ZW50VyA9IE1hdGgubWF4KDEsIE51bWJlcihib3VuZHMud2lkdGggfHwgMCkpO1xuICAgIHZhciBjb3ZlcmFnZSA9IGNvbnRlbnRXIC8gc2VjVztcblxuICAgIHZhciBzY2FsZSA9IDE7XG4gICAgdmFyIGRlYnVnID0ge1xuICAgICAgc2VjVzogc2VjVyxcbiAgICAgIHNlY0g6IHNlY0gsXG4gICAgICB0YXJnZXRDb3ZlcmFnZTogdGFyZ2V0Q292ZXJhZ2UsXG4gICAgICBtaW5GaWxsRm9yVXBzY2FsZTogbWluRmlsbEZvclVwc2NhbGUsXG4gICAgICBtaW5TY2FsZTogbWluU2NhbGUsXG4gICAgICBtYXhTY2FsZTogbWF4U2NhbGUsXG4gICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG4gICAgICBpbml0aWFsU2NhbGU6IDEsXG4gICAgICBtYXhTY2FsZUJ5V2lkdGg6IG51bGwsXG4gICAgICBtYXhTY2FsZUJ5SGVpZ2h0OiBudWxsLFxuICAgICAgc2NhbGVBZnRlcldpZHRoQ2xhbXA6IG51bGwsXG4gICAgICBzY2FsZUFmdGVySGVpZ2h0Q2xhbXA6IG51bGwsXG4gICAgICB0aW55U2hyaW5rUHJvdGVjdGVkOiBmYWxzZSxcbiAgICAgIHBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChjb3ZlcmFnZSA8IG1pbkZpbGxGb3JVcHNjYWxlKSB7XG4gICAgICBzY2FsZSA9IHRhcmdldENvdmVyYWdlIC8gTWF0aC5tYXgoMC4wMSwgY292ZXJhZ2UpO1xuICAgIH1cbiAgICBkZWJ1Zy5pbml0aWFsU2NhbGUgPSBzY2FsZTtcblxuICAgIGlmIChzY2FsZSA+PSAxKSBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZSk7XG4gICAgZWxzZSBzY2FsZSA9IE1hdGgubWF4KHNjYWxlLCBtaW5TY2FsZSk7XG5cbiAgICAvLyBMw61taXRlIGhvcml6b250YWwgZHVybyBwb3IgY2VudHJvIHZpc3VhbC5cbiAgICB2YXIgY2VudGVyWCA9IHNlY1cgLyAyO1xuICAgIHZhciBkaXN0TGVmdCA9IE1hdGgubWF4KDAsIGNlbnRlclggLSBOdW1iZXIoYm91bmRzLm1pbkxlZnQgfHwgMCkpO1xuICAgIHZhciBkaXN0UmlnaHQgPSBNYXRoLm1heCgwLCBOdW1iZXIoYm91bmRzLm1heFJpZ2h0IHx8IDApIC0gY2VudGVyWCk7XG4gICAgdmFyIG1heFNjYWxlQnlXaWR0aCA9IEluZmluaXR5O1xuICAgIGlmIChkaXN0TGVmdCA+IDAuNSkge1xuICAgICAgbWF4U2NhbGVCeVdpZHRoID0gTWF0aC5taW4obWF4U2NhbGVCeVdpZHRoLCBjZW50ZXJYIC8gZGlzdExlZnQpO1xuICAgIH1cbiAgICBpZiAoZGlzdFJpZ2h0ID4gMC41KSB7XG4gICAgICBtYXhTY2FsZUJ5V2lkdGggPSBNYXRoLm1pbihtYXhTY2FsZUJ5V2lkdGgsIChzZWNXIC0gY2VudGVyWCkgLyBkaXN0UmlnaHQpO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGUobWF4U2NhbGVCeVdpZHRoKSAmJiBtYXhTY2FsZUJ5V2lkdGggPiAwKSB7XG4gICAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhTY2FsZUJ5V2lkdGgpO1xuICAgICAgZGVidWcubWF4U2NhbGVCeVdpZHRoID0gbWF4U2NhbGVCeVdpZHRoO1xuICAgIH1cbiAgICBkZWJ1Zy5zY2FsZUFmdGVyV2lkdGhDbGFtcCA9IHNjYWxlO1xuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzY2FsZSA8IDEgJiYgc2NhbGUgPiAwLjk0KSB7XG4gICAgICAvLyBBdm9pZCBzaHJpbmtpbmcgXCJwYW50YWxsYVwiIGZvciB0aW55IG92ZXJmbG93czsgcHJlc2VydmUgdmlzdWFsIGltcGFjdC5cbiAgICAgIHNjYWxlID0gMTtcbiAgICAgIGRlYnVnLnRpbnlTaHJpbmtQcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEVuIG1vZG8gcGFudGFsbGEgbm8gZGVqYW1vcyBxdWUgZWwgY29udGVuaWRvIHNlIHJlY29ydGUgcG9yIGFsdHVyYS5cbiAgICBpZiAoc2VjTW9kbyA9PT0gXCJwYW50YWxsYVwiICYmIHNlY0ggPiAxKSB7XG4gICAgICB2YXIgbWF4Qm90dG9tID0gTnVtYmVyKGJvdW5kcy5tYXhCb3R0b20gfHwgMCk7XG4gICAgICBpZiAobWF4Qm90dG9tID4gMSkge1xuICAgICAgICB2YXIgbWF4U2NhbGVCeUhlaWdodCA9IHNlY0ggLyBtYXhCb3R0b207XG4gICAgICAgIGlmIChpc0Zpbml0ZShtYXhTY2FsZUJ5SGVpZ2h0KSAmJiBtYXhTY2FsZUJ5SGVpZ2h0ID4gMCkge1xuICAgICAgICAgIHNjYWxlID0gTWF0aC5taW4oc2NhbGUsIG1heFNjYWxlQnlIZWlnaHQpO1xuICAgICAgICAgIGRlYnVnLm1heFNjYWxlQnlIZWlnaHQgPSBtYXhTY2FsZUJ5SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnLnNjYWxlQWZ0ZXJIZWlnaHRDbGFtcCA9IHNjYWxlO1xuXG4gICAgaWYgKHNlY01vZG8gPT09IFwicGFudGFsbGFcIiAmJiBzY2FsZSA8IDEpIHtcbiAgICAgIC8vIFBhbnRhbGxhIHNlY3Rpb25zIGFscmVhZHkgaGF2ZSB0aGVpciBvd24gdmlld3BvcnQtZml0IGxvZ2ljLlxuICAgICAgLy8gQXZvaWQgYWRkaXRpb25hbCBkb3duc2NhbGUgaGVyZSB0byBrZWVwIGhlcm8gdGV4dCByZWFkYWJsZS5cbiAgICAgIHNjYWxlID0gMTtcbiAgICAgIGRlYnVnLnBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShzY2FsZSkgfHwgc2NhbGUgPD0gMCkgc2NhbGUgPSAxO1xuICAgIGlmIChNYXRoLmFicyhzY2FsZSAtIDEpIDwgMC4wMikgc2NhbGUgPSAxO1xuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBkZWJ1ZzogZGVidWdcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCwgbm9kZXNBbGwsIHNlY01vZG8sIENGRywgbWV0YSwgb3B0cyl7XG4gICAgaWYgKCFzZWMgfHwgIWNvbnRlbnQpIHtcbiAgICAgIHJldHVybiB7IHNjYWxlOiAxLCBuZWVkZWRIZWlnaHQ6IDAsIGJvdW5kczogbnVsbCB9O1xuICAgIH1cblxuICAgIGVuc3VyZUZpdFNjYWxlQmFzZWxpbmUoY29udGVudCk7XG4gICAgZW5zdXJlRml0U2NhbGVCYXNlbGluZShibGVlZCk7XG4gICAgdmFyIHByZXNlcnZlQm90dG9tR2FwID0gMDtcbiAgICBpZiAob3B0cyAmJiBOdW1iZXIuaXNGaW5pdGUob3B0cy5wcmVzZXJ2ZUJvdHRvbUdhcCkpIHtcbiAgICAgIHByZXNlcnZlQm90dG9tR2FwID0gTWF0aC5tYXgoMCwgTnVtYmVyKG9wdHMucHJlc2VydmVCb3R0b21HYXApKTtcbiAgICB9XG5cbiAgICB2YXIgZml0Tm9kZXMgPSAobm9kZXNBbGwgfHwgW10pLmZpbHRlcihmdW5jdGlvbihub2RlKXtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGZpdE1vZGUgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1maXRcIikgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChmaXRNb2RlID09PSBcImlnbm9yZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobm9kZS5jbG9zZXN0ICYmIG5vZGUuY2xvc2VzdChcIi5zZWMtYmxlZWRcIikpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgdmFyIGJvdW5kcyA9IGNvbXB1dGVTZWN0aW9uQm91bmRzKHNlYywgZml0Tm9kZXMpO1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICBib3VuZHMgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIG5vZGVzQWxsIHx8IFtdKTtcbiAgICB9XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgIHJlc3RvcmVGaXRTY2FsZUJhc2VsaW5lKGNvbnRlbnQpO1xuICAgICAgcmVzdG9yZUZpdFNjYWxlQmFzZWxpbmUoYmxlZWQpO1xuICAgICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBcIjFcIik7XG4gICAgICByZXR1cm4geyBzY2FsZTogMSwgbmVlZGVkSGVpZ2h0OiAwLCBib3VuZHM6IG51bGwgfTtcbiAgICB9XG5cbiAgICB2YXIgZml0UmVzdWx0ID0gY29tcHV0ZUZpdFNjYWxlKHNlYywgYm91bmRzLCBzZWNNb2RvLCBDRkcpO1xuICAgIHZhciBzY2FsZSA9IChmaXRSZXN1bHQgJiYgTnVtYmVyLmlzRmluaXRlKGZpdFJlc3VsdC5zY2FsZSkpID8gZml0UmVzdWx0LnNjYWxlIDogMTtcbiAgICB2YXIgZml0RGVidWcgPSBmaXRSZXN1bHQgJiYgZml0UmVzdWx0LmRlYnVnID8gZml0UmVzdWx0LmRlYnVnIDogbnVsbDtcbiAgICBhcHBseUVsZW1lbnRGaXRTY2FsZShjb250ZW50LCBzY2FsZSk7XG4gICAgYXBwbHlFbGVtZW50Rml0U2NhbGUoYmxlZWQsIHNjYWxlKTtcblxuICAgIHZhciBuZWVkZWRIZWlnaHQgPSAwO1xuICAgIGlmIChzZWNNb2RvICE9PSBcInBhbnRhbGxhXCIpIHtcbiAgICAgIHZhciBtYXhCb3R0b21XaXRoR2FwID0gTnVtYmVyKGJvdW5kcy5tYXhCb3R0b20gfHwgMCkgKyBwcmVzZXJ2ZUJvdHRvbUdhcDtcbiAgICAgIG5lZWRlZEhlaWdodCA9IE1hdGguY2VpbChtYXhCb3R0b21XaXRoR2FwICogc2NhbGUgKyAoQ0ZHLlBBRF9CT1QgfHwgMCkpO1xuICAgIH1cblxuICAgIGlmIChzZWNNb2RvID09PSBcInBhbnRhbGxhXCIpIHtcbiAgICAgIHZhciBzZWNSZWN0Tm93ID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHZ2ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuICAgICAgdmFyIHZpZXdwb3J0VyA9ICh2diAmJiB2di53aWR0aCkgPyB2di53aWR0aCA6ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCk7XG4gICAgICB2YXIgdmlld3BvcnRIID0gKHZ2ICYmIHZ2LmhlaWdodCkgPyB2di5oZWlnaHQgOiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCk7XG4gICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gICAgICB2YXIgbW9iaWxlVUEgPSAvQW5kcm9pZHxpUGhvbmV8aVBhZHxpUG9kfE1vYmlsZS9pLnRlc3QodWEpO1xuICAgICAgdmFyIHRvdWNoUG9pbnRzID0gTnVtYmVyKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwKTtcbiAgICAgIHZhciBjb2Fyc2VQb2ludGVyID0gZmFsc2U7XG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgdHJ5IHsgY29hcnNlUG9pbnRlciA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlczsgfSBjYXRjaChfZSkge31cbiAgICAgIH1cbiAgICAgIHZhciBtb2JpbGVWaWV3cG9ydCA9IHZpZXdwb3J0VyA8PSA3Njc7XG4gICAgICB2YXIgZGVza3RvcE1vYmlsZVByZXZpZXcgPSBtb2JpbGVWaWV3cG9ydCAmJiAhbW9iaWxlVUE7XG5cbiAgICAgIHZhciBib3VuZHNBbGwgPSBjb21wdXRlU2VjdGlvbkJvdW5kcyhzZWMsIG5vZGVzQWxsIHx8IFtdKTtcbiAgICAgIHZhciB0b3RhbE5vZGVzID0gKG5vZGVzQWxsIHx8IFtdKS5sZW5ndGg7XG4gICAgICB2YXIgZml0Tm9kZXNDb3VudCA9IGZpdE5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciB0ZXh0QWxsID0gMDtcbiAgICAgIHZhciB0ZXh0Rml0ID0gMDtcbiAgICAgIHZhciBpZ25vcmVkQmxlZWQgPSAwO1xuICAgICAgdmFyIGlnbm9yZWRFeHBsaWNpdCA9IDA7XG4gICAgICB2YXIgZG9taW5hbnRUZXh0ID0gbnVsbDtcbiAgICAgIHZhciBkb21pbmFudFRleHRIID0gLTE7XG4gICAgICB2YXIgZWxlbWVudFJvd3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbmk9MDsgbmk8dG90YWxOb2RlczsgbmkrKyl7XG4gICAgICAgIHZhciBub2RlQWxsID0gbm9kZXNBbGxbbmldO1xuICAgICAgICBpZiAoIW5vZGVBbGwpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBmaXRNb2RlQWxsID0gKG5vZGVBbGwuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChmaXRNb2RlQWxsID09PSBcImlnbm9yZVwiKSBpZ25vcmVkRXhwbGljaXQrKztcbiAgICAgICAgaWYgKG5vZGVBbGwuY2xvc2VzdCAmJiBub2RlQWxsLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSBpZ25vcmVkQmxlZWQrKztcblxuICAgICAgICB2YXIgcnJOb2RlID0gcmVsUmVjdChub2RlQWxsLCBzZWMpO1xuICAgICAgICB2YXIgbm9kZVcgPSBOdW1iZXIocnJOb2RlLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgbm9kZUggPSBOdW1iZXIocnJOb2RlLmhlaWdodCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVUb3AgPSBOdW1iZXIocnJOb2RlLnRvcCB8fCAwKTtcbiAgICAgICAgdmFyIG5vZGVCb3R0b20gPSBub2RlVG9wICsgbm9kZUg7XG4gICAgICAgIHZhciBpc1RleHRBbGwgPSAobm9kZUFsbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgaWYgKGlzVGV4dEFsbCkgdGV4dEFsbCsrO1xuXG4gICAgICAgIGlmIChub2RlVyA+IDAuNSB8fCBub2RlSCA+IDAuNSkge1xuICAgICAgICAgIHZhciBraW5kQWxsID0gaXNUZXh0QWxsID8gXCJ0ZXh0b1wiIDogU3RyaW5nKChub2RlQWxsLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgZWxlbWVudFJvd3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiBraW5kQWxsLFxuICAgICAgICAgICAgd2lkdGg6IG5vZGVXLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlSCxcbiAgICAgICAgICAgIHRvcDogbm9kZVRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogbm9kZUJvdHRvbSxcbiAgICAgICAgICAgIGFyZWE6IG5vZGVXICogbm9kZUgsXG4gICAgICAgICAgICB0ZXh0U2FtcGxlOiBpc1RleHRBbGxcbiAgICAgICAgICAgICAgPyAoKG5vZGVBbGwudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5yZXBsYWNlKC9cXFxccysvZywgXCIgXCIpLnNsaWNlKDAsIDcwKVxuICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUZXh0QWxsKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGVIIDw9IGRvbWluYW50VGV4dEgpIGNvbnRpbnVlO1xuICAgICAgICBkb21pbmFudFRleHRIID0gbm9kZUg7XG4gICAgICAgIHZhciBjc1R4dCA9IGdldENvbXB1dGVkU3R5bGUobm9kZUFsbCk7XG4gICAgICAgIGRvbWluYW50VGV4dCA9IHtcbiAgICAgICAgICB0b3A6ICtub2RlVG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgbGVmdDogK051bWJlcihyck5vZGUubGVmdCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIHdpZHRoOiArbm9kZVcudG9GaXhlZCgxKSxcbiAgICAgICAgICBoZWlnaHQ6ICtub2RlSC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGJvdHRvbTogK25vZGVCb3R0b20udG9GaXhlZCgxKSxcbiAgICAgICAgICB3aWR0aFNlY1JhdGlvOiBzZWNSZWN0Tm93LndpZHRoID4gMSA/ICsobm9kZVcgLyBzZWNSZWN0Tm93LndpZHRoKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICBoZWlnaHRTZWNSYXRpbzogc2VjUmVjdE5vdy5oZWlnaHQgPiAxID8gKyhub2RlSCAvIHNlY1JlY3ROb3cuaGVpZ2h0KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICB3aWR0aFZpZXdwb3J0UmF0aW86IHZpZXdwb3J0VyA+IDEgPyArKG5vZGVXIC8gdmlld3BvcnRXKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICBoZWlnaHRWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydEggPiAxID8gKyhub2RlSCAvIHZpZXdwb3J0SCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgZm9udFNpemU6IGNzVHh0LmZvbnRTaXplIHx8IFwiXCIsXG4gICAgICAgICAgbGluZUhlaWdodDogY3NUeHQubGluZUhlaWdodCB8fCBcIlwiLFxuICAgICAgICAgIHRleHRBbGlnbjogY3NUeHQudGV4dEFsaWduIHx8IFwiXCIsXG4gICAgICAgICAgdHJhbnNmb3JtOiAobm9kZUFsbC5zdHlsZSAmJiBub2RlQWxsLnN0eWxlLnRyYW5zZm9ybSkgPyBub2RlQWxsLnN0eWxlLnRyYW5zZm9ybSA6IFwiXCIsXG4gICAgICAgICAgdGV4dFNhbXBsZTogKChub2RlQWxsLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA5MClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZmk9MDsgZmk8Zml0Tm9kZXMubGVuZ3RoOyBmaSsrKXtcbiAgICAgICAgdmFyIGZpdE5vZGUgPSBmaXROb2Rlc1tmaV07XG4gICAgICAgIGlmICgoZml0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgdGV4dEZpdCsrO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9wRWxlbWVudHMgPSBlbGVtZW50Um93c1xuICAgICAgICAuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gKGIuYXJlYSB8fCAwKSAtIChhLmFyZWEgfHwgMCk7IH0pXG4gICAgICAgIC5zbGljZSgwLCA2KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHJvdyl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IHJvdy5raW5kLFxuICAgICAgICAgICAgd2lkdGg6ICtOdW1iZXIocm93LndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoZWlnaHQ6ICtOdW1iZXIocm93LmhlaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgd2lkdGhTZWNSYXRpbzogc2VjUmVjdE5vdy53aWR0aCA+IDEgPyArKChyb3cud2lkdGggfHwgMCkgLyBzZWNSZWN0Tm93LndpZHRoKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodFNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cuaGVpZ2h0IHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgd2lkdGhWaWV3cG9ydFJhdGlvOiB2aWV3cG9ydFcgPiAxID8gKygocm93LndpZHRoIHx8IDApIC8gdmlld3BvcnRXKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodFZpZXdwb3J0UmF0aW86IHZpZXdwb3J0SCA+IDEgPyArKChyb3cuaGVpZ2h0IHx8IDApIC8gdmlld3BvcnRIKS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIHRvcFNlY1JhdGlvOiBzZWNSZWN0Tm93LmhlaWdodCA+IDEgPyArKChyb3cudG9wIHx8IDApIC8gc2VjUmVjdE5vdy5oZWlnaHQpLnRvRml4ZWQoMykgOiBudWxsLFxuICAgICAgICAgICAgYm90dG9tU2VjUmF0aW86IHNlY1JlY3ROb3cuaGVpZ2h0ID4gMSA/ICsoKHJvdy5ib3R0b20gfHwgMCkgLyBzZWNSZWN0Tm93LmhlaWdodCkudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBzYW1wbGU6IHJvdy50ZXh0U2FtcGxlIHx8IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgdmFyIGNvdmVyYWdlRml0ID0gYm91bmRzLndpZHRoIC8gTWF0aC5tYXgoMSwgc2VjUmVjdE5vdy53aWR0aCB8fCAwKTtcbiAgICAgIHZhciBjb3ZlcmFnZUFsbCA9IGJvdW5kc0FsbCA/IChib3VuZHNBbGwud2lkdGggLyBNYXRoLm1heCgxLCBzZWNSZWN0Tm93LndpZHRoIHx8IDApKSA6IG51bGw7XG5cbiAgICAgIHZhciBmbGF0TGluZXMgPSBbXTtcbiAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICBcInNlYz1cIiArIFN0cmluZyhtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSlcbiAgICAgICAgKyBcIiB2aWV3cG9ydD1cIiArICgrTnVtYmVyKHZpZXdwb3J0VyB8fCAwKS50b0ZpeGVkKDEpKSArIFwieFwiICsgKCtOdW1iZXIodmlld3BvcnRIIHx8IDApLnRvRml4ZWQoMSkpXG4gICAgICAgICsgXCIgc2VjPVwiICsgKCtOdW1iZXIoc2VjUmVjdE5vdy53aWR0aCB8fCAwKS50b0ZpeGVkKDEpKSArIFwieFwiICsgKCtOdW1iZXIoc2VjUmVjdE5vdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSlcbiAgICAgICAgKyBcIiBtb2JpbGVWaWV3cG9ydD1cIiArIFN0cmluZyhtb2JpbGVWaWV3cG9ydClcbiAgICAgICAgKyBcIiBkZXNrdG9wTW9iaWxlUHJldmlldz1cIiArIFN0cmluZyhkZXNrdG9wTW9iaWxlUHJldmlldylcbiAgICAgICAgKyBcIiBtb2JpbGVVQT1cIiArIFN0cmluZyhtb2JpbGVVQSlcbiAgICAgICAgKyBcIiBjb2Fyc2VQb2ludGVyPVwiICsgU3RyaW5nKGNvYXJzZVBvaW50ZXIpXG4gICAgICAgICsgXCIgdG91Y2hQb2ludHM9XCIgKyBTdHJpbmcodG91Y2hQb2ludHMpXG4gICAgICApO1xuICAgICAgZmxhdExpbmVzLnB1c2goXG4gICAgICAgIFwiZml0IHNjYWxlPVwiICsgKCtOdW1iZXIoc2NhbGUgfHwgMSkudG9GaXhlZCgzKSlcbiAgICAgICAgKyBcIiBjb3ZlcmFnZUZpdD1cIiArICgrY292ZXJhZ2VGaXQudG9GaXhlZCgzKSlcbiAgICAgICAgKyBcIiBjb3ZlcmFnZUFsbD1cIiArIChjb3ZlcmFnZUFsbCA9PSBudWxsID8gXCJudWxsXCIgOiBTdHJpbmcoK2NvdmVyYWdlQWxsLnRvRml4ZWQoMykpKVxuICAgICAgICArIFwiIG5vZGVzPVwiICsgU3RyaW5nKGZpdE5vZGVzQ291bnQpICsgXCIvXCIgKyBTdHJpbmcodG90YWxOb2RlcylcbiAgICAgICAgKyBcIiBpZ25vcmVkQmxlZWQ9XCIgKyBTdHJpbmcoaWdub3JlZEJsZWVkKVxuICAgICAgICArIFwiIGlnbm9yZWRFeHBsaWNpdD1cIiArIFN0cmluZyhpZ25vcmVkRXhwbGljaXQpXG4gICAgICAgICsgXCIgdGlueVNocmlua1Byb3RlY3RlZD1cIiArIFN0cmluZyghIShmaXREZWJ1ZyAmJiBmaXREZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkKSlcbiAgICAgICAgKyBcIiBwYW50YWxsYURvd25zY2FsZUJsb2NrZWQ9XCIgKyBTdHJpbmcoISEoZml0RGVidWcgJiYgZml0RGVidWcucGFudGFsbGFEb3duc2NhbGVCbG9ja2VkKSlcbiAgICAgICk7XG4gICAgICBpZiAoZG9taW5hbnRUZXh0KSB7XG4gICAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICAgIFwiZG9taW5hbnRUZXh0IGhTZWNSYXRpbz1cIiArIFN0cmluZyhkb21pbmFudFRleHQuaGVpZ2h0U2VjUmF0aW8pXG4gICAgICAgICAgKyBcIiBoVmlld3BvcnRSYXRpbz1cIiArIFN0cmluZyhkb21pbmFudFRleHQuaGVpZ2h0Vmlld3BvcnRSYXRpbylcbiAgICAgICAgICArIFwiIHdTZWNSYXRpbz1cIiArIFN0cmluZyhkb21pbmFudFRleHQud2lkdGhTZWNSYXRpbylcbiAgICAgICAgICArIFwiIGZvbnRTaXplPVwiICsgU3RyaW5nKGRvbWluYW50VGV4dC5mb250U2l6ZSB8fCBcIlwiKVxuICAgICAgICAgICsgXCIgbGluZUhlaWdodD1cIiArIFN0cmluZyhkb21pbmFudFRleHQubGluZUhlaWdodCB8fCBcIlwiKVxuICAgICAgICAgICsgXCIgc2FtcGxlPSdcIiArIFN0cmluZyhkb21pbmFudFRleHQudGV4dFNhbXBsZSB8fCBcIlwiKSArIFwiJ1wiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0TGluZXMucHVzaChcImRvbWluYW50VGV4dCBub25lXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdGU9MDsgdGU8dG9wRWxlbWVudHMubGVuZ3RoOyB0ZSsrKXtcbiAgICAgICAgdmFyIGUgPSB0b3BFbGVtZW50c1t0ZV07XG4gICAgICAgIGZsYXRMaW5lcy5wdXNoKFxuICAgICAgICAgIFwiZWwjXCIgKyBTdHJpbmcodGUgKyAxKVxuICAgICAgICAgICsgXCIga2luZD1cIiArIFN0cmluZyhlLmtpbmQgfHwgXCJcIilcbiAgICAgICAgICArIFwiIHdWcD1cIiArIFN0cmluZyhlLndpZHRoVmlld3BvcnRSYXRpbylcbiAgICAgICAgICArIFwiIGhWcD1cIiArIFN0cmluZyhlLmhlaWdodFZpZXdwb3J0UmF0aW8pXG4gICAgICAgICAgKyBcIiB0b3BTZWM9XCIgKyBTdHJpbmcoZS50b3BTZWNSYXRpbylcbiAgICAgICAgICArIFwiIGJvdHRvbVNlYz1cIiArIFN0cmluZyhlLmJvdHRvbVNlY1JhdGlvKVxuICAgICAgICAgICsgKGUuc2FtcGxlID8gKFwiIHNhbXBsZT0nXCIgKyBTdHJpbmcoZS5zYW1wbGUpICsgXCInXCIpIDogXCJcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGU6cGFudGFsbGE6ZmxhdFwiLCBmbGF0TGluZXMuam9pbihcIlxcXFxuXCIpKTtcblxuICAgICAgbXNsTG9nKFwic2VjdGlvbjpmaXRTY2FsZTpwYW50YWxsYVwiLCB7XG4gICAgICAgIHNlY0luZGV4OiBtZXRhICYmIE51bWJlci5pc0Zpbml0ZShtZXRhLnNlY0luZGV4KSA/IG1ldGEuc2VjSW5kZXggOiAtMSxcbiAgICAgICAgc2VjVzogK051bWJlcihzZWNSZWN0Tm93LndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHNlY0g6ICtOdW1iZXIoc2VjUmVjdE5vdy5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICB3aWR0aDogK051bWJlcih2aWV3cG9ydFcgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBoZWlnaHQ6ICtOdW1iZXIodmlld3BvcnRIIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheUNvbnRleHQ6IHtcbiAgICAgICAgICBtb2JpbGVWaWV3cG9ydDogbW9iaWxlVmlld3BvcnQsXG4gICAgICAgICAgZGVza3RvcE1vYmlsZVByZXZpZXc6IGRlc2t0b3BNb2JpbGVQcmV2aWV3LFxuICAgICAgICAgIG1vYmlsZVVBOiBtb2JpbGVVQSxcbiAgICAgICAgICBjb2Fyc2VQb2ludGVyOiBjb2Fyc2VQb2ludGVyLFxuICAgICAgICAgIHRvdWNoUG9pbnRzOiB0b3VjaFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBwcmVzZXJ2ZUJvdHRvbUdhcDogK3ByZXNlcnZlQm90dG9tR2FwLnRvRml4ZWQoMSksXG4gICAgICAgIHRvdGFsTm9kZXM6IHRvdGFsTm9kZXMsXG4gICAgICAgIGZpdE5vZGVzOiBmaXROb2Rlc0NvdW50LFxuICAgICAgICB0ZXh0Tm9kZXNBbGw6IHRleHRBbGwsXG4gICAgICAgIHRleHROb2Rlc0ZpdDogdGV4dEZpdCxcbiAgICAgICAgaWdub3JlZEJsZWVkOiBpZ25vcmVkQmxlZWQsXG4gICAgICAgIGlnbm9yZWRFeHBsaWNpdDogaWdub3JlZEV4cGxpY2l0LFxuICAgICAgICBjb3ZlcmFnZUZpdDogK2NvdmVyYWdlRml0LnRvRml4ZWQoMyksXG4gICAgICAgIGNvdmVyYWdlQWxsOiBjb3ZlcmFnZUFsbCA9PSBudWxsID8gbnVsbCA6ICtjb3ZlcmFnZUFsbC50b0ZpeGVkKDMpLFxuICAgICAgICBmaXRCb3VuZHM6IHtcbiAgICAgICAgICB3aWR0aDogK051bWJlcihib3VuZHMud2lkdGggfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBoZWlnaHQ6ICtOdW1iZXIoYm91bmRzLmhlaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgIG1heEJvdHRvbTogK051bWJlcihib3VuZHMubWF4Qm90dG9tIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgfSxcbiAgICAgICAgYWxsQm91bmRzOiBib3VuZHNBbGwgPyB7XG4gICAgICAgICAgd2lkdGg6ICtOdW1iZXIoYm91bmRzQWxsLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgaGVpZ2h0OiArTnVtYmVyKGJvdW5kc0FsbC5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBtYXhCb3R0b206ICtOdW1iZXIoYm91bmRzQWxsLm1heEJvdHRvbSB8fCAwKS50b0ZpeGVkKDEpXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBmaXREZWJ1ZzogZml0RGVidWcgPyB7XG4gICAgICAgICAgdGFyZ2V0Q292ZXJhZ2U6ICtOdW1iZXIoZml0RGVidWcudGFyZ2V0Q292ZXJhZ2UgfHwgMCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBtaW5GaWxsRm9yVXBzY2FsZTogK051bWJlcihmaXREZWJ1Zy5taW5GaWxsRm9yVXBzY2FsZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIGNvdmVyYWdlOiArTnVtYmVyKGZpdERlYnVnLmNvdmVyYWdlIHx8IDApLnRvRml4ZWQoMyksXG4gICAgICAgICAgaW5pdGlhbFNjYWxlOiArTnVtYmVyKGZpdERlYnVnLmluaXRpYWxTY2FsZSB8fCAwKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIG1heFNjYWxlQnlXaWR0aDogZml0RGVidWcubWF4U2NhbGVCeVdpZHRoID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5tYXhTY2FsZUJ5V2lkdGgpLnRvRml4ZWQoMyksXG4gICAgICAgICAgbWF4U2NhbGVCeUhlaWdodDogZml0RGVidWcubWF4U2NhbGVCeUhlaWdodCA9PSBudWxsID8gbnVsbCA6ICtOdW1iZXIoZml0RGVidWcubWF4U2NhbGVCeUhlaWdodCkudG9GaXhlZCgzKSxcbiAgICAgICAgICBzY2FsZUFmdGVyV2lkdGhDbGFtcDogZml0RGVidWcuc2NhbGVBZnRlcldpZHRoQ2xhbXAgPT0gbnVsbCA/IG51bGwgOiArTnVtYmVyKGZpdERlYnVnLnNjYWxlQWZ0ZXJXaWR0aENsYW1wKS50b0ZpeGVkKDMpLFxuICAgICAgICAgIHNjYWxlQWZ0ZXJIZWlnaHRDbGFtcDogZml0RGVidWcuc2NhbGVBZnRlckhlaWdodENsYW1wID09IG51bGwgPyBudWxsIDogK051bWJlcihmaXREZWJ1Zy5zY2FsZUFmdGVySGVpZ2h0Q2xhbXApLnRvRml4ZWQoMyksXG4gICAgICAgICAgdGlueVNocmlua1Byb3RlY3RlZDogISFmaXREZWJ1Zy50aW55U2hyaW5rUHJvdGVjdGVkLFxuICAgICAgICAgIHBhbnRhbGxhRG93bnNjYWxlQmxvY2tlZDogISFmaXREZWJ1Zy5wYW50YWxsYURvd25zY2FsZUJsb2NrZWRcbiAgICAgICAgfSA6IG51bGwsXG4gICAgICAgIGFwcGxpZWRTY2FsZTogK051bWJlcihzY2FsZSB8fCAxKS50b0ZpeGVkKDMpLFxuICAgICAgICBkb21pbmFudFRleHQ6IGRvbWluYW50VGV4dCxcbiAgICAgICAgdG9wRWxlbWVudHM6IHRvcEVsZW1lbnRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWMuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LXNjYWxlXCIsIFN0cmluZygrc2NhbGUudG9GaXhlZCgzKSkpO1xuICAgIG1zbExvZyhcInNlY3Rpb246Zml0U2NhbGVcIiwge1xuICAgICAgc2VjSW5kZXg6IG1ldGEgJiYgTnVtYmVyLmlzRmluaXRlKG1ldGEuc2VjSW5kZXgpID8gbWV0YS5zZWNJbmRleCA6IC0xLFxuICAgICAgbW9kZTogc2VjTW9kbyxcbiAgICAgIG5vZGVzOiBib3VuZHMuY291bnQsXG4gICAgICBjb3ZlcmFnZTogKyhib3VuZHMud2lkdGggLyBNYXRoLm1heCgxLCBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgMCkpLnRvRml4ZWQoMyksXG4gICAgICBib3hXOiArYm91bmRzLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICBib3hIOiArYm91bmRzLmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgc2NhbGU6ICtzY2FsZS50b0ZpeGVkKDMpLFxuICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtwcmVzZXJ2ZUJvdHRvbUdhcC50b0ZpeGVkKDEpLFxuICAgICAgc2NhbGVkQm90dG9tR2FwOiArKChwcmVzZXJ2ZUJvdHRvbUdhcCB8fCAwKSAqIHNjYWxlKS50b0ZpeGVkKDEpLFxuICAgICAgbmVlZGVkSGVpZ2h0OiBuZWVkZWRIZWlnaHRcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBuZWVkZWRIZWlnaHQ6IG5lZWRlZEhlaWdodCxcbiAgICAgIGJvdW5kczogYm91bmRzXG4gICAgfTtcbiAgfVxuYC50cmltKCk7XG59XG4iXSwibmFtZXMiOlsianNGaXRTY2FsZUJsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/index.ts":
/*!********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/index.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* reexport safe */ _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__.buildScript),\n/* harmony export */   normalizeConfig: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/config.ts\");\n/* harmony import */ var _scriptTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scriptTemplate */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\");\n// functions/src/utils/mobileSmartLayout/index.ts\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlEQUFpRDtBQUVOO0FBQ0kiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvaW5kZXgudHNcclxuZXhwb3J0IHR5cGUgeyBNb2JpbGVTbWFydExheW91dE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5leHBvcnQgeyBub3JtYWxpemVDb25maWcgfSBmcm9tIFwiLi9jb25maWdcIjtcclxuZXhwb3J0IHsgYnVpbGRTY3JpcHQgfSBmcm9tIFwiLi9zY3JpcHRUZW1wbGF0ZVwiO1xyXG4iXSwibmFtZXMiOlsibm9ybWFsaXplQ29uZmlnIiwiYnVpbGRTY3JpcHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/ordering.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsOrderingBlock: () => (/* binding */ jsOrderingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/ordering.ts\nfunction jsOrderingBlock() {\n    return '\\n  /**\\n   * Ordena CLUSTERS (no items) para lectura mobile.\\n   * Devuelve groups (array de columnas/grupos) y mode.\\n   *\\n   * - three: [colL, colC, colR]\\n   * - two:   [left, right]\\n   * - rows:  [out] (fila+left)\\n   * - one:   [sortedTop]\\n   */\\n  function orderClustersForMobile(clusters, rootW, CFG){\\n    if (!rootW || rootW <= 0) {\\n      var o = clusters.slice().sort(function(a,b){ return a.top - b.top; });\\n      return { groups: [o], mode: \"one\" };\\n    }\\n\\n    function clusterHasText(c){\\n      if (!c || !c.items || !c.items.length) return false;\\n      for (var iTxt=0; iTxt<c.items.length; iTxt++){\\n        if ((c.items[iTxt].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return true;\\n      }\\n      return false;\\n    }\\n\\n    function columnHasText(col){\\n      if (!col || !col.length) return false;\\n      for (var iCol=0; iCol<col.length; iCol++){\\n        if (clusterHasText(col[iCol])) return true;\\n      }\\n      return false;\\n    }\\n\\n    // Un cluster \"invade\" una frontera si queda partido de forma significativa\\n    // entre ambos lados de la linea divisoria.\\n    function clusterInvadesDivider(c, dividerX){\\n      if (!c) return false;\\n      var left = Number(c.left || 0);\\n      var width = Math.max(0, Number(c.width || 0));\\n      var right = left + width;\\n      if (width <= 1) return false;\\n      if (right <= dividerX || left >= dividerX) return false;\\n\\n      var partLeft = dividerX - left;\\n      var partRight = right - dividerX;\\n      var minPart = Math.min(partLeft, partRight);\\n      var minRequired = Math.max(22, width * 0.22);\\n      return minPart >= minRequired;\\n    }\\n\\n    function dividerInvasionRatio(list, dividerX){\\n      if (!list || !list.length) return 0;\\n      var invaded = 0;\\n      for (var iInv=0; iInv<list.length; iInv++){\\n        if (clusterInvadesDivider(list[iInv], dividerX)) invaded++;\\n      }\\n      return invaded / Math.max(1, list.length);\\n    }\\n\\n    // -------- 0) Intentar 3 columnas claras --------\\n    var t1 = rootW / 3;\\n    var t2 = (2 * rootW) / 3;\\n\\n    var colL = [];\\n    var colC = [];\\n    var colR = [];\\n\\n    for (var i=0;i<clusters.length;i++){\\n      var c = clusters[i];\\n      var x = c.cx;\\n      if (x < t1) colL.push(c);\\n      else if (x < t2) colC.push(c);\\n      else colR.push(c);\\n    }\\n\\n    var looksThree =\\n      (colL.length >= CFG.MIN_PER_COL_3 && colC.length >= CFG.MIN_PER_COL_3 && colR.length >= CFG.MIN_PER_COL_3);\\n    var textColsThree =\\n      (columnHasText(colL) ? 1 : 0) +\\n      (columnHasText(colC) ? 1 : 0) +\\n      (columnHasText(colR) ? 1 : 0);\\n    var hasTextSignalThree = textColsThree >= 2;\\n    mslLog(\"order:three:candidates\", {\\n      rootW: rootW,\\n      total: clusters.length,\\n      colL: colL.length,\\n      colC: colC.length,\\n      colR: colR.length,\\n      minPerCol3: CFG.MIN_PER_COL_3,\\n      textColsThree: textColsThree,\\n      hasTextSignalThree: hasTextSignalThree\\n    });\\n\\n    if (looksThree) {\\n      var cxs = [];\\n      for (var j=0;j<clusters.length;j++) cxs.push(clusters[j].cx);\\n      cxs.sort(function(a,b){ return a-b; });\\n      var p20 = percentile(cxs, 0.20);\\n      var p80 = percentile(cxs, 0.80);\\n      var spread = (p80 - p20);\\n      mslLog(\"order:three:spread\", {\\n        p20: p20,\\n        p80: p80,\\n        spread: spread,\\n        minSpread: rootW * CFG.THREE_COL_SPREAD_RATIO,\\n        pass: spread >= rootW * CFG.THREE_COL_SPREAD_RATIO\\n      });\\n      if (spread < rootW * CFG.THREE_COL_SPREAD_RATIO) looksThree = false;\\n    }\\n\\n    if (looksThree) {\\n      var invadeT1 = dividerInvasionRatio(clusters, t1);\\n      var invadeT2 = dividerInvasionRatio(clusters, t2);\\n      var invadeThree = Math.max(invadeT1, invadeT2);\\n      var invasionLimitThree = hasTextSignalThree ? 0.46 : 0.34;\\n      mslLog(\"order:three:invasion\", {\\n        t1: +t1.toFixed(1),\\n        t2: +t2.toFixed(1),\\n        invadeT1: +invadeT1.toFixed(3),\\n        invadeT2: +invadeT2.toFixed(3),\\n        invadeThree: +invadeThree.toFixed(3),\\n        limit: +invasionLimitThree.toFixed(3),\\n        hasTextSignalThree: hasTextSignalThree,\\n        pass: invadeThree <= invasionLimitThree\\n      });\\n      if (invadeThree > invasionLimitThree) looksThree = false;\\n    }\\n\\n    if (looksThree) {\\n      colL.sort(function(a,b){ return a.top - b.top; });\\n      colC.sort(function(a,b){ return a.top - b.top; });\\n      colR.sort(function(a,b){ return a.top - b.top; });\\n      return { groups: [colL, colC, colR], mode: \"three\" };\\n    }\\n\\n    // -------- 1) Intentar 2 columnas claras --------\\n    var mid = rootW / 2;\\n    var left = [];\\n    var right = [];\\n\\n    for (var k=0;k<clusters.length;k++){\\n      var c2 = clusters[k];\\n      if (c2.cx < mid) left.push(c2);\\n      else right.push(c2);\\n    }\\n\\n    var looksTwo = (left.length >= CFG.MIN_PER_COL_2 && right.length >= CFG.MIN_PER_COL_2);\\n    var hasTextSignalTwo = columnHasText(left) && columnHasText(right);\\n    mslLog(\"order:two:candidates\", {\\n      rootW: rootW,\\n      total: clusters.length,\\n      left: left.length,\\n      right: right.length,\\n      minPerCol2: CFG.MIN_PER_COL_2,\\n      hasTextSignalTwo: hasTextSignalTwo\\n    });\\n\\n    // Politica para pares (2 clusters):\\n    // - par de columnas reales => mode \"two\"\\n    // - resto de casos => mode \"one\" (fitCheck decide si reflowea)\\n    if (clusters.length === 2) {\\n      var cA = clusters[0];\\n      var cB = clusters[1];\\n\\n      function pairStats(c){\\n        var text = 0;\\n        var non = 0;\\n        var force = 0;\\n        for (var q=0; q<c.items.length; q++) {\\n          var n = c.items[q].node;\\n          if ((n.getAttribute(\"data-mobile-center\") || \"\") === \"force\") force++;\\n          if ((n.getAttribute(\"data-debug-texto\") || \"\") === \"1\") text++;\\n          else non++;\\n        }\\n        return { text: text, non: non, force: force };\\n      }\\n\\n      var sA = pairStats(cA);\\n      var sB = pairStats(cB);\\n\\n      var topDelta = Math.abs((cA.top || 0) - (cB.top || 0));\\n      var xOverlap = Math.max(0, Math.min((cA.left + cA.width), (cB.left + cB.width)) - Math.max(cA.left, cB.left));\\n      var minWPair = Math.max(1, Math.min((cA.width || 0), (cB.width || 0)));\\n      var xOverlapRatio = xOverlap / minWPair;\\n      var sideBySide = topDelta <= (CFG.ROW_TOL * 1.5) && xOverlapRatio < 0.25;\\n      var pairInvasion = dividerInvasionRatio([cA, cB], mid);\\n      var pairInvasionLimit = hasTextSignalTwo ? 0.5 : 0.34;\\n\\n      var anyForceCenter = (sA.force > 0 || sB.force > 0);\\n      var bothMixed = (sA.text > 0 && sA.non > 0 && sB.text > 0 && sB.non > 0);\\n      // Se\\xf1al robusta de \"par de columnas\":\\n      // - est\\xe1n lado a lado y pasan split left/right\\n      // - y adem\\xe1s no son simplemente 2 textos sueltos en una fila\\n      var hasColumnSignal =\\n        (sA.non > 0 || sB.non > 0) ||\\n        ((cA.items && cA.items.length > 1) || (cB.items && cB.items.length > 1));\\n\\n      if (looksTwo && sideBySide && hasColumnSignal && pairInvasion <= pairInvasionLimit) {\\n        var leftPair = (cA.cx <= cB.cx) ? [cA] : [cB];\\n        var rightPair = (cA.cx <= cB.cx) ? [cB] : [cA];\\n        mslLog(\"order:two:pairPolicy\", {\\n          mode: \"two\",\\n          reason: \"pairColumns\",\\n          topDelta: +topDelta.toFixed(1),\\n          xOverlapRatio: +xOverlapRatio.toFixed(3),\\n          hasColumnSignal: hasColumnSignal,\\n          bothMixed: bothMixed,\\n          anyForceCenter: anyForceCenter,\\n          pairInvasion: +pairInvasion.toFixed(3),\\n          pairInvasionLimit: +pairInvasionLimit.toFixed(3),\\n          lefts: [+(cA.left || 0).toFixed(1), +(cB.left || 0).toFixed(1)]\\n        });\\n        return { groups: [leftPair, rightPair], mode: \"two\" };\\n      }\\n\\n      var pair = clusters.slice().sort(function(a,b){\\n        if (Math.abs(a.top - b.top) > 0.5) return a.top - b.top;\\n        return a.left - b.left;\\n      });\\n      mslLog(\"order:two:pairPolicy\", {\\n        mode: \"one\",\\n        reason: anyForceCenter ? \"forceCenterPair\" : \"pairDefault\",\\n        topDelta: +topDelta.toFixed(1),\\n        xOverlapRatio: +xOverlapRatio.toFixed(3),\\n        sideBySide: sideBySide,\\n        bothMixed: bothMixed,\\n        anyForceCenter: anyForceCenter,\\n        pairInvasion: +pairInvasion.toFixed(3),\\n        pairInvasionLimit: +pairInvasionLimit.toFixed(3),\\n        tops: pair.map(function(c){ return +c.top.toFixed(1); }),\\n        lefts: pair.map(function(c){ return +c.left.toFixed(1); })\\n      });\\n      return { groups: [pair], mode: \"one\" };\\n    }\\n    if (looksTwo) {\\n      var cxs2 = [];\\n      for (var m=0;m<clusters.length;m++) cxs2.push(clusters[m].cx);\\n      cxs2.sort(function(a,b){ return a-b; });\\n      var p25 = percentile(cxs2, 0.25);\\n      var p75 = percentile(cxs2, 0.75);\\n      var spread2 = (p75 - p25);\\n      mslLog(\"order:two:spread\", {\\n        p25: p25,\\n        p75: p75,\\n        spread: spread2,\\n        minSpread: rootW * CFG.TWO_COL_SPREAD_RATIO,\\n        pass: spread2 >= rootW * CFG.TWO_COL_SPREAD_RATIO\\n      });\\n      if (spread2 < rootW * CFG.TWO_COL_SPREAD_RATIO) looksTwo = false;\\n    }\\n\\n    if (looksTwo) {\\n      var invadeMid = dividerInvasionRatio(clusters, mid);\\n      var invasionLimitTwo = hasTextSignalTwo ? 0.48 : 0.34;\\n      mslLog(\"order:two:invasion\", {\\n        mid: +mid.toFixed(1),\\n        invadeMid: +invadeMid.toFixed(3),\\n        limit: +invasionLimitTwo.toFixed(3),\\n        hasTextSignalTwo: hasTextSignalTwo,\\n        pass: invadeMid <= invasionLimitTwo\\n      });\\n      if (invadeMid > invasionLimitTwo) looksTwo = false;\\n    }\\n\\n    if (looksTwo) {\\n      left.sort(function(a,b){ return a.top - b.top; });\\n      right.sort(function(a,b){ return a.top - b.top; });\\n      return { groups: [left, right], mode: \"two\" };\\n    }\\n\\n    // -------- 2) Guard tardio: una sola columna visual --------\\n    // Se evalua despues de two/three para evitar falsos \"one\" cuando hay\\n    // dos columnas reales con varios clusters.\\n    if (clusters.length >= 2) {\\n      var cxsOne = clusters.map(function(c){ return c.cx; }).sort(function(a,b){ return a-b; });\\n      var medianCx = percentile(cxsOne, 0.50);\\n      var maxDevCx = 0;\\n      for (var s=0; s<clusters.length; s++) {\\n        var dev = Math.abs((clusters[s].cx || 0) - medianCx);\\n        if (dev > maxDevCx) maxDevCx = dev;\\n      }\\n\\n      var singleColMaxDev = rootW * 0.18;\\n      var looksOneCol = maxDevCx <= singleColMaxDev;\\n      mslLog(\"order:one:candidates\", {\\n        rootW: rootW,\\n        total: clusters.length,\\n        medianCx: +medianCx.toFixed(1),\\n        maxDevCx: +maxDevCx.toFixed(1),\\n        maxAllowed: +singleColMaxDev.toFixed(1),\\n        pass: looksOneCol,\\n        stage: \"postTwoThree\"\\n      });\\n\\n      if (looksOneCol) {\\n        var oneCol = clusters.slice().sort(function(a,b){ return a.top - b.top; });\\n        return { groups: [oneCol], mode: \"one\" };\\n      }\\n    }\\n\\n    // -------- 3) Fallback: filas (top) y dentro por left --------\\n    var sorted = clusters.slice().sort(function(a,b){ return a.top - b.top; });\\n\\n    var rows = [];\\n    for (var r=0;r<sorted.length;r++){\\n      var c3 = sorted[r];\\n      var placed = false;\\n\\n      for (var rr=0; rr<rows.length; rr++){\\n        var row = rows[rr];\\n        if (Math.abs(c3.top - row.top) <= CFG.ROW_TOL){\\n          row.items.push(c3);\\n          row.top = (row.top * (row.items.length - 1) + c3.top) / row.items.length;\\n          placed = true;\\n          break;\\n        }\\n      }\\n\\n      if (!placed) rows.push({ top: c3.top, items: [c3] });\\n    }\\n\\n    rows.sort(function(a,b){ return a.top - b.top; });\\n    rows.forEach(function(row){\\n      row.items.sort(function(a,b){ return a.left - b.left; });\\n    });\\n\\n    function clusterIsText(c){\\n      if (!c || !c.items || !c.items.length) return false;\\n      for (var i2=0; i2<c.items.length; i2++){\\n        if ((c.items[i2].node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\\n      }\\n      return true;\\n    }\\n\\n    var out = [];\\n    var didInterleave = false;\\n    // Caso especial: dos filas simetricas (ej. iconos arriba y textos abajo).\\n    // Reordenamos por columna: top1,bottom1,top2,bottom2,...\\n    if (rows.length === 2 && rows[0].items.length === rows[1].items.length && rows[0].items.length >= 2) {\\n      var topRow = rows[0].items.slice();\\n      var botRow = rows[1].items.slice();\\n      var topHasNonText = topRow.some(function(c){ return !clusterIsText(c); });\\n      var botMostlyText = botRow.filter(function(c){ return clusterIsText(c); }).length >= Math.ceil(botRow.length / 2);\\n\\n      if (topHasNonText && botMostlyText) {\\n        var usedBottom = {};\\n        for (var tr=0; tr<topRow.length; tr++){\\n          var a = topRow[tr];\\n          out.push(a);\\n\\n          var bestIdx = -1;\\n          var bestDist = Infinity;\\n          for (var br=0; br<botRow.length; br++){\\n            if (usedBottom[br]) continue;\\n            var b = botRow[br];\\n            var d = Math.abs((a.left || 0) - (b.left || 0));\\n            if (d < bestDist) {\\n              bestDist = d;\\n              bestIdx = br;\\n            }\\n          }\\n          if (bestIdx >= 0) {\\n            out.push(botRow[bestIdx]);\\n            usedBottom[bestIdx] = true;\\n          }\\n        }\\n        for (var br2=0; br2<botRow.length; br2++){\\n          if (!usedBottom[br2]) out.push(botRow[br2]);\\n        }\\n        didInterleave = true;\\n      }\\n    }\\n\\n    if (!didInterleave) {\\n      rows.forEach(function(row){\\n        for (var z=0; z<row.items.length; z++) out.push(row.items[z]);\\n      });\\n    }\\n    mslLog(\"order:rows:fallback\", {\\n      rows: rows.map(function(r){\\n        return {\\n          top: +r.top.toFixed(1),\\n          len: r.items.length,\\n          lefts: r.items.map(function(it){ return +it.left.toFixed(1); })\\n        };\\n      }),\\n      outLen: out.length,\\n      didInterleave: didInterleave\\n    });\\n\\n    return { groups: [out], mode: \"rows\" };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvb3JkZXJpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8saXNiQXVZUEMsSUFBSTtBQUNOIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxmdW5jdGlvbnNcXHNyY1xcdXRpbHNcXG1vYmlsZVNtYXJ0TGF5b3V0XFxvcmRlcmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmdW5jdGlvbnMvc3JjL3V0aWxzL21vYmlsZVNtYXJ0TGF5b3V0L29yZGVyaW5nLnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBqc09yZGVyaW5nQmxvY2soKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFxyXG4gIC8qKlxyXG4gICAqIE9yZGVuYSBDTFVTVEVSUyAobm8gaXRlbXMpIHBhcmEgbGVjdHVyYSBtb2JpbGUuXHJcbiAgICogRGV2dWVsdmUgZ3JvdXBzIChhcnJheSBkZSBjb2x1bW5hcy9ncnVwb3MpIHkgbW9kZS5cclxuICAgKlxyXG4gICAqIC0gdGhyZWU6IFtjb2xMLCBjb2xDLCBjb2xSXVxyXG4gICAqIC0gdHdvOiAgIFtsZWZ0LCByaWdodF1cclxuICAgKiAtIHJvd3M6ICBbb3V0XSAoZmlsYStsZWZ0KVxyXG4gICAqIC0gb25lOiAgIFtzb3J0ZWRUb3BdXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gb3JkZXJDbHVzdGVyc0Zvck1vYmlsZShjbHVzdGVycywgcm9vdFcsIENGRyl7XG4gICAgaWYgKCFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICB2YXIgbyA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtvXSwgbW9kZTogXCJvbmVcIiB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJIYXNUZXh0KGMpe1xuICAgICAgaWYgKCFjIHx8ICFjLml0ZW1zIHx8ICFjLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaVR4dD0wOyBpVHh0PGMuaXRlbXMubGVuZ3RoOyBpVHh0Kyspe1xuICAgICAgICBpZiAoKGMuaXRlbXNbaVR4dF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sdW1uSGFzVGV4dChjb2wpe1xuICAgICAgaWYgKCFjb2wgfHwgIWNvbC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGlDb2w9MDsgaUNvbDxjb2wubGVuZ3RoOyBpQ29sKyspe1xuICAgICAgICBpZiAoY2x1c3Rlckhhc1RleHQoY29sW2lDb2xdKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVW4gY2x1c3RlciBcImludmFkZVwiIHVuYSBmcm9udGVyYSBzaSBxdWVkYSBwYXJ0aWRvIGRlIGZvcm1hIHNpZ25pZmljYXRpdmFcbiAgICAvLyBlbnRyZSBhbWJvcyBsYWRvcyBkZSBsYSBsaW5lYSBkaXZpc29yaWEuXG4gICAgZnVuY3Rpb24gY2x1c3RlckludmFkZXNEaXZpZGVyKGMsIGRpdmlkZXJYKXtcbiAgICAgIGlmICghYykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGxlZnQgPSBOdW1iZXIoYy5sZWZ0IHx8IDApO1xuICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoMCwgTnVtYmVyKGMud2lkdGggfHwgMCkpO1xuICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgaWYgKHdpZHRoIDw9IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChyaWdodCA8PSBkaXZpZGVyWCB8fCBsZWZ0ID49IGRpdmlkZXJYKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBwYXJ0TGVmdCA9IGRpdmlkZXJYIC0gbGVmdDtcbiAgICAgIHZhciBwYXJ0UmlnaHQgPSByaWdodCAtIGRpdmlkZXJYO1xuICAgICAgdmFyIG1pblBhcnQgPSBNYXRoLm1pbihwYXJ0TGVmdCwgcGFydFJpZ2h0KTtcbiAgICAgIHZhciBtaW5SZXF1aXJlZCA9IE1hdGgubWF4KDIyLCB3aWR0aCAqIDAuMjIpO1xuICAgICAgcmV0dXJuIG1pblBhcnQgPj0gbWluUmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2aWRlckludmFzaW9uUmF0aW8obGlzdCwgZGl2aWRlclgpe1xuICAgICAgaWYgKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICB2YXIgaW52YWRlZCA9IDA7XG4gICAgICBmb3IgKHZhciBpSW52PTA7IGlJbnY8bGlzdC5sZW5ndGg7IGlJbnYrKyl7XG4gICAgICAgIGlmIChjbHVzdGVySW52YWRlc0RpdmlkZXIobGlzdFtpSW52XSwgZGl2aWRlclgpKSBpbnZhZGVkKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW52YWRlZCAvIE1hdGgubWF4KDEsIGxpc3QubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLSAwKSBJbnRlbnRhciAzIGNvbHVtbmFzIGNsYXJhcyAtLS0tLS0tLVxuICAgIHZhciB0MSA9IHJvb3RXIC8gMztcbiAgICB2YXIgdDIgPSAoMiAqIHJvb3RXKSAvIDM7XG5cclxuICAgIHZhciBjb2xMID0gW107XHJcbiAgICB2YXIgY29sQyA9IFtdO1xyXG4gICAgdmFyIGNvbFIgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpPTA7aTxjbHVzdGVycy5sZW5ndGg7aSsrKXtcclxuICAgICAgdmFyIGMgPSBjbHVzdGVyc1tpXTtcclxuICAgICAgdmFyIHggPSBjLmN4O1xyXG4gICAgICBpZiAoeCA8IHQxKSBjb2xMLnB1c2goYyk7XHJcbiAgICAgIGVsc2UgaWYgKHggPCB0MikgY29sQy5wdXNoKGMpO1xyXG4gICAgICBlbHNlIGNvbFIucHVzaChjKTtcclxuICAgIH1cclxuXG4gICAgdmFyIGxvb2tzVGhyZWUgPVxuICAgICAgKGNvbEwubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8zICYmIGNvbEMubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8zICYmIGNvbFIubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8zKTtcbiAgICB2YXIgdGV4dENvbHNUaHJlZSA9XG4gICAgICAoY29sdW1uSGFzVGV4dChjb2xMKSA/IDEgOiAwKSArXG4gICAgICAoY29sdW1uSGFzVGV4dChjb2xDKSA/IDEgOiAwKSArXG4gICAgICAoY29sdW1uSGFzVGV4dChjb2xSKSA/IDEgOiAwKTtcbiAgICB2YXIgaGFzVGV4dFNpZ25hbFRocmVlID0gdGV4dENvbHNUaHJlZSA+PSAyO1xuICAgIG1zbExvZyhcIm9yZGVyOnRocmVlOmNhbmRpZGF0ZXNcIiwge1xuICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgIGNvbEw6IGNvbEwubGVuZ3RoLFxuICAgICAgY29sQzogY29sQy5sZW5ndGgsXG4gICAgICBjb2xSOiBjb2xSLmxlbmd0aCxcbiAgICAgIG1pblBlckNvbDM6IENGRy5NSU5fUEVSX0NPTF8zLFxuICAgICAgdGV4dENvbHNUaHJlZTogdGV4dENvbHNUaHJlZSxcbiAgICAgIGhhc1RleHRTaWduYWxUaHJlZTogaGFzVGV4dFNpZ25hbFRocmVlXG4gICAgfSk7XG5cbiAgICBpZiAobG9va3NUaHJlZSkge1xuICAgICAgdmFyIGN4cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaj0wO2o8Y2x1c3RlcnMubGVuZ3RoO2orKykgY3hzLnB1c2goY2x1c3RlcnNbal0uY3gpO1xyXG4gICAgICBjeHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS1iOyB9KTtcclxuICAgICAgdmFyIHAyMCA9IHBlcmNlbnRpbGUoY3hzLCAwLjIwKTtcbiAgICAgIHZhciBwODAgPSBwZXJjZW50aWxlKGN4cywgMC44MCk7XG4gICAgICB2YXIgc3ByZWFkID0gKHA4MCAtIHAyMCk7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0aHJlZTpzcHJlYWRcIiwge1xuICAgICAgICBwMjA6IHAyMCxcbiAgICAgICAgcDgwOiBwODAsXG4gICAgICAgIHNwcmVhZDogc3ByZWFkLFxuICAgICAgICBtaW5TcHJlYWQ6IHJvb3RXICogQ0ZHLlRIUkVFX0NPTF9TUFJFQURfUkFUSU8sXG4gICAgICAgIHBhc3M6IHNwcmVhZCA+PSByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmIChzcHJlYWQgPCByb290VyAqIENGRy5USFJFRV9DT0xfU1BSRUFEX1JBVElPKSBsb29rc1RocmVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIHZhciBpbnZhZGVUMSA9IGRpdmlkZXJJbnZhc2lvblJhdGlvKGNsdXN0ZXJzLCB0MSk7XG4gICAgICB2YXIgaW52YWRlVDIgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgdDIpO1xuICAgICAgdmFyIGludmFkZVRocmVlID0gTWF0aC5tYXgoaW52YWRlVDEsIGludmFkZVQyKTtcbiAgICAgIHZhciBpbnZhc2lvbkxpbWl0VGhyZWUgPSBoYXNUZXh0U2lnbmFsVGhyZWUgPyAwLjQ2IDogMC4zNDtcbiAgICAgIG1zbExvZyhcIm9yZGVyOnRocmVlOmludmFzaW9uXCIsIHtcbiAgICAgICAgdDE6ICt0MS50b0ZpeGVkKDEpLFxuICAgICAgICB0MjogK3QyLnRvRml4ZWQoMSksXG4gICAgICAgIGludmFkZVQxOiAraW52YWRlVDEudG9GaXhlZCgzKSxcbiAgICAgICAgaW52YWRlVDI6ICtpbnZhZGVUMi50b0ZpeGVkKDMpLFxuICAgICAgICBpbnZhZGVUaHJlZTogK2ludmFkZVRocmVlLnRvRml4ZWQoMyksXG4gICAgICAgIGxpbWl0OiAraW52YXNpb25MaW1pdFRocmVlLnRvRml4ZWQoMyksXG4gICAgICAgIGhhc1RleHRTaWduYWxUaHJlZTogaGFzVGV4dFNpZ25hbFRocmVlLFxuICAgICAgICBwYXNzOiBpbnZhZGVUaHJlZSA8PSBpbnZhc2lvbkxpbWl0VGhyZWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludmFkZVRocmVlID4gaW52YXNpb25MaW1pdFRocmVlKSBsb29rc1RocmVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVGhyZWUpIHtcbiAgICAgIGNvbEwuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICBjb2xDLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgY29sUi5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbY29sTCwgY29sQywgY29sUl0sIG1vZGU6IFwidGhyZWVcIiB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tIDEpIEludGVudGFyIDIgY29sdW1uYXMgY2xhcmFzIC0tLS0tLS0tXG4gICAgdmFyIG1pZCA9IHJvb3RXIC8gMjtcclxuICAgIHZhciBsZWZ0ID0gW107XHJcbiAgICB2YXIgcmlnaHQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBrPTA7azxjbHVzdGVycy5sZW5ndGg7aysrKXtcbiAgICAgIHZhciBjMiA9IGNsdXN0ZXJzW2tdO1xuICAgICAgaWYgKGMyLmN4IDwgbWlkKSBsZWZ0LnB1c2goYzIpO1xuICAgICAgZWxzZSByaWdodC5wdXNoKGMyKTtcbiAgICB9XG5cbiAgICB2YXIgbG9va3NUd28gPSAobGVmdC5sZW5ndGggPj0gQ0ZHLk1JTl9QRVJfQ09MXzIgJiYgcmlnaHQubGVuZ3RoID49IENGRy5NSU5fUEVSX0NPTF8yKTtcbiAgICB2YXIgaGFzVGV4dFNpZ25hbFR3byA9IGNvbHVtbkhhc1RleHQobGVmdCkgJiYgY29sdW1uSGFzVGV4dChyaWdodCk7XG4gICAgbXNsTG9nKFwib3JkZXI6dHdvOmNhbmRpZGF0ZXNcIiwge1xuICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgIGxlZnQ6IGxlZnQubGVuZ3RoLFxuICAgICAgcmlnaHQ6IHJpZ2h0Lmxlbmd0aCxcbiAgICAgIG1pblBlckNvbDI6IENGRy5NSU5fUEVSX0NPTF8yLFxuICAgICAgaGFzVGV4dFNpZ25hbFR3bzogaGFzVGV4dFNpZ25hbFR3b1xuICAgIH0pO1xuXG4gICAgLy8gUG9saXRpY2EgcGFyYSBwYXJlcyAoMiBjbHVzdGVycyk6XG4gICAgLy8gLSBwYXIgZGUgY29sdW1uYXMgcmVhbGVzID0+IG1vZGUgXCJ0d29cIlxuICAgIC8vIC0gcmVzdG8gZGUgY2Fzb3MgPT4gbW9kZSBcIm9uZVwiIChmaXRDaGVjayBkZWNpZGUgc2kgcmVmbG93ZWEpXHJcbiAgICBpZiAoY2x1c3RlcnMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHZhciBjQSA9IGNsdXN0ZXJzWzBdO1xyXG4gICAgICB2YXIgY0IgPSBjbHVzdGVyc1sxXTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHBhaXJTdGF0cyhjKXtcclxuICAgICAgICB2YXIgdGV4dCA9IDA7XHJcbiAgICAgICAgdmFyIG5vbiA9IDA7XHJcbiAgICAgICAgdmFyIGZvcmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBxPTA7IHE8Yy5pdGVtcy5sZW5ndGg7IHErKykge1xyXG4gICAgICAgICAgdmFyIG4gPSBjLml0ZW1zW3FdLm5vZGU7XHJcbiAgICAgICAgICBpZiAoKG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIpID09PSBcImZvcmNlXCIpIGZvcmNlKys7XHJcbiAgICAgICAgICBpZiAoKG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHQrKztcclxuICAgICAgICAgIGVsc2Ugbm9uKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHRleHQ6IHRleHQsIG5vbjogbm9uLCBmb3JjZTogZm9yY2UgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNBID0gcGFpclN0YXRzKGNBKTtcclxuICAgICAgdmFyIHNCID0gcGFpclN0YXRzKGNCKTtcclxuXHJcbiAgICAgIHZhciB0b3BEZWx0YSA9IE1hdGguYWJzKChjQS50b3AgfHwgMCkgLSAoY0IudG9wIHx8IDApKTtcbiAgICAgIHZhciB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKChjQS5sZWZ0ICsgY0Eud2lkdGgpLCAoY0IubGVmdCArIGNCLndpZHRoKSkgLSBNYXRoLm1heChjQS5sZWZ0LCBjQi5sZWZ0KSk7XG4gICAgICB2YXIgbWluV1BhaXIgPSBNYXRoLm1heCgxLCBNYXRoLm1pbigoY0Eud2lkdGggfHwgMCksIChjQi53aWR0aCB8fCAwKSkpO1xuICAgICAgdmFyIHhPdmVybGFwUmF0aW8gPSB4T3ZlcmxhcCAvIG1pbldQYWlyO1xuICAgICAgdmFyIHNpZGVCeVNpZGUgPSB0b3BEZWx0YSA8PSAoQ0ZHLlJPV19UT0wgKiAxLjUpICYmIHhPdmVybGFwUmF0aW8gPCAwLjI1O1xuICAgICAgdmFyIHBhaXJJbnZhc2lvbiA9IGRpdmlkZXJJbnZhc2lvblJhdGlvKFtjQSwgY0JdLCBtaWQpO1xuICAgICAgdmFyIHBhaXJJbnZhc2lvbkxpbWl0ID0gaGFzVGV4dFNpZ25hbFR3byA/IDAuNSA6IDAuMzQ7XG5cbiAgICAgIHZhciBhbnlGb3JjZUNlbnRlciA9IChzQS5mb3JjZSA+IDAgfHwgc0IuZm9yY2UgPiAwKTtcbiAgICAgIHZhciBib3RoTWl4ZWQgPSAoc0EudGV4dCA+IDAgJiYgc0Eubm9uID4gMCAmJiBzQi50ZXh0ID4gMCAmJiBzQi5ub24gPiAwKTtcbiAgICAgIC8vIFNlw7FhbCByb2J1c3RhIGRlIFwicGFyIGRlIGNvbHVtbmFzXCI6XG4gICAgICAvLyAtIGVzdMOhbiBsYWRvIGEgbGFkbyB5IHBhc2FuIHNwbGl0IGxlZnQvcmlnaHRcbiAgICAgIC8vIC0geSBhZGVtw6FzIG5vIHNvbiBzaW1wbGVtZW50ZSAyIHRleHRvcyBzdWVsdG9zIGVuIHVuYSBmaWxhXG4gICAgICB2YXIgaGFzQ29sdW1uU2lnbmFsID1cbiAgICAgICAgKHNBLm5vbiA+IDAgfHwgc0Iubm9uID4gMCkgfHxcbiAgICAgICAgKChjQS5pdGVtcyAmJiBjQS5pdGVtcy5sZW5ndGggPiAxKSB8fCAoY0IuaXRlbXMgJiYgY0IuaXRlbXMubGVuZ3RoID4gMSkpO1xuXG4gICAgICBpZiAobG9va3NUd28gJiYgc2lkZUJ5U2lkZSAmJiBoYXNDb2x1bW5TaWduYWwgJiYgcGFpckludmFzaW9uIDw9IHBhaXJJbnZhc2lvbkxpbWl0KSB7XG4gICAgICAgIHZhciBsZWZ0UGFpciA9IChjQS5jeCA8PSBjQi5jeCkgPyBbY0FdIDogW2NCXTtcbiAgICAgICAgdmFyIHJpZ2h0UGFpciA9IChjQS5jeCA8PSBjQi5jeCkgPyBbY0JdIDogW2NBXTtcbiAgICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnBhaXJQb2xpY3lcIiwge1xuICAgICAgICAgIG1vZGU6IFwidHdvXCIsXG4gICAgICAgICAgcmVhc29uOiBcInBhaXJDb2x1bW5zXCIsXG4gICAgICAgICAgdG9wRGVsdGE6ICt0b3BEZWx0YS50b0ZpeGVkKDEpLFxuICAgICAgICAgIHhPdmVybGFwUmF0aW86ICt4T3ZlcmxhcFJhdGlvLnRvRml4ZWQoMyksXG4gICAgICAgICAgaGFzQ29sdW1uU2lnbmFsOiBoYXNDb2x1bW5TaWduYWwsXG4gICAgICAgICAgYm90aE1peGVkOiBib3RoTWl4ZWQsXG4gICAgICAgICAgYW55Rm9yY2VDZW50ZXI6IGFueUZvcmNlQ2VudGVyLFxuICAgICAgICAgIHBhaXJJbnZhc2lvbjogK3BhaXJJbnZhc2lvbi50b0ZpeGVkKDMpLFxuICAgICAgICAgIHBhaXJJbnZhc2lvbkxpbWl0OiArcGFpckludmFzaW9uTGltaXQudG9GaXhlZCgzKSxcbiAgICAgICAgICBsZWZ0czogWysoY0EubGVmdCB8fCAwKS50b0ZpeGVkKDEpLCArKGNCLmxlZnQgfHwgMCkudG9GaXhlZCgxKV1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGdyb3VwczogW2xlZnRQYWlyLCByaWdodFBhaXJdLCBtb2RlOiBcInR3b1wiIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWlyID0gY2x1c3RlcnMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGEudG9wIC0gYi50b3ApID4gMC41KSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICB9KTtcclxuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOnBhaXJQb2xpY3lcIiwge1xyXG4gICAgICAgIG1vZGU6IFwib25lXCIsXHJcbiAgICAgICAgcmVhc29uOiBhbnlGb3JjZUNlbnRlciA/IFwiZm9yY2VDZW50ZXJQYWlyXCIgOiBcInBhaXJEZWZhdWx0XCIsXHJcbiAgICAgICAgdG9wRGVsdGE6ICt0b3BEZWx0YS50b0ZpeGVkKDEpLFxyXG4gICAgICAgIHhPdmVybGFwUmF0aW86ICt4T3ZlcmxhcFJhdGlvLnRvRml4ZWQoMyksXG4gICAgICAgIHNpZGVCeVNpZGU6IHNpZGVCeVNpZGUsXG4gICAgICAgIGJvdGhNaXhlZDogYm90aE1peGVkLFxuICAgICAgICBhbnlGb3JjZUNlbnRlcjogYW55Rm9yY2VDZW50ZXIsXG4gICAgICAgIHBhaXJJbnZhc2lvbjogK3BhaXJJbnZhc2lvbi50b0ZpeGVkKDMpLFxuICAgICAgICBwYWlySW52YXNpb25MaW1pdDogK3BhaXJJbnZhc2lvbkxpbWl0LnRvRml4ZWQoMyksXG4gICAgICAgIHRvcHM6IHBhaXIubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MudG9wLnRvRml4ZWQoMSk7IH0pLFxuICAgICAgICBsZWZ0czogcGFpci5tYXAoZnVuY3Rpb24oYyl7IHJldHVybiArYy5sZWZ0LnRvRml4ZWQoMSk7IH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IGdyb3VwczogW3BhaXJdLCBtb2RlOiBcIm9uZVwiIH07XG4gICAgfVxyXG4gICAgaWYgKGxvb2tzVHdvKSB7XHJcbiAgICAgIHZhciBjeHMyID0gW107XHJcbiAgICAgIGZvciAodmFyIG09MDttPGNsdXN0ZXJzLmxlbmd0aDttKyspIGN4czIucHVzaChjbHVzdGVyc1ttXS5jeCk7XHJcbiAgICAgIGN4czIuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS1iOyB9KTtcclxuICAgICAgdmFyIHAyNSA9IHBlcmNlbnRpbGUoY3hzMiwgMC4yNSk7XG4gICAgICB2YXIgcDc1ID0gcGVyY2VudGlsZShjeHMyLCAwLjc1KTtcbiAgICAgIHZhciBzcHJlYWQyID0gKHA3NSAtIHAyNSk7XG4gICAgICBtc2xMb2coXCJvcmRlcjp0d286c3ByZWFkXCIsIHtcbiAgICAgICAgcDI1OiBwMjUsXG4gICAgICAgIHA3NTogcDc1LFxuICAgICAgICBzcHJlYWQ6IHNwcmVhZDIsXG4gICAgICAgIG1pblNwcmVhZDogcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU8sXG4gICAgICAgIHBhc3M6IHNwcmVhZDIgPj0gcm9vdFcgKiBDRkcuVFdPX0NPTF9TUFJFQURfUkFUSU9cbiAgICAgIH0pO1xuICAgICAgaWYgKHNwcmVhZDIgPCByb290VyAqIENGRy5UV09fQ09MX1NQUkVBRF9SQVRJTykgbG9va3NUd28gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobG9va3NUd28pIHtcbiAgICAgIHZhciBpbnZhZGVNaWQgPSBkaXZpZGVySW52YXNpb25SYXRpbyhjbHVzdGVycywgbWlkKTtcbiAgICAgIHZhciBpbnZhc2lvbkxpbWl0VHdvID0gaGFzVGV4dFNpZ25hbFR3byA/IDAuNDggOiAwLjM0O1xuICAgICAgbXNsTG9nKFwib3JkZXI6dHdvOmludmFzaW9uXCIsIHtcbiAgICAgICAgbWlkOiArbWlkLnRvRml4ZWQoMSksXG4gICAgICAgIGludmFkZU1pZDogK2ludmFkZU1pZC50b0ZpeGVkKDMpLFxuICAgICAgICBsaW1pdDogK2ludmFzaW9uTGltaXRUd28udG9GaXhlZCgzKSxcbiAgICAgICAgaGFzVGV4dFNpZ25hbFR3bzogaGFzVGV4dFNpZ25hbFR3byxcbiAgICAgICAgcGFzczogaW52YWRlTWlkIDw9IGludmFzaW9uTGltaXRUd29cbiAgICAgIH0pO1xuICAgICAgaWYgKGludmFkZU1pZCA+IGludmFzaW9uTGltaXRUd28pIGxvb2tzVHdvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvb2tzVHdvKSB7XG4gICAgICBsZWZ0LnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEudG9wIC0gYi50b3A7IH0pO1xuICAgICAgcmlnaHQuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICByZXR1cm4geyBncm91cHM6IFtsZWZ0LCByaWdodF0sIG1vZGU6IFwidHdvXCIgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLSAyKSBHdWFyZCB0YXJkaW86IHVuYSBzb2xhIGNvbHVtbmEgdmlzdWFsIC0tLS0tLS0tXG4gICAgLy8gU2UgZXZhbHVhIGRlc3B1ZXMgZGUgdHdvL3RocmVlIHBhcmEgZXZpdGFyIGZhbHNvcyBcIm9uZVwiIGN1YW5kbyBoYXlcbiAgICAvLyBkb3MgY29sdW1uYXMgcmVhbGVzIGNvbiB2YXJpb3MgY2x1c3RlcnMuXG4gICAgaWYgKGNsdXN0ZXJzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgY3hzT25lID0gY2x1c3RlcnMubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gYy5jeDsgfSkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS1iOyB9KTtcbiAgICAgIHZhciBtZWRpYW5DeCA9IHBlcmNlbnRpbGUoY3hzT25lLCAwLjUwKTtcbiAgICAgIHZhciBtYXhEZXZDeCA9IDA7XG4gICAgICBmb3IgKHZhciBzPTA7IHM8Y2x1c3RlcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdmFyIGRldiA9IE1hdGguYWJzKChjbHVzdGVyc1tzXS5jeCB8fCAwKSAtIG1lZGlhbkN4KTtcbiAgICAgICAgaWYgKGRldiA+IG1heERldkN4KSBtYXhEZXZDeCA9IGRldjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbmdsZUNvbE1heERldiA9IHJvb3RXICogMC4xODtcbiAgICAgIHZhciBsb29rc09uZUNvbCA9IG1heERldkN4IDw9IHNpbmdsZUNvbE1heERldjtcbiAgICAgIG1zbExvZyhcIm9yZGVyOm9uZTpjYW5kaWRhdGVzXCIsIHtcbiAgICAgICAgcm9vdFc6IHJvb3RXLFxuICAgICAgICB0b3RhbDogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBtZWRpYW5DeDogK21lZGlhbkN4LnRvRml4ZWQoMSksXG4gICAgICAgIG1heERldkN4OiArbWF4RGV2Q3gudG9GaXhlZCgxKSxcbiAgICAgICAgbWF4QWxsb3dlZDogK3NpbmdsZUNvbE1heERldi50b0ZpeGVkKDEpLFxuICAgICAgICBwYXNzOiBsb29rc09uZUNvbCxcbiAgICAgICAgc3RhZ2U6IFwicG9zdFR3b1RocmVlXCJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobG9va3NPbmVDb2wpIHtcbiAgICAgICAgdmFyIG9uZUNvbCA9IGNsdXN0ZXJzLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS50b3AgLSBiLnRvcDsgfSk7XG4gICAgICAgIHJldHVybiB7IGdyb3VwczogW29uZUNvbF0sIG1vZGU6IFwib25lXCIgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLSAzKSBGYWxsYmFjazogZmlsYXMgKHRvcCkgeSBkZW50cm8gcG9yIGxlZnQgLS0tLS0tLS1cbiAgICB2YXIgc29ydGVkID0gY2x1c3RlcnMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuXHJcbiAgICB2YXIgcm93cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgcj0wO3I8c29ydGVkLmxlbmd0aDtyKyspe1xyXG4gICAgICB2YXIgYzMgPSBzb3J0ZWRbcl07XHJcbiAgICAgIHZhciBwbGFjZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAodmFyIHJyPTA7IHJyPHJvd3MubGVuZ3RoOyBycisrKXtcclxuICAgICAgICB2YXIgcm93ID0gcm93c1tycl07XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGMzLnRvcCAtIHJvdy50b3ApIDw9IENGRy5ST1dfVE9MKXtcclxuICAgICAgICAgIHJvdy5pdGVtcy5wdXNoKGMzKTtcclxuICAgICAgICAgIHJvdy50b3AgPSAocm93LnRvcCAqIChyb3cuaXRlbXMubGVuZ3RoIC0gMSkgKyBjMy50b3ApIC8gcm93Lml0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgIHBsYWNlZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcGxhY2VkKSByb3dzLnB1c2goeyB0b3A6IGMzLnRvcCwgaXRlbXM6IFtjM10gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcm93cy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLnRvcCAtIGIudG9wOyB9KTtcclxuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpe1xyXG4gICAgICByb3cuaXRlbXMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0OyB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsdXN0ZXJJc1RleHQoYyl7XG4gICAgICBpZiAoIWMgfHwgIWMuaXRlbXMgfHwgIWMuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpMj0wOyBpMjxjLml0ZW1zLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgIGlmICgoYy5pdGVtc1tpMl0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpICE9PSBcIjFcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBkaWRJbnRlcmxlYXZlID0gZmFsc2U7XG4gICAgLy8gQ2FzbyBlc3BlY2lhbDogZG9zIGZpbGFzIHNpbWV0cmljYXMgKGVqLiBpY29ub3MgYXJyaWJhIHkgdGV4dG9zIGFiYWpvKS5cbiAgICAvLyBSZW9yZGVuYW1vcyBwb3IgY29sdW1uYTogdG9wMSxib3R0b20xLHRvcDIsYm90dG9tMiwuLi5cbiAgICBpZiAocm93cy5sZW5ndGggPT09IDIgJiYgcm93c1swXS5pdGVtcy5sZW5ndGggPT09IHJvd3NbMV0uaXRlbXMubGVuZ3RoICYmIHJvd3NbMF0uaXRlbXMubGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciB0b3BSb3cgPSByb3dzWzBdLml0ZW1zLnNsaWNlKCk7XG4gICAgICB2YXIgYm90Um93ID0gcm93c1sxXS5pdGVtcy5zbGljZSgpO1xuICAgICAgdmFyIHRvcEhhc05vblRleHQgPSB0b3BSb3cuc29tZShmdW5jdGlvbihjKXsgcmV0dXJuICFjbHVzdGVySXNUZXh0KGMpOyB9KTtcbiAgICAgIHZhciBib3RNb3N0bHlUZXh0ID0gYm90Um93LmZpbHRlcihmdW5jdGlvbihjKXsgcmV0dXJuIGNsdXN0ZXJJc1RleHQoYyk7IH0pLmxlbmd0aCA+PSBNYXRoLmNlaWwoYm90Um93Lmxlbmd0aCAvIDIpO1xuXG4gICAgICBpZiAodG9wSGFzTm9uVGV4dCAmJiBib3RNb3N0bHlUZXh0KSB7XG4gICAgICAgIHZhciB1c2VkQm90dG9tID0ge307XG4gICAgICAgIGZvciAodmFyIHRyPTA7IHRyPHRvcFJvdy5sZW5ndGg7IHRyKyspe1xuICAgICAgICAgIHZhciBhID0gdG9wUm93W3RyXTtcbiAgICAgICAgICBvdXQucHVzaChhKTtcblxuICAgICAgICAgIHZhciBiZXN0SWR4ID0gLTE7XG4gICAgICAgICAgdmFyIGJlc3REaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgZm9yICh2YXIgYnI9MDsgYnI8Ym90Um93Lmxlbmd0aDsgYnIrKyl7XG4gICAgICAgICAgICBpZiAodXNlZEJvdHRvbVticl0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGIgPSBib3RSb3dbYnJdO1xuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLmFicygoYS5sZWZ0IHx8IDApIC0gKGIubGVmdCB8fCAwKSk7XG4gICAgICAgICAgICBpZiAoZCA8IGJlc3REaXN0KSB7XG4gICAgICAgICAgICAgIGJlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgYmVzdElkeCA9IGJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmVzdElkeCA+PSAwKSB7XG4gICAgICAgICAgICBvdXQucHVzaChib3RSb3dbYmVzdElkeF0pO1xuICAgICAgICAgICAgdXNlZEJvdHRvbVtiZXN0SWR4XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGJyMj0wOyBicjI8Ym90Um93Lmxlbmd0aDsgYnIyKyspe1xuICAgICAgICAgIGlmICghdXNlZEJvdHRvbVticjJdKSBvdXQucHVzaChib3RSb3dbYnIyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlkSW50ZXJsZWF2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkaWRJbnRlcmxlYXZlKSB7XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KXtcbiAgICAgICAgZm9yICh2YXIgej0wOyB6PHJvdy5pdGVtcy5sZW5ndGg7IHorKykgb3V0LnB1c2gocm93Lml0ZW1zW3pdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtc2xMb2coXCJvcmRlcjpyb3dzOmZhbGxiYWNrXCIsIHtcbiAgICAgIHJvd3M6IHJvd3MubWFwKGZ1bmN0aW9uKHIpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogK3IudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgbGVuOiByLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0czogci5pdGVtcy5tYXAoZnVuY3Rpb24oaXQpeyByZXR1cm4gK2l0LmxlZnQudG9GaXhlZCgxKTsgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgb3V0TGVuOiBvdXQubGVuZ3RoLFxuICAgICAgZGlkSW50ZXJsZWF2ZTogZGlkSW50ZXJsZWF2ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgZ3JvdXBzOiBbb3V0XSwgbW9kZTogXCJyb3dzXCIgfTtcbiAgfVxyXG5gLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsianNPcmRlcmluZ0Jsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts":
/*!*****************************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/scriptTemplate.ts ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* binding */ buildScript)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts\");\n/* harmony import */ var _fitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitScale */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts\");\n/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordering */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts\");\n/* harmony import */ var _stacking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacking */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts\");\n// functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n\n\n\n\nfunction buildScript(cfg) {\n    if (!cfg.enabled) return \"\";\n    return '\\n<script>\\n(function(){\\n  var ENABLED = true;\\n  function readFlagFromSearch(search, name){\\n    try {\\n      if (typeof search !== \"string\" || !search) return false;\\n      var normalized = search.charAt(0) === \"?\" ? search : (\"?\" + search);\\n      var qp = new URLSearchParams(normalized);\\n      var qv = qp.get(name);\\n      return qv === \"1\" || String(qv).toLowerCase() === \"true\";\\n    } catch(_e0) {\\n      return false;\\n    }\\n  }\\n  function readDebugFlag(name){\\n    try {\\n      var search = (window.location && window.location.search) ? window.location.search : \"\";\\n      if (readFlagFromSearch(search, name)) return true;\\n    } catch(_e1) {}\\n\\n    // srcDoc sandbox suele conservar document.referrer con la URL padre.\\n    try {\\n      var referrer = (typeof document !== \"undefined\" && document.referrer) ? String(document.referrer) : \"\";\\n      if (referrer) {\\n        var refUrl = new URL(referrer);\\n        if (readFlagFromSearch(refUrl.search || \"\", name)) return true;\\n      }\\n    } catch(_eRef) {}\\n\\n    // srcDoc/about:srcdoc no suele tener querystring.\\n    try {\\n      if (window.parent && window.parent !== window && window.parent.location) {\\n        var pSearch = window.parent.location.search || \"\";\\n        if (readFlagFromSearch(pSearch, name)) return true;\\n      }\\n    } catch(_e2) {}\\n\\n    try {\\n      if (window.top && window.top !== window && window.top.location) {\\n        var tSearch = window.top.location.search || \"\";\\n        if (readFlagFromSearch(tSearch, name)) return true;\\n      }\\n    } catch(_e3) {}\\n\\n    try {\\n      var ls = window.localStorage ? window.localStorage.getItem(name) : null;\\n      if (ls === \"1\" || String(ls).toLowerCase() === \"true\") return true;\\n    } catch(_e4) {}\\n\\n    return false;\\n  }\\n  var MSL_DEBUG = readDebugFlag(\"mslDebug\");\\n  var MSL_VERBOSE = readDebugFlag(\"mslVerbose\");\\n  function dbg(label, payload){\\n    if (!MSL_DEBUG) return;\\n    if (arguments.length <= 1) {\\n      console.log(\"[MSL] \" + label);\\n      return;\\n    }\\n    if (typeof payload === \"string\") {\\n      console.log(\"[MSL] \" + label + \" \" + payload);\\n      return;\\n    }\\n    var pretty = \"\";\\n    try {\\n      pretty = JSON.stringify(payload, null, 2);\\n    } catch(e) {\\n      try { pretty = String(payload); } catch(_) { pretty = \"[unserializable]\"; }\\n    }\\n    console.log(\"[MSL] \" + label + \"\\\\n\" + pretty);\\n  }\\n  function mslLog(){\\n    if (!MSL_DEBUG) return;\\n    var args = Array.prototype.slice.call(arguments);\\n    if (!args.length) return;\\n    var label = String(args[0]);\\n    if (!MSL_VERBOSE) {\\n      var noisy = {\\n        \"section:nodeSources\": 1,\\n        \"section:baselineRestore\": 1,\\n        \"section:anchorSplit\": 1,\\n        \"section:clusters\": 1,\\n        \"order:three:candidates\": 1,\\n        \"order:three:spread\": 1,\\n        \"order:two:candidates\": 1,\\n        \"order:two:spread\": 1,\\n        \"order:one:candidates\": 1,\\n        \"order:rows:fallback\": 1\\n      };\\n      if (noisy[label]) return;\\n    }\\n    if (args.length === 1) {\\n      dbg(label);\\n      return;\\n    }\\n    if (args.length === 2) {\\n      dbg(label, args[1]);\\n      return;\\n    }\\n    dbg(label, args.slice(1));\\n  }\\n  var CFG = {\\n    MIN_GAP: '.concat(cfg.minGapPx, \",\\n    MAX_GAP: \").concat(cfg.maxGapPx, \",\\n    GAP_SCALE: \").concat(cfg.gapScale, \",\\n\\n    PAD_TOP: \").concat(cfg.paddingTopPx, \",\\n    PAD_BOT: \").concat(cfg.paddingBottomPx, \",\\n\\n    ONLY_FIXED: \").concat(cfg.onlyFixedSections ? \"true\" : \"false\", \",\\n    ONLY_WHEN_REORDERED: \").concat(cfg.onlyWhenReordered ? \"true\" : \"false\", \",\\n\\n    ROW_TOL: \").concat(cfg.rowTolPx, \",\\n\\n    TWO_COL_SPREAD_RATIO: \").concat(cfg.twoColSpreadRatio, \",\\n    MIN_PER_COL_2: \").concat(cfg.minPerColumn2, \",\\n\\n    THREE_COL_SPREAD_RATIO: \").concat(cfg.threeColSpreadRatio, \",\\n    MIN_PER_COL_3: \").concat(cfg.minPerColumn3, \",\\n\\n    FIT_MIN_SCALE: \").concat(cfg.fitMinScale, \",\\n    FIT_MAX_SCALE: \").concat(cfg.fitMaxScale, \",\\n    FIT_TARGET_WIDTH_RATIO: \").concat(cfg.fitTargetWidthRatio, \",\\n    FIT_MIN_FILL_RATIO: \").concat(cfg.fitMinFillRatio, \"\\n  };\\n\\n  \").concat((0,_dom__WEBPACK_IMPORTED_MODULE_0__.jsDomHelpersBlock)(), \"\\n\\n  \").concat((0,_ordering__WEBPACK_IMPORTED_MODULE_2__.jsOrderingBlock)(), \"\\n\\n  \").concat((0,_stacking__WEBPACK_IMPORTED_MODULE_3__.jsStackingBlock)(), \"\\n\\n  \").concat((0,_fitScale__WEBPACK_IMPORTED_MODULE_1__.jsFitScaleBlock)(), '\\n\\n  function expandFixedSection(sec, neededHeight){\\n    var currentH = sec.getBoundingClientRect().height || 0;\\n    if (neededHeight > currentH + 1) {\\n      sec.style.height = Math.ceil(neededHeight) + \"px\";\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function shouldProcessSection(sec){\\n    if(!sec) return false;\\n    if(!CFG.ONLY_FIXED) return true;\\n    var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n    return modo === \"fijo\";\\n  }\\n\\n  function restoreNodeBaseline(node){\\n    if (!node) return 0;\\n    var restored = 0;\\n\\n    if (!node.hasAttribute(\"data-msl-orig-top\")) {\\n      node.setAttribute(\"data-msl-orig-top\", node.style.top || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-left\")) {\\n      node.setAttribute(\"data-msl-orig-left\", node.style.left || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-transform\")) {\\n      node.setAttribute(\"data-msl-orig-transform\", node.style.transform || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-text-align\")) {\\n      node.setAttribute(\"data-msl-orig-text-align\", node.style.textAlign || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-transform-origin\")) {\\n      node.setAttribute(\"data-msl-orig-transform-origin\", node.style.transformOrigin || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-text-zoom\")) {\\n      node.setAttribute(\"data-msl-orig-text-zoom\", node.style.getPropertyValue(\"--text-zoom\") || \"\");\\n    }\\n\\n    var origTop = node.getAttribute(\"data-msl-orig-top\");\\n    var origLeft = node.getAttribute(\"data-msl-orig-left\");\\n    var origTransform = node.getAttribute(\"data-msl-orig-transform\");\\n    var origTextAlign = node.getAttribute(\"data-msl-orig-text-align\");\\n    var origTransformOrigin = node.getAttribute(\"data-msl-orig-transform-origin\");\\n    var origTextZoom = node.getAttribute(\"data-msl-orig-text-zoom\");\\n\\n    if (origTop != null && node.style.top !== origTop) {\\n      node.style.top = origTop;\\n      restored++;\\n    }\\n    if (origLeft != null && node.style.left !== origLeft) {\\n      node.style.left = origLeft;\\n      restored++;\\n    }\\n    if (origTransform != null && node.style.transform !== origTransform) {\\n      node.style.transform = origTransform;\\n      restored++;\\n    }\\n    if (origTextAlign != null && node.style.textAlign !== origTextAlign) {\\n      if (origTextAlign) node.style.textAlign = origTextAlign;\\n      else node.style.removeProperty(\"text-align\");\\n      restored++;\\n    }\\n    if (origTransformOrigin != null && node.style.transformOrigin !== origTransformOrigin) {\\n      if (origTransformOrigin) node.style.transformOrigin = origTransformOrigin;\\n      else node.style.removeProperty(\"transform-origin\");\\n      restored++;\\n    }\\n    if (origTextZoom != null) {\\n      var currentTextZoom = node.style.getPropertyValue(\"--text-zoom\") || \"\";\\n      if (currentTextZoom !== origTextZoom) {\\n        if (origTextZoom) node.style.setProperty(\"--text-zoom\", origTextZoom);\\n        else node.style.removeProperty(\"--text-zoom\");\\n        restored++;\\n      }\\n    }\\n\\n    node.style.right = \"auto\";\\n    node.style.marginLeft = \"0px\";\\n    return restored;\\n  }\\n\\n  function runOnce(){\\n    if(!ENABLED) return;\\n    if(!isMobile()) {\\n      Array.from(document.querySelectorAll(\".sec\")).forEach(function(sec){\\n        var content = sec.querySelector(\".sec-content\");\\n        if(!content) return;\\n        var bleed = sec.querySelector(\".sec-bleed\");\\n        resetSectionFitScale(sec, content, bleed);\\n        var nodesAllDesktop = getObjNodes(sec);\\n        for (var nd=0; nd<nodesAllDesktop.length; nd++) {\\n          restoreNodeBaseline(nodesAllDesktop[nd]);\\n        }\\n        sec.setAttribute(\"data-msl-fit-scale\", \"1\");\\n      });\\n      return;\\n    }\\n\\n    var secs = Array.from(document.querySelectorAll(\".sec\"));\\n    if(!secs.length) return;\\n\\n    secs.forEach(function(sec){\\n      var secIndex = secs.indexOf(sec);\\n      var secModo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n      var allowReflow = shouldProcessSection(sec);\\n      mslLog(\"section:start\", { secIndex: secIndex, modo: secModo, allowReflow: allowReflow });\\n\\n      var content = sec.querySelector(\".sec-content\");\\n      if(!content) return;\\n      var bleed = sec.querySelector(\".sec-bleed\");\\n      resetSectionFitScale(sec, content, bleed);\\n      var nodesAll = getObjNodes(sec);\\n\\n      var reflowElementsDump = [];\\n      function buildReflowElementsDump(items, contentWNow){\\n        if (!MSL_DEBUG) return;\\n        var list = (items || []);\\n        var maxItems = 120;\\n        var out = [];\\n        for (var iDump=0; iDump<list.length && iDump<maxItems; iDump++){\\n          var itDump = list[iDump];\\n          if (!itDump || !itDump.node) continue;\\n          var nDump = itDump.node;\\n          var textRaw = ((nDump.textContent || \"\").trim()).replace(/s+/g, \" \");\\n          var isTextDump = (nDump.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          var clsDump = (nDump.className && typeof nDump.className === \"string\") ? nDump.className : \"\";\\n          var rootZone = (nDump.closest && nDump.closest(\".sec-bleed\")) ? \"bleed\" : \"content\";\\n          out.push({\\n            i: iDump,\\n            kind: isTextDump ? \"texto\" : String((nDump.tagName || \"\").toLowerCase()),\\n            zone: rootZone,\\n            top: +Number(itDump.top || 0).toFixed(1),\\n            left: +Number(itDump.left || 0).toFixed(1),\\n            w: +Number(itDump.width || 0).toFixed(1),\\n            h: +Number(itDump.height || 0).toFixed(1),\\n            right: +Number((itDump.left || 0) + (itDump.width || 0)).toFixed(1),\\n            bottom: +Number((itDump.top || 0) + (itDump.height || 0)).toFixed(1),\\n            cx: +Number((itDump.left || 0) + ((itDump.width || 0) / 2)).toFixed(1),\\n            wRatio: contentWNow > 1 ? +Number((itDump.width || 0) / contentWNow).toFixed(3) : null,\\n            className: clsDump,\\n            mobileLayout: nDump.getAttribute(\"data-mobile-layout\") || \"\",\\n            mobileRole: nDump.getAttribute(\"data-mobile-role\") || \"\",\\n            mobileCluster: nDump.getAttribute(\"data-mobile-cluster\") || \"\",\\n            mobileClusterId: nDump.getAttribute(\"data-mobile-cluster-id\") || \"\",\\n            mobileCenter: nDump.getAttribute(\"data-mobile-center\") || \"\",\\n            mobileAlign: nDump.getAttribute(\"data-mobile-align\") || \"\",\\n            mobileFit: nDump.getAttribute(\"data-mobile-fit\") || \"\",\\n            textAlign: (nDump.style && nDump.style.textAlign) ? nDump.style.textAlign : \"\",\\n            textSample: isTextDump ? textRaw.slice(0, 90) : \"\"\\n          });\\n        }\\n        reflowElementsDump = out;\\n      }\\n\\n      function logReflowDecision(reason, extra){\\n        if (!MSL_DEBUG) return;\\n        var payload = {\\n          secIndex: secIndex,\\n          secModo: secModo,\\n          allowReflow: allowReflow,\\n          totalNodes: (nodesAll || []).length,\\n          reason: String(reason || \"\"),\\n          details: extra || {}\\n        };\\n        mslLog(\"section:reflow:decision\", payload);\\n      }\\n\\n      function finalizeSection(minNeededHeight, preserveBottomGap){\\n        var gap = Number.isFinite(preserveBottomGap) ? Math.max(0, Number(preserveBottomGap)) : 0;\\n        var fit = applySectionFitScale(\\n          sec,\\n          content,\\n          bleed,\\n          nodesAll,\\n          secModo,\\n          CFG,\\n          { secIndex: secIndex },\\n          { preserveBottomGap: gap }\\n        );\\n        var fitNeeded = (fit && Number.isFinite(fit.neededHeight)) ? Number(fit.neededHeight) : 0;\\n        var neededHeight = Math.max(Number(minNeededHeight || 0), fitNeeded);\\n        mslLog(\"section:heightFinal\", {\\n          secIndex: secIndex,\\n          mode: secModo,\\n          minNeededHeight: +Number(minNeededHeight || 0).toFixed(1),\\n          fitNeededHeight: +fitNeeded.toFixed(1),\\n          preserveBottomGap: +gap.toFixed(1),\\n          finalNeededHeight: +neededHeight.toFixed(1)\\n        });\\n        if (secModo === \"fijo\" && neededHeight > 0) {\\n          expandFixedSection(sec, neededHeight);\\n        }\\n      }\\n\\n      if(!nodesAll.length) {\\n        logReflowDecision(\"skip:noNodes\", { willApplyReflow: false });\\n        finalizeSection(0, 0);\\n        return;\\n      }\\n\\n      var debugCounts = {\\n        secIndex: secIndex,\\n        contentObj: content ? content.querySelectorAll(\".objeto\").length : 0,\\n        bleedObj: bleed ? bleed.querySelectorAll(\".objeto\").length : 0,\\n        contentAbs: content ? Array.from(content.querySelectorAll(\"*\")).filter(function(el){\\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\\n        }).length : 0,\\n        bleedAbs: bleed ? Array.from(bleed.querySelectorAll(\"*\")).filter(function(el){\\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\\n        }).length : 0\\n      };\\n      mslLog(\"section:nodeSources\", debugCounts);\\n\\n      if (MSL_VERBOSE) {\\n        mslLog(\"section:nodesAll:raw\", {\\n          secIndex: secIndex,\\n          total: nodesAll.length,\\n          nodes: nodesAll.map(function(n, i){\\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\\n            var parentCls = (n.parentElement && n.parentElement.className && typeof n.parentElement.className === \"string\")\\n              ? n.parentElement.className\\n              : \"\";\\n            return {\\n              i: i,\\n              tag: (n.tagName || \"\").toLowerCase(),\\n              cls: cls,\\n              parentCls: parentCls,\\n              top: n.style ? n.style.top : \"\",\\n              left: n.style ? n.style.left : \"\",\\n              pos: n.style ? n.style.position : \"\",\\n              text: ((n.textContent || \"\").trim()).slice(0, 40)\\n            };\\n          })\\n        });\\n        try {\\n          var flat = nodesAll.map(function(n, i){\\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\\n            var txt = ((n.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 60);\\n            return \"#\" + i\\n              + \" tag=\" + String((n.tagName || \"\").toLowerCase())\\n              + \" cls=\" + cls\\n              + \" pos=\" + (n.style ? n.style.position : \"\")\\n              + \" top=\" + (n.style ? n.style.top : \"\")\\n              + \" left=\" + (n.style ? n.style.left : \"\")\\n              + \" text=\" + txt;\\n          });\\n          mslLog(\"section:nodesAll:flat\", \"sec=\" + secIndex + \" total=\" + nodesAll.length + \" :: \" + flat.join(\" | \"));\\n        } catch(e) {}\\n      }\\n      var restoredCount = 0;\\n      nodesAll.forEach(function(node){\\n        restoredCount += restoreNodeBaseline(node);\\n      });\\n      mslLog(\"section:baselineRestore\", { secIndex: secIndex, nodes: nodesAll.length, restored: restoredCount });\\n\\n      // Rect del content (m\\xe9tricas reales)\\n      var contentRect = content.getBoundingClientRect();\\n      var contentW = contentRect.width || 0;\\n      var secCurrentH = sec.getBoundingClientRect().height || 0;\\n      var baseHeightAttr = \"data-msl-base-height\";\\n      if (!sec.hasAttribute(baseHeightAttr)) {\\n        sec.setAttribute(baseHeightAttr, String(secCurrentH));\\n      }\\n      var baseSecHeight = parseFloat(sec.getAttribute(baseHeightAttr) || \"\");\\n      if (!isFinite(baseSecHeight) || baseSecHeight <= 0) baseSecHeight = secCurrentH;\\n\\n      // items (rects) en coordenadas del content (TODOS)\\n      var itemsAll = nodesAll.map(function(node){\\n        var rc = relRect(node, content);\\n        return {\\n          node: node,\\n          top: rc.top,\\n          left: rc.left,\\n          height: rc.height,\\n          width: rc.width\\n        };\\n      });\\n      buildReflowElementsDump(itemsAll, contentW);\\n      mslLog(\"section:reflow:elements\", {\\n        secIndex: secIndex,\\n        secModo: secModo,\\n        contentW: +Number(contentW || 0).toFixed(1),\\n        total: reflowElementsDump.length,\\n        elements: reflowElementsDump\\n      });\\n      if (MSL_VERBOSE) {\\n        mslLog(\"section:itemsAll\", {\\n          secIndex: secIndex,\\n          total: itemsAll.length,\\n          items: itemsAll.map(function(it, idx){\\n            return {\\n              i: idx,\\n              kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\\n              top: +it.top.toFixed(1),\\n              left: +it.left.toFixed(1),\\n              w: +it.width.toFixed(1),\\n              h: +it.height.toFixed(1),\\n              textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\\n            };\\n          })\\n        });\\n      }\\n\\n      // Preservar el \"aire\" inferior original de la seccion tras el reflow.\\n      var maxOriginalBottom = 0;\\n      for (var ib=0; ib<itemsAll.length; ib++){\\n        var itb = itemsAll[ib];\\n        var btm = (itb.top || 0) + (itb.height || 0);\\n        if (btm > maxOriginalBottom) maxOriginalBottom = btm;\\n      }\\n      var baseBottomGap = Math.max(0, baseSecHeight - maxOriginalBottom);\\n\\n      // Si todo mide 0 (fonts no listas), reintentamos luego\\n      var anyValidAll = itemsAll.some(function(it){ return it.height > 0.5; });\\n      if(!anyValidAll) {\\n        logReflowDecision(\"skip:invalidRects\", {\\n          willApplyReflow: false,\\n          allHeightsTiny: true\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      if (!allowReflow || nodesAll.length < 2) {\\n        logReflowDecision(\"skip:notEligible\", {\\n          willApplyReflow: false,\\n          allowReflow: allowReflow,\\n          totalNodes: nodesAll.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      function detectHeroLikeCentralText(items, rootW){\\n        var out = {\\n          isHero: false,\\n          reason: \"\",\\n          textCount: 0,\\n          textColumnCount: 0,\\n          textColumns: [],\\n          singleTextColumn: false,\\n          maxTextWidthRatio: null,\\n          widthRatio: null,\\n          centerDelta: null,\\n          centerTol: null,\\n          centeredByAlign: false,\\n          centeredByGeometry: false,\\n          decorNear: 0,\\n          decorLeft: 0,\\n          decorRight: 0,\\n          decorInvadingTextColumn: 0\\n        };\\n        if (!items || !items.length || !rootW || rootW <= 0) {\\n          out.reason = \"noItemsOrWidth\";\\n          return out;\\n        }\\n\\n        var textItems = items.filter(function(it){\\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\\n          var tw = Number(it.width || 0);\\n          var th = Number(it.height || 0);\\n          return tw > 2 && th > 2;\\n        });\\n        out.textCount = textItems.length;\\n        if (!textItems.length) {\\n          out.reason = \"noText\";\\n          return out;\\n        }\\n\\n        var explicitHero = false;\\n        for (var eh=0; eh<textItems.length; eh++){\\n          var roleEh = (textItems[eh].node.getAttribute(\"data-mobile-role\") || \"\").toLowerCase();\\n          if (roleEh === \"hero\") {\\n            explicitHero = true;\\n            break;\\n          }\\n        }\\n\\n        var colTol = Math.max(18, rootW * 0.14);\\n        var textCols = [];\\n        for (var tc=0; tc<textItems.length; tc++){\\n          var txt = textItems[tc];\\n          var txtCx = Number(txt.left || 0) + Number(txt.width || 0) / 2;\\n          var attached = false;\\n          for (var cc=0; cc<textCols.length; cc++){\\n            if (Math.abs(txtCx - textCols[cc].cx) <= colTol) {\\n              var nCol = textCols[cc].count + 1;\\n              textCols[cc].cx = ((textCols[cc].cx * textCols[cc].count) + txtCx) / nCol;\\n              textCols[cc].count = nCol;\\n              textCols[cc].minLeft = Math.min(textCols[cc].minLeft, Number(txt.left || 0));\\n              textCols[cc].maxRight = Math.max(textCols[cc].maxRight, Number(txt.left || 0) + Number(txt.width || 0));\\n              textCols[cc].minTop = Math.min(textCols[cc].minTop, Number(txt.top || 0));\\n              textCols[cc].maxBottom = Math.max(textCols[cc].maxBottom, Number(txt.top || 0) + Number(txt.height || 0));\\n              attached = true;\\n              break;\\n            }\\n          }\\n          if (!attached) {\\n            textCols.push({\\n              cx: txtCx,\\n              count: 1,\\n              minLeft: Number(txt.left || 0),\\n              maxRight: Number(txt.left || 0) + Number(txt.width || 0),\\n              minTop: Number(txt.top || 0),\\n              maxBottom: Number(txt.top || 0) + Number(txt.height || 0)\\n            });\\n          }\\n        }\\n        textCols.sort(function(a,b){ return a.cx - b.cx; });\\n        out.textColumnCount = textCols.length;\\n        out.singleTextColumn = textCols.length === 1;\\n        out.textColumns = textCols.map(function(col){\\n          return {\\n            cx: +Number(col.cx || 0).toFixed(1),\\n            count: col.count,\\n            left: +Number(col.minLeft || 0).toFixed(1),\\n            right: +Number(col.maxRight || 0).toFixed(1),\\n            top: +Number(col.minTop || 0).toFixed(1),\\n            bottom: +Number(col.maxBottom || 0).toFixed(1)\\n          };\\n        });\\n        if (!out.singleTextColumn) {\\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"multiTextColumns\";\\n          out.isHero = explicitHero;\\n          return out;\\n        }\\n\\n        var centerX = rootW / 2;\\n        var textCol = textCols[0];\\n        var textCenterX = Number(textCol.cx || centerX);\\n        var centerDelta = Math.abs(textCenterX - centerX);\\n        var centerTol = Math.max(18, rootW * 0.12);\\n        out.centerDelta = +centerDelta.toFixed(1);\\n        out.centerTol = +centerTol.toFixed(1);\\n\\n        var centeredAlignCount = 0;\\n        var maxTextWidthRatio = 0;\\n        var textTop = Infinity;\\n        var textBottom = -Infinity;\\n        for (var tix=0; tix<textItems.length; tix++){\\n          var t = textItems[tix];\\n          var ta = (t.node && t.node.style && t.node.style.textAlign)\\n            ? String(t.node.style.textAlign).toLowerCase()\\n            : \"\";\\n          if (ta === \"center\") centeredAlignCount++;\\n          var wRatio = Number(t.width || 0) / Math.max(1, rootW);\\n          if (wRatio > maxTextWidthRatio) maxTextWidthRatio = wRatio;\\n          textTop = Math.min(textTop, Number(t.top || 0));\\n          textBottom = Math.max(textBottom, Number(t.top || 0) + Number(t.height || 0));\\n        }\\n        out.maxTextWidthRatio = +maxTextWidthRatio.toFixed(3);\\n        out.widthRatio = out.maxTextWidthRatio;\\n        out.centeredByAlign = centeredAlignCount >= Math.max(1, Math.ceil(textItems.length * 0.5));\\n        out.centeredByGeometry = centerDelta <= centerTol;\\n        if (!out.centeredByAlign && !out.centeredByGeometry) {\\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"singleTextColumnNotCentered\";\\n          out.isHero = explicitHero;\\n          return out;\\n        }\\n\\n        // Evita marcar como hero textos sueltos muy chicos.\\n        if (textItems.length < 2 && maxTextWidthRatio < 0.28 && !explicitHero) {\\n          out.reason = \"textTooSmall\";\\n          return out;\\n        }\\n\\n        if (!isFinite(textTop) || !isFinite(textBottom) || textBottom <= textTop) {\\n          textTop = 0;\\n          textBottom = 0;\\n        }\\n        var nearTop = textTop - Math.max(28, (textBottom - textTop) * 0.2);\\n        var nearBottom = textBottom + Math.max(36, (textBottom - textTop) * 0.35);\\n        var invadePad = Math.max(24, rootW * 0.17);\\n        var invadeLeft = textCenterX - invadePad;\\n        var invadeRight = textCenterX + invadePad;\\n\\n        var decorNear = 0;\\n        var decorLeft = 0;\\n        var decorRight = 0;\\n        var decorInvading = 0;\\n\\n        for (var iHero=0; iHero<items.length; iHero++){\\n          var it = items[iHero];\\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") continue;\\n\\n          var w = Number(it.width || 0);\\n          var h = Number(it.height || 0);\\n          if (w < 8 || h < 8) continue;\\n\\n          var top = Number(it.top || 0);\\n          var bottom = top + h;\\n          var inBand = !(bottom < nearTop || top > nearBottom);\\n          if (!inBand) continue;\\n\\n          decorNear++;\\n          var cx = Number(it.left || 0) + w / 2;\\n          if (cx < textCenterX - 8) decorLeft++;\\n          else if (cx > textCenterX + 8) decorRight++;\\n\\n          var left = Number(it.left || 0);\\n          var right = left + w;\\n          if (right > invadeLeft && left < invadeRight) decorInvading++;\\n        }\\n\\n        out.decorNear = decorNear;\\n        out.decorLeft = decorLeft;\\n        out.decorRight = decorRight;\\n        out.decorInvadingTextColumn = decorInvading;\\n\\n        var decorAround = (decorLeft > 0 && decorRight > 0) || decorNear >= 3;\\n        var centeredSingleTextColumn = out.singleTextColumn && (out.centeredByAlign || out.centeredByGeometry);\\n        out.isHero = explicitHero || centeredSingleTextColumn;\\n        out.reason = out.isHero\\n          ? (\\n            explicitHero\\n              ? \"explicitHeroRole\"\\n              : (decorInvading > 0\\n                ? \"singleCenteredTextColumnDecorInvades\"\\n                : (decorAround\\n                  ? \"singleCenteredTextColumnWithDecor\"\\n                  : \"singleCenteredTextColumn\"))\\n          )\\n          : \"noHeroSignal\";\\n        return out;\\n      }\\n\\n      function detectInlinePairNoReflow(flowItems, allItems, rootW, CFG){\\n        var out = {\\n          skip: false,\\n          reason: \"\",\\n          totalFlow: flowItems ? flowItems.length : 0,\\n          totalAll: allItems ? allItems.length : 0,\\n          rowDelta: null,\\n          rowTol: null,\\n          pairSpan: null,\\n          pairSpanRatio: null,\\n          fitsTogether: false,\\n          bothSmall: false,\\n          smallWLimit: null,\\n          smallHLimit: null,\\n          widths: [],\\n          heights: []\\n        };\\n        if (!flowItems || flowItems.length !== 2 || !allItems || allItems.length !== 2 || !rootW || rootW <= 0) {\\n          out.reason = \"notExactPair\";\\n          return out;\\n        }\\n\\n        var a = flowItems[0];\\n        var b = flowItems[1];\\n        var aW = Math.max(0, Number(a.width || 0));\\n        var bW = Math.max(0, Number(b.width || 0));\\n        var aH = Math.max(0, Number(a.height || 0));\\n        var bH = Math.max(0, Number(b.height || 0));\\n        out.widths = [+aW.toFixed(1), +bW.toFixed(1)];\\n        out.heights = [+aH.toFixed(1), +bH.toFixed(1)];\\n\\n        if (aW < 2 || bW < 2 || aH < 2 || bH < 2) {\\n          out.reason = \"invalidSizes\";\\n          return out;\\n        }\\n\\n        var rowTol = Math.max(12, Number((CFG && CFG.ROW_TOL) || 28) * 1.2);\\n        var rowDelta = Math.abs(Number(a.top || 0) - Number(b.top || 0));\\n        out.rowTol = +rowTol.toFixed(1);\\n        out.rowDelta = +rowDelta.toFixed(1);\\n        if (rowDelta > rowTol) {\\n          out.reason = \"notInlineRow\";\\n          return out;\\n        }\\n\\n        var smallWLimit = Math.max(74, rootW * 0.42);\\n        var smallHLimit = Math.max(34, rootW * 0.2);\\n        out.smallWLimit = +smallWLimit.toFixed(1);\\n        out.smallHLimit = +smallHLimit.toFixed(1);\\n        var bothSmall =\\n          aW <= smallWLimit &&\\n          bW <= smallWLimit &&\\n          aH <= smallHLimit &&\\n          bH <= smallHLimit;\\n        out.bothSmall = bothSmall;\\n        if (!bothSmall) {\\n          out.reason = \"pairNotSmall\";\\n          return out;\\n        }\\n\\n        var pairLeft = Math.min(Number(a.left || 0), Number(b.left || 0));\\n        var pairRight = Math.max(Number(a.left || 0) + aW, Number(b.left || 0) + bW);\\n        var pairSpan = Math.max(0, pairRight - pairLeft);\\n        var fitsTogether = pairSpan <= (rootW + 1);\\n        out.pairSpan = +pairSpan.toFixed(1);\\n        out.pairSpanRatio = +(pairSpan / Math.max(1, rootW)).toFixed(3);\\n        out.fitsTogether = fitsTogether;\\n\\n        if (fitsTogether) {\\n          out.skip = true;\\n          out.reason = \"smallInlinePairFits\";\\n          return out;\\n        }\\n\\n        out.reason = \"smallInlinePairOverflow\";\\n        return out;\\n      }\\n\\n      function enforceInlinePairGap(flowItems, rootEl, rootW){\\n        var out = {\\n          applied: false,\\n          reason: \"\",\\n          minGap: 6,\\n          gapBefore: null,\\n          gapAfter: null,\\n          need: null,\\n          moveLeft: 0,\\n          moveRight: 0,\\n          overflowBefore: false,\\n          overflowAfter: false\\n        };\\n        var rootPadLeft = 0;\\n        if (rootEl) {\\n          var rootCS = getComputedStyle(rootEl);\\n          rootPadLeft = parseFloat(rootCS.paddingLeft) || 0;\\n        }\\n        if (!flowItems || flowItems.length !== 2 || !rootEl || !rootW || rootW <= 0) {\\n          out.reason = \"notExactPair\";\\n          return out;\\n        }\\n\\n        var a = flowItems[0];\\n        var b = flowItems[1];\\n        if (!a || !b || !a.node || !b.node) {\\n          out.reason = \"missingNodes\";\\n          return out;\\n        }\\n\\n        var leftItem = Number(a.left || 0) <= Number(b.left || 0) ? a : b;\\n        var rightItem = (leftItem === a) ? b : a;\\n\\n        var rrL = relRect(leftItem.node, rootEl);\\n        var rrR = relRect(rightItem.node, rootEl);\\n        var lLeft = Number(rrL.left || 0);\\n        var lW = Number(rrL.width || 0);\\n        var rLeft = Number(rrR.left || 0);\\n        var rW = Number(rrR.width || 0);\\n        if (!isFinite(lLeft) || !isFinite(lW) || !isFinite(rLeft) || !isFinite(rW)) {\\n          out.reason = \"invalidRects\";\\n          return out;\\n        }\\n\\n        var gapBefore = rLeft - (lLeft + lW);\\n        out.gapBefore = +gapBefore.toFixed(2);\\n        out.overflowBefore = (lLeft < -0.5) || ((rLeft + rW) > (rootW + 0.5));\\n\\n        var need = Math.max(0, out.minGap - gapBefore);\\n        out.need = +need.toFixed(2);\\n        if (need <= 0.25) {\\n          out.reason = \"alreadySpaced\";\\n          out.gapAfter = out.gapBefore;\\n          out.overflowAfter = out.overflowBefore;\\n          return out;\\n        }\\n\\n        var availRight = Math.max(0, rootW - (rLeft + rW));\\n        var availLeft = Math.max(0, lLeft);\\n        var moveRight = Math.min(availRight, need);\\n        var remaining = Math.max(0, need - moveRight);\\n        var moveLeft = Math.min(availLeft, remaining);\\n\\n        if (moveRight <= 0.01 && moveLeft <= 0.01) {\\n          out.reason = \"noRoomToAdjust\";\\n          return out;\\n        }\\n\\n        if (moveRight > 0.01) {\\n          rightItem.node.style.left = ((Number(rightItem.left || 0) + moveRight) - rootPadLeft) + \"px\";\\n          rightItem.node.style.right = \"auto\";\\n          rightItem.node.style.marginLeft = \"0px\";\\n        }\\n        if (moveLeft > 0.01) {\\n          leftItem.node.style.left = ((Number(leftItem.left || 0) - moveLeft) - rootPadLeft) + \"px\";\\n          leftItem.node.style.right = \"auto\";\\n          leftItem.node.style.marginLeft = \"0px\";\\n        }\\n\\n        var rrL2 = relRect(leftItem.node, rootEl);\\n        var rrR2 = relRect(rightItem.node, rootEl);\\n        var lLeft2 = Number(rrL2.left || 0);\\n        var lW2 = Number(rrL2.width || 0);\\n        var rLeft2 = Number(rrR2.left || 0);\\n        var rW2 = Number(rrR2.width || 0);\\n        var gapAfter = rLeft2 - (lLeft2 + lW2);\\n\\n        out.moveRight = +moveRight.toFixed(2);\\n        out.moveLeft = +moveLeft.toFixed(2);\\n        out.gapAfter = isFinite(gapAfter) ? +gapAfter.toFixed(2) : null;\\n        out.overflowAfter = (lLeft2 < -0.5) || ((rLeft2 + rW2) > (rootW + 0.5));\\n        out.applied = (moveRight > 0.01 || moveLeft > 0.01);\\n        out.reason = out.applied ? \"applied\" : \"noChange\";\\n        if (isFinite(gapAfter) && gapAfter < -0.2) out.reason = \"appliedButStillOverlap\";\\n        return out;\\n      }\\n\\n      var prominentNonTextCount = itemsAll.filter(function(it){\\n        if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return false;\\n        var w = Number(it.width || 0);\\n        var h = Number(it.height || 0);\\n        if (w < 6 || h < 6) return false;\\n        return true;\\n      }).length;\\n      // Si hay cualquier no-texto visible, evitamos anclar textos por heuristica.\\n      // Esto impide que textos de una columna queden \"congelados\" en left original.\\n      var allowHeuristicAnchors = prominentNonTextCount === 0;\\n\\n      // ✅ Determinar qu\\xe9 nodos son \"ANCHOR\" (no se reflowean)\\n      // Regla: texto centrado + casi full-width => t\\xedtulo/hero, no mover.\\n      function isAnchorNode(it){\\n        var node = it.node;\\n\\n        // opt-out expl\\xedcito\\n        var keepLayout = (node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n        if (keepLayout) return true;\\n\\n        // anchor expl\\xedcito (si lo us\\xe1s)\\n        var role = (node.getAttribute(\"data-mobile-role\") || \"\");\\n        if (role === \"anchor\") return true;\\n\\n        // heur\\xedstica para textos\\n        var isText = (node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n        if (!isText) return false;\\n        if (!allowHeuristicAnchors) return false;\\n\\n        var ta = (node.style && node.style.textAlign) ? String(node.style.textAlign).toLowerCase() : \"\";\\n        if (!ta) {\\n          try {\\n            ta = String(getComputedStyle(node).textAlign || \"\").toLowerCase();\\n          } catch(_e) {}\\n        }\\n        if (ta !== \"center\") return false;\\n\\n        // solo si realmente ocupa casi todo el ancho usable\\n        // (esto evita romper textos centrados dentro de columnas)\\n        if (contentW > 0 && it.width >= contentW * 0.78) return true;\\n\\n        return false;\\n      }\\n\\n      // ✅ Flow = todo lo que NO es anchor\\n      var itemsFlow = itemsAll.filter(function(it){ return !isAnchorNode(it); });\\n      var itemsAnchor = itemsAll.filter(function(it){ return isAnchorNode(it); });\\n      mslLog(\"section:anchorSplit\", {\\n        secIndex: secIndex,\\n        anchors: itemsAnchor.length,\\n        flow: itemsFlow.length,\\n        prominentNonTextCount: prominentNonTextCount,\\n        allowHeuristicAnchors: allowHeuristicAnchors,\\n        anchorsDetail: itemsAnchor.map(function(it){\\n          return {\\n            kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\\n            top: +it.top.toFixed(1),\\n            left: +it.left.toFixed(1),\\n            w: +it.width.toFixed(1),\\n            h: +it.height.toFixed(1),\\n            textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\\n          };\\n        })\\n      });\\n\\n      // Si no hay suficientes elementos reflowables, no hacemos nada\\n      if(itemsFlow.length < 2) {\\n        logReflowDecision(\"skip:flowTooSmall\", {\\n          willApplyReflow: false,\\n          flowCount: itemsFlow.length,\\n          anchorCount: itemsAnchor.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      // ✅ Para que \"altura necesaria\" no quede corta,\\n      // medimos el bottom m\\xe1ximo de anchors (en coords del content)\\n      var maxAnchorBottom = 0;\\n      itemsAll.forEach(function(it){\\n        if (!isAnchorNode(it)) return;\\n        var b = (it.top || 0) + (it.height || 0);\\n        if (b > maxAnchorBottom) maxAnchorBottom = b;\\n      });\\n\\n      // ✅ 1) agrupar por solape → clusters (SOLO FLOW)\\n      var clusters = buildOverlapClusters(itemsFlow);\\n      mslLog(\"section:clusters\", {\\n        secIndex: secIndex,\\n        count: clusters.length,\\n        clusters: clusters.map(function(c, idx){\\n          return {\\n            i: idx,\\n            top: +c.top.toFixed(1),\\n            left: +c.left.toFixed(1),\\n            w: +c.width.toFixed(1),\\n            h: +c.height.toFixed(1),\\n            cx: +c.cx.toFixed(1),\\n            items: c.items.length\\n          };\\n        })\\n      });\\n\\n      // ✅ 2) Detectar columnas/rows (SOLO FLOW)\\n      var rootW = contentW || 0;\\n      var ord = orderClustersForMobile(clusters, rootW, CFG);\\n      var groups = ord.groups;\\n      var mode = ord.mode;\\n      mslLog(\"section:ordering\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        rootW: rootW,\\n        groups: groups.map(function(grp, gi){\\n          return {\\n            g: gi,\\n            count: grp.length,\\n            tops: grp.map(function(c){ return +c.top.toFixed(1); }),\\n            lefts: grp.map(function(c){ return +c.left.toFixed(1); })\\n          };\\n        })\\n      });\\n\\n      var heroSignal = detectHeroLikeCentralText(itemsAll, rootW);\\n      mslLog(\"section:heroCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        isHero: heroSignal.isHero,\\n        reason: heroSignal.reason,\\n        textCount: heroSignal.textCount,\\n        textColumnCount: heroSignal.textColumnCount,\\n        singleTextColumn: heroSignal.singleTextColumn,\\n        textColumns: heroSignal.textColumns,\\n        maxTextWidthRatio: heroSignal.maxTextWidthRatio,\\n        widthRatio: heroSignal.widthRatio,\\n        centerDelta: heroSignal.centerDelta,\\n        centerTol: heroSignal.centerTol,\\n        centeredByAlign: heroSignal.centeredByAlign,\\n        centeredByGeometry: heroSignal.centeredByGeometry,\\n        decorNear: heroSignal.decorNear,\\n        decorLeft: heroSignal.decorLeft,\\n        decorRight: heroSignal.decorRight,\\n        decorInvadingTextColumn: heroSignal.decorInvadingTextColumn\\n      });\\n      if (heroSignal.isHero) {\\n        logReflowDecision(\"skip:heroCentralText\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          heroReason: heroSignal.reason,\\n          hero: heroSignal\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      var inlinePairSignal = detectInlinePairNoReflow(itemsFlow, itemsAll, rootW, CFG);\\n      mslLog(\"section:inlinePairCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        skip: inlinePairSignal.skip,\\n        reason: inlinePairSignal.reason,\\n        totalFlow: inlinePairSignal.totalFlow,\\n        totalAll: inlinePairSignal.totalAll,\\n        rowDelta: inlinePairSignal.rowDelta,\\n        rowTol: inlinePairSignal.rowTol,\\n        widths: inlinePairSignal.widths,\\n        heights: inlinePairSignal.heights,\\n        bothSmall: inlinePairSignal.bothSmall,\\n        smallWLimit: inlinePairSignal.smallWLimit,\\n        smallHLimit: inlinePairSignal.smallHLimit,\\n        pairSpan: inlinePairSignal.pairSpan,\\n        pairSpanRatio: inlinePairSignal.pairSpanRatio,\\n        fitsTogether: inlinePairSignal.fitsTogether\\n      });\\n      if (inlinePairSignal.skip) {\\n        var inlinePairAdjust = enforceInlinePairGap(itemsFlow, content, rootW);\\n        mslLog(\"section:inlinePairAdjust\", {\\n          secIndex: secIndex,\\n          mode: mode,\\n          adjust: inlinePairAdjust\\n        });\\n        logReflowDecision(\"skip:smallInlinePairFits\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          inlinePair: inlinePairSignal,\\n          inlinePairAdjust: inlinePairAdjust\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      // ✅ 3) Gate \"mejor de ambos mundos\":\\n      // - Si es \"one\" (layout ya natural) Y adem\\xe1s entra, NO hacemos reflow.\\n      // - En cualquier otro caso (two/three/rows), hacemos reflow para lectura mobile,\\n      //   incluso aunque \"entre\".\\n      var fits = clustersFitInMobile(clusters, content);\\n      mslLog(\"section:fitCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        fits: fits,\\n        willSkip: (mode === \"one\" && fits)\\n      });\\n      if (mode === \"one\" && fits) {\\n        logReflowDecision(\"skip:modeOneFits\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          fits: fits,\\n          clusters: clusters.length,\\n          flowCount: itemsFlow.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      logReflowDecision(\"apply:modeRequiresReflow\", {\\n        willApplyReflow: true,\\n        mode: mode,\\n        fits: fits,\\n        clusters: clusters.length,\\n        flowCount: itemsFlow.length,\\n        anchorCount: itemsAnchor.length,\\n        groupSizes: groups.map(function(grp){ return grp.length; })\\n      });\\n\\n      // ✅ 4) Reflow solo sobre FLOW (preserva solapes dentro de cada cluster)\\n      var res = applyClusterStack(groups, content, CFG, mode);\\n      mslLog(\"section:applyResult\", {\\n        secIndex: secIndex,\\n        changed: !!(res && res.changed),\\n        neededHeight: res ? res.neededHeight : null,\\n        maxAnchorBottom: +maxAnchorBottom.toFixed(1),\\n        baseBottomGap: +baseBottomGap.toFixed(1)\\n      });\\n      logReflowDecision(\"postApply\", {\\n        willApplyReflow: true,\\n        changed: !!(res && res.changed),\\n        neededHeight: res ? +Number(res.neededHeight || 0).toFixed(1) : null,\\n        mode: mode\\n      });\\n\\n      var neededAfterReflow = 0;\\n      if (res && res.changed) {\\n        // Evitar que la secci\\xf3n quede chica si hay anchors m\\xe1s abajo\\n        var needed = Number(res.neededHeight || 0);\\n        if (Number(maxAnchorBottom) > 0) {\\n          // sumamos padding bottom para que no quede pegado\\n          var anchorNeeded = Math.ceil(maxAnchorBottom + (CFG.PAD_BOT || 0));\\n          if (anchorNeeded > needed) needed = anchorNeeded;\\n        }\\n        if (baseBottomGap > 0) {\\n          needed = Math.ceil(needed + baseBottomGap);\\n        }\\n        if (needed > 0) neededAfterReflow = needed;\\n      }\\n      finalizeSection(neededAfterReflow, baseBottomGap);\\n    });\\n  }\\n\\n  function boot(){\\n    mslLog(\"boot\", { cfg: CFG });\\n    runOnce();\\n    setTimeout(runOnce, 150);\\n    setTimeout(runOnce, 600);\\n    setTimeout(runOnce, 1800);\\n\\n    if(document.fonts && document.fonts.ready){\\n      document.fonts.ready.then(function(){ runOnce(); }).catch(function(){});\\n    }\\n  }\\n\\n  window.addEventListener(\"load\", boot);\\n  window.addEventListener(\"resize\", runOnce);\\n\\n  if(window.visualViewport){\\n    window.visualViewport.addEventListener(\"resize\", runOnce);\\n    window.visualViewport.addEventListener(\"scroll\", runOnce);\\n  }\\n\\n  if(document.readyState !== \"loading\") boot();\\n  else document.addEventListener(\"DOMContentLoaded\", boot);\\n})();\\n</script>\\n').trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFFaEI7QUFDRztBQUNBO0FBQ0E7QUFFdEMsU0FBU0ksWUFBWUMsR0FBcUI7SUFDL0MsSUFBSSxDQUFDQSxJQUFJQyxPQUFPLEVBQUUsT0FBTztJQUV6QixPQUFPLGtxR0F3R01ELE9BREFBLElBQUlFLFFBQVEsRUFBQyxvQkFFWEYsT0FERkEsSUFBSUcsUUFBUSxFQUFDLHNCQUdiSCxPQUZFQSxJQUFJSSxRQUFRLEVBQUMsc0JBR2ZKLE9BREFBLElBQUlLLFlBQVksRUFBQyxvQkFHZEwsT0FGSEEsSUFBSU0sZUFBZSxFQUFDLHlCQUdSTixPQURUQSxJQUFJTyxpQkFBaUIsR0FBRyxTQUFTLFNBQVEsZ0NBRzVDUCxPQUZZQSxJQUFJUSxpQkFBaUIsR0FBRyxTQUFTLFNBQVEsc0JBSXhDUixPQUZiQSxJQUFJUyxRQUFRLEVBQUMsbUNBR1BULE9BRE9BLElBQUlVLGlCQUFpQixFQUFDLDBCQUdwQlYsT0FGVEEsSUFBSVcsYUFBYSxFQUFDLHFDQUdsQlgsT0FEU0EsSUFBSVksbUJBQW1CLEVBQUMsMEJBR2pDWixPQUZBQSxJQUFJYSxhQUFhLEVBQUMsNEJBR2xCYixPQURBQSxJQUFJYyxXQUFXLEVBQUMsMEJBRVBkLE9BRFRBLElBQUllLFdBQVcsRUFBQyxtQ0FFWGYsT0FESUEsSUFBSWdCLG1CQUFtQixFQUFDLCtCQUlsRHJCLE9BSHNCSyxJQUFJaUIsZUFBZSxFQUFDLGdCQUsxQ3BCLE9BRkFGLHVEQUFpQkEsSUFBRyxVQUlwQkcsT0FGQUQsMERBQWVBLElBQUcsVUFJbEJELE9BRkFFLDBEQUFlQSxJQUFHLFVBRUEsT0FBbEJGLDBEQUFlQSxJQUFHLDRsckNBeTlCcEJzQixJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHNjcmlwdFRlbXBsYXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHNcclxuaW1wb3J0IHsgTm9ybWFsaXplZENvbmZpZyB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsganNEb21IZWxwZXJzQmxvY2sgfSBmcm9tIFwiLi9kb21cIjtcbmltcG9ydCB7IGpzRml0U2NhbGVCbG9jayB9IGZyb20gXCIuL2ZpdFNjYWxlXCI7XG5pbXBvcnQgeyBqc09yZGVyaW5nQmxvY2sgfSBmcm9tIFwiLi9vcmRlcmluZ1wiO1xuaW1wb3J0IHsganNTdGFja2luZ0Jsb2NrIH0gZnJvbSBcIi4vc3RhY2tpbmdcIjtcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTY3JpcHQoY2ZnOiBOb3JtYWxpemVkQ29uZmlnKTogc3RyaW5nIHtcclxuICBpZiAoIWNmZy5lbmFibGVkKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgcmV0dXJuIGBcbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgdmFyIEVOQUJMRUQgPSB0cnVlO1xuICBmdW5jdGlvbiByZWFkRmxhZ0Zyb21TZWFyY2goc2VhcmNoLCBuYW1lKXtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09IFwic3RyaW5nXCIgfHwgIXNlYXJjaCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IChcIj9cIiArIHNlYXJjaCk7XG4gICAgICB2YXIgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG5vcm1hbGl6ZWQpO1xuICAgICAgdmFyIHF2ID0gcXAuZ2V0KG5hbWUpO1xuICAgICAgcmV0dXJuIHF2ID09PSBcIjFcIiB8fCBTdHJpbmcocXYpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xuICAgIH0gY2F0Y2goX2UwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlYWREZWJ1Z0ZsYWcobmFtZSl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzZWFyY2ggPSAod2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpID8gd2luZG93LmxvY2F0aW9uLnNlYXJjaCA6IFwiXCI7XG4gICAgICBpZiAocmVhZEZsYWdGcm9tU2VhcmNoKHNlYXJjaCwgbmFtZSkpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goX2UxKSB7fVxuXG4gICAgLy8gc3JjRG9jIHNhbmRib3ggc3VlbGUgY29uc2VydmFyIGRvY3VtZW50LnJlZmVycmVyIGNvbiBsYSBVUkwgcGFkcmUuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZWZlcnJlciA9ICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQucmVmZXJyZXIpID8gU3RyaW5nKGRvY3VtZW50LnJlZmVycmVyKSA6IFwiXCI7XG4gICAgICBpZiAocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHJlZlVybCA9IG5ldyBVUkwocmVmZXJyZXIpO1xuICAgICAgICBpZiAocmVhZEZsYWdGcm9tU2VhcmNoKHJlZlVybC5zZWFyY2ggfHwgXCJcIiwgbmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2VSZWYpIHt9XG5cbiAgICAvLyBzcmNEb2MvYWJvdXQ6c3JjZG9jIG5vIHN1ZWxlIHRlbmVyIHF1ZXJ5c3RyaW5nLlxuICAgIHRyeSB7XG4gICAgICBpZiAod2luZG93LnBhcmVudCAmJiB3aW5kb3cucGFyZW50ICE9PSB3aW5kb3cgJiYgd2luZG93LnBhcmVudC5sb2NhdGlvbikge1xuICAgICAgICB2YXIgcFNlYXJjaCA9IHdpbmRvdy5wYXJlbnQubG9jYXRpb24uc2VhcmNoIHx8IFwiXCI7XG4gICAgICAgIGlmIChyZWFkRmxhZ0Zyb21TZWFyY2gocFNlYXJjaCwgbmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2UyKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cudG9wICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB3aW5kb3cudG9wLmxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB0U2VhcmNoID0gd2luZG93LnRvcC5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgaWYgKHJlYWRGbGFnRnJvbVNlYXJjaCh0U2VhcmNoLCBuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChfZTMpIHt9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxzID0gd2luZG93LmxvY2FsU3RvcmFnZSA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKSA6IG51bGw7XG4gICAgICBpZiAobHMgPT09IFwiMVwiIHx8IFN0cmluZyhscykudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goX2U0KSB7fVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBNU0xfREVCVUcgPSByZWFkRGVidWdGbGFnKFwibXNsRGVidWdcIik7XG4gIHZhciBNU0xfVkVSQk9TRSA9IHJlYWREZWJ1Z0ZsYWcoXCJtc2xWZXJib3NlXCIpO1xuICBmdW5jdGlvbiBkYmcobGFiZWwsIHBheWxvYWQpe1xuICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltNU0xdIFwiICsgbGFiZWwgKyBcIiBcIiArIHBheWxvYWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldHR5ID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgcHJldHR5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgbnVsbCwgMik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0cnkgeyBwcmV0dHkgPSBTdHJpbmcocGF5bG9hZCk7IH0gY2F0Y2goXykgeyBwcmV0dHkgPSBcIlt1bnNlcmlhbGl6YWJsZV1cIjsgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIltNU0xdIFwiICsgbGFiZWwgKyBcIlxcXFxuXCIgKyBwcmV0dHkpO1xuICB9XG4gIGZ1bmN0aW9uIG1zbExvZygpe1xuICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgbGFiZWwgPSBTdHJpbmcoYXJnc1swXSk7XG4gICAgaWYgKCFNU0xfVkVSQk9TRSkge1xuICAgICAgdmFyIG5vaXN5ID0ge1xuICAgICAgICBcInNlY3Rpb246bm9kZVNvdXJjZXNcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmJhc2VsaW5lUmVzdG9yZVwiOiAxLFxuICAgICAgICBcInNlY3Rpb246YW5jaG9yU3BsaXRcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmNsdXN0ZXJzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6dGhyZWU6Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnRocmVlOnNwcmVhZFwiOiAxLFxuICAgICAgICBcIm9yZGVyOnR3bzpjYW5kaWRhdGVzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6dHdvOnNwcmVhZFwiOiAxLFxuICAgICAgICBcIm9yZGVyOm9uZTpjYW5kaWRhdGVzXCI6IDEsXG4gICAgICAgIFwib3JkZXI6cm93czpmYWxsYmFja1wiOiAxXG4gICAgICB9O1xuICAgICAgaWYgKG5vaXN5W2xhYmVsXSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRiZyhsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgZGJnKGxhYmVsLCBhcmdzWzFdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGJnKGxhYmVsLCBhcmdzLnNsaWNlKDEpKTtcbiAgfVxuICB2YXIgQ0ZHID0ge1xuICAgIE1JTl9HQVA6ICR7Y2ZnLm1pbkdhcFB4fSxcclxuICAgIE1BWF9HQVA6ICR7Y2ZnLm1heEdhcFB4fSxcclxuICAgIEdBUF9TQ0FMRTogJHtjZmcuZ2FwU2NhbGV9LFxyXG5cclxuICAgIFBBRF9UT1A6ICR7Y2ZnLnBhZGRpbmdUb3BQeH0sXHJcbiAgICBQQURfQk9UOiAke2NmZy5wYWRkaW5nQm90dG9tUHh9LFxyXG5cclxuICAgIE9OTFlfRklYRUQ6ICR7Y2ZnLm9ubHlGaXhlZFNlY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9LFxyXG4gICAgT05MWV9XSEVOX1JFT1JERVJFRDogJHtjZmcub25seVdoZW5SZW9yZGVyZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIn0sXHJcblxyXG4gICAgUk9XX1RPTDogJHtjZmcucm93VG9sUHh9LFxyXG5cclxuICAgIFRXT19DT0xfU1BSRUFEX1JBVElPOiAke2NmZy50d29Db2xTcHJlYWRSYXRpb30sXHJcbiAgICBNSU5fUEVSX0NPTF8yOiAke2NmZy5taW5QZXJDb2x1bW4yfSxcclxuXHJcbiAgICBUSFJFRV9DT0xfU1BSRUFEX1JBVElPOiAke2NmZy50aHJlZUNvbFNwcmVhZFJhdGlvfSxcbiAgICBNSU5fUEVSX0NPTF8zOiAke2NmZy5taW5QZXJDb2x1bW4zfSxcblxuICAgIEZJVF9NSU5fU0NBTEU6ICR7Y2ZnLmZpdE1pblNjYWxlfSxcbiAgICBGSVRfTUFYX1NDQUxFOiAke2NmZy5maXRNYXhTY2FsZX0sXG4gICAgRklUX1RBUkdFVF9XSURUSF9SQVRJTzogJHtjZmcuZml0VGFyZ2V0V2lkdGhSYXRpb30sXG4gICAgRklUX01JTl9GSUxMX1JBVElPOiAke2NmZy5maXRNaW5GaWxsUmF0aW99XG4gIH07XG5cclxuICAke2pzRG9tSGVscGVyc0Jsb2NrKCl9XHJcblxyXG4gICR7anNPcmRlcmluZ0Jsb2NrKCl9XHJcblxyXG4gICR7anNTdGFja2luZ0Jsb2NrKCl9XG5cbiAgJHtqc0ZpdFNjYWxlQmxvY2soKX1cblxyXG4gIGZ1bmN0aW9uIGV4cGFuZEZpeGVkU2VjdGlvbihzZWMsIG5lZWRlZEhlaWdodCl7XHJcbiAgICB2YXIgY3VycmVudEggPSBzZWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IDA7XHJcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEggKyAxKSB7XHJcbiAgICAgIHNlYy5zdHlsZS5oZWlnaHQgPSBNYXRoLmNlaWwobmVlZGVkSGVpZ2h0KSArIFwicHhcIjtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzaG91bGRQcm9jZXNzU2VjdGlvbihzZWMpe1xuICAgIGlmKCFzZWMpIHJldHVybiBmYWxzZTtcbiAgICBpZighQ0ZHLk9OTFlfRklYRUQpIHJldHVybiB0cnVlO1xuICAgIHZhciBtb2RvID0gKHNlYy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZG9cIikgfHwgXCJmaWpvXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1vZG8gPT09IFwiZmlqb1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZU5vZGVCYXNlbGluZShub2RlKXtcbiAgICBpZiAoIW5vZGUpIHJldHVybiAwO1xuICAgIHZhciByZXN0b3JlZCA9IDA7XG5cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIiwgbm9kZS5zdHlsZS50b3AgfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLWxlZnRcIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIsIG5vZGUuc3R5bGUubGVmdCB8fCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIsIG5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LWFsaWduXCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdGV4dC1hbGlnblwiLCBub2RlLnN0eWxlLnRleHRBbGlnbiB8fCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtLW9yaWdpblwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybS1vcmlnaW5cIiwgbm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtem9vbVwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtem9vbVwiLCBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLXRleHQtem9vbVwiKSB8fCBcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ1RvcCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10b3BcIik7XG4gICAgdmFyIG9yaWdMZWZ0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLWxlZnRcIik7XG4gICAgdmFyIG9yaWdUcmFuc2Zvcm0gPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtXCIpO1xuICAgIHZhciBvcmlnVGV4dEFsaWduID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtYWxpZ25cIik7XG4gICAgdmFyIG9yaWdUcmFuc2Zvcm1PcmlnaW4gPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdHJhbnNmb3JtLW9yaWdpblwiKTtcbiAgICB2YXIgb3JpZ1RleHRab29tID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtem9vbVwiKTtcblxuICAgIGlmIChvcmlnVG9wICE9IG51bGwgJiYgbm9kZS5zdHlsZS50b3AgIT09IG9yaWdUb3ApIHtcbiAgICAgIG5vZGUuc3R5bGUudG9wID0gb3JpZ1RvcDtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnTGVmdCAhPSBudWxsICYmIG5vZGUuc3R5bGUubGVmdCAhPT0gb3JpZ0xlZnQpIHtcbiAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG9yaWdMZWZ0O1xuICAgICAgcmVzdG9yZWQrKztcbiAgICB9XG4gICAgaWYgKG9yaWdUcmFuc2Zvcm0gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRyYW5zZm9ybSAhPT0gb3JpZ1RyYW5zZm9ybSkge1xuICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBvcmlnVHJhbnNmb3JtO1xuICAgICAgcmVzdG9yZWQrKztcbiAgICB9XG4gICAgaWYgKG9yaWdUZXh0QWxpZ24gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRleHRBbGlnbiAhPT0gb3JpZ1RleHRBbGlnbikge1xuICAgICAgaWYgKG9yaWdUZXh0QWxpZ24pIG5vZGUuc3R5bGUudGV4dEFsaWduID0gb3JpZ1RleHRBbGlnbjtcbiAgICAgIGVsc2Ugbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRleHQtYWxpZ25cIik7XG4gICAgICByZXN0b3JlZCsrO1xuICAgIH1cbiAgICBpZiAob3JpZ1RyYW5zZm9ybU9yaWdpbiAhPSBudWxsICYmIG5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luICE9PSBvcmlnVHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICBpZiAob3JpZ1RyYW5zZm9ybU9yaWdpbikgbm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnVHJhbnNmb3JtT3JpZ2luO1xuICAgICAgZWxzZSBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidHJhbnNmb3JtLW9yaWdpblwiKTtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnVGV4dFpvb20gIT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRUZXh0Wm9vbSA9IG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tdGV4dC16b29tXCIpIHx8IFwiXCI7XG4gICAgICBpZiAoY3VycmVudFRleHRab29tICE9PSBvcmlnVGV4dFpvb20pIHtcbiAgICAgICAgaWYgKG9yaWdUZXh0Wm9vbSkgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIG9yaWdUZXh0Wm9vbSk7XG4gICAgICAgIGVsc2Ugbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIpO1xuICAgICAgICByZXN0b3JlZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgIHJldHVybiByZXN0b3JlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bk9uY2UoKXtcbiAgICBpZighRU5BQkxFRCkgcmV0dXJuO1xuICAgIGlmKCFpc01vYmlsZSgpKSB7XG4gICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VjXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKHNlYyl7XG4gICAgICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XG4gICAgICAgIGlmKCFjb250ZW50KSByZXR1cm47XG4gICAgICAgIHZhciBibGVlZCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1ibGVlZFwiKTtcbiAgICAgICAgcmVzZXRTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCk7XG4gICAgICAgIHZhciBub2Rlc0FsbERlc2t0b3AgPSBnZXRPYmpOb2RlcyhzZWMpO1xuICAgICAgICBmb3IgKHZhciBuZD0wOyBuZDxub2Rlc0FsbERlc2t0b3AubGVuZ3RoOyBuZCsrKSB7XG4gICAgICAgICAgcmVzdG9yZU5vZGVCYXNlbGluZShub2Rlc0FsbERlc2t0b3BbbmRdKTtcbiAgICAgICAgfVxuICAgICAgICBzZWMuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtZml0LXNjYWxlXCIsIFwiMVwiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxyXG4gICAgdmFyIHNlY3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2VjXCIpKTtcclxuICAgIGlmKCFzZWNzLmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgIHNlY3MuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgdmFyIHNlY0luZGV4ID0gc2Vjcy5pbmRleE9mKHNlYyk7XG4gICAgICB2YXIgc2VjTW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGFsbG93UmVmbG93ID0gc2hvdWxkUHJvY2Vzc1NlY3Rpb24oc2VjKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246c3RhcnRcIiwgeyBzZWNJbmRleDogc2VjSW5kZXgsIG1vZG86IHNlY01vZG8sIGFsbG93UmVmbG93OiBhbGxvd1JlZmxvdyB9KTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtY29udGVudFwiKTtcbiAgICAgIGlmKCFjb250ZW50KSByZXR1cm47XG4gICAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XG4gICAgICByZXNldFNlY3Rpb25GaXRTY2FsZShzZWMsIGNvbnRlbnQsIGJsZWVkKTtcbiAgICAgIHZhciBub2Rlc0FsbCA9IGdldE9iak5vZGVzKHNlYyk7XG5cbiAgICAgIHZhciByZWZsb3dFbGVtZW50c0R1bXAgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGJ1aWxkUmVmbG93RWxlbWVudHNEdW1wKGl0ZW1zLCBjb250ZW50V05vdyl7XG4gICAgICAgIGlmICghTVNMX0RFQlVHKSByZXR1cm47XG4gICAgICAgIHZhciBsaXN0ID0gKGl0ZW1zIHx8IFtdKTtcbiAgICAgICAgdmFyIG1heEl0ZW1zID0gMTIwO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAodmFyIGlEdW1wPTA7IGlEdW1wPGxpc3QubGVuZ3RoICYmIGlEdW1wPG1heEl0ZW1zOyBpRHVtcCsrKXtcbiAgICAgICAgICB2YXIgaXREdW1wID0gbGlzdFtpRHVtcF07XG4gICAgICAgICAgaWYgKCFpdER1bXAgfHwgIWl0RHVtcC5ub2RlKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgbkR1bXAgPSBpdER1bXAubm9kZTtcbiAgICAgICAgICB2YXIgdGV4dFJhdyA9ICgobkR1bXAudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgICAgICB2YXIgaXNUZXh0RHVtcCA9IChuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcbiAgICAgICAgICB2YXIgY2xzRHVtcCA9IChuRHVtcC5jbGFzc05hbWUgJiYgdHlwZW9mIG5EdW1wLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikgPyBuRHVtcC5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgIHZhciByb290Wm9uZSA9IChuRHVtcC5jbG9zZXN0ICYmIG5EdW1wLmNsb3Nlc3QoXCIuc2VjLWJsZWVkXCIpKSA/IFwiYmxlZWRcIiA6IFwiY29udGVudFwiO1xuICAgICAgICAgIG91dC5wdXNoKHtcbiAgICAgICAgICAgIGk6IGlEdW1wLFxuICAgICAgICAgICAga2luZDogaXNUZXh0RHVtcCA/IFwidGV4dG9cIiA6IFN0cmluZygobkR1bXAudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAgIHpvbmU6IHJvb3Rab25lLFxuICAgICAgICAgICAgdG9wOiArTnVtYmVyKGl0RHVtcC50b3AgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtOdW1iZXIoaXREdW1wLmxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtOdW1iZXIoaXREdW1wLndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiArTnVtYmVyKGl0RHVtcC5oZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHJpZ2h0OiArTnVtYmVyKChpdER1bXAubGVmdCB8fCAwKSArIChpdER1bXAud2lkdGggfHwgMCkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBib3R0b206ICtOdW1iZXIoKGl0RHVtcC50b3AgfHwgMCkgKyAoaXREdW1wLmhlaWdodCB8fCAwKSkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGN4OiArTnVtYmVyKChpdER1bXAubGVmdCB8fCAwKSArICgoaXREdW1wLndpZHRoIHx8IDApIC8gMikpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3UmF0aW86IGNvbnRlbnRXTm93ID4gMSA/ICtOdW1iZXIoKGl0RHVtcC53aWR0aCB8fCAwKSAvIGNvbnRlbnRXTm93KS50b0ZpeGVkKDMpIDogbnVsbCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzRHVtcCxcbiAgICAgICAgICAgIG1vYmlsZUxheW91dDogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVSb2xlOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDbHVzdGVyOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDbHVzdGVySWQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNsdXN0ZXItaWRcIikgfHwgXCJcIixcbiAgICAgICAgICAgIG1vYmlsZUNlbnRlcjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVBbGlnbjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIixcbiAgICAgICAgICAgIG1vYmlsZUZpdDogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtZml0XCIpIHx8IFwiXCIsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IChuRHVtcC5zdHlsZSAmJiBuRHVtcC5zdHlsZS50ZXh0QWxpZ24pID8gbkR1bXAuc3R5bGUudGV4dEFsaWduIDogXCJcIixcbiAgICAgICAgICAgIHRleHRTYW1wbGU6IGlzVGV4dER1bXAgPyB0ZXh0UmF3LnNsaWNlKDAsIDkwKSA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZWZsb3dFbGVtZW50c0R1bXAgPSBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvZ1JlZmxvd0RlY2lzaW9uKHJlYXNvbiwgZXh0cmEpe1xuICAgICAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgc2VjTW9kbzogc2VjTW9kbyxcbiAgICAgICAgICBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3csXG4gICAgICAgICAgdG90YWxOb2RlczogKG5vZGVzQWxsIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgICAgcmVhc29uOiBTdHJpbmcocmVhc29uIHx8IFwiXCIpLFxuICAgICAgICAgIGRldGFpbHM6IGV4dHJhIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246cmVmbG93OmRlY2lzaW9uXCIsIHBheWxvYWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNlY3Rpb24obWluTmVlZGVkSGVpZ2h0LCBwcmVzZXJ2ZUJvdHRvbUdhcCl7XG4gICAgICAgIHZhciBnYXAgPSBOdW1iZXIuaXNGaW5pdGUocHJlc2VydmVCb3R0b21HYXApID8gTWF0aC5tYXgoMCwgTnVtYmVyKHByZXNlcnZlQm90dG9tR2FwKSkgOiAwO1xuICAgICAgICB2YXIgZml0ID0gYXBwbHlTZWN0aW9uRml0U2NhbGUoXG4gICAgICAgICAgc2VjLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgYmxlZWQsXG4gICAgICAgICAgbm9kZXNBbGwsXG4gICAgICAgICAgc2VjTW9kbyxcbiAgICAgICAgICBDRkcsXG4gICAgICAgICAgeyBzZWNJbmRleDogc2VjSW5kZXggfSxcbiAgICAgICAgICB7IHByZXNlcnZlQm90dG9tR2FwOiBnYXAgfVxuICAgICAgICApO1xuICAgICAgICB2YXIgZml0TmVlZGVkID0gKGZpdCAmJiBOdW1iZXIuaXNGaW5pdGUoZml0Lm5lZWRlZEhlaWdodCkpID8gTnVtYmVyKGZpdC5uZWVkZWRIZWlnaHQpIDogMDtcbiAgICAgICAgdmFyIG5lZWRlZEhlaWdodCA9IE1hdGgubWF4KE51bWJlcihtaW5OZWVkZWRIZWlnaHQgfHwgMCksIGZpdE5lZWRlZCk7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246aGVpZ2h0RmluYWxcIiwge1xuICAgICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgICBtb2RlOiBzZWNNb2RvLFxuICAgICAgICAgIG1pbk5lZWRlZEhlaWdodDogK051bWJlcihtaW5OZWVkZWRIZWlnaHQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICBmaXROZWVkZWRIZWlnaHQ6ICtmaXROZWVkZWQudG9GaXhlZCgxKSxcbiAgICAgICAgICBwcmVzZXJ2ZUJvdHRvbUdhcDogK2dhcC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGZpbmFsTmVlZGVkSGVpZ2h0OiArbmVlZGVkSGVpZ2h0LnRvRml4ZWQoMSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWNNb2RvID09PSBcImZpam9cIiAmJiBuZWVkZWRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgZXhwYW5kRml4ZWRTZWN0aW9uKHNlYywgbmVlZGVkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZighbm9kZXNBbGwubGVuZ3RoKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpub05vZGVzXCIsIHsgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWJ1Z0NvdW50cyA9IHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjb250ZW50T2JqOiBjb250ZW50ID8gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKS5sZW5ndGggOiAwLFxuICAgICAgICBibGVlZE9iajogYmxlZWQgPyBibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiLm9iamV0b1wiKS5sZW5ndGggOiAwLFxuICAgICAgICBjb250ZW50QWJzOiBjb250ZW50ID8gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5maWx0ZXIoZnVuY3Rpb24oZWwpe1xuICAgICAgICAgIHJldHVybiAhIShlbCAmJiBlbC5zdHlsZSAmJiAoZWwuc3R5bGUucG9zaXRpb24gfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJhYnNvbHV0ZVwiICYmIGVsLnN0eWxlLnRvcCAmJiBlbC5zdHlsZS5sZWZ0KTtcbiAgICAgICAgfSkubGVuZ3RoIDogMCxcbiAgICAgICAgYmxlZWRBYnM6IGJsZWVkID8gQXJyYXkuZnJvbShibGVlZC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYWJzb2x1dGVcIiAmJiBlbC5zdHlsZS50b3AgJiYgZWwuc3R5bGUubGVmdCk7XG4gICAgICAgIH0pLmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVTb3VyY2VzXCIsIGRlYnVnQ291bnRzKTtcblxuICAgICAgaWYgKE1TTF9WRVJCT1NFKSB7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246bm9kZXNBbGw6cmF3XCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgdG90YWw6IG5vZGVzQWxsLmxlbmd0aCxcbiAgICAgICAgICBub2Rlczogbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG4sIGkpe1xuICAgICAgICAgICAgdmFyIGNscyA9IChuLmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbi5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhcmVudENscyA9IChuLnBhcmVudEVsZW1lbnQgJiYgbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgPyBuLnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIHRhZzogKG4udGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICBjbHM6IGNscyxcbiAgICAgICAgICAgICAgcGFyZW50Q2xzOiBwYXJlbnRDbHMsXG4gICAgICAgICAgICAgIHRvcDogbi5zdHlsZSA/IG4uc3R5bGUudG9wIDogXCJcIixcbiAgICAgICAgICAgICAgbGVmdDogbi5zdHlsZSA/IG4uc3R5bGUubGVmdCA6IFwiXCIsXG4gICAgICAgICAgICAgIHBvczogbi5zdHlsZSA/IG4uc3R5bGUucG9zaXRpb24gOiBcIlwiLFxuICAgICAgICAgICAgICB0ZXh0OiAoKG4udGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKS5zbGljZSgwLCA0MClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGZsYXQgPSBub2Rlc0FsbC5tYXAoZnVuY3Rpb24obiwgaSl7XG4gICAgICAgICAgICB2YXIgY2xzID0gKG4uY2xhc3NOYW1lICYmIHR5cGVvZiBuLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikgPyBuLmNsYXNzTmFtZSA6IFwiXCI7XG4gICAgICAgICAgICB2YXIgdHh0ID0gKChuLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxcXHMrL2csIFwiIFwiKS5zbGljZSgwLCA2MCk7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBpXG4gICAgICAgICAgICAgICsgXCIgdGFnPVwiICsgU3RyaW5nKChuLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgKyBcIiBjbHM9XCIgKyBjbHNcbiAgICAgICAgICAgICAgKyBcIiBwb3M9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUucG9zaXRpb24gOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIHRvcD1cIiArIChuLnN0eWxlID8gbi5zdHlsZS50b3AgOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIGxlZnQ9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUubGVmdCA6IFwiXCIpXG4gICAgICAgICAgICAgICsgXCIgdGV4dD1cIiArIHR4dDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVzQWxsOmZsYXRcIiwgXCJzZWM9XCIgKyBzZWNJbmRleCArIFwiIHRvdGFsPVwiICsgbm9kZXNBbGwubGVuZ3RoICsgXCIgOjogXCIgKyBmbGF0LmpvaW4oXCIgfCBcIikpO1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdG9yZWRDb3VudCA9IDA7XG4gICAgICBub2Rlc0FsbC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICByZXN0b3JlZENvdW50ICs9IHJlc3RvcmVOb2RlQmFzZWxpbmUobm9kZSk7XG4gICAgICB9KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246YmFzZWxpbmVSZXN0b3JlXCIsIHsgc2VjSW5kZXg6IHNlY0luZGV4LCBub2Rlczogbm9kZXNBbGwubGVuZ3RoLCByZXN0b3JlZDogcmVzdG9yZWRDb3VudCB9KTtcblxuICAgICAgLy8gUmVjdCBkZWwgY29udGVudCAobcOpdHJpY2FzIHJlYWxlcylcbiAgICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY29udGVudFcgPSBjb250ZW50UmVjdC53aWR0aCB8fCAwO1xuICAgICAgdmFyIHNlY0N1cnJlbnRIID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCAwO1xuICAgICAgdmFyIGJhc2VIZWlnaHRBdHRyID0gXCJkYXRhLW1zbC1iYXNlLWhlaWdodFwiO1xuICAgICAgaWYgKCFzZWMuaGFzQXR0cmlidXRlKGJhc2VIZWlnaHRBdHRyKSkge1xuICAgICAgICBzZWMuc2V0QXR0cmlidXRlKGJhc2VIZWlnaHRBdHRyLCBTdHJpbmcoc2VjQ3VycmVudEgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlU2VjSGVpZ2h0ID0gcGFyc2VGbG9hdChzZWMuZ2V0QXR0cmlidXRlKGJhc2VIZWlnaHRBdHRyKSB8fCBcIlwiKTtcbiAgICAgIGlmICghaXNGaW5pdGUoYmFzZVNlY0hlaWdodCkgfHwgYmFzZVNlY0hlaWdodCA8PSAwKSBiYXNlU2VjSGVpZ2h0ID0gc2VjQ3VycmVudEg7XG5cclxuICAgICAgLy8gaXRlbXMgKHJlY3RzKSBlbiBjb29yZGVuYWRhcyBkZWwgY29udGVudCAoVE9ET1MpXHJcbiAgICAgIHZhciBpdGVtc0FsbCA9IG5vZGVzQWxsLm1hcChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIHJjID0gcmVsUmVjdChub2RlLCBjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIHRvcDogcmMudG9wLFxuICAgICAgICAgIGxlZnQ6IHJjLmxlZnQsXHJcbiAgICAgICAgICBoZWlnaHQ6IHJjLmhlaWdodCxcclxuICAgICAgICAgIHdpZHRoOiByYy53aWR0aFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBidWlsZFJlZmxvd0VsZW1lbnRzRHVtcChpdGVtc0FsbCwgY29udGVudFcpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpyZWZsb3c6ZWxlbWVudHNcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIHNlY01vZG86IHNlY01vZG8sXG4gICAgICAgIGNvbnRlbnRXOiArTnVtYmVyKGNvbnRlbnRXIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgIHRvdGFsOiByZWZsb3dFbGVtZW50c0R1bXAubGVuZ3RoLFxuICAgICAgICBlbGVtZW50czogcmVmbG93RWxlbWVudHNEdW1wXG4gICAgICB9KTtcbiAgICAgIGlmIChNU0xfVkVSQk9TRSkge1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOml0ZW1zQWxsXCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgdG90YWw6IGl0ZW1zQWxsLmxlbmd0aCxcbiAgICAgICAgICBpdGVtczogaXRlbXNBbGwubWFwKGZ1bmN0aW9uKGl0LCBpZHgpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaTogaWR4LFxuICAgICAgICAgICAgICBraW5kOiAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIiA/IFwidGV4dG9cIiA6IChpdC5ub2RlLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgdG9wOiAraXQudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGxlZnQ6ICtpdC5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIHc6ICtpdC53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBoOiAraXQuaGVpZ2h0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogKGl0Lm5vZGUuc3R5bGUgJiYgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24pID8gaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gOiBcIlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVzZXJ2YXIgZWwgXCJhaXJlXCIgaW5mZXJpb3Igb3JpZ2luYWwgZGUgbGEgc2VjY2lvbiB0cmFzIGVsIHJlZmxvdy5cbiAgICAgIHZhciBtYXhPcmlnaW5hbEJvdHRvbSA9IDA7XG4gICAgICBmb3IgKHZhciBpYj0wOyBpYjxpdGVtc0FsbC5sZW5ndGg7IGliKyspe1xuICAgICAgICB2YXIgaXRiID0gaXRlbXNBbGxbaWJdO1xuICAgICAgICB2YXIgYnRtID0gKGl0Yi50b3AgfHwgMCkgKyAoaXRiLmhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKGJ0bSA+IG1heE9yaWdpbmFsQm90dG9tKSBtYXhPcmlnaW5hbEJvdHRvbSA9IGJ0bTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlQm90dG9tR2FwID0gTWF0aC5tYXgoMCwgYmFzZVNlY0hlaWdodCAtIG1heE9yaWdpbmFsQm90dG9tKTtcblxuICAgICAgLy8gU2kgdG9kbyBtaWRlIDAgKGZvbnRzIG5vIGxpc3RhcyksIHJlaW50ZW50YW1vcyBsdWVnb1xuICAgICAgdmFyIGFueVZhbGlkQWxsID0gaXRlbXNBbGwuc29tZShmdW5jdGlvbihpdCl7IHJldHVybiBpdC5oZWlnaHQgPiAwLjU7IH0pO1xuICAgICAgaWYoIWFueVZhbGlkQWxsKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDppbnZhbGlkUmVjdHNcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgYWxsSGVpZ2h0c1Rpbnk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFsbG93UmVmbG93IHx8IG5vZGVzQWxsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOm5vdEVsaWdpYmxlXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGFsbG93UmVmbG93OiBhbGxvd1JlZmxvdyxcbiAgICAgICAgICB0b3RhbE5vZGVzOiBub2Rlc0FsbC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXRlY3RIZXJvTGlrZUNlbnRyYWxUZXh0KGl0ZW1zLCByb290Vyl7XG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgaXNIZXJvOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgdGV4dENvdW50OiAwLFxuICAgICAgICAgIHRleHRDb2x1bW5Db3VudDogMCxcbiAgICAgICAgICB0ZXh0Q29sdW1uczogW10sXG4gICAgICAgICAgc2luZ2xlVGV4dENvbHVtbjogZmFsc2UsXG4gICAgICAgICAgbWF4VGV4dFdpZHRoUmF0aW86IG51bGwsXG4gICAgICAgICAgd2lkdGhSYXRpbzogbnVsbCxcbiAgICAgICAgICBjZW50ZXJEZWx0YTogbnVsbCxcbiAgICAgICAgICBjZW50ZXJUb2w6IG51bGwsXG4gICAgICAgICAgY2VudGVyZWRCeUFsaWduOiBmYWxzZSxcbiAgICAgICAgICBjZW50ZXJlZEJ5R2VvbWV0cnk6IGZhbHNlLFxuICAgICAgICAgIGRlY29yTmVhcjogMCxcbiAgICAgICAgICBkZWNvckxlZnQ6IDAsXG4gICAgICAgICAgZGVjb3JSaWdodDogMCxcbiAgICAgICAgICBkZWNvckludmFkaW5nVGV4dENvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggfHwgIXJvb3RXIHx8IHJvb3RXIDw9IDApIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub0l0ZW1zT3JXaWR0aFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dEl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICBpZiAoKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB2YXIgdHcgPSBOdW1iZXIoaXQud2lkdGggfHwgMCk7XG4gICAgICAgICAgdmFyIHRoID0gTnVtYmVyKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgICByZXR1cm4gdHcgPiAyICYmIHRoID4gMjtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dC50ZXh0Q291bnQgPSB0ZXh0SXRlbXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXRleHRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub1RleHRcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGxpY2l0SGVybyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBlaD0wOyBlaDx0ZXh0SXRlbXMubGVuZ3RoOyBlaCsrKXtcbiAgICAgICAgICB2YXIgcm9sZUVoID0gKHRleHRJdGVtc1tlaF0ubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHJvbGVFaCA9PT0gXCJoZXJvXCIpIHtcbiAgICAgICAgICAgIGV4cGxpY2l0SGVybyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sVG9sID0gTWF0aC5tYXgoMTgsIHJvb3RXICogMC4xNCk7XG4gICAgICAgIHZhciB0ZXh0Q29scyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB0Yz0wOyB0Yzx0ZXh0SXRlbXMubGVuZ3RoOyB0YysrKXtcbiAgICAgICAgICB2YXIgdHh0ID0gdGV4dEl0ZW1zW3RjXTtcbiAgICAgICAgICB2YXIgdHh0Q3ggPSBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICB2YXIgYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBjYz0wOyBjYzx0ZXh0Q29scy5sZW5ndGg7IGNjKyspe1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHR4dEN4IC0gdGV4dENvbHNbY2NdLmN4KSA8PSBjb2xUb2wpIHtcbiAgICAgICAgICAgICAgdmFyIG5Db2wgPSB0ZXh0Q29sc1tjY10uY291bnQgKyAxO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10uY3ggPSAoKHRleHRDb2xzW2NjXS5jeCAqIHRleHRDb2xzW2NjXS5jb3VudCkgKyB0eHRDeCkgLyBuQ29sO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10uY291bnQgPSBuQ29sO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWluTGVmdCA9IE1hdGgubWluKHRleHRDb2xzW2NjXS5taW5MZWZ0LCBOdW1iZXIodHh0LmxlZnQgfHwgMCkpO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWF4UmlnaHQgPSBNYXRoLm1heCh0ZXh0Q29sc1tjY10ubWF4UmlnaHQsIE51bWJlcih0eHQubGVmdCB8fCAwKSArIE51bWJlcih0eHQud2lkdGggfHwgMCkpO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWluVG9wID0gTWF0aC5taW4odGV4dENvbHNbY2NdLm1pblRvcCwgTnVtYmVyKHR4dC50b3AgfHwgMCkpO1xuICAgICAgICAgICAgICB0ZXh0Q29sc1tjY10ubWF4Qm90dG9tID0gTWF0aC5tYXgodGV4dENvbHNbY2NdLm1heEJvdHRvbSwgTnVtYmVyKHR4dC50b3AgfHwgMCkgKyBOdW1iZXIodHh0LmhlaWdodCB8fCAwKSk7XG4gICAgICAgICAgICAgIGF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRleHRDb2xzLnB1c2goe1xuICAgICAgICAgICAgICBjeDogdHh0Q3gsXG4gICAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgICBtaW5MZWZ0OiBOdW1iZXIodHh0LmxlZnQgfHwgMCksXG4gICAgICAgICAgICAgIG1heFJpZ2h0OiBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApLFxuICAgICAgICAgICAgICBtaW5Ub3A6IE51bWJlcih0eHQudG9wIHx8IDApLFxuICAgICAgICAgICAgICBtYXhCb3R0b206IE51bWJlcih0eHQudG9wIHx8IDApICsgTnVtYmVyKHR4dC5oZWlnaHQgfHwgMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0Q29scy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhLmN4IC0gYi5jeDsgfSk7XG4gICAgICAgIG91dC50ZXh0Q29sdW1uQ291bnQgPSB0ZXh0Q29scy5sZW5ndGg7XG4gICAgICAgIG91dC5zaW5nbGVUZXh0Q29sdW1uID0gdGV4dENvbHMubGVuZ3RoID09PSAxO1xuICAgICAgICBvdXQudGV4dENvbHVtbnMgPSB0ZXh0Q29scy5tYXAoZnVuY3Rpb24oY29sKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3g6ICtOdW1iZXIoY29sLmN4IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjb3VudDogY29sLmNvdW50LFxuICAgICAgICAgICAgbGVmdDogK051bWJlcihjb2wubWluTGVmdCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgcmlnaHQ6ICtOdW1iZXIoY29sLm1heFJpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB0b3A6ICtOdW1iZXIoY29sLm1pblRvcCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgYm90dG9tOiArTnVtYmVyKGNvbC5tYXhCb3R0b20gfHwgMCkudG9GaXhlZCgxKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW91dC5zaW5nbGVUZXh0Q29sdW1uKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IGV4cGxpY2l0SGVybyA/IFwiZXhwbGljaXRIZXJvUm9sZVwiIDogXCJtdWx0aVRleHRDb2x1bW5zXCI7XG4gICAgICAgICAgb3V0LmlzSGVybyA9IGV4cGxpY2l0SGVybztcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlclggPSByb290VyAvIDI7XG4gICAgICAgIHZhciB0ZXh0Q29sID0gdGV4dENvbHNbMF07XG4gICAgICAgIHZhciB0ZXh0Q2VudGVyWCA9IE51bWJlcih0ZXh0Q29sLmN4IHx8IGNlbnRlclgpO1xuICAgICAgICB2YXIgY2VudGVyRGVsdGEgPSBNYXRoLmFicyh0ZXh0Q2VudGVyWCAtIGNlbnRlclgpO1xuICAgICAgICB2YXIgY2VudGVyVG9sID0gTWF0aC5tYXgoMTgsIHJvb3RXICogMC4xMik7XG4gICAgICAgIG91dC5jZW50ZXJEZWx0YSA9ICtjZW50ZXJEZWx0YS50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQuY2VudGVyVG9sID0gK2NlbnRlclRvbC50b0ZpeGVkKDEpO1xuXG4gICAgICAgIHZhciBjZW50ZXJlZEFsaWduQ291bnQgPSAwO1xuICAgICAgICB2YXIgbWF4VGV4dFdpZHRoUmF0aW8gPSAwO1xuICAgICAgICB2YXIgdGV4dFRvcCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgdGV4dEJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgdGl4PTA7IHRpeDx0ZXh0SXRlbXMubGVuZ3RoOyB0aXgrKyl7XG4gICAgICAgICAgdmFyIHQgPSB0ZXh0SXRlbXNbdGl4XTtcbiAgICAgICAgICB2YXIgdGEgPSAodC5ub2RlICYmIHQubm9kZS5zdHlsZSAmJiB0Lm5vZGUuc3R5bGUudGV4dEFsaWduKVxuICAgICAgICAgICAgPyBTdHJpbmcodC5ub2RlLnN0eWxlLnRleHRBbGlnbikudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgIGlmICh0YSA9PT0gXCJjZW50ZXJcIikgY2VudGVyZWRBbGlnbkNvdW50Kys7XG4gICAgICAgICAgdmFyIHdSYXRpbyA9IE51bWJlcih0LndpZHRoIHx8IDApIC8gTWF0aC5tYXgoMSwgcm9vdFcpO1xuICAgICAgICAgIGlmICh3UmF0aW8gPiBtYXhUZXh0V2lkdGhSYXRpbykgbWF4VGV4dFdpZHRoUmF0aW8gPSB3UmF0aW87XG4gICAgICAgICAgdGV4dFRvcCA9IE1hdGgubWluKHRleHRUb3AsIE51bWJlcih0LnRvcCB8fCAwKSk7XG4gICAgICAgICAgdGV4dEJvdHRvbSA9IE1hdGgubWF4KHRleHRCb3R0b20sIE51bWJlcih0LnRvcCB8fCAwKSArIE51bWJlcih0LmhlaWdodCB8fCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0Lm1heFRleHRXaWR0aFJhdGlvID0gK21heFRleHRXaWR0aFJhdGlvLnRvRml4ZWQoMyk7XG4gICAgICAgIG91dC53aWR0aFJhdGlvID0gb3V0Lm1heFRleHRXaWR0aFJhdGlvO1xuICAgICAgICBvdXQuY2VudGVyZWRCeUFsaWduID0gY2VudGVyZWRBbGlnbkNvdW50ID49IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0ZXh0SXRlbXMubGVuZ3RoICogMC41KSk7XG4gICAgICAgIG91dC5jZW50ZXJlZEJ5R2VvbWV0cnkgPSBjZW50ZXJEZWx0YSA8PSBjZW50ZXJUb2w7XG4gICAgICAgIGlmICghb3V0LmNlbnRlcmVkQnlBbGlnbiAmJiAhb3V0LmNlbnRlcmVkQnlHZW9tZXRyeSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBleHBsaWNpdEhlcm8gPyBcImV4cGxpY2l0SGVyb1JvbGVcIiA6IFwic2luZ2xlVGV4dENvbHVtbk5vdENlbnRlcmVkXCI7XG4gICAgICAgICAgb3V0LmlzSGVybyA9IGV4cGxpY2l0SGVybztcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZpdGEgbWFyY2FyIGNvbW8gaGVybyB0ZXh0b3Mgc3VlbHRvcyBtdXkgY2hpY29zLlxuICAgICAgICBpZiAodGV4dEl0ZW1zLmxlbmd0aCA8IDIgJiYgbWF4VGV4dFdpZHRoUmF0aW8gPCAwLjI4ICYmICFleHBsaWNpdEhlcm8pIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJ0ZXh0VG9vU21hbGxcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh0ZXh0VG9wKSB8fCAhaXNGaW5pdGUodGV4dEJvdHRvbSkgfHwgdGV4dEJvdHRvbSA8PSB0ZXh0VG9wKSB7XG4gICAgICAgICAgdGV4dFRvcCA9IDA7XG4gICAgICAgICAgdGV4dEJvdHRvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJUb3AgPSB0ZXh0VG9wIC0gTWF0aC5tYXgoMjgsICh0ZXh0Qm90dG9tIC0gdGV4dFRvcCkgKiAwLjIpO1xuICAgICAgICB2YXIgbmVhckJvdHRvbSA9IHRleHRCb3R0b20gKyBNYXRoLm1heCgzNiwgKHRleHRCb3R0b20gLSB0ZXh0VG9wKSAqIDAuMzUpO1xuICAgICAgICB2YXIgaW52YWRlUGFkID0gTWF0aC5tYXgoMjQsIHJvb3RXICogMC4xNyk7XG4gICAgICAgIHZhciBpbnZhZGVMZWZ0ID0gdGV4dENlbnRlclggLSBpbnZhZGVQYWQ7XG4gICAgICAgIHZhciBpbnZhZGVSaWdodCA9IHRleHRDZW50ZXJYICsgaW52YWRlUGFkO1xuXG4gICAgICAgIHZhciBkZWNvck5lYXIgPSAwO1xuICAgICAgICB2YXIgZGVjb3JMZWZ0ID0gMDtcbiAgICAgICAgdmFyIGRlY29yUmlnaHQgPSAwO1xuICAgICAgICB2YXIgZGVjb3JJbnZhZGluZyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaUhlcm89MDsgaUhlcm88aXRlbXMubGVuZ3RoOyBpSGVybysrKXtcbiAgICAgICAgICB2YXIgaXQgPSBpdGVtc1tpSGVyb107XG4gICAgICAgICAgaWYgKChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciB3ID0gTnVtYmVyKGl0LndpZHRoIHx8IDApO1xuICAgICAgICAgIHZhciBoID0gTnVtYmVyKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgICBpZiAodyA8IDggfHwgaCA8IDgpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgdmFyIHRvcCA9IE51bWJlcihpdC50b3AgfHwgMCk7XG4gICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGg7XG4gICAgICAgICAgdmFyIGluQmFuZCA9ICEoYm90dG9tIDwgbmVhclRvcCB8fCB0b3AgPiBuZWFyQm90dG9tKTtcbiAgICAgICAgICBpZiAoIWluQmFuZCkgY29udGludWU7XG5cbiAgICAgICAgICBkZWNvck5lYXIrKztcbiAgICAgICAgICB2YXIgY3ggPSBOdW1iZXIoaXQubGVmdCB8fCAwKSArIHcgLyAyO1xuICAgICAgICAgIGlmIChjeCA8IHRleHRDZW50ZXJYIC0gOCkgZGVjb3JMZWZ0Kys7XG4gICAgICAgICAgZWxzZSBpZiAoY3ggPiB0ZXh0Q2VudGVyWCArIDgpIGRlY29yUmlnaHQrKztcblxuICAgICAgICAgIHZhciBsZWZ0ID0gTnVtYmVyKGl0LmxlZnQgfHwgMCk7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHc7XG4gICAgICAgICAgaWYgKHJpZ2h0ID4gaW52YWRlTGVmdCAmJiBsZWZ0IDwgaW52YWRlUmlnaHQpIGRlY29ySW52YWRpbmcrKztcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5kZWNvck5lYXIgPSBkZWNvck5lYXI7XG4gICAgICAgIG91dC5kZWNvckxlZnQgPSBkZWNvckxlZnQ7XG4gICAgICAgIG91dC5kZWNvclJpZ2h0ID0gZGVjb3JSaWdodDtcbiAgICAgICAgb3V0LmRlY29ySW52YWRpbmdUZXh0Q29sdW1uID0gZGVjb3JJbnZhZGluZztcblxuICAgICAgICB2YXIgZGVjb3JBcm91bmQgPSAoZGVjb3JMZWZ0ID4gMCAmJiBkZWNvclJpZ2h0ID4gMCkgfHwgZGVjb3JOZWFyID49IDM7XG4gICAgICAgIHZhciBjZW50ZXJlZFNpbmdsZVRleHRDb2x1bW4gPSBvdXQuc2luZ2xlVGV4dENvbHVtbiAmJiAob3V0LmNlbnRlcmVkQnlBbGlnbiB8fCBvdXQuY2VudGVyZWRCeUdlb21ldHJ5KTtcbiAgICAgICAgb3V0LmlzSGVybyA9IGV4cGxpY2l0SGVybyB8fCBjZW50ZXJlZFNpbmdsZVRleHRDb2x1bW47XG4gICAgICAgIG91dC5yZWFzb24gPSBvdXQuaXNIZXJvXG4gICAgICAgICAgPyAoXG4gICAgICAgICAgICBleHBsaWNpdEhlcm9cbiAgICAgICAgICAgICAgPyBcImV4cGxpY2l0SGVyb1JvbGVcIlxuICAgICAgICAgICAgICA6IChkZWNvckludmFkaW5nID4gMFxuICAgICAgICAgICAgICAgID8gXCJzaW5nbGVDZW50ZXJlZFRleHRDb2x1bW5EZWNvckludmFkZXNcIlxuICAgICAgICAgICAgICAgIDogKGRlY29yQXJvdW5kXG4gICAgICAgICAgICAgICAgICA/IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uV2l0aERlY29yXCJcbiAgICAgICAgICAgICAgICAgIDogXCJzaW5nbGVDZW50ZXJlZFRleHRDb2x1bW5cIikpXG4gICAgICAgICAgKVxuICAgICAgICAgIDogXCJub0hlcm9TaWduYWxcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0SW5saW5lUGFpck5vUmVmbG93KGZsb3dJdGVtcywgYWxsSXRlbXMsIHJvb3RXLCBDRkcpe1xuICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgIHNraXA6IGZhbHNlLFxuICAgICAgICAgIHJlYXNvbjogXCJcIixcbiAgICAgICAgICB0b3RhbEZsb3c6IGZsb3dJdGVtcyA/IGZsb3dJdGVtcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHRvdGFsQWxsOiBhbGxJdGVtcyA/IGFsbEl0ZW1zLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcm93RGVsdGE6IG51bGwsXG4gICAgICAgICAgcm93VG9sOiBudWxsLFxuICAgICAgICAgIHBhaXJTcGFuOiBudWxsLFxuICAgICAgICAgIHBhaXJTcGFuUmF0aW86IG51bGwsXG4gICAgICAgICAgZml0c1RvZ2V0aGVyOiBmYWxzZSxcbiAgICAgICAgICBib3RoU21hbGw6IGZhbHNlLFxuICAgICAgICAgIHNtYWxsV0xpbWl0OiBudWxsLFxuICAgICAgICAgIHNtYWxsSExpbWl0OiBudWxsLFxuICAgICAgICAgIHdpZHRoczogW10sXG4gICAgICAgICAgaGVpZ2h0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFmbG93SXRlbXMgfHwgZmxvd0l0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhYWxsSXRlbXMgfHwgYWxsSXRlbXMubGVuZ3RoICE9PSAyIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90RXhhY3RQYWlyXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gZmxvd0l0ZW1zWzBdO1xuICAgICAgICB2YXIgYiA9IGZsb3dJdGVtc1sxXTtcbiAgICAgICAgdmFyIGFXID0gTWF0aC5tYXgoMCwgTnVtYmVyKGEud2lkdGggfHwgMCkpO1xuICAgICAgICB2YXIgYlcgPSBNYXRoLm1heCgwLCBOdW1iZXIoYi53aWR0aCB8fCAwKSk7XG4gICAgICAgIHZhciBhSCA9IE1hdGgubWF4KDAsIE51bWJlcihhLmhlaWdodCB8fCAwKSk7XG4gICAgICAgIHZhciBiSCA9IE1hdGgubWF4KDAsIE51bWJlcihiLmhlaWdodCB8fCAwKSk7XG4gICAgICAgIG91dC53aWR0aHMgPSBbK2FXLnRvRml4ZWQoMSksICtiVy50b0ZpeGVkKDEpXTtcbiAgICAgICAgb3V0LmhlaWdodHMgPSBbK2FILnRvRml4ZWQoMSksICtiSC50b0ZpeGVkKDEpXTtcblxuICAgICAgICBpZiAoYVcgPCAyIHx8IGJXIDwgMiB8fCBhSCA8IDIgfHwgYkggPCAyKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiaW52YWxpZFNpemVzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3dUb2wgPSBNYXRoLm1heCgxMiwgTnVtYmVyKChDRkcgJiYgQ0ZHLlJPV19UT0wpIHx8IDI4KSAqIDEuMik7XG4gICAgICAgIHZhciByb3dEZWx0YSA9IE1hdGguYWJzKE51bWJlcihhLnRvcCB8fCAwKSAtIE51bWJlcihiLnRvcCB8fCAwKSk7XG4gICAgICAgIG91dC5yb3dUb2wgPSArcm93VG9sLnRvRml4ZWQoMSk7XG4gICAgICAgIG91dC5yb3dEZWx0YSA9ICtyb3dEZWx0YS50b0ZpeGVkKDEpO1xuICAgICAgICBpZiAocm93RGVsdGEgPiByb3dUb2wpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub3RJbmxpbmVSb3dcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNtYWxsV0xpbWl0ID0gTWF0aC5tYXgoNzQsIHJvb3RXICogMC40Mik7XG4gICAgICAgIHZhciBzbWFsbEhMaW1pdCA9IE1hdGgubWF4KDM0LCByb290VyAqIDAuMik7XG4gICAgICAgIG91dC5zbWFsbFdMaW1pdCA9ICtzbWFsbFdMaW1pdC50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQuc21hbGxITGltaXQgPSArc21hbGxITGltaXQudG9GaXhlZCgxKTtcbiAgICAgICAgdmFyIGJvdGhTbWFsbCA9XG4gICAgICAgICAgYVcgPD0gc21hbGxXTGltaXQgJiZcbiAgICAgICAgICBiVyA8PSBzbWFsbFdMaW1pdCAmJlxuICAgICAgICAgIGFIIDw9IHNtYWxsSExpbWl0ICYmXG4gICAgICAgICAgYkggPD0gc21hbGxITGltaXQ7XG4gICAgICAgIG91dC5ib3RoU21hbGwgPSBib3RoU21hbGw7XG4gICAgICAgIGlmICghYm90aFNtYWxsKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwicGFpck5vdFNtYWxsXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWlyTGVmdCA9IE1hdGgubWluKE51bWJlcihhLmxlZnQgfHwgMCksIE51bWJlcihiLmxlZnQgfHwgMCkpO1xuICAgICAgICB2YXIgcGFpclJpZ2h0ID0gTWF0aC5tYXgoTnVtYmVyKGEubGVmdCB8fCAwKSArIGFXLCBOdW1iZXIoYi5sZWZ0IHx8IDApICsgYlcpO1xuICAgICAgICB2YXIgcGFpclNwYW4gPSBNYXRoLm1heCgwLCBwYWlyUmlnaHQgLSBwYWlyTGVmdCk7XG4gICAgICAgIHZhciBmaXRzVG9nZXRoZXIgPSBwYWlyU3BhbiA8PSAocm9vdFcgKyAxKTtcbiAgICAgICAgb3V0LnBhaXJTcGFuID0gK3BhaXJTcGFuLnRvRml4ZWQoMSk7XG4gICAgICAgIG91dC5wYWlyU3BhblJhdGlvID0gKyhwYWlyU3BhbiAvIE1hdGgubWF4KDEsIHJvb3RXKSkudG9GaXhlZCgzKTtcbiAgICAgICAgb3V0LmZpdHNUb2dldGhlciA9IGZpdHNUb2dldGhlcjtcblxuICAgICAgICBpZiAoZml0c1RvZ2V0aGVyKSB7XG4gICAgICAgICAgb3V0LnNraXAgPSB0cnVlO1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcInNtYWxsSW5saW5lUGFpckZpdHNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LnJlYXNvbiA9IFwic21hbGxJbmxpbmVQYWlyT3ZlcmZsb3dcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5mb3JjZUlubGluZVBhaXJHYXAoZmxvd0l0ZW1zLCByb290RWwsIHJvb3RXKXtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICBhcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgbWluR2FwOiA2LFxuICAgICAgICAgIGdhcEJlZm9yZTogbnVsbCxcbiAgICAgICAgICBnYXBBZnRlcjogbnVsbCxcbiAgICAgICAgICBuZWVkOiBudWxsLFxuICAgICAgICAgIG1vdmVMZWZ0OiAwLFxuICAgICAgICAgIG1vdmVSaWdodDogMCxcbiAgICAgICAgICBvdmVyZmxvd0JlZm9yZTogZmFsc2UsXG4gICAgICAgICAgb3ZlcmZsb3dBZnRlcjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJvb3RQYWRMZWZ0ID0gMDtcbiAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgIHZhciByb290Q1MgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbCk7XG4gICAgICAgICAgcm9vdFBhZExlZnQgPSBwYXJzZUZsb2F0KHJvb3RDUy5wYWRkaW5nTGVmdCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsb3dJdGVtcyB8fCBmbG93SXRlbXMubGVuZ3RoICE9PSAyIHx8ICFyb290RWwgfHwgIXJvb3RXIHx8IHJvb3RXIDw9IDApIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJub3RFeGFjdFBhaXJcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBmbG93SXRlbXNbMF07XG4gICAgICAgIHZhciBiID0gZmxvd0l0ZW1zWzFdO1xuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgIWEubm9kZSB8fCAhYi5ub2RlKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibWlzc2luZ05vZGVzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0SXRlbSA9IE51bWJlcihhLmxlZnQgfHwgMCkgPD0gTnVtYmVyKGIubGVmdCB8fCAwKSA/IGEgOiBiO1xuICAgICAgICB2YXIgcmlnaHRJdGVtID0gKGxlZnRJdGVtID09PSBhKSA/IGIgOiBhO1xuXG4gICAgICAgIHZhciByckwgPSByZWxSZWN0KGxlZnRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciByclIgPSByZWxSZWN0KHJpZ2h0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgbExlZnQgPSBOdW1iZXIocnJMLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciBsVyA9IE51bWJlcihyckwud2lkdGggfHwgMCk7XG4gICAgICAgIHZhciByTGVmdCA9IE51bWJlcihyclIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIHJXID0gTnVtYmVyKHJyUi53aWR0aCB8fCAwKTtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsTGVmdCkgfHwgIWlzRmluaXRlKGxXKSB8fCAhaXNGaW5pdGUockxlZnQpIHx8ICFpc0Zpbml0ZShyVykpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJpbnZhbGlkUmVjdHNcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdhcEJlZm9yZSA9IHJMZWZ0IC0gKGxMZWZ0ICsgbFcpO1xuICAgICAgICBvdXQuZ2FwQmVmb3JlID0gK2dhcEJlZm9yZS50b0ZpeGVkKDIpO1xuICAgICAgICBvdXQub3ZlcmZsb3dCZWZvcmUgPSAobExlZnQgPCAtMC41KSB8fCAoKHJMZWZ0ICsgclcpID4gKHJvb3RXICsgMC41KSk7XG5cbiAgICAgICAgdmFyIG5lZWQgPSBNYXRoLm1heCgwLCBvdXQubWluR2FwIC0gZ2FwQmVmb3JlKTtcbiAgICAgICAgb3V0Lm5lZWQgPSArbmVlZC50b0ZpeGVkKDIpO1xuICAgICAgICBpZiAobmVlZCA8PSAwLjI1KSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiYWxyZWFkeVNwYWNlZFwiO1xuICAgICAgICAgIG91dC5nYXBBZnRlciA9IG91dC5nYXBCZWZvcmU7XG4gICAgICAgICAgb3V0Lm92ZXJmbG93QWZ0ZXIgPSBvdXQub3ZlcmZsb3dCZWZvcmU7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdmFpbFJpZ2h0ID0gTWF0aC5tYXgoMCwgcm9vdFcgLSAockxlZnQgKyByVykpO1xuICAgICAgICB2YXIgYXZhaWxMZWZ0ID0gTWF0aC5tYXgoMCwgbExlZnQpO1xuICAgICAgICB2YXIgbW92ZVJpZ2h0ID0gTWF0aC5taW4oYXZhaWxSaWdodCwgbmVlZCk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBNYXRoLm1heCgwLCBuZWVkIC0gbW92ZVJpZ2h0KTtcbiAgICAgICAgdmFyIG1vdmVMZWZ0ID0gTWF0aC5taW4oYXZhaWxMZWZ0LCByZW1haW5pbmcpO1xuXG4gICAgICAgIGlmIChtb3ZlUmlnaHQgPD0gMC4wMSAmJiBtb3ZlTGVmdCA8PSAwLjAxKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9Sb29tVG9BZGp1c3RcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmVSaWdodCA+IDAuMDEpIHtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5sZWZ0ID0gKChOdW1iZXIocmlnaHRJdGVtLmxlZnQgfHwgMCkgKyBtb3ZlUmlnaHQpIC0gcm9vdFBhZExlZnQpICsgXCJweFwiO1xuICAgICAgICAgIHJpZ2h0SXRlbS5ub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgcmlnaHRJdGVtLm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVMZWZ0ID4gMC4wMSkge1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUubGVmdCA9ICgoTnVtYmVyKGxlZnRJdGVtLmxlZnQgfHwgMCkgLSBtb3ZlTGVmdCkgLSByb290UGFkTGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgbGVmdEl0ZW0ubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnJMMiA9IHJlbFJlY3QobGVmdEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIHJyUjIgPSByZWxSZWN0KHJpZ2h0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgbExlZnQyID0gTnVtYmVyKHJyTDIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIGxXMiA9IE51bWJlcihyckwyLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgckxlZnQyID0gTnVtYmVyKHJyUjIubGVmdCB8fCAwKTtcbiAgICAgICAgdmFyIHJXMiA9IE51bWJlcihyclIyLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgZ2FwQWZ0ZXIgPSByTGVmdDIgLSAobExlZnQyICsgbFcyKTtcblxuICAgICAgICBvdXQubW92ZVJpZ2h0ID0gK21vdmVSaWdodC50b0ZpeGVkKDIpO1xuICAgICAgICBvdXQubW92ZUxlZnQgPSArbW92ZUxlZnQudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0LmdhcEFmdGVyID0gaXNGaW5pdGUoZ2FwQWZ0ZXIpID8gK2dhcEFmdGVyLnRvRml4ZWQoMikgOiBudWxsO1xuICAgICAgICBvdXQub3ZlcmZsb3dBZnRlciA9IChsTGVmdDIgPCAtMC41KSB8fCAoKHJMZWZ0MiArIHJXMikgPiAocm9vdFcgKyAwLjUpKTtcbiAgICAgICAgb3V0LmFwcGxpZWQgPSAobW92ZVJpZ2h0ID4gMC4wMSB8fCBtb3ZlTGVmdCA+IDAuMDEpO1xuICAgICAgICBvdXQucmVhc29uID0gb3V0LmFwcGxpZWQgPyBcImFwcGxpZWRcIiA6IFwibm9DaGFuZ2VcIjtcbiAgICAgICAgaWYgKGlzRmluaXRlKGdhcEFmdGVyKSAmJiBnYXBBZnRlciA8IC0wLjIpIG91dC5yZWFzb24gPSBcImFwcGxpZWRCdXRTdGlsbE92ZXJsYXBcIjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pbmVudE5vblRleHRDb3VudCA9IGl0ZW1zQWxsLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICAgIGlmICgoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgdyA9IE51bWJlcihpdC53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIGggPSBOdW1iZXIoaXQuaGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAodyA8IDYgfHwgaCA8IDYpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KS5sZW5ndGg7XG4gICAgICAvLyBTaSBoYXkgY3VhbHF1aWVyIG5vLXRleHRvIHZpc2libGUsIGV2aXRhbW9zIGFuY2xhciB0ZXh0b3MgcG9yIGhldXJpc3RpY2EuXG4gICAgICAvLyBFc3RvIGltcGlkZSBxdWUgdGV4dG9zIGRlIHVuYSBjb2x1bW5hIHF1ZWRlbiBcImNvbmdlbGFkb3NcIiBlbiBsZWZ0IG9yaWdpbmFsLlxuICAgICAgdmFyIGFsbG93SGV1cmlzdGljQW5jaG9ycyA9IHByb21pbmVudE5vblRleHRDb3VudCA9PT0gMDtcblxuICAgICAgLy8g4pyFIERldGVybWluYXIgcXXDqSBub2RvcyBzb24gXCJBTkNIT1JcIiAobm8gc2UgcmVmbG93ZWFuKVxuICAgICAgLy8gUmVnbGE6IHRleHRvIGNlbnRyYWRvICsgY2FzaSBmdWxsLXdpZHRoID0+IHTDrXR1bG8vaGVybywgbm8gbW92ZXIuXG4gICAgICBmdW5jdGlvbiBpc0FuY2hvck5vZGUoaXQpe1xuICAgICAgICB2YXIgbm9kZSA9IGl0Lm5vZGU7XG5cclxuICAgICAgICAvLyBvcHQtb3V0IGV4cGzDrWNpdG9cclxuICAgICAgICB2YXIga2VlcExheW91dCA9IChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XHJcbiAgICAgICAgaWYgKGtlZXBMYXlvdXQpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBhbmNob3IgZXhwbMOtY2l0byAoc2kgbG8gdXPDoXMpXHJcbiAgICAgICAgdmFyIHJvbGUgPSAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1yb2xlXCIpIHx8IFwiXCIpO1xyXG4gICAgICAgIGlmIChyb2xlID09PSBcImFuY2hvclwiKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gaGV1csOtc3RpY2EgcGFyYSB0ZXh0b3NcbiAgICAgICAgdmFyIGlzVGV4dCA9IChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xuICAgICAgICBpZiAoIWlzVGV4dCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWFsbG93SGV1cmlzdGljQW5jaG9ycykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciB0YSA9IChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUudGV4dEFsaWduKSA/IFN0cmluZyhub2RlLnN0eWxlLnRleHRBbGlnbikudG9Mb3dlckNhc2UoKSA6IFwiXCI7XG4gICAgICAgIGlmICghdGEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGEgPSBTdHJpbmcoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS50ZXh0QWxpZ24gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9IGNhdGNoKF9lKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YSAhPT0gXCJjZW50ZXJcIikgcmV0dXJuIGZhbHNlO1xuXHJcbiAgICAgICAgLy8gc29sbyBzaSByZWFsbWVudGUgb2N1cGEgY2FzaSB0b2RvIGVsIGFuY2hvIHVzYWJsZVxyXG4gICAgICAgIC8vIChlc3RvIGV2aXRhIHJvbXBlciB0ZXh0b3MgY2VudHJhZG9zIGRlbnRybyBkZSBjb2x1bW5hcylcclxuICAgICAgICBpZiAoY29udGVudFcgPiAwICYmIGl0LndpZHRoID49IGNvbnRlbnRXICogMC43OCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8g4pyFIEZsb3cgPSB0b2RvIGxvIHF1ZSBOTyBlcyBhbmNob3JcbiAgICAgIHZhciBpdGVtc0Zsb3cgPSBpdGVtc0FsbC5maWx0ZXIoZnVuY3Rpb24oaXQpeyByZXR1cm4gIWlzQW5jaG9yTm9kZShpdCk7IH0pO1xuICAgICAgdmFyIGl0ZW1zQW5jaG9yID0gaXRlbXNBbGwuZmlsdGVyKGZ1bmN0aW9uKGl0KXsgcmV0dXJuIGlzQW5jaG9yTm9kZShpdCk7IH0pO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjphbmNob3JTcGxpdFwiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgYW5jaG9yczogaXRlbXNBbmNob3IubGVuZ3RoLFxuICAgICAgICBmbG93OiBpdGVtc0Zsb3cubGVuZ3RoLFxuICAgICAgICBwcm9taW5lbnROb25UZXh0Q291bnQ6IHByb21pbmVudE5vblRleHRDb3VudCxcbiAgICAgICAgYWxsb3dIZXVyaXN0aWNBbmNob3JzOiBhbGxvd0hldXJpc3RpY0FuY2hvcnMsXG4gICAgICAgIGFuY2hvcnNEZXRhaWw6IGl0ZW1zQW5jaG9yLm1hcChmdW5jdGlvbihpdCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiID8gXCJ0ZXh0b1wiIDogKGl0Lm5vZGUudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgdG9wOiAraXQudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiAraXQubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdzogK2l0LndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiAraXQuaGVpZ2h0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICB0ZXh0QWxpZ246IChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSA/IGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduIDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgLy8gU2kgbm8gaGF5IHN1ZmljaWVudGVzIGVsZW1lbnRvcyByZWZsb3dhYmxlcywgbm8gaGFjZW1vcyBuYWRhXG4gICAgICBpZihpdGVtc0Zsb3cubGVuZ3RoIDwgMikge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6Zmxvd1Rvb1NtYWxsXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aCxcbiAgICAgICAgICBhbmNob3JDb3VudDogaXRlbXNBbmNob3IubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxyXG4gICAgICAvLyDinIUgUGFyYSBxdWUgXCJhbHR1cmEgbmVjZXNhcmlhXCIgbm8gcXVlZGUgY29ydGEsXHJcbiAgICAgIC8vIG1lZGltb3MgZWwgYm90dG9tIG3DoXhpbW8gZGUgYW5jaG9ycyAoZW4gY29vcmRzIGRlbCBjb250ZW50KVxyXG4gICAgICB2YXIgbWF4QW5jaG9yQm90dG9tID0gMDtcclxuICAgICAgaXRlbXNBbGwuZm9yRWFjaChmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgaWYgKCFpc0FuY2hvck5vZGUoaXQpKSByZXR1cm47XHJcbiAgICAgICAgdmFyIGIgPSAoaXQudG9wIHx8IDApICsgKGl0LmhlaWdodCB8fCAwKTtcclxuICAgICAgICBpZiAoYiA+IG1heEFuY2hvckJvdHRvbSkgbWF4QW5jaG9yQm90dG9tID0gYjtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyDinIUgMSkgYWdydXBhciBwb3Igc29sYXBlIOKGkiBjbHVzdGVycyAoU09MTyBGTE9XKVxuICAgICAgdmFyIGNsdXN0ZXJzID0gYnVpbGRPdmVybGFwQ2x1c3RlcnMoaXRlbXNGbG93KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246Y2x1c3RlcnNcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIGNvdW50OiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycy5tYXAoZnVuY3Rpb24oYywgaWR4KXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTogaWR4LFxuICAgICAgICAgICAgdG9wOiArYy50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtjLmxlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGN4OiArYy5jeC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyDinIUgMikgRGV0ZWN0YXIgY29sdW1uYXMvcm93cyAoU09MTyBGTE9XKVxuICAgICAgdmFyIHJvb3RXID0gY29udGVudFcgfHwgMDtcbiAgICAgIHZhciBvcmQgPSBvcmRlckNsdXN0ZXJzRm9yTW9iaWxlKGNsdXN0ZXJzLCByb290VywgQ0ZHKTtcbiAgICAgIHZhciBncm91cHMgPSBvcmQuZ3JvdXBzO1xuICAgICAgdmFyIG1vZGUgPSBvcmQubW9kZTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246b3JkZXJpbmdcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHJvb3RXOiByb290VyxcbiAgICAgICAgZ3JvdXBzOiBncm91cHMubWFwKGZ1bmN0aW9uKGdycCwgZ2kpe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnOiBnaSxcbiAgICAgICAgICAgIGNvdW50OiBncnAubGVuZ3RoLFxuICAgICAgICAgICAgdG9wczogZ3JwLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLnRvcC50b0ZpeGVkKDEpOyB9KSxcbiAgICAgICAgICAgIGxlZnRzOiBncnAubWFwKGZ1bmN0aW9uKGMpeyByZXR1cm4gK2MubGVmdC50b0ZpeGVkKDEpOyB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgdmFyIGhlcm9TaWduYWwgPSBkZXRlY3RIZXJvTGlrZUNlbnRyYWxUZXh0KGl0ZW1zQWxsLCByb290Vyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmhlcm9DaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgaXNIZXJvOiBoZXJvU2lnbmFsLmlzSGVybyxcbiAgICAgICAgcmVhc29uOiBoZXJvU2lnbmFsLnJlYXNvbixcbiAgICAgICAgdGV4dENvdW50OiBoZXJvU2lnbmFsLnRleHRDb3VudCxcbiAgICAgICAgdGV4dENvbHVtbkNvdW50OiBoZXJvU2lnbmFsLnRleHRDb2x1bW5Db3VudCxcbiAgICAgICAgc2luZ2xlVGV4dENvbHVtbjogaGVyb1NpZ25hbC5zaW5nbGVUZXh0Q29sdW1uLFxuICAgICAgICB0ZXh0Q29sdW1uczogaGVyb1NpZ25hbC50ZXh0Q29sdW1ucyxcbiAgICAgICAgbWF4VGV4dFdpZHRoUmF0aW86IGhlcm9TaWduYWwubWF4VGV4dFdpZHRoUmF0aW8sXG4gICAgICAgIHdpZHRoUmF0aW86IGhlcm9TaWduYWwud2lkdGhSYXRpbyxcbiAgICAgICAgY2VudGVyRGVsdGE6IGhlcm9TaWduYWwuY2VudGVyRGVsdGEsXG4gICAgICAgIGNlbnRlclRvbDogaGVyb1NpZ25hbC5jZW50ZXJUb2wsXG4gICAgICAgIGNlbnRlcmVkQnlBbGlnbjogaGVyb1NpZ25hbC5jZW50ZXJlZEJ5QWxpZ24sXG4gICAgICAgIGNlbnRlcmVkQnlHZW9tZXRyeTogaGVyb1NpZ25hbC5jZW50ZXJlZEJ5R2VvbWV0cnksXG4gICAgICAgIGRlY29yTmVhcjogaGVyb1NpZ25hbC5kZWNvck5lYXIsXG4gICAgICAgIGRlY29yTGVmdDogaGVyb1NpZ25hbC5kZWNvckxlZnQsXG4gICAgICAgIGRlY29yUmlnaHQ6IGhlcm9TaWduYWwuZGVjb3JSaWdodCxcbiAgICAgICAgZGVjb3JJbnZhZGluZ1RleHRDb2x1bW46IGhlcm9TaWduYWwuZGVjb3JJbnZhZGluZ1RleHRDb2x1bW5cbiAgICAgIH0pO1xuICAgICAgaWYgKGhlcm9TaWduYWwuaXNIZXJvKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpoZXJvQ2VudHJhbFRleHRcIiwge1xuICAgICAgICAgIHdpbGxBcHBseVJlZmxvdzogZmFsc2UsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBoZXJvUmVhc29uOiBoZXJvU2lnbmFsLnJlYXNvbixcbiAgICAgICAgICBoZXJvOiBoZXJvU2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlubGluZVBhaXJTaWduYWwgPSBkZXRlY3RJbmxpbmVQYWlyTm9SZWZsb3coaXRlbXNGbG93LCBpdGVtc0FsbCwgcm9vdFcsIENGRyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmlubGluZVBhaXJDaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgc2tpcDogaW5saW5lUGFpclNpZ25hbC5za2lwLFxuICAgICAgICByZWFzb246IGlubGluZVBhaXJTaWduYWwucmVhc29uLFxuICAgICAgICB0b3RhbEZsb3c6IGlubGluZVBhaXJTaWduYWwudG90YWxGbG93LFxuICAgICAgICB0b3RhbEFsbDogaW5saW5lUGFpclNpZ25hbC50b3RhbEFsbCxcbiAgICAgICAgcm93RGVsdGE6IGlubGluZVBhaXJTaWduYWwucm93RGVsdGEsXG4gICAgICAgIHJvd1RvbDogaW5saW5lUGFpclNpZ25hbC5yb3dUb2wsXG4gICAgICAgIHdpZHRoczogaW5saW5lUGFpclNpZ25hbC53aWR0aHMsXG4gICAgICAgIGhlaWdodHM6IGlubGluZVBhaXJTaWduYWwuaGVpZ2h0cyxcbiAgICAgICAgYm90aFNtYWxsOiBpbmxpbmVQYWlyU2lnbmFsLmJvdGhTbWFsbCxcbiAgICAgICAgc21hbGxXTGltaXQ6IGlubGluZVBhaXJTaWduYWwuc21hbGxXTGltaXQsXG4gICAgICAgIHNtYWxsSExpbWl0OiBpbmxpbmVQYWlyU2lnbmFsLnNtYWxsSExpbWl0LFxuICAgICAgICBwYWlyU3BhbjogaW5saW5lUGFpclNpZ25hbC5wYWlyU3BhbixcbiAgICAgICAgcGFpclNwYW5SYXRpbzogaW5saW5lUGFpclNpZ25hbC5wYWlyU3BhblJhdGlvLFxuICAgICAgICBmaXRzVG9nZXRoZXI6IGlubGluZVBhaXJTaWduYWwuZml0c1RvZ2V0aGVyXG4gICAgICB9KTtcbiAgICAgIGlmIChpbmxpbmVQYWlyU2lnbmFsLnNraXApIHtcbiAgICAgICAgdmFyIGlubGluZVBhaXJBZGp1c3QgPSBlbmZvcmNlSW5saW5lUGFpckdhcChpdGVtc0Zsb3csIGNvbnRlbnQsIHJvb3RXKTtcbiAgICAgICAgbXNsTG9nKFwic2VjdGlvbjppbmxpbmVQYWlyQWRqdXN0XCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBhZGp1c3Q6IGlubGluZVBhaXJBZGp1c3RcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpzbWFsbElubGluZVBhaXJGaXRzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgaW5saW5lUGFpcjogaW5saW5lUGFpclNpZ25hbCxcbiAgICAgICAgICBpbmxpbmVQYWlyQWRqdXN0OiBpbmxpbmVQYWlyQWRqdXN0XG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8g4pyFIDMpIEdhdGUgXCJtZWpvciBkZSBhbWJvcyBtdW5kb3NcIjpcbiAgICAgIC8vIC0gU2kgZXMgXCJvbmVcIiAobGF5b3V0IHlhIG5hdHVyYWwpIFkgYWRlbcOhcyBlbnRyYSwgTk8gaGFjZW1vcyByZWZsb3cuXG4gICAgICAvLyAtIEVuIGN1YWxxdWllciBvdHJvIGNhc28gKHR3by90aHJlZS9yb3dzKSwgaGFjZW1vcyByZWZsb3cgcGFyYSBsZWN0dXJhIG1vYmlsZSxcbiAgICAgIC8vICAgaW5jbHVzbyBhdW5xdWUgXCJlbnRyZVwiLlxyXG4gICAgICB2YXIgZml0cyA9IGNsdXN0ZXJzRml0SW5Nb2JpbGUoY2x1c3RlcnMsIGNvbnRlbnQpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpmaXRDaGVja1wiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgd2lsbFNraXA6IChtb2RlID09PSBcIm9uZVwiICYmIGZpdHMpXG4gICAgICB9KTtcbiAgICAgIGlmIChtb2RlID09PSBcIm9uZVwiICYmIGZpdHMpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOm1vZGVPbmVGaXRzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICAgIGZsb3dDb3VudDogaXRlbXNGbG93Lmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwiYXBwbHk6bW9kZVJlcXVpcmVzUmVmbG93XCIsIHtcbiAgICAgICAgd2lsbEFwcGx5UmVmbG93OiB0cnVlLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBmaXRzOiBmaXRzLFxuICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgIGFuY2hvckNvdW50OiBpdGVtc0FuY2hvci5sZW5ndGgsXG4gICAgICAgIGdyb3VwU2l6ZXM6IGdyb3Vwcy5tYXAoZnVuY3Rpb24oZ3JwKXsgcmV0dXJuIGdycC5sZW5ndGg7IH0pXG4gICAgICB9KTtcblxuICAgICAgLy8g4pyFIDQpIFJlZmxvdyBzb2xvIHNvYnJlIEZMT1cgKHByZXNlcnZhIHNvbGFwZXMgZGVudHJvIGRlIGNhZGEgY2x1c3RlcilcbiAgICAgIHZhciByZXMgPSBhcHBseUNsdXN0ZXJTdGFjayhncm91cHMsIGNvbnRlbnQsIENGRywgbW9kZSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmFwcGx5UmVzdWx0XCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjaGFuZ2VkOiAhIShyZXMgJiYgcmVzLmNoYW5nZWQpLFxuICAgICAgICBuZWVkZWRIZWlnaHQ6IHJlcyA/IHJlcy5uZWVkZWRIZWlnaHQgOiBudWxsLFxuICAgICAgICBtYXhBbmNob3JCb3R0b206ICttYXhBbmNob3JCb3R0b20udG9GaXhlZCgxKSxcbiAgICAgICAgYmFzZUJvdHRvbUdhcDogK2Jhc2VCb3R0b21HYXAudG9GaXhlZCgxKVxuICAgICAgfSk7XG4gICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInBvc3RBcHBseVwiLCB7XG4gICAgICAgIHdpbGxBcHBseVJlZmxvdzogdHJ1ZSxcbiAgICAgICAgY2hhbmdlZDogISEocmVzICYmIHJlcy5jaGFuZ2VkKSxcbiAgICAgICAgbmVlZGVkSGVpZ2h0OiByZXMgPyArTnVtYmVyKHJlcy5uZWVkZWRIZWlnaHQgfHwgMCkudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbmVlZGVkQWZ0ZXJSZWZsb3cgPSAwO1xuICAgICAgaWYgKHJlcyAmJiByZXMuY2hhbmdlZCkge1xuICAgICAgICAvLyBFdml0YXIgcXVlIGxhIHNlY2Npw7NuIHF1ZWRlIGNoaWNhIHNpIGhheSBhbmNob3JzIG3DoXMgYWJham9cbiAgICAgICAgdmFyIG5lZWRlZCA9IE51bWJlcihyZXMubmVlZGVkSGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAoTnVtYmVyKG1heEFuY2hvckJvdHRvbSkgPiAwKSB7XG4gICAgICAgICAgLy8gc3VtYW1vcyBwYWRkaW5nIGJvdHRvbSBwYXJhIHF1ZSBubyBxdWVkZSBwZWdhZG9cbiAgICAgICAgICB2YXIgYW5jaG9yTmVlZGVkID0gTWF0aC5jZWlsKG1heEFuY2hvckJvdHRvbSArIChDRkcuUEFEX0JPVCB8fCAwKSk7XG4gICAgICAgICAgaWYgKGFuY2hvck5lZWRlZCA+IG5lZWRlZCkgbmVlZGVkID0gYW5jaG9yTmVlZGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlQm90dG9tR2FwID4gMCkge1xuICAgICAgICAgIG5lZWRlZCA9IE1hdGguY2VpbChuZWVkZWQgKyBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZGVkID4gMCkgbmVlZGVkQWZ0ZXJSZWZsb3cgPSBuZWVkZWQ7XG4gICAgICB9XG4gICAgICBmaW5hbGl6ZVNlY3Rpb24obmVlZGVkQWZ0ZXJSZWZsb3csIGJhc2VCb3R0b21HYXApO1xuICAgIH0pO1xuICB9XG5cclxuICBmdW5jdGlvbiBib290KCl7XG4gICAgbXNsTG9nKFwiYm9vdFwiLCB7IGNmZzogQ0ZHIH0pO1xuICAgIHJ1bk9uY2UoKTtcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDE1MCk7XHJcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDYwMCk7XHJcbiAgICBzZXRUaW1lb3V0KHJ1bk9uY2UsIDE4MDApO1xyXG5cclxuICAgIGlmKGRvY3VtZW50LmZvbnRzICYmIGRvY3VtZW50LmZvbnRzLnJlYWR5KXtcclxuICAgICAgZG9jdW1lbnQuZm9udHMucmVhZHkudGhlbihmdW5jdGlvbigpeyBydW5PbmNlKCk7IH0pLmNhdGNoKGZ1bmN0aW9uKCl7fSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYm9vdCk7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcnVuT25jZSk7XHJcblxyXG4gIGlmKHdpbmRvdy52aXN1YWxWaWV3cG9ydCl7XHJcbiAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBydW5PbmNlKTtcclxuICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHJ1bk9uY2UpO1xyXG4gIH1cclxuXHJcbiAgaWYoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIGJvb3QoKTtcclxuICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3QpO1xyXG59KSgpO1xyXG48L3NjcmlwdD5cclxuYC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImpzRG9tSGVscGVyc0Jsb2NrIiwianNGaXRTY2FsZUJsb2NrIiwianNPcmRlcmluZ0Jsb2NrIiwianNTdGFja2luZ0Jsb2NrIiwiYnVpbGRTY3JpcHQiLCJjZmciLCJlbmFibGVkIiwibWluR2FwUHgiLCJtYXhHYXBQeCIsImdhcFNjYWxlIiwicGFkZGluZ1RvcFB4IiwicGFkZGluZ0JvdHRvbVB4Iiwib25seUZpeGVkU2VjdGlvbnMiLCJvbmx5V2hlblJlb3JkZXJlZCIsInJvd1RvbFB4IiwidHdvQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4yIiwidGhyZWVDb2xTcHJlYWRSYXRpbyIsIm1pblBlckNvbHVtbjMiLCJmaXRNaW5TY2FsZSIsImZpdE1heFNjYWxlIiwiZml0VGFyZ2V0V2lkdGhSYXRpbyIsImZpdE1pbkZpbGxSYXRpbyIsInRyaW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/stacking.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsStackingBlock: () => (/* binding */ jsStackingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/stacking.ts\nfunction jsStackingBlock() {\n    return '\\n  // Centro real del \\xc3\\xa1rea usable (compensa padding safe-left/right)\\n  function computeCenterX(rootEl){\\n    var rootRect = rootEl.getBoundingClientRect();\\n    var rootW = rootRect.width || 0;\\n\\n    var cs = getComputedStyle(rootEl);\\n    var padL = parseFloat(cs.paddingLeft) || 0;\\n    var padR = parseFloat(cs.paddingRight) || 0;\\n\\n    var usableW = Math.max(0, rootW - padL - padR);\\n    var centerX = padL + usableW / 2; // centro del \\xc3\\xa1rea usable\\n\\n    return { rootW: rootW, usableW: usableW, centerX: centerX, padL: padL, padR: padR };\\n  }\\n\\n  function clamp(n, a, b){\\n    if (!isFinite(n)) return a;\\n    return Math.max(a, Math.min(b, n));\\n  }\\n\\n  /**\\n   * Apila CLUSTERS por groups (columnas/filas) y:\\n   * - mueve cada cluster como bloque\\n   * - preserva solape/posiciones relativas dentro del cluster\\n   * - centra el cluster como bloque en el eje X (sin transform)\\n   *\\n   * Devuelve changed + neededHeight (para expandir secci\\xc3\\xb3n)\\n   */\\n  function applyClusterStack(groups, rootEl, CFG, mode){\\n    var info = computeCenterX(rootEl);\\n    var centerX = info.centerX;\\n    mslLog(\"stack:start\", {\\n      groupCount: groups.length,\\n      groupSizes: groups.map(function(g){ return g.length; }),\\n      centerX: +centerX.toFixed(1),\\n      usableW: +info.usableW.toFixed(1)\\n    });\\n\\n    var changed = false;\\n    var isMultiColLayout = (mode === \"two\" || mode === \"three\");\\n\\n    // En multi-columna: cada columna apilada se centra por su propio bbox.\\n    // As\\xc3\\xad, el centro de cada columna coincide con el centro de pantalla.\\n\\n    // --- Anchor global: d\\xc3\\xb3nde estaba \\xe2€œel bloque\\xe2€\\x9d originalmente ---\\n    var firstGroup = groups[0] || [];\\n    var anchor = Infinity;\\n    for (var i=0;i<firstGroup.length;i++){\\n      anchor = Math.min(anchor, firstGroup[i].top);\\n    }\\n    if (!isFinite(anchor)) anchor = CFG.PAD_TOP;\\n    anchor = Math.max(CFG.PAD_TOP, anchor);\\n\\n    // Cursor global: d\\xc3\\xb3nde termina el contenido apilado hasta ahora\\n    var globalCursor = anchor;\\n\\n    // Separaci\\xc3\\xb3n entre columnas apiladas (izq, centro, der)\\n    var GROUP_GAP = 14;\\n\\n    for (var g=0; g<groups.length; g++){\\n      var col = groups[g] || [];\\n      if (!col.length) continue;\\n      var colReferenceCenterX = NaN;\\n      var colSourceReferenceCenterX = NaN;\\n      var narrowClusterCount = 0;\\n      var wideClusterCount = 0;\\n\\n      // M\\xc3\\xa9tricas por grupo solo para debug.\\n      var groupMinLeft = Infinity;\\n      var groupMaxRight = -Infinity;\\n      if (isMultiColLayout){\\n        for (var gg=0; gg<col.length; gg++){\\n          groupMinLeft = Math.min(groupMinLeft, col[gg].left);\\n          groupMaxRight = Math.max(groupMaxRight, col[gg].left + col[gg].width);\\n          var clusterWDbg = Number(col[gg].width || 0);\\n          if (clusterWDbg <= (info.usableW * 0.72)) narrowClusterCount++;\\n          if (clusterWDbg >= (info.usableW * 0.88)) wideClusterCount++;\\n        }\\n      }\\n      var groupWidth = isMultiColLayout ? Math.max(0, groupMaxRight - groupMinLeft) : 0;\\n      var groupBaseLeft = isMultiColLayout ? (centerX - groupWidth / 2) : 0;\\n      var suspiciousWideSpan = isMultiColLayout &&\\n        col.length > 1 &&\\n        groupWidth >= (info.usableW * 0.88) &&\\n        narrowClusterCount >= 1 &&\\n        wideClusterCount >= 1;\\n      var preserveColumnOffsets = isMultiColLayout && !suspiciousWideSpan;\\n\\n      // Offset vertical original de esta columna respecto del anchor\\n      var colMinTop = Infinity;\\n      for (var k=0;k<col.length;k++){\\n        colMinTop = Math.min(colMinTop, col[k].top);\\n      }\\n      if (!isFinite(colMinTop)) colMinTop = anchor;\\n\\n      var colOffset = colMinTop - anchor;\\n      var colStart = globalCursor + (g === 0 ? 0 : GROUP_GAP) + Math.max(0, colOffset);\\n      mslLog(\"stack:group:start\", {\\n        g: g,\\n        colSize: col.length,\\n        colMinTop: +colMinTop.toFixed(1),\\n        colOffset: +colOffset.toFixed(1),\\n        colStart: +colStart.toFixed(1),\\n        globalCursor: +globalCursor.toFixed(1),\\n        mode: mode,\\n        groupMinLeft: isMultiColLayout ? +groupMinLeft.toFixed(1) : null,\\n        groupWidth: isMultiColLayout ? +groupWidth.toFixed(1) : null,\\n        groupBaseLeft: isMultiColLayout ? +groupBaseLeft.toFixed(1) : null,\\n        narrowClusterCount: isMultiColLayout ? narrowClusterCount : null,\\n        wideClusterCount: isMultiColLayout ? wideClusterCount : null,\\n        preserveColumnOffsets: isMultiColLayout ? preserveColumnOffsets : null\\n      });\\n\\n      // Cursor local de esta columna\\n      var colCursor = colStart;\\n\\n      for (var j=0; j<col.length; j++){\\n        var c = col[j];\\n\\n        // Top del cluster en el flujo mobile\\n        var clusterTop;\\n\\n        if (j === 0) {\\n          clusterTop = colCursor;\\n        } else {\\n          var prevC = col[j-1];\\n          var prevBottom = (clusterTopPrev + prevC.height);\\n\\n          // \\xe2œ… Gap original entre clusters (canvas)\\n          var prevBottomOrig = (prevC.top + prevC.height);\\n          var gapOrig = c.top - prevBottomOrig;\\n          if (!isFinite(gapOrig)) gapOrig = 0;\\n\\n          var overlapInSource = gapOrig < 0;\\n          if ((mode === \"two\" || mode === \"three\") && overlapInSource) {\\n            // Si en el original este cluster cae dentro del anterior, respetamos\\n            // su top relativo para no mandarlo al final de la columna.\\n            var relTopInCol = c.top - colMinTop;\\n            if (!isFinite(relTopInCol)) relTopInCol = 0;\\n            clusterTop = colStart + Math.max(0, relTopInCol);\\n          } else {\\n            // \\xe2œ… Gap \\xe2€œmobile-friendly\\xe2€\\x9d: escalado + clamp\\n            var gapWanted = clamp(gapOrig * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\\n\\n            // \\xe2œ… Anti-solape definitivo:\\n            //   el pr\\xc3\\xb3ximo cluster SIEMPRE empieza despu\\xc3\\xa9s del bottom real del anterior + gapWanted\\n            clusterTop = prevBottom + gapWanted;\\n\\n            // En multi-columna nunca avanzamos hacia arriba respecto al flujo ya consumido.\\n            if ((mode === \"two\" || mode === \"three\") && clusterTop < colCursor) {\\n              clusterTop = colCursor;\\n            }\\n          }\\n        }\\n\\n        // Guardamos para el pr\\xc3\\xb3ximo loop\\n        var clusterTopPrev = clusterTop;\\n\\n        // \\xc2\\xbfcentrar este cluster?\\n        var forceCenter = false;\\n        var hasTextInCluster = false;\\n        var hasNonTextInCluster = false;\\n        for (var t=0; t<c.items.length; t++){\\n          var isTextT = (c.items[t].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          if (isTextT) hasTextInCluster = true;\\n          else hasNonTextInCluster = true;\\n          if ((c.items[t].node.getAttribute(\"data-mobile-center\") || \"\") === \"force\") {\\n            forceCenter = true;\\n          }\\n        }\\n\\n        // one/rows: centro por cluster (comportamiento original)\\n        // two/three: apilar cada columna en la misma referencia X,\\n        // preservando offsets internos de esa columna.\\n        var keepCenter = forceCenter ? true : (c.width < (info.usableW * 0.95));\\n        var clusterLeft = keepCenter ? (centerX - c.width / 2) : c.left;\\n        var isTextOnlyCluster = hasTextInCluster && !hasNonTextInCluster;\\n        var shouldCenterTextWithinCluster = false;\\n        if (isMultiColLayout) {\\n          // Modo lectura mobile multi-col:\\n          // usar una misma referencia X para toda la columna apilada y\\n          // preservar el offset horizontal original de cada cluster.\\n          // Esto mantiene alineado texto/forma cuando la columna se parte\\n          // en varios clusters.\\n          // Si el bbox de la columna queda contaminado por un outlier ancho\\n          // (tipicamente texto), centrar por offsets deja la columna pegada\\n          // al borde; en ese caso centramos cada cluster individualmente.\\n          if (preserveColumnOffsets) {\\n            var relClusterLeft = (c.left || 0) - (groupMinLeft || 0);\\n            clusterLeft = groupBaseLeft + relClusterLeft;\\n          } else {\\n            clusterLeft = centerX - c.width / 2;\\n          }\\n\\n          // Permite forzar centrado por cluster si el nodo lo pide.\\n          if (forceCenter) clusterLeft = centerX - c.width / 2;\\n\\n          // Si esta columna tiene un cluster con forma (o mixto), usamos su\\n          // centro como referencia para alinear clusters solo-texto debajo.\\n          var clusterRefCenterX = NaN;\\n          if (hasNonTextInCluster) {\\n            // Referencia basada en items no-texto (forma/icono), no en todo el\\n            // cluster, para que textos largos no desplacen el centro de columna.\\n            var ntMinRel = Infinity;\\n            var ntMaxRel = -Infinity;\\n            for (var nti=0; nti<c.items.length; nti++){\\n              var ntIt = c.items[nti];\\n              var ntIsText = (ntIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              if (ntIsText) continue;\\n              ntMinRel = Math.min(ntMinRel, (ntIt._relLeft || 0));\\n              ntMaxRel = Math.max(ntMaxRel, (ntIt._relLeft || 0) + (ntIt.width || 0));\\n            }\\n            var sourceClusterRefCenterX = NaN;\\n            if (isFinite(ntMinRel) && isFinite(ntMaxRel) && ntMaxRel > ntMinRel) {\\n              clusterRefCenterX = clusterLeft + ((ntMinRel + ntMaxRel) / 2);\\n              sourceClusterRefCenterX = (c.left || 0) + ((ntMinRel + ntMaxRel) / 2);\\n            } else {\\n              clusterRefCenterX = clusterLeft + c.width / 2;\\n              sourceClusterRefCenterX = (c.left || 0) + c.width / 2;\\n            }\\n\\n            colReferenceCenterX = Number(clusterRefCenterX);\\n            colSourceReferenceCenterX = Number(sourceClusterRefCenterX);\\n            if (!isFinite(colReferenceCenterX)) colReferenceCenterX = NaN;\\n            if (!isFinite(colSourceReferenceCenterX)) colSourceReferenceCenterX = NaN;\\n          }\\n\\n          if (isTextOnlyCluster) {\\n            // Mantener posicion de cluster alineada con la columna centrada\\n            // sin tocar la alineacion interna del texto.\\n            var centeredClusterLeft = centerX - c.width / 2;\\n            if (isFinite(colReferenceCenterX)) {\\n              var maxSnapDelta = Math.min(120, info.usableW * 0.35);\\n              var sourceClusterCenterX = (c.left || 0) + c.width / 2;\\n              var sourceDriftX = isFinite(colSourceReferenceCenterX)\\n                ? (sourceClusterCenterX - colSourceReferenceCenterX)\\n                : NaN;\\n              if (isFinite(sourceDriftX) && Math.abs(sourceDriftX) <= maxSnapDelta) {\\n                var driftedClusterLeft = (colReferenceCenterX + sourceDriftX) - c.width / 2;\\n                var driftedClusterCenterX = driftedClusterLeft + c.width / 2;\\n                var maxRefDrift = Math.max(12, info.usableW * 0.06);\\n                if (Math.abs(driftedClusterCenterX - centerX) <= maxRefDrift) {\\n                  centeredClusterLeft = driftedClusterLeft;\\n                }\\n              }\\n            }\\n            clusterLeft = centeredClusterLeft;\\n            shouldCenterTextWithinCluster = false;\\n          }\\n\\n          // Guard rail: en apilado multi-columna, un cluster no debe quedar\\n          // desviado demasiado del eje central del layout mobile.\\n          var clusterCenterXNow = clusterLeft + c.width / 2;\\n          var maxCenterDrift = Math.max(24, info.usableW * 0.18);\\n          if (Math.abs(clusterCenterXNow - centerX) > maxCenterDrift) {\\n            mslLog(\"stack:cluster:centerFallback\", {\\n              g: g,\\n              j: j,\\n              prevLeft: +clusterLeft.toFixed(1),\\n              centerX: +centerX.toFixed(1),\\n              clusterCenterX: +clusterCenterXNow.toFixed(1),\\n              maxCenterDrift: +maxCenterDrift.toFixed(1),\\n              clusterW: +(c.width || 0).toFixed(1)\\n            });\\n            clusterLeft = centerX - c.width / 2;\\n          }\\n        }\\n        mslLog(\"stack:cluster\", {\\n          g: g,\\n          j: j,\\n          origTop: +c.top.toFixed(1),\\n          origLeft: +c.left.toFixed(1),\\n          newTop: +clusterTop.toFixed(1),\\n          newLeft: +clusterLeft.toFixed(1),\\n          h: +c.height.toFixed(1),\\n          w: +c.width.toFixed(1),\\n          forceCenter: forceCenter,\\n          keepCenter: keepCenter,\\n          items: c.items.length,\\n          colReferenceCenterX: (typeof colReferenceCenterX === \"number\" && isFinite(colReferenceCenterX)) ? +colReferenceCenterX.toFixed(1) : null,\\n          isTextOnlyCluster: isTextOnlyCluster,\\n          centerShortText: shouldCenterTextWithinCluster\\n        });\\n\\n        var textCount = 0;\\n        for (var tc=0; tc<c.items.length; tc++){\\n          if ((c.items[tc].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textCount++;\\n        }\\n        var linearizeCluster = (mode === \"rows\" && c.items.length > 1 && textCount >= 2);\\n        var clusterBottomUsed = clusterTop + c.height;\\n\\n        // Caso especial: en rows, si el cluster agrupa varios textos, lo\\n        // convertimos a flujo vertical centrado para evitar texto lado a lado.\\n        if (linearizeCluster){\\n          var allItems = c.items.slice();\\n          var nonText = allItems.filter(function(itx){\\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\";\\n          }).sort(function(a,b){\\n            if (a.top !== b.top) return a.top - b.top;\\n            return a.left - b.left;\\n          });\\n          var texts = allItems.filter(function(itx){\\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          }).sort(function(a,b){\\n            if (a.top !== b.top) return a.top - b.top;\\n            return a.left - b.left;\\n          });\\n\\n          // Orden sem\\xc3\\xa1ntico de lectura:\\n          // no-texto + texto m\\xc3\\xa1s cercano (debajo y por eje X), luego remanentes.\\n          var ordered = [];\\n          var usedText = {};\\n\\n          for (var nt=0; nt<nonText.length; nt++){\\n            var ntItem = nonText[nt];\\n            ordered.push(ntItem);\\n\\n            var ntCx = (ntItem.left || 0) + (ntItem.width || 0) / 2;\\n            var ntBottom = (ntItem.top || 0) + (ntItem.height || 0);\\n            var bestIdxTxt = -1;\\n            var bestScore = Infinity;\\n\\n            for (var tx=0; tx<texts.length; tx++){\\n              if (usedText[tx]) continue;\\n              var tItem = texts[tx];\\n              var tCx = (tItem.left || 0) + (tItem.width || 0) / 2;\\n              var vGapTxt = (tItem.top || 0) - ntBottom; // preferir texto debajo\\n              var hDistTxt = Math.abs(tCx - ntCx);\\n              var penaltyAbove = vGapTxt < -2 ? 10000 : 0;\\n              var score = penaltyAbove + Math.abs(vGapTxt) * 2 + hDistTxt;\\n              if (score < bestScore){\\n                bestScore = score;\\n                bestIdxTxt = tx;\\n              }\\n            }\\n\\n            if (bestIdxTxt >= 0){\\n              ordered.push(texts[bestIdxTxt]);\\n              usedText[bestIdxTxt] = true;\\n            }\\n          }\\n\\n          // Textos no emparejados\\n          for (var tx2=0; tx2<texts.length; tx2++){\\n            if (!usedText[tx2]) ordered.push(texts[tx2]);\\n          }\\n\\n          // Si no hubo no-texto, fallback simple por top/left\\n          if (!ordered.length) {\\n            ordered = allItems.sort(function(a,b){\\n              if (a.top !== b.top) return a.top - b.top;\\n              return a.left - b.left;\\n            });\\n          }\\n\\n          var localCursor = clusterTop;\\n          var prevIt = null;\\n          var prevTopApplied = clusterTop;\\n          var EXTRA_COL_BREAK_GAP = 8;\\n\\n          for (var li=0; li<ordered.length; li++){\\n            var lit = ordered[li];\\n\\n            var keepLayoutLin = (lit.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n            if (keepLayoutLin) continue;\\n\\n            var newTopLin = localCursor;\\n            if (prevIt){\\n              var gapOrigLin = lit.top - (prevIt.top + prevIt.height);\\n              if (!isFinite(gapOrigLin)) gapOrigLin = 0;\\n              var gapWantedLin = clamp(gapOrigLin * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\\n              var prevIsTextLin = (prevIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              var currIsTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              // Al pasar de \"texto final de columna\" a \"nuevo no-texto\" agregamos aire.\\n              if (prevIsTextLin && !currIsTextLin) gapWantedLin += EXTRA_COL_BREAK_GAP;\\n              newTopLin = prevTopApplied + prevIt.height + gapWantedLin;\\n            }\\n\\n            var newLeftLin = centerX - (lit.width || 0) / 2;\\n            var keepAlignLin = (lit.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\\n            if (keepAlignLin) newLeftLin = lit.left;\\n\\n            if (Math.abs(newTopLin - lit.top) > 0.5 || Math.abs(newLeftLin - lit.left) > 0.5) changed = true;\\n\\n            // En rows linealizado, forzamos centrado visual real de texto.\\n            var isTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n            if (isTextLin && !keepAlignLin) {\\n              lit.node.style.textAlign = \"center\";\\n              lit.node.style.transformOrigin = \"top center\";\\n              lit.node.style.setProperty(\"--text-zoom\", \"1\");\\n              var tfLin = lit.node.style.transform || \"\";\\n              if (tfLin.indexOf(\"translateX(\") !== -1) {\\n                lit.node.style.transform = tfLin.replace(/translateX([^)]*)/, \"translateX(0px)\");\\n              }\\n            }\\n\\n            var cssLeftLin = newLeftLin - (info.padL || 0);\\n            lit.node.style.top = newTopLin + \"px\";\\n            lit.node.style.left = cssLeftLin + \"px\";\\n            lit.node.style.right = \"auto\";\\n            lit.node.style.marginLeft = \"0px\";\\n\\n            prevIt = lit;\\n            prevTopApplied = newTopLin;\\n            localCursor = newTopLin + (lit.height || 0);\\n            if (localCursor > clusterBottomUsed) clusterBottomUsed = localCursor;\\n          }\\n\\n          colCursor = Math.max(colCursor, clusterBottomUsed);\\n          continue;\\n        }\\n\\n        // Aplicar a cada item preservando offsets relativos (solape intacto)\\n        for (var ii=0; ii<c.items.length; ii++){\\n          var it = c.items[ii];\\n          var isTextNode = (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n\\n          // Opt-out total del layout (decoraciones, etc.)\\n          var keepLayout = (it.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n          if (keepLayout) continue;\\n\\n          var newTop = clusterTop + (it._relTop || 0);\\n          var newLeft = clusterLeft + (it._relLeft || 0);\\n\\n          // Opt-out de centrado (mantener left original del item)\\n          var keepAlign = (it.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\\n          if (keepAlign) newLeft = it.left;\\n\\n          // En multi-col, neutralizamos SIEMPRE translateX(...) de textos\\n          // para que la posici\\xc3\\xb3n left calculada sea la referencia visual real.\\n          var isShortTextBox = false;\\n          var shouldRecenterTextItem = false;\\n          var recenterGuardBlocked = false;\\n          var centerByAlign = false;\\n          var targetTextCenterX = NaN;\\n          if (isTextNode && isMultiColLayout) {\\n            var tf = it.node.style.transform || \"\";\\n            if (tf.indexOf(\"translateX(\") !== -1) {\\n              it.node.style.transform = tf.replace(/translateX([^)]*)/, \"translateX(0px)\");\\n            }\\n            isShortTextBox = (it.width || 0) <= (info.usableW * 0.5) && (it.height || 0) <= 42;\\n            var taCurrent = ((it.node.style && it.node.style.textAlign) || \"\").toLowerCase();\\n            centerByAlign = taCurrent === \"center\";\\n            var shouldCenterVisualText =\\n              (shouldCenterTextWithinCluster || isShortTextBox || centerByAlign) &&\\n              !keepAlign;\\n            shouldRecenterTextItem =\\n              shouldCenterVisualText &&\\n              !isTextOnlyCluster &&\\n              isFinite(colReferenceCenterX);\\n            if (shouldRecenterTextItem) {\\n              var prevLeftTxt = newLeft;\\n              var currentCenterX = prevLeftTxt + (it.width || 0) / 2;\\n              var sourceItemCenterX = (it.left || 0) + (it.width || 0) / 2;\\n              var sourceDriftItemX = isFinite(colSourceReferenceCenterX)\\n                ? (sourceItemCenterX - colSourceReferenceCenterX)\\n                : NaN;\\n              var targetCenterX = colReferenceCenterX;\\n              // En textos centrados (o labels cortos forzados al centro),\\n              // no arrastramos drift horizontal del layout original para\\n              // evitar corrimientos laterales en mobile.\\n              var preserveSourceDrift =\\n                !centerByAlign &&\\n                !shouldCenterTextWithinCluster &&\\n                !isShortTextBox;\\n              if (preserveSourceDrift && isFinite(sourceDriftItemX)) {\\n                targetCenterX += sourceDriftItemX;\\n              }\\n              // Guard rail: si la recorreccion propuesta se aleja demasiado del\\n              // centro ya calculado para el cluster, no la aplicamos.\\n              var maxRecenterShift = Math.max(18, info.usableW * 0.08);\\n              if (isFinite(currentCenterX) && isFinite(targetCenterX) && Math.abs(targetCenterX - currentCenterX) > maxRecenterShift) {\\n                recenterGuardBlocked = true;\\n                shouldRecenterTextItem = false;\\n                targetCenterX = currentCenterX;\\n              }\\n              targetTextCenterX = targetCenterX;\\n              newLeft = targetCenterX - (it.width || 0) / 2;\\n              if (Math.abs(newLeft - prevLeftTxt) > 0.5) {\\n                mslLog(\"stack:item:textRecenter\", {\\n                  g: g,\\n                  j: j,\\n                  ii: ii,\\n                  prevLeft: +prevLeftTxt.toFixed(1),\\n                  newLeft: +newLeft.toFixed(1),\\n                  itemW: +(it.width || 0).toFixed(1),\\n                  refCenterX: +colReferenceCenterX.toFixed(1),\\n                  sourceRefCenterX: (typeof colSourceReferenceCenterX === \"number\" && isFinite(colSourceReferenceCenterX)) ? +colSourceReferenceCenterX.toFixed(1) : null,\\n                  sourceDriftX: isFinite(sourceDriftItemX) ? +sourceDriftItemX.toFixed(1) : null,\\n                  preserveSourceDrift: preserveSourceDrift,\\n                  guardBlocked: recenterGuardBlocked,\\n                  shortBox: isShortTextBox,\\n                  centerByAlign: centerByAlign\\n                });\\n              }\\n            }\\n            if (shouldCenterVisualText) {\\n              it.node.style.textAlign = \"center\";\\n              it.node.style.transformOrigin = \"top center\";\\n              // Evita encogimiento horizontal heredado que desplaza el centro visual.\\n              it.node.style.setProperty(\"--text-zoom\", \"1\");\\n            }\\n          }\\n\\n          var cssLeft = newLeft - (info.padL || 0);\\n          it.node.style.top = newTop + \"px\";\\n          it.node.style.left = cssLeft + \"px\";\\n          it.node.style.right = \"auto\";\\n          it.node.style.marginLeft = \"0px\";\\n\\n          // Correcci\\xc3\\xb3n final por posici\\xc3\\xb3n renderizada real del texto\\n          // (fuentes/transform pueden introducir desv\\xc3\\xados visuales sub-p\\xc3\\xadxel).\\n          if (isTextNode && isMultiColLayout && shouldRecenterTextItem) {\\n            var rrTxt = relRect(it.node, rootEl);\\n            var renderedCenterX = (rrTxt.left || 0) + (rrTxt.width || 0) / 2;\\n            var targetRenderCenterX = isFinite(targetTextCenterX) ? targetTextCenterX : colReferenceCenterX;\\n            var renderDelta = renderedCenterX - targetRenderCenterX;\\n            if (isFinite(renderDelta) && Math.abs(renderDelta) > 0.6) {\\n              var correctedLeft = newLeft - renderDelta;\\n              if (isFinite(correctedLeft)) {\\n                mslLog(\"stack:item:textRenderAdjust\", {\\n                  g: g,\\n                  j: j,\\n                  ii: ii,\\n                  prevLeft: +newLeft.toFixed(1),\\n                  correctedLeft: +correctedLeft.toFixed(1),\\n                  renderedCenterX: +renderedCenterX.toFixed(1),\\n                  refCenterX: +targetRenderCenterX.toFixed(1),\\n                  delta: +renderDelta.toFixed(2)\\n                });\\n                newLeft = correctedLeft;\\n                it.node.style.left = (newLeft - (info.padL || 0)) + \"px\";\\n              }\\n            }\\n          }\\n\\n          if (Math.abs(newTop - it.top) > 0.5 || Math.abs(newLeft - it.left) > 0.5) changed = true;\\n\\n          var itemBottom = newTop + (it.height || 0);\\n          if (itemBottom > clusterBottomUsed) clusterBottomUsed = itemBottom;\\n        }\\n\\n        // Avanza el cursor local al final del cluster\\n        colCursor = Math.max(colCursor, clusterBottomUsed);\\n      }\\n\\n      // Al terminar la columna, el cursor global baja hasta donde lleg\\xc3\\xb3 esta columna\\n      globalCursor = Math.max(globalCursor, colCursor);\\n    }\\n\\n    var needed = globalCursor + CFG.PAD_BOT;\\n    mslLog(\"stack:end\", {\\n      changed: changed,\\n      neededHeight: +needed.toFixed(1),\\n      finalCursor: +globalCursor.toFixed(1)\\n    });\\n    return { changed: changed, neededHeight: needed };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sczZ4QkEraUJQQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHN0YWNraW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHNcclxuZXhwb3J0IGZ1bmN0aW9uIGpzU3RhY2tpbmdCbG9jaygpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgXHJcbiAgLy8gQ2VudHJvIHJlYWwgZGVsIMODwqFyZWEgdXNhYmxlIChjb21wZW5zYSBwYWRkaW5nIHNhZmUtbGVmdC9yaWdodClcclxuICBmdW5jdGlvbiBjb21wdXRlQ2VudGVyWChyb290RWwpe1xyXG4gICAgdmFyIHJvb3RSZWN0ID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJvb3RXID0gcm9vdFJlY3Qud2lkdGggfHwgMDtcclxuXHJcbiAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbCk7XHJcbiAgICB2YXIgcGFkTCA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ0xlZnQpIHx8IDA7XHJcbiAgICB2YXIgcGFkUiA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSB8fCAwO1xyXG5cclxuICAgIHZhciB1c2FibGVXID0gTWF0aC5tYXgoMCwgcm9vdFcgLSBwYWRMIC0gcGFkUik7XHJcbiAgICB2YXIgY2VudGVyWCA9IHBhZEwgKyB1c2FibGVXIC8gMjsgLy8gY2VudHJvIGRlbCDDg8KhcmVhIHVzYWJsZVxyXG5cclxuICAgIHJldHVybiB7IHJvb3RXOiByb290VywgdXNhYmxlVzogdXNhYmxlVywgY2VudGVyWDogY2VudGVyWCwgcGFkTDogcGFkTCwgcGFkUjogcGFkUiB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xhbXAobiwgYSwgYil7XHJcbiAgICBpZiAoIWlzRmluaXRlKG4pKSByZXR1cm4gYTtcclxuICAgIHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCBuKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcGlsYSBDTFVTVEVSUyBwb3IgZ3JvdXBzIChjb2x1bW5hcy9maWxhcykgeTpcclxuICAgKiAtIG11ZXZlIGNhZGEgY2x1c3RlciBjb21vIGJsb3F1ZVxyXG4gICAqIC0gcHJlc2VydmEgc29sYXBlL3Bvc2ljaW9uZXMgcmVsYXRpdmFzIGRlbnRybyBkZWwgY2x1c3RlclxyXG4gICAqIC0gY2VudHJhIGVsIGNsdXN0ZXIgY29tbyBibG9xdWUgZW4gZWwgZWplIFggKHNpbiB0cmFuc2Zvcm0pXHJcbiAgICpcclxuICAgKiBEZXZ1ZWx2ZSBjaGFuZ2VkICsgbmVlZGVkSGVpZ2h0IChwYXJhIGV4cGFuZGlyIHNlY2Npw4PCs24pXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXBwbHlDbHVzdGVyU3RhY2soZ3JvdXBzLCByb290RWwsIENGRywgbW9kZSl7XHJcbiAgICB2YXIgaW5mbyA9IGNvbXB1dGVDZW50ZXJYKHJvb3RFbCk7XHJcbiAgICB2YXIgY2VudGVyWCA9IGluZm8uY2VudGVyWDtcclxuICAgIG1zbExvZyhcInN0YWNrOnN0YXJ0XCIsIHtcclxuICAgICAgZ3JvdXBDb3VudDogZ3JvdXBzLmxlbmd0aCxcclxuICAgICAgZ3JvdXBTaXplczogZ3JvdXBzLm1hcChmdW5jdGlvbihnKXsgcmV0dXJuIGcubGVuZ3RoOyB9KSxcclxuICAgICAgY2VudGVyWDogK2NlbnRlclgudG9GaXhlZCgxKSxcclxuICAgICAgdXNhYmxlVzogK2luZm8udXNhYmxlVy50b0ZpeGVkKDEpXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGlzTXVsdGlDb2xMYXlvdXQgPSAobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpO1xyXG5cclxuICAgIC8vIEVuIG11bHRpLWNvbHVtbmE6IGNhZGEgY29sdW1uYSBhcGlsYWRhIHNlIGNlbnRyYSBwb3Igc3UgcHJvcGlvIGJib3guXHJcbiAgICAvLyBBc8ODwq0sIGVsIGNlbnRybyBkZSBjYWRhIGNvbHVtbmEgY29pbmNpZGUgY29uIGVsIGNlbnRybyBkZSBwYW50YWxsYS5cclxuXHJcbiAgICAvLyAtLS0gQW5jaG9yIGdsb2JhbDogZMODwrNuZGUgZXN0YWJhIMOi4oKsxZNlbCBibG9xdWXDouKCrMKdIG9yaWdpbmFsbWVudGUgLS0tXHJcbiAgICB2YXIgZmlyc3RHcm91cCA9IGdyb3Vwc1swXSB8fCBbXTtcclxuICAgIHZhciBhbmNob3IgPSBJbmZpbml0eTtcclxuICAgIGZvciAodmFyIGk9MDtpPGZpcnN0R3JvdXAubGVuZ3RoO2krKyl7XHJcbiAgICAgIGFuY2hvciA9IE1hdGgubWluKGFuY2hvciwgZmlyc3RHcm91cFtpXS50b3ApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0Zpbml0ZShhbmNob3IpKSBhbmNob3IgPSBDRkcuUEFEX1RPUDtcclxuICAgIGFuY2hvciA9IE1hdGgubWF4KENGRy5QQURfVE9QLCBhbmNob3IpO1xyXG5cclxuICAgIC8vIEN1cnNvciBnbG9iYWw6IGTDg8KzbmRlIHRlcm1pbmEgZWwgY29udGVuaWRvIGFwaWxhZG8gaGFzdGEgYWhvcmFcclxuICAgIHZhciBnbG9iYWxDdXJzb3IgPSBhbmNob3I7XHJcblxyXG4gICAgLy8gU2VwYXJhY2nDg8KzbiBlbnRyZSBjb2x1bW5hcyBhcGlsYWRhcyAoaXpxLCBjZW50cm8sIGRlcilcclxuICAgIHZhciBHUk9VUF9HQVAgPSAxNDtcclxuXHJcbiAgICBmb3IgKHZhciBnPTA7IGc8Z3JvdXBzLmxlbmd0aDsgZysrKXtcclxuICAgICAgdmFyIGNvbCA9IGdyb3Vwc1tnXSB8fCBbXTtcclxuICAgICAgaWYgKCFjb2wubGVuZ3RoKSBjb250aW51ZTtcclxuICAgICAgdmFyIGNvbFJlZmVyZW5jZUNlbnRlclggPSBOYU47XHJcbiAgICAgIHZhciBjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYID0gTmFOO1xyXG4gICAgICB2YXIgbmFycm93Q2x1c3RlckNvdW50ID0gMDtcclxuICAgICAgdmFyIHdpZGVDbHVzdGVyQ291bnQgPSAwO1xyXG5cclxuICAgICAgLy8gTcODwql0cmljYXMgcG9yIGdydXBvIHNvbG8gcGFyYSBkZWJ1Zy5cclxuICAgICAgdmFyIGdyb3VwTWluTGVmdCA9IEluZmluaXR5O1xyXG4gICAgICB2YXIgZ3JvdXBNYXhSaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpe1xyXG4gICAgICAgIGZvciAodmFyIGdnPTA7IGdnPGNvbC5sZW5ndGg7IGdnKyspe1xyXG4gICAgICAgICAgZ3JvdXBNaW5MZWZ0ID0gTWF0aC5taW4oZ3JvdXBNaW5MZWZ0LCBjb2xbZ2ddLmxlZnQpO1xyXG4gICAgICAgICAgZ3JvdXBNYXhSaWdodCA9IE1hdGgubWF4KGdyb3VwTWF4UmlnaHQsIGNvbFtnZ10ubGVmdCArIGNvbFtnZ10ud2lkdGgpO1xyXG4gICAgICAgICAgdmFyIGNsdXN0ZXJXRGJnID0gTnVtYmVyKGNvbFtnZ10ud2lkdGggfHwgMCk7XHJcbiAgICAgICAgICBpZiAoY2x1c3RlcldEYmcgPD0gKGluZm8udXNhYmxlVyAqIDAuNzIpKSBuYXJyb3dDbHVzdGVyQ291bnQrKztcclxuICAgICAgICAgIGlmIChjbHVzdGVyV0RiZyA+PSAoaW5mby51c2FibGVXICogMC44OCkpIHdpZGVDbHVzdGVyQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGdyb3VwV2lkdGggPSBpc011bHRpQ29sTGF5b3V0ID8gTWF0aC5tYXgoMCwgZ3JvdXBNYXhSaWdodCAtIGdyb3VwTWluTGVmdCkgOiAwO1xyXG4gICAgICB2YXIgZ3JvdXBCYXNlTGVmdCA9IGlzTXVsdGlDb2xMYXlvdXQgPyAoY2VudGVyWCAtIGdyb3VwV2lkdGggLyAyKSA6IDA7XHJcbiAgICAgIHZhciBzdXNwaWNpb3VzV2lkZVNwYW4gPSBpc011bHRpQ29sTGF5b3V0ICYmXHJcbiAgICAgICAgY29sLmxlbmd0aCA+IDEgJiZcclxuICAgICAgICBncm91cFdpZHRoID49IChpbmZvLnVzYWJsZVcgKiAwLjg4KSAmJlxyXG4gICAgICAgIG5hcnJvd0NsdXN0ZXJDb3VudCA+PSAxICYmXHJcbiAgICAgICAgd2lkZUNsdXN0ZXJDb3VudCA+PSAxO1xyXG4gICAgICB2YXIgcHJlc2VydmVDb2x1bW5PZmZzZXRzID0gaXNNdWx0aUNvbExheW91dCAmJiAhc3VzcGljaW91c1dpZGVTcGFuO1xyXG5cclxuICAgICAgLy8gT2Zmc2V0IHZlcnRpY2FsIG9yaWdpbmFsIGRlIGVzdGEgY29sdW1uYSByZXNwZWN0byBkZWwgYW5jaG9yXHJcbiAgICAgIHZhciBjb2xNaW5Ub3AgPSBJbmZpbml0eTtcclxuICAgICAgZm9yICh2YXIgaz0wO2s8Y29sLmxlbmd0aDtrKyspe1xyXG4gICAgICAgIGNvbE1pblRvcCA9IE1hdGgubWluKGNvbE1pblRvcCwgY29sW2tdLnRvcCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc0Zpbml0ZShjb2xNaW5Ub3ApKSBjb2xNaW5Ub3AgPSBhbmNob3I7XHJcblxyXG4gICAgICB2YXIgY29sT2Zmc2V0ID0gY29sTWluVG9wIC0gYW5jaG9yO1xyXG4gICAgICB2YXIgY29sU3RhcnQgPSBnbG9iYWxDdXJzb3IgKyAoZyA9PT0gMCA/IDAgOiBHUk9VUF9HQVApICsgTWF0aC5tYXgoMCwgY29sT2Zmc2V0KTtcclxuICAgICAgbXNsTG9nKFwic3RhY2s6Z3JvdXA6c3RhcnRcIiwge1xyXG4gICAgICAgIGc6IGcsXHJcbiAgICAgICAgY29sU2l6ZTogY29sLmxlbmd0aCxcclxuICAgICAgICBjb2xNaW5Ub3A6ICtjb2xNaW5Ub3AudG9GaXhlZCgxKSxcclxuICAgICAgICBjb2xPZmZzZXQ6ICtjb2xPZmZzZXQudG9GaXhlZCgxKSxcclxuICAgICAgICBjb2xTdGFydDogK2NvbFN0YXJ0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgZ2xvYmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSksXHJcbiAgICAgICAgbW9kZTogbW9kZSxcclxuICAgICAgICBncm91cE1pbkxlZnQ6IGlzTXVsdGlDb2xMYXlvdXQgPyArZ3JvdXBNaW5MZWZ0LnRvRml4ZWQoMSkgOiBudWxsLFxyXG4gICAgICAgIGdyb3VwV2lkdGg6IGlzTXVsdGlDb2xMYXlvdXQgPyArZ3JvdXBXaWR0aC50b0ZpeGVkKDEpIDogbnVsbCxcclxuICAgICAgICBncm91cEJhc2VMZWZ0OiBpc011bHRpQ29sTGF5b3V0ID8gK2dyb3VwQmFzZUxlZnQudG9GaXhlZCgxKSA6IG51bGwsXHJcbiAgICAgICAgbmFycm93Q2x1c3RlckNvdW50OiBpc011bHRpQ29sTGF5b3V0ID8gbmFycm93Q2x1c3RlckNvdW50IDogbnVsbCxcclxuICAgICAgICB3aWRlQ2x1c3RlckNvdW50OiBpc011bHRpQ29sTGF5b3V0ID8gd2lkZUNsdXN0ZXJDb3VudCA6IG51bGwsXHJcbiAgICAgICAgcHJlc2VydmVDb2x1bW5PZmZzZXRzOiBpc011bHRpQ29sTGF5b3V0ID8gcHJlc2VydmVDb2x1bW5PZmZzZXRzIDogbnVsbFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEN1cnNvciBsb2NhbCBkZSBlc3RhIGNvbHVtbmFcclxuICAgICAgdmFyIGNvbEN1cnNvciA9IGNvbFN0YXJ0O1xyXG5cclxuICAgICAgZm9yICh2YXIgaj0wOyBqPGNvbC5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgdmFyIGMgPSBjb2xbal07XHJcblxyXG4gICAgICAgIC8vIFRvcCBkZWwgY2x1c3RlciBlbiBlbCBmbHVqbyBtb2JpbGVcclxuICAgICAgICB2YXIgY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgaWYgKGogPT09IDApIHtcclxuICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xDdXJzb3I7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBwcmV2QyA9IGNvbFtqLTFdO1xyXG4gICAgICAgICAgdmFyIHByZXZCb3R0b20gPSAoY2x1c3RlclRvcFByZXYgKyBwcmV2Qy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgIC8vIMOixZPigKYgR2FwIG9yaWdpbmFsIGVudHJlIGNsdXN0ZXJzIChjYW52YXMpXHJcbiAgICAgICAgICB2YXIgcHJldkJvdHRvbU9yaWcgPSAocHJldkMudG9wICsgcHJldkMuaGVpZ2h0KTtcclxuICAgICAgICAgIHZhciBnYXBPcmlnID0gYy50b3AgLSBwcmV2Qm90dG9tT3JpZztcclxuICAgICAgICAgIGlmICghaXNGaW5pdGUoZ2FwT3JpZykpIGdhcE9yaWcgPSAwO1xyXG5cclxuICAgICAgICAgIHZhciBvdmVybGFwSW5Tb3VyY2UgPSBnYXBPcmlnIDwgMDtcclxuICAgICAgICAgIGlmICgobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpICYmIG92ZXJsYXBJblNvdXJjZSkge1xyXG4gICAgICAgICAgICAvLyBTaSBlbiBlbCBvcmlnaW5hbCBlc3RlIGNsdXN0ZXIgY2FlIGRlbnRybyBkZWwgYW50ZXJpb3IsIHJlc3BldGFtb3NcclxuICAgICAgICAgICAgLy8gc3UgdG9wIHJlbGF0aXZvIHBhcmEgbm8gbWFuZGFybG8gYWwgZmluYWwgZGUgbGEgY29sdW1uYS5cclxuICAgICAgICAgICAgdmFyIHJlbFRvcEluQ29sID0gYy50b3AgLSBjb2xNaW5Ub3A7XHJcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUocmVsVG9wSW5Db2wpKSByZWxUb3BJbkNvbCA9IDA7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xTdGFydCArIE1hdGgubWF4KDAsIHJlbFRvcEluQ29sKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIMOixZPigKYgR2FwIMOi4oKsxZNtb2JpbGUtZnJpZW5kbHnDouKCrMKdOiBlc2NhbGFkbyArIGNsYW1wXHJcbiAgICAgICAgICAgIHZhciBnYXBXYW50ZWQgPSBjbGFtcChnYXBPcmlnICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XHJcblxyXG4gICAgICAgICAgICAvLyDDosWT4oCmIEFudGktc29sYXBlIGRlZmluaXRpdm86XHJcbiAgICAgICAgICAgIC8vICAgZWwgcHLDg8KzeGltbyBjbHVzdGVyIFNJRU1QUkUgZW1waWV6YSBkZXNwdcODwqlzIGRlbCBib3R0b20gcmVhbCBkZWwgYW50ZXJpb3IgKyBnYXBXYW50ZWRcclxuICAgICAgICAgICAgY2x1c3RlclRvcCA9IHByZXZCb3R0b20gKyBnYXBXYW50ZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBFbiBtdWx0aS1jb2x1bW5hIG51bmNhIGF2YW56YW1vcyBoYWNpYSBhcnJpYmEgcmVzcGVjdG8gYWwgZmx1am8geWEgY29uc3VtaWRvLlxyXG4gICAgICAgICAgICBpZiAoKG1vZGUgPT09IFwidHdvXCIgfHwgbW9kZSA9PT0gXCJ0aHJlZVwiKSAmJiBjbHVzdGVyVG9wIDwgY29sQ3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgY2x1c3RlclRvcCA9IGNvbEN1cnNvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR3VhcmRhbW9zIHBhcmEgZWwgcHLDg8KzeGltbyBsb29wXHJcbiAgICAgICAgdmFyIGNsdXN0ZXJUb3BQcmV2ID0gY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgLy8gw4LCv2NlbnRyYXIgZXN0ZSBjbHVzdGVyP1xyXG4gICAgICAgIHZhciBmb3JjZUNlbnRlciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBoYXNUZXh0SW5DbHVzdGVyID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGhhc05vblRleHRJbkNsdXN0ZXIgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciB0PTA7IHQ8Yy5pdGVtcy5sZW5ndGg7IHQrKyl7XHJcbiAgICAgICAgICB2YXIgaXNUZXh0VCA9IChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICBpZiAoaXNUZXh0VCkgaGFzVGV4dEluQ2x1c3RlciA9IHRydWU7XHJcbiAgICAgICAgICBlbHNlIGhhc05vblRleHRJbkNsdXN0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIpID09PSBcImZvcmNlXCIpIHtcclxuICAgICAgICAgICAgZm9yY2VDZW50ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb25lL3Jvd3M6IGNlbnRybyBwb3IgY2x1c3RlciAoY29tcG9ydGFtaWVudG8gb3JpZ2luYWwpXHJcbiAgICAgICAgLy8gdHdvL3RocmVlOiBhcGlsYXIgY2FkYSBjb2x1bW5hIGVuIGxhIG1pc21hIHJlZmVyZW5jaWEgWCxcclxuICAgICAgICAvLyBwcmVzZXJ2YW5kbyBvZmZzZXRzIGludGVybm9zIGRlIGVzYSBjb2x1bW5hLlxyXG4gICAgICAgIHZhciBrZWVwQ2VudGVyID0gZm9yY2VDZW50ZXIgPyB0cnVlIDogKGMud2lkdGggPCAoaW5mby51c2FibGVXICogMC45NSkpO1xyXG4gICAgICAgIHZhciBjbHVzdGVyTGVmdCA9IGtlZXBDZW50ZXIgPyAoY2VudGVyWCAtIGMud2lkdGggLyAyKSA6IGMubGVmdDtcclxuICAgICAgICB2YXIgaXNUZXh0T25seUNsdXN0ZXIgPSBoYXNUZXh0SW5DbHVzdGVyICYmICFoYXNOb25UZXh0SW5DbHVzdGVyO1xyXG4gICAgICAgIHZhciBzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlciA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpc011bHRpQ29sTGF5b3V0KSB7XHJcbiAgICAgICAgICAvLyBNb2RvIGxlY3R1cmEgbW9iaWxlIG11bHRpLWNvbDpcclxuICAgICAgICAgIC8vIHVzYXIgdW5hIG1pc21hIHJlZmVyZW5jaWEgWCBwYXJhIHRvZGEgbGEgY29sdW1uYSBhcGlsYWRhIHlcclxuICAgICAgICAgIC8vIHByZXNlcnZhciBlbCBvZmZzZXQgaG9yaXpvbnRhbCBvcmlnaW5hbCBkZSBjYWRhIGNsdXN0ZXIuXHJcbiAgICAgICAgICAvLyBFc3RvIG1hbnRpZW5lIGFsaW5lYWRvIHRleHRvL2Zvcm1hIGN1YW5kbyBsYSBjb2x1bW5hIHNlIHBhcnRlXHJcbiAgICAgICAgICAvLyBlbiB2YXJpb3MgY2x1c3RlcnMuXHJcbiAgICAgICAgICAvLyBTaSBlbCBiYm94IGRlIGxhIGNvbHVtbmEgcXVlZGEgY29udGFtaW5hZG8gcG9yIHVuIG91dGxpZXIgYW5jaG9cclxuICAgICAgICAgIC8vICh0aXBpY2FtZW50ZSB0ZXh0byksIGNlbnRyYXIgcG9yIG9mZnNldHMgZGVqYSBsYSBjb2x1bW5hIHBlZ2FkYVxyXG4gICAgICAgICAgLy8gYWwgYm9yZGU7IGVuIGVzZSBjYXNvIGNlbnRyYW1vcyBjYWRhIGNsdXN0ZXIgaW5kaXZpZHVhbG1lbnRlLlxyXG4gICAgICAgICAgaWYgKHByZXNlcnZlQ29sdW1uT2Zmc2V0cykge1xyXG4gICAgICAgICAgICB2YXIgcmVsQ2x1c3RlckxlZnQgPSAoYy5sZWZ0IHx8IDApIC0gKGdyb3VwTWluTGVmdCB8fCAwKTtcclxuICAgICAgICAgICAgY2x1c3RlckxlZnQgPSBncm91cEJhc2VMZWZ0ICsgcmVsQ2x1c3RlckxlZnQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQZXJtaXRlIGZvcnphciBjZW50cmFkbyBwb3IgY2x1c3RlciBzaSBlbCBub2RvIGxvIHBpZGUuXHJcbiAgICAgICAgICBpZiAoZm9yY2VDZW50ZXIpIGNsdXN0ZXJMZWZ0ID0gY2VudGVyWCAtIGMud2lkdGggLyAyO1xyXG5cclxuICAgICAgICAgIC8vIFNpIGVzdGEgY29sdW1uYSB0aWVuZSB1biBjbHVzdGVyIGNvbiBmb3JtYSAobyBtaXh0byksIHVzYW1vcyBzdVxyXG4gICAgICAgICAgLy8gY2VudHJvIGNvbW8gcmVmZXJlbmNpYSBwYXJhIGFsaW5lYXIgY2x1c3RlcnMgc29sby10ZXh0byBkZWJham8uXHJcbiAgICAgICAgICB2YXIgY2x1c3RlclJlZkNlbnRlclggPSBOYU47XHJcbiAgICAgICAgICBpZiAoaGFzTm9uVGV4dEluQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAvLyBSZWZlcmVuY2lhIGJhc2FkYSBlbiBpdGVtcyBuby10ZXh0byAoZm9ybWEvaWNvbm8pLCBubyBlbiB0b2RvIGVsXHJcbiAgICAgICAgICAgIC8vIGNsdXN0ZXIsIHBhcmEgcXVlIHRleHRvcyBsYXJnb3Mgbm8gZGVzcGxhY2VuIGVsIGNlbnRybyBkZSBjb2x1bW5hLlxyXG4gICAgICAgICAgICB2YXIgbnRNaW5SZWwgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG50TWF4UmVsID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBudGk9MDsgbnRpPGMuaXRlbXMubGVuZ3RoOyBudGkrKyl7XHJcbiAgICAgICAgICAgICAgdmFyIG50SXQgPSBjLml0ZW1zW250aV07XHJcbiAgICAgICAgICAgICAgdmFyIG50SXNUZXh0ID0gKG50SXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgICAgICBpZiAobnRJc1RleHQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIG50TWluUmVsID0gTWF0aC5taW4obnRNaW5SZWwsIChudEl0Ll9yZWxMZWZ0IHx8IDApKTtcclxuICAgICAgICAgICAgICBudE1heFJlbCA9IE1hdGgubWF4KG50TWF4UmVsLCAobnRJdC5fcmVsTGVmdCB8fCAwKSArIChudEl0LndpZHRoIHx8IDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSBOYU47XHJcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShudE1pblJlbCkgJiYgaXNGaW5pdGUobnRNYXhSZWwpICYmIG50TWF4UmVsID4gbnRNaW5SZWwpIHtcclxuICAgICAgICAgICAgICBjbHVzdGVyUmVmQ2VudGVyWCA9IGNsdXN0ZXJMZWZ0ICsgKChudE1pblJlbCArIG50TWF4UmVsKSAvIDIpO1xyXG4gICAgICAgICAgICAgIHNvdXJjZUNsdXN0ZXJSZWZDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArICgobnRNaW5SZWwgKyBudE1heFJlbCkgLyAyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjbHVzdGVyUmVmQ2VudGVyWCA9IGNsdXN0ZXJMZWZ0ICsgYy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclggPSBOdW1iZXIoY2x1c3RlclJlZkNlbnRlclgpO1xuICAgICAgICAgICAgY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCA9IE51bWJlcihzb3VyY2VDbHVzdGVyUmVmQ2VudGVyWCk7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvbFJlZmVyZW5jZUNlbnRlclgpKSBjb2xSZWZlcmVuY2VDZW50ZXJYID0gTmFOO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYKSkgY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWCA9IE5hTjtcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGlzVGV4dE9ubHlDbHVzdGVyKSB7XHJcbiAgICAgICAgICAgIC8vIE1hbnRlbmVyIHBvc2ljaW9uIGRlIGNsdXN0ZXIgYWxpbmVhZGEgY29uIGxhIGNvbHVtbmEgY2VudHJhZGFcclxuICAgICAgICAgICAgLy8gc2luIHRvY2FyIGxhIGFsaW5lYWNpb24gaW50ZXJuYSBkZWwgdGV4dG8uXHJcbiAgICAgICAgICAgIHZhciBjZW50ZXJlZENsdXN0ZXJMZWZ0ID0gY2VudGVyWCAtIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpIHtcclxuICAgICAgICAgICAgICB2YXIgbWF4U25hcERlbHRhID0gTWF0aC5taW4oMTIwLCBpbmZvLnVzYWJsZVcgKiAwLjM1KTtcclxuICAgICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlckNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0WCA9IGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXHJcbiAgICAgICAgICAgICAgICA/IChzb3VyY2VDbHVzdGVyQ2VudGVyWCAtIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXHJcbiAgICAgICAgICAgICAgICA6IE5hTjtcclxuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRYKSAmJiBNYXRoLmFicyhzb3VyY2VEcmlmdFgpIDw9IG1heFNuYXBEZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyaWZ0ZWRDbHVzdGVyTGVmdCA9IChjb2xSZWZlcmVuY2VDZW50ZXJYICsgc291cmNlRHJpZnRYKSAtIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyaWZ0ZWRDbHVzdGVyQ2VudGVyWCA9IGRyaWZ0ZWRDbHVzdGVyTGVmdCArIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heFJlZkRyaWZ0ID0gTWF0aC5tYXgoMTIsIGluZm8udXNhYmxlVyAqIDAuMDYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRyaWZ0ZWRDbHVzdGVyQ2VudGVyWCAtIGNlbnRlclgpIDw9IG1heFJlZkRyaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNlbnRlcmVkQ2x1c3RlckxlZnQgPSBkcmlmdGVkQ2x1c3RlckxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsdXN0ZXJMZWZ0ID0gY2VudGVyZWRDbHVzdGVyTGVmdDtcclxuICAgICAgICAgICAgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBHdWFyZCByYWlsOiBlbiBhcGlsYWRvIG11bHRpLWNvbHVtbmEsIHVuIGNsdXN0ZXIgbm8gZGViZSBxdWVkYXJcclxuICAgICAgICAgIC8vIGRlc3ZpYWRvIGRlbWFzaWFkbyBkZWwgZWplIGNlbnRyYWwgZGVsIGxheW91dCBtb2JpbGUuXHJcbiAgICAgICAgICB2YXIgY2x1c3RlckNlbnRlclhOb3cgPSBjbHVzdGVyTGVmdCArIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgdmFyIG1heENlbnRlckRyaWZ0ID0gTWF0aC5tYXgoMjQsIGluZm8udXNhYmxlVyAqIDAuMTgpO1xyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGNsdXN0ZXJDZW50ZXJYTm93IC0gY2VudGVyWCkgPiBtYXhDZW50ZXJEcmlmdCkge1xyXG4gICAgICAgICAgICBtc2xMb2coXCJzdGFjazpjbHVzdGVyOmNlbnRlckZhbGxiYWNrXCIsIHtcclxuICAgICAgICAgICAgICBnOiBnLFxyXG4gICAgICAgICAgICAgIGo6IGosXHJcbiAgICAgICAgICAgICAgcHJldkxlZnQ6ICtjbHVzdGVyTGVmdC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgIGNlbnRlclg6ICtjZW50ZXJYLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgY2x1c3RlckNlbnRlclg6ICtjbHVzdGVyQ2VudGVyWE5vdy50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgIG1heENlbnRlckRyaWZ0OiArbWF4Q2VudGVyRHJpZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICBjbHVzdGVyVzogKyhjLndpZHRoIHx8IDApLnRvRml4ZWQoMSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJMZWZ0ID0gY2VudGVyWCAtIGMud2lkdGggLyAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtc2xMb2coXCJzdGFjazpjbHVzdGVyXCIsIHtcbiAgICAgICAgICBnOiBnLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgb3JpZ1RvcDogK2MudG9wLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBvcmlnTGVmdDogK2MubGVmdC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgbmV3VG9wOiArY2x1c3RlclRvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgbmV3TGVmdDogK2NsdXN0ZXJMZWZ0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBoOiArYy5oZWlnaHQudG9GaXhlZCgxKSxcclxuICAgICAgICAgIHc6ICtjLndpZHRoLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICBmb3JjZUNlbnRlcjogZm9yY2VDZW50ZXIsXHJcbiAgICAgICAgICBrZWVwQ2VudGVyOiBrZWVwQ2VudGVyLFxyXG4gICAgICAgICAgaXRlbXM6IGMuaXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgY29sUmVmZXJlbmNlQ2VudGVyWDogKHR5cGVvZiBjb2xSZWZlcmVuY2VDZW50ZXJYID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGNvbFJlZmVyZW5jZUNlbnRlclgpKSA/ICtjb2xSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgIGlzVGV4dE9ubHlDbHVzdGVyOiBpc1RleHRPbmx5Q2x1c3RlcixcbiAgICAgICAgICBjZW50ZXJTaG9ydFRleHQ6IHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyXG4gICAgICAgIH0pO1xuXHJcbiAgICAgICAgdmFyIHRleHRDb3VudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgdGM9MDsgdGM8Yy5pdGVtcy5sZW5ndGg7IHRjKyspe1xyXG4gICAgICAgICAgaWYgKChjLml0ZW1zW3RjXS5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiKSB0ZXh0Q291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxpbmVhcml6ZUNsdXN0ZXIgPSAobW9kZSA9PT0gXCJyb3dzXCIgJiYgYy5pdGVtcy5sZW5ndGggPiAxICYmIHRleHRDb3VudCA+PSAyKTtcclxuICAgICAgICB2YXIgY2x1c3RlckJvdHRvbVVzZWQgPSBjbHVzdGVyVG9wICsgYy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIENhc28gZXNwZWNpYWw6IGVuIHJvd3MsIHNpIGVsIGNsdXN0ZXIgYWdydXBhIHZhcmlvcyB0ZXh0b3MsIGxvXHJcbiAgICAgICAgLy8gY29udmVydGltb3MgYSBmbHVqbyB2ZXJ0aWNhbCBjZW50cmFkbyBwYXJhIGV2aXRhciB0ZXh0byBsYWRvIGEgbGFkby5cclxuICAgICAgICBpZiAobGluZWFyaXplQ2x1c3Rlcil7XHJcbiAgICAgICAgICB2YXIgYWxsSXRlbXMgPSBjLml0ZW1zLnNsaWNlKCk7XHJcbiAgICAgICAgICB2YXIgbm9uVGV4dCA9IGFsbEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdHgpe1xyXG4gICAgICAgICAgICByZXR1cm4gKGl0eC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgIT09IFwiMVwiO1xyXG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdmFyIHRleHRzID0gYWxsSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0eCl7XHJcbiAgICAgICAgICAgIHJldHVybiAoaXR4Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgIGlmIChhLnRvcCAhPT0gYi50b3ApIHJldHVybiBhLnRvcCAtIGIudG9wO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gT3JkZW4gc2Vtw4PCoW50aWNvIGRlIGxlY3R1cmE6XHJcbiAgICAgICAgICAvLyBuby10ZXh0byArIHRleHRvIG3Dg8KhcyBjZXJjYW5vIChkZWJham8geSBwb3IgZWplIFgpLCBsdWVnbyByZW1hbmVudGVzLlxyXG4gICAgICAgICAgdmFyIG9yZGVyZWQgPSBbXTtcclxuICAgICAgICAgIHZhciB1c2VkVGV4dCA9IHt9O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIG50PTA7IG50PG5vblRleHQubGVuZ3RoOyBudCsrKXtcclxuICAgICAgICAgICAgdmFyIG50SXRlbSA9IG5vblRleHRbbnRdO1xyXG4gICAgICAgICAgICBvcmRlcmVkLnB1c2gobnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBudEN4ID0gKG50SXRlbS5sZWZ0IHx8IDApICsgKG50SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBudEJvdHRvbSA9IChudEl0ZW0udG9wIHx8IDApICsgKG50SXRlbS5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIHZhciBiZXN0SWR4VHh0ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBiZXN0U2NvcmUgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHR4PTA7IHR4PHRleHRzLmxlbmd0aDsgdHgrKyl7XHJcbiAgICAgICAgICAgICAgaWYgKHVzZWRUZXh0W3R4XSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgdmFyIHRJdGVtID0gdGV4dHNbdHhdO1xyXG4gICAgICAgICAgICAgIHZhciB0Q3ggPSAodEl0ZW0ubGVmdCB8fCAwKSArICh0SXRlbS53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHZHYXBUeHQgPSAodEl0ZW0udG9wIHx8IDApIC0gbnRCb3R0b207IC8vIHByZWZlcmlyIHRleHRvIGRlYmFqb1xyXG4gICAgICAgICAgICAgIHZhciBoRGlzdFR4dCA9IE1hdGguYWJzKHRDeCAtIG50Q3gpO1xyXG4gICAgICAgICAgICAgIHZhciBwZW5hbHR5QWJvdmUgPSB2R2FwVHh0IDwgLTIgPyAxMDAwMCA6IDA7XHJcbiAgICAgICAgICAgICAgdmFyIHNjb3JlID0gcGVuYWx0eUFib3ZlICsgTWF0aC5hYnModkdhcFR4dCkgKiAyICsgaERpc3RUeHQ7XHJcbiAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKXtcclxuICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgICAgICAgYmVzdElkeFR4dCA9IHR4O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJlc3RJZHhUeHQgPj0gMCl7XHJcbiAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKHRleHRzW2Jlc3RJZHhUeHRdKTtcclxuICAgICAgICAgICAgICB1c2VkVGV4dFtiZXN0SWR4VHh0XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBUZXh0b3Mgbm8gZW1wYXJlamFkb3NcclxuICAgICAgICAgIGZvciAodmFyIHR4Mj0wOyB0eDI8dGV4dHMubGVuZ3RoOyB0eDIrKyl7XHJcbiAgICAgICAgICAgIGlmICghdXNlZFRleHRbdHgyXSkgb3JkZXJlZC5wdXNoKHRleHRzW3R4Ml0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNpIG5vIGh1Ym8gbm8tdGV4dG8sIGZhbGxiYWNrIHNpbXBsZSBwb3IgdG9wL2xlZnRcclxuICAgICAgICAgIGlmICghb3JkZXJlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgb3JkZXJlZCA9IGFsbEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgICBpZiAoYS50b3AgIT09IGIudG9wKSByZXR1cm4gYS50b3AgLSBiLnRvcDtcclxuICAgICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgbG9jYWxDdXJzb3IgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIHByZXZJdCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgcHJldlRvcEFwcGxpZWQgPSBjbHVzdGVyVG9wO1xyXG4gICAgICAgICAgdmFyIEVYVFJBX0NPTF9CUkVBS19HQVAgPSA4O1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGxpPTA7IGxpPG9yZGVyZWQubGVuZ3RoOyBsaSsrKXtcclxuICAgICAgICAgICAgdmFyIGxpdCA9IG9yZGVyZWRbbGldO1xyXG5cclxuICAgICAgICAgICAgdmFyIGtlZXBMYXlvdXRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgICAgaWYgKGtlZXBMYXlvdXRMaW4pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1RvcExpbiA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgICBpZiAocHJldkl0KXtcclxuICAgICAgICAgICAgICB2YXIgZ2FwT3JpZ0xpbiA9IGxpdC50b3AgLSAocHJldkl0LnRvcCArIHByZXZJdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZ2FwT3JpZ0xpbikpIGdhcE9yaWdMaW4gPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBnYXBXYW50ZWRMaW4gPSBjbGFtcChnYXBPcmlnTGluICogKENGRy5HQVBfU0NBTEUgfHwgMSksIENGRy5NSU5fR0FQLCBDRkcuTUFYX0dBUCk7XHJcbiAgICAgICAgICAgICAgdmFyIHByZXZJc1RleHRMaW4gPSAocHJldkl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgdmFyIGN1cnJJc1RleHRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgICAgLy8gQWwgcGFzYXIgZGUgXCJ0ZXh0byBmaW5hbCBkZSBjb2x1bW5hXCIgYSBcIm51ZXZvIG5vLXRleHRvXCIgYWdyZWdhbW9zIGFpcmUuXHJcbiAgICAgICAgICAgICAgaWYgKHByZXZJc1RleHRMaW4gJiYgIWN1cnJJc1RleHRMaW4pIGdhcFdhbnRlZExpbiArPSBFWFRSQV9DT0xfQlJFQUtfR0FQO1xyXG4gICAgICAgICAgICAgIG5ld1RvcExpbiA9IHByZXZUb3BBcHBsaWVkICsgcHJldkl0LmhlaWdodCArIGdhcFdhbnRlZExpbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ld0xlZnRMaW4gPSBjZW50ZXJYIC0gKGxpdC53aWR0aCB8fCAwKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBrZWVwQWxpZ25MaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtYWxpZ25cIikgfHwgXCJcIikgPT09IFwia2VlcFwiO1xyXG4gICAgICAgICAgICBpZiAoa2VlcEFsaWduTGluKSBuZXdMZWZ0TGluID0gbGl0LmxlZnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3VG9wTGluIC0gbGl0LnRvcCkgPiAwLjUgfHwgTWF0aC5hYnMobmV3TGVmdExpbiAtIGxpdC5sZWZ0KSA+IDAuNSkgY2hhbmdlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBFbiByb3dzIGxpbmVhbGl6YWRvLCBmb3J6YW1vcyBjZW50cmFkbyB2aXN1YWwgcmVhbCBkZSB0ZXh0by5cclxuICAgICAgICAgICAgdmFyIGlzVGV4dExpbiA9IChsaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgICAgaWYgKGlzVGV4dExpbiAmJiAha2VlcEFsaWduTGluKSB7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcInRvcCBjZW50ZXJcIjtcclxuICAgICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgICB2YXIgdGZMaW4gPSBsaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gfHwgXCJcIjtcclxuICAgICAgICAgICAgICBpZiAodGZMaW4uaW5kZXhPZihcInRyYW5zbGF0ZVgoXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gdGZMaW4ucmVwbGFjZSgvdHJhbnNsYXRlWFxcKFteKV0qXFwpLywgXCJ0cmFuc2xhdGVYKDBweClcIik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY3NzTGVmdExpbiA9IG5ld0xlZnRMaW4gLSAoaW5mby5wYWRMIHx8IDApO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS50b3AgPSBuZXdUb3BMaW4gKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLmxlZnQgPSBjc3NMZWZ0TGluICsgXCJweFwiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgICBsaXQubm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcclxuXHJcbiAgICAgICAgICAgIHByZXZJdCA9IGxpdDtcclxuICAgICAgICAgICAgcHJldlRvcEFwcGxpZWQgPSBuZXdUb3BMaW47XHJcbiAgICAgICAgICAgIGxvY2FsQ3Vyc29yID0gbmV3VG9wTGluICsgKGxpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEN1cnNvciA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcGxpY2FyIGEgY2FkYSBpdGVtIHByZXNlcnZhbmRvIG9mZnNldHMgcmVsYXRpdm9zIChzb2xhcGUgaW50YWN0bylcbiAgICAgICAgZm9yICh2YXIgaWk9MDsgaWk8Yy5pdGVtcy5sZW5ndGg7IGlpKyspe1xuICAgICAgICAgIHZhciBpdCA9IGMuaXRlbXNbaWldO1xuICAgICAgICAgIHZhciBpc1RleHROb2RlID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG5cbiAgICAgICAgICAvLyBPcHQtb3V0IHRvdGFsIGRlbCBsYXlvdXQgKGRlY29yYWNpb25lcywgZXRjLilcbiAgICAgICAgICB2YXIga2VlcExheW91dCA9IChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBMYXlvdXQpIGNvbnRpbnVlO1xuXHJcbiAgICAgICAgICB2YXIgbmV3VG9wID0gY2x1c3RlclRvcCArIChpdC5fcmVsVG9wIHx8IDApO1xyXG4gICAgICAgICAgdmFyIG5ld0xlZnQgPSBjbHVzdGVyTGVmdCArIChpdC5fcmVsTGVmdCB8fCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IGRlIGNlbnRyYWRvIChtYW50ZW5lciBsZWZ0IG9yaWdpbmFsIGRlbCBpdGVtKVxuICAgICAgICAgIHZhciBrZWVwQWxpZ24gPSAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1hbGlnblwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBBbGlnbikgbmV3TGVmdCA9IGl0LmxlZnQ7XG5cclxuICAgICAgICAgIC8vIEVuIG11bHRpLWNvbCwgbmV1dHJhbGl6YW1vcyBTSUVNUFJFIHRyYW5zbGF0ZVgoLi4uKSBkZSB0ZXh0b3NcclxuICAgICAgICAgIC8vIHBhcmEgcXVlIGxhIHBvc2ljacODwrNuIGxlZnQgY2FsY3VsYWRhIHNlYSBsYSByZWZlcmVuY2lhIHZpc3VhbCByZWFsLlxyXG4gICAgICAgICAgdmFyIGlzU2hvcnRUZXh0Qm94ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNob3VsZFJlY2VudGVyVGV4dEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVjZW50ZXJHdWFyZEJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2VudGVyQnlBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0YXJnZXRUZXh0Q2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZSAmJiBpc011bHRpQ29sTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZiA9IGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIGlmICh0Zi5pbmRleE9mKFwidHJhbnNsYXRlWChcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0Zi5yZXBsYWNlKC90cmFuc2xhdGVYXFwoW14pXSpcXCkvLCBcInRyYW5zbGF0ZVgoMHB4KVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1Nob3J0VGV4dEJveCA9IChpdC53aWR0aCB8fCAwKSA8PSAoaW5mby51c2FibGVXICogMC41KSAmJiAoaXQuaGVpZ2h0IHx8IDApIDw9IDQyO1xyXG4gICAgICAgICAgICB2YXIgdGFDdXJyZW50ID0gKChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBjZW50ZXJCeUFsaWduID0gdGFDdXJyZW50ID09PSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2VudGVyVmlzdWFsVGV4dCA9XHJcbiAgICAgICAgICAgICAgKHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyIHx8IGlzU2hvcnRUZXh0Qm94IHx8IGNlbnRlckJ5QWxpZ24pICYmXHJcbiAgICAgICAgICAgICAgIWtlZXBBbGlnbjtcclxuICAgICAgICAgICAgc2hvdWxkUmVjZW50ZXJUZXh0SXRlbSA9XG4gICAgICAgICAgICAgIHNob3VsZENlbnRlclZpc3VhbFRleHQgJiZcbiAgICAgICAgICAgICAgIWlzVGV4dE9ubHlDbHVzdGVyICYmXG4gICAgICAgICAgICAgIGlzRmluaXRlKGNvbFJlZmVyZW5jZUNlbnRlclgpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlY2VudGVyVGV4dEl0ZW0pIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZMZWZ0VHh0ID0gbmV3TGVmdDtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDZW50ZXJYID0gcHJldkxlZnRUeHQgKyAoaXQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgICB2YXIgc291cmNlSXRlbUNlbnRlclggPSAoaXQubGVmdCB8fCAwKSArIChpdC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VEcmlmdEl0ZW1YID0gaXNGaW5pdGUoY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgICA/IChzb3VyY2VJdGVtQ2VudGVyWCAtIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXG4gICAgICAgICAgICAgICAgOiBOYU47XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRDZW50ZXJYID0gY29sUmVmZXJlbmNlQ2VudGVyWDtcbiAgICAgICAgICAgICAgLy8gRW4gdGV4dG9zIGNlbnRyYWRvcyAobyBsYWJlbHMgY29ydG9zIGZvcnphZG9zIGFsIGNlbnRybyksXHJcbiAgICAgICAgICAgICAgLy8gbm8gYXJyYXN0cmFtb3MgZHJpZnQgaG9yaXpvbnRhbCBkZWwgbGF5b3V0IG9yaWdpbmFsIHBhcmFcclxuICAgICAgICAgICAgICAvLyBldml0YXIgY29ycmltaWVudG9zIGxhdGVyYWxlcyBlbiBtb2JpbGUuXHJcbiAgICAgICAgICAgICAgdmFyIHByZXNlcnZlU291cmNlRHJpZnQgPVxyXG4gICAgICAgICAgICAgICAgIWNlbnRlckJ5QWxpZ24gJiZcclxuICAgICAgICAgICAgICAgICFzaG91bGRDZW50ZXJUZXh0V2l0aGluQ2x1c3RlciAmJlxyXG4gICAgICAgICAgICAgICAgIWlzU2hvcnRUZXh0Qm94O1xyXG4gICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVNvdXJjZURyaWZ0ICYmIGlzRmluaXRlKHNvdXJjZURyaWZ0SXRlbVgpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyWCArPSBzb3VyY2VEcmlmdEl0ZW1YO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEd1YXJkIHJhaWw6IHNpIGxhIHJlY29ycmVjY2lvbiBwcm9wdWVzdGEgc2UgYWxlamEgZGVtYXNpYWRvIGRlbFxuICAgICAgICAgICAgICAvLyBjZW50cm8geWEgY2FsY3VsYWRvIHBhcmEgZWwgY2x1c3Rlciwgbm8gbGEgYXBsaWNhbW9zLlxuICAgICAgICAgICAgICB2YXIgbWF4UmVjZW50ZXJTaGlmdCA9IE1hdGgubWF4KDE4LCBpbmZvLnVzYWJsZVcgKiAwLjA4KTtcbiAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGN1cnJlbnRDZW50ZXJYKSAmJiBpc0Zpbml0ZSh0YXJnZXRDZW50ZXJYKSAmJiBNYXRoLmFicyh0YXJnZXRDZW50ZXJYIC0gY3VycmVudENlbnRlclgpID4gbWF4UmVjZW50ZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgIHJlY2VudGVyR3VhcmRCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzaG91bGRSZWNlbnRlclRleHRJdGVtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyWCA9IGN1cnJlbnRDZW50ZXJYO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldFRleHRDZW50ZXJYID0gdGFyZ2V0Q2VudGVyWDtcbiAgICAgICAgICAgICAgbmV3TGVmdCA9IHRhcmdldENlbnRlclggLSAoaXQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3TGVmdCAtIHByZXZMZWZ0VHh0KSA+IDAuNSkge1xuICAgICAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOml0ZW06dGV4dFJlY2VudGVyXCIsIHtcbiAgICAgICAgICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgICAgICAgICBqOiBqLFxyXG4gICAgICAgICAgICAgICAgICBpaTogaWksXHJcbiAgICAgICAgICAgICAgICAgIHByZXZMZWZ0OiArcHJldkxlZnRUeHQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgbmV3TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgaXRlbVc6ICsoaXQud2lkdGggfHwgMCkudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgcmVmQ2VudGVyWDogK2NvbFJlZmVyZW5jZUNlbnRlclgudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgc291cmNlUmVmQ2VudGVyWDogKHR5cGVvZiBjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpKSA/ICtjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc291cmNlRHJpZnRYOiBpc0Zpbml0ZShzb3VyY2VEcmlmdEl0ZW1YKSA/ICtzb3VyY2VEcmlmdEl0ZW1YLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcHJlc2VydmVTb3VyY2VEcmlmdDogcHJlc2VydmVTb3VyY2VEcmlmdCxcbiAgICAgICAgICAgICAgICAgIGd1YXJkQmxvY2tlZDogcmVjZW50ZXJHdWFyZEJsb2NrZWQsXG4gICAgICAgICAgICAgICAgICBzaG9ydEJveDogaXNTaG9ydFRleHRCb3gsXG4gICAgICAgICAgICAgICAgICBjZW50ZXJCeUFsaWduOiBjZW50ZXJCeUFsaWduXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRDZW50ZXJWaXN1YWxUZXh0KSB7XHJcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgLy8gRXZpdGEgZW5jb2dpbWllbnRvIGhvcml6b250YWwgaGVyZWRhZG8gcXVlIGRlc3BsYXphIGVsIGNlbnRybyB2aXN1YWwuXHJcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBjc3NMZWZ0ID0gbmV3TGVmdCAtIChpbmZvLnBhZEwgfHwgMCk7XHJcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLnRvcCA9IG5ld1RvcCArIFwicHhcIjtcclxuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IGNzc0xlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICBpdC5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xyXG5cclxuICAgICAgICAgIC8vIENvcnJlY2Npw4PCs24gZmluYWwgcG9yIHBvc2ljacODwrNuIHJlbmRlcml6YWRhIHJlYWwgZGVsIHRleHRvXHJcbiAgICAgICAgICAvLyAoZnVlbnRlcy90cmFuc2Zvcm0gcHVlZGVuIGludHJvZHVjaXIgZGVzdsODwq1vcyB2aXN1YWxlcyBzdWItcMODwq14ZWwpLlxyXG4gICAgICAgICAgaWYgKGlzVGV4dE5vZGUgJiYgaXNNdWx0aUNvbExheW91dCAmJiBzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICB2YXIgcnJUeHQgPSByZWxSZWN0KGl0Lm5vZGUsIHJvb3RFbCk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRDZW50ZXJYID0gKHJyVHh0LmxlZnQgfHwgMCkgKyAocnJUeHQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgdmFyIHRhcmdldFJlbmRlckNlbnRlclggPSBpc0Zpbml0ZSh0YXJnZXRUZXh0Q2VudGVyWCkgPyB0YXJnZXRUZXh0Q2VudGVyWCA6IGNvbFJlZmVyZW5jZUNlbnRlclg7XG4gICAgICAgICAgICB2YXIgcmVuZGVyRGVsdGEgPSByZW5kZXJlZENlbnRlclggLSB0YXJnZXRSZW5kZXJDZW50ZXJYO1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUocmVuZGVyRGVsdGEpICYmIE1hdGguYWJzKHJlbmRlckRlbHRhKSA+IDAuNikge1xyXG4gICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRMZWZ0ID0gbmV3TGVmdCAtIHJlbmRlckRlbHRhO1xyXG4gICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb3JyZWN0ZWRMZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgbXNsTG9nKFwic3RhY2s6aXRlbTp0ZXh0UmVuZGVyQWRqdXN0XCIsIHtcclxuICAgICAgICAgICAgICAgICAgZzogZyxcclxuICAgICAgICAgICAgICAgICAgajogaixcclxuICAgICAgICAgICAgICAgICAgaWk6IGlpLFxyXG4gICAgICAgICAgICAgICAgICBwcmV2TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgY29ycmVjdGVkTGVmdDogK2NvcnJlY3RlZExlZnQudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWRDZW50ZXJYOiArcmVuZGVyZWRDZW50ZXJYLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgICAgIHJlZkNlbnRlclg6ICt0YXJnZXRSZW5kZXJDZW50ZXJYLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiArcmVuZGVyRGVsdGEudG9GaXhlZCgyKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBuZXdMZWZ0ID0gY29ycmVjdGVkTGVmdDtcclxuICAgICAgICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IChuZXdMZWZ0IC0gKGluZm8ucGFkTCB8fCAwKSkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdUb3AgLSBpdC50b3ApID4gMC41IHx8IE1hdGguYWJzKG5ld0xlZnQgLSBpdC5sZWZ0KSA+IDAuNSkgY2hhbmdlZCA9IHRydWU7XG5cclxuICAgICAgICAgIHZhciBpdGVtQm90dG9tID0gbmV3VG9wICsgKGl0LmhlaWdodCB8fCAwKTtcclxuICAgICAgICAgIGlmIChpdGVtQm90dG9tID4gY2x1c3RlckJvdHRvbVVzZWQpIGNsdXN0ZXJCb3R0b21Vc2VkID0gaXRlbUJvdHRvbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF2YW56YSBlbCBjdXJzb3IgbG9jYWwgYWwgZmluYWwgZGVsIGNsdXN0ZXJcclxuICAgICAgICBjb2xDdXJzb3IgPSBNYXRoLm1heChjb2xDdXJzb3IsIGNsdXN0ZXJCb3R0b21Vc2VkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWwgdGVybWluYXIgbGEgY29sdW1uYSwgZWwgY3Vyc29yIGdsb2JhbCBiYWphIGhhc3RhIGRvbmRlIGxsZWfDg8KzIGVzdGEgY29sdW1uYVxyXG4gICAgICBnbG9iYWxDdXJzb3IgPSBNYXRoLm1heChnbG9iYWxDdXJzb3IsIGNvbEN1cnNvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5lZWRlZCA9IGdsb2JhbEN1cnNvciArIENGRy5QQURfQk9UO1xyXG4gICAgbXNsTG9nKFwic3RhY2s6ZW5kXCIsIHtcclxuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcclxuICAgICAgbmVlZGVkSGVpZ2h0OiArbmVlZGVkLnRvRml4ZWQoMSksXHJcbiAgICAgIGZpbmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSlcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgY2hhbmdlZDogY2hhbmdlZCwgbmVlZGVkSGVpZ2h0OiBuZWVkZWQgfTtcclxuICB9XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc1N0YWNraW5nQmxvY2siLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartSectionLayout.ts":
/*!*********************************************************!*\
  !*** ./functions/src/utils/mobileSmartSectionLayout.ts ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMobileSmartSectionLayoutScript: () => (/* binding */ buildMobileSmartSectionLayoutScript)\n/* harmony export */ });\n/* harmony import */ var _mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobileSmartLayout */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/index.ts\");\n// functions/src/utils/mobileSmartSectionLayout.ts\n\nfunction buildMobileSmartSectionLayoutScript(opts) {\n    const cfg = (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.normalizeConfig)(opts);\n    return (0,_mobileSmartLayout__WEBPACK_IMPORTED_MODULE_0__.buildScript)(cfg);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRTZWN0aW9uTGF5b3V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBRWlCO0FBRTVELFNBQVNFLG9DQUFvQ0MsSUFBOEI7SUFDaEYsTUFBTUMsTUFBTUosbUVBQWVBLENBQUNHO0lBQzVCLE9BQU9GLCtEQUFXQSxDQUFDRztBQUNyQiIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcZnVuY3Rpb25zXFxzcmNcXHV0aWxzXFxtb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb25zL3NyYy91dGlscy9tb2JpbGVTbWFydFNlY3Rpb25MYXlvdXQudHNcclxuaW1wb3J0IHsgTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zIH0gZnJvbSBcIi4vbW9iaWxlU21hcnRMYXlvdXRcIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplQ29uZmlnLCBidWlsZFNjcmlwdCB9IGZyb20gXCIuL21vYmlsZVNtYXJ0TGF5b3V0XCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQob3B0czogTW9iaWxlU21hcnRMYXlvdXRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBjZmcgPSBub3JtYWxpemVDb25maWcob3B0cyk7XHJcbiAgcmV0dXJuIGJ1aWxkU2NyaXB0KGNmZyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUNvbmZpZyIsImJ1aWxkU2NyaXB0IiwiYnVpbGRNb2JpbGVTbWFydFNlY3Rpb25MYXlvdXRTY3JpcHQiLCJvcHRzIiwiY2ZnIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartSectionLayout.ts\n"));

/***/ })

}]);