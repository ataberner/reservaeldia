"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_functions_src_utils_generarHTMLDesdeSecciones_ts",{

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts":
/*!*****************************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/scriptTemplate.ts ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildScript: () => (/* binding */ buildScript)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/dom.ts\");\n/* harmony import */ var _fitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitScale */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/fitScale.ts\");\n/* harmony import */ var _ordering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordering */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/ordering.ts\");\n/* harmony import */ var _stacking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacking */ \"(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts\");\n// functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n\n\n\n\nfunction buildScript(cfg) {\n    if (!cfg.enabled) return \"\";\n    return '\\n<script>\\n(function(){\\n  var ENABLED = true;\\n  function readDebugFlag(name){\\n    try {\\n      var search = (window.location && window.location.search) ? window.location.search : \"\";\\n      var qp = new URLSearchParams(search);\\n      var qv = qp.get(name);\\n      if (qv === \"1\" || String(qv).toLowerCase() === \"true\") return true;\\n    } catch(_e1) {}\\n\\n    // srcDoc/about:srcdoc no suele tener querystring.\\n    try {\\n      if (window.parent && window.parent !== window && window.parent.location) {\\n        var pSearch = window.parent.location.search || \"\";\\n        var pQ = new URLSearchParams(pSearch);\\n        var pV = pQ.get(name);\\n        if (pV === \"1\" || String(pV).toLowerCase() === \"true\") return true;\\n      }\\n    } catch(_e2) {}\\n\\n    try {\\n      if (window.top && window.top !== window && window.top.location) {\\n        var tSearch = window.top.location.search || \"\";\\n        var tQ = new URLSearchParams(tSearch);\\n        var tV = tQ.get(name);\\n        if (tV === \"1\" || String(tV).toLowerCase() === \"true\") return true;\\n      }\\n    } catch(_e3) {}\\n\\n    try {\\n      var ls = window.localStorage ? window.localStorage.getItem(name) : null;\\n      if (ls === \"1\" || String(ls).toLowerCase() === \"true\") return true;\\n    } catch(_e4) {}\\n\\n    return false;\\n  }\\n  var MSL_DEBUG = readDebugFlag(\"mslDebug\");\\n  var MSL_VERBOSE = readDebugFlag(\"mslVerbose\");\\n  function dbg(label, payload){\\n    if (!MSL_DEBUG) return;\\n    if (arguments.length <= 1) {\\n      console.log(\"[MSL] \" + label);\\n      return;\\n    }\\n    if (typeof payload === \"string\") {\\n      console.log(\"[MSL] \" + label + \" \" + payload);\\n      return;\\n    }\\n    var pretty = \"\";\\n    try {\\n      pretty = JSON.stringify(payload, null, 2);\\n    } catch(e) {\\n      try { pretty = String(payload); } catch(_) { pretty = \"[unserializable]\"; }\\n    }\\n    console.log(\"[MSL] \" + label + \"\\\\n\" + pretty);\\n  }\\n  function mslLog(){\\n    if (!MSL_DEBUG) return;\\n    var args = Array.prototype.slice.call(arguments);\\n    if (!args.length) return;\\n    var label = String(args[0]);\\n    if (!MSL_VERBOSE) {\\n      var noisy = {\\n        \"section:nodeSources\": 1,\\n        \"section:baselineRestore\": 1,\\n        \"section:anchorSplit\": 1,\\n        \"section:clusters\": 1,\\n        \"order:three:candidates\": 1,\\n        \"order:three:spread\": 1,\\n        \"order:two:candidates\": 1,\\n        \"order:two:spread\": 1,\\n        \"order:one:candidates\": 1,\\n        \"order:rows:fallback\": 1\\n      };\\n      if (noisy[label]) return;\\n    }\\n    if (args.length === 1) {\\n      dbg(label);\\n      return;\\n    }\\n    if (args.length === 2) {\\n      dbg(label, args[1]);\\n      return;\\n    }\\n    dbg(label, args.slice(1));\\n  }\\n\\n  var CFG = {\\n    MIN_GAP: '.concat(cfg.minGapPx, \",\\n    MAX_GAP: \").concat(cfg.maxGapPx, \",\\n    GAP_SCALE: \").concat(cfg.gapScale, \",\\n\\n    PAD_TOP: \").concat(cfg.paddingTopPx, \",\\n    PAD_BOT: \").concat(cfg.paddingBottomPx, \",\\n\\n    ONLY_FIXED: \").concat(cfg.onlyFixedSections ? \"true\" : \"false\", \",\\n    ONLY_WHEN_REORDERED: \").concat(cfg.onlyWhenReordered ? \"true\" : \"false\", \",\\n\\n    ROW_TOL: \").concat(cfg.rowTolPx, \",\\n\\n    TWO_COL_SPREAD_RATIO: \").concat(cfg.twoColSpreadRatio, \",\\n    MIN_PER_COL_2: \").concat(cfg.minPerColumn2, \",\\n\\n    THREE_COL_SPREAD_RATIO: \").concat(cfg.threeColSpreadRatio, \",\\n    MIN_PER_COL_3: \").concat(cfg.minPerColumn3, \",\\n\\n    FIT_MIN_SCALE: \").concat(cfg.fitMinScale, \",\\n    FIT_MAX_SCALE: \").concat(cfg.fitMaxScale, \",\\n    FIT_TARGET_WIDTH_RATIO: \").concat(cfg.fitTargetWidthRatio, \",\\n    FIT_MIN_FILL_RATIO: \").concat(cfg.fitMinFillRatio, \"\\n  };\\n\\n  \").concat((0,_dom__WEBPACK_IMPORTED_MODULE_0__.jsDomHelpersBlock)(), \"\\n\\n  \").concat((0,_ordering__WEBPACK_IMPORTED_MODULE_2__.jsOrderingBlock)(), \"\\n\\n  \").concat((0,_stacking__WEBPACK_IMPORTED_MODULE_3__.jsStackingBlock)(), \"\\n\\n  \").concat((0,_fitScale__WEBPACK_IMPORTED_MODULE_1__.jsFitScaleBlock)(), '\\n\\n  function expandFixedSection(sec, neededHeight){\\n    var currentH = sec.getBoundingClientRect().height || 0;\\n    if (neededHeight > currentH + 1) {\\n      sec.style.height = Math.ceil(neededHeight) + \"px\";\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function shouldProcessSection(sec){\\n    if(!sec) return false;\\n    if(!CFG.ONLY_FIXED) return true;\\n    var modo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n    return modo === \"fijo\";\\n  }\\n\\n  function restoreNodeBaseline(node){\\n    if (!node) return 0;\\n    var restored = 0;\\n\\n    if (!node.hasAttribute(\"data-msl-orig-top\")) {\\n      node.setAttribute(\"data-msl-orig-top\", node.style.top || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-left\")) {\\n      node.setAttribute(\"data-msl-orig-left\", node.style.left || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-transform\")) {\\n      node.setAttribute(\"data-msl-orig-transform\", node.style.transform || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-text-align\")) {\\n      node.setAttribute(\"data-msl-orig-text-align\", node.style.textAlign || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-transform-origin\")) {\\n      node.setAttribute(\"data-msl-orig-transform-origin\", node.style.transformOrigin || \"\");\\n    }\\n    if (!node.hasAttribute(\"data-msl-orig-text-zoom\")) {\\n      node.setAttribute(\"data-msl-orig-text-zoom\", node.style.getPropertyValue(\"--text-zoom\") || \"\");\\n    }\\n\\n    var origTop = node.getAttribute(\"data-msl-orig-top\");\\n    var origLeft = node.getAttribute(\"data-msl-orig-left\");\\n    var origTransform = node.getAttribute(\"data-msl-orig-transform\");\\n    var origTextAlign = node.getAttribute(\"data-msl-orig-text-align\");\\n    var origTransformOrigin = node.getAttribute(\"data-msl-orig-transform-origin\");\\n    var origTextZoom = node.getAttribute(\"data-msl-orig-text-zoom\");\\n\\n    if (origTop != null && node.style.top !== origTop) {\\n      node.style.top = origTop;\\n      restored++;\\n    }\\n    if (origLeft != null && node.style.left !== origLeft) {\\n      node.style.left = origLeft;\\n      restored++;\\n    }\\n    if (origTransform != null && node.style.transform !== origTransform) {\\n      node.style.transform = origTransform;\\n      restored++;\\n    }\\n    if (origTextAlign != null && node.style.textAlign !== origTextAlign) {\\n      if (origTextAlign) node.style.textAlign = origTextAlign;\\n      else node.style.removeProperty(\"text-align\");\\n      restored++;\\n    }\\n    if (origTransformOrigin != null && node.style.transformOrigin !== origTransformOrigin) {\\n      if (origTransformOrigin) node.style.transformOrigin = origTransformOrigin;\\n      else node.style.removeProperty(\"transform-origin\");\\n      restored++;\\n    }\\n    if (origTextZoom != null) {\\n      var currentTextZoom = node.style.getPropertyValue(\"--text-zoom\") || \"\";\\n      if (currentTextZoom !== origTextZoom) {\\n        if (origTextZoom) node.style.setProperty(\"--text-zoom\", origTextZoom);\\n        else node.style.removeProperty(\"--text-zoom\");\\n        restored++;\\n      }\\n    }\\n\\n    node.style.right = \"auto\";\\n    node.style.marginLeft = \"0px\";\\n    return restored;\\n  }\\n\\n  function runOnce(){\\n    if(!ENABLED) return;\\n    if(!isMobile()) {\\n      Array.from(document.querySelectorAll(\".sec\")).forEach(function(sec){\\n        var content = sec.querySelector(\".sec-content\");\\n        if(!content) return;\\n        var bleed = sec.querySelector(\".sec-bleed\");\\n        resetSectionFitScale(sec, content, bleed);\\n        var nodesAllDesktop = getObjNodes(sec);\\n        for (var nd=0; nd<nodesAllDesktop.length; nd++) {\\n          restoreNodeBaseline(nodesAllDesktop[nd]);\\n        }\\n        sec.setAttribute(\"data-msl-fit-scale\", \"1\");\\n      });\\n      return;\\n    }\\n\\n    var secs = Array.from(document.querySelectorAll(\".sec\"));\\n    if(!secs.length) return;\\n\\n    secs.forEach(function(sec){\\n      var secIndex = secs.indexOf(sec);\\n      var secModo = (sec.getAttribute(\"data-modo\") || \"fijo\").toLowerCase();\\n      var allowReflow = shouldProcessSection(sec);\\n      mslLog(\"section:start\", { secIndex: secIndex, modo: secModo, allowReflow: allowReflow });\\n\\n      var content = sec.querySelector(\".sec-content\");\\n      if(!content) return;\\n      var bleed = sec.querySelector(\".sec-bleed\");\\n      resetSectionFitScale(sec, content, bleed);\\n      var nodesAll = getObjNodes(sec);\\n\\n      var reflowElementsDump = [];\\n      function buildReflowElementsDump(items, contentWNow){\\n        if (!MSL_DEBUG) return;\\n        var list = (items || []);\\n        var maxItems = 120;\\n        var out = [];\\n        for (var iDump=0; iDump<list.length && iDump<maxItems; iDump++){\\n          var itDump = list[iDump];\\n          if (!itDump || !itDump.node) continue;\\n          var nDump = itDump.node;\\n          var textRaw = ((nDump.textContent || \"\").trim()).replace(/s+/g, \" \");\\n          var isTextDump = (nDump.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          var clsDump = (nDump.className && typeof nDump.className === \"string\") ? nDump.className : \"\";\\n          var rootZone = (nDump.closest && nDump.closest(\".sec-bleed\")) ? \"bleed\" : \"content\";\\n          out.push({\\n            i: iDump,\\n            kind: isTextDump ? \"texto\" : String((nDump.tagName || \"\").toLowerCase()),\\n            zone: rootZone,\\n            top: +Number(itDump.top || 0).toFixed(1),\\n            left: +Number(itDump.left || 0).toFixed(1),\\n            w: +Number(itDump.width || 0).toFixed(1),\\n            h: +Number(itDump.height || 0).toFixed(1),\\n            right: +Number((itDump.left || 0) + (itDump.width || 0)).toFixed(1),\\n            bottom: +Number((itDump.top || 0) + (itDump.height || 0)).toFixed(1),\\n            cx: +Number((itDump.left || 0) + ((itDump.width || 0) / 2)).toFixed(1),\\n            wRatio: contentWNow > 1 ? +Number((itDump.width || 0) / contentWNow).toFixed(3) : null,\\n            className: clsDump,\\n            mobileLayout: nDump.getAttribute(\"data-mobile-layout\") || \"\",\\n            mobileRole: nDump.getAttribute(\"data-mobile-role\") || \"\",\\n            mobileCluster: nDump.getAttribute(\"data-mobile-cluster\") || \"\",\\n            mobileClusterId: nDump.getAttribute(\"data-mobile-cluster-id\") || \"\",\\n            mobileCenter: nDump.getAttribute(\"data-mobile-center\") || \"\",\\n            mobileAlign: nDump.getAttribute(\"data-mobile-align\") || \"\",\\n            mobileFit: nDump.getAttribute(\"data-mobile-fit\") || \"\",\\n            textAlign: (nDump.style && nDump.style.textAlign) ? nDump.style.textAlign : \"\",\\n            textSample: isTextDump ? textRaw.slice(0, 90) : \"\"\\n          });\\n        }\\n        reflowElementsDump = out;\\n      }\\n\\n      function logReflowDecision(reason, extra){\\n        if (!MSL_DEBUG) return;\\n        var payload = {\\n          secIndex: secIndex,\\n          secModo: secModo,\\n          allowReflow: allowReflow,\\n          totalNodes: (nodesAll || []).length,\\n          reason: String(reason || \"\"),\\n          details: extra || {}\\n        };\\n        mslLog(\"section:reflow:decision\", payload);\\n      }\\n\\n      function finalizeSection(minNeededHeight, preserveBottomGap){\\n        var gap = Number.isFinite(preserveBottomGap) ? Math.max(0, Number(preserveBottomGap)) : 0;\\n        var fit = applySectionFitScale(\\n          sec,\\n          content,\\n          bleed,\\n          nodesAll,\\n          secModo,\\n          CFG,\\n          { secIndex: secIndex },\\n          { preserveBottomGap: gap }\\n        );\\n        var fitNeeded = (fit && Number.isFinite(fit.neededHeight)) ? Number(fit.neededHeight) : 0;\\n        var neededHeight = Math.max(Number(minNeededHeight || 0), fitNeeded);\\n        mslLog(\"section:heightFinal\", {\\n          secIndex: secIndex,\\n          mode: secModo,\\n          minNeededHeight: +Number(minNeededHeight || 0).toFixed(1),\\n          fitNeededHeight: +fitNeeded.toFixed(1),\\n          preserveBottomGap: +gap.toFixed(1),\\n          finalNeededHeight: +neededHeight.toFixed(1)\\n        });\\n        if (secModo === \"fijo\" && neededHeight > 0) {\\n          expandFixedSection(sec, neededHeight);\\n        }\\n      }\\n\\n      if(!nodesAll.length) {\\n        logReflowDecision(\"skip:noNodes\", { willApplyReflow: false });\\n        finalizeSection(0, 0);\\n        return;\\n      }\\n\\n      var debugCounts = {\\n        secIndex: secIndex,\\n        contentObj: content ? content.querySelectorAll(\".objeto\").length : 0,\\n        bleedObj: bleed ? bleed.querySelectorAll(\".objeto\").length : 0,\\n        contentAbs: content ? Array.from(content.querySelectorAll(\"*\")).filter(function(el){\\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\\n        }).length : 0,\\n        bleedAbs: bleed ? Array.from(bleed.querySelectorAll(\"*\")).filter(function(el){\\n          return !!(el && el.style && (el.style.position || \"\").toLowerCase() === \"absolute\" && el.style.top && el.style.left);\\n        }).length : 0\\n      };\\n      mslLog(\"section:nodeSources\", debugCounts);\\n\\n      if (MSL_VERBOSE) {\\n        mslLog(\"section:nodesAll:raw\", {\\n          secIndex: secIndex,\\n          total: nodesAll.length,\\n          nodes: nodesAll.map(function(n, i){\\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\\n            var parentCls = (n.parentElement && n.parentElement.className && typeof n.parentElement.className === \"string\")\\n              ? n.parentElement.className\\n              : \"\";\\n            return {\\n              i: i,\\n              tag: (n.tagName || \"\").toLowerCase(),\\n              cls: cls,\\n              parentCls: parentCls,\\n              top: n.style ? n.style.top : \"\",\\n              left: n.style ? n.style.left : \"\",\\n              pos: n.style ? n.style.position : \"\",\\n              text: ((n.textContent || \"\").trim()).slice(0, 40)\\n            };\\n          })\\n        });\\n        try {\\n          var flat = nodesAll.map(function(n, i){\\n            var cls = (n.className && typeof n.className === \"string\") ? n.className : \"\";\\n            var txt = ((n.textContent || \"\").trim()).replace(/\\\\s+/g, \" \").slice(0, 60);\\n            return \"#\" + i\\n              + \" tag=\" + String((n.tagName || \"\").toLowerCase())\\n              + \" cls=\" + cls\\n              + \" pos=\" + (n.style ? n.style.position : \"\")\\n              + \" top=\" + (n.style ? n.style.top : \"\")\\n              + \" left=\" + (n.style ? n.style.left : \"\")\\n              + \" text=\" + txt;\\n          });\\n          mslLog(\"section:nodesAll:flat\", \"sec=\" + secIndex + \" total=\" + nodesAll.length + \" :: \" + flat.join(\" | \"));\\n        } catch(e) {}\\n      }\\n      var restoredCount = 0;\\n      nodesAll.forEach(function(node){\\n        restoredCount += restoreNodeBaseline(node);\\n      });\\n      mslLog(\"section:baselineRestore\", { secIndex: secIndex, nodes: nodesAll.length, restored: restoredCount });\\n\\n      // Rect del content (m\\xe9tricas reales)\\n      var contentRect = content.getBoundingClientRect();\\n      var contentW = contentRect.width || 0;\\n      var secCurrentH = sec.getBoundingClientRect().height || 0;\\n      var baseHeightAttr = \"data-msl-base-height\";\\n      if (!sec.hasAttribute(baseHeightAttr)) {\\n        sec.setAttribute(baseHeightAttr, String(secCurrentH));\\n      }\\n      var baseSecHeight = parseFloat(sec.getAttribute(baseHeightAttr) || \"\");\\n      if (!isFinite(baseSecHeight) || baseSecHeight <= 0) baseSecHeight = secCurrentH;\\n\\n      // items (rects) en coordenadas del content (TODOS)\\n      var itemsAll = nodesAll.map(function(node){\\n        var rc = relRect(node, content);\\n        return {\\n          node: node,\\n          top: rc.top,\\n          left: rc.left,\\n          height: rc.height,\\n          width: rc.width\\n        };\\n      });\\n      buildReflowElementsDump(itemsAll, contentW);\\n      mslLog(\"section:reflow:elements\", {\\n        secIndex: secIndex,\\n        secModo: secModo,\\n        contentW: +Number(contentW || 0).toFixed(1),\\n        total: reflowElementsDump.length,\\n        elements: reflowElementsDump\\n      });\\n      if (MSL_VERBOSE) {\\n        mslLog(\"section:itemsAll\", {\\n          secIndex: secIndex,\\n          total: itemsAll.length,\\n          items: itemsAll.map(function(it, idx){\\n            return {\\n              i: idx,\\n              kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\\n              top: +it.top.toFixed(1),\\n              left: +it.left.toFixed(1),\\n              w: +it.width.toFixed(1),\\n              h: +it.height.toFixed(1),\\n              textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\\n            };\\n          })\\n        });\\n      }\\n\\n      // Preservar el \"aire\" inferior original de la seccion tras el reflow.\\n      var maxOriginalBottom = 0;\\n      for (var ib=0; ib<itemsAll.length; ib++){\\n        var itb = itemsAll[ib];\\n        var btm = (itb.top || 0) + (itb.height || 0);\\n        if (btm > maxOriginalBottom) maxOriginalBottom = btm;\\n      }\\n      var baseBottomGap = Math.max(0, baseSecHeight - maxOriginalBottom);\\n\\n      // Si todo mide 0 (fonts no listas), reintentamos luego\\n      var anyValidAll = itemsAll.some(function(it){ return it.height > 0.5; });\\n      if(!anyValidAll) {\\n        logReflowDecision(\"skip:invalidRects\", {\\n          willApplyReflow: false,\\n          allHeightsTiny: true\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      if (!allowReflow || nodesAll.length < 2) {\\n        logReflowDecision(\"skip:notEligible\", {\\n          willApplyReflow: false,\\n          allowReflow: allowReflow,\\n          totalNodes: nodesAll.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      function detectHeroLikeCentralText(items, rootW){\\n        var out = {\\n          isHero: false,\\n          reason: \"\",\\n          textCount: 0,\\n          textColumnCount: 0,\\n          textColumns: [],\\n          singleTextColumn: false,\\n          maxTextWidthRatio: null,\\n          widthRatio: null,\\n          centerDelta: null,\\n          centerTol: null,\\n          centeredByAlign: false,\\n          centeredByGeometry: false,\\n          decorNear: 0,\\n          decorLeft: 0,\\n          decorRight: 0,\\n          decorInvadingTextColumn: 0\\n        };\\n        if (!items || !items.length || !rootW || rootW <= 0) {\\n          out.reason = \"noItemsOrWidth\";\\n          return out;\\n        }\\n\\n        var textItems = items.filter(function(it){\\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\") return false;\\n          var tw = Number(it.width || 0);\\n          var th = Number(it.height || 0);\\n          return tw > 2 && th > 2;\\n        });\\n        out.textCount = textItems.length;\\n        if (!textItems.length) {\\n          out.reason = \"noText\";\\n          return out;\\n        }\\n\\n        var explicitHero = false;\\n        for (var eh=0; eh<textItems.length; eh++){\\n          var roleEh = (textItems[eh].node.getAttribute(\"data-mobile-role\") || \"\").toLowerCase();\\n          if (roleEh === \"hero\") {\\n            explicitHero = true;\\n            break;\\n          }\\n        }\\n\\n        var colTol = Math.max(18, rootW * 0.14);\\n        var textCols = [];\\n        for (var tc=0; tc<textItems.length; tc++){\\n          var txt = textItems[tc];\\n          var txtCx = Number(txt.left || 0) + Number(txt.width || 0) / 2;\\n          var attached = false;\\n          for (var cc=0; cc<textCols.length; cc++){\\n            if (Math.abs(txtCx - textCols[cc].cx) <= colTol) {\\n              var nCol = textCols[cc].count + 1;\\n              textCols[cc].cx = ((textCols[cc].cx * textCols[cc].count) + txtCx) / nCol;\\n              textCols[cc].count = nCol;\\n              textCols[cc].minLeft = Math.min(textCols[cc].minLeft, Number(txt.left || 0));\\n              textCols[cc].maxRight = Math.max(textCols[cc].maxRight, Number(txt.left || 0) + Number(txt.width || 0));\\n              textCols[cc].minTop = Math.min(textCols[cc].minTop, Number(txt.top || 0));\\n              textCols[cc].maxBottom = Math.max(textCols[cc].maxBottom, Number(txt.top || 0) + Number(txt.height || 0));\\n              attached = true;\\n              break;\\n            }\\n          }\\n          if (!attached) {\\n            textCols.push({\\n              cx: txtCx,\\n              count: 1,\\n              minLeft: Number(txt.left || 0),\\n              maxRight: Number(txt.left || 0) + Number(txt.width || 0),\\n              minTop: Number(txt.top || 0),\\n              maxBottom: Number(txt.top || 0) + Number(txt.height || 0)\\n            });\\n          }\\n        }\\n        textCols.sort(function(a,b){ return a.cx - b.cx; });\\n        out.textColumnCount = textCols.length;\\n        out.singleTextColumn = textCols.length === 1;\\n        out.textColumns = textCols.map(function(col){\\n          return {\\n            cx: +Number(col.cx || 0).toFixed(1),\\n            count: col.count,\\n            left: +Number(col.minLeft || 0).toFixed(1),\\n            right: +Number(col.maxRight || 0).toFixed(1),\\n            top: +Number(col.minTop || 0).toFixed(1),\\n            bottom: +Number(col.maxBottom || 0).toFixed(1)\\n          };\\n        });\\n        if (!out.singleTextColumn) {\\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"multiTextColumns\";\\n          out.isHero = explicitHero;\\n          return out;\\n        }\\n\\n        var centerX = rootW / 2;\\n        var textCol = textCols[0];\\n        var textCenterX = Number(textCol.cx || centerX);\\n        var centerDelta = Math.abs(textCenterX - centerX);\\n        var centerTol = Math.max(18, rootW * 0.12);\\n        out.centerDelta = +centerDelta.toFixed(1);\\n        out.centerTol = +centerTol.toFixed(1);\\n\\n        var centeredAlignCount = 0;\\n        var maxTextWidthRatio = 0;\\n        var textTop = Infinity;\\n        var textBottom = -Infinity;\\n        for (var tix=0; tix<textItems.length; tix++){\\n          var t = textItems[tix];\\n          var ta = (t.node && t.node.style && t.node.style.textAlign)\\n            ? String(t.node.style.textAlign).toLowerCase()\\n            : \"\";\\n          if (ta === \"center\") centeredAlignCount++;\\n          var wRatio = Number(t.width || 0) / Math.max(1, rootW);\\n          if (wRatio > maxTextWidthRatio) maxTextWidthRatio = wRatio;\\n          textTop = Math.min(textTop, Number(t.top || 0));\\n          textBottom = Math.max(textBottom, Number(t.top || 0) + Number(t.height || 0));\\n        }\\n        out.maxTextWidthRatio = +maxTextWidthRatio.toFixed(3);\\n        out.widthRatio = out.maxTextWidthRatio;\\n        out.centeredByAlign = centeredAlignCount >= Math.max(1, Math.ceil(textItems.length * 0.5));\\n        out.centeredByGeometry = centerDelta <= centerTol;\\n        if (!out.centeredByAlign && !out.centeredByGeometry) {\\n          out.reason = explicitHero ? \"explicitHeroRole\" : \"singleTextColumnNotCentered\";\\n          out.isHero = explicitHero;\\n          return out;\\n        }\\n\\n        // Evita marcar como hero textos sueltos muy chicos.\\n        if (textItems.length < 2 && maxTextWidthRatio < 0.28 && !explicitHero) {\\n          out.reason = \"textTooSmall\";\\n          return out;\\n        }\\n\\n        if (!isFinite(textTop) || !isFinite(textBottom) || textBottom <= textTop) {\\n          textTop = 0;\\n          textBottom = 0;\\n        }\\n        var nearTop = textTop - Math.max(28, (textBottom - textTop) * 0.2);\\n        var nearBottom = textBottom + Math.max(36, (textBottom - textTop) * 0.35);\\n        var invadePad = Math.max(24, rootW * 0.17);\\n        var invadeLeft = textCenterX - invadePad;\\n        var invadeRight = textCenterX + invadePad;\\n\\n        var decorNear = 0;\\n        var decorLeft = 0;\\n        var decorRight = 0;\\n        var decorInvading = 0;\\n\\n        for (var iHero=0; iHero<items.length; iHero++){\\n          var it = items[iHero];\\n          if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") continue;\\n\\n          var w = Number(it.width || 0);\\n          var h = Number(it.height || 0);\\n          if (w < 8 || h < 8) continue;\\n\\n          var top = Number(it.top || 0);\\n          var bottom = top + h;\\n          var inBand = !(bottom < nearTop || top > nearBottom);\\n          if (!inBand) continue;\\n\\n          decorNear++;\\n          var cx = Number(it.left || 0) + w / 2;\\n          if (cx < textCenterX - 8) decorLeft++;\\n          else if (cx > textCenterX + 8) decorRight++;\\n\\n          var left = Number(it.left || 0);\\n          var right = left + w;\\n          if (right > invadeLeft && left < invadeRight) decorInvading++;\\n        }\\n\\n        out.decorNear = decorNear;\\n        out.decorLeft = decorLeft;\\n        out.decorRight = decorRight;\\n        out.decorInvadingTextColumn = decorInvading;\\n\\n        var decorAround = (decorLeft > 0 && decorRight > 0) || decorNear >= 3;\\n        var centeredSingleTextColumn = out.singleTextColumn && (out.centeredByAlign || out.centeredByGeometry);\\n        out.isHero = explicitHero || centeredSingleTextColumn;\\n        out.reason = out.isHero\\n          ? (\\n            explicitHero\\n              ? \"explicitHeroRole\"\\n              : (decorInvading > 0\\n                ? \"singleCenteredTextColumnDecorInvades\"\\n                : (decorAround\\n                  ? \"singleCenteredTextColumnWithDecor\"\\n                  : \"singleCenteredTextColumn\"))\\n          )\\n          : \"noHeroSignal\";\\n        return out;\\n      }\\n\\n      function detectInlinePairNoReflow(flowItems, allItems, rootW, CFG){\\n        var out = {\\n          skip: false,\\n          reason: \"\",\\n          totalFlow: flowItems ? flowItems.length : 0,\\n          totalAll: allItems ? allItems.length : 0,\\n          rowDelta: null,\\n          rowTol: null,\\n          pairSpan: null,\\n          pairSpanRatio: null,\\n          fitsTogether: false,\\n          bothSmall: false,\\n          smallWLimit: null,\\n          smallHLimit: null,\\n          widths: [],\\n          heights: []\\n        };\\n        if (!flowItems || flowItems.length !== 2 || !allItems || allItems.length !== 2 || !rootW || rootW <= 0) {\\n          out.reason = \"notExactPair\";\\n          return out;\\n        }\\n\\n        var a = flowItems[0];\\n        var b = flowItems[1];\\n        var aW = Math.max(0, Number(a.width || 0));\\n        var bW = Math.max(0, Number(b.width || 0));\\n        var aH = Math.max(0, Number(a.height || 0));\\n        var bH = Math.max(0, Number(b.height || 0));\\n        out.widths = [+aW.toFixed(1), +bW.toFixed(1)];\\n        out.heights = [+aH.toFixed(1), +bH.toFixed(1)];\\n\\n        if (aW < 2 || bW < 2 || aH < 2 || bH < 2) {\\n          out.reason = \"invalidSizes\";\\n          return out;\\n        }\\n\\n        var rowTol = Math.max(12, Number((CFG && CFG.ROW_TOL) || 28) * 1.2);\\n        var rowDelta = Math.abs(Number(a.top || 0) - Number(b.top || 0));\\n        out.rowTol = +rowTol.toFixed(1);\\n        out.rowDelta = +rowDelta.toFixed(1);\\n        if (rowDelta > rowTol) {\\n          out.reason = \"notInlineRow\";\\n          return out;\\n        }\\n\\n        var smallWLimit = Math.max(74, rootW * 0.42);\\n        var smallHLimit = Math.max(34, rootW * 0.2);\\n        out.smallWLimit = +smallWLimit.toFixed(1);\\n        out.smallHLimit = +smallHLimit.toFixed(1);\\n        var bothSmall =\\n          aW <= smallWLimit &&\\n          bW <= smallWLimit &&\\n          aH <= smallHLimit &&\\n          bH <= smallHLimit;\\n        out.bothSmall = bothSmall;\\n        if (!bothSmall) {\\n          out.reason = \"pairNotSmall\";\\n          return out;\\n        }\\n\\n        var pairLeft = Math.min(Number(a.left || 0), Number(b.left || 0));\\n        var pairRight = Math.max(Number(a.left || 0) + aW, Number(b.left || 0) + bW);\\n        var pairSpan = Math.max(0, pairRight - pairLeft);\\n        var fitsTogether = pairSpan <= (rootW + 1);\\n        out.pairSpan = +pairSpan.toFixed(1);\\n        out.pairSpanRatio = +(pairSpan / Math.max(1, rootW)).toFixed(3);\\n        out.fitsTogether = fitsTogether;\\n\\n        if (fitsTogether) {\\n          out.skip = true;\\n          out.reason = \"smallInlinePairFits\";\\n          return out;\\n        }\\n\\n        out.reason = \"smallInlinePairOverflow\";\\n        return out;\\n      }\\n\\n      function enforceInlinePairGap(flowItems, rootEl, rootW){\\n        var out = {\\n          applied: false,\\n          reason: \"\",\\n          minGap: 6,\\n          gapBefore: null,\\n          gapAfter: null,\\n          need: null,\\n          moveLeft: 0,\\n          moveRight: 0,\\n          overflowBefore: false,\\n          overflowAfter: false\\n        };\\n        var rootPadLeft = 0;\\n        if (rootEl) {\\n          var rootCS = getComputedStyle(rootEl);\\n          rootPadLeft = parseFloat(rootCS.paddingLeft) || 0;\\n        }\\n        if (!flowItems || flowItems.length !== 2 || !rootEl || !rootW || rootW <= 0) {\\n          out.reason = \"notExactPair\";\\n          return out;\\n        }\\n\\n        var a = flowItems[0];\\n        var b = flowItems[1];\\n        if (!a || !b || !a.node || !b.node) {\\n          out.reason = \"missingNodes\";\\n          return out;\\n        }\\n\\n        var leftItem = Number(a.left || 0) <= Number(b.left || 0) ? a : b;\\n        var rightItem = (leftItem === a) ? b : a;\\n\\n        var rrL = relRect(leftItem.node, rootEl);\\n        var rrR = relRect(rightItem.node, rootEl);\\n        var lLeft = Number(rrL.left || 0);\\n        var lW = Number(rrL.width || 0);\\n        var rLeft = Number(rrR.left || 0);\\n        var rW = Number(rrR.width || 0);\\n        if (!isFinite(lLeft) || !isFinite(lW) || !isFinite(rLeft) || !isFinite(rW)) {\\n          out.reason = \"invalidRects\";\\n          return out;\\n        }\\n\\n        var gapBefore = rLeft - (lLeft + lW);\\n        out.gapBefore = +gapBefore.toFixed(2);\\n        out.overflowBefore = (lLeft < -0.5) || ((rLeft + rW) > (rootW + 0.5));\\n\\n        var need = Math.max(0, out.minGap - gapBefore);\\n        out.need = +need.toFixed(2);\\n        if (need <= 0.25) {\\n          out.reason = \"alreadySpaced\";\\n          out.gapAfter = out.gapBefore;\\n          out.overflowAfter = out.overflowBefore;\\n          return out;\\n        }\\n\\n        var availRight = Math.max(0, rootW - (rLeft + rW));\\n        var availLeft = Math.max(0, lLeft);\\n        var moveRight = Math.min(availRight, need);\\n        var remaining = Math.max(0, need - moveRight);\\n        var moveLeft = Math.min(availLeft, remaining);\\n\\n        if (moveRight <= 0.01 && moveLeft <= 0.01) {\\n          out.reason = \"noRoomToAdjust\";\\n          return out;\\n        }\\n\\n        if (moveRight > 0.01) {\\n          rightItem.node.style.left = ((Number(rightItem.left || 0) + moveRight) - rootPadLeft) + \"px\";\\n          rightItem.node.style.right = \"auto\";\\n          rightItem.node.style.marginLeft = \"0px\";\\n        }\\n        if (moveLeft > 0.01) {\\n          leftItem.node.style.left = ((Number(leftItem.left || 0) - moveLeft) - rootPadLeft) + \"px\";\\n          leftItem.node.style.right = \"auto\";\\n          leftItem.node.style.marginLeft = \"0px\";\\n        }\\n\\n        var rrL2 = relRect(leftItem.node, rootEl);\\n        var rrR2 = relRect(rightItem.node, rootEl);\\n        var lLeft2 = Number(rrL2.left || 0);\\n        var lW2 = Number(rrL2.width || 0);\\n        var rLeft2 = Number(rrR2.left || 0);\\n        var rW2 = Number(rrR2.width || 0);\\n        var gapAfter = rLeft2 - (lLeft2 + lW2);\\n\\n        out.moveRight = +moveRight.toFixed(2);\\n        out.moveLeft = +moveLeft.toFixed(2);\\n        out.gapAfter = isFinite(gapAfter) ? +gapAfter.toFixed(2) : null;\\n        out.overflowAfter = (lLeft2 < -0.5) || ((rLeft2 + rW2) > (rootW + 0.5));\\n        out.applied = (moveRight > 0.01 || moveLeft > 0.01);\\n        out.reason = out.applied ? \"applied\" : \"noChange\";\\n        if (isFinite(gapAfter) && gapAfter < -0.2) out.reason = \"appliedButStillOverlap\";\\n        return out;\\n      }\\n\\n      var prominentNonTextCount = itemsAll.filter(function(it){\\n        if ((it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") return false;\\n        var w = Number(it.width || 0);\\n        var h = Number(it.height || 0);\\n        if (w < Math.max(10, contentW * 0.06)) return false;\\n        if (h < Math.max(10, contentW * 0.04)) return false;\\n        return true;\\n      }).length;\\n      var allowHeuristicAnchors = prominentNonTextCount <= 1;\\n\\n      // ✅ Determinar qu\\xe9 nodos son \"ANCHOR\" (no se reflowean)\\n      // Regla: texto centrado + casi full-width => t\\xedtulo/hero, no mover.\\n      function isAnchorNode(it){\\n        var node = it.node;\\n\\n        // opt-out expl\\xedcito\\n        var keepLayout = (node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n        if (keepLayout) return true;\\n\\n        // anchor expl\\xedcito (si lo us\\xe1s)\\n        var role = (node.getAttribute(\"data-mobile-role\") || \"\");\\n        if (role === \"anchor\") return true;\\n\\n        // heur\\xedstica para textos\\n        var isText = (node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n        if (!isText) return false;\\n        if (!allowHeuristicAnchors) return false;\\n\\n        var ta = (node.style && node.style.textAlign) ? String(node.style.textAlign).toLowerCase() : \"\";\\n        if (!ta) {\\n          try {\\n            ta = String(getComputedStyle(node).textAlign || \"\").toLowerCase();\\n          } catch(_e) {}\\n        }\\n        if (ta !== \"center\") return false;\\n\\n        // solo si realmente ocupa casi todo el ancho usable\\n        // (esto evita romper textos centrados dentro de columnas)\\n        if (contentW > 0 && it.width >= contentW * 0.78) return true;\\n\\n        return false;\\n      }\\n\\n      // ✅ Flow = todo lo que NO es anchor\\n      var itemsFlow = itemsAll.filter(function(it){ return !isAnchorNode(it); });\\n      var itemsAnchor = itemsAll.filter(function(it){ return isAnchorNode(it); });\\n      mslLog(\"section:anchorSplit\", {\\n        secIndex: secIndex,\\n        anchors: itemsAnchor.length,\\n        flow: itemsFlow.length,\\n        prominentNonTextCount: prominentNonTextCount,\\n        allowHeuristicAnchors: allowHeuristicAnchors,\\n        anchorsDetail: itemsAnchor.map(function(it){\\n          return {\\n            kind: (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\" ? \"texto\" : (it.node.tagName || \"\").toLowerCase(),\\n            top: +it.top.toFixed(1),\\n            left: +it.left.toFixed(1),\\n            w: +it.width.toFixed(1),\\n            h: +it.height.toFixed(1),\\n            textAlign: (it.node.style && it.node.style.textAlign) ? it.node.style.textAlign : \"\"\\n          };\\n        })\\n      });\\n\\n      // Si no hay suficientes elementos reflowables, no hacemos nada\\n      if(itemsFlow.length < 2) {\\n        logReflowDecision(\"skip:flowTooSmall\", {\\n          willApplyReflow: false,\\n          flowCount: itemsFlow.length,\\n          anchorCount: itemsAnchor.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      // ✅ Para que \"altura necesaria\" no quede corta,\\n      // medimos el bottom m\\xe1ximo de anchors (en coords del content)\\n      var maxAnchorBottom = 0;\\n      itemsAll.forEach(function(it){\\n        if (!isAnchorNode(it)) return;\\n        var b = (it.top || 0) + (it.height || 0);\\n        if (b > maxAnchorBottom) maxAnchorBottom = b;\\n      });\\n\\n      // ✅ 1) agrupar por solape → clusters (SOLO FLOW)\\n      var clusters = buildOverlapClusters(itemsFlow);\\n      mslLog(\"section:clusters\", {\\n        secIndex: secIndex,\\n        count: clusters.length,\\n        clusters: clusters.map(function(c, idx){\\n          return {\\n            i: idx,\\n            top: +c.top.toFixed(1),\\n            left: +c.left.toFixed(1),\\n            w: +c.width.toFixed(1),\\n            h: +c.height.toFixed(1),\\n            cx: +c.cx.toFixed(1),\\n            items: c.items.length\\n          };\\n        })\\n      });\\n\\n      // ✅ 2) Detectar columnas/rows (SOLO FLOW)\\n      var rootW = contentW || 0;\\n      var ord = orderClustersForMobile(clusters, rootW, CFG);\\n      var groups = ord.groups;\\n      var mode = ord.mode;\\n      mslLog(\"section:ordering\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        rootW: rootW,\\n        groups: groups.map(function(grp, gi){\\n          return {\\n            g: gi,\\n            count: grp.length,\\n            tops: grp.map(function(c){ return +c.top.toFixed(1); }),\\n            lefts: grp.map(function(c){ return +c.left.toFixed(1); })\\n          };\\n        })\\n      });\\n\\n      var heroSignal = detectHeroLikeCentralText(itemsAll, rootW);\\n      mslLog(\"section:heroCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        isHero: heroSignal.isHero,\\n        reason: heroSignal.reason,\\n        textCount: heroSignal.textCount,\\n        textColumnCount: heroSignal.textColumnCount,\\n        singleTextColumn: heroSignal.singleTextColumn,\\n        textColumns: heroSignal.textColumns,\\n        maxTextWidthRatio: heroSignal.maxTextWidthRatio,\\n        widthRatio: heroSignal.widthRatio,\\n        centerDelta: heroSignal.centerDelta,\\n        centerTol: heroSignal.centerTol,\\n        centeredByAlign: heroSignal.centeredByAlign,\\n        centeredByGeometry: heroSignal.centeredByGeometry,\\n        decorNear: heroSignal.decorNear,\\n        decorLeft: heroSignal.decorLeft,\\n        decorRight: heroSignal.decorRight,\\n        decorInvadingTextColumn: heroSignal.decorInvadingTextColumn\\n      });\\n      if (heroSignal.isHero) {\\n        logReflowDecision(\"skip:heroCentralText\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          heroReason: heroSignal.reason,\\n          hero: heroSignal\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      var inlinePairSignal = detectInlinePairNoReflow(itemsFlow, itemsAll, rootW, CFG);\\n      mslLog(\"section:inlinePairCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        skip: inlinePairSignal.skip,\\n        reason: inlinePairSignal.reason,\\n        totalFlow: inlinePairSignal.totalFlow,\\n        totalAll: inlinePairSignal.totalAll,\\n        rowDelta: inlinePairSignal.rowDelta,\\n        rowTol: inlinePairSignal.rowTol,\\n        widths: inlinePairSignal.widths,\\n        heights: inlinePairSignal.heights,\\n        bothSmall: inlinePairSignal.bothSmall,\\n        smallWLimit: inlinePairSignal.smallWLimit,\\n        smallHLimit: inlinePairSignal.smallHLimit,\\n        pairSpan: inlinePairSignal.pairSpan,\\n        pairSpanRatio: inlinePairSignal.pairSpanRatio,\\n        fitsTogether: inlinePairSignal.fitsTogether\\n      });\\n      if (inlinePairSignal.skip) {\\n        var inlinePairAdjust = enforceInlinePairGap(itemsFlow, content, rootW);\\n        mslLog(\"section:inlinePairAdjust\", {\\n          secIndex: secIndex,\\n          mode: mode,\\n          adjust: inlinePairAdjust\\n        });\\n        logReflowDecision(\"skip:smallInlinePairFits\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          inlinePair: inlinePairSignal,\\n          inlinePairAdjust: inlinePairAdjust\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      // ✅ 3) Gate \"mejor de ambos mundos\":\\n      // - Si es \"one\" (layout ya natural) Y adem\\xe1s entra, NO hacemos reflow.\\n      // - En cualquier otro caso (two/three/rows), hacemos reflow para lectura mobile,\\n      //   incluso aunque \"entre\".\\n      var fits = clustersFitInMobile(clusters, content);\\n      mslLog(\"section:fitCheck\", {\\n        secIndex: secIndex,\\n        mode: mode,\\n        fits: fits,\\n        willSkip: (mode === \"one\" && fits)\\n      });\\n      if (mode === \"one\" && fits) {\\n        logReflowDecision(\"skip:modeOneFits\", {\\n          willApplyReflow: false,\\n          mode: mode,\\n          fits: fits,\\n          clusters: clusters.length,\\n          flowCount: itemsFlow.length\\n        });\\n        finalizeSection(0, baseBottomGap);\\n        return;\\n      }\\n\\n      logReflowDecision(\"apply:modeRequiresReflow\", {\\n        willApplyReflow: true,\\n        mode: mode,\\n        fits: fits,\\n        clusters: clusters.length,\\n        flowCount: itemsFlow.length,\\n        anchorCount: itemsAnchor.length,\\n        groupSizes: groups.map(function(grp){ return grp.length; })\\n      });\\n\\n      // ✅ 4) Reflow solo sobre FLOW (preserva solapes dentro de cada cluster)\\n      var res = applyClusterStack(groups, content, CFG, mode);\\n      mslLog(\"section:applyResult\", {\\n        secIndex: secIndex,\\n        changed: !!(res && res.changed),\\n        neededHeight: res ? res.neededHeight : null,\\n        maxAnchorBottom: +maxAnchorBottom.toFixed(1),\\n        baseBottomGap: +baseBottomGap.toFixed(1)\\n      });\\n      logReflowDecision(\"postApply\", {\\n        willApplyReflow: true,\\n        changed: !!(res && res.changed),\\n        neededHeight: res ? +Number(res.neededHeight || 0).toFixed(1) : null,\\n        mode: mode\\n      });\\n\\n      var neededAfterReflow = 0;\\n      if (res && res.changed) {\\n        // Evitar que la secci\\xf3n quede chica si hay anchors m\\xe1s abajo\\n        var needed = Number(res.neededHeight || 0);\\n        if (Number(maxAnchorBottom) > 0) {\\n          // sumamos padding bottom para que no quede pegado\\n          var anchorNeeded = Math.ceil(maxAnchorBottom + (CFG.PAD_BOT || 0));\\n          if (anchorNeeded > needed) needed = anchorNeeded;\\n        }\\n        if (baseBottomGap > 0) {\\n          needed = Math.ceil(needed + baseBottomGap);\\n        }\\n        if (needed > 0) neededAfterReflow = needed;\\n      }\\n      finalizeSection(neededAfterReflow, baseBottomGap);\\n    });\\n  }\\n\\n  function boot(){\\n    mslLog(\"boot\", { cfg: CFG });\\n    runOnce();\\n    setTimeout(runOnce, 150);\\n    setTimeout(runOnce, 600);\\n    setTimeout(runOnce, 1800);\\n\\n    if(document.fonts && document.fonts.ready){\\n      document.fonts.ready.then(function(){ runOnce(); }).catch(function(){});\\n    }\\n  }\\n\\n  window.addEventListener(\"load\", boot);\\n  window.addEventListener(\"resize\", runOnce);\\n\\n  if(window.visualViewport){\\n    window.visualViewport.addEventListener(\"resize\", runOnce);\\n    window.visualViewport.addEventListener(\"scroll\", runOnce);\\n  }\\n\\n  if(document.readyState !== \"loading\") boot();\\n  else document.addEventListener(\"DOMContentLoaded\", boot);\\n})();\\n</script>\\n').trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFFaEI7QUFDRztBQUNBO0FBQ0E7QUFFdEMsU0FBU0ksWUFBWUMsR0FBcUI7SUFDL0MsSUFBSSxDQUFDQSxJQUFJQyxPQUFPLEVBQUUsT0FBTztJQUV6QixPQUFPLHNzRkEyRk1ELE9BREFBLElBQUlFLFFBQVEsRUFBQyxvQkFFWEYsT0FERkEsSUFBSUcsUUFBUSxFQUFDLHNCQUdiSCxPQUZFQSxJQUFJSSxRQUFRLEVBQUMsc0JBR2ZKLE9BREFBLElBQUlLLFlBQVksRUFBQyxvQkFHZEwsT0FGSEEsSUFBSU0sZUFBZSxFQUFDLHlCQUdSTixPQURUQSxJQUFJTyxpQkFBaUIsR0FBRyxTQUFTLFNBQVEsZ0NBRzVDUCxPQUZZQSxJQUFJUSxpQkFBaUIsR0FBRyxTQUFTLFNBQVEsc0JBSXhDUixPQUZiQSxJQUFJUyxRQUFRLEVBQUMsbUNBR1BULE9BRE9BLElBQUlVLGlCQUFpQixFQUFDLDBCQUdwQlYsT0FGVEEsSUFBSVcsYUFBYSxFQUFDLHFDQUdsQlgsT0FEU0EsSUFBSVksbUJBQW1CLEVBQUMsMEJBR2pDWixPQUZBQSxJQUFJYSxhQUFhLEVBQUMsNEJBR2xCYixPQURBQSxJQUFJYyxXQUFXLEVBQUMsMEJBRVBkLE9BRFRBLElBQUllLFdBQVcsRUFBQyxtQ0FFWGYsT0FESUEsSUFBSWdCLG1CQUFtQixFQUFDLCtCQUlsRHJCLE9BSHNCSyxJQUFJaUIsZUFBZSxFQUFDLGdCQUsxQ3BCLE9BRkFGLHVEQUFpQkEsSUFBRyxVQUlwQkcsT0FGQUQsMERBQWVBLElBQUcsVUFJbEJELE9BRkFFLDBEQUFlQSxJQUFHLFVBRUEsT0FBbEJGLDBEQUFlQSxJQUFHLGtnckNBdzlCcEJzQixJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHNjcmlwdFRlbXBsYXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc2NyaXB0VGVtcGxhdGUudHNcclxuaW1wb3J0IHsgTm9ybWFsaXplZENvbmZpZyB9IGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHsganNEb21IZWxwZXJzQmxvY2sgfSBmcm9tIFwiLi9kb21cIjtcbmltcG9ydCB7IGpzRml0U2NhbGVCbG9jayB9IGZyb20gXCIuL2ZpdFNjYWxlXCI7XG5pbXBvcnQgeyBqc09yZGVyaW5nQmxvY2sgfSBmcm9tIFwiLi9vcmRlcmluZ1wiO1xuaW1wb3J0IHsganNTdGFja2luZ0Jsb2NrIH0gZnJvbSBcIi4vc3RhY2tpbmdcIjtcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTY3JpcHQoY2ZnOiBOb3JtYWxpemVkQ29uZmlnKTogc3RyaW5nIHtcclxuICBpZiAoIWNmZy5lbmFibGVkKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgcmV0dXJuIGBcbjxzY3JpcHQ+XG4oZnVuY3Rpb24oKXtcbiAgdmFyIEVOQUJMRUQgPSB0cnVlO1xuICBmdW5jdGlvbiByZWFkRGVidWdGbGFnKG5hbWUpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgc2VhcmNoID0gKHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uc2VhcmNoKSA/IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggOiBcIlwiO1xuICAgICAgdmFyIHFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgICAgdmFyIHF2ID0gcXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKHF2ID09PSBcIjFcIiB8fCBTdHJpbmcocXYpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKF9lMSkge31cblxuICAgIC8vIHNyY0RvYy9hYm91dDpzcmNkb2Mgbm8gc3VlbGUgdGVuZXIgcXVlcnlzdHJpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cucGFyZW50ICYmIHdpbmRvdy5wYXJlbnQgIT09IHdpbmRvdyAmJiB3aW5kb3cucGFyZW50LmxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBwU2VhcmNoID0gd2luZG93LnBhcmVudC5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgdmFyIHBRID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwU2VhcmNoKTtcbiAgICAgICAgdmFyIHBWID0gcFEuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocFYgPT09IFwiMVwiIHx8IFN0cmluZyhwVikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2UyKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3cudG9wICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB3aW5kb3cudG9wLmxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB0U2VhcmNoID0gd2luZG93LnRvcC5sb2NhdGlvbi5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgdmFyIHRRID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh0U2VhcmNoKTtcbiAgICAgICAgdmFyIHRWID0gdFEuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodFYgPT09IFwiMVwiIHx8IFN0cmluZyh0VikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goX2UzKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBscyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UgPyB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSkgOiBudWxsO1xuICAgICAgaWYgKGxzID09PSBcIjFcIiB8fCBTdHJpbmcobHMpLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKF9lNCkge31cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgTVNMX0RFQlVHID0gcmVhZERlYnVnRmxhZyhcIm1zbERlYnVnXCIpO1xuICB2YXIgTVNMX1ZFUkJPU0UgPSByZWFkRGVidWdGbGFnKFwibXNsVmVyYm9zZVwiKTtcbiAgZnVuY3Rpb24gZGJnKGxhYmVsLCBwYXlsb2FkKXtcbiAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW01TTF0gXCIgKyBsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsICsgXCIgXCIgKyBwYXlsb2FkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByZXR0eSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHByZXR0eSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQsIG51bGwsIDIpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdHJ5IHsgcHJldHR5ID0gU3RyaW5nKHBheWxvYWQpOyB9IGNhdGNoKF8pIHsgcHJldHR5ID0gXCJbdW5zZXJpYWxpemFibGVdXCI7IH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJbTVNMXSBcIiArIGxhYmVsICsgXCJcXFxcblwiICsgcHJldHR5KTtcbiAgfVxuICBmdW5jdGlvbiBtc2xMb2coKXtcbiAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgdmFyIGxhYmVsID0gU3RyaW5nKGFyZ3NbMF0pO1xuICAgIGlmICghTVNMX1ZFUkJPU0UpIHtcbiAgICAgIHZhciBub2lzeSA9IHtcbiAgICAgICAgXCJzZWN0aW9uOm5vZGVTb3VyY2VzXCI6IDEsXG4gICAgICAgIFwic2VjdGlvbjpiYXNlbGluZVJlc3RvcmVcIjogMSxcbiAgICAgICAgXCJzZWN0aW9uOmFuY2hvclNwbGl0XCI6IDEsXG4gICAgICAgIFwic2VjdGlvbjpjbHVzdGVyc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnRocmVlOmNhbmRpZGF0ZXNcIjogMSxcbiAgICAgICAgXCJvcmRlcjp0aHJlZTpzcHJlYWRcIjogMSxcbiAgICAgICAgXCJvcmRlcjp0d286Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnR3bzpzcHJlYWRcIjogMSxcbiAgICAgICAgXCJvcmRlcjpvbmU6Y2FuZGlkYXRlc1wiOiAxLFxuICAgICAgICBcIm9yZGVyOnJvd3M6ZmFsbGJhY2tcIjogMVxuICAgICAgfTtcbiAgICAgIGlmIChub2lzeVtsYWJlbF0pIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBkYmcobGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGRiZyhsYWJlbCwgYXJnc1sxXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRiZyhsYWJlbCwgYXJncy5zbGljZSgxKSk7XG4gIH1cblxyXG4gIHZhciBDRkcgPSB7XHJcbiAgICBNSU5fR0FQOiAke2NmZy5taW5HYXBQeH0sXHJcbiAgICBNQVhfR0FQOiAke2NmZy5tYXhHYXBQeH0sXHJcbiAgICBHQVBfU0NBTEU6ICR7Y2ZnLmdhcFNjYWxlfSxcclxuXHJcbiAgICBQQURfVE9QOiAke2NmZy5wYWRkaW5nVG9wUHh9LFxyXG4gICAgUEFEX0JPVDogJHtjZmcucGFkZGluZ0JvdHRvbVB4fSxcclxuXHJcbiAgICBPTkxZX0ZJWEVEOiAke2NmZy5vbmx5Rml4ZWRTZWN0aW9ucyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwifSxcclxuICAgIE9OTFlfV0hFTl9SRU9SREVSRUQ6ICR7Y2ZnLm9ubHlXaGVuUmVvcmRlcmVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJ9LFxyXG5cclxuICAgIFJPV19UT0w6ICR7Y2ZnLnJvd1RvbFB4fSxcclxuXHJcbiAgICBUV09fQ09MX1NQUkVBRF9SQVRJTzogJHtjZmcudHdvQ29sU3ByZWFkUmF0aW99LFxyXG4gICAgTUlOX1BFUl9DT0xfMjogJHtjZmcubWluUGVyQ29sdW1uMn0sXHJcblxyXG4gICAgVEhSRUVfQ09MX1NQUkVBRF9SQVRJTzogJHtjZmcudGhyZWVDb2xTcHJlYWRSYXRpb30sXG4gICAgTUlOX1BFUl9DT0xfMzogJHtjZmcubWluUGVyQ29sdW1uM30sXG5cbiAgICBGSVRfTUlOX1NDQUxFOiAke2NmZy5maXRNaW5TY2FsZX0sXG4gICAgRklUX01BWF9TQ0FMRTogJHtjZmcuZml0TWF4U2NhbGV9LFxuICAgIEZJVF9UQVJHRVRfV0lEVEhfUkFUSU86ICR7Y2ZnLmZpdFRhcmdldFdpZHRoUmF0aW99LFxuICAgIEZJVF9NSU5fRklMTF9SQVRJTzogJHtjZmcuZml0TWluRmlsbFJhdGlvfVxuICB9O1xuXHJcbiAgJHtqc0RvbUhlbHBlcnNCbG9jaygpfVxyXG5cclxuICAke2pzT3JkZXJpbmdCbG9jaygpfVxyXG5cclxuICAke2pzU3RhY2tpbmdCbG9jaygpfVxuXG4gICR7anNGaXRTY2FsZUJsb2NrKCl9XG5cclxuICBmdW5jdGlvbiBleHBhbmRGaXhlZFNlY3Rpb24oc2VjLCBuZWVkZWRIZWlnaHQpe1xyXG4gICAgdmFyIGN1cnJlbnRIID0gc2VjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCAwO1xyXG4gICAgaWYgKG5lZWRlZEhlaWdodCA+IGN1cnJlbnRIICsgMSkge1xyXG4gICAgICBzZWMuc3R5bGUuaGVpZ2h0ID0gTWF0aC5jZWlsKG5lZWRlZEhlaWdodCkgKyBcInB4XCI7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc1NlY3Rpb24oc2VjKXtcbiAgICBpZighc2VjKSByZXR1cm4gZmFsc2U7XG4gICAgaWYoIUNGRy5PTkxZX0ZJWEVEKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgbW9kbyA9IChzZWMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2RvXCIpIHx8IFwiZmlqb1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBtb2RvID09PSBcImZpam9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVOb2RlQmFzZWxpbmUobm9kZSl7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gMDtcbiAgICB2YXIgcmVzdG9yZWQgPSAwO1xuXG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIsIG5vZGUuc3R5bGUudG9wIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctbGVmdFwiLCBub2RlLnN0eWxlLmxlZnQgfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiLCBub2RlLnN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdGV4dC1hbGlnblwiKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRleHQtYWxpZ25cIiwgbm9kZS5zdHlsZS50ZXh0QWxpZ24gfHwgXCJcIik7XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybS1vcmlnaW5cIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10cmFuc2Zvcm0tb3JpZ2luXCIsIG5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luIHx8IFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LXpvb21cIikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LXpvb21cIiwgbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS10ZXh0LXpvb21cIikgfHwgXCJcIik7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdUb3AgPSBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbXNsLW9yaWctdG9wXCIpO1xuICAgIHZhciBvcmlnTGVmdCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy1sZWZ0XCIpO1xuICAgIHZhciBvcmlnVHJhbnNmb3JtID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybVwiKTtcbiAgICB2YXIgb3JpZ1RleHRBbGlnbiA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LWFsaWduXCIpO1xuICAgIHZhciBvcmlnVHJhbnNmb3JtT3JpZ2luID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1zbC1vcmlnLXRyYW5zZm9ybS1vcmlnaW5cIik7XG4gICAgdmFyIG9yaWdUZXh0Wm9vbSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tc2wtb3JpZy10ZXh0LXpvb21cIik7XG5cbiAgICBpZiAob3JpZ1RvcCAhPSBudWxsICYmIG5vZGUuc3R5bGUudG9wICE9PSBvcmlnVG9wKSB7XG4gICAgICBub2RlLnN0eWxlLnRvcCA9IG9yaWdUb3A7XG4gICAgICByZXN0b3JlZCsrO1xuICAgIH1cbiAgICBpZiAob3JpZ0xlZnQgIT0gbnVsbCAmJiBub2RlLnN0eWxlLmxlZnQgIT09IG9yaWdMZWZ0KSB7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBvcmlnTGVmdDtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnVHJhbnNmb3JtICE9IG51bGwgJiYgbm9kZS5zdHlsZS50cmFuc2Zvcm0gIT09IG9yaWdUcmFuc2Zvcm0pIHtcbiAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gb3JpZ1RyYW5zZm9ybTtcbiAgICAgIHJlc3RvcmVkKys7XG4gICAgfVxuICAgIGlmIChvcmlnVGV4dEFsaWduICE9IG51bGwgJiYgbm9kZS5zdHlsZS50ZXh0QWxpZ24gIT09IG9yaWdUZXh0QWxpZ24pIHtcbiAgICAgIGlmIChvcmlnVGV4dEFsaWduKSBub2RlLnN0eWxlLnRleHRBbGlnbiA9IG9yaWdUZXh0QWxpZ247XG4gICAgICBlbHNlIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0ZXh0LWFsaWduXCIpO1xuICAgICAgcmVzdG9yZWQrKztcbiAgICB9XG4gICAgaWYgKG9yaWdUcmFuc2Zvcm1PcmlnaW4gIT0gbnVsbCAmJiBub2RlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiAhPT0gb3JpZ1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgaWYgKG9yaWdUcmFuc2Zvcm1PcmlnaW4pIG5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ1RyYW5zZm9ybU9yaWdpbjtcbiAgICAgIGVsc2Ugbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybS1vcmlnaW5cIik7XG4gICAgICByZXN0b3JlZCsrO1xuICAgIH1cbiAgICBpZiAob3JpZ1RleHRab29tICE9IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGV4dFpvb20gPSBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLXRleHQtem9vbVwiKSB8fCBcIlwiO1xuICAgICAgaWYgKGN1cnJlbnRUZXh0Wm9vbSAhPT0gb3JpZ1RleHRab29tKSB7XG4gICAgICAgIGlmIChvcmlnVGV4dFpvb20pIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRleHQtem9vbVwiLCBvcmlnVGV4dFpvb20pO1xuICAgICAgICBlbHNlIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXRleHQtem9vbVwiKTtcbiAgICAgICAgcmVzdG9yZWQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcbiAgICByZXR1cm4gcmVzdG9yZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBydW5PbmNlKCl7XG4gICAgaWYoIUVOQUJMRUQpIHJldHVybjtcbiAgICBpZighaXNNb2JpbGUoKSkge1xuICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSkuZm9yRWFjaChmdW5jdGlvbihzZWMpe1xuICAgICAgICB2YXIgY29udGVudCA9IHNlYy5xdWVyeVNlbGVjdG9yKFwiLnNlYy1jb250ZW50XCIpO1xuICAgICAgICBpZighY29udGVudCkgcmV0dXJuO1xuICAgICAgICB2YXIgYmxlZWQgPSBzZWMucXVlcnlTZWxlY3RvcihcIi5zZWMtYmxlZWRcIik7XG4gICAgICAgIHJlc2V0U2VjdGlvbkZpdFNjYWxlKHNlYywgY29udGVudCwgYmxlZWQpO1xuICAgICAgICB2YXIgbm9kZXNBbGxEZXNrdG9wID0gZ2V0T2JqTm9kZXMoc2VjKTtcbiAgICAgICAgZm9yICh2YXIgbmQ9MDsgbmQ8bm9kZXNBbGxEZXNrdG9wLmxlbmd0aDsgbmQrKykge1xuICAgICAgICAgIHJlc3RvcmVOb2RlQmFzZWxpbmUobm9kZXNBbGxEZXNrdG9wW25kXSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjLnNldEF0dHJpYnV0ZShcImRhdGEtbXNsLWZpdC1zY2FsZVwiLCBcIjFcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cclxuICAgIHZhciBzZWNzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNlY1wiKSk7XHJcbiAgICBpZighc2Vjcy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICBzZWNzLmZvckVhY2goZnVuY3Rpb24oc2VjKXtcbiAgICAgIHZhciBzZWNJbmRleCA9IHNlY3MuaW5kZXhPZihzZWMpO1xuICAgICAgdmFyIHNlY01vZG8gPSAoc2VjLmdldEF0dHJpYnV0ZShcImRhdGEtbW9kb1wiKSB8fCBcImZpam9cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBhbGxvd1JlZmxvdyA9IHNob3VsZFByb2Nlc3NTZWN0aW9uKHNlYyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOnN0YXJ0XCIsIHsgc2VjSW5kZXg6IHNlY0luZGV4LCBtb2RvOiBzZWNNb2RvLCBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3cgfSk7XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWNvbnRlbnRcIik7XG4gICAgICBpZighY29udGVudCkgcmV0dXJuO1xuICAgICAgdmFyIGJsZWVkID0gc2VjLnF1ZXJ5U2VsZWN0b3IoXCIuc2VjLWJsZWVkXCIpO1xuICAgICAgcmVzZXRTZWN0aW9uRml0U2NhbGUoc2VjLCBjb250ZW50LCBibGVlZCk7XG4gICAgICB2YXIgbm9kZXNBbGwgPSBnZXRPYmpOb2RlcyhzZWMpO1xuXG4gICAgICB2YXIgcmVmbG93RWxlbWVudHNEdW1wID0gW107XG4gICAgICBmdW5jdGlvbiBidWlsZFJlZmxvd0VsZW1lbnRzRHVtcChpdGVtcywgY29udGVudFdOb3cpe1xuICAgICAgICBpZiAoIU1TTF9ERUJVRykgcmV0dXJuO1xuICAgICAgICB2YXIgbGlzdCA9IChpdGVtcyB8fCBbXSk7XG4gICAgICAgIHZhciBtYXhJdGVtcyA9IDEyMDtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpRHVtcD0wOyBpRHVtcDxsaXN0Lmxlbmd0aCAmJiBpRHVtcDxtYXhJdGVtczsgaUR1bXArKyl7XG4gICAgICAgICAgdmFyIGl0RHVtcCA9IGxpc3RbaUR1bXBdO1xuICAgICAgICAgIGlmICghaXREdW1wIHx8ICFpdER1bXAubm9kZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIG5EdW1wID0gaXREdW1wLm5vZGU7XG4gICAgICAgICAgdmFyIHRleHRSYXcgPSAoKG5EdW1wLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgICAgdmFyIGlzVGV4dER1bXAgPSAobkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGNsc0R1bXAgPSAobkR1bXAuY2xhc3NOYW1lICYmIHR5cGVvZiBuRHVtcC5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbkR1bXAuY2xhc3NOYW1lIDogXCJcIjtcbiAgICAgICAgICB2YXIgcm9vdFpvbmUgPSAobkR1bXAuY2xvc2VzdCAmJiBuRHVtcC5jbG9zZXN0KFwiLnNlYy1ibGVlZFwiKSkgPyBcImJsZWVkXCIgOiBcImNvbnRlbnRcIjtcbiAgICAgICAgICBvdXQucHVzaCh7XG4gICAgICAgICAgICBpOiBpRHVtcCxcbiAgICAgICAgICAgIGtpbmQ6IGlzVGV4dER1bXAgPyBcInRleHRvXCIgOiBTdHJpbmcoKG5EdW1wLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICB6b25lOiByb290Wm9uZSxcbiAgICAgICAgICAgIHRvcDogK051bWJlcihpdER1bXAudG9wIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiArTnVtYmVyKGl0RHVtcC5sZWZ0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3OiArTnVtYmVyKGl0RHVtcC53aWR0aCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK051bWJlcihpdER1bXAuaGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICByaWdodDogK051bWJlcigoaXREdW1wLmxlZnQgfHwgMCkgKyAoaXREdW1wLndpZHRoIHx8IDApKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgYm90dG9tOiArTnVtYmVyKChpdER1bXAudG9wIHx8IDApICsgKGl0RHVtcC5oZWlnaHQgfHwgMCkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjeDogK051bWJlcigoaXREdW1wLmxlZnQgfHwgMCkgKyAoKGl0RHVtcC53aWR0aCB8fCAwKSAvIDIpKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgd1JhdGlvOiBjb250ZW50V05vdyA+IDEgPyArTnVtYmVyKChpdER1bXAud2lkdGggfHwgMCkgLyBjb250ZW50V05vdykudG9GaXhlZCgzKSA6IG51bGwsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsc0R1bXAsXG4gICAgICAgICAgICBtb2JpbGVMYXlvdXQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlUm9sZTogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQ2x1c3RlcjogbkR1bXAuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2x1c3RlclwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQ2x1c3RlcklkOiBuRHVtcC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1jbHVzdGVyLWlkXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVDZW50ZXI6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWNlbnRlclwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgbW9iaWxlQWxpZ246IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWFsaWduXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICBtb2JpbGVGaXQ6IG5EdW1wLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWZpdFwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAobkR1bXAuc3R5bGUgJiYgbkR1bXAuc3R5bGUudGV4dEFsaWduKSA/IG5EdW1wLnN0eWxlLnRleHRBbGlnbiA6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0U2FtcGxlOiBpc1RleHREdW1wID8gdGV4dFJhdy5zbGljZSgwLCA5MCkgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmbG93RWxlbWVudHNEdW1wID0gb3V0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2dSZWZsb3dEZWNpc2lvbihyZWFzb24sIGV4dHJhKXtcbiAgICAgICAgaWYgKCFNU0xfREVCVUcpIHJldHVybjtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHNlY01vZG86IHNlY01vZG8sXG4gICAgICAgICAgYWxsb3dSZWZsb3c6IGFsbG93UmVmbG93LFxuICAgICAgICAgIHRvdGFsTm9kZXM6IChub2Rlc0FsbCB8fCBbXSkubGVuZ3RoLFxuICAgICAgICAgIHJlYXNvbjogU3RyaW5nKHJlYXNvbiB8fCBcIlwiKSxcbiAgICAgICAgICBkZXRhaWxzOiBleHRyYSB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOnJlZmxvdzpkZWNpc2lvblwiLCBwYXlsb2FkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmluYWxpemVTZWN0aW9uKG1pbk5lZWRlZEhlaWdodCwgcHJlc2VydmVCb3R0b21HYXApe1xuICAgICAgICB2YXIgZ2FwID0gTnVtYmVyLmlzRmluaXRlKHByZXNlcnZlQm90dG9tR2FwKSA/IE1hdGgubWF4KDAsIE51bWJlcihwcmVzZXJ2ZUJvdHRvbUdhcCkpIDogMDtcbiAgICAgICAgdmFyIGZpdCA9IGFwcGx5U2VjdGlvbkZpdFNjYWxlKFxuICAgICAgICAgIHNlYyxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGJsZWVkLFxuICAgICAgICAgIG5vZGVzQWxsLFxuICAgICAgICAgIHNlY01vZG8sXG4gICAgICAgICAgQ0ZHLFxuICAgICAgICAgIHsgc2VjSW5kZXg6IHNlY0luZGV4IH0sXG4gICAgICAgICAgeyBwcmVzZXJ2ZUJvdHRvbUdhcDogZ2FwIH1cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGZpdE5lZWRlZCA9IChmaXQgJiYgTnVtYmVyLmlzRmluaXRlKGZpdC5uZWVkZWRIZWlnaHQpKSA/IE51bWJlcihmaXQubmVlZGVkSGVpZ2h0KSA6IDA7XG4gICAgICAgIHZhciBuZWVkZWRIZWlnaHQgPSBNYXRoLm1heChOdW1iZXIobWluTmVlZGVkSGVpZ2h0IHx8IDApLCBmaXROZWVkZWQpO1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOmhlaWdodEZpbmFsXCIsIHtcbiAgICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgICAgbW9kZTogc2VjTW9kbyxcbiAgICAgICAgICBtaW5OZWVkZWRIZWlnaHQ6ICtOdW1iZXIobWluTmVlZGVkSGVpZ2h0IHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgZml0TmVlZGVkSGVpZ2h0OiArZml0TmVlZGVkLnRvRml4ZWQoMSksXG4gICAgICAgICAgcHJlc2VydmVCb3R0b21HYXA6ICtnYXAudG9GaXhlZCgxKSxcbiAgICAgICAgICBmaW5hbE5lZWRlZEhlaWdodDogK25lZWRlZEhlaWdodC50b0ZpeGVkKDEpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VjTW9kbyA9PT0gXCJmaWpvXCIgJiYgbmVlZGVkSGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGV4cGFuZEZpeGVkU2VjdGlvbihzZWMsIG5lZWRlZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIW5vZGVzQWxsLmxlbmd0aCkge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6bm9Ob2Rlc1wiLCB7IHdpbGxBcHBseVJlZmxvdzogZmFsc2UgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVidWdDb3VudHMgPSB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgY29udGVudE9iajogY29udGVudCA/IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikubGVuZ3RoIDogMCxcbiAgICAgICAgYmxlZWRPYmo6IGJsZWVkID8gYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIi5vYmpldG9cIikubGVuZ3RoIDogMCxcbiAgICAgICAgY29udGVudEFiczogY29udGVudCA/IEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICByZXR1cm4gISEoZWwgJiYgZWwuc3R5bGUgJiYgKGVsLnN0eWxlLnBvc2l0aW9uIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYWJzb2x1dGVcIiAmJiBlbC5zdHlsZS50b3AgJiYgZWwuc3R5bGUubGVmdCk7XG4gICAgICAgIH0pLmxlbmd0aCA6IDAsXG4gICAgICAgIGJsZWVkQWJzOiBibGVlZCA/IEFycmF5LmZyb20oYmxlZWQucXVlcnlTZWxlY3RvckFsbChcIipcIikpLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgICAgcmV0dXJuICEhKGVsICYmIGVsLnN0eWxlICYmIChlbC5zdHlsZS5wb3NpdGlvbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImFic29sdXRlXCIgJiYgZWwuc3R5bGUudG9wICYmIGVsLnN0eWxlLmxlZnQpO1xuICAgICAgICB9KS5sZW5ndGggOiAwXG4gICAgICB9O1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpub2RlU291cmNlc1wiLCBkZWJ1Z0NvdW50cyk7XG5cbiAgICAgIGlmIChNU0xfVkVSQk9TRSkge1xuICAgICAgICBtc2xMb2coXCJzZWN0aW9uOm5vZGVzQWxsOnJhd1wiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHRvdGFsOiBub2Rlc0FsbC5sZW5ndGgsXG4gICAgICAgICAgbm9kZXM6IG5vZGVzQWxsLm1hcChmdW5jdGlvbihuLCBpKXtcbiAgICAgICAgICAgIHZhciBjbHMgPSAobi5jbGFzc05hbWUgJiYgdHlwZW9mIG4uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiKSA/IG4uY2xhc3NOYW1lIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDbHMgPSAobi5wYXJlbnRFbGVtZW50ICYmIG4ucGFyZW50RWxlbWVudC5jbGFzc05hbWUgJiYgdHlwZW9mIG4ucGFyZW50RWxlbWVudC5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgID8gbi5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICB0YWc6IChuLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgY2xzOiBjbHMsXG4gICAgICAgICAgICAgIHBhcmVudENsczogcGFyZW50Q2xzLFxuICAgICAgICAgICAgICB0b3A6IG4uc3R5bGUgPyBuLnN0eWxlLnRvcCA6IFwiXCIsXG4gICAgICAgICAgICAgIGxlZnQ6IG4uc3R5bGUgPyBuLnN0eWxlLmxlZnQgOiBcIlwiLFxuICAgICAgICAgICAgICBwb3M6IG4uc3R5bGUgPyBuLnN0eWxlLnBvc2l0aW9uIDogXCJcIixcbiAgICAgICAgICAgICAgdGV4dDogKChuLnRleHRDb250ZW50IHx8IFwiXCIpLnRyaW0oKSkuc2xpY2UoMCwgNDApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBmbGF0ID0gbm9kZXNBbGwubWFwKGZ1bmN0aW9uKG4sIGkpe1xuICAgICAgICAgICAgdmFyIGNscyA9IChuLmNsYXNzTmFtZSAmJiB0eXBlb2Ygbi5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIpID8gbi5jbGFzc05hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIHR4dCA9ICgobi50ZXh0Q29udGVudCB8fCBcIlwiKS50cmltKCkpLnJlcGxhY2UoL1xcXFxzKy9nLCBcIiBcIikuc2xpY2UoMCwgNjApO1xuICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgaVxuICAgICAgICAgICAgICArIFwiIHRhZz1cIiArIFN0cmluZygobi50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICsgXCIgY2xzPVwiICsgY2xzXG4gICAgICAgICAgICAgICsgXCIgcG9zPVwiICsgKG4uc3R5bGUgPyBuLnN0eWxlLnBvc2l0aW9uIDogXCJcIilcbiAgICAgICAgICAgICAgKyBcIiB0b3A9XCIgKyAobi5zdHlsZSA/IG4uc3R5bGUudG9wIDogXCJcIilcbiAgICAgICAgICAgICAgKyBcIiBsZWZ0PVwiICsgKG4uc3R5bGUgPyBuLnN0eWxlLmxlZnQgOiBcIlwiKVxuICAgICAgICAgICAgICArIFwiIHRleHQ9XCIgKyB0eHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbXNsTG9nKFwic2VjdGlvbjpub2Rlc0FsbDpmbGF0XCIsIFwic2VjPVwiICsgc2VjSW5kZXggKyBcIiB0b3RhbD1cIiArIG5vZGVzQWxsLmxlbmd0aCArIFwiIDo6IFwiICsgZmxhdC5qb2luKFwiIHwgXCIpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgdmFyIHJlc3RvcmVkQ291bnQgPSAwO1xuICAgICAgbm9kZXNBbGwuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgcmVzdG9yZWRDb3VudCArPSByZXN0b3JlTm9kZUJhc2VsaW5lKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmJhc2VsaW5lUmVzdG9yZVwiLCB7IHNlY0luZGV4OiBzZWNJbmRleCwgbm9kZXM6IG5vZGVzQWxsLmxlbmd0aCwgcmVzdG9yZWQ6IHJlc3RvcmVkQ291bnQgfSk7XG5cbiAgICAgIC8vIFJlY3QgZGVsIGNvbnRlbnQgKG3DqXRyaWNhcyByZWFsZXMpXG4gICAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNvbnRlbnRXID0gY29udGVudFJlY3Qud2lkdGggfHwgMDtcbiAgICAgIHZhciBzZWNDdXJyZW50SCA9IHNlYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgMDtcbiAgICAgIHZhciBiYXNlSGVpZ2h0QXR0ciA9IFwiZGF0YS1tc2wtYmFzZS1oZWlnaHRcIjtcbiAgICAgIGlmICghc2VjLmhhc0F0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0cikpIHtcbiAgICAgICAgc2VjLnNldEF0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0ciwgU3RyaW5nKHNlY0N1cnJlbnRIKSk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVNlY0hlaWdodCA9IHBhcnNlRmxvYXQoc2VjLmdldEF0dHJpYnV0ZShiYXNlSGVpZ2h0QXR0cikgfHwgXCJcIik7XG4gICAgICBpZiAoIWlzRmluaXRlKGJhc2VTZWNIZWlnaHQpIHx8IGJhc2VTZWNIZWlnaHQgPD0gMCkgYmFzZVNlY0hlaWdodCA9IHNlY0N1cnJlbnRIO1xuXHJcbiAgICAgIC8vIGl0ZW1zIChyZWN0cykgZW4gY29vcmRlbmFkYXMgZGVsIGNvbnRlbnQgKFRPRE9TKVxyXG4gICAgICB2YXIgaXRlbXNBbGwgPSBub2Rlc0FsbC5tYXAoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIHZhciByYyA9IHJlbFJlY3Qobm9kZSwgY29udGVudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICB0b3A6IHJjLnRvcCxcbiAgICAgICAgICBsZWZ0OiByYy5sZWZ0LFxyXG4gICAgICAgICAgaGVpZ2h0OiByYy5oZWlnaHQsXHJcbiAgICAgICAgICB3aWR0aDogcmMud2lkdGhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgYnVpbGRSZWZsb3dFbGVtZW50c0R1bXAoaXRlbXNBbGwsIGNvbnRlbnRXKTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246cmVmbG93OmVsZW1lbnRzXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBzZWNNb2RvOiBzZWNNb2RvLFxuICAgICAgICBjb250ZW50VzogK051bWJlcihjb250ZW50VyB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICB0b3RhbDogcmVmbG93RWxlbWVudHNEdW1wLmxlbmd0aCxcbiAgICAgICAgZWxlbWVudHM6IHJlZmxvd0VsZW1lbnRzRHVtcFxuICAgICAgfSk7XG4gICAgICBpZiAoTVNMX1ZFUkJPU0UpIHtcbiAgICAgICAgbXNsTG9nKFwic2VjdGlvbjppdGVtc0FsbFwiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIHRvdGFsOiBpdGVtc0FsbC5sZW5ndGgsXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zQWxsLm1hcChmdW5jdGlvbihpdCwgaWR4KXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGk6IGlkeCxcbiAgICAgICAgICAgICAga2luZDogKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIgPyBcInRleHRvXCIgOiAoaXQubm9kZS50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIHRvcDogK2l0LnRvcC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBsZWZ0OiAraXQubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICB3OiAraXQud2lkdGgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgaDogK2l0LmhlaWdodC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICB0ZXh0QWxpZ246IChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSA/IGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduIDogXCJcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlc2VydmFyIGVsIFwiYWlyZVwiIGluZmVyaW9yIG9yaWdpbmFsIGRlIGxhIHNlY2Npb24gdHJhcyBlbCByZWZsb3cuXG4gICAgICB2YXIgbWF4T3JpZ2luYWxCb3R0b20gPSAwO1xuICAgICAgZm9yICh2YXIgaWI9MDsgaWI8aXRlbXNBbGwubGVuZ3RoOyBpYisrKXtcbiAgICAgICAgdmFyIGl0YiA9IGl0ZW1zQWxsW2liXTtcbiAgICAgICAgdmFyIGJ0bSA9IChpdGIudG9wIHx8IDApICsgKGl0Yi5oZWlnaHQgfHwgMCk7XG4gICAgICAgIGlmIChidG0gPiBtYXhPcmlnaW5hbEJvdHRvbSkgbWF4T3JpZ2luYWxCb3R0b20gPSBidG07XG4gICAgICB9XG4gICAgICB2YXIgYmFzZUJvdHRvbUdhcCA9IE1hdGgubWF4KDAsIGJhc2VTZWNIZWlnaHQgLSBtYXhPcmlnaW5hbEJvdHRvbSk7XG5cbiAgICAgIC8vIFNpIHRvZG8gbWlkZSAwIChmb250cyBubyBsaXN0YXMpLCByZWludGVudGFtb3MgbHVlZ29cbiAgICAgIHZhciBhbnlWYWxpZEFsbCA9IGl0ZW1zQWxsLnNvbWUoZnVuY3Rpb24oaXQpeyByZXR1cm4gaXQuaGVpZ2h0ID4gMC41OyB9KTtcbiAgICAgIGlmKCFhbnlWYWxpZEFsbCkge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6aW52YWxpZFJlY3RzXCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIGFsbEhlaWdodHNUaW55OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbGxvd1JlZmxvdyB8fCBub2Rlc0FsbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDpub3RFbGlnaWJsZVwiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1JlZmxvdzogYWxsb3dSZWZsb3csXG4gICAgICAgICAgdG90YWxOb2Rlczogbm9kZXNBbGwubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBmaW5hbGl6ZVNlY3Rpb24oMCwgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0SGVyb0xpa2VDZW50cmFsVGV4dChpdGVtcywgcm9vdFcpe1xuICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgIGlzSGVybzogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIHRleHRDb3VudDogMCxcbiAgICAgICAgICB0ZXh0Q29sdW1uQ291bnQ6IDAsXG4gICAgICAgICAgdGV4dENvbHVtbnM6IFtdLFxuICAgICAgICAgIHNpbmdsZVRleHRDb2x1bW46IGZhbHNlLFxuICAgICAgICAgIG1heFRleHRXaWR0aFJhdGlvOiBudWxsLFxuICAgICAgICAgIHdpZHRoUmF0aW86IG51bGwsXG4gICAgICAgICAgY2VudGVyRGVsdGE6IG51bGwsXG4gICAgICAgICAgY2VudGVyVG9sOiBudWxsLFxuICAgICAgICAgIGNlbnRlcmVkQnlBbGlnbjogZmFsc2UsXG4gICAgICAgICAgY2VudGVyZWRCeUdlb21ldHJ5OiBmYWxzZSxcbiAgICAgICAgICBkZWNvck5lYXI6IDAsXG4gICAgICAgICAgZGVjb3JMZWZ0OiAwLFxuICAgICAgICAgIGRlY29yUmlnaHQ6IDAsXG4gICAgICAgICAgZGVjb3JJbnZhZGluZ1RleHRDb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9JdGVtc09yV2lkdGhcIjtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdCl7XG4gICAgICAgICAgaWYgKChpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgIT09IFwiMVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgdmFyIHR3ID0gTnVtYmVyKGl0LndpZHRoIHx8IDApO1xuICAgICAgICAgIHZhciB0aCA9IE51bWJlcihpdC5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgcmV0dXJuIHR3ID4gMiAmJiB0aCA+IDI7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXQudGV4dENvdW50ID0gdGV4dEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0ZXh0SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm9UZXh0XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHBsaWNpdEhlcm8gPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZWg9MDsgZWg8dGV4dEl0ZW1zLmxlbmd0aDsgZWgrKyl7XG4gICAgICAgICAgdmFyIHJvbGVFaCA9ICh0ZXh0SXRlbXNbZWhdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtcm9sZVwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChyb2xlRWggPT09IFwiaGVyb1wiKSB7XG4gICAgICAgICAgICBleHBsaWNpdEhlcm8gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbFRvbCA9IE1hdGgubWF4KDE4LCByb290VyAqIDAuMTQpO1xuICAgICAgICB2YXIgdGV4dENvbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdGM9MDsgdGM8dGV4dEl0ZW1zLmxlbmd0aDsgdGMrKyl7XG4gICAgICAgICAgdmFyIHR4dCA9IHRleHRJdGVtc1t0Y107XG4gICAgICAgICAgdmFyIHR4dEN4ID0gTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSAvIDI7XG4gICAgICAgICAgdmFyIGF0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgY2M9MDsgY2M8dGV4dENvbHMubGVuZ3RoOyBjYysrKXtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0eHRDeCAtIHRleHRDb2xzW2NjXS5jeCkgPD0gY29sVG9sKSB7XG4gICAgICAgICAgICAgIHZhciBuQ29sID0gdGV4dENvbHNbY2NdLmNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLmN4ID0gKCh0ZXh0Q29sc1tjY10uY3ggKiB0ZXh0Q29sc1tjY10uY291bnQpICsgdHh0Q3gpIC8gbkNvbDtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLmNvdW50ID0gbkNvbDtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1pbkxlZnQgPSBNYXRoLm1pbih0ZXh0Q29sc1tjY10ubWluTGVmdCwgTnVtYmVyKHR4dC5sZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1heFJpZ2h0ID0gTWF0aC5tYXgodGV4dENvbHNbY2NdLm1heFJpZ2h0LCBOdW1iZXIodHh0LmxlZnQgfHwgMCkgKyBOdW1iZXIodHh0LndpZHRoIHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1pblRvcCA9IE1hdGgubWluKHRleHRDb2xzW2NjXS5taW5Ub3AsIE51bWJlcih0eHQudG9wIHx8IDApKTtcbiAgICAgICAgICAgICAgdGV4dENvbHNbY2NdLm1heEJvdHRvbSA9IE1hdGgubWF4KHRleHRDb2xzW2NjXS5tYXhCb3R0b20sIE51bWJlcih0eHQudG9wIHx8IDApICsgTnVtYmVyKHR4dC5oZWlnaHQgfHwgMCkpO1xuICAgICAgICAgICAgICBhdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWF0dGFjaGVkKSB7XG4gICAgICAgICAgICB0ZXh0Q29scy5wdXNoKHtcbiAgICAgICAgICAgICAgY3g6IHR4dEN4LFxuICAgICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgICAgbWluTGVmdDogTnVtYmVyKHR4dC5sZWZ0IHx8IDApLFxuICAgICAgICAgICAgICBtYXhSaWdodDogTnVtYmVyKHR4dC5sZWZ0IHx8IDApICsgTnVtYmVyKHR4dC53aWR0aCB8fCAwKSxcbiAgICAgICAgICAgICAgbWluVG9wOiBOdW1iZXIodHh0LnRvcCB8fCAwKSxcbiAgICAgICAgICAgICAgbWF4Qm90dG9tOiBOdW1iZXIodHh0LnRvcCB8fCAwKSArIE51bWJlcih0eHQuaGVpZ2h0IHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGV4dENvbHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5jeCAtIGIuY3g7IH0pO1xuICAgICAgICBvdXQudGV4dENvbHVtbkNvdW50ID0gdGV4dENvbHMubGVuZ3RoO1xuICAgICAgICBvdXQuc2luZ2xlVGV4dENvbHVtbiA9IHRleHRDb2xzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgb3V0LnRleHRDb2x1bW5zID0gdGV4dENvbHMubWFwKGZ1bmN0aW9uKGNvbCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiArTnVtYmVyKGNvbC5jeCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgY291bnQ6IGNvbC5jb3VudCxcbiAgICAgICAgICAgIGxlZnQ6ICtOdW1iZXIoY29sLm1pbkxlZnQgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHJpZ2h0OiArTnVtYmVyKGNvbC5tYXhSaWdodCB8fCAwKS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgdG9wOiArTnVtYmVyKGNvbC5taW5Ub3AgfHwgMCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGJvdHRvbTogK051bWJlcihjb2wubWF4Qm90dG9tIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvdXQuc2luZ2xlVGV4dENvbHVtbikge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBleHBsaWNpdEhlcm8gPyBcImV4cGxpY2l0SGVyb1JvbGVcIiA6IFwibXVsdGlUZXh0Q29sdW1uc1wiO1xuICAgICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm87XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZW50ZXJYID0gcm9vdFcgLyAyO1xuICAgICAgICB2YXIgdGV4dENvbCA9IHRleHRDb2xzWzBdO1xuICAgICAgICB2YXIgdGV4dENlbnRlclggPSBOdW1iZXIodGV4dENvbC5jeCB8fCBjZW50ZXJYKTtcbiAgICAgICAgdmFyIGNlbnRlckRlbHRhID0gTWF0aC5hYnModGV4dENlbnRlclggLSBjZW50ZXJYKTtcbiAgICAgICAgdmFyIGNlbnRlclRvbCA9IE1hdGgubWF4KDE4LCByb290VyAqIDAuMTIpO1xuICAgICAgICBvdXQuY2VudGVyRGVsdGEgPSArY2VudGVyRGVsdGEudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LmNlbnRlclRvbCA9ICtjZW50ZXJUb2wudG9GaXhlZCgxKTtcblxuICAgICAgICB2YXIgY2VudGVyZWRBbGlnbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIG1heFRleHRXaWR0aFJhdGlvID0gMDtcbiAgICAgICAgdmFyIHRleHRUb3AgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHRleHRCb3R0b20gPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIHRpeD0wOyB0aXg8dGV4dEl0ZW1zLmxlbmd0aDsgdGl4Kyspe1xuICAgICAgICAgIHZhciB0ID0gdGV4dEl0ZW1zW3RpeF07XG4gICAgICAgICAgdmFyIHRhID0gKHQubm9kZSAmJiB0Lm5vZGUuc3R5bGUgJiYgdC5ub2RlLnN0eWxlLnRleHRBbGlnbilcbiAgICAgICAgICAgID8gU3RyaW5nKHQubm9kZS5zdHlsZS50ZXh0QWxpZ24pLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICBpZiAodGEgPT09IFwiY2VudGVyXCIpIGNlbnRlcmVkQWxpZ25Db3VudCsrO1xuICAgICAgICAgIHZhciB3UmF0aW8gPSBOdW1iZXIodC53aWR0aCB8fCAwKSAvIE1hdGgubWF4KDEsIHJvb3RXKTtcbiAgICAgICAgICBpZiAod1JhdGlvID4gbWF4VGV4dFdpZHRoUmF0aW8pIG1heFRleHRXaWR0aFJhdGlvID0gd1JhdGlvO1xuICAgICAgICAgIHRleHRUb3AgPSBNYXRoLm1pbih0ZXh0VG9wLCBOdW1iZXIodC50b3AgfHwgMCkpO1xuICAgICAgICAgIHRleHRCb3R0b20gPSBNYXRoLm1heCh0ZXh0Qm90dG9tLCBOdW1iZXIodC50b3AgfHwgMCkgKyBOdW1iZXIodC5oZWlnaHQgfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIG91dC5tYXhUZXh0V2lkdGhSYXRpbyA9ICttYXhUZXh0V2lkdGhSYXRpby50b0ZpeGVkKDMpO1xuICAgICAgICBvdXQud2lkdGhSYXRpbyA9IG91dC5tYXhUZXh0V2lkdGhSYXRpbztcbiAgICAgICAgb3V0LmNlbnRlcmVkQnlBbGlnbiA9IGNlbnRlcmVkQWxpZ25Db3VudCA+PSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGV4dEl0ZW1zLmxlbmd0aCAqIDAuNSkpO1xuICAgICAgICBvdXQuY2VudGVyZWRCeUdlb21ldHJ5ID0gY2VudGVyRGVsdGEgPD0gY2VudGVyVG9sO1xuICAgICAgICBpZiAoIW91dC5jZW50ZXJlZEJ5QWxpZ24gJiYgIW91dC5jZW50ZXJlZEJ5R2VvbWV0cnkpIHtcbiAgICAgICAgICBvdXQucmVhc29uID0gZXhwbGljaXRIZXJvID8gXCJleHBsaWNpdEhlcm9Sb2xlXCIgOiBcInNpbmdsZVRleHRDb2x1bW5Ob3RDZW50ZXJlZFwiO1xuICAgICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm87XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2aXRhIG1hcmNhciBjb21vIGhlcm8gdGV4dG9zIHN1ZWx0b3MgbXV5IGNoaWNvcy5cbiAgICAgICAgaWYgKHRleHRJdGVtcy5sZW5ndGggPCAyICYmIG1heFRleHRXaWR0aFJhdGlvIDwgMC4yOCAmJiAhZXhwbGljaXRIZXJvKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwidGV4dFRvb1NtYWxsXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNGaW5pdGUodGV4dFRvcCkgfHwgIWlzRmluaXRlKHRleHRCb3R0b20pIHx8IHRleHRCb3R0b20gPD0gdGV4dFRvcCkge1xuICAgICAgICAgIHRleHRUb3AgPSAwO1xuICAgICAgICAgIHRleHRCb3R0b20gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyVG9wID0gdGV4dFRvcCAtIE1hdGgubWF4KDI4LCAodGV4dEJvdHRvbSAtIHRleHRUb3ApICogMC4yKTtcbiAgICAgICAgdmFyIG5lYXJCb3R0b20gPSB0ZXh0Qm90dG9tICsgTWF0aC5tYXgoMzYsICh0ZXh0Qm90dG9tIC0gdGV4dFRvcCkgKiAwLjM1KTtcbiAgICAgICAgdmFyIGludmFkZVBhZCA9IE1hdGgubWF4KDI0LCByb290VyAqIDAuMTcpO1xuICAgICAgICB2YXIgaW52YWRlTGVmdCA9IHRleHRDZW50ZXJYIC0gaW52YWRlUGFkO1xuICAgICAgICB2YXIgaW52YWRlUmlnaHQgPSB0ZXh0Q2VudGVyWCArIGludmFkZVBhZDtcblxuICAgICAgICB2YXIgZGVjb3JOZWFyID0gMDtcbiAgICAgICAgdmFyIGRlY29yTGVmdCA9IDA7XG4gICAgICAgIHZhciBkZWNvclJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGRlY29ySW52YWRpbmcgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlIZXJvPTA7IGlIZXJvPGl0ZW1zLmxlbmd0aDsgaUhlcm8rKyl7XG4gICAgICAgICAgdmFyIGl0ID0gaXRlbXNbaUhlcm9dO1xuICAgICAgICAgIGlmICgoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIikgY29udGludWU7XG5cbiAgICAgICAgICB2YXIgdyA9IE51bWJlcihpdC53aWR0aCB8fCAwKTtcbiAgICAgICAgICB2YXIgaCA9IE51bWJlcihpdC5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgaWYgKHcgPCA4IHx8IGggPCA4KSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciB0b3AgPSBOdW1iZXIoaXQudG9wIHx8IDApO1xuICAgICAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoO1xuICAgICAgICAgIHZhciBpbkJhbmQgPSAhKGJvdHRvbSA8IG5lYXJUb3AgfHwgdG9wID4gbmVhckJvdHRvbSk7XG4gICAgICAgICAgaWYgKCFpbkJhbmQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZGVjb3JOZWFyKys7XG4gICAgICAgICAgdmFyIGN4ID0gTnVtYmVyKGl0LmxlZnQgfHwgMCkgKyB3IC8gMjtcbiAgICAgICAgICBpZiAoY3ggPCB0ZXh0Q2VudGVyWCAtIDgpIGRlY29yTGVmdCsrO1xuICAgICAgICAgIGVsc2UgaWYgKGN4ID4gdGV4dENlbnRlclggKyA4KSBkZWNvclJpZ2h0Kys7XG5cbiAgICAgICAgICB2YXIgbGVmdCA9IE51bWJlcihpdC5sZWZ0IHx8IDApO1xuICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3O1xuICAgICAgICAgIGlmIChyaWdodCA+IGludmFkZUxlZnQgJiYgbGVmdCA8IGludmFkZVJpZ2h0KSBkZWNvckludmFkaW5nKys7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQuZGVjb3JOZWFyID0gZGVjb3JOZWFyO1xuICAgICAgICBvdXQuZGVjb3JMZWZ0ID0gZGVjb3JMZWZ0O1xuICAgICAgICBvdXQuZGVjb3JSaWdodCA9IGRlY29yUmlnaHQ7XG4gICAgICAgIG91dC5kZWNvckludmFkaW5nVGV4dENvbHVtbiA9IGRlY29ySW52YWRpbmc7XG5cbiAgICAgICAgdmFyIGRlY29yQXJvdW5kID0gKGRlY29yTGVmdCA+IDAgJiYgZGVjb3JSaWdodCA+IDApIHx8IGRlY29yTmVhciA+PSAzO1xuICAgICAgICB2YXIgY2VudGVyZWRTaW5nbGVUZXh0Q29sdW1uID0gb3V0LnNpbmdsZVRleHRDb2x1bW4gJiYgKG91dC5jZW50ZXJlZEJ5QWxpZ24gfHwgb3V0LmNlbnRlcmVkQnlHZW9tZXRyeSk7XG4gICAgICAgIG91dC5pc0hlcm8gPSBleHBsaWNpdEhlcm8gfHwgY2VudGVyZWRTaW5nbGVUZXh0Q29sdW1uO1xuICAgICAgICBvdXQucmVhc29uID0gb3V0LmlzSGVyb1xuICAgICAgICAgID8gKFxuICAgICAgICAgICAgZXhwbGljaXRIZXJvXG4gICAgICAgICAgICAgID8gXCJleHBsaWNpdEhlcm9Sb2xlXCJcbiAgICAgICAgICAgICAgOiAoZGVjb3JJbnZhZGluZyA+IDBcbiAgICAgICAgICAgICAgICA/IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uRGVjb3JJbnZhZGVzXCJcbiAgICAgICAgICAgICAgICA6IChkZWNvckFyb3VuZFxuICAgICAgICAgICAgICAgICAgPyBcInNpbmdsZUNlbnRlcmVkVGV4dENvbHVtbldpdGhEZWNvclwiXG4gICAgICAgICAgICAgICAgICA6IFwic2luZ2xlQ2VudGVyZWRUZXh0Q29sdW1uXCIpKVxuICAgICAgICAgIClcbiAgICAgICAgICA6IFwibm9IZXJvU2lnbmFsXCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGVjdElubGluZVBhaXJOb1JlZmxvdyhmbG93SXRlbXMsIGFsbEl0ZW1zLCByb290VywgQ0ZHKXtcbiAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICBza2lwOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgdG90YWxGbG93OiBmbG93SXRlbXMgPyBmbG93SXRlbXMubGVuZ3RoIDogMCxcbiAgICAgICAgICB0b3RhbEFsbDogYWxsSXRlbXMgPyBhbGxJdGVtcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJvd0RlbHRhOiBudWxsLFxuICAgICAgICAgIHJvd1RvbDogbnVsbCxcbiAgICAgICAgICBwYWlyU3BhbjogbnVsbCxcbiAgICAgICAgICBwYWlyU3BhblJhdGlvOiBudWxsLFxuICAgICAgICAgIGZpdHNUb2dldGhlcjogZmFsc2UsXG4gICAgICAgICAgYm90aFNtYWxsOiBmYWxzZSxcbiAgICAgICAgICBzbWFsbFdMaW1pdDogbnVsbCxcbiAgICAgICAgICBzbWFsbEhMaW1pdDogbnVsbCxcbiAgICAgICAgICB3aWR0aHM6IFtdLFxuICAgICAgICAgIGhlaWdodHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZmxvd0l0ZW1zIHx8IGZsb3dJdGVtcy5sZW5ndGggIT09IDIgfHwgIWFsbEl0ZW1zIHx8IGFsbEl0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhcm9vdFcgfHwgcm9vdFcgPD0gMCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vdEV4YWN0UGFpclwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGZsb3dJdGVtc1swXTtcbiAgICAgICAgdmFyIGIgPSBmbG93SXRlbXNbMV07XG4gICAgICAgIHZhciBhVyA9IE1hdGgubWF4KDAsIE51bWJlcihhLndpZHRoIHx8IDApKTtcbiAgICAgICAgdmFyIGJXID0gTWF0aC5tYXgoMCwgTnVtYmVyKGIud2lkdGggfHwgMCkpO1xuICAgICAgICB2YXIgYUggPSBNYXRoLm1heCgwLCBOdW1iZXIoYS5oZWlnaHQgfHwgMCkpO1xuICAgICAgICB2YXIgYkggPSBNYXRoLm1heCgwLCBOdW1iZXIoYi5oZWlnaHQgfHwgMCkpO1xuICAgICAgICBvdXQud2lkdGhzID0gWythVy50b0ZpeGVkKDEpLCArYlcudG9GaXhlZCgxKV07XG4gICAgICAgIG91dC5oZWlnaHRzID0gWythSC50b0ZpeGVkKDEpLCArYkgudG9GaXhlZCgxKV07XG5cbiAgICAgICAgaWYgKGFXIDwgMiB8fCBiVyA8IDIgfHwgYUggPCAyIHx8IGJIIDwgMikge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcImludmFsaWRTaXplc1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93VG9sID0gTWF0aC5tYXgoMTIsIE51bWJlcigoQ0ZHICYmIENGRy5ST1dfVE9MKSB8fCAyOCkgKiAxLjIpO1xuICAgICAgICB2YXIgcm93RGVsdGEgPSBNYXRoLmFicyhOdW1iZXIoYS50b3AgfHwgMCkgLSBOdW1iZXIoYi50b3AgfHwgMCkpO1xuICAgICAgICBvdXQucm93VG9sID0gK3Jvd1RvbC50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQucm93RGVsdGEgPSArcm93RGVsdGEudG9GaXhlZCgxKTtcbiAgICAgICAgaWYgKHJvd0RlbHRhID4gcm93VG9sKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90SW5saW5lUm93XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzbWFsbFdMaW1pdCA9IE1hdGgubWF4KDc0LCByb290VyAqIDAuNDIpO1xuICAgICAgICB2YXIgc21hbGxITGltaXQgPSBNYXRoLm1heCgzNCwgcm9vdFcgKiAwLjIpO1xuICAgICAgICBvdXQuc21hbGxXTGltaXQgPSArc21hbGxXTGltaXQudG9GaXhlZCgxKTtcbiAgICAgICAgb3V0LnNtYWxsSExpbWl0ID0gK3NtYWxsSExpbWl0LnRvRml4ZWQoMSk7XG4gICAgICAgIHZhciBib3RoU21hbGwgPVxuICAgICAgICAgIGFXIDw9IHNtYWxsV0xpbWl0ICYmXG4gICAgICAgICAgYlcgPD0gc21hbGxXTGltaXQgJiZcbiAgICAgICAgICBhSCA8PSBzbWFsbEhMaW1pdCAmJlxuICAgICAgICAgIGJIIDw9IHNtYWxsSExpbWl0O1xuICAgICAgICBvdXQuYm90aFNtYWxsID0gYm90aFNtYWxsO1xuICAgICAgICBpZiAoIWJvdGhTbWFsbCkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcInBhaXJOb3RTbWFsbFwiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFpckxlZnQgPSBNYXRoLm1pbihOdW1iZXIoYS5sZWZ0IHx8IDApLCBOdW1iZXIoYi5sZWZ0IHx8IDApKTtcbiAgICAgICAgdmFyIHBhaXJSaWdodCA9IE1hdGgubWF4KE51bWJlcihhLmxlZnQgfHwgMCkgKyBhVywgTnVtYmVyKGIubGVmdCB8fCAwKSArIGJXKTtcbiAgICAgICAgdmFyIHBhaXJTcGFuID0gTWF0aC5tYXgoMCwgcGFpclJpZ2h0IC0gcGFpckxlZnQpO1xuICAgICAgICB2YXIgZml0c1RvZ2V0aGVyID0gcGFpclNwYW4gPD0gKHJvb3RXICsgMSk7XG4gICAgICAgIG91dC5wYWlyU3BhbiA9ICtwYWlyU3Bhbi50b0ZpeGVkKDEpO1xuICAgICAgICBvdXQucGFpclNwYW5SYXRpbyA9ICsocGFpclNwYW4gLyBNYXRoLm1heCgxLCByb290VykpLnRvRml4ZWQoMyk7XG4gICAgICAgIG91dC5maXRzVG9nZXRoZXIgPSBmaXRzVG9nZXRoZXI7XG5cbiAgICAgICAgaWYgKGZpdHNUb2dldGhlcikge1xuICAgICAgICAgIG91dC5za2lwID0gdHJ1ZTtcbiAgICAgICAgICBvdXQucmVhc29uID0gXCJzbWFsbElubGluZVBhaXJGaXRzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5yZWFzb24gPSBcInNtYWxsSW5saW5lUGFpck92ZXJmbG93XCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVuZm9yY2VJbmxpbmVQYWlyR2FwKGZsb3dJdGVtcywgcm9vdEVsLCByb290Vyl7XG4gICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgYXBwbGllZDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgIG1pbkdhcDogNixcbiAgICAgICAgICBnYXBCZWZvcmU6IG51bGwsXG4gICAgICAgICAgZ2FwQWZ0ZXI6IG51bGwsXG4gICAgICAgICAgbmVlZDogbnVsbCxcbiAgICAgICAgICBtb3ZlTGVmdDogMCxcbiAgICAgICAgICBtb3ZlUmlnaHQ6IDAsXG4gICAgICAgICAgb3ZlcmZsb3dCZWZvcmU6IGZhbHNlLFxuICAgICAgICAgIG92ZXJmbG93QWZ0ZXI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciByb290UGFkTGVmdCA9IDA7XG4gICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICB2YXIgcm9vdENTID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWwpO1xuICAgICAgICAgIHJvb3RQYWRMZWZ0ID0gcGFyc2VGbG9hdChyb290Q1MucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG93SXRlbXMgfHwgZmxvd0l0ZW1zLmxlbmd0aCAhPT0gMiB8fCAhcm9vdEVsIHx8ICFyb290VyB8fCByb290VyA8PSAwKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwibm90RXhhY3RQYWlyXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gZmxvd0l0ZW1zWzBdO1xuICAgICAgICB2YXIgYiA9IGZsb3dJdGVtc1sxXTtcbiAgICAgICAgaWYgKCFhIHx8ICFiIHx8ICFhLm5vZGUgfHwgIWIubm9kZSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm1pc3NpbmdOb2Rlc1wiO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdEl0ZW0gPSBOdW1iZXIoYS5sZWZ0IHx8IDApIDw9IE51bWJlcihiLmxlZnQgfHwgMCkgPyBhIDogYjtcbiAgICAgICAgdmFyIHJpZ2h0SXRlbSA9IChsZWZ0SXRlbSA9PT0gYSkgPyBiIDogYTtcblxuICAgICAgICB2YXIgcnJMID0gcmVsUmVjdChsZWZ0SXRlbS5ub2RlLCByb290RWwpO1xuICAgICAgICB2YXIgcnJSID0gcmVsUmVjdChyaWdodEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIGxMZWZ0ID0gTnVtYmVyKHJyTC5sZWZ0IHx8IDApO1xuICAgICAgICB2YXIgbFcgPSBOdW1iZXIocnJMLndpZHRoIHx8IDApO1xuICAgICAgICB2YXIgckxlZnQgPSBOdW1iZXIocnJSLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciByVyA9IE51bWJlcihyclIud2lkdGggfHwgMCk7XG4gICAgICAgIGlmICghaXNGaW5pdGUobExlZnQpIHx8ICFpc0Zpbml0ZShsVykgfHwgIWlzRmluaXRlKHJMZWZ0KSB8fCAhaXNGaW5pdGUoclcpKSB7XG4gICAgICAgICAgb3V0LnJlYXNvbiA9IFwiaW52YWxpZFJlY3RzXCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnYXBCZWZvcmUgPSByTGVmdCAtIChsTGVmdCArIGxXKTtcbiAgICAgICAgb3V0LmdhcEJlZm9yZSA9ICtnYXBCZWZvcmUudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0Lm92ZXJmbG93QmVmb3JlID0gKGxMZWZ0IDwgLTAuNSkgfHwgKChyTGVmdCArIHJXKSA+IChyb290VyArIDAuNSkpO1xuXG4gICAgICAgIHZhciBuZWVkID0gTWF0aC5tYXgoMCwgb3V0Lm1pbkdhcCAtIGdhcEJlZm9yZSk7XG4gICAgICAgIG91dC5uZWVkID0gK25lZWQudG9GaXhlZCgyKTtcbiAgICAgICAgaWYgKG5lZWQgPD0gMC4yNSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcImFscmVhZHlTcGFjZWRcIjtcbiAgICAgICAgICBvdXQuZ2FwQWZ0ZXIgPSBvdXQuZ2FwQmVmb3JlO1xuICAgICAgICAgIG91dC5vdmVyZmxvd0FmdGVyID0gb3V0Lm92ZXJmbG93QmVmb3JlO1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXZhaWxSaWdodCA9IE1hdGgubWF4KDAsIHJvb3RXIC0gKHJMZWZ0ICsgclcpKTtcbiAgICAgICAgdmFyIGF2YWlsTGVmdCA9IE1hdGgubWF4KDAsIGxMZWZ0KTtcbiAgICAgICAgdmFyIG1vdmVSaWdodCA9IE1hdGgubWluKGF2YWlsUmlnaHQsIG5lZWQpO1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gTWF0aC5tYXgoMCwgbmVlZCAtIG1vdmVSaWdodCk7XG4gICAgICAgIHZhciBtb3ZlTGVmdCA9IE1hdGgubWluKGF2YWlsTGVmdCwgcmVtYWluaW5nKTtcblxuICAgICAgICBpZiAobW92ZVJpZ2h0IDw9IDAuMDEgJiYgbW92ZUxlZnQgPD0gMC4wMSkge1xuICAgICAgICAgIG91dC5yZWFzb24gPSBcIm5vUm9vbVRvQWRqdXN0XCI7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3ZlUmlnaHQgPiAwLjAxKSB7XG4gICAgICAgICAgcmlnaHRJdGVtLm5vZGUuc3R5bGUubGVmdCA9ICgoTnVtYmVyKHJpZ2h0SXRlbS5sZWZ0IHx8IDApICsgbW92ZVJpZ2h0KSAtIHJvb3RQYWRMZWZ0KSArIFwicHhcIjtcbiAgICAgICAgICByaWdodEl0ZW0ubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHJpZ2h0SXRlbS5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlTGVmdCA+IDAuMDEpIHtcbiAgICAgICAgICBsZWZ0SXRlbS5ub2RlLnN0eWxlLmxlZnQgPSAoKE51bWJlcihsZWZ0SXRlbS5sZWZ0IHx8IDApIC0gbW92ZUxlZnQpIC0gcm9vdFBhZExlZnQpICsgXCJweFwiO1xuICAgICAgICAgIGxlZnRJdGVtLm5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICBsZWZ0SXRlbS5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJyTDIgPSByZWxSZWN0KGxlZnRJdGVtLm5vZGUsIHJvb3RFbCk7XG4gICAgICAgIHZhciByclIyID0gcmVsUmVjdChyaWdodEl0ZW0ubm9kZSwgcm9vdEVsKTtcbiAgICAgICAgdmFyIGxMZWZ0MiA9IE51bWJlcihyckwyLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciBsVzIgPSBOdW1iZXIocnJMMi53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIHJMZWZ0MiA9IE51bWJlcihyclIyLmxlZnQgfHwgMCk7XG4gICAgICAgIHZhciByVzIgPSBOdW1iZXIocnJSMi53aWR0aCB8fCAwKTtcbiAgICAgICAgdmFyIGdhcEFmdGVyID0gckxlZnQyIC0gKGxMZWZ0MiArIGxXMik7XG5cbiAgICAgICAgb3V0Lm1vdmVSaWdodCA9ICttb3ZlUmlnaHQudG9GaXhlZCgyKTtcbiAgICAgICAgb3V0Lm1vdmVMZWZ0ID0gK21vdmVMZWZ0LnRvRml4ZWQoMik7XG4gICAgICAgIG91dC5nYXBBZnRlciA9IGlzRmluaXRlKGdhcEFmdGVyKSA/ICtnYXBBZnRlci50b0ZpeGVkKDIpIDogbnVsbDtcbiAgICAgICAgb3V0Lm92ZXJmbG93QWZ0ZXIgPSAobExlZnQyIDwgLTAuNSkgfHwgKChyTGVmdDIgKyByVzIpID4gKHJvb3RXICsgMC41KSk7XG4gICAgICAgIG91dC5hcHBsaWVkID0gKG1vdmVSaWdodCA+IDAuMDEgfHwgbW92ZUxlZnQgPiAwLjAxKTtcbiAgICAgICAgb3V0LnJlYXNvbiA9IG91dC5hcHBsaWVkID8gXCJhcHBsaWVkXCIgOiBcIm5vQ2hhbmdlXCI7XG4gICAgICAgIGlmIChpc0Zpbml0ZShnYXBBZnRlcikgJiYgZ2FwQWZ0ZXIgPCAtMC4yKSBvdXQucmVhc29uID0gXCJhcHBsaWVkQnV0U3RpbGxPdmVybGFwXCI7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taW5lbnROb25UZXh0Q291bnQgPSBpdGVtc0FsbC5maWx0ZXIoZnVuY3Rpb24oaXQpe1xuICAgICAgICBpZiAoKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHcgPSBOdW1iZXIoaXQud2lkdGggfHwgMCk7XG4gICAgICAgIHZhciBoID0gTnVtYmVyKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKHcgPCBNYXRoLm1heCgxMCwgY29udGVudFcgKiAwLjA2KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaCA8IE1hdGgubWF4KDEwLCBjb250ZW50VyAqIDAuMDQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkubGVuZ3RoO1xuICAgICAgdmFyIGFsbG93SGV1cmlzdGljQW5jaG9ycyA9IHByb21pbmVudE5vblRleHRDb3VudCA8PSAxO1xuXG4gICAgICAvLyDinIUgRGV0ZXJtaW5hciBxdcOpIG5vZG9zIHNvbiBcIkFOQ0hPUlwiIChubyBzZSByZWZsb3dlYW4pXG4gICAgICAvLyBSZWdsYTogdGV4dG8gY2VudHJhZG8gKyBjYXNpIGZ1bGwtd2lkdGggPT4gdMOtdHVsby9oZXJvLCBubyBtb3Zlci5cbiAgICAgIGZ1bmN0aW9uIGlzQW5jaG9yTm9kZShpdCl7XG4gICAgICAgIHZhciBub2RlID0gaXQubm9kZTtcblxyXG4gICAgICAgIC8vIG9wdC1vdXQgZXhwbMOtY2l0b1xyXG4gICAgICAgIHZhciBrZWVwTGF5b3V0ID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICBpZiAoa2VlcExheW91dCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIGFuY2hvciBleHBsw61jaXRvIChzaSBsbyB1c8OhcylcclxuICAgICAgICB2YXIgcm9sZSA9IChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLXJvbGVcIikgfHwgXCJcIik7XHJcbiAgICAgICAgaWYgKHJvbGUgPT09IFwiYW5jaG9yXCIpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAvLyBoZXVyw61zdGljYSBwYXJhIHRleHRvc1xuICAgICAgICB2YXIgaXNUZXh0ID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgIGlmICghaXNUZXh0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYWxsb3dIZXVyaXN0aWNBbmNob3JzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHRhID0gKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZS50ZXh0QWxpZ24pID8gU3RyaW5nKG5vZGUuc3R5bGUudGV4dEFsaWduKS50b0xvd2VyQ2FzZSgpIDogXCJcIjtcbiAgICAgICAgaWYgKCF0YSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YSA9IFN0cmluZyhnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnRleHRBbGlnbiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH0gY2F0Y2goX2UpIHt9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhICE9PSBcImNlbnRlclwiKSByZXR1cm4gZmFsc2U7XG5cclxuICAgICAgICAvLyBzb2xvIHNpIHJlYWxtZW50ZSBvY3VwYSBjYXNpIHRvZG8gZWwgYW5jaG8gdXNhYmxlXHJcbiAgICAgICAgLy8gKGVzdG8gZXZpdGEgcm9tcGVyIHRleHRvcyBjZW50cmFkb3MgZGVudHJvIGRlIGNvbHVtbmFzKVxyXG4gICAgICAgIGlmIChjb250ZW50VyA+IDAgJiYgaXQud2lkdGggPj0gY29udGVudFcgKiAwLjc4KSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyDinIUgRmxvdyA9IHRvZG8gbG8gcXVlIE5PIGVzIGFuY2hvclxuICAgICAgdmFyIGl0ZW1zRmxvdyA9IGl0ZW1zQWxsLmZpbHRlcihmdW5jdGlvbihpdCl7IHJldHVybiAhaXNBbmNob3JOb2RlKGl0KTsgfSk7XG4gICAgICB2YXIgaXRlbXNBbmNob3IgPSBpdGVtc0FsbC5maWx0ZXIoZnVuY3Rpb24oaXQpeyByZXR1cm4gaXNBbmNob3JOb2RlKGl0KTsgfSk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmFuY2hvclNwbGl0XCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBhbmNob3JzOiBpdGVtc0FuY2hvci5sZW5ndGgsXG4gICAgICAgIGZsb3c6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgIHByb21pbmVudE5vblRleHRDb3VudDogcHJvbWluZW50Tm9uVGV4dENvdW50LFxuICAgICAgICBhbGxvd0hldXJpc3RpY0FuY2hvcnM6IGFsbG93SGV1cmlzdGljQW5jaG9ycyxcbiAgICAgICAgYW5jaG9yc0RldGFpbDogaXRlbXNBbmNob3IubWFwKGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIgPyBcInRleHRvXCIgOiAoaXQubm9kZS50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICB0b3A6ICtpdC50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGxlZnQ6ICtpdC5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3OiAraXQud2lkdGgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGg6ICtpdC5oZWlnaHQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIHRleHRBbGlnbjogKGl0Lm5vZGUuc3R5bGUgJiYgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24pID8gaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gOiBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXHJcbiAgICAgIC8vIFNpIG5vIGhheSBzdWZpY2llbnRlcyBlbGVtZW50b3MgcmVmbG93YWJsZXMsIG5vIGhhY2Vtb3MgbmFkYVxuICAgICAgaWYoaXRlbXNGbG93Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJza2lwOmZsb3dUb29TbWFsbFwiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGgsXG4gICAgICAgICAgYW5jaG9yQ291bnQ6IGl0ZW1zQW5jaG9yLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cclxuICAgICAgLy8g4pyFIFBhcmEgcXVlIFwiYWx0dXJhIG5lY2VzYXJpYVwiIG5vIHF1ZWRlIGNvcnRhLFxyXG4gICAgICAvLyBtZWRpbW9zIGVsIGJvdHRvbSBtw6F4aW1vIGRlIGFuY2hvcnMgKGVuIGNvb3JkcyBkZWwgY29udGVudClcclxuICAgICAgdmFyIG1heEFuY2hvckJvdHRvbSA9IDA7XHJcbiAgICAgIGl0ZW1zQWxsLmZvckVhY2goZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIGlmICghaXNBbmNob3JOb2RlKGl0KSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBiID0gKGl0LnRvcCB8fCAwKSArIChpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgaWYgKGIgPiBtYXhBbmNob3JCb3R0b20pIG1heEFuY2hvckJvdHRvbSA9IGI7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8g4pyFIDEpIGFncnVwYXIgcG9yIHNvbGFwZSDihpIgY2x1c3RlcnMgKFNPTE8gRkxPVylcbiAgICAgIHZhciBjbHVzdGVycyA9IGJ1aWxkT3ZlcmxhcENsdXN0ZXJzKGl0ZW1zRmxvdyk7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOmNsdXN0ZXJzXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBjb3VudDogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBjbHVzdGVyczogY2x1c3RlcnMubWFwKGZ1bmN0aW9uKGMsIGlkeCl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGk6IGlkeCxcbiAgICAgICAgICAgIHRvcDogK2MudG9wLnRvRml4ZWQoMSksXG4gICAgICAgICAgICBsZWZ0OiArYy5sZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICB3OiArYy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgaDogK2MuaGVpZ2h0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICBjeDogK2MuY3gudG9GaXhlZCgxKSxcbiAgICAgICAgICAgIGl0ZW1zOiBjLml0ZW1zLmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgLy8g4pyFIDIpIERldGVjdGFyIGNvbHVtbmFzL3Jvd3MgKFNPTE8gRkxPVylcbiAgICAgIHZhciByb290VyA9IGNvbnRlbnRXIHx8IDA7XG4gICAgICB2YXIgb3JkID0gb3JkZXJDbHVzdGVyc0Zvck1vYmlsZShjbHVzdGVycywgcm9vdFcsIENGRyk7XG4gICAgICB2YXIgZ3JvdXBzID0gb3JkLmdyb3VwcztcbiAgICAgIHZhciBtb2RlID0gb3JkLm1vZGU7XG4gICAgICBtc2xMb2coXCJzZWN0aW9uOm9yZGVyaW5nXCIsIHtcbiAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICByb290Vzogcm9vdFcsXG4gICAgICAgIGdyb3VwczogZ3JvdXBzLm1hcChmdW5jdGlvbihncnAsIGdpKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZzogZ2ksXG4gICAgICAgICAgICBjb3VudDogZ3JwLmxlbmd0aCxcbiAgICAgICAgICAgIHRvcHM6IGdycC5tYXAoZnVuY3Rpb24oYyl7IHJldHVybiArYy50b3AudG9GaXhlZCgxKTsgfSksXG4gICAgICAgICAgICBsZWZ0czogZ3JwLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuICtjLmxlZnQudG9GaXhlZCgxKTsgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBoZXJvU2lnbmFsID0gZGV0ZWN0SGVyb0xpa2VDZW50cmFsVGV4dChpdGVtc0FsbCwgcm9vdFcpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjpoZXJvQ2hlY2tcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGlzSGVybzogaGVyb1NpZ25hbC5pc0hlcm8sXG4gICAgICAgIHJlYXNvbjogaGVyb1NpZ25hbC5yZWFzb24sXG4gICAgICAgIHRleHRDb3VudDogaGVyb1NpZ25hbC50ZXh0Q291bnQsXG4gICAgICAgIHRleHRDb2x1bW5Db3VudDogaGVyb1NpZ25hbC50ZXh0Q29sdW1uQ291bnQsXG4gICAgICAgIHNpbmdsZVRleHRDb2x1bW46IGhlcm9TaWduYWwuc2luZ2xlVGV4dENvbHVtbixcbiAgICAgICAgdGV4dENvbHVtbnM6IGhlcm9TaWduYWwudGV4dENvbHVtbnMsXG4gICAgICAgIG1heFRleHRXaWR0aFJhdGlvOiBoZXJvU2lnbmFsLm1heFRleHRXaWR0aFJhdGlvLFxuICAgICAgICB3aWR0aFJhdGlvOiBoZXJvU2lnbmFsLndpZHRoUmF0aW8sXG4gICAgICAgIGNlbnRlckRlbHRhOiBoZXJvU2lnbmFsLmNlbnRlckRlbHRhLFxuICAgICAgICBjZW50ZXJUb2w6IGhlcm9TaWduYWwuY2VudGVyVG9sLFxuICAgICAgICBjZW50ZXJlZEJ5QWxpZ246IGhlcm9TaWduYWwuY2VudGVyZWRCeUFsaWduLFxuICAgICAgICBjZW50ZXJlZEJ5R2VvbWV0cnk6IGhlcm9TaWduYWwuY2VudGVyZWRCeUdlb21ldHJ5LFxuICAgICAgICBkZWNvck5lYXI6IGhlcm9TaWduYWwuZGVjb3JOZWFyLFxuICAgICAgICBkZWNvckxlZnQ6IGhlcm9TaWduYWwuZGVjb3JMZWZ0LFxuICAgICAgICBkZWNvclJpZ2h0OiBoZXJvU2lnbmFsLmRlY29yUmlnaHQsXG4gICAgICAgIGRlY29ySW52YWRpbmdUZXh0Q29sdW1uOiBoZXJvU2lnbmFsLmRlY29ySW52YWRpbmdUZXh0Q29sdW1uXG4gICAgICB9KTtcbiAgICAgIGlmIChoZXJvU2lnbmFsLmlzSGVybykge1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6aGVyb0NlbnRyYWxUZXh0XCIsIHtcbiAgICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IGZhbHNlLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgaGVyb1JlYXNvbjogaGVyb1NpZ25hbC5yZWFzb24sXG4gICAgICAgICAgaGVybzogaGVyb1NpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmxpbmVQYWlyU2lnbmFsID0gZGV0ZWN0SW5saW5lUGFpck5vUmVmbG93KGl0ZW1zRmxvdywgaXRlbXNBbGwsIHJvb3RXLCBDRkcpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjppbmxpbmVQYWlyQ2hlY2tcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHNraXA6IGlubGluZVBhaXJTaWduYWwuc2tpcCxcbiAgICAgICAgcmVhc29uOiBpbmxpbmVQYWlyU2lnbmFsLnJlYXNvbixcbiAgICAgICAgdG90YWxGbG93OiBpbmxpbmVQYWlyU2lnbmFsLnRvdGFsRmxvdyxcbiAgICAgICAgdG90YWxBbGw6IGlubGluZVBhaXJTaWduYWwudG90YWxBbGwsXG4gICAgICAgIHJvd0RlbHRhOiBpbmxpbmVQYWlyU2lnbmFsLnJvd0RlbHRhLFxuICAgICAgICByb3dUb2w6IGlubGluZVBhaXJTaWduYWwucm93VG9sLFxuICAgICAgICB3aWR0aHM6IGlubGluZVBhaXJTaWduYWwud2lkdGhzLFxuICAgICAgICBoZWlnaHRzOiBpbmxpbmVQYWlyU2lnbmFsLmhlaWdodHMsXG4gICAgICAgIGJvdGhTbWFsbDogaW5saW5lUGFpclNpZ25hbC5ib3RoU21hbGwsXG4gICAgICAgIHNtYWxsV0xpbWl0OiBpbmxpbmVQYWlyU2lnbmFsLnNtYWxsV0xpbWl0LFxuICAgICAgICBzbWFsbEhMaW1pdDogaW5saW5lUGFpclNpZ25hbC5zbWFsbEhMaW1pdCxcbiAgICAgICAgcGFpclNwYW46IGlubGluZVBhaXJTaWduYWwucGFpclNwYW4sXG4gICAgICAgIHBhaXJTcGFuUmF0aW86IGlubGluZVBhaXJTaWduYWwucGFpclNwYW5SYXRpbyxcbiAgICAgICAgZml0c1RvZ2V0aGVyOiBpbmxpbmVQYWlyU2lnbmFsLmZpdHNUb2dldGhlclxuICAgICAgfSk7XG4gICAgICBpZiAoaW5saW5lUGFpclNpZ25hbC5za2lwKSB7XG4gICAgICAgIHZhciBpbmxpbmVQYWlyQWRqdXN0ID0gZW5mb3JjZUlubGluZVBhaXJHYXAoaXRlbXNGbG93LCBjb250ZW50LCByb290Vyk7XG4gICAgICAgIG1zbExvZyhcInNlY3Rpb246aW5saW5lUGFpckFkanVzdFwiLCB7XG4gICAgICAgICAgc2VjSW5kZXg6IHNlY0luZGV4LFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgYWRqdXN0OiBpbmxpbmVQYWlyQWRqdXN0XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dSZWZsb3dEZWNpc2lvbihcInNraXA6c21hbGxJbmxpbmVQYWlyRml0c1wiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGlubGluZVBhaXI6IGlubGluZVBhaXJTaWduYWwsXG4gICAgICAgICAgaW5saW5lUGFpckFkanVzdDogaW5saW5lUGFpckFkanVzdFxuICAgICAgICB9KTtcbiAgICAgICAgZmluYWxpemVTZWN0aW9uKDAsIGJhc2VCb3R0b21HYXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIOKchSAzKSBHYXRlIFwibWVqb3IgZGUgYW1ib3MgbXVuZG9zXCI6XG4gICAgICAvLyAtIFNpIGVzIFwib25lXCIgKGxheW91dCB5YSBuYXR1cmFsKSBZIGFkZW3DoXMgZW50cmEsIE5PIGhhY2Vtb3MgcmVmbG93LlxuICAgICAgLy8gLSBFbiBjdWFscXVpZXIgb3RybyBjYXNvICh0d28vdGhyZWUvcm93cyksIGhhY2Vtb3MgcmVmbG93IHBhcmEgbGVjdHVyYSBtb2JpbGUsXG4gICAgICAvLyAgIGluY2x1c28gYXVucXVlIFwiZW50cmVcIi5cclxuICAgICAgdmFyIGZpdHMgPSBjbHVzdGVyc0ZpdEluTW9iaWxlKGNsdXN0ZXJzLCBjb250ZW50KTtcbiAgICAgIG1zbExvZyhcInNlY3Rpb246Zml0Q2hlY2tcIiwge1xuICAgICAgICBzZWNJbmRleDogc2VjSW5kZXgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGZpdHM6IGZpdHMsXG4gICAgICAgIHdpbGxTa2lwOiAobW9kZSA9PT0gXCJvbmVcIiAmJiBmaXRzKVxuICAgICAgfSk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJvbmVcIiAmJiBmaXRzKSB7XG4gICAgICAgIGxvZ1JlZmxvd0RlY2lzaW9uKFwic2tpcDptb2RlT25lRml0c1wiLCB7XG4gICAgICAgICAgd2lsbEFwcGx5UmVmbG93OiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGZpdHM6IGZpdHMsXG4gICAgICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgICBmbG93Q291bnQ6IGl0ZW1zRmxvdy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsaXplU2VjdGlvbigwLCBiYXNlQm90dG9tR2FwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2dSZWZsb3dEZWNpc2lvbihcImFwcGx5Om1vZGVSZXF1aXJlc1JlZmxvd1wiLCB7XG4gICAgICAgIHdpbGxBcHBseVJlZmxvdzogdHJ1ZSxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgZml0czogZml0cyxcbiAgICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgZmxvd0NvdW50OiBpdGVtc0Zsb3cubGVuZ3RoLFxuICAgICAgICBhbmNob3JDb3VudDogaXRlbXNBbmNob3IubGVuZ3RoLFxuICAgICAgICBncm91cFNpemVzOiBncm91cHMubWFwKGZ1bmN0aW9uKGdycCl7IHJldHVybiBncnAubGVuZ3RoOyB9KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIOKchSA0KSBSZWZsb3cgc29sbyBzb2JyZSBGTE9XIChwcmVzZXJ2YSBzb2xhcGVzIGRlbnRybyBkZSBjYWRhIGNsdXN0ZXIpXG4gICAgICB2YXIgcmVzID0gYXBwbHlDbHVzdGVyU3RhY2soZ3JvdXBzLCBjb250ZW50LCBDRkcsIG1vZGUpO1xuICAgICAgbXNsTG9nKFwic2VjdGlvbjphcHBseVJlc3VsdFwiLCB7XG4gICAgICAgIHNlY0luZGV4OiBzZWNJbmRleCxcbiAgICAgICAgY2hhbmdlZDogISEocmVzICYmIHJlcy5jaGFuZ2VkKSxcbiAgICAgICAgbmVlZGVkSGVpZ2h0OiByZXMgPyByZXMubmVlZGVkSGVpZ2h0IDogbnVsbCxcbiAgICAgICAgbWF4QW5jaG9yQm90dG9tOiArbWF4QW5jaG9yQm90dG9tLnRvRml4ZWQoMSksXG4gICAgICAgIGJhc2VCb3R0b21HYXA6ICtiYXNlQm90dG9tR2FwLnRvRml4ZWQoMSlcbiAgICAgIH0pO1xuICAgICAgbG9nUmVmbG93RGVjaXNpb24oXCJwb3N0QXBwbHlcIiwge1xuICAgICAgICB3aWxsQXBwbHlSZWZsb3c6IHRydWUsXG4gICAgICAgIGNoYW5nZWQ6ICEhKHJlcyAmJiByZXMuY2hhbmdlZCksXG4gICAgICAgIG5lZWRlZEhlaWdodDogcmVzID8gK051bWJlcihyZXMubmVlZGVkSGVpZ2h0IHx8IDApLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KTtcblxuICAgICAgdmFyIG5lZWRlZEFmdGVyUmVmbG93ID0gMDtcbiAgICAgIGlmIChyZXMgJiYgcmVzLmNoYW5nZWQpIHtcbiAgICAgICAgLy8gRXZpdGFyIHF1ZSBsYSBzZWNjacOzbiBxdWVkZSBjaGljYSBzaSBoYXkgYW5jaG9ycyBtw6FzIGFiYWpvXG4gICAgICAgIHZhciBuZWVkZWQgPSBOdW1iZXIocmVzLm5lZWRlZEhlaWdodCB8fCAwKTtcbiAgICAgICAgaWYgKE51bWJlcihtYXhBbmNob3JCb3R0b20pID4gMCkge1xuICAgICAgICAgIC8vIHN1bWFtb3MgcGFkZGluZyBib3R0b20gcGFyYSBxdWUgbm8gcXVlZGUgcGVnYWRvXG4gICAgICAgICAgdmFyIGFuY2hvck5lZWRlZCA9IE1hdGguY2VpbChtYXhBbmNob3JCb3R0b20gKyAoQ0ZHLlBBRF9CT1QgfHwgMCkpO1xuICAgICAgICAgIGlmIChhbmNob3JOZWVkZWQgPiBuZWVkZWQpIG5lZWRlZCA9IGFuY2hvck5lZWRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUJvdHRvbUdhcCA+IDApIHtcbiAgICAgICAgICBuZWVkZWQgPSBNYXRoLmNlaWwobmVlZGVkICsgYmFzZUJvdHRvbUdhcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRlZCA+IDApIG5lZWRlZEFmdGVyUmVmbG93ID0gbmVlZGVkO1xuICAgICAgfVxuICAgICAgZmluYWxpemVTZWN0aW9uKG5lZWRlZEFmdGVyUmVmbG93LCBiYXNlQm90dG9tR2FwKTtcbiAgICB9KTtcbiAgfVxuXHJcbiAgZnVuY3Rpb24gYm9vdCgpe1xuICAgIG1zbExvZyhcImJvb3RcIiwgeyBjZmc6IENGRyB9KTtcbiAgICBydW5PbmNlKCk7XG4gICAgc2V0VGltZW91dChydW5PbmNlLCAxNTApO1xyXG4gICAgc2V0VGltZW91dChydW5PbmNlLCA2MDApO1xyXG4gICAgc2V0VGltZW91dChydW5PbmNlLCAxODAwKTtcclxuXHJcbiAgICBpZihkb2N1bWVudC5mb250cyAmJiBkb2N1bWVudC5mb250cy5yZWFkeSl7XHJcbiAgICAgIGRvY3VtZW50LmZvbnRzLnJlYWR5LnRoZW4oZnVuY3Rpb24oKXsgcnVuT25jZSgpOyB9KS5jYXRjaChmdW5jdGlvbigpe30pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGJvb3QpO1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJ1bk9uY2UpO1xyXG5cclxuICBpZih3aW5kb3cudmlzdWFsVmlld3BvcnQpe1xyXG4gICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcnVuT25jZSk7XHJcbiAgICB3aW5kb3cudmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBydW5PbmNlKTtcclxuICB9XHJcblxyXG4gIGlmKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSBib290KCk7XHJcbiAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBib290KTtcclxufSkoKTtcclxuPC9zY3JpcHQ+XHJcbmAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJqc0RvbUhlbHBlcnNCbG9jayIsImpzRml0U2NhbGVCbG9jayIsImpzT3JkZXJpbmdCbG9jayIsImpzU3RhY2tpbmdCbG9jayIsImJ1aWxkU2NyaXB0IiwiY2ZnIiwiZW5hYmxlZCIsIm1pbkdhcFB4IiwibWF4R2FwUHgiLCJnYXBTY2FsZSIsInBhZGRpbmdUb3BQeCIsInBhZGRpbmdCb3R0b21QeCIsIm9ubHlGaXhlZFNlY3Rpb25zIiwib25seVdoZW5SZW9yZGVyZWQiLCJyb3dUb2xQeCIsInR3b0NvbFNwcmVhZFJhdGlvIiwibWluUGVyQ29sdW1uMiIsInRocmVlQ29sU3ByZWFkUmF0aW8iLCJtaW5QZXJDb2x1bW4zIiwiZml0TWluU2NhbGUiLCJmaXRNYXhTY2FsZSIsImZpdFRhcmdldFdpZHRoUmF0aW8iLCJmaXRNaW5GaWxsUmF0aW8iLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/scriptTemplate.ts\n"));

/***/ })

});