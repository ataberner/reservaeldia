"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_functions_src_utils_generarHTMLDesdeSecciones_ts",{

/***/ "(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts":
/*!***********************************************************!*\
  !*** ./functions/src/utils/mobileSmartLayout/stacking.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jsStackingBlock: () => (/* binding */ jsStackingBlock)\n/* harmony export */ });\n// functions/src/utils/mobileSmartLayout/stacking.ts\nfunction jsStackingBlock() {\n    return '\\n  // Centro real del \\xe1rea usable (compensa padding safe-left/right)\\n  function computeCenterX(rootEl){\\n    var rootRect = rootEl.getBoundingClientRect();\\n    var rootW = rootRect.width || 0;\\n\\n    var cs = getComputedStyle(rootEl);\\n    var padL = parseFloat(cs.paddingLeft) || 0;\\n    var padR = parseFloat(cs.paddingRight) || 0;\\n\\n    var usableW = Math.max(0, rootW - padL - padR);\\n    var centerX = padL + usableW / 2; // centro del \\xe1rea usable\\n\\n    return { rootW: rootW, usableW: usableW, centerX: centerX, padL: padL, padR: padR };\\n  }\\n\\n  function clamp(n, a, b){\\n    if (!isFinite(n)) return a;\\n    return Math.max(a, Math.min(b, n));\\n  }\\n\\n  /**\\n   * Apila CLUSTERS por groups (columnas/filas) y:\\n   * - mueve cada cluster como bloque\\n   * - preserva solape/posiciones relativas dentro del cluster\\n   * - centra el cluster como bloque en el eje X (sin transform)\\n   *\\n   * Devuelve changed + neededHeight (para expandir secci\\xf3n)\\n   */\\n  function applyClusterStack(groups, rootEl, CFG, mode){\\n    var info = computeCenterX(rootEl);\\n    var centerX = info.centerX;\\n    mslLog(\"stack:start\", {\\n      groupCount: groups.length,\\n      groupSizes: groups.map(function(g){ return g.length; }),\\n      centerX: +centerX.toFixed(1),\\n      usableW: +info.usableW.toFixed(1)\\n    });\\n\\n    var changed = false;\\n    var isMultiColLayout = (mode === \"two\" || mode === \"three\");\\n\\n    // En multi-columna: cada columna apilada se centra por su propio bbox.\\n    // As\\xed, el centro de cada columna coincide con el centro de pantalla.\\n\\n    // --- Anchor global: d\\xf3nde estaba “el bloque” originalmente ---\\n    var firstGroup = groups[0] || [];\\n    var anchor = Infinity;\\n    for (var i=0;i<firstGroup.length;i++){\\n      anchor = Math.min(anchor, firstGroup[i].top);\\n    }\\n    if (!isFinite(anchor)) anchor = CFG.PAD_TOP;\\n    anchor = Math.max(CFG.PAD_TOP, anchor);\\n\\n    // Cursor global: d\\xf3nde termina el contenido apilado hasta ahora\\n    var globalCursor = anchor;\\n\\n    // Separaci\\xf3n entre columnas apiladas (izq, centro, der)\\n    var GROUP_GAP = 14;\\n\\n    for (var g=0; g<groups.length; g++){\\n      var col = groups[g] || [];\\n      if (!col.length) continue;\\n      var colReferenceCenterX = NaN;\\n      var colSourceReferenceCenterX = NaN;\\n      var narrowClusterCount = 0;\\n      var wideClusterCount = 0;\\n\\n      // M\\xe9tricas por grupo solo para debug.\\n      var groupMinLeft = Infinity;\\n      var groupMaxRight = -Infinity;\\n      if (isMultiColLayout){\\n        for (var gg=0; gg<col.length; gg++){\\n          groupMinLeft = Math.min(groupMinLeft, col[gg].left);\\n          groupMaxRight = Math.max(groupMaxRight, col[gg].left + col[gg].width);\\n          var clusterWDbg = Number(col[gg].width || 0);\\n          if (clusterWDbg <= (info.usableW * 0.72)) narrowClusterCount++;\\n          if (clusterWDbg >= (info.usableW * 0.88)) wideClusterCount++;\\n        }\\n      }\\n      var groupWidth = isMultiColLayout ? Math.max(0, groupMaxRight - groupMinLeft) : 0;\\n      var groupBaseLeft = isMultiColLayout ? (centerX - groupWidth / 2) : 0;\\n      var suspiciousWideSpan = isMultiColLayout &&\\n        col.length > 1 &&\\n        groupWidth >= (info.usableW * 0.88) &&\\n        narrowClusterCount >= 1 &&\\n        wideClusterCount >= 1;\\n      var preserveColumnOffsets = isMultiColLayout && !suspiciousWideSpan;\\n\\n      // Offset vertical original de esta columna respecto del anchor\\n      var colMinTop = Infinity;\\n      for (var k=0;k<col.length;k++){\\n        colMinTop = Math.min(colMinTop, col[k].top);\\n      }\\n      if (!isFinite(colMinTop)) colMinTop = anchor;\\n\\n      var colOffset = colMinTop - anchor;\\n      var colStart = globalCursor + (g === 0 ? 0 : GROUP_GAP) + Math.max(0, colOffset);\\n      mslLog(\"stack:group:start\", {\\n        g: g,\\n        colSize: col.length,\\n        colMinTop: +colMinTop.toFixed(1),\\n        colOffset: +colOffset.toFixed(1),\\n        colStart: +colStart.toFixed(1),\\n        globalCursor: +globalCursor.toFixed(1),\\n        mode: mode,\\n        groupMinLeft: isMultiColLayout ? +groupMinLeft.toFixed(1) : null,\\n        groupWidth: isMultiColLayout ? +groupWidth.toFixed(1) : null,\\n        groupBaseLeft: isMultiColLayout ? +groupBaseLeft.toFixed(1) : null,\\n        narrowClusterCount: isMultiColLayout ? narrowClusterCount : null,\\n        wideClusterCount: isMultiColLayout ? wideClusterCount : null,\\n        preserveColumnOffsets: isMultiColLayout ? preserveColumnOffsets : null\\n      });\\n\\n      // Cursor local de esta columna\\n      var colCursor = colStart;\\n\\n      for (var j=0; j<col.length; j++){\\n        var c = col[j];\\n\\n        // Top del cluster en el flujo mobile\\n        var clusterTop;\\n\\n        if (j === 0) {\\n          clusterTop = colCursor;\\n        } else {\\n          var prevC = col[j-1];\\n          var prevBottom = (clusterTopPrev + prevC.height);\\n\\n          // ✅ Gap original entre clusters (canvas)\\n          var prevBottomOrig = (prevC.top + prevC.height);\\n          var gapOrig = c.top - prevBottomOrig;\\n          if (!isFinite(gapOrig)) gapOrig = 0;\\n\\n          var overlapInSource = gapOrig < 0;\\n          if ((mode === \"two\" || mode === \"three\") && overlapInSource) {\\n            // Si en el original este cluster cae dentro del anterior, respetamos\\n            // su top relativo para no mandarlo al final de la columna.\\n            var relTopInCol = c.top - colMinTop;\\n            if (!isFinite(relTopInCol)) relTopInCol = 0;\\n            clusterTop = colStart + Math.max(0, relTopInCol);\\n          } else {\\n            // ✅ Gap “mobile-friendly”: escalado + clamp\\n            var gapWanted = clamp(gapOrig * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\\n\\n            // ✅ Anti-solape definitivo:\\n            //   el pr\\xf3ximo cluster SIEMPRE empieza despu\\xe9s del bottom real del anterior + gapWanted\\n            clusterTop = prevBottom + gapWanted;\\n\\n            // En multi-columna nunca avanzamos hacia arriba respecto al flujo ya consumido.\\n            if ((mode === \"two\" || mode === \"three\") && clusterTop < colCursor) {\\n              clusterTop = colCursor;\\n            }\\n          }\\n        }\\n\\n        // Guardamos para el pr\\xf3ximo loop\\n        var clusterTopPrev = clusterTop;\\n\\n        // \\xbfcentrar este cluster?\\n        var forceCenter = false;\\n        var hasTextInCluster = false;\\n        var hasNonTextInCluster = false;\\n        for (var t=0; t<c.items.length; t++){\\n          var isTextT = (c.items[t].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          if (isTextT) hasTextInCluster = true;\\n          else hasNonTextInCluster = true;\\n          if ((c.items[t].node.getAttribute(\"data-mobile-center\") || \"\") === \"force\") {\\n            forceCenter = true;\\n          }\\n        }\\n\\n        // one/rows: centro por cluster (comportamiento original)\\n        // two/three: apilar cada columna en la misma referencia X,\\n        // preservando offsets internos de esa columna.\\n        var keepCenter = forceCenter ? true : (c.width < (info.usableW * 0.95));\\n        var clusterLeft = keepCenter ? (centerX - c.width / 2) : c.left;\\n        var isTextOnlyCluster = hasTextInCluster && !hasNonTextInCluster;\\n        var shouldCenterTextWithinCluster = false;\\n        if (isMultiColLayout) {\\n          // Modo lectura mobile multi-col:\\n          // usar una misma referencia X para toda la columna apilada y\\n          // preservar el offset horizontal original de cada cluster.\\n          // Esto mantiene alineado texto/forma cuando la columna se parte\\n          // en varios clusters.\\n          // Si el bbox de la columna queda contaminado por un outlier ancho\\n          // (tipicamente texto), centrar por offsets deja la columna pegada\\n          // al borde; en ese caso centramos cada cluster individualmente.\\n          if (preserveColumnOffsets) {\\n            var relClusterLeft = (c.left || 0) - (groupMinLeft || 0);\\n            clusterLeft = groupBaseLeft + relClusterLeft;\\n          } else {\\n            clusterLeft = centerX - c.width / 2;\\n          }\\n\\n          // Permite forzar centrado por cluster si el nodo lo pide.\\n          if (forceCenter) clusterLeft = centerX - c.width / 2;\\n\\n          // Si esta columna tiene un cluster con forma (o mixto), usamos su\\n          // centro como referencia para alinear clusters solo-texto debajo.\\n          var clusterRefCenterX = NaN;\\n          if (hasNonTextInCluster) {\\n            // Referencia basada en items no-texto (forma/icono), no en todo el\\n            // cluster, para que textos largos no desplacen el centro de columna.\\n            var ntMinRel = Infinity;\\n            var ntMaxRel = -Infinity;\\n            for (var nti=0; nti<c.items.length; nti++){\\n              var ntIt = c.items[nti];\\n              var ntIsText = (ntIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              if (ntIsText) continue;\\n              ntMinRel = Math.min(ntMinRel, (ntIt._relLeft || 0));\\n              ntMaxRel = Math.max(ntMaxRel, (ntIt._relLeft || 0) + (ntIt.width || 0));\\n            }\\n            var sourceClusterRefCenterX = NaN;\\n            if (isFinite(ntMinRel) && isFinite(ntMaxRel) && ntMaxRel > ntMinRel) {\\n              clusterRefCenterX = clusterLeft + ((ntMinRel + ntMaxRel) / 2);\\n              sourceClusterRefCenterX = (c.left || 0) + ((ntMinRel + ntMaxRel) / 2);\\n            } else {\\n              clusterRefCenterX = clusterLeft + c.width / 2;\\n              sourceClusterRefCenterX = (c.left || 0) + c.width / 2;\\n            }\\n\\n            colReferenceCenterX = clusterRefCenterX;\\n            colSourceReferenceCenterX = sourceClusterRefCenterX;\\n          }\\n\\n          if (isTextOnlyCluster && isFinite(colReferenceCenterX)) {\\n            var maxSnapDelta = Math.min(120, info.usableW * 0.35);\\n            var sourceClusterCenterX = (c.left || 0) + c.width / 2;\\n            var sourceDriftX = isFinite(colSourceReferenceCenterX)\\n              ? (sourceClusterCenterX - colSourceReferenceCenterX)\\n              : NaN;\\n            if (isFinite(sourceDriftX) && Math.abs(sourceDriftX) <= maxSnapDelta) {\\n              clusterLeft = (colReferenceCenterX + sourceDriftX) - c.width / 2;\\n            }\\n            // Para labels cortos, centrar el contenido textual dentro del box.\\n            shouldCenterTextWithinCluster = c.width <= (info.usableW * 0.65);\\n          }\\n\\n          // Guard rail: en apilado multi-columna, un cluster no debe quedar\\n          // desviado demasiado del eje central del layout mobile.\\n          var clusterCenterXNow = clusterLeft + c.width / 2;\\n          var maxCenterDrift = Math.max(24, info.usableW * 0.18);\\n          if (Math.abs(clusterCenterXNow - centerX) > maxCenterDrift) {\\n            mslLog(\"stack:cluster:centerFallback\", {\\n              g: g,\\n              j: j,\\n              prevLeft: +clusterLeft.toFixed(1),\\n              centerX: +centerX.toFixed(1),\\n              clusterCenterX: +clusterCenterXNow.toFixed(1),\\n              maxCenterDrift: +maxCenterDrift.toFixed(1),\\n              clusterW: +(c.width || 0).toFixed(1)\\n            });\\n            clusterLeft = centerX - c.width / 2;\\n          }\\n        }\\n        mslLog(\"stack:cluster\", {\\n          g: g,\\n          j: j,\\n          origTop: +c.top.toFixed(1),\\n          origLeft: +c.left.toFixed(1),\\n          newTop: +clusterTop.toFixed(1),\\n          newLeft: +clusterLeft.toFixed(1),\\n          h: +c.height.toFixed(1),\\n          w: +c.width.toFixed(1),\\n          forceCenter: forceCenter,\\n          keepCenter: keepCenter,\\n          items: c.items.length,\\n          colReferenceCenterX: (typeof colReferenceCenterX === \"number\" && isFinite(colReferenceCenterX)) ? +colReferenceCenterX.toFixed(1) : null,\\n          isTextOnlyCluster: isTextOnlyCluster,\\n          centerShortText: shouldCenterTextWithinCluster\\n        });\\n\\n        var textCount = 0;\\n        for (var tc=0; tc<c.items.length; tc++){\\n          if ((c.items[tc].node.getAttribute(\"data-debug-texto\") || \"\") === \"1\") textCount++;\\n        }\\n        var linearizeCluster = (mode === \"rows\" && c.items.length > 1 && textCount >= 2);\\n        var clusterBottomUsed = clusterTop + c.height;\\n\\n        // Caso especial: en rows, si el cluster agrupa varios textos, lo\\n        // convertimos a flujo vertical centrado para evitar texto lado a lado.\\n        if (linearizeCluster){\\n          var allItems = c.items.slice();\\n          var nonText = allItems.filter(function(itx){\\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") !== \"1\";\\n          }).sort(function(a,b){\\n            if (a.top !== b.top) return a.top - b.top;\\n            return a.left - b.left;\\n          });\\n          var texts = allItems.filter(function(itx){\\n            return (itx.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          }).sort(function(a,b){\\n            if (a.top !== b.top) return a.top - b.top;\\n            return a.left - b.left;\\n          });\\n\\n          // Orden sem\\xe1ntico de lectura:\\n          // no-texto + texto m\\xe1s cercano (debajo y por eje X), luego remanentes.\\n          var ordered = [];\\n          var usedText = {};\\n\\n          for (var nt=0; nt<nonText.length; nt++){\\n            var ntItem = nonText[nt];\\n            ordered.push(ntItem);\\n\\n            var ntCx = (ntItem.left || 0) + (ntItem.width || 0) / 2;\\n            var ntBottom = (ntItem.top || 0) + (ntItem.height || 0);\\n            var bestIdxTxt = -1;\\n            var bestScore = Infinity;\\n\\n            for (var tx=0; tx<texts.length; tx++){\\n              if (usedText[tx]) continue;\\n              var tItem = texts[tx];\\n              var tCx = (tItem.left || 0) + (tItem.width || 0) / 2;\\n              var vGapTxt = (tItem.top || 0) - ntBottom; // preferir texto debajo\\n              var hDistTxt = Math.abs(tCx - ntCx);\\n              var penaltyAbove = vGapTxt < -2 ? 10000 : 0;\\n              var score = penaltyAbove + Math.abs(vGapTxt) * 2 + hDistTxt;\\n              if (score < bestScore){\\n                bestScore = score;\\n                bestIdxTxt = tx;\\n              }\\n            }\\n\\n            if (bestIdxTxt >= 0){\\n              ordered.push(texts[bestIdxTxt]);\\n              usedText[bestIdxTxt] = true;\\n            }\\n          }\\n\\n          // Textos no emparejados\\n          for (var tx2=0; tx2<texts.length; tx2++){\\n            if (!usedText[tx2]) ordered.push(texts[tx2]);\\n          }\\n\\n          // Si no hubo no-texto, fallback simple por top/left\\n          if (!ordered.length) {\\n            ordered = allItems.sort(function(a,b){\\n              if (a.top !== b.top) return a.top - b.top;\\n              return a.left - b.left;\\n            });\\n          }\\n\\n          var localCursor = clusterTop;\\n          var prevIt = null;\\n          var prevTopApplied = clusterTop;\\n          var EXTRA_COL_BREAK_GAP = 8;\\n\\n          for (var li=0; li<ordered.length; li++){\\n            var lit = ordered[li];\\n\\n            var keepLayoutLin = (lit.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n            if (keepLayoutLin) continue;\\n\\n            var newTopLin = localCursor;\\n            if (prevIt){\\n              var gapOrigLin = lit.top - (prevIt.top + prevIt.height);\\n              if (!isFinite(gapOrigLin)) gapOrigLin = 0;\\n              var gapWantedLin = clamp(gapOrigLin * (CFG.GAP_SCALE || 1), CFG.MIN_GAP, CFG.MAX_GAP);\\n              var prevIsTextLin = (prevIt.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              var currIsTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n              // Al pasar de \"texto final de columna\" a \"nuevo no-texto\" agregamos aire.\\n              if (prevIsTextLin && !currIsTextLin) gapWantedLin += EXTRA_COL_BREAK_GAP;\\n              newTopLin = prevTopApplied + prevIt.height + gapWantedLin;\\n            }\\n\\n            var newLeftLin = centerX - (lit.width || 0) / 2;\\n            var keepAlignLin = (lit.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\\n            if (keepAlignLin) newLeftLin = lit.left;\\n\\n            if (Math.abs(newTopLin - lit.top) > 0.5 || Math.abs(newLeftLin - lit.left) > 0.5) changed = true;\\n\\n            // En rows linealizado, forzamos centrado visual real de texto.\\n            var isTextLin = (lit.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n            if (isTextLin && !keepAlignLin) {\\n              lit.node.style.textAlign = \"center\";\\n              lit.node.style.transformOrigin = \"top center\";\\n              lit.node.style.setProperty(\"--text-zoom\", \"1\");\\n              var tfLin = lit.node.style.transform || \"\";\\n              if (tfLin.indexOf(\"translateX(\") !== -1) {\\n                lit.node.style.transform = tfLin.replace(/translateX([^)]*)/, \"translateX(0px)\");\\n              }\\n            }\\n\\n            var cssLeftLin = newLeftLin - (info.padL || 0);\\n            lit.node.style.top = newTopLin + \"px\";\\n            lit.node.style.left = cssLeftLin + \"px\";\\n            lit.node.style.right = \"auto\";\\n            lit.node.style.marginLeft = \"0px\";\\n\\n            prevIt = lit;\\n            prevTopApplied = newTopLin;\\n            localCursor = newTopLin + (lit.height || 0);\\n            if (localCursor > clusterBottomUsed) clusterBottomUsed = localCursor;\\n          }\\n\\n          colCursor = Math.max(colCursor, clusterBottomUsed);\\n          continue;\\n        }\\n\\n        // Aplicar a cada item preservando offsets relativos (solape intacto)\\n        for (var ii=0; ii<c.items.length; ii++){\\n          var it = c.items[ii];\\n\\n          // Opt-out total del layout (decoraciones, etc.)\\n          var keepLayout = (it.node.getAttribute(\"data-mobile-layout\") || \"\") === \"keep\";\\n          if (keepLayout) continue;\\n\\n          var newTop = clusterTop + (it._relTop || 0);\\n          var newLeft = clusterLeft + (it._relLeft || 0);\\n\\n          // Opt-out de centrado (mantener left original del item)\\n          var keepAlign = (it.node.getAttribute(\"data-mobile-align\") || \"\") === \"keep\";\\n          if (keepAlign) newLeft = it.left;\\n\\n          // En multi-col, neutralizamos SIEMPRE translateX(...) de textos\\n          // para que la posici\\xf3n left calculada sea la referencia visual real.\\n          var isTextNode = (it.node.getAttribute(\"data-debug-texto\") || \"\") === \"1\";\\n          var isShortTextBox = false;\\n          var shouldRecenterTextItem = false;\\n          var centerByAlign = false;\\n          var targetTextCenterX = NaN;\\n          if (isTextNode && isMultiColLayout) {\\n            var tf = it.node.style.transform || \"\";\\n            if (tf.indexOf(\"translateX(\") !== -1) {\\n              it.node.style.transform = tf.replace(/translateX([^)]*)/, \"translateX(0px)\");\\n            }\\n            isShortTextBox = (it.width || 0) <= (info.usableW * 0.5) && (it.height || 0) <= 42;\\n            var taCurrent = ((it.node.style && it.node.style.textAlign) || \"\").toLowerCase();\\n            centerByAlign = taCurrent === \"center\";\\n            var shouldCenterVisualText =\\n              (shouldCenterTextWithinCluster || isShortTextBox || centerByAlign) &&\\n              !keepAlign;\\n            shouldRecenterTextItem =\\n              shouldCenterVisualText &&\\n              isFinite(colReferenceCenterX);\\n            if (shouldRecenterTextItem) {\\n              var prevLeftTxt = newLeft;\\n              var sourceItemCenterX = (it.left || 0) + (it.width || 0) / 2;\\n              var sourceDriftItemX = isFinite(colSourceReferenceCenterX)\\n                ? (sourceItemCenterX - colSourceReferenceCenterX)\\n                : NaN;\\n              var targetCenterX = colReferenceCenterX;\\n              // En textos centrados (o labels cortos forzados al centro),\\n              // no arrastramos drift horizontal del layout original para\\n              // evitar corrimientos laterales en mobile.\\n              var preserveSourceDrift =\\n                !centerByAlign &&\\n                !shouldCenterTextWithinCluster &&\\n                !isShortTextBox;\\n              if (preserveSourceDrift && isFinite(sourceDriftItemX)) {\\n                targetCenterX += sourceDriftItemX;\\n              }\\n              targetTextCenterX = targetCenterX;\\n              newLeft = targetCenterX - (it.width || 0) / 2;\\n              if (Math.abs(newLeft - prevLeftTxt) > 0.5) {\\n                mslLog(\"stack:item:textRecenter\", {\\n                  g: g,\\n                  j: j,\\n                  ii: ii,\\n                  prevLeft: +prevLeftTxt.toFixed(1),\\n                  newLeft: +newLeft.toFixed(1),\\n                  itemW: +(it.width || 0).toFixed(1),\\n                  refCenterX: +colReferenceCenterX.toFixed(1),\\n                  sourceRefCenterX: (typeof colSourceReferenceCenterX === \"number\" && isFinite(colSourceReferenceCenterX)) ? +colSourceReferenceCenterX.toFixed(1) : null,\\n                  sourceDriftX: isFinite(sourceDriftItemX) ? +sourceDriftItemX.toFixed(1) : null,\\n                  preserveSourceDrift: preserveSourceDrift,\\n                  shortBox: isShortTextBox,\\n                  centerByAlign: centerByAlign\\n                });\\n              }\\n            }\\n            if (shouldCenterVisualText) {\\n              it.node.style.textAlign = \"center\";\\n              it.node.style.transformOrigin = \"top center\";\\n              // Evita encogimiento horizontal heredado que desplaza el centro visual.\\n              it.node.style.setProperty(\"--text-zoom\", \"1\");\\n            }\\n          }\\n\\n          var cssLeft = newLeft - (info.padL || 0);\\n          it.node.style.top = newTop + \"px\";\\n          it.node.style.left = cssLeft + \"px\";\\n          it.node.style.right = \"auto\";\\n          it.node.style.marginLeft = \"0px\";\\n\\n          // Correcci\\xf3n final por posici\\xf3n renderizada real del texto\\n          // (fuentes/transform pueden introducir desv\\xedos visuales sub-p\\xedxel).\\n          if (isTextNode && isMultiColLayout && shouldRecenterTextItem) {\\n            var rrTxt = relRect(it.node, rootEl);\\n            var renderedCenterX = (rrTxt.left || 0) + (rrTxt.width || 0) / 2;\\n            var targetRenderCenterX = isFinite(targetTextCenterX) ? targetTextCenterX : colReferenceCenterX;\\n            var renderDelta = renderedCenterX - targetRenderCenterX;\\n            if (isFinite(renderDelta) && Math.abs(renderDelta) > 0.6) {\\n              var correctedLeft = newLeft - renderDelta;\\n              if (isFinite(correctedLeft)) {\\n                mslLog(\"stack:item:textRenderAdjust\", {\\n                  g: g,\\n                  j: j,\\n                  ii: ii,\\n                  prevLeft: +newLeft.toFixed(1),\\n                  correctedLeft: +correctedLeft.toFixed(1),\\n                  renderedCenterX: +renderedCenterX.toFixed(1),\\n                  refCenterX: +targetRenderCenterX.toFixed(1),\\n                  delta: +renderDelta.toFixed(2)\\n                });\\n                newLeft = correctedLeft;\\n                it.node.style.left = (newLeft - (info.padL || 0)) + \"px\";\\n              }\\n            }\\n          }\\n\\n          if (Math.abs(newTop - it.top) > 0.5 || Math.abs(newLeft - it.left) > 0.5) changed = true;\\n\\n          var itemBottom = newTop + (it.height || 0);\\n          if (itemBottom > clusterBottomUsed) clusterBottomUsed = itemBottom;\\n        }\\n\\n        // Avanza el cursor local al final del cluster\\n        colCursor = Math.max(colCursor, clusterBottomUsed);\\n      }\\n\\n      // Al terminar la columna, el cursor global baja hasta donde lleg\\xf3 esta columna\\n      globalCursor = Math.max(globalCursor, colCursor);\\n    }\\n\\n    var needed = globalCursor + CFG.PAD_BOT;\\n    mslLog(\"stack:end\", {\\n      changed: changed,\\n      neededHeight: +needed.toFixed(1),\\n      finalCursor: +globalCursor.toFixed(1)\\n    });\\n    return { changed: changed, neededHeight: needed };\\n  }\\n'.trim();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2Z1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9EQUFvRDtBQUM3QyxTQUFTQTtJQUNkLE9BQU8sZzZ1QkF1aEJQQyxJQUFJO0FBQ04iLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXGZ1bmN0aW9uc1xcc3JjXFx1dGlsc1xcbW9iaWxlU21hcnRMYXlvdXRcXHN0YWNraW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9ucy9zcmMvdXRpbHMvbW9iaWxlU21hcnRMYXlvdXQvc3RhY2tpbmcudHNcclxuZXhwb3J0IGZ1bmN0aW9uIGpzU3RhY2tpbmdCbG9jaygpOiBzdHJpbmcge1xyXG4gIHJldHVybiBgXHJcbiAgLy8gQ2VudHJvIHJlYWwgZGVsIMOhcmVhIHVzYWJsZSAoY29tcGVuc2EgcGFkZGluZyBzYWZlLWxlZnQvcmlnaHQpXHJcbiAgZnVuY3Rpb24gY29tcHV0ZUNlbnRlclgocm9vdEVsKXtcclxuICAgIHZhciByb290UmVjdCA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciByb290VyA9IHJvb3RSZWN0LndpZHRoIHx8IDA7XHJcblxyXG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWwpO1xyXG4gICAgdmFyIHBhZEwgPSBwYXJzZUZsb2F0KGNzLnBhZGRpbmdMZWZ0KSB8fCAwO1xyXG4gICAgdmFyIHBhZFIgPSBwYXJzZUZsb2F0KGNzLnBhZGRpbmdSaWdodCkgfHwgMDtcclxuXHJcbiAgICB2YXIgdXNhYmxlVyA9IE1hdGgubWF4KDAsIHJvb3RXIC0gcGFkTCAtIHBhZFIpO1xyXG4gICAgdmFyIGNlbnRlclggPSBwYWRMICsgdXNhYmxlVyAvIDI7IC8vIGNlbnRybyBkZWwgw6FyZWEgdXNhYmxlXHJcblxyXG4gICAgcmV0dXJuIHsgcm9vdFc6IHJvb3RXLCB1c2FibGVXOiB1c2FibGVXLCBjZW50ZXJYOiBjZW50ZXJYLCBwYWRMOiBwYWRMLCBwYWRSOiBwYWRSIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbGFtcChuLCBhLCBiKXtcclxuICAgIGlmICghaXNGaW5pdGUobikpIHJldHVybiBhO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIG4pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwaWxhIENMVVNURVJTIHBvciBncm91cHMgKGNvbHVtbmFzL2ZpbGFzKSB5OlxyXG4gICAqIC0gbXVldmUgY2FkYSBjbHVzdGVyIGNvbW8gYmxvcXVlXHJcbiAgICogLSBwcmVzZXJ2YSBzb2xhcGUvcG9zaWNpb25lcyByZWxhdGl2YXMgZGVudHJvIGRlbCBjbHVzdGVyXHJcbiAgICogLSBjZW50cmEgZWwgY2x1c3RlciBjb21vIGJsb3F1ZSBlbiBlbCBlamUgWCAoc2luIHRyYW5zZm9ybSlcclxuICAgKlxyXG4gICAqIERldnVlbHZlIGNoYW5nZWQgKyBuZWVkZWRIZWlnaHQgKHBhcmEgZXhwYW5kaXIgc2VjY2nDs24pXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXBwbHlDbHVzdGVyU3RhY2soZ3JvdXBzLCByb290RWwsIENGRywgbW9kZSl7XHJcbiAgICB2YXIgaW5mbyA9IGNvbXB1dGVDZW50ZXJYKHJvb3RFbCk7XHJcbiAgICB2YXIgY2VudGVyWCA9IGluZm8uY2VudGVyWDtcclxuICAgIG1zbExvZyhcInN0YWNrOnN0YXJ0XCIsIHtcclxuICAgICAgZ3JvdXBDb3VudDogZ3JvdXBzLmxlbmd0aCxcclxuICAgICAgZ3JvdXBTaXplczogZ3JvdXBzLm1hcChmdW5jdGlvbihnKXsgcmV0dXJuIGcubGVuZ3RoOyB9KSxcclxuICAgICAgY2VudGVyWDogK2NlbnRlclgudG9GaXhlZCgxKSxcclxuICAgICAgdXNhYmxlVzogK2luZm8udXNhYmxlVy50b0ZpeGVkKDEpXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGlzTXVsdGlDb2xMYXlvdXQgPSAobW9kZSA9PT0gXCJ0d29cIiB8fCBtb2RlID09PSBcInRocmVlXCIpO1xyXG5cclxuICAgIC8vIEVuIG11bHRpLWNvbHVtbmE6IGNhZGEgY29sdW1uYSBhcGlsYWRhIHNlIGNlbnRyYSBwb3Igc3UgcHJvcGlvIGJib3guXG4gICAgLy8gQXPDrSwgZWwgY2VudHJvIGRlIGNhZGEgY29sdW1uYSBjb2luY2lkZSBjb24gZWwgY2VudHJvIGRlIHBhbnRhbGxhLlxuXHJcbiAgICAvLyAtLS0gQW5jaG9yIGdsb2JhbDogZMOzbmRlIGVzdGFiYSDigJxlbCBibG9xdWXigJ0gb3JpZ2luYWxtZW50ZSAtLS1cclxuICAgIHZhciBmaXJzdEdyb3VwID0gZ3JvdXBzWzBdIHx8IFtdO1xyXG4gICAgdmFyIGFuY2hvciA9IEluZmluaXR5O1xyXG4gICAgZm9yICh2YXIgaT0wO2k8Zmlyc3RHcm91cC5sZW5ndGg7aSsrKXtcclxuICAgICAgYW5jaG9yID0gTWF0aC5taW4oYW5jaG9yLCBmaXJzdEdyb3VwW2ldLnRvcCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRmluaXRlKGFuY2hvcikpIGFuY2hvciA9IENGRy5QQURfVE9QO1xyXG4gICAgYW5jaG9yID0gTWF0aC5tYXgoQ0ZHLlBBRF9UT1AsIGFuY2hvcik7XHJcblxyXG4gICAgLy8gQ3Vyc29yIGdsb2JhbDogZMOzbmRlIHRlcm1pbmEgZWwgY29udGVuaWRvIGFwaWxhZG8gaGFzdGEgYWhvcmFcclxuICAgIHZhciBnbG9iYWxDdXJzb3IgPSBhbmNob3I7XHJcblxyXG4gICAgLy8gU2VwYXJhY2nDs24gZW50cmUgY29sdW1uYXMgYXBpbGFkYXMgKGl6cSwgY2VudHJvLCBkZXIpXHJcbiAgICB2YXIgR1JPVVBfR0FQID0gMTQ7XHJcblxyXG4gICAgZm9yICh2YXIgZz0wOyBnPGdyb3Vwcy5sZW5ndGg7IGcrKyl7XG4gICAgICB2YXIgY29sID0gZ3JvdXBzW2ddIHx8IFtdO1xuICAgICAgaWYgKCFjb2wubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgIHZhciBjb2xSZWZlcmVuY2VDZW50ZXJYID0gTmFOO1xuICAgICAgdmFyIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPSBOYU47XG4gICAgICB2YXIgbmFycm93Q2x1c3RlckNvdW50ID0gMDtcbiAgICAgIHZhciB3aWRlQ2x1c3RlckNvdW50ID0gMDtcblxyXG4gICAgICAvLyBNw6l0cmljYXMgcG9yIGdydXBvIHNvbG8gcGFyYSBkZWJ1Zy5cclxuICAgICAgdmFyIGdyb3VwTWluTGVmdCA9IEluZmluaXR5O1xyXG4gICAgICB2YXIgZ3JvdXBNYXhSaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpe1xuICAgICAgICBmb3IgKHZhciBnZz0wOyBnZzxjb2wubGVuZ3RoOyBnZysrKXtcbiAgICAgICAgICBncm91cE1pbkxlZnQgPSBNYXRoLm1pbihncm91cE1pbkxlZnQsIGNvbFtnZ10ubGVmdCk7XG4gICAgICAgICAgZ3JvdXBNYXhSaWdodCA9IE1hdGgubWF4KGdyb3VwTWF4UmlnaHQsIGNvbFtnZ10ubGVmdCArIGNvbFtnZ10ud2lkdGgpO1xuICAgICAgICAgIHZhciBjbHVzdGVyV0RiZyA9IE51bWJlcihjb2xbZ2ddLndpZHRoIHx8IDApO1xuICAgICAgICAgIGlmIChjbHVzdGVyV0RiZyA8PSAoaW5mby51c2FibGVXICogMC43MikpIG5hcnJvd0NsdXN0ZXJDb3VudCsrO1xuICAgICAgICAgIGlmIChjbHVzdGVyV0RiZyA+PSAoaW5mby51c2FibGVXICogMC44OCkpIHdpZGVDbHVzdGVyQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGdyb3VwV2lkdGggPSBpc011bHRpQ29sTGF5b3V0ID8gTWF0aC5tYXgoMCwgZ3JvdXBNYXhSaWdodCAtIGdyb3VwTWluTGVmdCkgOiAwO1xuICAgICAgdmFyIGdyb3VwQmFzZUxlZnQgPSBpc011bHRpQ29sTGF5b3V0ID8gKGNlbnRlclggLSBncm91cFdpZHRoIC8gMikgOiAwO1xuICAgICAgdmFyIHN1c3BpY2lvdXNXaWRlU3BhbiA9IGlzTXVsdGlDb2xMYXlvdXQgJiZcbiAgICAgICAgY29sLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgZ3JvdXBXaWR0aCA+PSAoaW5mby51c2FibGVXICogMC44OCkgJiZcbiAgICAgICAgbmFycm93Q2x1c3RlckNvdW50ID49IDEgJiZcbiAgICAgICAgd2lkZUNsdXN0ZXJDb3VudCA+PSAxO1xuICAgICAgdmFyIHByZXNlcnZlQ29sdW1uT2Zmc2V0cyA9IGlzTXVsdGlDb2xMYXlvdXQgJiYgIXN1c3BpY2lvdXNXaWRlU3BhbjtcblxyXG4gICAgICAvLyBPZmZzZXQgdmVydGljYWwgb3JpZ2luYWwgZGUgZXN0YSBjb2x1bW5hIHJlc3BlY3RvIGRlbCBhbmNob3JcclxuICAgICAgdmFyIGNvbE1pblRvcCA9IEluZmluaXR5O1xyXG4gICAgICBmb3IgKHZhciBrPTA7azxjb2wubGVuZ3RoO2srKyl7XHJcbiAgICAgICAgY29sTWluVG9wID0gTWF0aC5taW4oY29sTWluVG9wLCBjb2xba10udG9wKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzRmluaXRlKGNvbE1pblRvcCkpIGNvbE1pblRvcCA9IGFuY2hvcjtcclxuXHJcbiAgICAgIHZhciBjb2xPZmZzZXQgPSBjb2xNaW5Ub3AgLSBhbmNob3I7XHJcbiAgICAgIHZhciBjb2xTdGFydCA9IGdsb2JhbEN1cnNvciArIChnID09PSAwID8gMCA6IEdST1VQX0dBUCkgKyBNYXRoLm1heCgwLCBjb2xPZmZzZXQpO1xyXG4gICAgICBtc2xMb2coXCJzdGFjazpncm91cDpzdGFydFwiLCB7XHJcbiAgICAgICAgZzogZyxcclxuICAgICAgICBjb2xTaXplOiBjb2wubGVuZ3RoLFxyXG4gICAgICAgIGNvbE1pblRvcDogK2NvbE1pblRvcC50b0ZpeGVkKDEpLFxyXG4gICAgICAgIGNvbE9mZnNldDogK2NvbE9mZnNldC50b0ZpeGVkKDEpLFxyXG4gICAgICAgIGNvbFN0YXJ0OiArY29sU3RhcnQudG9GaXhlZCgxKSxcbiAgICAgICAgZ2xvYmFsQ3Vyc29yOiArZ2xvYmFsQ3Vyc29yLnRvRml4ZWQoMSksXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGdyb3VwTWluTGVmdDogaXNNdWx0aUNvbExheW91dCA/ICtncm91cE1pbkxlZnQudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgIGdyb3VwV2lkdGg6IGlzTXVsdGlDb2xMYXlvdXQgPyArZ3JvdXBXaWR0aC50b0ZpeGVkKDEpIDogbnVsbCxcbiAgICAgICAgZ3JvdXBCYXNlTGVmdDogaXNNdWx0aUNvbExheW91dCA/ICtncm91cEJhc2VMZWZ0LnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICBuYXJyb3dDbHVzdGVyQ291bnQ6IGlzTXVsdGlDb2xMYXlvdXQgPyBuYXJyb3dDbHVzdGVyQ291bnQgOiBudWxsLFxuICAgICAgICB3aWRlQ2x1c3RlckNvdW50OiBpc011bHRpQ29sTGF5b3V0ID8gd2lkZUNsdXN0ZXJDb3VudCA6IG51bGwsXG4gICAgICAgIHByZXNlcnZlQ29sdW1uT2Zmc2V0czogaXNNdWx0aUNvbExheW91dCA/IHByZXNlcnZlQ29sdW1uT2Zmc2V0cyA6IG51bGxcbiAgICAgIH0pO1xuXHJcbiAgICAgIC8vIEN1cnNvciBsb2NhbCBkZSBlc3RhIGNvbHVtbmFcclxuICAgICAgdmFyIGNvbEN1cnNvciA9IGNvbFN0YXJ0O1xyXG5cclxuICAgICAgZm9yICh2YXIgaj0wOyBqPGNvbC5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgdmFyIGMgPSBjb2xbal07XHJcblxyXG4gICAgICAgIC8vIFRvcCBkZWwgY2x1c3RlciBlbiBlbCBmbHVqbyBtb2JpbGVcclxuICAgICAgICB2YXIgY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICBjbHVzdGVyVG9wID0gY29sQ3Vyc29yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2QyA9IGNvbFtqLTFdO1xuICAgICAgICAgIHZhciBwcmV2Qm90dG9tID0gKGNsdXN0ZXJUb3BQcmV2ICsgcHJldkMuaGVpZ2h0KTtcblxuICAgICAgICAgIC8vIOKchSBHYXAgb3JpZ2luYWwgZW50cmUgY2x1c3RlcnMgKGNhbnZhcylcbiAgICAgICAgICB2YXIgcHJldkJvdHRvbU9yaWcgPSAocHJldkMudG9wICsgcHJldkMuaGVpZ2h0KTtcbiAgICAgICAgICB2YXIgZ2FwT3JpZyA9IGMudG9wIC0gcHJldkJvdHRvbU9yaWc7XG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShnYXBPcmlnKSkgZ2FwT3JpZyA9IDA7XG5cbiAgICAgICAgICB2YXIgb3ZlcmxhcEluU291cmNlID0gZ2FwT3JpZyA8IDA7XG4gICAgICAgICAgaWYgKChtb2RlID09PSBcInR3b1wiIHx8IG1vZGUgPT09IFwidGhyZWVcIikgJiYgb3ZlcmxhcEluU291cmNlKSB7XG4gICAgICAgICAgICAvLyBTaSBlbiBlbCBvcmlnaW5hbCBlc3RlIGNsdXN0ZXIgY2FlIGRlbnRybyBkZWwgYW50ZXJpb3IsIHJlc3BldGFtb3NcbiAgICAgICAgICAgIC8vIHN1IHRvcCByZWxhdGl2byBwYXJhIG5vIG1hbmRhcmxvIGFsIGZpbmFsIGRlIGxhIGNvbHVtbmEuXG4gICAgICAgICAgICB2YXIgcmVsVG9wSW5Db2wgPSBjLnRvcCAtIGNvbE1pblRvcDtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUocmVsVG9wSW5Db2wpKSByZWxUb3BJbkNvbCA9IDA7XG4gICAgICAgICAgICBjbHVzdGVyVG9wID0gY29sU3RhcnQgKyBNYXRoLm1heCgwLCByZWxUb3BJbkNvbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOKchSBHYXAg4oCcbW9iaWxlLWZyaWVuZGx54oCdOiBlc2NhbGFkbyArIGNsYW1wXG4gICAgICAgICAgICB2YXIgZ2FwV2FudGVkID0gY2xhbXAoZ2FwT3JpZyAqIChDRkcuR0FQX1NDQUxFIHx8IDEpLCBDRkcuTUlOX0dBUCwgQ0ZHLk1BWF9HQVApO1xuXG4gICAgICAgICAgICAvLyDinIUgQW50aS1zb2xhcGUgZGVmaW5pdGl2bzpcbiAgICAgICAgICAgIC8vICAgZWwgcHLDs3hpbW8gY2x1c3RlciBTSUVNUFJFIGVtcGllemEgZGVzcHXDqXMgZGVsIGJvdHRvbSByZWFsIGRlbCBhbnRlcmlvciArIGdhcFdhbnRlZFxuICAgICAgICAgICAgY2x1c3RlclRvcCA9IHByZXZCb3R0b20gKyBnYXBXYW50ZWQ7XG5cbiAgICAgICAgICAgIC8vIEVuIG11bHRpLWNvbHVtbmEgbnVuY2EgYXZhbnphbW9zIGhhY2lhIGFycmliYSByZXNwZWN0byBhbCBmbHVqbyB5YSBjb25zdW1pZG8uXG4gICAgICAgICAgICBpZiAoKG1vZGUgPT09IFwidHdvXCIgfHwgbW9kZSA9PT0gXCJ0aHJlZVwiKSAmJiBjbHVzdGVyVG9wIDwgY29sQ3Vyc29yKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJUb3AgPSBjb2xDdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cclxuICAgICAgICAvLyBHdWFyZGFtb3MgcGFyYSBlbCBwcsOzeGltbyBsb29wXHJcbiAgICAgICAgdmFyIGNsdXN0ZXJUb3BQcmV2ID0gY2x1c3RlclRvcDtcclxuXHJcbiAgICAgICAgLy8gwr9jZW50cmFyIGVzdGUgY2x1c3Rlcj9cbiAgICAgICAgdmFyIGZvcmNlQ2VudGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNUZXh0SW5DbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNOb25UZXh0SW5DbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIHQ9MDsgdDxjLml0ZW1zLmxlbmd0aDsgdCsrKXtcbiAgICAgICAgICB2YXIgaXNUZXh0VCA9IChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgaWYgKGlzVGV4dFQpIGhhc1RleHRJbkNsdXN0ZXIgPSB0cnVlO1xuICAgICAgICAgIGVsc2UgaGFzTm9uVGV4dEluQ2x1c3RlciA9IHRydWU7XG4gICAgICAgICAgaWYgKChjLml0ZW1zW3RdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtY2VudGVyXCIpIHx8IFwiXCIpID09PSBcImZvcmNlXCIpIHtcbiAgICAgICAgICAgIGZvcmNlQ2VudGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxyXG4gICAgICAgIC8vIG9uZS9yb3dzOiBjZW50cm8gcG9yIGNsdXN0ZXIgKGNvbXBvcnRhbWllbnRvIG9yaWdpbmFsKVxyXG4gICAgICAgIC8vIHR3by90aHJlZTogYXBpbGFyIGNhZGEgY29sdW1uYSBlbiBsYSBtaXNtYSByZWZlcmVuY2lhIFgsXHJcbiAgICAgICAgLy8gcHJlc2VydmFuZG8gb2Zmc2V0cyBpbnRlcm5vcyBkZSBlc2EgY29sdW1uYS5cclxuICAgICAgICB2YXIga2VlcENlbnRlciA9IGZvcmNlQ2VudGVyID8gdHJ1ZSA6IChjLndpZHRoIDwgKGluZm8udXNhYmxlVyAqIDAuOTUpKTtcbiAgICAgICAgdmFyIGNsdXN0ZXJMZWZ0ID0ga2VlcENlbnRlciA/IChjZW50ZXJYIC0gYy53aWR0aCAvIDIpIDogYy5sZWZ0O1xuICAgICAgICB2YXIgaXNUZXh0T25seUNsdXN0ZXIgPSBoYXNUZXh0SW5DbHVzdGVyICYmICFoYXNOb25UZXh0SW5DbHVzdGVyO1xuICAgICAgICB2YXIgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzTXVsdGlDb2xMYXlvdXQpIHtcbiAgICAgICAgICAvLyBNb2RvIGxlY3R1cmEgbW9iaWxlIG11bHRpLWNvbDpcbiAgICAgICAgICAvLyB1c2FyIHVuYSBtaXNtYSByZWZlcmVuY2lhIFggcGFyYSB0b2RhIGxhIGNvbHVtbmEgYXBpbGFkYSB5XG4gICAgICAgICAgLy8gcHJlc2VydmFyIGVsIG9mZnNldCBob3Jpem9udGFsIG9yaWdpbmFsIGRlIGNhZGEgY2x1c3Rlci5cbiAgICAgICAgICAvLyBFc3RvIG1hbnRpZW5lIGFsaW5lYWRvIHRleHRvL2Zvcm1hIGN1YW5kbyBsYSBjb2x1bW5hIHNlIHBhcnRlXG4gICAgICAgICAgLy8gZW4gdmFyaW9zIGNsdXN0ZXJzLlxuICAgICAgICAgIC8vIFNpIGVsIGJib3ggZGUgbGEgY29sdW1uYSBxdWVkYSBjb250YW1pbmFkbyBwb3IgdW4gb3V0bGllciBhbmNob1xuICAgICAgICAgIC8vICh0aXBpY2FtZW50ZSB0ZXh0byksIGNlbnRyYXIgcG9yIG9mZnNldHMgZGVqYSBsYSBjb2x1bW5hIHBlZ2FkYVxuICAgICAgICAgIC8vIGFsIGJvcmRlOyBlbiBlc2UgY2FzbyBjZW50cmFtb3MgY2FkYSBjbHVzdGVyIGluZGl2aWR1YWxtZW50ZS5cbiAgICAgICAgICBpZiAocHJlc2VydmVDb2x1bW5PZmZzZXRzKSB7XG4gICAgICAgICAgICB2YXIgcmVsQ2x1c3RlckxlZnQgPSAoYy5sZWZ0IHx8IDApIC0gKGdyb3VwTWluTGVmdCB8fCAwKTtcbiAgICAgICAgICAgIGNsdXN0ZXJMZWZ0ID0gZ3JvdXBCYXNlTGVmdCArIHJlbENsdXN0ZXJMZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQZXJtaXRlIGZvcnphciBjZW50cmFkbyBwb3IgY2x1c3RlciBzaSBlbCBub2RvIGxvIHBpZGUuXG4gICAgICAgICAgaWYgKGZvcmNlQ2VudGVyKSBjbHVzdGVyTGVmdCA9IGNlbnRlclggLSBjLndpZHRoIC8gMjtcblxuICAgICAgICAgIC8vIFNpIGVzdGEgY29sdW1uYSB0aWVuZSB1biBjbHVzdGVyIGNvbiBmb3JtYSAobyBtaXh0byksIHVzYW1vcyBzdVxuICAgICAgICAgIC8vIGNlbnRybyBjb21vIHJlZmVyZW5jaWEgcGFyYSBhbGluZWFyIGNsdXN0ZXJzIHNvbG8tdGV4dG8gZGViYWpvLlxuICAgICAgICAgIHZhciBjbHVzdGVyUmVmQ2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaGFzTm9uVGV4dEluQ2x1c3Rlcikge1xuICAgICAgICAgICAgLy8gUmVmZXJlbmNpYSBiYXNhZGEgZW4gaXRlbXMgbm8tdGV4dG8gKGZvcm1hL2ljb25vKSwgbm8gZW4gdG9kbyBlbFxuICAgICAgICAgICAgLy8gY2x1c3RlciwgcGFyYSBxdWUgdGV4dG9zIGxhcmdvcyBubyBkZXNwbGFjZW4gZWwgY2VudHJvIGRlIGNvbHVtbmEuXG4gICAgICAgICAgICB2YXIgbnRNaW5SZWwgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBudE1heFJlbCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIG50aT0wOyBudGk8Yy5pdGVtcy5sZW5ndGg7IG50aSsrKXtcbiAgICAgICAgICAgICAgdmFyIG50SXQgPSBjLml0ZW1zW250aV07XG4gICAgICAgICAgICAgIHZhciBudElzVGV4dCA9IChudEl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgICAgIGlmIChudElzVGV4dCkgY29udGludWU7XG4gICAgICAgICAgICAgIG50TWluUmVsID0gTWF0aC5taW4obnRNaW5SZWwsIChudEl0Ll9yZWxMZWZ0IHx8IDApKTtcbiAgICAgICAgICAgICAgbnRNYXhSZWwgPSBNYXRoLm1heChudE1heFJlbCwgKG50SXQuX3JlbExlZnQgfHwgMCkgKyAobnRJdC53aWR0aCB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUobnRNaW5SZWwpICYmIGlzRmluaXRlKG50TWF4UmVsKSAmJiBudE1heFJlbCA+IG50TWluUmVsKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyAoKG50TWluUmVsICsgbnRNYXhSZWwpIC8gMik7XG4gICAgICAgICAgICAgIHNvdXJjZUNsdXN0ZXJSZWZDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArICgobnRNaW5SZWwgKyBudE1heFJlbCkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJSZWZDZW50ZXJYID0gY2x1c3RlckxlZnQgKyBjLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgc291cmNlQ2x1c3RlclJlZkNlbnRlclggPSAoYy5sZWZ0IHx8IDApICsgYy53aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbFJlZmVyZW5jZUNlbnRlclggPSBjbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICAgIGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclggPSBzb3VyY2VDbHVzdGVyUmVmQ2VudGVyWDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNUZXh0T25seUNsdXN0ZXIgJiYgaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpIHtcbiAgICAgICAgICAgIHZhciBtYXhTbmFwRGVsdGEgPSBNYXRoLm1pbigxMjAsIGluZm8udXNhYmxlVyAqIDAuMzUpO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUNsdXN0ZXJDZW50ZXJYID0gKGMubGVmdCB8fCAwKSArIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0WCA9IGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpXG4gICAgICAgICAgICAgID8gKHNvdXJjZUNsdXN0ZXJDZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgOiBOYU47XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoc291cmNlRHJpZnRYKSAmJiBNYXRoLmFicyhzb3VyY2VEcmlmdFgpIDw9IG1heFNuYXBEZWx0YSkge1xuICAgICAgICAgICAgICBjbHVzdGVyTGVmdCA9IChjb2xSZWZlcmVuY2VDZW50ZXJYICsgc291cmNlRHJpZnRYKSAtIGMud2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyYSBsYWJlbHMgY29ydG9zLCBjZW50cmFyIGVsIGNvbnRlbmlkbyB0ZXh0dWFsIGRlbnRybyBkZWwgYm94LlxuICAgICAgICAgICAgc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgPSBjLndpZHRoIDw9IChpbmZvLnVzYWJsZVcgKiAwLjY1KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHdWFyZCByYWlsOiBlbiBhcGlsYWRvIG11bHRpLWNvbHVtbmEsIHVuIGNsdXN0ZXIgbm8gZGViZSBxdWVkYXJcbiAgICAgICAgICAvLyBkZXN2aWFkbyBkZW1hc2lhZG8gZGVsIGVqZSBjZW50cmFsIGRlbCBsYXlvdXQgbW9iaWxlLlxuICAgICAgICAgIHZhciBjbHVzdGVyQ2VudGVyWE5vdyA9IGNsdXN0ZXJMZWZ0ICsgYy53aWR0aCAvIDI7XG4gICAgICAgICAgdmFyIG1heENlbnRlckRyaWZ0ID0gTWF0aC5tYXgoMjQsIGluZm8udXNhYmxlVyAqIDAuMTgpO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjbHVzdGVyQ2VudGVyWE5vdyAtIGNlbnRlclgpID4gbWF4Q2VudGVyRHJpZnQpIHtcbiAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOmNsdXN0ZXI6Y2VudGVyRmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICBwcmV2TGVmdDogK2NsdXN0ZXJMZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGNlbnRlclg6ICtjZW50ZXJYLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJYOiArY2x1c3RlckNlbnRlclhOb3cudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgbWF4Q2VudGVyRHJpZnQ6ICttYXhDZW50ZXJEcmlmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBjbHVzdGVyVzogKyhjLndpZHRoIHx8IDApLnRvRml4ZWQoMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2x1c3RlckxlZnQgPSBjZW50ZXJYIC0gYy53aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1zbExvZyhcInN0YWNrOmNsdXN0ZXJcIiwge1xuICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgajogaixcbiAgICAgICAgICBvcmlnVG9wOiArYy50b3AudG9GaXhlZCgxKSxcbiAgICAgICAgICBvcmlnTGVmdDogK2MubGVmdC50b0ZpeGVkKDEpLFxuICAgICAgICAgIG5ld1RvcDogK2NsdXN0ZXJUb3AudG9GaXhlZCgxKSxcclxuICAgICAgICAgIG5ld0xlZnQ6ICtjbHVzdGVyTGVmdC50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgaDogK2MuaGVpZ2h0LnRvRml4ZWQoMSksXHJcbiAgICAgICAgICB3OiArYy53aWR0aC50b0ZpeGVkKDEpLFxuICAgICAgICAgIGZvcmNlQ2VudGVyOiBmb3JjZUNlbnRlcixcbiAgICAgICAgICBrZWVwQ2VudGVyOiBrZWVwQ2VudGVyLFxuICAgICAgICAgIGl0ZW1zOiBjLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBjb2xSZWZlcmVuY2VDZW50ZXJYOiAodHlwZW9mIGNvbFJlZmVyZW5jZUNlbnRlclggPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoY29sUmVmZXJlbmNlQ2VudGVyWCkpID8gK2NvbFJlZmVyZW5jZUNlbnRlclgudG9GaXhlZCgxKSA6IG51bGwsXG4gICAgICAgICAgaXNUZXh0T25seUNsdXN0ZXI6IGlzVGV4dE9ubHlDbHVzdGVyLFxuICAgICAgICAgIGNlbnRlclNob3J0VGV4dDogc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXJcbiAgICAgICAgfSk7XG5cclxuICAgICAgICB2YXIgdGV4dENvdW50ID0gMDtcclxuICAgICAgICBmb3IgKHZhciB0Yz0wOyB0YzxjLml0ZW1zLmxlbmd0aDsgdGMrKyl7XHJcbiAgICAgICAgICBpZiAoKGMuaXRlbXNbdGNdLm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCIpIHRleHRDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGluZWFyaXplQ2x1c3RlciA9IChtb2RlID09PSBcInJvd3NcIiAmJiBjLml0ZW1zLmxlbmd0aCA+IDEgJiYgdGV4dENvdW50ID49IDIpO1xyXG4gICAgICAgIHZhciBjbHVzdGVyQm90dG9tVXNlZCA9IGNsdXN0ZXJUb3AgKyBjLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gQ2FzbyBlc3BlY2lhbDogZW4gcm93cywgc2kgZWwgY2x1c3RlciBhZ3J1cGEgdmFyaW9zIHRleHRvcywgbG9cclxuICAgICAgICAvLyBjb252ZXJ0aW1vcyBhIGZsdWpvIHZlcnRpY2FsIGNlbnRyYWRvIHBhcmEgZXZpdGFyIHRleHRvIGxhZG8gYSBsYWRvLlxyXG4gICAgICAgIGlmIChsaW5lYXJpemVDbHVzdGVyKXtcclxuICAgICAgICAgIHZhciBhbGxJdGVtcyA9IGMuaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICAgIHZhciBub25UZXh0ID0gYWxsSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0eCl7XHJcbiAgICAgICAgICAgIHJldHVybiAoaXR4Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSAhPT0gXCIxXCI7XHJcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgIGlmIChhLnRvcCAhPT0gYi50b3ApIHJldHVybiBhLnRvcCAtIGIudG9wO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB2YXIgdGV4dHMgPSBhbGxJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXR4KXtcclxuICAgICAgICAgICAgcmV0dXJuIChpdHgubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRlYnVnLXRleHRvXCIpIHx8IFwiXCIpID09PSBcIjFcIjtcclxuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgaWYgKGEudG9wICE9PSBiLnRvcCkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBPcmRlbiBzZW3DoW50aWNvIGRlIGxlY3R1cmE6XHJcbiAgICAgICAgICAvLyBuby10ZXh0byArIHRleHRvIG3DoXMgY2VyY2FubyAoZGViYWpvIHkgcG9yIGVqZSBYKSwgbHVlZ28gcmVtYW5lbnRlcy5cclxuICAgICAgICAgIHZhciBvcmRlcmVkID0gW107XHJcbiAgICAgICAgICB2YXIgdXNlZFRleHQgPSB7fTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBudD0wOyBudDxub25UZXh0Lmxlbmd0aDsgbnQrKyl7XHJcbiAgICAgICAgICAgIHZhciBudEl0ZW0gPSBub25UZXh0W250XTtcclxuICAgICAgICAgICAgb3JkZXJlZC5wdXNoKG50SXRlbSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbnRDeCA9IChudEl0ZW0ubGVmdCB8fCAwKSArIChudEl0ZW0ud2lkdGggfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbnRCb3R0b20gPSAobnRJdGVtLnRvcCB8fCAwKSArIChudEl0ZW0uaGVpZ2h0IHx8IDApO1xyXG4gICAgICAgICAgICB2YXIgYmVzdElkeFR4dCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgYmVzdFNjb3JlID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciB0eD0wOyB0eDx0ZXh0cy5sZW5ndGg7IHR4Kyspe1xyXG4gICAgICAgICAgICAgIGlmICh1c2VkVGV4dFt0eF0pIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIHZhciB0SXRlbSA9IHRleHRzW3R4XTtcclxuICAgICAgICAgICAgICB2YXIgdEN4ID0gKHRJdGVtLmxlZnQgfHwgMCkgKyAodEl0ZW0ud2lkdGggfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICAgIHZhciB2R2FwVHh0ID0gKHRJdGVtLnRvcCB8fCAwKSAtIG50Qm90dG9tOyAvLyBwcmVmZXJpciB0ZXh0byBkZWJham9cclxuICAgICAgICAgICAgICB2YXIgaERpc3RUeHQgPSBNYXRoLmFicyh0Q3ggLSBudEN4KTtcclxuICAgICAgICAgICAgICB2YXIgcGVuYWx0eUFib3ZlID0gdkdhcFR4dCA8IC0yID8gMTAwMDAgOiAwO1xyXG4gICAgICAgICAgICAgIHZhciBzY29yZSA9IHBlbmFsdHlBYm92ZSArIE1hdGguYWJzKHZHYXBUeHQpICogMiArIGhEaXN0VHh0O1xyXG4gICAgICAgICAgICAgIGlmIChzY29yZSA8IGJlc3RTY29yZSl7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgICAgICAgIGJlc3RJZHhUeHQgPSB0eDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChiZXN0SWR4VHh0ID49IDApe1xyXG4gICAgICAgICAgICAgIG9yZGVyZWQucHVzaCh0ZXh0c1tiZXN0SWR4VHh0XSk7XHJcbiAgICAgICAgICAgICAgdXNlZFRleHRbYmVzdElkeFR4dF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVGV4dG9zIG5vIGVtcGFyZWphZG9zXHJcbiAgICAgICAgICBmb3IgKHZhciB0eDI9MDsgdHgyPHRleHRzLmxlbmd0aDsgdHgyKyspe1xyXG4gICAgICAgICAgICBpZiAoIXVzZWRUZXh0W3R4Ml0pIG9yZGVyZWQucHVzaCh0ZXh0c1t0eDJdKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTaSBubyBodWJvIG5vLXRleHRvLCBmYWxsYmFjayBzaW1wbGUgcG9yIHRvcC9sZWZ0XHJcbiAgICAgICAgICBpZiAoIW9yZGVyZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG9yZGVyZWQgPSBhbGxJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgICAgaWYgKGEudG9wICE9PSBiLnRvcCkgcmV0dXJuIGEudG9wIC0gYi50b3A7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGxvY2FsQ3Vyc29yID0gY2x1c3RlclRvcDtcclxuICAgICAgICAgIHZhciBwcmV2SXQgPSBudWxsO1xyXG4gICAgICAgICAgdmFyIHByZXZUb3BBcHBsaWVkID0gY2x1c3RlclRvcDtcclxuICAgICAgICAgIHZhciBFWFRSQV9DT0xfQlJFQUtfR0FQID0gODtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBsaT0wOyBsaTxvcmRlcmVkLmxlbmd0aDsgbGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBsaXQgPSBvcmRlcmVkW2xpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZWVwTGF5b3V0TGluID0gKGxpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWxheW91dFwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XHJcbiAgICAgICAgICAgIGlmIChrZWVwTGF5b3V0TGluKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdUb3BMaW4gPSBsb2NhbEN1cnNvcjtcclxuICAgICAgICAgICAgaWYgKHByZXZJdCl7XHJcbiAgICAgICAgICAgICAgdmFyIGdhcE9yaWdMaW4gPSBsaXQudG9wIC0gKHByZXZJdC50b3AgKyBwcmV2SXQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGdhcE9yaWdMaW4pKSBnYXBPcmlnTGluID0gMDtcclxuICAgICAgICAgICAgICB2YXIgZ2FwV2FudGVkTGluID0gY2xhbXAoZ2FwT3JpZ0xpbiAqIChDRkcuR0FQX1NDQUxFIHx8IDEpLCBDRkcuTUlOX0dBUCwgQ0ZHLk1BWF9HQVApO1xyXG4gICAgICAgICAgICAgIHZhciBwcmV2SXNUZXh0TGluID0gKHByZXZJdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgICAgICAgICAgIHZhciBjdXJySXNUZXh0TGluID0gKGxpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZGVidWctdGV4dG9cIikgfHwgXCJcIikgPT09IFwiMVwiO1xyXG4gICAgICAgICAgICAgIC8vIEFsIHBhc2FyIGRlIFwidGV4dG8gZmluYWwgZGUgY29sdW1uYVwiIGEgXCJudWV2byBuby10ZXh0b1wiIGFncmVnYW1vcyBhaXJlLlxyXG4gICAgICAgICAgICAgIGlmIChwcmV2SXNUZXh0TGluICYmICFjdXJySXNUZXh0TGluKSBnYXBXYW50ZWRMaW4gKz0gRVhUUkFfQ09MX0JSRUFLX0dBUDtcclxuICAgICAgICAgICAgICBuZXdUb3BMaW4gPSBwcmV2VG9wQXBwbGllZCArIHByZXZJdC5oZWlnaHQgKyBnYXBXYW50ZWRMaW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0TGluID0gY2VudGVyWCAtIChsaXQud2lkdGggfHwgMCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIga2VlcEFsaWduTGluID0gKGxpdC5ub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbW9iaWxlLWFsaWduXCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgICAgaWYgKGtlZXBBbGlnbkxpbikgbmV3TGVmdExpbiA9IGxpdC5sZWZ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5ld1RvcExpbiAtIGxpdC50b3ApID4gMC41IHx8IE1hdGguYWJzKG5ld0xlZnRMaW4gLSBsaXQubGVmdCkgPiAwLjUpIGNoYW5nZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gRW4gcm93cyBsaW5lYWxpemFkbywgZm9yemFtb3MgY2VudHJhZG8gdmlzdWFsIHJlYWwgZGUgdGV4dG8uXHJcbiAgICAgICAgICAgIHZhciBpc1RleHRMaW4gPSAobGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XHJcbiAgICAgICAgICAgIGlmIChpc1RleHRMaW4gJiYgIWtlZXBBbGlnbkxpbikge1xyXG4gICAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJ0b3AgY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRleHQtem9vbVwiLCBcIjFcIik7XHJcbiAgICAgICAgICAgICAgdmFyIHRmTGluID0gbGl0Lm5vZGUuc3R5bGUudHJhbnNmb3JtIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgaWYgKHRmTGluLmluZGV4T2YoXCJ0cmFuc2xhdGVYKFwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRmTGluLnJlcGxhY2UoL3RyYW5zbGF0ZVhcXChbXildKlxcKS8sIFwidHJhbnNsYXRlWCgwcHgpXCIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNzc0xlZnRMaW4gPSBuZXdMZWZ0TGluIC0gKGluZm8ucGFkTCB8fCAwKTtcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLnRvcCA9IG5ld1RvcExpbiArIFwicHhcIjtcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLmxlZnQgPSBjc3NMZWZ0TGluICsgXCJweFwiO1xuICAgICAgICAgICAgbGl0Lm5vZGUuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIGxpdC5ub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuXHJcbiAgICAgICAgICAgIHByZXZJdCA9IGxpdDtcclxuICAgICAgICAgICAgcHJldlRvcEFwcGxpZWQgPSBuZXdUb3BMaW47XHJcbiAgICAgICAgICAgIGxvY2FsQ3Vyc29yID0gbmV3VG9wTGluICsgKGxpdC5oZWlnaHQgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbEN1cnNvciA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGxvY2FsQ3Vyc29yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbEN1cnNvciA9IE1hdGgubWF4KGNvbEN1cnNvciwgY2x1c3RlckJvdHRvbVVzZWQpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcGxpY2FyIGEgY2FkYSBpdGVtIHByZXNlcnZhbmRvIG9mZnNldHMgcmVsYXRpdm9zIChzb2xhcGUgaW50YWN0bylcclxuICAgICAgICBmb3IgKHZhciBpaT0wOyBpaTxjLml0ZW1zLmxlbmd0aDsgaWkrKyl7XHJcbiAgICAgICAgICB2YXIgaXQgPSBjLml0ZW1zW2lpXTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IHRvdGFsIGRlbCBsYXlvdXQgKGRlY29yYWNpb25lcywgZXRjLilcclxuICAgICAgICAgIHZhciBrZWVwTGF5b3V0ID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb2JpbGUtbGF5b3V0XCIpIHx8IFwiXCIpID09PSBcImtlZXBcIjtcclxuICAgICAgICAgIGlmIChrZWVwTGF5b3V0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICB2YXIgbmV3VG9wID0gY2x1c3RlclRvcCArIChpdC5fcmVsVG9wIHx8IDApO1xyXG4gICAgICAgICAgdmFyIG5ld0xlZnQgPSBjbHVzdGVyTGVmdCArIChpdC5fcmVsTGVmdCB8fCAwKTtcclxuXHJcbiAgICAgICAgICAvLyBPcHQtb3V0IGRlIGNlbnRyYWRvIChtYW50ZW5lciBsZWZ0IG9yaWdpbmFsIGRlbCBpdGVtKVxuICAgICAgICAgIHZhciBrZWVwQWxpZ24gPSAoaXQubm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vYmlsZS1hbGlnblwiKSB8fCBcIlwiKSA9PT0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKGtlZXBBbGlnbikgbmV3TGVmdCA9IGl0LmxlZnQ7XG5cbiAgICAgICAgICAvLyBFbiBtdWx0aS1jb2wsIG5ldXRyYWxpemFtb3MgU0lFTVBSRSB0cmFuc2xhdGVYKC4uLikgZGUgdGV4dG9zXG4gICAgICAgICAgLy8gcGFyYSBxdWUgbGEgcG9zaWNpw7NuIGxlZnQgY2FsY3VsYWRhIHNlYSBsYSByZWZlcmVuY2lhIHZpc3VhbCByZWFsLlxuICAgICAgICAgIHZhciBpc1RleHROb2RlID0gKGl0Lm5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1kZWJ1Zy10ZXh0b1wiKSB8fCBcIlwiKSA9PT0gXCIxXCI7XG4gICAgICAgICAgdmFyIGlzU2hvcnRUZXh0Qm94ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNob3VsZFJlY2VudGVyVGV4dEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2VudGVyQnlBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0YXJnZXRUZXh0Q2VudGVyWCA9IE5hTjtcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZSAmJiBpc011bHRpQ29sTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgdGYgPSBpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRmLmluZGV4T2YoXCJ0cmFuc2xhdGVYKFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0Zi5yZXBsYWNlKC90cmFuc2xhdGVYXFwoW14pXSpcXCkvLCBcInRyYW5zbGF0ZVgoMHB4KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzU2hvcnRUZXh0Qm94ID0gKGl0LndpZHRoIHx8IDApIDw9IChpbmZvLnVzYWJsZVcgKiAwLjUpICYmIChpdC5oZWlnaHQgfHwgMCkgPD0gNDI7XG4gICAgICAgICAgICB2YXIgdGFDdXJyZW50ID0gKChpdC5ub2RlLnN0eWxlICYmIGl0Lm5vZGUuc3R5bGUudGV4dEFsaWduKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY2VudGVyQnlBbGlnbiA9IHRhQ3VycmVudCA9PT0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIHZhciBzaG91bGRDZW50ZXJWaXN1YWxUZXh0ID1cbiAgICAgICAgICAgICAgKHNob3VsZENlbnRlclRleHRXaXRoaW5DbHVzdGVyIHx8IGlzU2hvcnRUZXh0Qm94IHx8IGNlbnRlckJ5QWxpZ24pICYmXG4gICAgICAgICAgICAgICFrZWVwQWxpZ247XG4gICAgICAgICAgICBzaG91bGRSZWNlbnRlclRleHRJdGVtID1cbiAgICAgICAgICAgICAgc2hvdWxkQ2VudGVyVmlzdWFsVGV4dCAmJlxuICAgICAgICAgICAgICBpc0Zpbml0ZShjb2xSZWZlcmVuY2VDZW50ZXJYKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWNlbnRlclRleHRJdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2TGVmdFR4dCA9IG5ld0xlZnQ7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VJdGVtQ2VudGVyWCA9IChpdC5sZWZ0IHx8IDApICsgKGl0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZURyaWZ0SXRlbVggPSBpc0Zpbml0ZShjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYKVxuICAgICAgICAgICAgICAgID8gKHNvdXJjZUl0ZW1DZW50ZXJYIC0gY29sU291cmNlUmVmZXJlbmNlQ2VudGVyWClcbiAgICAgICAgICAgICAgICA6IE5hTjtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldENlbnRlclggPSBjb2xSZWZlcmVuY2VDZW50ZXJYO1xuICAgICAgICAgICAgICAvLyBFbiB0ZXh0b3MgY2VudHJhZG9zIChvIGxhYmVscyBjb3J0b3MgZm9yemFkb3MgYWwgY2VudHJvKSxcbiAgICAgICAgICAgICAgLy8gbm8gYXJyYXN0cmFtb3MgZHJpZnQgaG9yaXpvbnRhbCBkZWwgbGF5b3V0IG9yaWdpbmFsIHBhcmFcbiAgICAgICAgICAgICAgLy8gZXZpdGFyIGNvcnJpbWllbnRvcyBsYXRlcmFsZXMgZW4gbW9iaWxlLlxuICAgICAgICAgICAgICB2YXIgcHJlc2VydmVTb3VyY2VEcmlmdCA9XG4gICAgICAgICAgICAgICAgIWNlbnRlckJ5QWxpZ24gJiZcbiAgICAgICAgICAgICAgICAhc2hvdWxkQ2VudGVyVGV4dFdpdGhpbkNsdXN0ZXIgJiZcbiAgICAgICAgICAgICAgICAhaXNTaG9ydFRleHRCb3g7XG4gICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVNvdXJjZURyaWZ0ICYmIGlzRmluaXRlKHNvdXJjZURyaWZ0SXRlbVgpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyWCArPSBzb3VyY2VEcmlmdEl0ZW1YO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldFRleHRDZW50ZXJYID0gdGFyZ2V0Q2VudGVyWDtcbiAgICAgICAgICAgICAgbmV3TGVmdCA9IHRhcmdldENlbnRlclggLSAoaXQud2lkdGggfHwgMCkgLyAyO1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3TGVmdCAtIHByZXZMZWZ0VHh0KSA+IDAuNSkge1xuICAgICAgICAgICAgICAgIG1zbExvZyhcInN0YWNrOml0ZW06dGV4dFJlY2VudGVyXCIsIHtcbiAgICAgICAgICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgaWk6IGlpLFxuICAgICAgICAgICAgICAgICAgcHJldkxlZnQ6ICtwcmV2TGVmdFR4dC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgbmV3TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIGl0ZW1XOiArKGl0LndpZHRoIHx8IDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICByZWZDZW50ZXJYOiArY29sUmVmZXJlbmNlQ2VudGVyWC50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICAgc291cmNlUmVmQ2VudGVyWDogKHR5cGVvZiBjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGNvbFNvdXJjZVJlZmVyZW5jZUNlbnRlclgpKSA/ICtjb2xTb3VyY2VSZWZlcmVuY2VDZW50ZXJYLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc291cmNlRHJpZnRYOiBpc0Zpbml0ZShzb3VyY2VEcmlmdEl0ZW1YKSA/ICtzb3VyY2VEcmlmdEl0ZW1YLnRvRml4ZWQoMSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcHJlc2VydmVTb3VyY2VEcmlmdDogcHJlc2VydmVTb3VyY2VEcmlmdCxcbiAgICAgICAgICAgICAgICAgIHNob3J0Qm94OiBpc1Nob3J0VGV4dEJveCxcbiAgICAgICAgICAgICAgICAgIGNlbnRlckJ5QWxpZ246IGNlbnRlckJ5QWxpZ25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZENlbnRlclZpc3VhbFRleHQpIHtcbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgICBpdC5ub2RlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwidG9wIGNlbnRlclwiO1xuICAgICAgICAgICAgICAvLyBFdml0YSBlbmNvZ2ltaWVudG8gaG9yaXpvbnRhbCBoZXJlZGFkbyBxdWUgZGVzcGxhemEgZWwgY2VudHJvIHZpc3VhbC5cbiAgICAgICAgICAgICAgaXQubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGV4dC16b29tXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3NzTGVmdCA9IG5ld0xlZnQgLSAoaW5mby5wYWRMIHx8IDApO1xuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUudG9wID0gbmV3VG9wICsgXCJweFwiO1xuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubGVmdCA9IGNzc0xlZnQgKyBcInB4XCI7XG4gICAgICAgICAgaXQubm9kZS5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGl0Lm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG5cbiAgICAgICAgICAvLyBDb3JyZWNjacOzbiBmaW5hbCBwb3IgcG9zaWNpw7NuIHJlbmRlcml6YWRhIHJlYWwgZGVsIHRleHRvXG4gICAgICAgICAgLy8gKGZ1ZW50ZXMvdHJhbnNmb3JtIHB1ZWRlbiBpbnRyb2R1Y2lyIGRlc3bDrW9zIHZpc3VhbGVzIHN1Yi1ww614ZWwpLlxuICAgICAgICAgIGlmIChpc1RleHROb2RlICYmIGlzTXVsdGlDb2xMYXlvdXQgJiYgc2hvdWxkUmVjZW50ZXJUZXh0SXRlbSkge1xuICAgICAgICAgICAgdmFyIHJyVHh0ID0gcmVsUmVjdChpdC5ub2RlLCByb290RWwpO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQ2VudGVyWCA9IChyclR4dC5sZWZ0IHx8IDApICsgKHJyVHh0LndpZHRoIHx8IDApIC8gMjtcbiAgICAgICAgICAgIHZhciB0YXJnZXRSZW5kZXJDZW50ZXJYID0gaXNGaW5pdGUodGFyZ2V0VGV4dENlbnRlclgpID8gdGFyZ2V0VGV4dENlbnRlclggOiBjb2xSZWZlcmVuY2VDZW50ZXJYO1xuICAgICAgICAgICAgdmFyIHJlbmRlckRlbHRhID0gcmVuZGVyZWRDZW50ZXJYIC0gdGFyZ2V0UmVuZGVyQ2VudGVyWDtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShyZW5kZXJEZWx0YSkgJiYgTWF0aC5hYnMocmVuZGVyRGVsdGEpID4gMC42KSB7XG4gICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRMZWZ0ID0gbmV3TGVmdCAtIHJlbmRlckRlbHRhO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoY29ycmVjdGVkTGVmdCkpIHtcbiAgICAgICAgICAgICAgICBtc2xMb2coXCJzdGFjazppdGVtOnRleHRSZW5kZXJBZGp1c3RcIiwge1xuICAgICAgICAgICAgICAgICAgZzogZyxcbiAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICBpaTogaWksXG4gICAgICAgICAgICAgICAgICBwcmV2TGVmdDogK25ld0xlZnQudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZExlZnQ6ICtjb3JyZWN0ZWRMZWZ0LnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJlZENlbnRlclg6ICtyZW5kZXJlZENlbnRlclgudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAgIHJlZkNlbnRlclg6ICt0YXJnZXRSZW5kZXJDZW50ZXJYLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgICBkZWx0YTogK3JlbmRlckRlbHRhLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdMZWZ0ID0gY29ycmVjdGVkTGVmdDtcbiAgICAgICAgICAgICAgICBpdC5ub2RlLnN0eWxlLmxlZnQgPSAobmV3TGVmdCAtIChpbmZvLnBhZEwgfHwgMCkpICsgXCJweFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKG5ld1RvcCAtIGl0LnRvcCkgPiAwLjUgfHwgTWF0aC5hYnMobmV3TGVmdCAtIGl0LmxlZnQpID4gMC41KSBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBpdGVtQm90dG9tID0gbmV3VG9wICsgKGl0LmhlaWdodCB8fCAwKTtcbiAgICAgICAgICBpZiAoaXRlbUJvdHRvbSA+IGNsdXN0ZXJCb3R0b21Vc2VkKSBjbHVzdGVyQm90dG9tVXNlZCA9IGl0ZW1Cb3R0b207XG4gICAgICAgIH1cblxyXG4gICAgICAgIC8vIEF2YW56YSBlbCBjdXJzb3IgbG9jYWwgYWwgZmluYWwgZGVsIGNsdXN0ZXJcclxuICAgICAgICBjb2xDdXJzb3IgPSBNYXRoLm1heChjb2xDdXJzb3IsIGNsdXN0ZXJCb3R0b21Vc2VkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWwgdGVybWluYXIgbGEgY29sdW1uYSwgZWwgY3Vyc29yIGdsb2JhbCBiYWphIGhhc3RhIGRvbmRlIGxsZWfDsyBlc3RhIGNvbHVtbmFcclxuICAgICAgZ2xvYmFsQ3Vyc29yID0gTWF0aC5tYXgoZ2xvYmFsQ3Vyc29yLCBjb2xDdXJzb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZWVkZWQgPSBnbG9iYWxDdXJzb3IgKyBDRkcuUEFEX0JPVDtcclxuICAgIG1zbExvZyhcInN0YWNrOmVuZFwiLCB7XHJcbiAgICAgIGNoYW5nZWQ6IGNoYW5nZWQsXHJcbiAgICAgIG5lZWRlZEhlaWdodDogK25lZWRlZC50b0ZpeGVkKDEpLFxyXG4gICAgICBmaW5hbEN1cnNvcjogK2dsb2JhbEN1cnNvci50b0ZpeGVkKDEpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IGNoYW5nZWQ6IGNoYW5nZWQsIG5lZWRlZEhlaWdodDogbmVlZGVkIH07XHJcbiAgfVxyXG5gLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsianNTdGFja2luZ0Jsb2NrIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./functions/src/utils/mobileSmartLayout/stacking.ts\n"));

/***/ })

});