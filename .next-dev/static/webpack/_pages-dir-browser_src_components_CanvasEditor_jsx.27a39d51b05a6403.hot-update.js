"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/components/SelectionBounds.jsx":
/*!********************************************!*\
  !*** ./src/components/SelectionBounds.jsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectionBounds)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-konva */ \"(pages-dir-browser)/./node_modules/react-konva/es/ReactKonva.js\");\n// SelectionBounds.jsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst DEBUG_SELECTION_BOUNDS = false;\nconst sbLog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!DEBUG_SELECTION_BOUNDS) return;\n    console.log(\"[SB]\", ...args);\n};\nconst slog = sbLog;\nconst TRDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!window.__DBG_TR) return;\n    console.log(\"[TRDBG]\", ...args);\n};\n_c = TRDBG;\nconst TXTDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n    if (!window.__DBG_TEXT_RESIZE) return;\n    console.log(\"[TEXT-TR]\", ...args);\n};\n_c1 = TXTDBG;\nfunction rectFromNodes(nodes) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for (const n of nodes){\n        if (!(n === null || n === void 0 ? void 0 : n.getClientRect)) continue;\n        const r = n.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        minX = Math.min(minX, r.x);\n        minY = Math.min(minY, r.y);\n        maxX = Math.max(maxX, r.x + r.width);\n        maxY = Math.max(maxY, r.y + r.height);\n    }\n    if (minX === Infinity) return null;\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getCountdownScaledSize(node) {\n    try {\n        var _node_findOne;\n        const hitbox = node === null || node === void 0 ? void 0 : (_node_findOne = node.findOne) === null || _node_findOne === void 0 ? void 0 : _node_findOne.call(node, \".countdown-hitbox\");\n        const baseW = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.width) === \"function\" ? hitbox.width() : NaN;\n        const baseH = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.height) === \"function\" ? hitbox.height() : NaN;\n        const sx = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() || 1 : 1);\n        const sy = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() || 1 : 1);\n        if (Number.isFinite(baseW) && Number.isFinite(baseH) && baseW > 0 && baseH > 0) {\n            return {\n                width: Math.abs(baseW * sx),\n                height: Math.abs(baseH * sy)\n            };\n        }\n    } catch (e) {}\n    try {\n        const r = node.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        return {\n            width: Math.abs(r.width),\n            height: Math.abs(r.height)\n        };\n    } catch (e) {}\n    return {\n        width: 100,\n        height: 50\n    };\n}\n// ðŸŽ¨ Componente para mostrar bounds sin transformer (lÃ­neas, etc.)\nconst BoundsIndicator = (param)=>{\n    let { selectedElements, elementRefs, objetos } = param;\n    _s();\n    const [forceUpdate, setForceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"BoundsIndicator.useEffect\": ()=>{\n            var _elementRefs_current, _firstRef_getStage;\n            const firstRef = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[selectedElements[0]];\n            const stage = firstRef === null || firstRef === void 0 ? void 0 : (_firstRef_getStage = firstRef.getStage) === null || _firstRef_getStage === void 0 ? void 0 : _firstRef_getStage.call(firstRef);\n            if (!stage) return;\n            const handleDragMove = {\n                \"BoundsIndicator.useEffect.handleDragMove\": ()=>{\n                    setForceUpdate({\n                        \"BoundsIndicator.useEffect.handleDragMove\": (p)=>p + 1\n                    }[\"BoundsIndicator.useEffect.handleDragMove\"]);\n                }\n            }[\"BoundsIndicator.useEffect.handleDragMove\"];\n            stage.on(\"dragmove\", handleDragMove);\n            return ({\n                \"BoundsIndicator.useEffect\": ()=>{\n                    stage.off(\"dragmove\", handleDragMove);\n                }\n            })[\"BoundsIndicator.useEffect\"];\n        }\n    }[\"BoundsIndicator.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    const elementosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    if (elementosData.length === 0) {\n        return null;\n    }\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    elementosData.forEach((obj)=>{\n        const node = elementRefs.current[obj.id];\n        if (!node) return;\n        try {\n            if (obj.tipo === \"forma\" && obj.figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    100,\n                    0\n                ];\n                const cleanPoints = [\n                    parseFloat(points[0]) || 0,\n                    parseFloat(points[1]) || 0,\n                    parseFloat(points[2]) || 100,\n                    parseFloat(points[3]) || 0\n                ];\n                const realX = node.x();\n                const realY = node.y();\n                const x1 = realX + cleanPoints[0];\n                const y1 = realY + cleanPoints[1];\n                const x2 = realX + cleanPoints[2];\n                const y2 = realY + cleanPoints[3];\n                const linePadding = 5;\n                minX = Math.min(minX, x1 - linePadding, x2 - linePadding);\n                minY = Math.min(minY, y1 - linePadding, y2 - linePadding);\n                maxX = Math.max(maxX, x1 + linePadding, x2 + linePadding);\n                maxY = Math.max(maxY, y1 + linePadding, y2 + linePadding);\n            } else {\n                var _node_scaleX, _node_scaleY;\n                const box = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                const r = box;\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = node === null || node === void 0 ? void 0 : (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = node === null || node === void 0 ? void 0 : (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                slog(\"[BI]\", \"id=\".concat(obj.id), \"tipo=\".concat(obj.tipo), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"rect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"));\n                const realX = box.x;\n                const realY = box.y;\n                let width = box.width;\n                let height = box.height;\n                if (obj.tipo === \"texto\" && node.getTextHeight) {\n                    const textHeight = node.getTextHeight();\n                    if (textHeight) {\n                        height = textHeight;\n                    }\n                }\n                minX = Math.min(minX, realX);\n                minY = Math.min(minY, realY);\n                maxX = Math.max(maxX, realX + width);\n                maxY = Math.max(maxY, realY + height);\n            }\n        } catch (error) {\n            const fallbackX = obj.x || 0;\n            const fallbackY = obj.y || 0;\n            const fallbackSize = 20;\n            minX = Math.min(minX, fallbackX);\n            minY = Math.min(minY, fallbackY);\n            maxX = Math.max(maxX, fallbackX + fallbackSize);\n            maxY = Math.max(maxY, fallbackY + fallbackSize);\n        }\n    });\n    if (minX === Infinity || maxX === -Infinity) {\n        const primerElemento = elementosData[0];\n        if (!primerElemento) return null;\n        minX = primerElemento.x || 0;\n        minY = primerElemento.y || 0;\n        maxX = minX + 100;\n        maxY = minY + 50;\n    }\n    const padding = 10;\n    const finalX = minX - padding;\n    const finalY = minY - padding;\n    const finalWidth = maxX - minX + padding * 2;\n    const finalHeight = maxY - minY + padding * 2;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, {\n        name: \"ui\",\n        x: finalX,\n        y: finalY,\n        width: finalWidth,\n        height: finalHeight,\n        fill: \"transparent\",\n        stroke: \"#9333EA\",\n        strokeWidth: 1,\n        listening: false,\n        opacity: 0.7\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 188,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BoundsIndicator, \"X1gDcjpboC/BQr7oI4aemyzw8+o=\");\n_c2 = BoundsIndicator;\nfunction SelectionBounds(param) {\n    let { selectedElements, elementRefs, objetos, onTransform, onTransformInteractionStart = null, onTransformInteractionEnd = null, isDragging, isMobile = false } = param;\n    _s1();\n    const transformerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [transformTick, setTransformTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const lastNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const circleAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textTransformAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const transformGestureRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        isRotate: false,\n        activeAnchor: null\n    });\n    const isTransformingResizeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const [isResizeGestureActive, setIsResizeGestureActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [pressedResizeAnchorName, setPressedResizeAnchorName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const elementosSeleccionadosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    const primerElemento = elementosSeleccionadosData[0] || null;\n    const esTexto = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"texto\";\n    const esCountdown = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\";\n    const esGaleria = selectedElements.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"galeria\";\n    const lockAspectCountdown = selectedElements.length === 1 && esCountdown;\n    const lockAspectText = selectedElements.length === 1 && esTexto;\n    const transformerAnchorSize = isMobile ? 32 : 14; //tamaÃ±o visual del nodo (mÃ¡s grande en mobile).\n    const transformerRotateOffset = isMobile ? 34 : 24; // distancia del handle de rotaciÃ³n al borde.\n    const transformerAnchorRadius = 999; //radio de esquina del nodo (999 lo hace circular).\n    const transformerPadding = isMobile ? 14 : 4; // espacio extra entre borde del transformer y elemento.\n    const transformerBorderStrokeWidth = isMobile ? 1.5 : 1; //grosor del borde del transformer.\n    const transformerAnchorFillColor = \"#9333EA\";\n    const transformerAnchorStrokeWidth = isMobile ? 1.4 : 2.5; //grosor del borde del nodo.\n    const transformerAnchorShadowBlur = isMobile ? 9 : 6; // quÃ© tan difusa es la sombra base del nodo.\n    const transformerAnchorShadowOffsetY = isMobile ? 4 : 3; // desplazamiento vertical de esa sombra.\n    const transformerAnchorHitStrokeWidth = isMobile ? 62 : 20;\n    const transformerAnchorPressedHitStrokeWidth = isMobile ? 96 : 24;\n    const transformerAnchorStrokeColor = \"#ffffff\";\n    const transformerAnchorPressedHaloStrokeColor = isMobile ? \"rgba(255, 255, 255, 0.95)\" : transformerAnchorStrokeColor;\n    const transformerAnchorPressedHaloStrokeWidth = isMobile ? 2.2 : 3.2;\n    const transformerAnchorShadowColor = \"rgba(147, 51, 234, 0.3)\";\n    const transformerAnchorPressedShadowColor = isMobile ? \"rgba(198, 120, 255, 1)\" : \"rgba(147, 51, 234, 0.7)\";\n    const transformerAnchorPressedShadowBlur = isMobile ? 92 : 18;\n    const transformerAnchorPressedShadowOffsetY = isMobile ? 0 : transformerAnchorShadowOffsetY + 1;\n    const transformerAnchorPressedScale = isMobile ? 1.03 : 1.1;\n    const transformerRotationSnapTolerance = isMobile ? 8 : 5; //tolerancia para â€œencajarâ€ rotaciÃ³n en Ã¡ngulos fijos.\n    const esTriangulo = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"triangle\";\n    const hasGallery = elementosSeleccionadosData.some((o)=>o.tipo === \"galeria\");\n    const hayLineas = elementosSeleccionadosData.some((obj)=>obj.tipo === \"forma\" && obj.figura === \"line\");\n    const elementosTransformables = elementosSeleccionadosData.filter((obj)=>!(obj.tipo === \"forma\" && obj.figura === \"line\"));\n    const deberiaUsarTransformer = elementosTransformables.length > 0;\n    const selectedGeomKey = elementosSeleccionadosData.map((o)=>{\n        var _o_x, _o_y, _o_width, _o_height, _o_scaleX, _o_scaleY, _o_rotation, _o_chipWidth, _o_gap, _o_paddingX, _o_paddingY;\n        return [\n            o.id,\n            (_o_x = o.x) !== null && _o_x !== void 0 ? _o_x : 0,\n            (_o_y = o.y) !== null && _o_y !== void 0 ? _o_y : 0,\n            (_o_width = o.width) !== null && _o_width !== void 0 ? _o_width : \"\",\n            (_o_height = o.height) !== null && _o_height !== void 0 ? _o_height : \"\",\n            (_o_scaleX = o.scaleX) !== null && _o_scaleX !== void 0 ? _o_scaleX : 1,\n            (_o_scaleY = o.scaleY) !== null && _o_scaleY !== void 0 ? _o_scaleY : 1,\n            (_o_rotation = o.rotation) !== null && _o_rotation !== void 0 ? _o_rotation : 0,\n            (_o_chipWidth = o.chipWidth) !== null && _o_chipWidth !== void 0 ? _o_chipWidth : \"\",\n            (_o_gap = o.gap) !== null && _o_gap !== void 0 ? _o_gap : \"\",\n            (_o_paddingX = o.paddingX) !== null && _o_paddingX !== void 0 ? _o_paddingX : \"\",\n            (_o_paddingY = o.paddingY) !== null && _o_paddingY !== void 0 ? _o_paddingY : \"\"\n        ].join(\":\");\n    }).join(\"|\");\n    const getTransformPose = (node)=>{\n        if (!node) return {\n            x: 0,\n            y: 0,\n            rotation: 0\n        };\n        if (esGaleria && typeof node.getParent === \"function\") {\n            const parent = node.getParent();\n            if (parent) {\n                return {\n                    x: typeof parent.x === \"function\" ? parent.x() : 0,\n                    y: typeof parent.y === \"function\" ? parent.y() : 0,\n                    rotation: typeof parent.rotation === \"function\" ? parent.rotation() || 0 : 0\n                };\n            }\n        }\n        return {\n            x: typeof node.x === \"function\" ? node.x() : 0,\n            y: typeof node.y === \"function\" ? node.y() : 0,\n            rotation: typeof node.rotation === \"function\" ? node.rotation() || 0 : 0\n        };\n    };\n    const clearResizeAnchorPressFeedback = ()=>{\n        if (isTransformingResizeRef.current) return;\n        setIsResizeGestureActive(false);\n        setPressedResizeAnchorName((current)=>current ? null : current);\n    };\n    const getResizeAnchorNameFromTarget = (target)=>{\n        if (!target) return null;\n        const isAnchorTarget = typeof target.hasName === \"function\" ? target.hasName(\"_anchor\") : typeof target.name === \"function\" && String(target.name() || \"\").includes(\"_anchor\");\n        if (!isAnchorTarget) return null;\n        const rawName = typeof target.name === \"function\" ? String(target.name() || \"\") : \"\";\n        const anchorName = rawName.split(\" \")[0] || null;\n        if (!anchorName) return null;\n        if (anchorName.toLowerCase().includes(\"rotat\")) return null;\n        return anchorName;\n    };\n    const handleResizeAnchorPressStart = (event)=>{\n        let anchorName = getResizeAnchorNameFromTarget(event === null || event === void 0 ? void 0 : event.target);\n        if (!anchorName) {\n            var _transformerRef_current;\n            const activeAnchor = typeof ((_transformerRef_current = transformerRef.current) === null || _transformerRef_current === void 0 ? void 0 : _transformerRef_current.getActiveAnchor) === \"function\" ? transformerRef.current.getActiveAnchor() : null;\n            if (typeof activeAnchor === \"string\" && !activeAnchor.toLowerCase().includes(\"rotat\")) {\n                anchorName = activeAnchor;\n            }\n        }\n        if (!anchorName) return;\n        setIsResizeGestureActive(true);\n        setPressedResizeAnchorName((current)=>current === anchorName ? current : anchorName);\n    };\n    const getBoxOverflowAmount = (box, stageWidth, stageHeight)=>{\n        if (!box) return Number.POSITIVE_INFINITY;\n        const x = Number(box.x);\n        const y = Number(box.y);\n        const width = Number(box.width);\n        const height = Number(box.height);\n        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height)) {\n            return Number.POSITIVE_INFINITY;\n        }\n        const left = Math.min(x, x + width);\n        const right = Math.max(x, x + width);\n        const top = Math.min(y, y + height);\n        const bottom = Math.max(y, y + height);\n        const overflowLeft = Math.max(0, -left);\n        const overflowTop = Math.max(0, -top);\n        const overflowRight = Math.max(0, right - stageWidth);\n        const overflowBottom = Math.max(0, bottom - stageHeight);\n        return overflowLeft + overflowTop + overflowRight + overflowBottom;\n    };\n    const keepBoxInsideStage = (oldBox, nextBox)=>{\n        var _tr_getStage, _stage_attrs, _stage_attrs1;\n        const tr = transformerRef.current;\n        const stage = tr === null || tr === void 0 ? void 0 : (_tr_getStage = tr.getStage) === null || _tr_getStage === void 0 ? void 0 : _tr_getStage.call(tr);\n        const stageWidth = typeof (stage === null || stage === void 0 ? void 0 : stage.width) === \"function\" ? Number(stage.width()) : Number(stage === null || stage === void 0 ? void 0 : (_stage_attrs = stage.attrs) === null || _stage_attrs === void 0 ? void 0 : _stage_attrs.width);\n        const stageHeight = typeof (stage === null || stage === void 0 ? void 0 : stage.height) === \"function\" ? Number(stage.height()) : Number(stage === null || stage === void 0 ? void 0 : (_stage_attrs1 = stage.attrs) === null || _stage_attrs1 === void 0 ? void 0 : _stage_attrs1.height);\n        if (!Number.isFinite(stageWidth) || stageWidth <= 0 || !Number.isFinite(stageHeight) || stageHeight <= 0) {\n            return nextBox;\n        }\n        const oldOverflow = getBoxOverflowAmount(oldBox, stageWidth, stageHeight);\n        const nextOverflow = getBoxOverflowAmount(nextBox, stageWidth, stageHeight);\n        const epsilon = 0.5;\n        if (!Number.isFinite(nextOverflow)) {\n            return oldBox;\n        }\n        if (nextOverflow <= epsilon) {\n            return nextBox;\n        }\n        // Permitir transformar de vuelta hacia adentro del canvas.\n        if (nextOverflow <= oldOverflow + epsilon) {\n            return nextBox;\n        }\n        // Si el resize empuja mÃ¡s afuera del canvas, mantener el estado anterior.\n        return oldBox;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            if (selectedElements.length === 0 || !deberiaUsarTransformer) {\n                setIsResizeGestureActive(false);\n                setPressedResizeAnchorName({\n                    \"SelectionBounds.useEffect\": (current)=>current ? null : current\n                }[\"SelectionBounds.useEffect\"]);\n                return;\n            }\n            if (isDragging && !isTransformingResizeRef.current) {\n                setIsResizeGestureActive(false);\n                setPressedResizeAnchorName({\n                    \"SelectionBounds.useEffect\": (current)=>current ? null : current\n                }[\"SelectionBounds.useEffect\"]);\n            }\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.length,\n        isDragging,\n        deberiaUsarTransformer\n    ]);\n    // ðŸ”¥ Efecto principal del Transformer (SIN retry / SIN flicker)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _window_editing, _tr_nodes, _tr_nodes1, _tr_getLayer;\n            const tr = transformerRef.current;\n            if (!tr) return;\n            const selKey = selectedElements.join(\",\");\n            TRDBG(\"EFFECT start\", {\n                selKey,\n                isDragging,\n                deberiaUsarTransformer,\n                hasGallery,\n                elementosTransformablesLen: elementosTransformables.length,\n                transformTick,\n                editingId: ((_window_editing = window.editing) === null || _window_editing === void 0 ? void 0 : _window_editing.id) || null\n            });\n            // Si no corresponde transformer, no hagas detach agresivo (evita flicker)\n            if (!deberiaUsarTransformer) {\n                TRDBG(\"EFFECT exit: no transformer or gallery\", {\n                    selKey\n                });\n                return;\n            }\n            // Resolver nodes desde refs (fuente de verdad)\n            let nodosTransformables = elementosTransformables.map({\n                \"SelectionBounds.useEffect.nodosTransformables\": (o)=>{\n                    var _elementRefs_current;\n                    return (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id];\n                }\n            }[\"SelectionBounds.useEffect.nodosTransformables\"]).filter(Boolean);\n            // Single select: usar ref fresco SIEMPRE\n            if (selectedElements.length === 1) {\n                var _elementRefs_current;\n                const idSel = selectedElements[0];\n                const refNode = ((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel]) || null;\n                if (refNode && typeof refNode.getClientRect === \"function\") {\n                    if (esGaleria && typeof refNode.findOne === \"function\") {\n                        const galleryFrame = refNode.findOne(\".gallery-transform-frame\");\n                        if (galleryFrame && typeof galleryFrame.getClientRect === \"function\") {\n                            nodosTransformables = [\n                                galleryFrame\n                            ];\n                        } else {\n                            nodosTransformables = [\n                                refNode\n                            ];\n                        }\n                    } else {\n                        nodosTransformables = [\n                            refNode\n                        ];\n                    }\n                }\n            }\n            // Si aÃºn no hay nodos (imagen cargando, etc.), NO despegar (evita parpadeo)\n            if (nodosTransformables.length === 0) {\n                TRDBG(\"EFFECT exit: no nodes yet\", {\n                    selKey,\n                    wantedIds: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>o.id\n                    }[\"SelectionBounds.useEffect\"]),\n                    refsPresent: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>{\n                            var _elementRefs_current;\n                            return !!((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id]);\n                        }\n                    }[\"SelectionBounds.useEffect\"])\n                });\n                return;\n            }\n            // Attach estable\n            TRDBG(\"ATTACH try\", {\n                selKey,\n                nodesCount: nodosTransformables.length,\n                nodeIds: nodosTransformables.map({\n                    \"SelectionBounds.useEffect\": (n)=>{\n                        var _n_attrs;\n                        return typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id;\n                    }\n                }[\"SelectionBounds.useEffect\"])\n            });\n            tr.nodes(nodosTransformables);\n            TRDBG(\"ATTACH done\", {\n                selKey,\n                trNodesCount: ((_tr_nodes1 = tr.nodes) === null || _tr_nodes1 === void 0 ? void 0 : (_tr_nodes = _tr_nodes1.call(tr)) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.length) || 0\n            });\n            try {\n                var _tr_forceUpdate;\n                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n            } catch (e) {}\n            (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        // Dependencias mÃ­nimas reales\n        selectedElements.join(\",\"),\n        deberiaUsarTransformer,\n        hasGallery,\n        elementosTransformables.length,\n        selectedGeomKey,\n        transformTick,\n        elementRefs\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            const handler = {\n                \"SelectionBounds.useEffect.handler\": (e)=>{\n                    var _e_detail;\n                    const id = e === null || e === void 0 ? void 0 : (_e_detail = e.detail) === null || _e_detail === void 0 ? void 0 : _e_detail.id;\n                    if (!id) return;\n                    TRDBG(\"REF event\", {\n                        id,\n                        isSelected: selectedElements.includes(id),\n                        selKey: selectedElements.join(\",\")\n                    });\n                    if (!selectedElements.includes(id)) return;\n                    setTransformTick({\n                        \"SelectionBounds.useEffect.handler\": (t)=>t + 1\n                    }[\"SelectionBounds.useEffect.handler\"]);\n                }\n            }[\"SelectionBounds.useEffect.handler\"];\n            window.addEventListener(\"element-ref-registrado\", handler);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>window.removeEventListener(\"element-ref-registrado\", handler)\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _elementRefs_current, _firstNode_getStage;\n            const firstId = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n            if (!firstId) return;\n            const firstNode = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[firstId];\n            const stage = firstNode === null || firstNode === void 0 ? void 0 : (_firstNode_getStage = firstNode.getStage) === null || _firstNode_getStage === void 0 ? void 0 : _firstNode_getStage.call(firstNode);\n            if (!stage) return;\n            let rafId = null;\n            const syncTransformer = {\n                \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                    if (rafId != null) return;\n                    rafId = requestAnimationFrame({\n                        \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                            var _tr_getLayer_batchDraw, _tr_getLayer, _tr_getLayer1;\n                            rafId = null;\n                            const tr = transformerRef.current;\n                            if (!tr) return;\n                            try {\n                                var _tr_forceUpdate;\n                                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n                            } catch (e) {}\n                            (_tr_getLayer1 = tr.getLayer) === null || _tr_getLayer1 === void 0 ? void 0 : (_tr_getLayer = _tr_getLayer1.call(tr)) === null || _tr_getLayer === void 0 ? void 0 : (_tr_getLayer_batchDraw = _tr_getLayer.batchDraw) === null || _tr_getLayer_batchDraw === void 0 ? void 0 : _tr_getLayer_batchDraw.call(_tr_getLayer);\n                        }\n                    }[\"SelectionBounds.useEffect.syncTransformer\"]);\n                }\n            }[\"SelectionBounds.useEffect.syncTransformer\"];\n            stage.on(\"dragmove\", syncTransformer);\n            stage.on(\"dragend\", syncTransformer);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>{\n                    stage.off(\"dragmove\", syncTransformer);\n                    stage.off(\"dragend\", syncTransformer);\n                    if (rafId != null) cancelAnimationFrame(rafId);\n                }\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\"),\n        elementRefs\n    ]);\n    // ðŸ”¥ Render\n    if (selectedElements.length === 0) return null;\n    if (hayLineas && elementosTransformables.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 592,\n            columnNumber: 7\n        }, this);\n    }\n    if (hayLineas && elementosTransformables.length > 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 602,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Transformer, {\n        name: \"ui\",\n        ref: transformerRef,\n        // ðŸ”µ borde siempre visible\n        borderEnabled: true,\n        borderStroke: \"#9333EA\",\n        borderStrokeWidth: transformerBorderStrokeWidth,\n        padding: transformerPadding,\n        // âŒ nodos y rotaciÃ³n OFF durante drag\n        enabledAnchors: isDragging && !isResizeGestureActive ? [] : [\n            \"bottom-right\"\n        ],\n        rotateEnabled: !isDragging && !esGaleria,\n        onMouseDown: handleResizeAnchorPressStart,\n        onTouchStart: handleResizeAnchorPressStart,\n        onPointerDown: handleResizeAnchorPressStart,\n        onMouseUp: clearResizeAnchorPressFeedback,\n        onTouchEnd: clearResizeAnchorPressFeedback,\n        onPointerUp: clearResizeAnchorPressFeedback,\n        onTouchCancel: clearResizeAnchorPressFeedback,\n        onPointerCancel: clearResizeAnchorPressFeedback,\n        anchorFill: transformerAnchorFillColor,\n        anchorStroke: transformerAnchorStrokeColor,\n        anchorStrokeWidth: transformerAnchorStrokeWidth,\n        anchorSize: transformerAnchorSize,\n        anchorCornerRadius: transformerAnchorRadius,\n        anchorShadowColor: transformerAnchorShadowColor,\n        anchorShadowBlur: transformerAnchorShadowBlur,\n        anchorShadowOffset: {\n            x: 0,\n            y: transformerAnchorShadowOffsetY\n        },\n        anchorStyleFunc: (anchor)=>{\n            var _window__resizeData;\n            const anchorName = typeof (anchor === null || anchor === void 0 ? void 0 : anchor.name) === \"function\" ? String(anchor.name() || \"\").split(\" \")[0] : \"\";\n            const isResizeAnchorNode = Boolean(anchorName) && !anchorName.toLowerCase().includes(\"rotat\");\n            const isResizeActiveFallback = isResizeGestureActive || isTransformingResizeRef.current ||  true && Boolean((_window__resizeData = window._resizeData) === null || _window__resizeData === void 0 ? void 0 : _window__resizeData.isResizing);\n            const isPressedResizeAnchor = isResizeActiveFallback && isResizeAnchorNode && (!pressedResizeAnchorName || anchorName === pressedResizeAnchorName);\n            anchor.shadowColor(isPressedResizeAnchor ? transformerAnchorPressedShadowColor : transformerAnchorShadowColor);\n            // Mantener siempre el color original del nodo.\n            anchor.fill(transformerAnchorFillColor);\n            anchor.shadowEnabled(true);\n            // En pressed, el halo nace mÃ¡s cerca del anillo para que se note mejor.\n            anchor.shadowForStrokeEnabled(isPressedResizeAnchor);\n            anchor.shadowOpacity(isPressedResizeAnchor ? 1 : 0.12);\n            anchor.shadowBlur(isPressedResizeAnchor ? transformerAnchorPressedShadowBlur : transformerAnchorShadowBlur);\n            anchor.shadowOffset({\n                x: 0,\n                y: isPressedResizeAnchor ? transformerAnchorPressedShadowOffsetY : transformerAnchorShadowOffsetY\n            });\n            anchor.hitStrokeWidth(isPressedResizeAnchor ? transformerAnchorPressedHitStrokeWidth : transformerAnchorHitStrokeWidth);\n            anchor.stroke(isPressedResizeAnchor ? transformerAnchorPressedHaloStrokeColor : transformerAnchorStrokeColor);\n            anchor.strokeWidth(isPressedResizeAnchor ? transformerAnchorPressedHaloStrokeWidth : transformerAnchorStrokeWidth);\n            const anchorScale = isPressedResizeAnchor ? transformerAnchorPressedScale : 1;\n            anchor.scale({\n                x: anchorScale,\n                y: anchorScale\n            });\n        },\n        keepRatio: lockAspectCountdown || esGaleria || lockAspectText,\n        centeredScaling: selectedElements.length === 1 && esTexto,\n        flipEnabled: false,\n        resizeEnabled: !isDragging || isResizeGestureActive,\n        rotationSnaps: [\n            0,\n            45,\n            90,\n            135,\n            180,\n            225,\n            270,\n            315\n        ],\n        rotateAnchorOffset: transformerRotateOffset,\n        rotationSnapTolerance: transformerRotationSnapTolerance,\n        boundBoxFunc: (oldBox, newBox)=>{\n            const minSize = esTexto ? 20 : 10;\n            const maxSize = 800;\n            if (esGaleria) {\n                const rows = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.rows) || 1);\n                const cols = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.cols) || 1);\n                const gap = Math.max(0, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.gap) || 0);\n                const cellRatio = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"4:3\" ? 3 / 4 : (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"16:9\" ? 9 / 16 : 1;\n                const minGridWidth = gap * (cols - 1) + cols;\n                const nextWidth = Math.min(maxSize, Math.max(minSize, minGridWidth, Math.abs(newBox.width)));\n                const cellW = Math.max(1, (nextWidth - gap * (cols - 1)) / cols);\n                const cellH = cellW * cellRatio;\n                const nextHeight = rows * cellH + gap * (rows - 1);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: nextWidth,\n                    height: Math.max(minSize, nextHeight)\n                });\n            }\n            if (newBox.width < minSize || newBox.height < minSize) {\n                return oldBox;\n            }\n            if (lockAspectCountdown) {\n                const baseW = Math.max(1, oldBox.width);\n                const baseH = Math.max(1, oldBox.height);\n                const ratio = baseW / baseH;\n                const dw = Math.abs(newBox.width - oldBox.width) / baseW;\n                const dh = Math.abs(newBox.height - oldBox.height) / baseH;\n                let width = newBox.width;\n                let height = newBox.height;\n                if (dh > dw) {\n                    width = height * ratio;\n                } else {\n                    height = width / ratio;\n                }\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: Math.min(Math.max(width, minSize), maxSize),\n                    height: Math.min(Math.max(height, minSize), maxSize)\n                });\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                const size = Math.max(newBox.width, newBox.height);\n                const finalSize = Math.min(size, maxSize);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: finalSize,\n                    height: finalSize\n                });\n            }\n            if (esTriangulo) {\n                const safeOldW = Math.max(1, Math.abs(oldBox.width || minSize));\n                const safeOldH = Math.max(1, Math.abs(oldBox.height || minSize));\n                const scaleX = Math.abs(newBox.width) / safeOldW;\n                const scaleY = Math.abs(newBox.height) / safeOldH;\n                const uniformScale = Math.max(0.05, Math.min(scaleX, scaleY));\n                const width = Math.min(Math.max(safeOldW * uniformScale, minSize), maxSize);\n                const height = Math.min(Math.max(safeOldH * uniformScale, minSize), maxSize);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width,\n                    height\n                });\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"imagen\" || (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"icono\") {\n                const scaleX = newBox.width / oldBox.width;\n                const scaleY = newBox.height / oldBox.height;\n                const uniformScale = Math.min(scaleX, scaleY);\n                const newWidth = oldBox.width * uniformScale;\n                const newHeight = oldBox.height * uniformScale;\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: Math.min(Math.max(newWidth, minSize), maxSize),\n                    height: Math.min(Math.max(newHeight, minSize), maxSize)\n                });\n            }\n            return keepBoxInsideStage(oldBox, {\n                ...newBox,\n                width: Math.min(newBox.width, maxSize),\n                height: Math.min(newBox.height, maxSize)\n            });\n        },\n        onTransformStart: (e)=>{\n            isTransformingResizeRef.current = true;\n            window._resizeData = {\n                isResizing: true\n            };\n            const tr = transformerRef.current;\n            const activeAnchor = typeof (tr === null || tr === void 0 ? void 0 : tr.getActiveAnchor) === \"function\" ? tr.getActiveAnchor() : null;\n            const isRotateGesture = typeof activeAnchor === \"string\" && activeAnchor.toLowerCase().includes(\"rotat\");\n            transformGestureRef.current = {\n                isRotate: isRotateGesture,\n                activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null\n            };\n            if (!isRotateGesture) {\n                setIsResizeGestureActive(true);\n            }\n            if (!isRotateGesture && activeAnchor) {\n                setPressedResizeAnchorName((current)=>current === activeAnchor ? current : activeAnchor);\n            }\n            if (typeof onTransformInteractionStart === \"function\") {\n                var _e_evt;\n                var _e_evt_pointerType;\n                onTransformInteractionStart({\n                    isRotate: isRotateGesture,\n                    activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null,\n                    pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n                });\n            }\n            try {\n                var _tr_nodes, _n_attrs, _tr_getClientRect;\n                const nodes = (tr === null || tr === void 0 ? void 0 : (_tr_nodes = tr.nodes) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.call(tr)) || [];\n                circleAnchorRef.current = null;\n                textTransformAnchorRef.current = null;\n                if (nodes.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                    try {\n                        const r0 = nodes[0].getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        circleAnchorRef.current = {\n                            left: r0.x,\n                            top: r0.y\n                        };\n                    } catch (e) {}\n                }\n                if (nodes.length === 1 && esTexto) {\n                    const node = nodes[0];\n                    let centerX = null;\n                    let centerY = null;\n                    let baseWidth = null;\n                    let baseHeight = null;\n                    let baseVisualWidth = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.x) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width)) {\n                            centerX = rect.x + rect.width / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.y) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height)) {\n                            centerY = rect.y + rect.height / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            baseWidth = rect.width;\n                            baseVisualWidth = rect.width;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height) && rect.height > 0) {\n                            baseHeight = rect.height;\n                        }\n                    } catch (e) {}\n                    const safeBaseFontSize = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.fontSize) && primerElemento.fontSize > 0 ? primerElemento.fontSize : 24;\n                    textTransformAnchorRef.current = {\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : 0,\n                        baseRotation: typeof (node === null || node === void 0 ? void 0 : node.rotation) === \"function\" ? node.rotation() || 0 : 0,\n                        centerX,\n                        centerY,\n                        baseWidth,\n                        baseHeight,\n                        baseFontSize: safeBaseFontSize,\n                        lastPreviewFontSize: safeBaseFontSize,\n                        lastPreviewCenterX: centerX,\n                        lastPreviewCenterY: centerY,\n                        lastPreviewVisualWidth: baseVisualWidth,\n                        previewTick: 0\n                    };\n                    var _primerElemento_id;\n                    TXTDBG(\"start\", {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        baseFontSize: safeBaseFontSize,\n                        baseWidth,\n                        baseHeight,\n                        centerX,\n                        centerY,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        nodeScaleX: typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() : null,\n                        nodeScaleY: typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() : null\n                    });\n                }\n                const union = rectFromNodes(nodes);\n                const pad = typeof (tr === null || tr === void 0 ? void 0 : tr.padding) === \"function\" ? tr.padding() : 0;\n                const borderRect = union ? {\n                    x: union.x - pad,\n                    y: union.y - pad,\n                    width: union.width + pad * 2,\n                    height: union.height + pad * 2\n                } : null;\n                const n = nodes[0];\n                const id = n ? typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id : \"âˆ…\";\n                const trRect = tr === null || tr === void 0 ? void 0 : (_tr_getClientRect = tr.getClientRect) === null || _tr_getClientRect === void 0 ? void 0 : _tr_getClientRect.call(tr, {\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                slog(\"[TR] start\", \"id=\".concat(id), \"nodes=\".concat(nodes.length), union ? \"union(w=\".concat(union.width.toFixed(1), \",h=\").concat(union.height.toFixed(1), \")\") : \"union(null)\", borderRect ? \"border(w=\".concat(borderRect.width.toFixed(1), \",h=\").concat(borderRect.height.toFixed(1), \")\") : \"border(null)\", trRect ? \"trRect(w=\".concat(trRect.width.toFixed(1), \",h=\").concat(trRect.height.toFixed(1), \")\") : \"trRect(null)\", \"pad=\".concat(pad));\n            } catch (e) {}\n        },\n        onTransform: (e)=>{\n            if (!onTransform || !transformerRef.current) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            const node = nodes[0]; // âœ… nodo real (single select)\n            if (!node) return;\n            try {\n                var _node_attrs, _node_scaleX, _node_scaleY, _node_x, _node_y;\n                const pose = getTransformPose(node);\n                const transformData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isPreview: true\n                };\n                if (esTexto) {\n                    var _textTransformAnchorRef_current, _textTransformAnchorRef_current1, _textTransformAnchorRef_current2;\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let liveRectWidth = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            liveRectWidth = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    transformData.fontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    if (textTransformAnchorRef.current) {\n                        const tick = Number(textTransformAnchorRef.current.previewTick || 0) + 1;\n                        textTransformAnchorRef.current.previewTick = tick;\n                        textTransformAnchorRef.current.lastPreviewFontSize = transformData.fontSize;\n                        if (Number.isFinite(liveRectWidth) && liveRectWidth > 0) {\n                            textTransformAnchorRef.current.lastPreviewVisualWidth = liveRectWidth;\n                        }\n                        if (tick <= 2 || tick % 5 === 0) {\n                            var _textTransformAnchorRef_current3;\n                            var _primerElemento_id, _textTransformAnchorRef_current_centerX;\n                            TXTDBG(\"preview\", {\n                                id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                                tick,\n                                scaleX,\n                                scaleY,\n                                avgScale,\n                                scaleFromRect,\n                                effectiveScale,\n                                baseFontSize,\n                                fontSize: transformData.fontSize,\n                                liveRectWidth,\n                                centerXTarget: (_textTransformAnchorRef_current_centerX = (_textTransformAnchorRef_current3 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current3 === void 0 ? void 0 : _textTransformAnchorRef_current3.centerX) !== null && _textTransformAnchorRef_current_centerX !== void 0 ? _textTransformAnchorRef_current_centerX : null,\n                                nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                                nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                            });\n                        }\n                    }\n                    transformData.scaleX = 1;\n                    transformData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite((_textTransformAnchorRef_current = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current === void 0 ? void 0 : _textTransformAnchorRef_current.y)) {\n                        transformData.y = textTransformAnchorRef.current.y;\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current1 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current1 === void 0 ? void 0 : _textTransformAnchorRef_current1.centerX)) {\n                        transformData.textCenterX = textTransformAnchorRef.current.centerX;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterX = textTransformAnchorRef.current.centerX;\n                        }\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current2 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current2 === void 0 ? void 0 : _textTransformAnchorRef_current2.centerY)) {\n                        transformData.textCenterY = textTransformAnchorRef.current.centerY;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterY = textTransformAnchorRef.current.centerY;\n                        }\n                    }\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    transformData.scaleX = scaleX;\n                    transformData.scaleY = scaleY;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        const countdownSize = getCountdownScaledSize(node);\n                        transformData.width = countdownSize.width;\n                        transformData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        transformData.radius = Math.max(1, baseRadius * avgScale);\n                    } else {\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        transformData.width = Math.abs(originalWidth * scaleX);\n                        transformData.height = Math.abs(originalHeight * scaleY);\n                    }\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                        try {\n                            const liveRect = node.getClientRect({\n                                skipTransform: false,\n                                skipShadow: true,\n                                skipStroke: true\n                            });\n                            const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                            transformData.radius = diameter / 2;\n                            const anchor = circleAnchorRef.current;\n                            if (anchor) {\n                                transformData.x = anchor.left + transformData.radius;\n                                transformData.y = anchor.top + transformData.radius;\n                            } else {\n                                transformData.x = liveRect.x + transformData.radius;\n                                transformData.y = liveRect.y + transformData.radius;\n                            }\n                        } catch (e) {}\n                    }\n                }\n                onTransform(transformData);\n                // --- LOG COMPACTO (opcional) ---\n                const id = (typeof node.id === \"function\" ? node.id() : (_node_attrs = node.attrs) === null || _node_attrs === void 0 ? void 0 : _node_attrs.id) || \"âˆ…\";\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                const r = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                var _node_x1, _node_y1, _transformData_width, _transformData_height;\n                slog(\"[TR] live\", \"id=\".concat(id), \"tipo=\".concat((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) || \"âˆ…\"), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"x=\".concat(((_node_x1 = (_node_x = node.x) === null || _node_x === void 0 ? void 0 : _node_x.call(node)) !== null && _node_x1 !== void 0 ? _node_x1 : 0).toFixed(1)), \"y=\".concat(((_node_y1 = (_node_y = node.y) === null || _node_y === void 0 ? void 0 : _node_y.call(node)) !== null && _node_y1 !== void 0 ? _node_y1 : 0).toFixed(1)), \"nodeRect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"), \"w=\".concat((_transformData_width = transformData.width) !== null && _transformData_width !== void 0 ? _transformData_width : \"âˆ…\"), \"h=\".concat((_transformData_height = transformData.height) !== null && _transformData_height !== void 0 ? _transformData_height : \"âˆ…\"));\n            } catch (error) {\n                console.warn(\"Error en onTransform:\", error);\n            }\n        },\n        onTransformEnd: (e)=>{\n            var _transformGestureRef_current, _transformGestureRef_current1, _e_evt;\n            var _transformGestureRef_current_activeAnchor, _e_evt_pointerType;\n            const interactionSnapshot = {\n                isRotate: Boolean((_transformGestureRef_current = transformGestureRef.current) === null || _transformGestureRef_current === void 0 ? void 0 : _transformGestureRef_current.isRotate),\n                activeAnchor: (_transformGestureRef_current_activeAnchor = (_transformGestureRef_current1 = transformGestureRef.current) === null || _transformGestureRef_current1 === void 0 ? void 0 : _transformGestureRef_current1.activeAnchor) !== null && _transformGestureRef_current_activeAnchor !== void 0 ? _transformGestureRef_current_activeAnchor : null,\n                pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n            };\n            const notifyTransformInteractionEnd = ()=>{\n                if (typeof onTransformInteractionEnd === \"function\") {\n                    onTransformInteractionEnd(interactionSnapshot);\n                }\n                transformGestureRef.current = {\n                    isRotate: false,\n                    activeAnchor: null\n                };\n            };\n            try {\n                if (!transformerRef.current || !onTransform) return;\n                const tr = transformerRef.current;\n                const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n                // -------------------------\n                // MULTI-SELECCIÃ“N\n                // -------------------------\n                if (nodes.length > 1) {\n                    try {\n                        var _tr_getLayer;\n                        const tScaleX = typeof tr.scaleX === \"function\" ? tr.scaleX() || 1 : 1;\n                        const tScaleY = typeof tr.scaleY === \"function\" ? tr.scaleY() || 1 : 1;\n                        const avg = (Math.abs(tScaleX) + Math.abs(tScaleY)) / 2;\n                        const updates = nodes.map((n)=>{\n                            let id = null;\n                            try {\n                                var _n_attrs;\n                                id = (typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id) || null;\n                            } catch (e) {}\n                            if (!id) return null;\n                            const obj = (objetos || []).find((o)=>o.id === id);\n                            if (!obj) return null;\n                            const upd = {\n                                id,\n                                x: typeof n.x === \"function\" ? n.x() : obj.x,\n                                y: typeof n.y === \"function\" ? n.y() : obj.y,\n                                rotation: typeof n.rotation === \"function\" ? n.rotation() || 0 : obj.rotation || 0\n                            };\n                            if (obj.tipo === \"texto\") {\n                                const base = obj.fontSize || 24;\n                                upd.fontSize = Math.max(6, Math.round(base * avg));\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"forma\" && obj.figura === \"circle\") {\n                                const baseR = obj.radius || 50;\n                                upd.radius = baseR * avg;\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"forma\" && obj.figura === \"triangle\") {\n                                const baseR = obj.radius || 60;\n                                upd.radius = Math.max(1, baseR * avg);\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"countdown\") {\n                                const countdownSize = getCountdownScaledSize(n);\n                                upd.width = countdownSize.width;\n                                upd.height = countdownSize.height;\n                                return upd;\n                            }\n                            const baseW = obj.width != null ? obj.width : typeof n.width === \"function\" ? n.width() : 100;\n                            const baseH = obj.height != null ? obj.height : typeof n.height === \"function\" ? n.height() : 100;\n                            upd.width = Math.abs(baseW * tScaleX);\n                            upd.height = Math.abs(baseH * tScaleY);\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }).filter(Boolean);\n                        onTransform({\n                            isFinal: true,\n                            batch: updates\n                        });\n                        if (typeof tr.scaleX === \"function\") {\n                            tr.scaleX(1);\n                            tr.scaleY(1);\n                        }\n                        (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n                        window._resizeData = {\n                            isResizing: false\n                        };\n                        setTimeout(()=>{\n                            window._resizeData = null;\n                        }, 100);\n                        return;\n                    } catch (err) {\n                        console.warn(\"Error en onTransformEnd (multi):\", err);\n                        window._resizeData = null;\n                        return;\n                    }\n                }\n                // -------------------------\n                // SINGLE-SELECCIÃ“N\n                // -------------------------\n                const node = nodes[0];\n                if (!node) return;\n                const pose = getTransformPose(node);\n                const finalData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isFinal: true\n                };\n                let textPreviewEndSnapshot = null;\n                if (esTexto) {\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let visualWidthFromRect = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            visualWidthFromRect = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    const computedFontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    finalData.fontSize = Math.max(6, Number(Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewFontSize) && anchorData.lastPreviewFontSize > 0 ? anchorData.lastPreviewFontSize : computedFontSize));\n                    finalData.scaleX = 1;\n                    finalData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.y)) {\n                        finalData.y = anchorData.y;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterX)) {\n                        finalData.textCenterX = anchorData.lastPreviewCenterX;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerX)) {\n                        finalData.textCenterX = anchorData.centerX;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterY)) {\n                        finalData.textCenterY = anchorData.lastPreviewCenterY;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerY)) {\n                        finalData.textCenterY = anchorData.centerY;\n                    }\n                    const visualWidth = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewVisualWidth) && anchorData.lastPreviewVisualWidth > 0 ? anchorData.lastPreviewVisualWidth : visualWidthFromRect;\n                    if (Number.isFinite(visualWidth) && visualWidth > 0) {\n                        finalData.textVisualWidth = visualWidth;\n                    }\n                    var _primerElemento_id;\n                    textPreviewEndSnapshot = {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        x: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        scaleX,\n                        scaleY,\n                        fontSize: typeof (node === null || node === void 0 ? void 0 : node.fontSize) === \"function\" ? node.fontSize() : null,\n                        rectWidth: Number.isFinite(visualWidthFromRect) ? visualWidthFromRect : null,\n                        rectHeight: null\n                    };\n                    try {\n                        const rectForSnapshot = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rectForSnapshot === null || rectForSnapshot === void 0 ? void 0 : rectForSnapshot.height)) {\n                            textPreviewEndSnapshot.rectHeight = rectForSnapshot.height;\n                        }\n                    } catch (e) {}\n                    var _primerElemento_id1, _finalData_textCenterX, _finalData_textCenterY, _finalData_textVisualWidth;\n                    TXTDBG(\"end\", {\n                        id: (_primerElemento_id1 = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id1 !== void 0 ? _primerElemento_id1 : null,\n                        scaleX,\n                        scaleY,\n                        avgScale,\n                        scaleFromRect,\n                        effectiveScale,\n                        computedFontSize,\n                        finalFontSize: finalData.fontSize,\n                        textCenterX: (_finalData_textCenterX = finalData.textCenterX) !== null && _finalData_textCenterX !== void 0 ? _finalData_textCenterX : null,\n                        textCenterY: (_finalData_textCenterY = finalData.textCenterY) !== null && _finalData_textCenterY !== void 0 ? _finalData_textCenterY : null,\n                        textVisualWidth: (_finalData_textVisualWidth = finalData.textVisualWidth) !== null && _finalData_textVisualWidth !== void 0 ? _finalData_textVisualWidth : null,\n                        nodeRectWidth: visualWidthFromRect,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                    });\n                    // Aplanar escala del texto en el release para evitar doble escalado\n                    // (escala del nodo + fontSize persistido).\n                    try {\n                        var _node_getLayer;\n                        if (typeof node.scaleX === \"function\") node.scaleX(1);\n                        if (typeof node.scaleY === \"function\") node.scaleY(1);\n                        if (Number.isFinite(finalData.fontSize) && typeof node.fontSize === \"function\") {\n                            node.fontSize(finalData.fontSize);\n                        }\n                        const targetCenterX = Number(finalData.textCenterX);\n                        const targetCenterY = Number(finalData.textCenterY);\n                        if ((Number.isFinite(targetCenterX) || Number.isFinite(targetCenterY)) && typeof node.x === \"function\" && typeof node.y === \"function\") {\n                            try {\n                                const flattenedRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const flattenedCenterX = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.x) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.width) ? flattenedRect.x + flattenedRect.width / 2 : null;\n                                const flattenedCenterY = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.y) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.height) ? flattenedRect.y + flattenedRect.height / 2 : null;\n                                if (Number.isFinite(flattenedCenterX) && Number.isFinite(targetCenterX)) {\n                                    node.x(node.x() + (targetCenterX - flattenedCenterX));\n                                }\n                                if (Number.isFinite(flattenedCenterY) && Number.isFinite(targetCenterY)) {\n                                    node.y(node.y() + (targetCenterY - flattenedCenterY));\n                                }\n                            } catch (e) {}\n                        }\n                        (_node_getLayer = node.getLayer()) === null || _node_getLayer === void 0 ? void 0 : _node_getLayer.batchDraw();\n                    } catch (err) {\n                        console.warn(\"Error aplanando escala de texto (sync):\", err);\n                    }\n                    if (!canUseRectScale) {\n                        if (typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\") {\n                            finalData.x = node.x();\n                        }\n                        if (typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\") {\n                            finalData.y = node.y();\n                        }\n                    }\n                    // Para texto evitamos aplanar antes del commit en React,\n                    // asÃ­ no aparece un frame intermedio con tamaÃ±o \"saltado\".\n                    textTransformAnchorRef.current = null;\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        // Countdown: persistir escala real para que el resultado final\n                        // sea exactamente el mismo que se ve al soltar.\n                        finalData.scaleX = scaleX;\n                        finalData.scaleY = scaleY;\n                        const countdownSize = getCountdownScaledSize(node);\n                        finalData.width = countdownSize.width;\n                        finalData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        finalData.radius = Math.max(1, baseRadius * avgScale);\n                        try {\n                            var _node_getLayer1;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (typeof node.radius === \"function\") node.radius(finalData.radius);\n                            (_node_getLayer1 = node.getLayer()) === null || _node_getLayer1 === void 0 ? void 0 : _node_getLayer1.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escala de triÃ¡ngulo (sync):\", err);\n                        }\n                    } else {\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        finalData.width = Math.abs(originalWidth * scaleX);\n                        finalData.height = Math.abs(originalHeight * scaleY);\n                        if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                            try {\n                                const liveRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                                finalData.radius = diameter / 2;\n                                const anchor = circleAnchorRef.current;\n                                if (anchor) {\n                                    finalData.x = anchor.left + finalData.radius;\n                                    finalData.y = anchor.top + finalData.radius;\n                                } else {\n                                    finalData.x = liveRect.x + finalData.radius;\n                                    finalData.y = liveRect.y + finalData.radius;\n                                }\n                            } catch (e) {}\n                        }\n                        // âœ… Aplanar escala INMEDIATO\n                        try {\n                            var _node_getLayer2;\n                            const fw = finalData.width;\n                            const fh = finalData.height;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (fw != null && typeof node.width === \"function\") node.width(fw);\n                            if (fh != null && typeof node.height === \"function\") node.height(fh);\n                            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\" && finalData.radius != null && typeof node.radius === \"function\") {\n                                node.radius(finalData.radius);\n                            }\n                            (_node_getLayer2 = node.getLayer()) === null || _node_getLayer2 === void 0 ? void 0 : _node_getLayer2.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escalas (sync):\", err);\n                        }\n                    }\n                }\n                onTransform(finalData);\n                circleAnchorRef.current = null;\n                // âœ… Reatachar 1 vez, con ref fresco, en el prÃ³ximo frame\n                try {\n                    const tr2 = transformerRef.current;\n                    if (!tr2) return;\n                    TRDBG(\"onTransformEnd -> schedule RAF reattach\", {\n                        selKey: selectedElements.join(\",\"),\n                        idSel: (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0]) || null\n                    });\n                    requestAnimationFrame(()=>{\n                        var _elementRefs_current, _freshNode_getStage, _freshNode_getStage1;\n                        const idSel = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n                        const freshNode = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                        TRDBG(\"onTransformEnd RAF\", {\n                            idSel,\n                            hasFresh: !!freshNode,\n                            destroyed: !!(freshNode === null || freshNode === void 0 ? void 0 : freshNode._destroyed),\n                            hasStage: !!(freshNode === null || freshNode === void 0 ? void 0 : (_freshNode_getStage = freshNode.getStage) === null || _freshNode_getStage === void 0 ? void 0 : _freshNode_getStage.call(freshNode))\n                        });\n                        // Si el nodo no estÃ¡ listo, despegar y salir\n                        if (!freshNode || freshNode._destroyed || !((_freshNode_getStage1 = freshNode.getStage) === null || _freshNode_getStage1 === void 0 ? void 0 : _freshNode_getStage1.call(freshNode))) {\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            try {\n                                var _tr2_getLayer, _tr2_getLayer1;\n                                tr2.nodes([]);\n                                (_tr2_getLayer1 = tr2.getLayer) === null || _tr2_getLayer1 === void 0 ? void 0 : (_tr2_getLayer = _tr2_getLayer1.call(tr2)) === null || _tr2_getLayer === void 0 ? void 0 : _tr2_getLayer.batchDraw();\n                            } catch (e) {}\n                            return;\n                        }\n                        try {\n                            var _tr2_getLayer2, _tr2_getLayer3;\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            tr2.nodes([\n                                freshNode\n                            ]);\n                            tr2.forceUpdate();\n                            (_tr2_getLayer3 = tr2.getLayer) === null || _tr2_getLayer3 === void 0 ? void 0 : (_tr2_getLayer2 = _tr2_getLayer3.call(tr2)) === null || _tr2_getLayer2 === void 0 ? void 0 : _tr2_getLayer2.batchDraw();\n                            if (textPreviewEndSnapshot && freshNode) {\n                                try {\n                                    const postRect = freshNode.getClientRect({\n                                        skipTransform: false,\n                                        skipShadow: true,\n                                        skipStroke: true\n                                    });\n                                    TXTDBG(\"post-commit:raf1\", {\n                                        id: idSel,\n                                        pre: textPreviewEndSnapshot,\n                                        post: {\n                                            x: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.x) === \"function\" ? freshNode.x() : null,\n                                            y: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.y) === \"function\" ? freshNode.y() : null,\n                                            scaleX: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleX) === \"function\" ? freshNode.scaleX() : null,\n                                            scaleY: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleY) === \"function\" ? freshNode.scaleY() : null,\n                                            fontSize: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.fontSize) === \"function\" ? freshNode.fontSize() : null,\n                                            rectWidth: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) ? postRect.width : null,\n                                            rectHeight: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) ? postRect.height : null\n                                        },\n                                        delta: {\n                                            width: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect.width - textPreviewEndSnapshot.rectWidth : null,\n                                            height: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect.height - textPreviewEndSnapshot.rectHeight : null\n                                        }\n                                    });\n                                } catch (e) {}\n                                requestAnimationFrame(()=>{\n                                    var _elementRefs_current;\n                                    const freshNode2 = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                                    if (!freshNode2) return;\n                                    try {\n                                        const postRect2 = freshNode2.getClientRect({\n                                            skipTransform: false,\n                                            skipShadow: true,\n                                            skipStroke: true\n                                        });\n                                        TXTDBG(\"post-commit:raf2\", {\n                                            id: idSel,\n                                            post: {\n                                                x: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.x) === \"function\" ? freshNode2.x() : null,\n                                                y: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.y) === \"function\" ? freshNode2.y() : null,\n                                                scaleX: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleX) === \"function\" ? freshNode2.scaleX() : null,\n                                                scaleY: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleY) === \"function\" ? freshNode2.scaleY() : null,\n                                                fontSize: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.fontSize) === \"function\" ? freshNode2.fontSize() : null,\n                                                rectWidth: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) ? postRect2.width : null,\n                                                rectHeight: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) ? postRect2.height : null\n                                            },\n                                            deltaFromPre: {\n                                                width: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect2.width - textPreviewEndSnapshot.rectWidth : null,\n                                                height: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect2.height - textPreviewEndSnapshot.rectHeight : null\n                                            }\n                                        });\n                                    } catch (e) {}\n                                });\n                            }\n                        } catch (e) {}\n                    });\n                } catch (e) {}\n            } catch (error) {\n                console.warn(\"Error en onTransformEnd:\", error);\n                window._resizeData = null;\n            } finally{\n                isTransformingResizeRef.current = false;\n                setIsResizeGestureActive(false);\n                clearResizeAnchorPressFeedback();\n                notifyTransformInteractionEnd();\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 611,\n        columnNumber: 5\n    }, this);\n}\n_s1(SelectionBounds, \"IMqo/S4ZLseQxerUTPZnWjua6f8=\");\n_c3 = SelectionBounds;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"TRDBG\");\n$RefreshReg$(_c1, \"TXTDBG\");\n$RefreshReg$(_c2, \"BoundsIndicator\");\n$RefreshReg$(_c3, \"SelectionBounds\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NlbGVjdGlvbkJvdW5kcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsc0JBQXNCOzs7QUFDOEI7QUFDSjtBQUloRCxNQUFNSyx5QkFBeUI7QUFFL0IsTUFBTUMsUUFBUTtxQ0FBSUM7UUFBQUE7O0lBQ2hCLElBQUksQ0FBQ0Ysd0JBQXdCO0lBQzdCRyxRQUFRQyxHQUFHLENBQUMsV0FBV0Y7QUFDekI7QUFDQSxNQUFNRyxPQUFPSjtBQUViLE1BQU1LLFFBQVE7cUNBQUlKO1FBQUFBOztJQUNoQixJQUFJLENBQUNLLE9BQU9DLFFBQVEsRUFBRTtJQUN0QkwsUUFBUUMsR0FBRyxDQUFDLGNBQWNGO0FBQzVCO0tBSE1JO0FBS04sTUFBTUcsU0FBUztxQ0FBSVA7UUFBQUE7O0lBQ2pCLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBQzFDLElBQUksQ0FBQ0ssT0FBT0csaUJBQWlCLEVBQUU7SUFDL0JQLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JGO0FBQzlCO01BSk1PO0FBT04sU0FBU0UsY0FBY0MsS0FBSztJQUMxQixJQUFJQyxPQUFPQyxVQUFVQyxPQUFPRCxVQUFVRSxPQUFPLENBQUNGLFVBQVVHLE9BQU8sQ0FBQ0g7SUFFaEUsS0FBSyxNQUFNSSxLQUFLTixNQUFPO1FBQ3JCLElBQUksRUFBQ00sY0FBQUEsd0JBQUFBLEVBQUdDLGFBQWEsR0FBRTtRQUN2QixNQUFNQyxJQUFJRixFQUFFQyxhQUFhLENBQUM7WUFBRUUsZUFBZTtZQUFPQyxZQUFZO1lBQU1DLFlBQVk7UUFBSztRQUNyRlYsT0FBT1csS0FBS0MsR0FBRyxDQUFDWixNQUFNTyxFQUFFTSxDQUFDO1FBQ3pCWCxPQUFPUyxLQUFLQyxHQUFHLENBQUNWLE1BQU1LLEVBQUVPLENBQUM7UUFDekJYLE9BQU9RLEtBQUtJLEdBQUcsQ0FBQ1osTUFBTUksRUFBRU0sQ0FBQyxHQUFHTixFQUFFUyxLQUFLO1FBQ25DWixPQUFPTyxLQUFLSSxH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T0MsUUFBUSxDQUFDd1Ysc0JBQUFBLGdDQUFBQSxVQUFXdlcsS0FBSyxLQUNoQ2MsT0FBT0MsUUFBUSxDQUFDNFQsdUJBQXVCSyxTQUFTLElBQzNDdUIsVUFBVXZXLEtBQUssR0FBRzJVLHVCQUF1QkssU0FBUyxHQUNuRDtnREFDTi9VLFFBQ0VhLE9BQU9DLFFBQVEsQ0FBQ3dWLHNCQUFBQSxnQ0FBQUEsVUFBV3RXLE1BQU0sS0FDakNhLE9BQU9DLFFBQVEsQ0FBQzRULHVCQUF1Qk0sVUFBVSxJQUM1Q3NCLFVBQVV0VyxNQUFNLEdBQUcwVSx1QkFBdUJNLFVBQVUsR0FDckQ7NENBQ1I7d0NBQ0Y7b0NBQ0YsRUFBRSxVQUFNLENBQUM7Z0NBQ1g7NEJBQ0Y7d0JBQ0YsRUFBRSxVQUFNLENBQUU7b0JBQ1o7Z0JBQ0YsRUFBRSxVQUFNLENBQUU7WUFHWixFQUFFLE9BQU96UixPQUFPO2dCQUNkbEYsUUFBUW9WLElBQUksQ0FBQyw0QkFBNEJsUTtnQkFDekM5RSxPQUFPb1AsV0FBVyxHQUFHO1lBQ3ZCLFNBQVU7Z0JBQ1J2SSx3QkFBd0JoRSxPQUFPLEdBQUc7Z0JBQ2xDa0UseUJBQXlCO2dCQUN6QjZDO2dCQUNBdUw7WUFDRjtRQUNGOzs7Ozs7QUFJTjtJQTU2Q3dCclA7TUFBQUEiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXHNyY1xcY29tcG9uZW50c1xcU2VsZWN0aW9uQm91bmRzLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZWxlY3Rpb25Cb3VuZHMuanN4XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBUcmFuc2Zvcm1lciwgUmVjdCB9IGZyb20gXCJyZWFjdC1rb252YVwiO1xyXG5cclxuXHJcblxyXG5jb25zdCBERUJVR19TRUxFQ1RJT05fQk9VTkRTID0gZmFsc2U7XHJcblxyXG5jb25zdCBzYkxvZyA9ICguLi5hcmdzKSA9PiB7XHJcbiAgaWYgKCFERUJVR19TRUxFQ1RJT05fQk9VTkRTKSByZXR1cm47XHJcbiAgY29uc29sZS5sb2coXCJbU0JdXCIsIC4uLmFyZ3MpO1xyXG59O1xyXG5jb25zdCBzbG9nID0gc2JMb2c7XHJcblxyXG5jb25zdCBUUkRCRyA9ICguLi5hcmdzKSA9PiB7XHJcbiAgaWYgKCF3aW5kb3cuX19EQkdfVFIpIHJldHVybjtcclxuICBjb25zb2xlLmxvZyhcIltUUkRCR11cIiwgLi4uYXJncyk7XHJcbn07XHJcblxyXG5jb25zdCBUWFREQkcgPSAoLi4uYXJncykgPT4ge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XHJcbiAgaWYgKCF3aW5kb3cuX19EQkdfVEVYVF9SRVNJWkUpIHJldHVybjtcclxuICBjb25zb2xlLmxvZyhcIltURVhULVRSXVwiLCAuLi5hcmdzKTtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiByZWN0RnJvbU5vZGVzKG5vZGVzKSB7XHJcbiAgbGV0IG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXMpIHtcclxuICAgIGlmICghbj8uZ2V0Q2xpZW50UmVjdCkgY29udGludWU7XHJcbiAgICBjb25zdCByID0gbi5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XHJcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgci54KTtcclxuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCByLnkpO1xyXG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHIueCArIHIud2lkdGgpO1xyXG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHIueSArIHIuaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIGlmIChtaW5YID09PSBJbmZpbml0eSkgcmV0dXJuIG51bGw7XHJcbiAgcmV0dXJuIHsgeDogbWluWCwgeTogbWluWSwgd2lkdGg6IG1heFggLSBtaW5YLCBoZWlnaHQ6IG1heFkgLSBtaW5ZIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvdW50ZG93blNjYWxlZFNpemUobm9kZSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBoaXRib3ggPSBub2RlPy5maW5kT25lPy4oXCIuY291bnRkb3duLWhpdGJveFwiKTtcclxuICAgIGNvbnN0IGJhc2VXID0gdHlwZW9mIGhpdGJveD8ud2lkdGggPT09IFwiZnVuY3Rpb25cIiA/IGhpdGJveC53aWR0aCgpIDogTmFOO1xyXG4gICAgY29uc3QgYmFzZUggPSB0eXBlb2YgaGl0Ym94Py5oZWlnaHQgPT09IFwiZnVuY3Rpb25cIiA/IGhpdGJveC5oZWlnaHQoKSA6IE5hTjtcclxuICAgIGNvbnN0IHN4ID0gTWF0aC5hYnModHlwZW9mIG5vZGU/LnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUuc2NhbGVYKCkgfHwgMSkgOiAxKTtcclxuICAgIGNvbnN0IHN5ID0gTWF0aC5hYnModHlwZW9mIG5vZGU/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUuc2NhbGVZKCkgfHwgMSkgOiAxKTtcclxuXHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGJhc2VXKSAmJiBOdW1iZXIuaXNGaW5pdGUoYmFzZUgpICYmIGJhc2VXID4gMCAmJiBiYXNlSCA+IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogTWF0aC5hYnMoYmFzZVcgKiBzeCksXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhiYXNlSCAqIHN5KSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9IGNhdGNoIHt9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByID0gbm9kZS5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XHJcbiAgICByZXR1cm4geyB3aWR0aDogTWF0aC5hYnMoci53aWR0aCksIGhlaWdodDogTWF0aC5hYnMoci5oZWlnaHQpIH07XHJcbiAgfSBjYXRjaCB7fVxyXG5cclxuICByZXR1cm4geyB3aWR0aDogMTAwLCBoZWlnaHQ6IDUwIH07XHJcbn1cclxuXHJcblxyXG4vLyDwn46oIENvbXBvbmVudGUgcGFyYSBtb3N0cmFyIGJvdW5kcyBzaW4gdHJhbnNmb3JtZXIgKGzDrW5lYXMsIGV0Yy4pXHJcbmNvbnN0IEJvdW5kc0luZGljYXRvciA9ICh7IHNlbGVjdGVkRWxlbWVudHMsIGVsZW1lbnRSZWZzLCBvYmpldG9zIH0pID0+IHtcclxuICBjb25zdCBbZm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgZmlyc3RSZWYgPSBlbGVtZW50UmVmcy5jdXJyZW50Py5bc2VsZWN0ZWRFbGVtZW50c1swXV07XHJcbiAgICBjb25zdCBzdGFnZSA9IGZpcnN0UmVmPy5nZXRTdGFnZT8uKCk7XHJcbiAgICBpZiAoIXN0YWdlKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRHJhZ01vdmUgPSAoKSA9PiB7XHJcbiAgICAgIHNldEZvcmNlVXBkYXRlKChwKSA9PiBwICsgMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHN0YWdlLm9uKFwiZHJhZ21vdmVcIiwgaGFuZGxlRHJhZ01vdmUpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ21vdmVcIiwgaGFuZGxlRHJhZ01vdmUpO1xyXG4gICAgfTtcclxuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKV0pO1xyXG5cclxuICBjb25zdCBlbGVtZW50b3NEYXRhID0gc2VsZWN0ZWRFbGVtZW50c1xyXG4gICAgLm1hcCgoaWQpID0+IG9iamV0b3MuZmluZCgob2JqKSA9PiBvYmouaWQgPT09IGlkKSlcclxuICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcblxyXG4gIGlmIChlbGVtZW50b3NEYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBsZXQgbWluWCA9IEluZmluaXR5LFxyXG4gICAgbWluWSA9IEluZmluaXR5LFxyXG4gICAgbWF4WCA9IC1JbmZpbml0eSxcclxuICAgIG1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gIGVsZW1lbnRvc0RhdGEuZm9yRWFjaCgob2JqKSA9PiB7XHJcbiAgICBjb25zdCBub2RlID0gZWxlbWVudFJlZnMuY3VycmVudFtvYmouaWRdO1xyXG4gICAgaWYgKCFub2RlKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJsaW5lXCIpIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBvYmoucG9pbnRzIHx8IFswLCAwLCAxMDAsIDBdO1xyXG5cclxuICAgICAgICBjb25zdCBjbGVhblBvaW50cyA9IFtcclxuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzBdKSB8fCAwLFxyXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbMV0pIHx8IDAsXHJcbiAgICAgICAgICBwYXJzZUZsb2F0KHBvaW50c1syXSkgfHwgMTAwLFxyXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbM10pIHx8IDAsXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVhbFggPSBub2RlLngoKTtcclxuICAgICAgICBjb25zdCByZWFsWSA9IG5vZGUueSgpO1xyXG5cclxuICAgICAgICBjb25zdCB4MSA9IHJlYWxYICsgY2xlYW5Qb2ludHNbMF07XHJcbiAgICAgICAgY29uc3QgeTEgPSByZWFsWSArIGNsZWFuUG9pbnRzWzFdO1xyXG4gICAgICAgIGNvbnN0IHgyID0gcmVhbFggKyBjbGVhblBvaW50c1syXTtcclxuICAgICAgICBjb25zdCB5MiA9IHJlYWxZICsgY2xlYW5Qb2ludHNbM107XHJcblxyXG4gICAgICAgIGNvbnN0IGxpbmVQYWRkaW5nID0gNTtcclxuXHJcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgxIC0gbGluZVBhZGRpbmcsIHgyIC0gbGluZVBhZGRpbmcpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5MSAtIGxpbmVQYWRkaW5nLCB5MiAtIGxpbmVQYWRkaW5nKTtcclxuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeDEgKyBsaW5lUGFkZGluZywgeDIgKyBsaW5lUGFkZGluZyk7XHJcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkxICsgbGluZVBhZGRpbmcsIHkyICsgbGluZVBhZGRpbmcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGJveCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xyXG4gICAgICAgIGNvbnN0IHIgPSBib3g7XHJcbiAgICAgICAgY29uc3Qgc3ggPSAobm9kZT8uc2NhbGVYPy4oKSA/PyAxKTtcclxuICAgICAgICBjb25zdCBzeSA9IChub2RlPy5zY2FsZVk/LigpID8/IDEpO1xyXG4gICAgICAgIHNsb2coXHJcbiAgICAgICAgICBcIltCSV1cIixcclxuICAgICAgICAgIGBpZD0ke29iai5pZH1gLFxyXG4gICAgICAgICAgYHRpcG89JHtvYmoudGlwb31gLFxyXG4gICAgICAgICAgYHN4PSR7c3gudG9GaXhlZCgzKX1gLFxyXG4gICAgICAgICAgYHN5PSR7c3kudG9GaXhlZCgzKX1gLFxyXG4gICAgICAgICAgYHJlY3Qodz0ke3Iud2lkdGgudG9GaXhlZCgxKX0saD0ke3IuaGVpZ2h0LnRvRml4ZWQoMSl9KWBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCByZWFsWCA9IGJveC54O1xyXG4gICAgICAgIGNvbnN0IHJlYWxZID0gYm94Lnk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gYm94LndpZHRoO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSBib3guaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwidGV4dG9cIiAmJiBub2RlLmdldFRleHRIZWlnaHQpIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSBub2RlLmdldFRleHRIZWlnaHQoKTtcclxuICAgICAgICAgIGlmICh0ZXh0SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHRleHRIZWlnaHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcmVhbFgpO1xyXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCByZWFsWSk7XHJcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHJlYWxYICsgd2lkdGgpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCByZWFsWSArIGhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnN0IGZhbGxiYWNrWCA9IG9iai54IHx8IDA7XHJcbiAgICAgIGNvbnN0IGZhbGxiYWNrWSA9IG9iai55IHx8IDA7XHJcbiAgICAgIGNvbnN0IGZhbGxiYWNrU2l6ZSA9IDIwO1xyXG5cclxuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIGZhbGxiYWNrWCk7XHJcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBmYWxsYmFja1kpO1xyXG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgZmFsbGJhY2tYICsgZmFsbGJhY2tTaXplKTtcclxuICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIGZhbGxiYWNrWSArIGZhbGxiYWNrU2l6ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChtaW5YID09PSBJbmZpbml0eSB8fCBtYXhYID09PSAtSW5maW5pdHkpIHtcclxuICAgIGNvbnN0IHByaW1lckVsZW1lbnRvID0gZWxlbWVudG9zRGF0YVswXTtcclxuICAgIGlmICghcHJpbWVyRWxlbWVudG8pIHJldHVybiBudWxsO1xyXG4gICAgbWluWCA9IHByaW1lckVsZW1lbnRvLnggfHwgMDtcclxuICAgIG1pblkgPSBwcmltZXJFbGVtZW50by55IHx8IDA7XHJcbiAgICBtYXhYID0gbWluWCArIDEwMDtcclxuICAgIG1heFkgPSBtaW5ZICsgNTA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwYWRkaW5nID0gMTA7XHJcbiAgY29uc3QgZmluYWxYID0gbWluWCAtIHBhZGRpbmc7XHJcbiAgY29uc3QgZmluYWxZID0gbWluWSAtIHBhZGRpbmc7XHJcbiAgY29uc3QgZmluYWxXaWR0aCA9IG1heFggLSBtaW5YICsgcGFkZGluZyAqIDI7XHJcbiAgY29uc3QgZmluYWxIZWlnaHQgPSBtYXhZIC0gbWluWSArIHBhZGRpbmcgKiAyO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFJlY3RcclxuICAgICAgbmFtZT1cInVpXCJcclxuICAgICAgeD17ZmluYWxYfVxyXG4gICAgICB5PXtmaW5hbFl9XHJcbiAgICAgIHdpZHRoPXtmaW5hbFdpZHRofVxyXG4gICAgICBoZWlnaHQ9e2ZpbmFsSGVpZ2h0fVxyXG4gICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxyXG4gICAgICBzdHJva2U9XCIjOTMzM0VBXCJcclxuICAgICAgc3Ryb2tlV2lkdGg9ezF9XHJcbiAgICAgIGxpc3RlbmluZz17ZmFsc2V9XHJcbiAgICAgIG9wYWNpdHk9ezAuN31cclxuICAgIC8+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbGVjdGlvbkJvdW5kcyh7XHJcbiAgc2VsZWN0ZWRFbGVtZW50cyxcclxuICBlbGVtZW50UmVmcyxcclxuICBvYmpldG9zLFxyXG4gIG9uVHJhbnNmb3JtLFxyXG4gIG9uVHJhbnNmb3JtSW50ZXJhY3Rpb25TdGFydCA9IG51bGwsXHJcbiAgb25UcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCA9IG51bGwsXHJcbiAgaXNEcmFnZ2luZyxcclxuICBpc01vYmlsZSA9IGZhbHNlLFxyXG59KSB7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3QgW3RyYW5zZm9ybVRpY2ssIHNldFRyYW5zZm9ybVRpY2tdID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3QgbGFzdE5vZGVzUmVmID0gdXNlUmVmKFtdKTtcclxuICBjb25zdCBjaXJjbGVBbmNob3JSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3QgdGV4dFRyYW5zZm9ybUFuY2hvclJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCB0cmFuc2Zvcm1HZXN0dXJlUmVmID0gdXNlUmVmKHtcclxuICAgIGlzUm90YXRlOiBmYWxzZSxcclxuICAgIGFjdGl2ZUFuY2hvcjogbnVsbCxcclxuICB9KTtcclxuICBjb25zdCBpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZiA9IHVzZVJlZihmYWxzZSk7XHJcbiAgY29uc3QgW2lzUmVzaXplR2VzdHVyZUFjdGl2ZSwgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbcHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUsIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gIGNvbnN0IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhID0gc2VsZWN0ZWRFbGVtZW50c1xyXG4gICAgLm1hcCgoaWQpID0+IG9iamV0b3MuZmluZCgob2JqKSA9PiBvYmouaWQgPT09IGlkKSlcclxuICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcblxyXG4gIGNvbnN0IHByaW1lckVsZW1lbnRvID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGFbMF0gfHwgbnVsbDtcclxuICBjb25zdCBlc1RleHRvID0gcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwidGV4dG9cIjtcclxuICBjb25zdCBlc0NvdW50ZG93biA9IHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImNvdW50ZG93blwiO1xyXG4gIGNvbnN0IGVzR2FsZXJpYSA9IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImdhbGVyaWFcIjtcclxuICBjb25zdCBsb2NrQXNwZWN0Q291bnRkb3duID0gc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZXNDb3VudGRvd247XHJcbiAgY29uc3QgbG9ja0FzcGVjdFRleHQgPSBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBlc1RleHRvO1xyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU2l6ZSA9IGlzTW9iaWxlID8gMzIgOiAxNDsgLy90YW1hw7FvIHZpc3VhbCBkZWwgbm9kbyAobcOhcyBncmFuZGUgZW4gbW9iaWxlKS5cclxuICBjb25zdCB0cmFuc2Zvcm1lclJvdGF0ZU9mZnNldCA9IGlzTW9iaWxlID8gMzQgOiAyNDsgLy8gZGlzdGFuY2lhIGRlbCBoYW5kbGUgZGUgcm90YWNpw7NuIGFsIGJvcmRlLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUmFkaXVzID0gOTk5OyAvL3JhZGlvIGRlIGVzcXVpbmEgZGVsIG5vZG8gKDk5OSBsbyBoYWNlIGNpcmN1bGFyKS5cclxuICBjb25zdCB0cmFuc2Zvcm1lclBhZGRpbmcgPSBpc01vYmlsZSA/IDE0IDogNDsgLy8gZXNwYWNpbyBleHRyYSBlbnRyZSBib3JkZSBkZWwgdHJhbnNmb3JtZXIgeSBlbGVtZW50by5cclxuICBjb25zdCB0cmFuc2Zvcm1lckJvcmRlclN0cm9rZVdpZHRoID0gaXNNb2JpbGUgPyAxLjUgOiAxOyAvL2dyb3NvciBkZWwgYm9yZGUgZGVsIHRyYW5zZm9ybWVyLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yRmlsbENvbG9yID0gXCIjOTMzM0VBXCI7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlV2lkdGggPSBpc01vYmlsZSA/IDEuNCA6IDIuNTsgLy9ncm9zb3IgZGVsIGJvcmRlIGRlbCBub2RvLlxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclNoYWRvd0JsdXIgPSBpc01vYmlsZSA/IDkgOiA2OyAvLyBxdcOpIHRhbiBkaWZ1c2EgZXMgbGEgc29tYnJhIGJhc2UgZGVsIG5vZG8uXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dPZmZzZXRZID0gaXNNb2JpbGUgPyA0IDogMzsgLy8gZGVzcGxhemFtaWVudG8gdmVydGljYWwgZGUgZXNhIHNvbWJyYS5cclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvckhpdFN0cm9rZVdpZHRoID0gaXNNb2JpbGUgPyA2MiA6IDIwO1xyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhpdFN0cm9rZVdpZHRoID0gaXNNb2JpbGUgPyA5NiA6IDI0O1xyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlQ29sb3IgPSBcIiNmZmZmZmZcIjtcclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIYWxvU3Ryb2tlQ29sb3IgPSBpc01vYmlsZVxuICAgID8gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTUpXCJcbiAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlQ29sb3I7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhhbG9TdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gMi4yIDogMy4yO1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclNoYWRvd0NvbG9yID0gXCJyZ2JhKDE0NywgNTEsIDIzNCwgMC4zKVwiO1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dDb2xvciA9IGlzTW9iaWxlXG4gICAgPyBcInJnYmEoMTk4LCAxMjAsIDI1NSwgMSlcIlxuICAgIDogXCJyZ2JhKDE0NywgNTEsIDIzNCwgMC43KVwiO1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dCbHVyID0gaXNNb2JpbGUgPyA5MiA6IDE4O1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dPZmZzZXRZID1cclxuICAgIGlzTW9iaWxlID8gMCA6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSArIDE7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2NhbGUgPSBpc01vYmlsZSA/IDEuMDMgOiAxLjE7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJSb3RhdGlvblNuYXBUb2xlcmFuY2UgPSBpc01vYmlsZSA/IDggOiA1OyAvL3RvbGVyYW5jaWEgcGFyYSDigJxlbmNhamFy4oCdIHJvdGFjacOzbiBlbiDDoW5ndWxvcyBmaWpvcy5cclxuICBjb25zdCBlc1RyaWFuZ3VsbyA9XHJcbiAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJmb3JtYVwiICYmXHJcbiAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcInRyaWFuZ2xlXCI7XHJcblxyXG4gIGNvbnN0IGhhc0dhbGxlcnkgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YS5zb21lKFxyXG4gICAgKG8pID0+IG8udGlwbyA9PT0gXCJnYWxlcmlhXCJcclxuICApO1xyXG5cclxuICBjb25zdCBoYXlMaW5lYXMgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YS5zb21lKFxyXG4gICAgKG9iaikgPT4gb2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImxpbmVcIlxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEuZmlsdGVyKFxyXG4gICAgKG9iaikgPT4gIShvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwibGluZVwiKVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGRlYmVyaWFVc2FyVHJhbnNmb3JtZXIgPVxyXG4gICAgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID4gMDtcclxuXHJcbiAgY29uc3Qgc2VsZWN0ZWRHZW9tS2V5ID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGFcclxuICAgIC5tYXAoKG8pID0+XHJcbiAgICAgIFtcclxuICAgICAgICBvLmlkLFxyXG4gICAgICAgIG8ueCA/PyAwLFxyXG4gICAgICAgIG8ueSA/PyAwLFxyXG4gICAgICAgIG8ud2lkdGggPz8gXCJcIixcclxuICAgICAgICBvLmhlaWdodCA/PyBcIlwiLFxyXG4gICAgICAgIG8uc2NhbGVYID8/IDEsXHJcbiAgICAgICAgby5zY2FsZVkgPz8gMSxcclxuICAgICAgICBvLnJvdGF0aW9uID8/IDAsXHJcbiAgICAgICAgby5jaGlwV2lkdGggPz8gXCJcIixcclxuICAgICAgICBvLmdhcCA/PyBcIlwiLFxyXG4gICAgICAgIG8ucGFkZGluZ1ggPz8gXCJcIixcclxuICAgICAgICBvLnBhZGRpbmdZID8/IFwiXCIsXHJcbiAgICAgIF0uam9pbihcIjpcIilcclxuICAgIClcclxuICAgIC5qb2luKFwifFwiKTtcclxuXHJcbiAgY29uc3QgZ2V0VHJhbnNmb3JtUG9zZSA9IChub2RlKSA9PiB7XHJcbiAgICBpZiAoIW5vZGUpIHJldHVybiB7IHg6IDAsIHk6IDAsIHJvdGF0aW9uOiAwIH07XHJcblxyXG4gICAgaWYgKGVzR2FsZXJpYSAmJiB0eXBlb2Ygbm9kZS5nZXRQYXJlbnQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHg6IHR5cGVvZiBwYXJlbnQueCA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LngoKSA6IDAsXHJcbiAgICAgICAgICB5OiB0eXBlb2YgcGFyZW50LnkgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmVudC55KCkgOiAwLFxyXG4gICAgICAgICAgcm90YXRpb246IHR5cGVvZiBwYXJlbnQucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IHBhcmVudC5yb3RhdGlvbigpIHx8IDAgOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB0eXBlb2Ygbm9kZS54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IDAsXHJcbiAgICAgIHk6IHR5cGVvZiBub2RlLnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogMCxcclxuICAgICAgcm90YXRpb246IHR5cGVvZiBub2RlLnJvdGF0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnJvdGF0aW9uKCkgfHwgMCA6IDAsXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICBjb25zdCBjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2sgPSAoKSA9PiB7XHJcbiAgICBpZiAoaXNUcmFuc2Zvcm1pbmdSZXNpemVSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlKGZhbHNlKTtcclxuICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PiAoY3VycmVudCA/IG51bGwgOiBjdXJyZW50KSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0UmVzaXplQW5jaG9yTmFtZUZyb21UYXJnZXQgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBpc0FuY2hvclRhcmdldCA9XHJcbiAgICAgIHR5cGVvZiB0YXJnZXQuaGFzTmFtZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgPyB0YXJnZXQuaGFzTmFtZShcIl9hbmNob3JcIilcclxuICAgICAgICA6IHR5cGVvZiB0YXJnZXQubmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICBTdHJpbmcodGFyZ2V0Lm5hbWUoKSB8fCBcIlwiKS5pbmNsdWRlcyhcIl9hbmNob3JcIik7XHJcbiAgICBpZiAoIWlzQW5jaG9yVGFyZ2V0KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCByYXdOYW1lID1cclxuICAgICAgdHlwZW9mIHRhcmdldC5uYW1lID09PSBcImZ1bmN0aW9uXCIgPyBTdHJpbmcodGFyZ2V0Lm5hbWUoKSB8fCBcIlwiKSA6IFwiXCI7XHJcbiAgICBjb25zdCBhbmNob3JOYW1lID0gcmF3TmFtZS5zcGxpdChcIiBcIilbMF0gfHwgbnVsbDtcclxuICAgIGlmICghYW5jaG9yTmFtZSkgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoYW5jaG9yTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIikpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGFuY2hvck5hbWU7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmVzaXplQW5jaG9yUHJlc3NTdGFydCA9IChldmVudCkgPT4ge1xyXG4gICAgbGV0IGFuY2hvck5hbWUgPSBnZXRSZXNpemVBbmNob3JOYW1lRnJvbVRhcmdldChldmVudD8udGFyZ2V0KTtcclxuICAgIGlmICghYW5jaG9yTmFtZSkge1xyXG4gICAgICBjb25zdCBhY3RpdmVBbmNob3IgPVxyXG4gICAgICAgIHR5cGVvZiB0cmFuc2Zvcm1lclJlZi5jdXJyZW50Py5nZXRBY3RpdmVBbmNob3IgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgPyB0cmFuc2Zvcm1lclJlZi5jdXJyZW50LmdldEFjdGl2ZUFuY2hvcigpXHJcbiAgICAgICAgICA6IG51bGw7XHJcbiAgICAgIGlmIChcclxuICAgICAgICB0eXBlb2YgYWN0aXZlQW5jaG9yID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgIWFjdGl2ZUFuY2hvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIilcclxuICAgICAgKSB7XHJcbiAgICAgICAgYW5jaG9yTmFtZSA9IGFjdGl2ZUFuY2hvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFhbmNob3JOYW1lKSByZXR1cm47XHJcbiAgICBzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmUodHJ1ZSk7XHJcbiAgICBzZXRQcmVzc2VkUmVzaXplQW5jaG9yTmFtZSgoY3VycmVudCkgPT5cclxuICAgICAgY3VycmVudCA9PT0gYW5jaG9yTmFtZSA/IGN1cnJlbnQgOiBhbmNob3JOYW1lXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEJveE92ZXJmbG93QW1vdW50ID0gKGJveCwgc3RhZ2VXaWR0aCwgc3RhZ2VIZWlnaHQpID0+IHtcclxuICAgIGlmICghYm94KSByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihib3gueCk7XHJcbiAgICBjb25zdCB5ID0gTnVtYmVyKGJveC55KTtcclxuICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKGJveC53aWR0aCk7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBOdW1iZXIoYm94LmhlaWdodCk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAhTnVtYmVyLmlzRmluaXRlKHgpIHx8XHJcbiAgICAgICFOdW1iZXIuaXNGaW5pdGUoeSkgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZSh3aWR0aCkgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZShoZWlnaHQpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeCwgeCArIHdpZHRoKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeCwgeCArIHdpZHRoKTtcclxuICAgIGNvbnN0IHRvcCA9IE1hdGgubWluKHksIHkgKyBoZWlnaHQpO1xyXG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoeSwgeSArIGhlaWdodCk7XHJcblxyXG4gICAgY29uc3Qgb3ZlcmZsb3dMZWZ0ID0gTWF0aC5tYXgoMCwgLWxlZnQpO1xyXG4gICAgY29uc3Qgb3ZlcmZsb3dUb3AgPSBNYXRoLm1heCgwLCAtdG9wKTtcclxuICAgIGNvbnN0IG92ZXJmbG93UmlnaHQgPSBNYXRoLm1heCgwLCByaWdodCAtIHN0YWdlV2lkdGgpO1xyXG4gICAgY29uc3Qgb3ZlcmZsb3dCb3R0b20gPSBNYXRoLm1heCgwLCBib3R0b20gLSBzdGFnZUhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIG92ZXJmbG93TGVmdCArIG92ZXJmbG93VG9wICsgb3ZlcmZsb3dSaWdodCArIG92ZXJmbG93Qm90dG9tO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGtlZXBCb3hJbnNpZGVTdGFnZSA9IChvbGRCb3gsIG5leHRCb3gpID0+IHtcclxuICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IHN0YWdlID0gdHI/LmdldFN0YWdlPy4oKTtcclxuICAgIGNvbnN0IHN0YWdlV2lkdGggPVxyXG4gICAgICB0eXBlb2Ygc3RhZ2U/LndpZHRoID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/IE51bWJlcihzdGFnZS53aWR0aCgpKVxyXG4gICAgICAgIDogTnVtYmVyKHN0YWdlPy5hdHRycz8ud2lkdGgpO1xyXG4gICAgY29uc3Qgc3RhZ2VIZWlnaHQgPVxyXG4gICAgICB0eXBlb2Ygc3RhZ2U/LmhlaWdodCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgPyBOdW1iZXIoc3RhZ2UuaGVpZ2h0KCkpXHJcbiAgICAgICAgOiBOdW1iZXIoc3RhZ2U/LmF0dHJzPy5oZWlnaHQpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZShzdGFnZVdpZHRoKSB8fFxyXG4gICAgICBzdGFnZVdpZHRoIDw9IDAgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZShzdGFnZUhlaWdodCkgfHxcclxuICAgICAgc3RhZ2VIZWlnaHQgPD0gMFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBuZXh0Qm94O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9sZE92ZXJmbG93ID0gZ2V0Qm94T3ZlcmZsb3dBbW91bnQob2xkQm94LCBzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XHJcbiAgICBjb25zdCBuZXh0T3ZlcmZsb3cgPSBnZXRCb3hPdmVyZmxvd0Ftb3VudChuZXh0Qm94LCBzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XHJcbiAgICBjb25zdCBlcHNpbG9uID0gMC41O1xyXG5cclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5leHRPdmVyZmxvdykpIHtcclxuICAgICAgcmV0dXJuIG9sZEJveDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV4dE92ZXJmbG93IDw9IGVwc2lsb24pIHtcclxuICAgICAgcmV0dXJuIG5leHRCb3g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVybWl0aXIgdHJhbnNmb3JtYXIgZGUgdnVlbHRhIGhhY2lhIGFkZW50cm8gZGVsIGNhbnZhcy5cclxuICAgIGlmIChuZXh0T3ZlcmZsb3cgPD0gb2xkT3ZlcmZsb3cgKyBlcHNpbG9uKSB7XHJcbiAgICAgIHJldHVybiBuZXh0Qm94O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpIGVsIHJlc2l6ZSBlbXB1amEgbcOhcyBhZnVlcmEgZGVsIGNhbnZhcywgbWFudGVuZXIgZWwgZXN0YWRvIGFudGVyaW9yLlxyXG4gICAgcmV0dXJuIG9sZEJveDtcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAwIHx8ICFkZWJlcmlhVXNhclRyYW5zZm9ybWVyKSB7XHJcbiAgICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PiAoY3VycmVudCA/IG51bGwgOiBjdXJyZW50KSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0RyYWdnaW5nICYmICFpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PiAoY3VycmVudCA/IG51bGwgOiBjdXJyZW50KSk7XHJcbiAgICB9XHJcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMubGVuZ3RoLCBpc0RyYWdnaW5nLCBkZWJlcmlhVXNhclRyYW5zZm9ybWVyXSk7XHJcblxyXG4gIC8vIPCflKUgRWZlY3RvIHByaW5jaXBhbCBkZWwgVHJhbnNmb3JtZXIgKFNJTiByZXRyeSAvIFNJTiBmbGlja2VyKVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIXRyKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgc2VsS2V5ID0gc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKTtcclxuICAgIFRSREJHKFwiRUZGRUNUIHN0YXJ0XCIsIHtcclxuICAgICAgc2VsS2V5LFxyXG4gICAgICBpc0RyYWdnaW5nLFxyXG4gICAgICBkZWJlcmlhVXNhclRyYW5zZm9ybWVyLFxyXG4gICAgICBoYXNHYWxsZXJ5LFxyXG4gICAgICBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlc0xlbjogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoLFxyXG4gICAgICB0cmFuc2Zvcm1UaWNrLFxyXG4gICAgICBlZGl0aW5nSWQ6IHdpbmRvdy5lZGl0aW5nPy5pZCB8fCBudWxsLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2kgbm8gY29ycmVzcG9uZGUgdHJhbnNmb3JtZXIsIG5vIGhhZ2FzIGRldGFjaCBhZ3Jlc2l2byAoZXZpdGEgZmxpY2tlcilcclxuICAgIGlmICghZGViZXJpYVVzYXJUcmFuc2Zvcm1lcikge1xyXG4gICAgICBUUkRCRyhcIkVGRkVDVCBleGl0OiBubyB0cmFuc2Zvcm1lciBvciBnYWxsZXJ5XCIsIHsgc2VsS2V5IH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFJlc29sdmVyIG5vZGVzIGRlc2RlIHJlZnMgKGZ1ZW50ZSBkZSB2ZXJkYWQpXHJcbiAgICBsZXQgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzXHJcbiAgICAgIC5tYXAoKG8pID0+IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltvLmlkXSlcclxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgICAvLyBTaW5nbGUgc2VsZWN0OiB1c2FyIHJlZiBmcmVzY28gU0lFTVBSRVxyXG4gICAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGNvbnN0IGlkU2VsID0gc2VsZWN0ZWRFbGVtZW50c1swXTtcclxuICAgICAgY29uc3QgcmVmTm9kZSA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltpZFNlbF0gfHwgbnVsbDtcclxuICAgICAgaWYgKHJlZk5vZGUgJiYgdHlwZW9mIHJlZk5vZGUuZ2V0Q2xpZW50UmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGVzR2FsZXJpYSAmJiB0eXBlb2YgcmVmTm9kZS5maW5kT25lID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIGNvbnN0IGdhbGxlcnlGcmFtZSA9IHJlZk5vZGUuZmluZE9uZShcIi5nYWxsZXJ5LXRyYW5zZm9ybS1mcmFtZVwiKTtcclxuICAgICAgICAgIGlmIChnYWxsZXJ5RnJhbWUgJiYgdHlwZW9mIGdhbGxlcnlGcmFtZS5nZXRDbGllbnRSZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtnYWxsZXJ5RnJhbWVdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtyZWZOb2RlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtyZWZOb2RlXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTaSBhw7puIG5vIGhheSBub2RvcyAoaW1hZ2VuIGNhcmdhbmRvLCBldGMuKSwgTk8gZGVzcGVnYXIgKGV2aXRhIHBhcnBhZGVvKVxyXG4gICAgaWYgKG5vZG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIFRSREJHKFwiRUZGRUNUIGV4aXQ6IG5vIG5vZGVzIHlldFwiLCB7XHJcbiAgICAgICAgc2VsS2V5LFxyXG4gICAgICAgIHdhbnRlZElkczogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubWFwKG8gPT4gby5pZCksXHJcbiAgICAgICAgcmVmc1ByZXNlbnQ6IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLm1hcChvID0+ICEhZWxlbWVudFJlZnMuY3VycmVudD8uW28uaWRdKSxcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQXR0YWNoIGVzdGFibGVcclxuICAgIFRSREJHKFwiQVRUQUNIIHRyeVwiLCB7XHJcbiAgICAgIHNlbEtleSxcclxuICAgICAgbm9kZXNDb3VudDogbm9kb3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGgsXHJcbiAgICAgIG5vZGVJZHM6IG5vZG9zVHJhbnNmb3JtYWJsZXMubWFwKG4gPT4gKHR5cGVvZiBuLmlkID09PSBcImZ1bmN0aW9uXCIgPyBuLmlkKCkgOiBuLmF0dHJzPy5pZCkpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdHIubm9kZXMobm9kb3NUcmFuc2Zvcm1hYmxlcyk7XHJcblxyXG4gICAgVFJEQkcoXCJBVFRBQ0ggZG9uZVwiLCB7XHJcbiAgICAgIHNlbEtleSxcclxuICAgICAgdHJOb2Rlc0NvdW50OiB0ci5ub2Rlcz8uKCk/Lmxlbmd0aCB8fCAwLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdHJ5IHsgdHIuZm9yY2VVcGRhdGU/LigpOyB9IGNhdGNoIHsgfVxyXG4gICAgdHIuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XHJcblxyXG4gIH0sIFtcclxuICAgIC8vIERlcGVuZGVuY2lhcyBtw61uaW1hcyByZWFsZXNcclxuICAgIHNlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIiksXHJcbiAgICBkZWJlcmlhVXNhclRyYW5zZm9ybWVyLFxyXG4gICAgaGFzR2FsbGVyeSxcclxuICAgIGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCxcclxuICAgIHNlbGVjdGVkR2VvbUtleSxcclxuICAgIHRyYW5zZm9ybVRpY2ssXHJcbiAgICBlbGVtZW50UmVmcyxcclxuICBdKTtcclxuXHJcblxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IChlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlkID0gZT8uZGV0YWlsPy5pZDtcclxuICAgICAgaWYgKCFpZCkgcmV0dXJuO1xyXG5cclxuICAgICAgVFJEQkcoXCJSRUYgZXZlbnRcIiwge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdGVkRWxlbWVudHMuaW5jbHVkZXMoaWQpLFxyXG4gICAgICAgIHNlbEtleTogc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudHMuaW5jbHVkZXMoaWQpKSByZXR1cm47XHJcbiAgICAgIHNldFRyYW5zZm9ybVRpY2sodCA9PiB0ICsgMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZWxlbWVudC1yZWYtcmVnaXN0cmFkb1wiLCBoYW5kbGVyKTtcclxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVsZW1lbnQtcmVmLXJlZ2lzdHJhZG9cIiwgaGFuZGxlcik7XHJcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIildKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGZpcnN0SWQgPSBzZWxlY3RlZEVsZW1lbnRzPy5bMF07XHJcbiAgICBpZiAoIWZpcnN0SWQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBlbGVtZW50UmVmcy5jdXJyZW50Py5bZmlyc3RJZF07XHJcbiAgICBjb25zdCBzdGFnZSA9IGZpcnN0Tm9kZT8uZ2V0U3RhZ2U/LigpO1xyXG4gICAgaWYgKCFzdGFnZSkgcmV0dXJuO1xyXG5cclxuICAgIGxldCByYWZJZCA9IG51bGw7XHJcbiAgICBjb25zdCBzeW5jVHJhbnNmb3JtZXIgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChyYWZJZCAhPSBudWxsKSByZXR1cm47XHJcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICByYWZJZCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghdHIpIHJldHVybjtcclxuICAgICAgICB0cnkgeyB0ci5mb3JjZVVwZGF0ZT8uKCk7IH0gY2F0Y2ggeyB9XHJcbiAgICAgICAgdHIuZ2V0TGF5ZXI/LigpPy5iYXRjaERyYXc/LigpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhZ2Uub24oXCJkcmFnbW92ZVwiLCBzeW5jVHJhbnNmb3JtZXIpO1xyXG4gICAgc3RhZ2Uub24oXCJkcmFnZW5kXCIsIHN5bmNUcmFuc2Zvcm1lcik7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ21vdmVcIiwgc3luY1RyYW5zZm9ybWVyKTtcclxuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ2VuZFwiLCBzeW5jVHJhbnNmb3JtZXIpO1xyXG4gICAgICBpZiAocmFmSWQgIT0gbnVsbCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xyXG4gICAgfTtcclxuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSwgZWxlbWVudFJlZnNdKTtcclxuXHJcblxyXG5cclxuXHJcbiAgLy8g8J+UpSBSZW5kZXJcclxuXHJcbiAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgaWYgKGhheUxpbmVhcyAmJiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxCb3VuZHNJbmRpY2F0b3JcclxuICAgICAgICBzZWxlY3RlZEVsZW1lbnRzPXtzZWxlY3RlZEVsZW1lbnRzfVxyXG4gICAgICAgIGVsZW1lbnRSZWZzPXtlbGVtZW50UmVmc31cclxuICAgICAgICBvYmpldG9zPXtvYmpldG9zfVxyXG4gICAgICAvPlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmIChoYXlMaW5lYXMgJiYgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPEJvdW5kc0luZGljYXRvclxyXG4gICAgICAgIHNlbGVjdGVkRWxlbWVudHM9e3NlbGVjdGVkRWxlbWVudHN9XHJcbiAgICAgICAgZWxlbWVudFJlZnM9e2VsZW1lbnRSZWZzfVxyXG4gICAgICAgIG9iamV0b3M9e29iamV0b3N9XHJcbiAgICAgIC8+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxUcmFuc2Zvcm1lclxyXG4gICAgICBuYW1lPVwidWlcIlxyXG4gICAgICByZWY9e3RyYW5zZm9ybWVyUmVmfVxyXG5cclxuICAgICAgLy8g8J+UtSBib3JkZSBzaWVtcHJlIHZpc2libGVcclxuICAgICAgYm9yZGVyRW5hYmxlZD17dHJ1ZX1cclxuXHJcbiAgICAgIGJvcmRlclN0cm9rZT1cIiM5MzMzRUFcIlxyXG5cclxuXHJcbiAgICAgIGJvcmRlclN0cm9rZVdpZHRoPXt0cmFuc2Zvcm1lckJvcmRlclN0cm9rZVdpZHRofVxyXG4gICAgICBwYWRkaW5nPXt0cmFuc2Zvcm1lclBhZGRpbmd9XHJcblxyXG4gICAgICAvLyDinYwgbm9kb3MgeSByb3RhY2nDs24gT0ZGIGR1cmFudGUgZHJhZ1xyXG4gICAgICBlbmFibGVkQW5jaG9ycz17aXNEcmFnZ2luZyAmJiAhaXNSZXNpemVHZXN0dXJlQWN0aXZlID8gW10gOiBbXCJib3R0b20tcmlnaHRcIl19XHJcbiAgICAgIHJvdGF0ZUVuYWJsZWQ9eyFpc0RyYWdnaW5nICYmICFlc0dhbGVyaWF9XHJcbiAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVSZXNpemVBbmNob3JQcmVzc1N0YXJ0fVxyXG4gICAgICBvblRvdWNoU3RhcnQ9e2hhbmRsZVJlc2l6ZUFuY2hvclByZXNzU3RhcnR9XHJcbiAgICAgIG9uUG9pbnRlckRvd249e2hhbmRsZVJlc2l6ZUFuY2hvclByZXNzU3RhcnR9XHJcbiAgICAgIG9uTW91c2VVcD17Y2xlYXJSZXNpemVBbmNob3JQcmVzc0ZlZWRiYWNrfVxyXG4gICAgICBvblRvdWNoRW5kPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcbiAgICAgIG9uUG9pbnRlclVwPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcbiAgICAgIG9uVG91Y2hDYW5jZWw9e2NsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFja31cclxuICAgICAgb25Qb2ludGVyQ2FuY2VsPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcblxyXG4gICAgICBhbmNob3JGaWxsPXt0cmFuc2Zvcm1lckFuY2hvckZpbGxDb2xvcn1cbiAgICAgIGFuY2hvclN0cm9rZT17dHJhbnNmb3JtZXJBbmNob3JTdHJva2VDb2xvcn1cclxuICAgICAgYW5jaG9yU3Ryb2tlV2lkdGg9e3RyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlV2lkdGh9XHJcbiAgICAgIGFuY2hvclNpemU9e3RyYW5zZm9ybWVyQW5jaG9yU2l6ZX1cclxuICAgICAgYW5jaG9yQ29ybmVyUmFkaXVzPXt0cmFuc2Zvcm1lckFuY2hvclJhZGl1c31cclxuICAgICAgYW5jaG9yU2hhZG93Q29sb3I9e3RyYW5zZm9ybWVyQW5jaG9yU2hhZG93Q29sb3J9XHJcbiAgICAgIGFuY2hvclNoYWRvd0JsdXI9e3RyYW5zZm9ybWVyQW5jaG9yU2hhZG93Qmx1cn1cclxuICAgICAgYW5jaG9yU2hhZG93T2Zmc2V0PXt7IHg6IDAsIHk6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSB9fVxyXG4gICAgICBhbmNob3JTdHlsZUZ1bmM9eyhhbmNob3IpID0+IHtcclxuICAgICAgICBjb25zdCBhbmNob3JOYW1lID1cclxuICAgICAgICAgIHR5cGVvZiBhbmNob3I/Lm5hbWUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICA/IFN0cmluZyhhbmNob3IubmFtZSgpIHx8IFwiXCIpLnNwbGl0KFwiIFwiKVswXVxyXG4gICAgICAgICAgICA6IFwiXCI7XHJcbiAgICAgICAgY29uc3QgaXNSZXNpemVBbmNob3JOb2RlID1cclxuICAgICAgICAgIEJvb2xlYW4oYW5jaG9yTmFtZSkgJiYgIWFuY2hvck5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInJvdGF0XCIpO1xyXG4gICAgICAgIGNvbnN0IGlzUmVzaXplQWN0aXZlRmFsbGJhY2sgPVxyXG4gICAgICAgICAgaXNSZXNpemVHZXN0dXJlQWN0aXZlIHx8XHJcbiAgICAgICAgICBpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50IHx8XHJcbiAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICBCb29sZWFuKHdpbmRvdy5fcmVzaXplRGF0YT8uaXNSZXNpemluZykpO1xyXG4gICAgICAgIGNvbnN0IGlzUHJlc3NlZFJlc2l6ZUFuY2hvciA9XHJcbiAgICAgICAgICBpc1Jlc2l6ZUFjdGl2ZUZhbGxiYWNrICYmXHJcbiAgICAgICAgICBpc1Jlc2l6ZUFuY2hvck5vZGUgJiZcclxuICAgICAgICAgICghcHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUgfHwgYW5jaG9yTmFtZSA9PT0gcHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUpO1xyXG5cclxuICAgICAgICBhbmNob3Iuc2hhZG93Q29sb3IoXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0NvbG9yXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Q29sb3JcbiAgICAgICAgKTtcbiAgICAgICAgLy8gTWFudGVuZXIgc2llbXByZSBlbCBjb2xvciBvcmlnaW5hbCBkZWwgbm9kby5cbiAgICAgICAgYW5jaG9yLmZpbGwodHJhbnNmb3JtZXJBbmNob3JGaWxsQ29sb3IpO1xuICAgICAgICBhbmNob3Iuc2hhZG93RW5hYmxlZCh0cnVlKTtcbiAgICAgICAgLy8gRW4gcHJlc3NlZCwgZWwgaGFsbyBuYWNlIG3DoXMgY2VyY2EgZGVsIGFuaWxsbyBwYXJhIHF1ZSBzZSBub3RlIG1lam9yLlxuICAgICAgICBhbmNob3Iuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZChpc1ByZXNzZWRSZXNpemVBbmNob3IpO1xuICAgICAgICBhbmNob3Iuc2hhZG93T3BhY2l0eShpc1ByZXNzZWRSZXNpemVBbmNob3IgPyAxIDogMC4xMik7XG4gICAgICAgIGFuY2hvci5zaGFkb3dCbHVyKFxyXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXHJcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93Qmx1clxyXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Qmx1clxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYW5jaG9yLnNoYWRvd09mZnNldCh7XHJcbiAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgeTogaXNQcmVzc2VkUmVzaXplQW5jaG9yXHJcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93T2Zmc2V0WVxyXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbmNob3IuaGl0U3Ryb2tlV2lkdGgoXHJcbiAgICAgICAgICBpc1ByZXNzZWRSZXNpemVBbmNob3JcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIaXRTdHJva2VXaWR0aFxyXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9ySGl0U3Ryb2tlV2lkdGhcclxuICAgICAgICApO1xyXG4gICAgICAgIGFuY2hvci5zdHJva2UoXHJcbiAgICAgICAgICBpc1ByZXNzZWRSZXNpemVBbmNob3JcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIYWxvU3Ryb2tlQ29sb3JcclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lckFuY2hvclN0cm9rZUNvbG9yXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbmNob3Iuc3Ryb2tlV2lkdGgoXHJcbiAgICAgICAgICBpc1ByZXNzZWRSZXNpemVBbmNob3JcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIYWxvU3Ryb2tlV2lkdGhcclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lckFuY2hvclN0cm9rZVdpZHRoXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBhbmNob3JTY2FsZSA9IGlzUHJlc3NlZFJlc2l6ZUFuY2hvclxyXG4gICAgICAgICAgPyB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTY2FsZVxyXG4gICAgICAgICAgOiAxO1xyXG4gICAgICAgIGFuY2hvci5zY2FsZSh7IHg6IGFuY2hvclNjYWxlLCB5OiBhbmNob3JTY2FsZSB9KTtcclxuICAgICAgfX1cclxuICAgICAga2VlcFJhdGlvPXtsb2NrQXNwZWN0Q291bnRkb3duIHx8IGVzR2FsZXJpYSB8fCBsb2NrQXNwZWN0VGV4dH1cclxuICAgICAgY2VudGVyZWRTY2FsaW5nPXtzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBlc1RleHRvfVxyXG4gICAgICBmbGlwRW5hYmxlZD17ZmFsc2V9XHJcbiAgICAgIHJlc2l6ZUVuYWJsZWQ9eyFpc0RyYWdnaW5nIHx8IGlzUmVzaXplR2VzdHVyZUFjdGl2ZX1cclxuICAgICAgcm90YXRpb25TbmFwcz17WzAsIDQ1LCA5MCwgMTM1LCAxODAsIDIyNSwgMjcwLCAzMTVdfVxyXG4gICAgICByb3RhdGVBbmNob3JPZmZzZXQ9e3RyYW5zZm9ybWVyUm90YXRlT2Zmc2V0fVxyXG4gICAgICByb3RhdGlvblNuYXBUb2xlcmFuY2U9e3RyYW5zZm9ybWVyUm90YXRpb25TbmFwVG9sZXJhbmNlfVxyXG4gICAgICBib3VuZEJveEZ1bmM9eyhvbGRCb3gsIG5ld0JveCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1pblNpemUgPSBlc1RleHRvID8gMjAgOiAxMDtcclxuICAgICAgICBjb25zdCBtYXhTaXplID0gODAwO1xyXG4gICAgICAgIGlmIChlc0dhbGVyaWEpIHtcclxuICAgICAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLm1heCgxLCBOdW1iZXIocHJpbWVyRWxlbWVudG8/LnJvd3MpIHx8IDEpO1xyXG4gICAgICAgICAgY29uc3QgY29scyA9IE1hdGgubWF4KDEsIE51bWJlcihwcmltZXJFbGVtZW50bz8uY29scykgfHwgMSk7XHJcbiAgICAgICAgICBjb25zdCBnYXAgPSBNYXRoLm1heCgwLCBOdW1iZXIocHJpbWVyRWxlbWVudG8/LmdhcCkgfHwgMCk7XHJcbiAgICAgICAgICBjb25zdCBjZWxsUmF0aW8gPVxyXG4gICAgICAgICAgICBwcmltZXJFbGVtZW50bz8ucmF0aW8gPT09IFwiNDozXCJcclxuICAgICAgICAgICAgICA/IDMgLyA0XHJcbiAgICAgICAgICAgICAgOiBwcmltZXJFbGVtZW50bz8ucmF0aW8gPT09IFwiMTY6OVwiXHJcbiAgICAgICAgICAgICAgICA/IDkgLyAxNlxyXG4gICAgICAgICAgICAgICAgOiAxO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG1pbkdyaWRXaWR0aCA9IGdhcCAqIChjb2xzIC0gMSkgKyBjb2xzO1xyXG4gICAgICAgICAgY29uc3QgbmV4dFdpZHRoID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgIG1heFNpemUsXHJcbiAgICAgICAgICAgIE1hdGgubWF4KG1pblNpemUsIG1pbkdyaWRXaWR0aCwgTWF0aC5hYnMobmV3Qm94LndpZHRoKSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjb25zdCBjZWxsVyA9IE1hdGgubWF4KDEsIChuZXh0V2lkdGggLSBnYXAgKiAoY29scyAtIDEpKSAvIGNvbHMpO1xyXG4gICAgICAgICAgY29uc3QgY2VsbEggPSBjZWxsVyAqIGNlbGxSYXRpbztcclxuICAgICAgICAgIGNvbnN0IG5leHRIZWlnaHQgPSByb3dzICogY2VsbEggKyBnYXAgKiAocm93cyAtIDEpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBrZWVwQm94SW5zaWRlU3RhZ2Uob2xkQm94LCB7XHJcbiAgICAgICAgICAgIC4uLm5ld0JveCxcclxuICAgICAgICAgICAgd2lkdGg6IG5leHRXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChtaW5TaXplLCBuZXh0SGVpZ2h0KSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld0JveC53aWR0aCA8IG1pblNpemUgfHwgbmV3Qm94LmhlaWdodCA8IG1pblNpemUpIHtcclxuICAgICAgICAgIHJldHVybiBvbGRCb3g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobG9ja0FzcGVjdENvdW50ZG93bikge1xyXG4gICAgICAgICAgY29uc3QgYmFzZVcgPSBNYXRoLm1heCgxLCBvbGRCb3gud2lkdGgpO1xyXG4gICAgICAgICAgY29uc3QgYmFzZUggPSBNYXRoLm1heCgxLCBvbGRCb3guaGVpZ2h0KTtcclxuICAgICAgICAgIGNvbnN0IHJhdGlvID0gYmFzZVcgLyBiYXNlSDtcclxuXHJcbiAgICAgICAgICBjb25zdCBkdyA9IE1hdGguYWJzKG5ld0JveC53aWR0aCAtIG9sZEJveC53aWR0aCkgLyBiYXNlVztcclxuICAgICAgICAgIGNvbnN0IGRoID0gTWF0aC5hYnMobmV3Qm94LmhlaWdodCAtIG9sZEJveC5oZWlnaHQpIC8gYmFzZUg7XHJcblxyXG4gICAgICAgICAgbGV0IHdpZHRoID0gbmV3Qm94LndpZHRoO1xyXG4gICAgICAgICAgbGV0IGhlaWdodCA9IG5ld0JveC5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKGRoID4gZHcpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiByYXRpbztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gcmF0aW87XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGtlZXBCb3hJbnNpZGVTdGFnZShvbGRCb3gsIHtcclxuICAgICAgICAgICAgLi4ubmV3Qm94LFxyXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oTWF0aC5tYXgod2lkdGgsIG1pblNpemUpLCBtYXhTaXplKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihNYXRoLm1heChoZWlnaHQsIG1pblNpemUpLCBtYXhTaXplKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZm9ybWFcIiAmJlxyXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KG5ld0JveC53aWR0aCwgbmV3Qm94LmhlaWdodCk7XHJcbiAgICAgICAgICBjb25zdCBmaW5hbFNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhTaXplKTtcclxuICAgICAgICAgIHJldHVybiBrZWVwQm94SW5zaWRlU3RhZ2Uob2xkQm94LCB7XHJcbiAgICAgICAgICAgIC4uLm5ld0JveCxcclxuICAgICAgICAgICAgd2lkdGg6IGZpbmFsU2l6ZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBmaW5hbFNpemUsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlc1RyaWFuZ3Vsbykge1xyXG4gICAgICAgICAgY29uc3Qgc2FmZU9sZFcgPSBNYXRoLm1heCgxLCBNYXRoLmFicyhvbGRCb3gud2lkdGggfHwgbWluU2l6ZSkpO1xyXG4gICAgICAgICAgY29uc3Qgc2FmZU9sZEggPSBNYXRoLm1heCgxLCBNYXRoLmFicyhvbGRCb3guaGVpZ2h0IHx8IG1pblNpemUpKTtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IE1hdGguYWJzKG5ld0JveC53aWR0aCkgLyBzYWZlT2xkVztcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IE1hdGguYWJzKG5ld0JveC5oZWlnaHQpIC8gc2FmZU9sZEg7XHJcbiAgICAgICAgICBjb25zdCB1bmlmb3JtU2NhbGUgPSBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoc2FmZU9sZFcgKiB1bmlmb3JtU2NhbGUsIG1pblNpemUpLCBtYXhTaXplKTtcclxuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KHNhZmVPbGRIICogdW5pZm9ybVNjYWxlLCBtaW5TaXplKSwgbWF4U2l6ZSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGtlZXBCb3hJbnNpZGVTdGFnZShvbGRCb3gsIHtcclxuICAgICAgICAgICAgLi4ubmV3Qm94LFxyXG4gICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJpbWFnZW5cIiB8fFxyXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiaWNvbm9cIlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gbmV3Qm94LndpZHRoIC8gb2xkQm94LndpZHRoO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gbmV3Qm94LmhlaWdodCAvIG9sZEJveC5oZWlnaHQ7XHJcbiAgICAgICAgICBjb25zdCB1bmlmb3JtU2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBvbGRCb3gud2lkdGggKiB1bmlmb3JtU2NhbGU7XHJcbiAgICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBvbGRCb3guaGVpZ2h0ICogdW5pZm9ybVNjYWxlO1xyXG5cclxuICAgICAgICAgIHJldHVybiBrZWVwQm94SW5zaWRlU3RhZ2Uob2xkQm94LCB7XHJcbiAgICAgICAgICAgIC4uLm5ld0JveCxcclxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKE1hdGgubWF4KG5ld1dpZHRoLCBtaW5TaXplKSwgbWF4U2l6ZSksXHJcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5taW4oTWF0aC5tYXgobmV3SGVpZ2h0LCBtaW5TaXplKSwgbWF4U2l6ZSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBrZWVwQm94SW5zaWRlU3RhZ2Uob2xkQm94LCB7XHJcbiAgICAgICAgICAuLi5uZXdCb3gsXHJcbiAgICAgICAgICB3aWR0aDogTWF0aC5taW4obmV3Qm94LndpZHRoLCBtYXhTaXplKSxcclxuICAgICAgICAgIGhlaWdodDogTWF0aC5taW4obmV3Qm94LmhlaWdodCwgbWF4U2l6ZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH19XHJcbiAgICAgIG9uVHJhbnNmb3JtU3RhcnQ9eyhlKSA9PiB7XHJcbiAgICAgICAgaXNUcmFuc2Zvcm1pbmdSZXNpemVSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0geyBpc1Jlc2l6aW5nOiB0cnVlIH07XHJcbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUFuY2hvciA9XHJcbiAgICAgICAgICB0eXBlb2YgdHI/LmdldEFjdGl2ZUFuY2hvciA9PT0gXCJmdW5jdGlvblwiID8gdHIuZ2V0QWN0aXZlQW5jaG9yKCkgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGlzUm90YXRlR2VzdHVyZSA9XHJcbiAgICAgICAgICB0eXBlb2YgYWN0aXZlQW5jaG9yID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICBhY3RpdmVBbmNob3IudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInJvdGF0XCIpO1xyXG4gICAgICAgIHRyYW5zZm9ybUdlc3R1cmVSZWYuY3VycmVudCA9IHtcclxuICAgICAgICAgIGlzUm90YXRlOiBpc1JvdGF0ZUdlc3R1cmUsXHJcbiAgICAgICAgICBhY3RpdmVBbmNob3I6IGFjdGl2ZUFuY2hvciA/PyBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFpc1JvdGF0ZUdlc3R1cmUpIHtcclxuICAgICAgICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1JvdGF0ZUdlc3R1cmUgJiYgYWN0aXZlQW5jaG9yKSB7XHJcbiAgICAgICAgICBzZXRQcmVzc2VkUmVzaXplQW5jaG9yTmFtZSgoY3VycmVudCkgPT5cclxuICAgICAgICAgICAgY3VycmVudCA9PT0gYWN0aXZlQW5jaG9yID8gY3VycmVudCA6IGFjdGl2ZUFuY2hvclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvblRyYW5zZm9ybUludGVyYWN0aW9uU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgb25UcmFuc2Zvcm1JbnRlcmFjdGlvblN0YXJ0KHtcclxuICAgICAgICAgICAgaXNSb3RhdGU6IGlzUm90YXRlR2VzdHVyZSxcclxuICAgICAgICAgICAgYWN0aXZlQW5jaG9yOiBhY3RpdmVBbmNob3IgPz8gbnVsbCxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IGU/LmV2dD8ucG9pbnRlclR5cGUgPz8gbnVsbCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSB0cj8ubm9kZXM/LigpIHx8IFtdO1xyXG4gICAgICAgICAgY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIG5vZGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJmb3JtYVwiICYmXHJcbiAgICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHIwID0gbm9kZXNbMF0uZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGNpcmNsZUFuY2hvclJlZi5jdXJyZW50ID0geyBsZWZ0OiByMC54LCB0b3A6IHIwLnkgfTtcclxuICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgZXNUZXh0bykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbMF07XHJcbiAgICAgICAgICAgIGxldCBjZW50ZXJYID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGNlbnRlclkgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgYmFzZVdpZHRoID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGJhc2VIZWlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgYmFzZVZpc3VhbFdpZHRoID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py54KSAmJiBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJYID0gcmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py55KSAmJiBOdW1iZXIuaXNGaW5pdGUocmVjdD8uaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyWSA9IHJlY3QueSArIChyZWN0LmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJiByZWN0LndpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYmFzZVdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgIGJhc2VWaXN1YWxXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8uaGVpZ2h0KSAmJiByZWN0LmhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJhc2VIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgY29uc3Qgc2FmZUJhc2VGb250U2l6ZSA9XHJcbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHByaW1lckVsZW1lbnRvPy5mb250U2l6ZSkgJiYgcHJpbWVyRWxlbWVudG8uZm9udFNpemUgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHByaW1lckVsZW1lbnRvLmZvbnRTaXplXHJcbiAgICAgICAgICAgICAgICA6IDI0O1xyXG4gICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgPSB7XHJcbiAgICAgICAgICAgICAgeTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogMCxcclxuICAgICAgICAgICAgICBiYXNlUm90YXRpb246XHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZT8ucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnJvdGF0aW9uKCkgfHwgMCkgOiAwLFxyXG4gICAgICAgICAgICAgIGNlbnRlclgsXHJcbiAgICAgICAgICAgICAgY2VudGVyWSxcclxuICAgICAgICAgICAgICBiYXNlV2lkdGgsXHJcbiAgICAgICAgICAgICAgYmFzZUhlaWdodCxcclxuICAgICAgICAgICAgICBiYXNlRm9udFNpemU6IHNhZmVCYXNlRm9udFNpemUsXHJcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdGb250U2l6ZTogc2FmZUJhc2VGb250U2l6ZSxcclxuICAgICAgICAgICAgICBsYXN0UHJldmlld0NlbnRlclg6IGNlbnRlclgsXHJcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdDZW50ZXJZOiBjZW50ZXJZLFxyXG4gICAgICAgICAgICAgIGxhc3RQcmV2aWV3VmlzdWFsV2lkdGg6IGJhc2VWaXN1YWxXaWR0aCxcclxuICAgICAgICAgICAgICBwcmV2aWV3VGljazogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVFhUREJHKFwic3RhcnRcIiwge1xyXG4gICAgICAgICAgICAgIGlkOiBwcmltZXJFbGVtZW50bz8uaWQgPz8gbnVsbCxcclxuICAgICAgICAgICAgICBiYXNlRm9udFNpemU6IHNhZmVCYXNlRm9udFNpemUsXHJcbiAgICAgICAgICAgICAgYmFzZVdpZHRoLFxyXG4gICAgICAgICAgICAgIGJhc2VIZWlnaHQsXHJcbiAgICAgICAgICAgICAgY2VudGVyWCxcclxuICAgICAgICAgICAgICBjZW50ZXJZLFxyXG4gICAgICAgICAgICAgIG5vZGVYOiB0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIG5vZGVZOiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIG5vZGVTY2FsZVg6IHR5cGVvZiBub2RlPy5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIG5vZGVTY2FsZVk6IHR5cGVvZiBub2RlPy5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiBudWxsLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCB1bmlvbiA9IHJlY3RGcm9tTm9kZXMobm9kZXMpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHBhZCA9IHR5cGVvZiB0cj8ucGFkZGluZyA9PT0gXCJmdW5jdGlvblwiID8gdHIucGFkZGluZygpIDogMDtcclxuICAgICAgICAgIGNvbnN0IGJvcmRlclJlY3QgPSB1bmlvblxyXG4gICAgICAgICAgICA/IHsgeDogdW5pb24ueCAtIHBhZCwgeTogdW5pb24ueSAtIHBhZCwgd2lkdGg6IHVuaW9uLndpZHRoICsgcGFkICogMiwgaGVpZ2h0OiB1bmlvbi5oZWlnaHQgKyBwYWQgKiAyIH1cclxuICAgICAgICAgICAgOiBudWxsO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1swXTtcclxuICAgICAgICAgIGNvbnN0IGlkID0gbiA/ICh0eXBlb2Ygbi5pZCA9PT0gXCJmdW5jdGlvblwiID8gbi5pZCgpIDogbi5hdHRycz8uaWQpIDogXCLiiIVcIjtcclxuICAgICAgICAgIGNvbnN0IHRyUmVjdCA9IHRyPy5nZXRDbGllbnRSZWN0Py4oeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgICBzbG9nKFxyXG4gICAgICAgICAgICBcIltUUl0gc3RhcnRcIixcclxuICAgICAgICAgICAgYGlkPSR7aWR9YCxcclxuICAgICAgICAgICAgYG5vZGVzPSR7bm9kZXMubGVuZ3RofWAsXHJcbiAgICAgICAgICAgIHVuaW9uID8gYHVuaW9uKHc9JHt1bmlvbi53aWR0aC50b0ZpeGVkKDEpfSxoPSR7dW5pb24uaGVpZ2h0LnRvRml4ZWQoMSl9KWAgOiBcInVuaW9uKG51bGwpXCIsXHJcbiAgICAgICAgICAgIGJvcmRlclJlY3QgPyBgYm9yZGVyKHc9JHtib3JkZXJSZWN0LndpZHRoLnRvRml4ZWQoMSl9LGg9JHtib3JkZXJSZWN0LmhlaWdodC50b0ZpeGVkKDEpfSlgIDogXCJib3JkZXIobnVsbClcIixcclxuICAgICAgICAgICAgdHJSZWN0ID8gYHRyUmVjdCh3PSR7dHJSZWN0LndpZHRoLnRvRml4ZWQoMSl9LGg9JHt0clJlY3QuaGVpZ2h0LnRvRml4ZWQoMSl9KWAgOiBcInRyUmVjdChudWxsKVwiLFxyXG4gICAgICAgICAgICBgcGFkPSR7cGFkfWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCB7IH1cclxuICAgICAgfX1cclxuXHJcbiAgICAgIG9uVHJhbnNmb3JtPXsoZSkgPT4ge1xyXG4gICAgICAgIGlmICghb25UcmFuc2Zvcm0gfHwgIXRyYW5zZm9ybWVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gdHlwZW9mIHRyLm5vZGVzID09PSBcImZ1bmN0aW9uXCIgPyB0ci5ub2RlcygpIHx8IFtdIDogW107XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdOyAvLyDinIUgbm9kbyByZWFsIChzaW5nbGUgc2VsZWN0KVxyXG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcG9zZSA9IGdldFRyYW5zZm9ybVBvc2Uobm9kZSk7XHJcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1EYXRhID0ge1xyXG4gICAgICAgICAgICB4OiBwb3NlLngsXHJcbiAgICAgICAgICAgIHk6IHBvc2UueSxcclxuICAgICAgICAgICAgcm90YXRpb246IHBvc2Uucm90YXRpb24sXHJcbiAgICAgICAgICAgIGlzUHJldmlldzogdHJ1ZSxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKGVzVGV4dG8pIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHByaW1lckVsZW1lbnRvLmZvbnRTaXplIHx8IDI0O1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVkgPSB0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3JEYXRhID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50IHx8IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VGb250U2l6ZSA9XHJcbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmJhc2VGb250U2l6ZSkgJiZcclxuICAgICAgICAgICAgICBhbmNob3JEYXRhLmJhc2VGb250U2l6ZSA+IDBcclxuICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5iYXNlRm9udFNpemVcclxuICAgICAgICAgICAgICAgIDogb3JpZ2luYWxGb250U2l6ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGF2Z1NjYWxlID0gKE1hdGguYWJzKHNjYWxlWCkgKyBNYXRoLmFicyhzY2FsZVkpKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCBzY2FsZUZyb21SZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGxpdmVSZWN0V2lkdGggPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Um90YXRpb24gPVxyXG4gICAgICAgICAgICAgIHR5cGVvZiBub2RlLnJvdGF0aW9uID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5yb3RhdGlvbigpIHx8IDApIDogMDtcclxuICAgICAgICAgICAgY29uc3QgYmFzZVJvdGF0aW9uID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VSb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uRGVsdGEgPSBOdW1iZXIuaXNGaW5pdGUoYmFzZVJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgID8gTWF0aC5hYnMoY3VycmVudFJvdGF0aW9uIC0gYmFzZVJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkgJiYgcmVjdC53aWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxpdmVSZWN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb25zdCBiYXNlV2lkdGggPSBOdW1iZXIoYW5jaG9yRGF0YT8uYmFzZVdpZHRoKTtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYmFzZVdpZHRoKSAmJlxyXG4gICAgICAgICAgICAgICAgYmFzZVdpZHRoID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJlxyXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA+IDBcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlRnJvbVJlY3QgPSByZWN0LndpZHRoIC8gYmFzZVdpZHRoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICBjb25zdCBjYW5Vc2VSZWN0U2NhbGUgPSByb3RhdGlvbkRlbHRhIDwgMC4xO1xyXG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVTY2FsZSA9XHJcbiAgICAgICAgICAgICAgY2FuVXNlUmVjdFNjYWxlICYmIE51bWJlci5pc0Zpbml0ZShzY2FsZUZyb21SZWN0KSAmJiBzY2FsZUZyb21SZWN0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyBzY2FsZUZyb21SZWN0XHJcbiAgICAgICAgICAgICAgICA6IGF2Z1NjYWxlO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLmZvbnRTaXplID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgNixcclxuICAgICAgICAgICAgICBOdW1iZXIoKGJhc2VGb250U2l6ZSAqIGVmZmVjdGl2ZVNjYWxlKS50b0ZpeGVkKDMpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGljayA9IE51bWJlcih0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQucHJldmlld1RpY2sgfHwgMCkgKyAxO1xyXG4gICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5wcmV2aWV3VGljayA9IHRpY2s7XHJcbiAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Lmxhc3RQcmV2aWV3Rm9udFNpemUgPSB0cmFuc2Zvcm1EYXRhLmZvbnRTaXplO1xyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobGl2ZVJlY3RXaWR0aCkgJiYgbGl2ZVJlY3RXaWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld1Zpc3VhbFdpZHRoID0gbGl2ZVJlY3RXaWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHRpY2sgPD0gMiB8fCB0aWNrICUgNSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgVFhUREJHKFwicHJldmlld1wiLCB7XHJcbiAgICAgICAgICAgICAgICAgIGlkOiBwcmltZXJFbGVtZW50bz8uaWQgPz8gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgdGljayxcclxuICAgICAgICAgICAgICAgICAgc2NhbGVYLFxyXG4gICAgICAgICAgICAgICAgICBzY2FsZVksXHJcbiAgICAgICAgICAgICAgICAgIGF2Z1NjYWxlLFxyXG4gICAgICAgICAgICAgICAgICBzY2FsZUZyb21SZWN0LFxyXG4gICAgICAgICAgICAgICAgICBlZmZlY3RpdmVTY2FsZSxcclxuICAgICAgICAgICAgICAgICAgYmFzZUZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogdHJhbnNmb3JtRGF0YS5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgbGl2ZVJlY3RXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgY2VudGVyWFRhcmdldDogdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py5jZW50ZXJYID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIG5vZGVYOiB0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBub2RlWTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgaWYgKGNhblVzZVJlY3RTY2FsZSAmJiBOdW1iZXIuaXNGaW5pdGUodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py55KSkge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueSA9IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py5jZW50ZXJYKSkge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudGV4dENlbnRlclggPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQuY2VudGVyWDtcclxuICAgICAgICAgICAgICBpZiAodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdDZW50ZXJYID1cclxuICAgICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py5jZW50ZXJZKSkge1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudGV4dENlbnRlclkgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQuY2VudGVyWTtcclxuICAgICAgICAgICAgICBpZiAodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdDZW50ZXJZID1cclxuICAgICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVkgPSB0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiAxO1xyXG5cclxuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5zY2FsZVggPSBzY2FsZVg7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVZID0gc2NhbGVZO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImNvdW50ZG93blwiKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY291bnRkb3duU2l6ZSA9IGdldENvdW50ZG93blNjYWxlZFNpemUobm9kZSk7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS53aWR0aCA9IGNvdW50ZG93blNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5oZWlnaHQgPSBjb3VudGRvd25TaXplLmhlaWdodDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlc1RyaWFuZ3Vsbykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VSYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUocHJpbWVyRWxlbWVudG8/LnJhZGl1cylcclxuICAgICAgICAgICAgICAgID8gcHJpbWVyRWxlbWVudG8ucmFkaXVzXHJcbiAgICAgICAgICAgICAgICA6IDYwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGF2Z1NjYWxlID0gKE1hdGguYWJzKHNjYWxlWCkgKyBNYXRoLmFicyhzY2FsZVkpKSAvIDI7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5yYWRpdXMgPSBNYXRoLm1heCgxLCBiYXNlUmFkaXVzICogYXZnU2NhbGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsV2lkdGggPSBwcmltZXJFbGVtZW50by53aWR0aCB8fCAxMDA7XHJcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSBwcmltZXJFbGVtZW50by5oZWlnaHQgfHwgMTAwO1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEud2lkdGggPSBNYXRoLmFicyhvcmlnaW5hbFdpZHRoICogc2NhbGVYKTtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLmhlaWdodCA9IE1hdGguYWJzKG9yaWdpbmFsSGVpZ2h0ICogc2NhbGVZKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCIpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGl2ZVJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlhbWV0ZXIgPSBNYXRoLm1heCgxLCBNYXRoLm1heChsaXZlUmVjdC53aWR0aCwgbGl2ZVJlY3QuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnJhZGl1cyA9IGRpYW1ldGVyIC8gMjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGNpcmNsZUFuY2hvclJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvcikge1xyXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnggPSBhbmNob3IubGVmdCArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnkgPSBhbmNob3IudG9wICsgdHJhbnNmb3JtRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnggPSBsaXZlUmVjdC54ICsgdHJhbnNmb3JtRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueSA9IGxpdmVSZWN0LnkgKyB0cmFuc2Zvcm1EYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBvblRyYW5zZm9ybSh0cmFuc2Zvcm1EYXRhKTtcclxuXHJcbiAgICAgICAgICAvLyAtLS0gTE9HIENPTVBBQ1RPIChvcGNpb25hbCkgLS0tXHJcbiAgICAgICAgICBjb25zdCBpZCA9ICh0eXBlb2Ygbm9kZS5pZCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5pZCgpIDogbm9kZS5hdHRycz8uaWQpIHx8IFwi4oiFXCI7XHJcbiAgICAgICAgICBjb25zdCBzeCA9IG5vZGUuc2NhbGVYPy4oKSA/PyAxO1xyXG4gICAgICAgICAgY29uc3Qgc3kgPSBub2RlLnNjYWxlWT8uKCkgPz8gMTtcclxuICAgICAgICAgIGNvbnN0IHIgPSBub2RlLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcclxuICAgICAgICAgIHNsb2coXHJcbiAgICAgICAgICAgIFwiW1RSXSBsaXZlXCIsXHJcbiAgICAgICAgICAgIGBpZD0ke2lkfWAsXHJcbiAgICAgICAgICAgIGB0aXBvPSR7cHJpbWVyRWxlbWVudG8/LnRpcG8gfHwgXCLiiIVcIn1gLFxyXG4gICAgICAgICAgICBgc3g9JHtzeC50b0ZpeGVkKDMpfWAsXHJcbiAgICAgICAgICAgIGBzeT0ke3N5LnRvRml4ZWQoMyl9YCxcclxuICAgICAgICAgICAgYHg9JHsobm9kZS54Py4oKSA/PyAwKS50b0ZpeGVkKDEpfWAsXHJcbiAgICAgICAgICAgIGB5PSR7KG5vZGUueT8uKCkgPz8gMCkudG9GaXhlZCgxKX1gLFxyXG4gICAgICAgICAgICBgbm9kZVJlY3Qodz0ke3Iud2lkdGgudG9GaXhlZCgxKX0saD0ke3IuaGVpZ2h0LnRvRml4ZWQoMSl9KWAsXHJcbiAgICAgICAgICAgIGB3PSR7dHJhbnNmb3JtRGF0YS53aWR0aCA/PyBcIuKIhVwifWAsXHJcbiAgICAgICAgICAgIGBoPSR7dHJhbnNmb3JtRGF0YS5oZWlnaHQgPz8gXCLiiIVcIn1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBlbiBvblRyYW5zZm9ybTpcIiwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfX1cclxuICAgICAgb25UcmFuc2Zvcm1FbmQ9eyhlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25TbmFwc2hvdCA9IHtcclxuICAgICAgICAgIGlzUm90YXRlOiBCb29sZWFuKHRyYW5zZm9ybUdlc3R1cmVSZWYuY3VycmVudD8uaXNSb3RhdGUpLFxyXG4gICAgICAgICAgYWN0aXZlQW5jaG9yOiB0cmFuc2Zvcm1HZXN0dXJlUmVmLmN1cnJlbnQ/LmFjdGl2ZUFuY2hvciA/PyBudWxsLFxyXG4gICAgICAgICAgcG9pbnRlclR5cGU6IGU/LmV2dD8ucG9pbnRlclR5cGUgPz8gbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG5vdGlmeVRyYW5zZm9ybUludGVyYWN0aW9uRW5kID0gKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblRyYW5zZm9ybUludGVyYWN0aW9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgb25UcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZChpbnRlcmFjdGlvblNuYXBzaG90KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRyYW5zZm9ybUdlc3R1cmVSZWYuY3VycmVudCA9IHtcclxuICAgICAgICAgICAgaXNSb3RhdGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhY3RpdmVBbmNob3I6IG51bGwsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVyUmVmLmN1cnJlbnQgfHwgIW9uVHJhbnNmb3JtKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSB0eXBlb2YgdHIubm9kZXMgPT09IFwiZnVuY3Rpb25cIiA/IHRyLm5vZGVzKCkgfHwgW10gOiBbXTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIC8vIE1VTFRJLVNFTEVDQ0nDk05cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRTY2FsZVggPSB0eXBlb2YgdHIuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyB0ci5zY2FsZVgoKSB8fCAxIDogMTtcclxuICAgICAgICAgICAgY29uc3QgdFNjYWxlWSA9IHR5cGVvZiB0ci5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IHRyLnNjYWxlWSgpIHx8IDEgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBhdmcgPSAoTWF0aC5hYnModFNjYWxlWCkgKyBNYXRoLmFicyh0U2NhbGVZKSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5vZGVzXHJcbiAgICAgICAgICAgICAgLm1hcCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIGlkID0gKHR5cGVvZiBuLmlkID09PSBcImZ1bmN0aW9uXCIgPyBuLmlkKCkgOiBuLmF0dHJzPy5pZCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggeyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSAob2JqZXRvcyB8fCBbXSkuZmluZCgobykgPT4gby5pZCA9PT0gaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmopIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZCA9IHtcclxuICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgIHg6IHR5cGVvZiBuLnggPT09IFwiZnVuY3Rpb25cIiA/IG4ueCgpIDogb2JqLngsXHJcbiAgICAgICAgICAgICAgICAgIHk6IHR5cGVvZiBuLnkgPT09IFwiZnVuY3Rpb25cIiA/IG4ueSgpIDogb2JqLnksXHJcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0eXBlb2Ygbi5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gbi5yb3RhdGlvbigpIHx8IDAgOiAob2JqLnJvdGF0aW9uIHx8IDApLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwidGV4dG9cIikge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gb2JqLmZvbnRTaXplIHx8IDI0O1xyXG4gICAgICAgICAgICAgICAgICB1cGQuZm9udFNpemUgPSBNYXRoLm1heCg2LCBNYXRoLnJvdW5kKGJhc2UgKiBhdmcpKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImNpcmNsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VSID0gb2JqLnJhZGl1cyB8fCA1MDtcclxuICAgICAgICAgICAgICAgICAgdXBkLnJhZGl1cyA9IGJhc2VSICogYXZnO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG4uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwidHJpYW5nbGVcIikge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUiA9IG9iai5yYWRpdXMgfHwgNjA7XHJcbiAgICAgICAgICAgICAgICAgIHVwZC5yYWRpdXMgPSBNYXRoLm1heCgxLCBiYXNlUiAqIGF2Zyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVZKDEpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcImNvdW50ZG93blwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ZG93blNpemUgPSBnZXRDb3VudGRvd25TY2FsZWRTaXplKG4pO1xyXG4gICAgICAgICAgICAgICAgICB1cGQud2lkdGggPSBjb3VudGRvd25TaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICB1cGQuaGVpZ2h0ID0gY291bnRkb3duU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVcgPVxyXG4gICAgICAgICAgICAgICAgICBvYmoud2lkdGggIT0gbnVsbCA/IG9iai53aWR0aCA6ICh0eXBlb2Ygbi53aWR0aCA9PT0gXCJmdW5jdGlvblwiID8gbi53aWR0aCgpIDogMTAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VIID1cclxuICAgICAgICAgICAgICAgICAgb2JqLmhlaWdodCAhPSBudWxsID8gb2JqLmhlaWdodCA6ICh0eXBlb2Ygbi5oZWlnaHQgPT09IFwiZnVuY3Rpb25cIiA/IG4uaGVpZ2h0KCkgOiAxMDApO1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZC53aWR0aCA9IE1hdGguYWJzKGJhc2VXICogdFNjYWxlWCk7XHJcbiAgICAgICAgICAgICAgICB1cGQuaGVpZ2h0ID0gTWF0aC5hYnMoYmFzZUggKiB0U2NhbGVZKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG4uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgbi5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgICAgIG4uc2NhbGVZKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZDtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcblxyXG4gICAgICAgICAgICBvblRyYW5zZm9ybSh7IGlzRmluYWw6IHRydWUsIGJhdGNoOiB1cGRhdGVzIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ci5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgIHRyLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICB0ci5zY2FsZVkoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHIuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSB7IGlzUmVzaXppbmc6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sIDEwMCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZW4gb25UcmFuc2Zvcm1FbmQgKG11bHRpKTpcIiwgZXJyKTtcclxuICAgICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIC8vIFNJTkdMRS1TRUxFQ0NJw5NOXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTtcclxuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgcG9zZSA9IGdldFRyYW5zZm9ybVBvc2Uobm9kZSk7XHJcbiAgICAgICAgY29uc3QgZmluYWxEYXRhID0ge1xyXG4gICAgICAgICAgICB4OiBwb3NlLngsXHJcbiAgICAgICAgICAgIHk6IHBvc2UueSxcclxuICAgICAgICAgICAgcm90YXRpb246IHBvc2Uucm90YXRpb24sXHJcbiAgICAgICAgICAgIGlzRmluYWw6IHRydWUsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgbGV0IHRleHRQcmV2aWV3RW5kU25hcHNob3QgPSBudWxsO1xyXG5cclxuICAgICAgICAgIGlmIChlc1RleHRvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRm9udFNpemUgPSBwcmltZXJFbGVtZW50by5mb250U2l6ZSB8fCAyNDtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yRGF0YSA9IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCB8fCBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlRm9udFNpemUgPVxyXG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5iYXNlRm9udFNpemUpICYmXHJcbiAgICAgICAgICAgICAgYW5jaG9yRGF0YS5iYXNlRm9udFNpemUgPiAwXHJcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEuYmFzZUZvbnRTaXplXHJcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRm9udFNpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2Z1NjYWxlID0gKE1hdGguYWJzKHNjYWxlWCkgKyBNYXRoLmFicyhzY2FsZVkpKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCBzY2FsZUZyb21SZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHZpc3VhbFdpZHRoRnJvbVJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Um90YXRpb24gPVxyXG4gICAgICAgICAgICAgIHR5cGVvZiBub2RlLnJvdGF0aW9uID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5yb3RhdGlvbigpIHx8IDApIDogMDtcclxuICAgICAgICAgICAgY29uc3QgYmFzZVJvdGF0aW9uID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VSb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uRGVsdGEgPSBOdW1iZXIuaXNGaW5pdGUoYmFzZVJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgID8gTWF0aC5hYnMoY3VycmVudFJvdGF0aW9uIC0gYmFzZVJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkgJiYgcmVjdC53aWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZpc3VhbFdpZHRoRnJvbVJlY3QgPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb25zdCBiYXNlV2lkdGggPSBOdW1iZXIoYW5jaG9yRGF0YT8uYmFzZVdpZHRoKTtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYmFzZVdpZHRoKSAmJlxyXG4gICAgICAgICAgICAgICAgYmFzZVdpZHRoID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJlxyXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA+IDBcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlRnJvbVJlY3QgPSByZWN0LndpZHRoIC8gYmFzZVdpZHRoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICBjb25zdCBjYW5Vc2VSZWN0U2NhbGUgPSByb3RhdGlvbkRlbHRhIDwgMC4xO1xyXG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVTY2FsZSA9XHJcbiAgICAgICAgICAgICAgY2FuVXNlUmVjdFNjYWxlICYmIE51bWJlci5pc0Zpbml0ZShzY2FsZUZyb21SZWN0KSAmJiBzY2FsZUZyb21SZWN0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyBzY2FsZUZyb21SZWN0XHJcbiAgICAgICAgICAgICAgICA6IGF2Z1NjYWxlO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgIDYsXHJcbiAgICAgICAgICAgICAgTnVtYmVyKChiYXNlRm9udFNpemUgKiBlZmZlY3RpdmVTY2FsZSkudG9GaXhlZCgzKSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZmluYWxEYXRhLmZvbnRTaXplID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgNixcclxuICAgICAgICAgICAgICBOdW1iZXIoXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdGb250U2l6ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgYW5jaG9yRGF0YS5sYXN0UHJldmlld0ZvbnRTaXplID4gMFxyXG4gICAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEubGFzdFByZXZpZXdGb250U2l6ZVxyXG4gICAgICAgICAgICAgICAgICA6IGNvbXB1dGVkRm9udFNpemVcclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgaWYgKGNhblVzZVJlY3RTY2FsZSAmJiBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ueSkpIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IGFuY2hvckRhdGEueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3Q2VudGVyWCkpIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclggPSBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Q2VudGVyWDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8uY2VudGVyWCkpIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclggPSBhbmNob3JEYXRhLmNlbnRlclg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5sYXN0UHJldmlld0NlbnRlclkpKSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnRleHRDZW50ZXJZID0gYW5jaG9yRGF0YS5sYXN0UHJldmlld0NlbnRlclk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmNlbnRlclkpKSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnRleHRDZW50ZXJZID0gYW5jaG9yRGF0YS5jZW50ZXJZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbFdpZHRoID1cclxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdWaXN1YWxXaWR0aCkgJiZcclxuICAgICAgICAgICAgICBhbmNob3JEYXRhLmxhc3RQcmV2aWV3VmlzdWFsV2lkdGggPiAwXHJcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEubGFzdFByZXZpZXdWaXN1YWxXaWR0aFxyXG4gICAgICAgICAgICAgICAgOiB2aXN1YWxXaWR0aEZyb21SZWN0O1xyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZpc3VhbFdpZHRoKSAmJiB2aXN1YWxXaWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dFZpc3VhbFdpZHRoID0gdmlzdWFsV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGV4dFByZXZpZXdFbmRTbmFwc2hvdCA9IHtcclxuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgeDogdHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICB5OiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIHNjYWxlWCxcclxuICAgICAgICAgICAgICBzY2FsZVksXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IHR5cGVvZiBub2RlPy5mb250U2l6ZSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5mb250U2l6ZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICByZWN0V2lkdGg6IE51bWJlci5pc0Zpbml0ZSh2aXN1YWxXaWR0aEZyb21SZWN0KSA/IHZpc3VhbFdpZHRoRnJvbVJlY3QgOiBudWxsLFxyXG4gICAgICAgICAgICAgIHJlY3RIZWlnaHQ6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVjdEZvclNuYXBzaG90ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Rm9yU25hcHNob3Q/LmhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodCA9IHJlY3RGb3JTbmFwc2hvdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgIFRYVERCRyhcImVuZFwiLCB7XHJcbiAgICAgICAgICAgICAgaWQ6IHByaW1lckVsZW1lbnRvPy5pZCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIHNjYWxlWCxcclxuICAgICAgICAgICAgICBzY2FsZVksXHJcbiAgICAgICAgICAgICAgYXZnU2NhbGUsXHJcbiAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCxcclxuICAgICAgICAgICAgICBlZmZlY3RpdmVTY2FsZSxcclxuICAgICAgICAgICAgICBjb21wdXRlZEZvbnRTaXplLFxyXG4gICAgICAgICAgICAgIGZpbmFsRm9udFNpemU6IGZpbmFsRGF0YS5mb250U2l6ZSxcclxuICAgICAgICAgICAgICB0ZXh0Q2VudGVyWDogZmluYWxEYXRhLnRleHRDZW50ZXJYID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgdGV4dENlbnRlclk6IGZpbmFsRGF0YS50ZXh0Q2VudGVyWSA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIHRleHRWaXN1YWxXaWR0aDogZmluYWxEYXRhLnRleHRWaXN1YWxXaWR0aCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIG5vZGVSZWN0V2lkdGg6IHZpc3VhbFdpZHRoRnJvbVJlY3QsXHJcbiAgICAgICAgICAgICAgbm9kZVg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgbm9kZVk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBsYW5hciBlc2NhbGEgZGVsIHRleHRvIGVuIGVsIHJlbGVhc2UgcGFyYSBldml0YXIgZG9ibGUgZXNjYWxhZG9cclxuICAgICAgICAgICAgLy8gKGVzY2FsYSBkZWwgbm9kbyArIGZvbnRTaXplIHBlcnNpc3RpZG8pLlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikgbm9kZS5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiKSBub2RlLnNjYWxlWSgxKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZpbmFsRGF0YS5mb250U2l6ZSkgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLmZvbnRTaXplID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZm9udFNpemUoZmluYWxEYXRhLmZvbnRTaXplKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2VudGVyWCA9IE51bWJlcihmaW5hbERhdGEudGV4dENlbnRlclgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldENlbnRlclkgPSBOdW1iZXIoZmluYWxEYXRhLnRleHRDZW50ZXJZKTtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAoTnVtYmVyLmlzRmluaXRlKHRhcmdldENlbnRlclgpIHx8IE51bWJlci5pc0Zpbml0ZSh0YXJnZXRDZW50ZXJZKSkgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLnggPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUueSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuZWRSZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuZWRDZW50ZXJYID1cclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkUmVjdD8ueCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkUmVjdD8ud2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IGZsYXR0ZW5lZFJlY3QueCArIChmbGF0dGVuZWRSZWN0LndpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkQ2VudGVyWSA9XHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZsYXR0ZW5lZFJlY3Q/LnkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZsYXR0ZW5lZFJlY3Q/LmhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgID8gZmxhdHRlbmVkUmVjdC55ICsgKGZsYXR0ZW5lZFJlY3QuaGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkQ2VudGVyWCkgJiYgTnVtYmVyLmlzRmluaXRlKHRhcmdldENlbnRlclgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54KG5vZGUueCgpICsgKHRhcmdldENlbnRlclggLSBmbGF0dGVuZWRDZW50ZXJYKSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRDZW50ZXJZKSAmJiBOdW1iZXIuaXNGaW5pdGUodGFyZ2V0Q2VudGVyWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkobm9kZS55KCkgKyAodGFyZ2V0Q2VudGVyWSAtIGZsYXR0ZW5lZENlbnRlclkpKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgbm9kZS5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgYXBsYW5hbmRvIGVzY2FsYSBkZSB0ZXh0byAoc3luYyk6XCIsIGVycik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghY2FuVXNlUmVjdFNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGZpbmFsRGF0YS54ID0gbm9kZS54KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IG5vZGUueSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGFyYSB0ZXh0byBldml0YW1vcyBhcGxhbmFyIGFudGVzIGRlbCBjb21taXQgZW4gUmVhY3QsXHJcbiAgICAgICAgICAgIC8vIGFzw60gbm8gYXBhcmVjZSB1biBmcmFtZSBpbnRlcm1lZGlvIGNvbiB0YW1hw7FvIFwic2FsdGFkb1wiLlxyXG4gICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcclxuICAgICAgICAgICAgaWYgKHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImNvdW50ZG93blwiKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ291bnRkb3duOiBwZXJzaXN0aXIgZXNjYWxhIHJlYWwgcGFyYSBxdWUgZWwgcmVzdWx0YWRvIGZpbmFsXHJcbiAgICAgICAgICAgICAgLy8gc2VhIGV4YWN0YW1lbnRlIGVsIG1pc21vIHF1ZSBzZSB2ZSBhbCBzb2x0YXIuXHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWCA9IHNjYWxlWDtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50ZG93blNpemUgPSBnZXRDb3VudGRvd25TY2FsZWRTaXplKG5vZGUpO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS53aWR0aCA9IGNvdW50ZG93blNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLmhlaWdodCA9IGNvdW50ZG93blNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVzVHJpYW5ndWxvKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVJhZGl1cyA9IE51bWJlci5pc0Zpbml0ZShwcmltZXJFbGVtZW50bz8ucmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgPyBwcmltZXJFbGVtZW50by5yYWRpdXNcclxuICAgICAgICAgICAgICAgIDogNjA7XHJcbiAgICAgICAgICAgICAgY29uc3QgYXZnU2NhbGUgPSAoTWF0aC5hYnMoc2NhbGVYKSArIE1hdGguYWJzKHNjYWxlWSkpIC8gMjtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEucmFkaXVzID0gTWF0aC5tYXgoMSwgYmFzZVJhZGl1cyAqIGF2Z1NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zY2FsZVkoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUucmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIG5vZGUucmFkaXVzKGZpbmFsRGF0YS5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGFwbGFuYW5kbyBlc2NhbGEgZGUgdHJpw6FuZ3VsbyAoc3luYyk6XCIsIGVycik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsV2lkdGggPSBwcmltZXJFbGVtZW50by53aWR0aCB8fCAxMDA7XHJcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSBwcmltZXJFbGVtZW50by5oZWlnaHQgfHwgMTAwO1xyXG5cclxuICAgICAgICAgICAgICBmaW5hbERhdGEud2lkdGggPSBNYXRoLmFicyhvcmlnaW5hbFdpZHRoICogc2NhbGVYKTtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuaGVpZ2h0ID0gTWF0aC5hYnMob3JpZ2luYWxIZWlnaHQgKiBzY2FsZVkpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgbGl2ZVJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRpYW1ldGVyID0gTWF0aC5tYXgoMSwgTWF0aC5tYXgobGl2ZVJlY3Qud2lkdGgsIGxpdmVSZWN0LmhlaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgICBmaW5hbERhdGEucmFkaXVzID0gZGlhbWV0ZXIgLyAyO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBjaXJjbGVBbmNob3JSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgaWYgKGFuY2hvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS54ID0gYW5jaG9yLmxlZnQgKyBmaW5hbERhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS55ID0gYW5jaG9yLnRvcCArIGZpbmFsRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnggPSBsaXZlUmVjdC54ICsgZmluYWxEYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IGxpdmVSZWN0LnkgKyBmaW5hbERhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyDinIUgQXBsYW5hciBlc2NhbGEgSU5NRURJQVRPXHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZ3ID0gZmluYWxEYXRhLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmggPSBmaW5hbERhdGEuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIG5vZGUuc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zY2FsZVkoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZ3ICE9IG51bGwgJiYgdHlwZW9mIG5vZGUud2lkdGggPT09IFwiZnVuY3Rpb25cIikgbm9kZS53aWR0aChmdyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmggIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZS5oZWlnaHQgPT09IFwiZnVuY3Rpb25cIikgbm9kZS5oZWlnaHQoZmgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgcHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIiAmJlxyXG4gICAgICAgICAgICAgICAgICBmaW5hbERhdGEucmFkaXVzICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUucmFkaXVzID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICBub2RlLnJhZGl1cyhmaW5hbERhdGEucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBub2RlLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgYXBsYW5hbmRvIGVzY2FsYXMgKHN5bmMpOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG9uVHJhbnNmb3JtKGZpbmFsRGF0YSk7XHJcbiAgICAgICAgICBjaXJjbGVBbmNob3JSZWYuY3VycmVudCA9IG51bGw7XHJcblxyXG5cclxuICAgICAgICAgIC8vIOKchSBSZWF0YWNoYXIgMSB2ZXosIGNvbiByZWYgZnJlc2NvLCBlbiBlbCBwcsOzeGltbyBmcmFtZVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdHIyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgaWYgKCF0cjIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIFRSREJHKFwib25UcmFuc2Zvcm1FbmQgLT4gc2NoZWR1bGUgUkFGIHJlYXR0YWNoXCIsIHtcclxuICAgICAgICAgICAgICBzZWxLZXk6IHNlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIiksXHJcbiAgICAgICAgICAgICAgaWRTZWw6IHNlbGVjdGVkRWxlbWVudHM/LlswXSB8fCBudWxsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBpZFNlbCA9IHNlbGVjdGVkRWxlbWVudHM/LlswXTtcclxuICAgICAgICAgICAgICBjb25zdCBmcmVzaE5vZGUgPSBpZFNlbCA/IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltpZFNlbF0gOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIFJBRlwiLCB7XHJcbiAgICAgICAgICAgICAgICBpZFNlbCxcclxuICAgICAgICAgICAgICAgIGhhc0ZyZXNoOiAhIWZyZXNoTm9kZSxcclxuICAgICAgICAgICAgICAgIGRlc3Ryb3llZDogISFmcmVzaE5vZGU/Ll9kZXN0cm95ZWQsXHJcbiAgICAgICAgICAgICAgICBoYXNTdGFnZTogISFmcmVzaE5vZGU/LmdldFN0YWdlPy4oKSxcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU2kgZWwgbm9kbyBubyBlc3TDoSBsaXN0bywgZGVzcGVnYXIgeSBzYWxpclxyXG4gICAgICAgICAgICAgIGlmICghZnJlc2hOb2RlIHx8IGZyZXNoTm9kZS5fZGVzdHJveWVkIHx8ICFmcmVzaE5vZGUuZ2V0U3RhZ2U/LigpKSB7XHJcbiAgICAgICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIFJBRiAtPiBERVRBQ0ggbm9kZXMoW10pXCIsIHsgaWRTZWwgfSk7XHJcbiAgICAgICAgICAgICAgICB0cnkgeyB0cjIubm9kZXMoW10pOyB0cjIuZ2V0TGF5ZXI/LigpPy5iYXRjaERyYXcoKTsgfSBjYXRjaCB7IH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIFJBRiAtPiBERVRBQ0ggbm9kZXMoW10pXCIsIHsgaWRTZWwgfSk7XHJcbiAgICAgICAgICAgICAgICB0cjIubm9kZXMoW2ZyZXNoTm9kZV0pO1xyXG4gICAgICAgICAgICAgICAgdHIyLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0cjIuZ2V0TGF5ZXI/LigpPy5iYXRjaERyYXcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dFByZXZpZXdFbmRTbmFwc2hvdCAmJiBmcmVzaE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0UmVjdCA9IGZyZXNoTm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgVFhUREJHKFwicG9zdC1jb21taXQ6cmFmMVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZDogaWRTZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwcmU6IHRleHRQcmV2aWV3RW5kU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHR5cGVvZiBmcmVzaE5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS54KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0eXBlb2YgZnJlc2hOb2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUueSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVYOiB0eXBlb2YgZnJlc2hOb2RlPy5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS5zY2FsZVgoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWTogdHlwZW9mIGZyZXNoTm9kZT8uc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUuc2NhbGVZKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogdHlwZW9mIGZyZXNoTm9kZT8uZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS5mb250U2l6ZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpZHRoOiBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LndpZHRoKSA/IHBvc3RSZWN0LndpZHRoIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdEhlaWdodDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Py5oZWlnaHQpID8gcG9zdFJlY3QuaGVpZ2h0IDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LndpZHRoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKHBvc3RSZWN0LndpZHRoIC0gdGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LmhlaWdodCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3QuaGVpZ2h0IC0gdGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyZXNoTm9kZTIgPSBpZFNlbCA/IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltpZFNlbF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJlc2hOb2RlMikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0UmVjdDIgPSBmcmVzaE5vZGUyLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgVFhUREJHKFwicG9zdC1jb21taXQ6cmFmMlwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFNlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHR5cGVvZiBmcmVzaE5vZGUyPy54ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLngoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdHlwZW9mIGZyZXNoTm9kZTI/LnkgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZTIueSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVg6IHR5cGVvZiBmcmVzaE5vZGUyPy5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZTIuc2NhbGVYKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWTogdHlwZW9mIGZyZXNoTm9kZTI/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi5zY2FsZVkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHR5cGVvZiBmcmVzaE5vZGUyPy5mb250U2l6ZSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi5mb250U2l6ZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0V2lkdGg6IE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdDI/LndpZHRoKSA/IHBvc3RSZWN0Mi53aWR0aCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdEhlaWdodDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Mj8uaGVpZ2h0KSA/IHBvc3RSZWN0Mi5oZWlnaHQgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUZyb21QcmU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdDI/LndpZHRoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChwb3N0UmVjdDIud2lkdGggLSB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdDI/LmhlaWdodCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKHBvc3RSZWN0Mi5oZWlnaHQgLSB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCB7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIHsgfVxyXG5cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGVuIG9uVHJhbnNmb3JtRW5kOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSBudWxsO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICBzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmUoZmFsc2UpO1xyXG4gICAgICAgICAgY2xlYXJSZXNpemVBbmNob3JQcmVzc0ZlZWRiYWNrKCk7XHJcbiAgICAgICAgICBub3RpZnlUcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfX1cclxuXHJcbiAgICAvPlxyXG4gICk7XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlRyYW5zZm9ybWVyIiwiUmVjdCIsIkRFQlVHX1NFTEVDVElPTl9CT1VORFMiLCJzYkxvZyIsImFyZ3MiLCJjb25zb2xlIiwibG9nIiwic2xvZyIsIlRSREJHIiwid2luZG93IiwiX19EQkdfVFIiLCJUWFREQkciLCJfX0RCR19URVhUX1JFU0laRSIsInJlY3RGcm9tTm9kZXMiLCJub2RlcyIsIm1pblgiLCJJbmZpbml0eSIsIm1pblkiLCJtYXhYIiwibWF4WSIsIm4iLCJnZXRDbGllbnRSZWN0IiwiciIsInNraXBUcmFuc2Zvcm0iLCJza2lwU2hhZG93Iiwic2tpcFN0cm9rZSIsIk1hdGgiLCJtaW4iLCJ4IiwieSIsIm1heCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0Q291bnRkb3duU2NhbGVkU2l6ZSIsIm5vZGUiLCJoaXRib3giLCJmaW5kT25lIiwiYmFzZVciLCJOYU4iLCJiYXNlSCIsInN4IiwiYWJzIiwic2NhbGVYIiwic3kiLCJzY2FsZVkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkJvdW5kc0luZGljYXRvciIsInNlbGVjdGVkRWxlbWVudHMiLCJlbGVtZW50UmVmcyIsIm9iamV0b3MiLCJmb3JjZVVwZGF0ZSIsInNldEZvcmNlVXBkYXRlIiwiZmlyc3RSZWYiLCJjdXJyZW50Iiwic3RhZ2UiLCJnZXRTdGFnZSIsImhhbmRsZURyYWdNb3ZlIiwicCIsIm9uIiwib2ZmIiwiam9pbiIsImVsZW1lbnRvc0RhdGEiLCJtYXAiLCJpZCIsImZpbmQiLCJvYmoiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwiZm9yRWFjaCIsInRpcG8iLCJmaWd1cmEiLCJwb2ludHMiLCJjbGVhblBvaW50cyIsInBhcnNlRmxvYXQiLCJyZWFsWCIsInJlYWxZIiwieDEiLCJ5MSIsIngyIiwieTIiLCJsaW5lUGFkZGluZyIsImJveCIsInRvRml4ZWQiLCJnZXRUZXh0SGVpZ2h0IiwidGV4dEhlaWdodCIsImVycm9yIiwiZmFsbGJhY2tYIiwiZmFsbGJhY2tZIiwiZmFsbGJhY2tTaXplIiwicHJpbWVyRWxlbWVudG8iLCJwYWRkaW5nIiwiZmluYWxYIiwiZmluYWxZIiwiZmluYWxXaWR0aCIsImZpbmFsSGVpZ2h0IiwibmFtZSIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsImxpc3RlbmluZyIsIm9wYWNpdHkiLCJTZWxlY3Rpb25Cb3VuZHMiLCJvblRyYW5zZm9ybSIsIm9uVHJhbnNmb3JtSW50ZXJhY3Rpb25TdGFydCIsIm9uVHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQiLCJpc0RyYWdnaW5nIiwiaXNNb2JpbGUiLCJ0cmFuc2Zvcm1lclJlZiIsInRyYW5zZm9ybVRpY2siLCJzZXRUcmFuc2Zvcm1UaWNrIiwibGFzdE5vZGVzUmVmIiwiY2lyY2xlQW5jaG9yUmVmIiwidGV4dFRyYW5zZm9ybUFuY2hvclJlZiIsInRyYW5zZm9ybUdlc3R1cmVSZWYiLCJpc1JvdGF0ZSIsImFjdGl2ZUFuY2hvciIsImlzVHJhbnNmb3JtaW5nUmVzaXplUmVmIiwiaXNSZXNpemVHZXN0dXJlQWN0aXZlIiwic2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlIiwicHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUiLCJzZXRQcmVzc2VkUmVzaXplQW5jaG9yTmFtZSIsImVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhIiwiZXNUZXh0byIsImVzQ291bnRkb3duIiwiZXNHYWxlcmlhIiwibG9ja0FzcGVjdENvdW50ZG93biIsImxvY2tBc3BlY3RUZXh0IiwidHJhbnNmb3JtZXJBbmNob3JTaXplIiwidHJhbnNmb3JtZXJSb3RhdGVPZmZzZXQiLCJ0cmFuc2Zvcm1lckFuY2hvclJhZGl1cyIsInRyYW5zZm9ybWVyUGFkZGluZyIsInRyYW5zZm9ybWVyQm9yZGVyU3Ryb2tlV2lkdGgiLCJ0cmFuc2Zvcm1lckFuY2hvckZpbGxDb2xvciIsInRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlV2lkdGgiLCJ0cmFuc2Zvcm1lckFuY2hvclNoYWRvd0JsdXIiLCJ0cmFuc2Zvcm1lckFuY2hvclNoYWRvd09mZnNldFkiLCJ0cmFuc2Zvcm1lckFuY2hvckhpdFN0cm9rZVdpZHRoIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGl0U3Ryb2tlV2lkdGgiLCJ0cmFuc2Zvcm1lckFuY2hvclN0cm9rZUNvbG9yIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGFsb1N0cm9rZUNvbG9yIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGFsb1N0cm9rZVdpZHRoIiwidHJhbnNmb3JtZXJBbmNob3JTaGFkb3dDb2xvciIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0NvbG9yIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93Qmx1ciIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd09mZnNldFkiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTY2FsZSIsInRyYW5zZm9ybWVyUm90YXRpb25TbmFwVG9sZXJhbmNlIiwiZXNUcmlhbmd1bG8iLCJoYXNHYWxsZXJ5Iiwic29tZSIsIm8iLCJoYXlMaW5lYXMiLCJlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcyIsImRlYmVyaWFVc2FyVHJhbnNmb3JtZXIiLCJzZWxlY3RlZEdlb21LZXkiLCJyb3RhdGlvbiIsImNoaXBXaWR0aCIsImdhcCIsInBhZGRpbmdYIiwicGFkZGluZ1kiLCJnZXRUcmFuc2Zvcm1Qb3NlIiwiZ2V0UGFyZW50IiwicGFyZW50IiwiY2xlYXJSZXNpemVBbmNob3JQcmVzc0ZlZWRiYWNrIiwiZ2V0UmVzaXplQW5jaG9yTmFtZUZyb21UYXJnZXQiLCJ0YXJnZXQiLCJpc0FuY2hvclRhcmdldCIsImhhc05hbWUiLCJTdHJpbmciLCJpbmNsdWRlcyIsInJhd05hbWUiLCJhbmNob3JOYW1lIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImhhbmRsZVJlc2l6ZUFuY2hvclByZXNzU3RhcnQiLCJldmVudCIsImdldEFjdGl2ZUFuY2hvciIsImdldEJveE92ZXJmbG93QW1vdW50Iiwic3RhZ2VXaWR0aCIsInN0YWdlSGVpZ2h0IiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJvdmVyZmxvd0xlZnQiLCJvdmVyZmxvd1RvcCIsIm92ZXJmbG93UmlnaHQiLCJvdmVyZmxvd0JvdHRvbSIsImtlZXBCb3hJbnNpZGVTdGFnZSIsIm9sZEJveCIsIm5leHRCb3giLCJ0ciIsImF0dHJzIiwib2xkT3ZlcmZsb3ciLCJuZXh0T3ZlcmZsb3ciLCJlcHNpbG9uIiwic2VsS2V5IiwiZWxlbWVudG9zVHJhbnNmb3JtYWJsZXNMZW4iLCJlZGl0aW5nSWQiLCJlZGl0aW5nIiwibm9kb3NUcmFuc2Zvcm1hYmxlcyIsImlkU2VsIiwicmVmTm9kZSIsImdhbGxlcnlGcmFtZSIsIndhbnRlZElkcyIsInJlZnNQcmVzZW50Iiwibm9kZXNDb3VudCIsIm5vZGVJZHMiLCJ0ck5vZGVzQ291bnQiLCJnZXRMYXllciIsImJhdGNoRHJhdyIsImhhbmRsZXIiLCJlIiwiZGV0YWlsIiwiaXNTZWxlY3RlZCIsInQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZpcnN0Tm9kZSIsImZpcnN0SWQiLCJyYWZJZCIsInN5bmNUcmFuc2Zvcm1lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIiwiYm9yZGVyRW5hYmxlZCIsImJvcmRlclN0cm9rZSIsImJvcmRlclN0cm9rZVdpZHRoIiwiZW5hYmxlZEFuY2hvcnMiLCJyb3RhdGVFbmFibGVkIiwib25Nb3VzZURvd24iLCJvblRvdWNoU3RhcnQiLCJvblBvaW50ZXJEb3duIiwib25Nb3VzZVVwIiwib25Ub3VjaEVuZCIsIm9uUG9pbnRlclVwIiwib25Ub3VjaENhbmNlbCIsIm9uUG9pbnRlckNhbmNlbCIsImFuY2hvckZpbGwiLCJhbmNob3JTdHJva2UiLCJhbmNob3JTdHJva2VXaWR0aCIsImFuY2hvclNpemUiLCJhbmNob3JDb3JuZXJSYWRpdXMiLCJhbmNob3JTaGFkb3dDb2xvciIsImFuY2hvclNoYWRvd0JsdXIiLCJhbmNob3JTaGFkb3dPZmZzZXQiLCJhbmNob3JTdHlsZUZ1bmMiLCJhbmNob3IiLCJpc1Jlc2l6ZUFuY2hvck5vZGUiLCJpc1Jlc2l6ZUFjdGl2ZUZhbGxiYWNrIiwiX3Jlc2l6ZURhdGEiLCJpc1Jlc2l6aW5nIiwiaXNQcmVzc2VkUmVzaXplQW5jaG9yIiwic2hhZG93Q29sb3IiLCJzaGFkb3dFbmFibGVkIiwic2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCIsInNoYWRvd09wYWNpdHkiLCJzaGFkb3dCbHVyIiwic2hhZG93T2Zmc2V0IiwiaGl0U3Ryb2tlV2lkdGgiLCJhbmNob3JTY2FsZSIsInNjYWxlIiwia2VlcFJhdGlvIiwiY2VudGVyZWRTY2FsaW5nIiwiZmxpcEVuYWJsZWQiLCJyZXNpemVFbmFibGVkIiwicm90YXRpb25TbmFwcyIsInJvdGF0ZUFuY2hvck9mZnNldCIsInJvdGF0aW9uU25hcFRvbGVyYW5jZSIsImJvdW5kQm94RnVuYyIsIm5ld0JveCIsIm1pblNpemUiLCJtYXhTaXplIiwicm93cyIsImNvbHMiLCJjZWxsUmF0aW8iLCJyYXRpbyIsIm1pbkdyaWRXaWR0aCIsIm5leHRXaWR0aCIsImNlbGxXIiwiY2VsbEgiLCJuZXh0SGVpZ2h0IiwiZHciLCJkaCIsInNpemUiLCJmaW5hbFNpemUiLCJzYWZlT2xkVyIsInNhZmVPbGRIIiwidW5pZm9ybVNjYWxlIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJvblRyYW5zZm9ybVN0YXJ0IiwiaXNSb3RhdGVHZXN0dXJlIiwicG9pbnRlclR5cGUiLCJldnQiLCJyMCIsImNlbnRlclgiLCJjZW50ZXJZIiwiYmFzZVdpZHRoIiwiYmFzZUhlaWdodCIsImJhc2VWaXN1YWxXaWR0aCIsInJlY3QiLCJzYWZlQmFzZUZvbnRTaXplIiwiZm9udFNpemUiLCJiYXNlUm90YXRpb24iLCJiYXNlRm9udFNpemUiLCJsYXN0UHJldmlld0ZvbnRTaXplIiwibGFzdFByZXZpZXdDZW50ZXJYIiwibGFzdFByZXZpZXdDZW50ZXJZIiwibGFzdFByZXZpZXdWaXN1YWxXaWR0aCIsInByZXZpZXdUaWNrIiwibm9kZVgiLCJub2RlWSIsIm5vZGVTY2FsZVgiLCJub2RlU2NhbGVZIiwidW5pb24iLCJwYWQiLCJib3JkZXJSZWN0IiwidHJSZWN0IiwicG9zZSIsInRyYW5zZm9ybURhdGEiLCJpc1ByZXZpZXciLCJvcmlnaW5hbEZvbnRTaXplIiwiYW5jaG9yRGF0YSIsImF2Z1NjYWxlIiwic2NhbGVGcm9tUmVjdCIsImxpdmVSZWN0V2lkdGgiLCJjdXJyZW50Um90YXRpb24iLCJyb3RhdGlvbkRlbHRhIiwiY2FuVXNlUmVjdFNjYWxlIiwiZWZmZWN0aXZlU2NhbGUiLCJ0aWNrIiwiY2VudGVyWFRhcmdldCIsInRleHRDZW50ZXJYIiwidGV4dENlbnRlclkiLCJjb3VudGRvd25TaXplIiwiYmFzZVJhZGl1cyIsInJhZGl1cyIsIm9yaWdpbmFsV2lkdGgiLCJvcmlnaW5hbEhlaWdodCIsImxpdmVSZWN0IiwiZGlhbWV0ZXIiLCJ3YXJuIiwib25UcmFuc2Zvcm1FbmQiLCJpbnRlcmFjdGlvblNuYXBzaG90Iiwibm90aWZ5VHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQiLCJ0U2NhbGVYIiwidFNjYWxlWSIsImF2ZyIsInVwZGF0ZXMiLCJ1cGQiLCJiYXNlIiwicm91bmQiLCJiYXNlUiIsImlzRmluYWwiLCJiYXRjaCIsInNldFRpbWVvdXQiLCJlcnIiLCJmaW5hbERhdGEiLCJ0ZXh0UHJldmlld0VuZFNuYXBzaG90IiwidmlzdWFsV2lkdGhGcm9tUmVjdCIsImNvbXB1dGVkRm9udFNpemUiLCJ2aXN1YWxXaWR0aCIsInRleHRWaXN1YWxXaWR0aCIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJyZWN0Rm9yU25hcHNob3QiLCJmaW5hbEZvbnRTaXplIiwibm9kZVJlY3RXaWR0aCIsInRhcmdldENlbnRlclgiLCJ0YXJnZXRDZW50ZXJZIiwiZmxhdHRlbmVkUmVjdCIsImZsYXR0ZW5lZENlbnRlclgiLCJmbGF0dGVuZWRDZW50ZXJZIiwiZnciLCJmaCIsInRyMiIsImZyZXNoTm9kZSIsImhhc0ZyZXNoIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3llZCIsImhhc1N0YWdlIiwicG9zdFJlY3QiLCJwcmUiLCJwb3N0IiwiZGVsdGEiLCJmcmVzaE5vZGUyIiwicG9zdFJlY3QyIiwiZGVsdGFGcm9tUHJlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/SelectionBounds.jsx\n"));

/***/ })

});