"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/components/SelectionBounds.jsx":
/*!********************************************!*\
  !*** ./src/components/SelectionBounds.jsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectionBounds)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-konva */ \"(pages-dir-browser)/./node_modules/react-konva/es/ReactKonva.js\");\n// SelectionBounds.jsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst DEBUG_SELECTION_BOUNDS = false;\nconst sbLog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!DEBUG_SELECTION_BOUNDS) return;\n    console.log(\"[SB]\", ...args);\n};\nconst slog = sbLog;\nconst TRDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!window.__DBG_TR) return;\n    console.log(\"[TRDBG]\", ...args);\n};\n_c = TRDBG;\nconst TXTDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n    if (!window.__DBG_TEXT_RESIZE) return;\n    console.log(\"[TEXT-TR]\", ...args);\n};\n_c1 = TXTDBG;\nfunction rectFromNodes(nodes) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for (const n of nodes){\n        if (!(n === null || n === void 0 ? void 0 : n.getClientRect)) continue;\n        const r = n.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        minX = Math.min(minX, r.x);\n        minY = Math.min(minY, r.y);\n        maxX = Math.max(maxX, r.x + r.width);\n        maxY = Math.max(maxY, r.y + r.height);\n    }\n    if (minX === Infinity) return null;\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getCountdownScaledSize(node) {\n    try {\n        var _node_findOne;\n        const hitbox = node === null || node === void 0 ? void 0 : (_node_findOne = node.findOne) === null || _node_findOne === void 0 ? void 0 : _node_findOne.call(node, \".countdown-hitbox\");\n        const baseW = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.width) === \"function\" ? hitbox.width() : NaN;\n        const baseH = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.height) === \"function\" ? hitbox.height() : NaN;\n        const sx = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() || 1 : 1);\n        const sy = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() || 1 : 1);\n        if (Number.isFinite(baseW) && Number.isFinite(baseH) && baseW > 0 && baseH > 0) {\n            return {\n                width: Math.abs(baseW * sx),\n                height: Math.abs(baseH * sy)\n            };\n        }\n    } catch (e) {}\n    try {\n        const r = node.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        return {\n            width: Math.abs(r.width),\n            height: Math.abs(r.height)\n        };\n    } catch (e) {}\n    return {\n        width: 100,\n        height: 50\n    };\n}\n// ðŸŽ¨ Componente para mostrar bounds sin transformer (lÃ­neas, etc.)\nconst BoundsIndicator = (param)=>{\n    let { selectedElements, elementRefs, objetos } = param;\n    _s();\n    const [forceUpdate, setForceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"BoundsIndicator.useEffect\": ()=>{\n            var _elementRefs_current, _firstRef_getStage;\n            const firstRef = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[selectedElements[0]];\n            const stage = firstRef === null || firstRef === void 0 ? void 0 : (_firstRef_getStage = firstRef.getStage) === null || _firstRef_getStage === void 0 ? void 0 : _firstRef_getStage.call(firstRef);\n            if (!stage) return;\n            const handleDragMove = {\n                \"BoundsIndicator.useEffect.handleDragMove\": ()=>{\n                    setForceUpdate({\n                        \"BoundsIndicator.useEffect.handleDragMove\": (p)=>p + 1\n                    }[\"BoundsIndicator.useEffect.handleDragMove\"]);\n                }\n            }[\"BoundsIndicator.useEffect.handleDragMove\"];\n            stage.on(\"dragmove\", handleDragMove);\n            return ({\n                \"BoundsIndicator.useEffect\": ()=>{\n                    stage.off(\"dragmove\", handleDragMove);\n                }\n            })[\"BoundsIndicator.useEffect\"];\n        }\n    }[\"BoundsIndicator.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    const elementosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    if (elementosData.length === 0) {\n        return null;\n    }\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    elementosData.forEach((obj)=>{\n        const node = elementRefs.current[obj.id];\n        if (!node) return;\n        try {\n            if (obj.tipo === \"forma\" && obj.figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    100,\n                    0\n                ];\n                const cleanPoints = [\n                    parseFloat(points[0]) || 0,\n                    parseFloat(points[1]) || 0,\n                    parseFloat(points[2]) || 100,\n                    parseFloat(points[3]) || 0\n                ];\n                const realX = node.x();\n                const realY = node.y();\n                const x1 = realX + cleanPoints[0];\n                const y1 = realY + cleanPoints[1];\n                const x2 = realX + cleanPoints[2];\n                const y2 = realY + cleanPoints[3];\n                const linePadding = 5;\n                minX = Math.min(minX, x1 - linePadding, x2 - linePadding);\n                minY = Math.min(minY, y1 - linePadding, y2 - linePadding);\n                maxX = Math.max(maxX, x1 + linePadding, x2 + linePadding);\n                maxY = Math.max(maxY, y1 + linePadding, y2 + linePadding);\n            } else {\n                var _node_scaleX, _node_scaleY;\n                const box = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                const r = box;\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = node === null || node === void 0 ? void 0 : (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = node === null || node === void 0 ? void 0 : (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                slog(\"[BI]\", \"id=\".concat(obj.id), \"tipo=\".concat(obj.tipo), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"rect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"));\n                const realX = box.x;\n                const realY = box.y;\n                let width = box.width;\n                let height = box.height;\n                if (obj.tipo === \"texto\" && node.getTextHeight) {\n                    const textHeight = node.getTextHeight();\n                    if (textHeight) {\n                        height = textHeight;\n                    }\n                }\n                minX = Math.min(minX, realX);\n                minY = Math.min(minY, realY);\n                maxX = Math.max(maxX, realX + width);\n                maxY = Math.max(maxY, realY + height);\n            }\n        } catch (error) {\n            const fallbackX = obj.x || 0;\n            const fallbackY = obj.y || 0;\n            const fallbackSize = 20;\n            minX = Math.min(minX, fallbackX);\n            minY = Math.min(minY, fallbackY);\n            maxX = Math.max(maxX, fallbackX + fallbackSize);\n            maxY = Math.max(maxY, fallbackY + fallbackSize);\n        }\n    });\n    if (minX === Infinity || maxX === -Infinity) {\n        const primerElemento = elementosData[0];\n        if (!primerElemento) return null;\n        minX = primerElemento.x || 0;\n        minY = primerElemento.y || 0;\n        maxX = minX + 100;\n        maxY = minY + 50;\n    }\n    const padding = 10;\n    const finalX = minX - padding;\n    const finalY = minY - padding;\n    const finalWidth = maxX - minX + padding * 2;\n    const finalHeight = maxY - minY + padding * 2;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, {\n        name: \"ui\",\n        x: finalX,\n        y: finalY,\n        width: finalWidth,\n        height: finalHeight,\n        fill: \"transparent\",\n        stroke: \"#9333EA\",\n        strokeWidth: 1,\n        listening: false,\n        opacity: 0.7\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 188,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BoundsIndicator, \"X1gDcjpboC/BQr7oI4aemyzw8+o=\");\n_c2 = BoundsIndicator;\nfunction SelectionBounds(param) {\n    let { selectedElements, elementRefs, objetos, onTransform, onTransformInteractionStart = null, onTransformInteractionEnd = null, isDragging, isMobile = false } = param;\n    _s1();\n    const transformerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [transformTick, setTransformTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const lastNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const circleAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textTransformAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const transformGestureRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        isRotate: false,\n        activeAnchor: null\n    });\n    const isTransformingResizeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const [isResizeGestureActive, setIsResizeGestureActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [pressedResizeAnchorName, setPressedResizeAnchorName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const elementosSeleccionadosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    const primerElemento = elementosSeleccionadosData[0] || null;\n    const esTexto = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"texto\";\n    const esCountdown = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\";\n    const esGaleria = selectedElements.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"galeria\";\n    const lockAspectCountdown = selectedElements.length === 1 && esCountdown;\n    const lockAspectText = selectedElements.length === 1 && esTexto;\n    const transformerAnchorSize = isMobile ? 32 : 14; //tamaÃ±o visual del nodo (mÃ¡s grande en mobile).\n    const transformerRotateOffset = isMobile ? 34 : 24; // distancia del handle de rotaciÃ³n al borde.\n    const transformerAnchorRadius = 999; //radio de esquina del nodo (999 lo hace circular).\n    const transformerPadding = isMobile ? 14 : 4; // espacio extra entre borde del transformer y elemento.\n    const transformerBorderStrokeWidth = isMobile ? 1.5 : 1; //grosor del borde del transformer.\n    const transformerAnchorFillColor = \"#9333EA\";\n    const transformerAnchorStrokeWidth = isMobile ? 1.4 : 2.5; //grosor del borde del nodo.\n    const transformerAnchorShadowBlur = isMobile ? 9 : 6; // quÃ© tan difusa es la sombra base del nodo.\n    const transformerAnchorShadowOffsetY = isMobile ? 4 : 3; // desplazamiento vertical de esa sombra.\n    const transformerAnchorHitStrokeWidth = isMobile ? 62 : 20;\n    const transformerAnchorPressedHitStrokeWidth = isMobile ? 96 : 24;\n    const transformerAnchorStrokeColor = \"#ffffff\";\n    const transformerAnchorPressedHaloStrokeColor = isMobile ? \"rgba(255, 255, 255, 0.95)\" : transformerAnchorStrokeColor;\n    const transformerAnchorPressedHaloStrokeWidth = isMobile ? 2.2 : 3.2;\n    const transformerAnchorShadowColor = \"rgba(147, 51, 234, 0.3)\";\n    const transformerAnchorPressedShadowColor = isMobile ? \"rgba(224, 168, 255, 1)\" : \"rgba(147, 51, 234, 0.7)\";\n    const transformerAnchorPressedShadowBlur = isMobile ? 180 : 18;\n    const transformerAnchorPressedShadowOffsetY = isMobile ? 0 : transformerAnchorShadowOffsetY + 1;\n    const transformerAnchorPressedScale = isMobile ? 1.03 : 1.1;\n    const transformerRotationSnapTolerance = isMobile ? 8 : 5; //tolerancia para â€œencajarâ€ rotaciÃ³n en Ã¡ngulos fijos.\n    const esTriangulo = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"triangle\";\n    const hasGallery = elementosSeleccionadosData.some((o)=>o.tipo === \"galeria\");\n    const hayLineas = elementosSeleccionadosData.some((obj)=>obj.tipo === \"forma\" && obj.figura === \"line\");\n    const elementosTransformables = elementosSeleccionadosData.filter((obj)=>!(obj.tipo === \"forma\" && obj.figura === \"line\"));\n    const deberiaUsarTransformer = elementosTransformables.length > 0;\n    const selectedGeomKey = elementosSeleccionadosData.map((o)=>{\n        var _o_x, _o_y, _o_width, _o_height, _o_scaleX, _o_scaleY, _o_rotation, _o_chipWidth, _o_gap, _o_paddingX, _o_paddingY;\n        return [\n            o.id,\n            (_o_x = o.x) !== null && _o_x !== void 0 ? _o_x : 0,\n            (_o_y = o.y) !== null && _o_y !== void 0 ? _o_y : 0,\n            (_o_width = o.width) !== null && _o_width !== void 0 ? _o_width : \"\",\n            (_o_height = o.height) !== null && _o_height !== void 0 ? _o_height : \"\",\n            (_o_scaleX = o.scaleX) !== null && _o_scaleX !== void 0 ? _o_scaleX : 1,\n            (_o_scaleY = o.scaleY) !== null && _o_scaleY !== void 0 ? _o_scaleY : 1,\n            (_o_rotation = o.rotation) !== null && _o_rotation !== void 0 ? _o_rotation : 0,\n            (_o_chipWidth = o.chipWidth) !== null && _o_chipWidth !== void 0 ? _o_chipWidth : \"\",\n            (_o_gap = o.gap) !== null && _o_gap !== void 0 ? _o_gap : \"\",\n            (_o_paddingX = o.paddingX) !== null && _o_paddingX !== void 0 ? _o_paddingX : \"\",\n            (_o_paddingY = o.paddingY) !== null && _o_paddingY !== void 0 ? _o_paddingY : \"\"\n        ].join(\":\");\n    }).join(\"|\");\n    const getTransformPose = (node)=>{\n        if (!node) return {\n            x: 0,\n            y: 0,\n            rotation: 0\n        };\n        if (esGaleria && typeof node.getParent === \"function\") {\n            const parent = node.getParent();\n            if (parent) {\n                return {\n                    x: typeof parent.x === \"function\" ? parent.x() : 0,\n                    y: typeof parent.y === \"function\" ? parent.y() : 0,\n                    rotation: typeof parent.rotation === \"function\" ? parent.rotation() || 0 : 0\n                };\n            }\n        }\n        return {\n            x: typeof node.x === \"function\" ? node.x() : 0,\n            y: typeof node.y === \"function\" ? node.y() : 0,\n            rotation: typeof node.rotation === \"function\" ? node.rotation() || 0 : 0\n        };\n    };\n    const clearResizeAnchorPressFeedback = ()=>{\n        if (isTransformingResizeRef.current) return;\n        setIsResizeGestureActive(false);\n        setPressedResizeAnchorName((current)=>current ? null : current);\n    };\n    const getResizeAnchorNameFromTarget = (target)=>{\n        if (!target) return null;\n        const isAnchorTarget = typeof target.hasName === \"function\" ? target.hasName(\"_anchor\") : typeof target.name === \"function\" && String(target.name() || \"\").includes(\"_anchor\");\n        if (!isAnchorTarget) return null;\n        const rawName = typeof target.name === \"function\" ? String(target.name() || \"\") : \"\";\n        const anchorName = rawName.split(\" \")[0] || null;\n        if (!anchorName) return null;\n        if (anchorName.toLowerCase().includes(\"rotat\")) return null;\n        return anchorName;\n    };\n    const handleResizeAnchorPressStart = (event)=>{\n        let anchorName = getResizeAnchorNameFromTarget(event === null || event === void 0 ? void 0 : event.target);\n        if (!anchorName) {\n            var _transformerRef_current;\n            const activeAnchor = typeof ((_transformerRef_current = transformerRef.current) === null || _transformerRef_current === void 0 ? void 0 : _transformerRef_current.getActiveAnchor) === \"function\" ? transformerRef.current.getActiveAnchor() : null;\n            if (typeof activeAnchor === \"string\" && !activeAnchor.toLowerCase().includes(\"rotat\")) {\n                anchorName = activeAnchor;\n            }\n        }\n        if (!anchorName) return;\n        setIsResizeGestureActive(true);\n        setPressedResizeAnchorName((current)=>current === anchorName ? current : anchorName);\n    };\n    const getBoxOverflowAmount = (box, stageWidth, stageHeight)=>{\n        if (!box) return Number.POSITIVE_INFINITY;\n        const x = Number(box.x);\n        const y = Number(box.y);\n        const width = Number(box.width);\n        const height = Number(box.height);\n        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height)) {\n            return Number.POSITIVE_INFINITY;\n        }\n        const left = Math.min(x, x + width);\n        const right = Math.max(x, x + width);\n        const top = Math.min(y, y + height);\n        const bottom = Math.max(y, y + height);\n        const overflowLeft = Math.max(0, -left);\n        const overflowTop = Math.max(0, -top);\n        const overflowRight = Math.max(0, right - stageWidth);\n        const overflowBottom = Math.max(0, bottom - stageHeight);\n        return overflowLeft + overflowTop + overflowRight + overflowBottom;\n    };\n    const keepBoxInsideStage = (oldBox, nextBox)=>{\n        var _tr_getStage, _stage_attrs, _stage_attrs1;\n        const tr = transformerRef.current;\n        const stage = tr === null || tr === void 0 ? void 0 : (_tr_getStage = tr.getStage) === null || _tr_getStage === void 0 ? void 0 : _tr_getStage.call(tr);\n        const stageWidth = typeof (stage === null || stage === void 0 ? void 0 : stage.width) === \"function\" ? Number(stage.width()) : Number(stage === null || stage === void 0 ? void 0 : (_stage_attrs = stage.attrs) === null || _stage_attrs === void 0 ? void 0 : _stage_attrs.width);\n        const stageHeight = typeof (stage === null || stage === void 0 ? void 0 : stage.height) === \"function\" ? Number(stage.height()) : Number(stage === null || stage === void 0 ? void 0 : (_stage_attrs1 = stage.attrs) === null || _stage_attrs1 === void 0 ? void 0 : _stage_attrs1.height);\n        if (!Number.isFinite(stageWidth) || stageWidth <= 0 || !Number.isFinite(stageHeight) || stageHeight <= 0) {\n            return nextBox;\n        }\n        const oldOverflow = getBoxOverflowAmount(oldBox, stageWidth, stageHeight);\n        const nextOverflow = getBoxOverflowAmount(nextBox, stageWidth, stageHeight);\n        const epsilon = 0.5;\n        if (!Number.isFinite(nextOverflow)) {\n            return oldBox;\n        }\n        if (nextOverflow <= epsilon) {\n            return nextBox;\n        }\n        // Permitir transformar de vuelta hacia adentro del canvas.\n        if (nextOverflow <= oldOverflow + epsilon) {\n            return nextBox;\n        }\n        // Si el resize empuja mÃ¡s afuera del canvas, mantener el estado anterior.\n        return oldBox;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            if (selectedElements.length === 0 || !deberiaUsarTransformer) {\n                setIsResizeGestureActive(false);\n                setPressedResizeAnchorName({\n                    \"SelectionBounds.useEffect\": (current)=>current ? null : current\n                }[\"SelectionBounds.useEffect\"]);\n                return;\n            }\n            if (isDragging && !isTransformingResizeRef.current) {\n                setIsResizeGestureActive(false);\n                setPressedResizeAnchorName({\n                    \"SelectionBounds.useEffect\": (current)=>current ? null : current\n                }[\"SelectionBounds.useEffect\"]);\n            }\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.length,\n        isDragging,\n        deberiaUsarTransformer\n    ]);\n    // ðŸ”¥ Efecto principal del Transformer (SIN retry / SIN flicker)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _window_editing, _tr_nodes, _tr_nodes1, _tr_getLayer;\n            const tr = transformerRef.current;\n            if (!tr) return;\n            const selKey = selectedElements.join(\",\");\n            TRDBG(\"EFFECT start\", {\n                selKey,\n                isDragging,\n                deberiaUsarTransformer,\n                hasGallery,\n                elementosTransformablesLen: elementosTransformables.length,\n                transformTick,\n                editingId: ((_window_editing = window.editing) === null || _window_editing === void 0 ? void 0 : _window_editing.id) || null\n            });\n            // Si no corresponde transformer, no hagas detach agresivo (evita flicker)\n            if (!deberiaUsarTransformer) {\n                TRDBG(\"EFFECT exit: no transformer or gallery\", {\n                    selKey\n                });\n                return;\n            }\n            // Resolver nodes desde refs (fuente de verdad)\n            let nodosTransformables = elementosTransformables.map({\n                \"SelectionBounds.useEffect.nodosTransformables\": (o)=>{\n                    var _elementRefs_current;\n                    return (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id];\n                }\n            }[\"SelectionBounds.useEffect.nodosTransformables\"]).filter(Boolean);\n            // Single select: usar ref fresco SIEMPRE\n            if (selectedElements.length === 1) {\n                var _elementRefs_current;\n                const idSel = selectedElements[0];\n                const refNode = ((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel]) || null;\n                if (refNode && typeof refNode.getClientRect === \"function\") {\n                    if (esGaleria && typeof refNode.findOne === \"function\") {\n                        const galleryFrame = refNode.findOne(\".gallery-transform-frame\");\n                        if (galleryFrame && typeof galleryFrame.getClientRect === \"function\") {\n                            nodosTransformables = [\n                                galleryFrame\n                            ];\n                        } else {\n                            nodosTransformables = [\n                                refNode\n                            ];\n                        }\n                    } else {\n                        nodosTransformables = [\n                            refNode\n                        ];\n                    }\n                }\n            }\n            // Si aÃºn no hay nodos (imagen cargando, etc.), NO despegar (evita parpadeo)\n            if (nodosTransformables.length === 0) {\n                TRDBG(\"EFFECT exit: no nodes yet\", {\n                    selKey,\n                    wantedIds: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>o.id\n                    }[\"SelectionBounds.useEffect\"]),\n                    refsPresent: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>{\n                            var _elementRefs_current;\n                            return !!((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id]);\n                        }\n                    }[\"SelectionBounds.useEffect\"])\n                });\n                return;\n            }\n            // Attach estable\n            TRDBG(\"ATTACH try\", {\n                selKey,\n                nodesCount: nodosTransformables.length,\n                nodeIds: nodosTransformables.map({\n                    \"SelectionBounds.useEffect\": (n)=>{\n                        var _n_attrs;\n                        return typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id;\n                    }\n                }[\"SelectionBounds.useEffect\"])\n            });\n            tr.nodes(nodosTransformables);\n            TRDBG(\"ATTACH done\", {\n                selKey,\n                trNodesCount: ((_tr_nodes1 = tr.nodes) === null || _tr_nodes1 === void 0 ? void 0 : (_tr_nodes = _tr_nodes1.call(tr)) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.length) || 0\n            });\n            try {\n                var _tr_forceUpdate;\n                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n            } catch (e) {}\n            (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        // Dependencias mÃ­nimas reales\n        selectedElements.join(\",\"),\n        deberiaUsarTransformer,\n        hasGallery,\n        elementosTransformables.length,\n        selectedGeomKey,\n        transformTick,\n        elementRefs\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            const handler = {\n                \"SelectionBounds.useEffect.handler\": (e)=>{\n                    var _e_detail;\n                    const id = e === null || e === void 0 ? void 0 : (_e_detail = e.detail) === null || _e_detail === void 0 ? void 0 : _e_detail.id;\n                    if (!id) return;\n                    TRDBG(\"REF event\", {\n                        id,\n                        isSelected: selectedElements.includes(id),\n                        selKey: selectedElements.join(\",\")\n                    });\n                    if (!selectedElements.includes(id)) return;\n                    setTransformTick({\n                        \"SelectionBounds.useEffect.handler\": (t)=>t + 1\n                    }[\"SelectionBounds.useEffect.handler\"]);\n                }\n            }[\"SelectionBounds.useEffect.handler\"];\n            window.addEventListener(\"element-ref-registrado\", handler);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>window.removeEventListener(\"element-ref-registrado\", handler)\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _elementRefs_current, _firstNode_getStage;\n            const firstId = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n            if (!firstId) return;\n            const firstNode = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[firstId];\n            const stage = firstNode === null || firstNode === void 0 ? void 0 : (_firstNode_getStage = firstNode.getStage) === null || _firstNode_getStage === void 0 ? void 0 : _firstNode_getStage.call(firstNode);\n            if (!stage) return;\n            let rafId = null;\n            const syncTransformer = {\n                \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                    if (rafId != null) return;\n                    rafId = requestAnimationFrame({\n                        \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                            var _tr_getLayer_batchDraw, _tr_getLayer, _tr_getLayer1;\n                            rafId = null;\n                            const tr = transformerRef.current;\n                            if (!tr) return;\n                            try {\n                                var _tr_forceUpdate;\n                                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n                            } catch (e) {}\n                            (_tr_getLayer1 = tr.getLayer) === null || _tr_getLayer1 === void 0 ? void 0 : (_tr_getLayer = _tr_getLayer1.call(tr)) === null || _tr_getLayer === void 0 ? void 0 : (_tr_getLayer_batchDraw = _tr_getLayer.batchDraw) === null || _tr_getLayer_batchDraw === void 0 ? void 0 : _tr_getLayer_batchDraw.call(_tr_getLayer);\n                        }\n                    }[\"SelectionBounds.useEffect.syncTransformer\"]);\n                }\n            }[\"SelectionBounds.useEffect.syncTransformer\"];\n            stage.on(\"dragmove\", syncTransformer);\n            stage.on(\"dragend\", syncTransformer);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>{\n                    stage.off(\"dragmove\", syncTransformer);\n                    stage.off(\"dragend\", syncTransformer);\n                    if (rafId != null) cancelAnimationFrame(rafId);\n                }\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\"),\n        elementRefs\n    ]);\n    // ðŸ”¥ Render\n    if (selectedElements.length === 0) return null;\n    if (hayLineas && elementosTransformables.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 592,\n            columnNumber: 7\n        }, this);\n    }\n    if (hayLineas && elementosTransformables.length > 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 602,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Transformer, {\n        name: \"ui\",\n        ref: transformerRef,\n        // ðŸ”µ borde siempre visible\n        borderEnabled: true,\n        borderStroke: \"#9333EA\",\n        borderStrokeWidth: transformerBorderStrokeWidth,\n        padding: transformerPadding,\n        // âŒ nodos y rotaciÃ³n OFF durante drag\n        enabledAnchors: isDragging && !isResizeGestureActive ? [] : [\n            \"bottom-right\"\n        ],\n        rotateEnabled: !isDragging && !esGaleria,\n        onMouseDown: handleResizeAnchorPressStart,\n        onTouchStart: handleResizeAnchorPressStart,\n        onPointerDown: handleResizeAnchorPressStart,\n        onMouseUp: clearResizeAnchorPressFeedback,\n        onTouchEnd: clearResizeAnchorPressFeedback,\n        onPointerUp: clearResizeAnchorPressFeedback,\n        onTouchCancel: clearResizeAnchorPressFeedback,\n        onPointerCancel: clearResizeAnchorPressFeedback,\n        anchorFill: transformerAnchorFillColor,\n        anchorStroke: transformerAnchorStrokeColor,\n        anchorStrokeWidth: transformerAnchorStrokeWidth,\n        anchorSize: transformerAnchorSize,\n        anchorCornerRadius: transformerAnchorRadius,\n        anchorShadowColor: transformerAnchorShadowColor,\n        anchorShadowBlur: transformerAnchorShadowBlur,\n        anchorShadowOffset: {\n            x: 0,\n            y: transformerAnchorShadowOffsetY\n        },\n        anchorStyleFunc: (anchor)=>{\n            var _window__resizeData;\n            const anchorName = typeof (anchor === null || anchor === void 0 ? void 0 : anchor.name) === \"function\" ? String(anchor.name() || \"\").split(\" \")[0] : \"\";\n            const isResizeAnchorNode = Boolean(anchorName) && !anchorName.toLowerCase().includes(\"rotat\");\n            const isResizeActiveFallback = isResizeGestureActive || isTransformingResizeRef.current ||  true && Boolean((_window__resizeData = window._resizeData) === null || _window__resizeData === void 0 ? void 0 : _window__resizeData.isResizing);\n            const isPressedResizeAnchor = isResizeActiveFallback && isResizeAnchorNode && (!pressedResizeAnchorName || anchorName === pressedResizeAnchorName);\n            anchor.shadowColor(isPressedResizeAnchor ? transformerAnchorPressedShadowColor : transformerAnchorShadowColor);\n            anchor.fill(isPressedResizeAnchor ? transformerAnchorPressedCoreColor : transformerAnchorFillColor);\n            anchor.shadowEnabled(true);\n            // Halo nace desde el centro (fill) y se desvanece hacia afuera.\n            anchor.shadowForStrokeEnabled(false);\n            anchor.shadowOpacity(isPressedResizeAnchor ? 0.96 : 0.28);\n            anchor.shadowBlur(isPressedResizeAnchor ? transformerAnchorPressedShadowBlur : transformerAnchorShadowBlur);\n            anchor.shadowOffset({\n                x: 0,\n                y: isPressedResizeAnchor ? transformerAnchorPressedShadowOffsetY : transformerAnchorShadowOffsetY\n            });\n            anchor.hitStrokeWidth(isPressedResizeAnchor ? transformerAnchorPressedHitStrokeWidth : transformerAnchorHitStrokeWidth);\n            anchor.stroke(isPressedResizeAnchor ? transformerAnchorPressedHaloStrokeColor : transformerAnchorStrokeColor);\n            anchor.strokeWidth(isPressedResizeAnchor ? transformerAnchorPressedHaloStrokeWidth : transformerAnchorStrokeWidth);\n            const anchorScale = isPressedResizeAnchor ? transformerAnchorPressedScale : 1;\n            anchor.scale({\n                x: anchorScale,\n                y: anchorScale\n            });\n        },\n        keepRatio: lockAspectCountdown || esGaleria || lockAspectText,\n        centeredScaling: selectedElements.length === 1 && esTexto,\n        flipEnabled: false,\n        resizeEnabled: !isDragging || isResizeGestureActive,\n        rotationSnaps: [\n            0,\n            45,\n            90,\n            135,\n            180,\n            225,\n            270,\n            315\n        ],\n        rotateAnchorOffset: transformerRotateOffset,\n        rotationSnapTolerance: transformerRotationSnapTolerance,\n        boundBoxFunc: (oldBox, newBox)=>{\n            const minSize = esTexto ? 20 : 10;\n            const maxSize = 800;\n            if (esGaleria) {\n                const rows = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.rows) || 1);\n                const cols = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.cols) || 1);\n                const gap = Math.max(0, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.gap) || 0);\n                const cellRatio = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"4:3\" ? 3 / 4 : (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"16:9\" ? 9 / 16 : 1;\n                const minGridWidth = gap * (cols - 1) + cols;\n                const nextWidth = Math.min(maxSize, Math.max(minSize, minGridWidth, Math.abs(newBox.width)));\n                const cellW = Math.max(1, (nextWidth - gap * (cols - 1)) / cols);\n                const cellH = cellW * cellRatio;\n                const nextHeight = rows * cellH + gap * (rows - 1);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: nextWidth,\n                    height: Math.max(minSize, nextHeight)\n                });\n            }\n            if (newBox.width < minSize || newBox.height < minSize) {\n                return oldBox;\n            }\n            if (lockAspectCountdown) {\n                const baseW = Math.max(1, oldBox.width);\n                const baseH = Math.max(1, oldBox.height);\n                const ratio = baseW / baseH;\n                const dw = Math.abs(newBox.width - oldBox.width) / baseW;\n                const dh = Math.abs(newBox.height - oldBox.height) / baseH;\n                let width = newBox.width;\n                let height = newBox.height;\n                if (dh > dw) {\n                    width = height * ratio;\n                } else {\n                    height = width / ratio;\n                }\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: Math.min(Math.max(width, minSize), maxSize),\n                    height: Math.min(Math.max(height, minSize), maxSize)\n                });\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                const size = Math.max(newBox.width, newBox.height);\n                const finalSize = Math.min(size, maxSize);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: finalSize,\n                    height: finalSize\n                });\n            }\n            if (esTriangulo) {\n                const safeOldW = Math.max(1, Math.abs(oldBox.width || minSize));\n                const safeOldH = Math.max(1, Math.abs(oldBox.height || minSize));\n                const scaleX = Math.abs(newBox.width) / safeOldW;\n                const scaleY = Math.abs(newBox.height) / safeOldH;\n                const uniformScale = Math.max(0.05, Math.min(scaleX, scaleY));\n                const width = Math.min(Math.max(safeOldW * uniformScale, minSize), maxSize);\n                const height = Math.min(Math.max(safeOldH * uniformScale, minSize), maxSize);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width,\n                    height\n                });\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"imagen\" || (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"icono\") {\n                const scaleX = newBox.width / oldBox.width;\n                const scaleY = newBox.height / oldBox.height;\n                const uniformScale = Math.min(scaleX, scaleY);\n                const newWidth = oldBox.width * uniformScale;\n                const newHeight = oldBox.height * uniformScale;\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: Math.min(Math.max(newWidth, minSize), maxSize),\n                    height: Math.min(Math.max(newHeight, minSize), maxSize)\n                });\n            }\n            return keepBoxInsideStage(oldBox, {\n                ...newBox,\n                width: Math.min(newBox.width, maxSize),\n                height: Math.min(newBox.height, maxSize)\n            });\n        },\n        onTransformStart: (e)=>{\n            isTransformingResizeRef.current = true;\n            window._resizeData = {\n                isResizing: true\n            };\n            const tr = transformerRef.current;\n            const activeAnchor = typeof (tr === null || tr === void 0 ? void 0 : tr.getActiveAnchor) === \"function\" ? tr.getActiveAnchor() : null;\n            const isRotateGesture = typeof activeAnchor === \"string\" && activeAnchor.toLowerCase().includes(\"rotat\");\n            transformGestureRef.current = {\n                isRotate: isRotateGesture,\n                activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null\n            };\n            if (!isRotateGesture) {\n                setIsResizeGestureActive(true);\n            }\n            if (!isRotateGesture && activeAnchor) {\n                setPressedResizeAnchorName((current)=>current === activeAnchor ? current : activeAnchor);\n            }\n            if (typeof onTransformInteractionStart === \"function\") {\n                var _e_evt;\n                var _e_evt_pointerType;\n                onTransformInteractionStart({\n                    isRotate: isRotateGesture,\n                    activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null,\n                    pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n                });\n            }\n            try {\n                var _tr_nodes, _n_attrs, _tr_getClientRect;\n                const nodes = (tr === null || tr === void 0 ? void 0 : (_tr_nodes = tr.nodes) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.call(tr)) || [];\n                circleAnchorRef.current = null;\n                textTransformAnchorRef.current = null;\n                if (nodes.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                    try {\n                        const r0 = nodes[0].getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        circleAnchorRef.current = {\n                            left: r0.x,\n                            top: r0.y\n                        };\n                    } catch (e) {}\n                }\n                if (nodes.length === 1 && esTexto) {\n                    const node = nodes[0];\n                    let centerX = null;\n                    let centerY = null;\n                    let baseWidth = null;\n                    let baseHeight = null;\n                    let baseVisualWidth = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.x) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width)) {\n                            centerX = rect.x + rect.width / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.y) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height)) {\n                            centerY = rect.y + rect.height / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            baseWidth = rect.width;\n                            baseVisualWidth = rect.width;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height) && rect.height > 0) {\n                            baseHeight = rect.height;\n                        }\n                    } catch (e) {}\n                    const safeBaseFontSize = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.fontSize) && primerElemento.fontSize > 0 ? primerElemento.fontSize : 24;\n                    textTransformAnchorRef.current = {\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : 0,\n                        baseRotation: typeof (node === null || node === void 0 ? void 0 : node.rotation) === \"function\" ? node.rotation() || 0 : 0,\n                        centerX,\n                        centerY,\n                        baseWidth,\n                        baseHeight,\n                        baseFontSize: safeBaseFontSize,\n                        lastPreviewFontSize: safeBaseFontSize,\n                        lastPreviewCenterX: centerX,\n                        lastPreviewCenterY: centerY,\n                        lastPreviewVisualWidth: baseVisualWidth,\n                        previewTick: 0\n                    };\n                    var _primerElemento_id;\n                    TXTDBG(\"start\", {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        baseFontSize: safeBaseFontSize,\n                        baseWidth,\n                        baseHeight,\n                        centerX,\n                        centerY,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        nodeScaleX: typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() : null,\n                        nodeScaleY: typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() : null\n                    });\n                }\n                const union = rectFromNodes(nodes);\n                const pad = typeof (tr === null || tr === void 0 ? void 0 : tr.padding) === \"function\" ? tr.padding() : 0;\n                const borderRect = union ? {\n                    x: union.x - pad,\n                    y: union.y - pad,\n                    width: union.width + pad * 2,\n                    height: union.height + pad * 2\n                } : null;\n                const n = nodes[0];\n                const id = n ? typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id : \"âˆ…\";\n                const trRect = tr === null || tr === void 0 ? void 0 : (_tr_getClientRect = tr.getClientRect) === null || _tr_getClientRect === void 0 ? void 0 : _tr_getClientRect.call(tr, {\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                slog(\"[TR] start\", \"id=\".concat(id), \"nodes=\".concat(nodes.length), union ? \"union(w=\".concat(union.width.toFixed(1), \",h=\").concat(union.height.toFixed(1), \")\") : \"union(null)\", borderRect ? \"border(w=\".concat(borderRect.width.toFixed(1), \",h=\").concat(borderRect.height.toFixed(1), \")\") : \"border(null)\", trRect ? \"trRect(w=\".concat(trRect.width.toFixed(1), \",h=\").concat(trRect.height.toFixed(1), \")\") : \"trRect(null)\", \"pad=\".concat(pad));\n            } catch (e) {}\n        },\n        onTransform: (e)=>{\n            if (!onTransform || !transformerRef.current) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            const node = nodes[0]; // âœ… nodo real (single select)\n            if (!node) return;\n            try {\n                var _node_attrs, _node_scaleX, _node_scaleY, _node_x, _node_y;\n                const pose = getTransformPose(node);\n                const transformData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isPreview: true\n                };\n                if (esTexto) {\n                    var _textTransformAnchorRef_current, _textTransformAnchorRef_current1, _textTransformAnchorRef_current2;\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let liveRectWidth = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            liveRectWidth = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    transformData.fontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    if (textTransformAnchorRef.current) {\n                        const tick = Number(textTransformAnchorRef.current.previewTick || 0) + 1;\n                        textTransformAnchorRef.current.previewTick = tick;\n                        textTransformAnchorRef.current.lastPreviewFontSize = transformData.fontSize;\n                        if (Number.isFinite(liveRectWidth) && liveRectWidth > 0) {\n                            textTransformAnchorRef.current.lastPreviewVisualWidth = liveRectWidth;\n                        }\n                        if (tick <= 2 || tick % 5 === 0) {\n                            var _textTransformAnchorRef_current3;\n                            var _primerElemento_id, _textTransformAnchorRef_current_centerX;\n                            TXTDBG(\"preview\", {\n                                id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                                tick,\n                                scaleX,\n                                scaleY,\n                                avgScale,\n                                scaleFromRect,\n                                effectiveScale,\n                                baseFontSize,\n                                fontSize: transformData.fontSize,\n                                liveRectWidth,\n                                centerXTarget: (_textTransformAnchorRef_current_centerX = (_textTransformAnchorRef_current3 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current3 === void 0 ? void 0 : _textTransformAnchorRef_current3.centerX) !== null && _textTransformAnchorRef_current_centerX !== void 0 ? _textTransformAnchorRef_current_centerX : null,\n                                nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                                nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                            });\n                        }\n                    }\n                    transformData.scaleX = 1;\n                    transformData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite((_textTransformAnchorRef_current = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current === void 0 ? void 0 : _textTransformAnchorRef_current.y)) {\n                        transformData.y = textTransformAnchorRef.current.y;\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current1 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current1 === void 0 ? void 0 : _textTransformAnchorRef_current1.centerX)) {\n                        transformData.textCenterX = textTransformAnchorRef.current.centerX;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterX = textTransformAnchorRef.current.centerX;\n                        }\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current2 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current2 === void 0 ? void 0 : _textTransformAnchorRef_current2.centerY)) {\n                        transformData.textCenterY = textTransformAnchorRef.current.centerY;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterY = textTransformAnchorRef.current.centerY;\n                        }\n                    }\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    transformData.scaleX = scaleX;\n                    transformData.scaleY = scaleY;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        const countdownSize = getCountdownScaledSize(node);\n                        transformData.width = countdownSize.width;\n                        transformData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        transformData.radius = Math.max(1, baseRadius * avgScale);\n                    } else {\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        transformData.width = Math.abs(originalWidth * scaleX);\n                        transformData.height = Math.abs(originalHeight * scaleY);\n                    }\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                        try {\n                            const liveRect = node.getClientRect({\n                                skipTransform: false,\n                                skipShadow: true,\n                                skipStroke: true\n                            });\n                            const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                            transformData.radius = diameter / 2;\n                            const anchor = circleAnchorRef.current;\n                            if (anchor) {\n                                transformData.x = anchor.left + transformData.radius;\n                                transformData.y = anchor.top + transformData.radius;\n                            } else {\n                                transformData.x = liveRect.x + transformData.radius;\n                                transformData.y = liveRect.y + transformData.radius;\n                            }\n                        } catch (e) {}\n                    }\n                }\n                onTransform(transformData);\n                // --- LOG COMPACTO (opcional) ---\n                const id = (typeof node.id === \"function\" ? node.id() : (_node_attrs = node.attrs) === null || _node_attrs === void 0 ? void 0 : _node_attrs.id) || \"âˆ…\";\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                const r = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                var _node_x1, _node_y1, _transformData_width, _transformData_height;\n                slog(\"[TR] live\", \"id=\".concat(id), \"tipo=\".concat((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) || \"âˆ…\"), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"x=\".concat(((_node_x1 = (_node_x = node.x) === null || _node_x === void 0 ? void 0 : _node_x.call(node)) !== null && _node_x1 !== void 0 ? _node_x1 : 0).toFixed(1)), \"y=\".concat(((_node_y1 = (_node_y = node.y) === null || _node_y === void 0 ? void 0 : _node_y.call(node)) !== null && _node_y1 !== void 0 ? _node_y1 : 0).toFixed(1)), \"nodeRect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"), \"w=\".concat((_transformData_width = transformData.width) !== null && _transformData_width !== void 0 ? _transformData_width : \"âˆ…\"), \"h=\".concat((_transformData_height = transformData.height) !== null && _transformData_height !== void 0 ? _transformData_height : \"âˆ…\"));\n            } catch (error) {\n                console.warn(\"Error en onTransform:\", error);\n            }\n        },\n        onTransformEnd: (e)=>{\n            var _transformGestureRef_current, _transformGestureRef_current1, _e_evt;\n            var _transformGestureRef_current_activeAnchor, _e_evt_pointerType;\n            const interactionSnapshot = {\n                isRotate: Boolean((_transformGestureRef_current = transformGestureRef.current) === null || _transformGestureRef_current === void 0 ? void 0 : _transformGestureRef_current.isRotate),\n                activeAnchor: (_transformGestureRef_current_activeAnchor = (_transformGestureRef_current1 = transformGestureRef.current) === null || _transformGestureRef_current1 === void 0 ? void 0 : _transformGestureRef_current1.activeAnchor) !== null && _transformGestureRef_current_activeAnchor !== void 0 ? _transformGestureRef_current_activeAnchor : null,\n                pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n            };\n            const notifyTransformInteractionEnd = ()=>{\n                if (typeof onTransformInteractionEnd === \"function\") {\n                    onTransformInteractionEnd(interactionSnapshot);\n                }\n                transformGestureRef.current = {\n                    isRotate: false,\n                    activeAnchor: null\n                };\n            };\n            try {\n                if (!transformerRef.current || !onTransform) return;\n                const tr = transformerRef.current;\n                const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n                // -------------------------\n                // MULTI-SELECCIÃ“N\n                // -------------------------\n                if (nodes.length > 1) {\n                    try {\n                        var _tr_getLayer;\n                        const tScaleX = typeof tr.scaleX === \"function\" ? tr.scaleX() || 1 : 1;\n                        const tScaleY = typeof tr.scaleY === \"function\" ? tr.scaleY() || 1 : 1;\n                        const avg = (Math.abs(tScaleX) + Math.abs(tScaleY)) / 2;\n                        const updates = nodes.map((n)=>{\n                            let id = null;\n                            try {\n                                var _n_attrs;\n                                id = (typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id) || null;\n                            } catch (e) {}\n                            if (!id) return null;\n                            const obj = (objetos || []).find((o)=>o.id === id);\n                            if (!obj) return null;\n                            const upd = {\n                                id,\n                                x: typeof n.x === \"function\" ? n.x() : obj.x,\n                                y: typeof n.y === \"function\" ? n.y() : obj.y,\n                                rotation: typeof n.rotation === \"function\" ? n.rotation() || 0 : obj.rotation || 0\n                            };\n                            if (obj.tipo === \"texto\") {\n                                const base = obj.fontSize || 24;\n                                upd.fontSize = Math.max(6, Math.round(base * avg));\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"forma\" && obj.figura === \"circle\") {\n                                const baseR = obj.radius || 50;\n                                upd.radius = baseR * avg;\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"forma\" && obj.figura === \"triangle\") {\n                                const baseR = obj.radius || 60;\n                                upd.radius = Math.max(1, baseR * avg);\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"countdown\") {\n                                const countdownSize = getCountdownScaledSize(n);\n                                upd.width = countdownSize.width;\n                                upd.height = countdownSize.height;\n                                return upd;\n                            }\n                            const baseW = obj.width != null ? obj.width : typeof n.width === \"function\" ? n.width() : 100;\n                            const baseH = obj.height != null ? obj.height : typeof n.height === \"function\" ? n.height() : 100;\n                            upd.width = Math.abs(baseW * tScaleX);\n                            upd.height = Math.abs(baseH * tScaleY);\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }).filter(Boolean);\n                        onTransform({\n                            isFinal: true,\n                            batch: updates\n                        });\n                        if (typeof tr.scaleX === \"function\") {\n                            tr.scaleX(1);\n                            tr.scaleY(1);\n                        }\n                        (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n                        window._resizeData = {\n                            isResizing: false\n                        };\n                        setTimeout(()=>{\n                            window._resizeData = null;\n                        }, 100);\n                        return;\n                    } catch (err) {\n                        console.warn(\"Error en onTransformEnd (multi):\", err);\n                        window._resizeData = null;\n                        return;\n                    }\n                }\n                // -------------------------\n                // SINGLE-SELECCIÃ“N\n                // -------------------------\n                const node = nodes[0];\n                if (!node) return;\n                const pose = getTransformPose(node);\n                const finalData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isFinal: true\n                };\n                let textPreviewEndSnapshot = null;\n                if (esTexto) {\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let visualWidthFromRect = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            visualWidthFromRect = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    const computedFontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    finalData.fontSize = Math.max(6, Number(Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewFontSize) && anchorData.lastPreviewFontSize > 0 ? anchorData.lastPreviewFontSize : computedFontSize));\n                    finalData.scaleX = 1;\n                    finalData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.y)) {\n                        finalData.y = anchorData.y;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterX)) {\n                        finalData.textCenterX = anchorData.lastPreviewCenterX;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerX)) {\n                        finalData.textCenterX = anchorData.centerX;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterY)) {\n                        finalData.textCenterY = anchorData.lastPreviewCenterY;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerY)) {\n                        finalData.textCenterY = anchorData.centerY;\n                    }\n                    const visualWidth = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewVisualWidth) && anchorData.lastPreviewVisualWidth > 0 ? anchorData.lastPreviewVisualWidth : visualWidthFromRect;\n                    if (Number.isFinite(visualWidth) && visualWidth > 0) {\n                        finalData.textVisualWidth = visualWidth;\n                    }\n                    var _primerElemento_id;\n                    textPreviewEndSnapshot = {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        x: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        scaleX,\n                        scaleY,\n                        fontSize: typeof (node === null || node === void 0 ? void 0 : node.fontSize) === \"function\" ? node.fontSize() : null,\n                        rectWidth: Number.isFinite(visualWidthFromRect) ? visualWidthFromRect : null,\n                        rectHeight: null\n                    };\n                    try {\n                        const rectForSnapshot = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rectForSnapshot === null || rectForSnapshot === void 0 ? void 0 : rectForSnapshot.height)) {\n                            textPreviewEndSnapshot.rectHeight = rectForSnapshot.height;\n                        }\n                    } catch (e) {}\n                    var _primerElemento_id1, _finalData_textCenterX, _finalData_textCenterY, _finalData_textVisualWidth;\n                    TXTDBG(\"end\", {\n                        id: (_primerElemento_id1 = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id1 !== void 0 ? _primerElemento_id1 : null,\n                        scaleX,\n                        scaleY,\n                        avgScale,\n                        scaleFromRect,\n                        effectiveScale,\n                        computedFontSize,\n                        finalFontSize: finalData.fontSize,\n                        textCenterX: (_finalData_textCenterX = finalData.textCenterX) !== null && _finalData_textCenterX !== void 0 ? _finalData_textCenterX : null,\n                        textCenterY: (_finalData_textCenterY = finalData.textCenterY) !== null && _finalData_textCenterY !== void 0 ? _finalData_textCenterY : null,\n                        textVisualWidth: (_finalData_textVisualWidth = finalData.textVisualWidth) !== null && _finalData_textVisualWidth !== void 0 ? _finalData_textVisualWidth : null,\n                        nodeRectWidth: visualWidthFromRect,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                    });\n                    // Aplanar escala del texto en el release para evitar doble escalado\n                    // (escala del nodo + fontSize persistido).\n                    try {\n                        var _node_getLayer;\n                        if (typeof node.scaleX === \"function\") node.scaleX(1);\n                        if (typeof node.scaleY === \"function\") node.scaleY(1);\n                        if (Number.isFinite(finalData.fontSize) && typeof node.fontSize === \"function\") {\n                            node.fontSize(finalData.fontSize);\n                        }\n                        const targetCenterX = Number(finalData.textCenterX);\n                        const targetCenterY = Number(finalData.textCenterY);\n                        if ((Number.isFinite(targetCenterX) || Number.isFinite(targetCenterY)) && typeof node.x === \"function\" && typeof node.y === \"function\") {\n                            try {\n                                const flattenedRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const flattenedCenterX = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.x) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.width) ? flattenedRect.x + flattenedRect.width / 2 : null;\n                                const flattenedCenterY = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.y) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.height) ? flattenedRect.y + flattenedRect.height / 2 : null;\n                                if (Number.isFinite(flattenedCenterX) && Number.isFinite(targetCenterX)) {\n                                    node.x(node.x() + (targetCenterX - flattenedCenterX));\n                                }\n                                if (Number.isFinite(flattenedCenterY) && Number.isFinite(targetCenterY)) {\n                                    node.y(node.y() + (targetCenterY - flattenedCenterY));\n                                }\n                            } catch (e) {}\n                        }\n                        (_node_getLayer = node.getLayer()) === null || _node_getLayer === void 0 ? void 0 : _node_getLayer.batchDraw();\n                    } catch (err) {\n                        console.warn(\"Error aplanando escala de texto (sync):\", err);\n                    }\n                    if (!canUseRectScale) {\n                        if (typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\") {\n                            finalData.x = node.x();\n                        }\n                        if (typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\") {\n                            finalData.y = node.y();\n                        }\n                    }\n                    // Para texto evitamos aplanar antes del commit en React,\n                    // asÃ­ no aparece un frame intermedio con tamaÃ±o \"saltado\".\n                    textTransformAnchorRef.current = null;\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        // Countdown: persistir escala real para que el resultado final\n                        // sea exactamente el mismo que se ve al soltar.\n                        finalData.scaleX = scaleX;\n                        finalData.scaleY = scaleY;\n                        const countdownSize = getCountdownScaledSize(node);\n                        finalData.width = countdownSize.width;\n                        finalData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        finalData.radius = Math.max(1, baseRadius * avgScale);\n                        try {\n                            var _node_getLayer1;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (typeof node.radius === \"function\") node.radius(finalData.radius);\n                            (_node_getLayer1 = node.getLayer()) === null || _node_getLayer1 === void 0 ? void 0 : _node_getLayer1.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escala de triÃ¡ngulo (sync):\", err);\n                        }\n                    } else {\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        finalData.width = Math.abs(originalWidth * scaleX);\n                        finalData.height = Math.abs(originalHeight * scaleY);\n                        if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                            try {\n                                const liveRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                                finalData.radius = diameter / 2;\n                                const anchor = circleAnchorRef.current;\n                                if (anchor) {\n                                    finalData.x = anchor.left + finalData.radius;\n                                    finalData.y = anchor.top + finalData.radius;\n                                } else {\n                                    finalData.x = liveRect.x + finalData.radius;\n                                    finalData.y = liveRect.y + finalData.radius;\n                                }\n                            } catch (e) {}\n                        }\n                        // âœ… Aplanar escala INMEDIATO\n                        try {\n                            var _node_getLayer2;\n                            const fw = finalData.width;\n                            const fh = finalData.height;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (fw != null && typeof node.width === \"function\") node.width(fw);\n                            if (fh != null && typeof node.height === \"function\") node.height(fh);\n                            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\" && finalData.radius != null && typeof node.radius === \"function\") {\n                                node.radius(finalData.radius);\n                            }\n                            (_node_getLayer2 = node.getLayer()) === null || _node_getLayer2 === void 0 ? void 0 : _node_getLayer2.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escalas (sync):\", err);\n                        }\n                    }\n                }\n                onTransform(finalData);\n                circleAnchorRef.current = null;\n                // âœ… Reatachar 1 vez, con ref fresco, en el prÃ³ximo frame\n                try {\n                    const tr2 = transformerRef.current;\n                    if (!tr2) return;\n                    TRDBG(\"onTransformEnd -> schedule RAF reattach\", {\n                        selKey: selectedElements.join(\",\"),\n                        idSel: (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0]) || null\n                    });\n                    requestAnimationFrame(()=>{\n                        var _elementRefs_current, _freshNode_getStage, _freshNode_getStage1;\n                        const idSel = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n                        const freshNode = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                        TRDBG(\"onTransformEnd RAF\", {\n                            idSel,\n                            hasFresh: !!freshNode,\n                            destroyed: !!(freshNode === null || freshNode === void 0 ? void 0 : freshNode._destroyed),\n                            hasStage: !!(freshNode === null || freshNode === void 0 ? void 0 : (_freshNode_getStage = freshNode.getStage) === null || _freshNode_getStage === void 0 ? void 0 : _freshNode_getStage.call(freshNode))\n                        });\n                        // Si el nodo no estÃ¡ listo, despegar y salir\n                        if (!freshNode || freshNode._destroyed || !((_freshNode_getStage1 = freshNode.getStage) === null || _freshNode_getStage1 === void 0 ? void 0 : _freshNode_getStage1.call(freshNode))) {\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            try {\n                                var _tr2_getLayer, _tr2_getLayer1;\n                                tr2.nodes([]);\n                                (_tr2_getLayer1 = tr2.getLayer) === null || _tr2_getLayer1 === void 0 ? void 0 : (_tr2_getLayer = _tr2_getLayer1.call(tr2)) === null || _tr2_getLayer === void 0 ? void 0 : _tr2_getLayer.batchDraw();\n                            } catch (e) {}\n                            return;\n                        }\n                        try {\n                            var _tr2_getLayer2, _tr2_getLayer3;\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            tr2.nodes([\n                                freshNode\n                            ]);\n                            tr2.forceUpdate();\n                            (_tr2_getLayer3 = tr2.getLayer) === null || _tr2_getLayer3 === void 0 ? void 0 : (_tr2_getLayer2 = _tr2_getLayer3.call(tr2)) === null || _tr2_getLayer2 === void 0 ? void 0 : _tr2_getLayer2.batchDraw();\n                            if (textPreviewEndSnapshot && freshNode) {\n                                try {\n                                    const postRect = freshNode.getClientRect({\n                                        skipTransform: false,\n                                        skipShadow: true,\n                                        skipStroke: true\n                                    });\n                                    TXTDBG(\"post-commit:raf1\", {\n                                        id: idSel,\n                                        pre: textPreviewEndSnapshot,\n                                        post: {\n                                            x: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.x) === \"function\" ? freshNode.x() : null,\n                                            y: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.y) === \"function\" ? freshNode.y() : null,\n                                            scaleX: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleX) === \"function\" ? freshNode.scaleX() : null,\n                                            scaleY: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleY) === \"function\" ? freshNode.scaleY() : null,\n                                            fontSize: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.fontSize) === \"function\" ? freshNode.fontSize() : null,\n                                            rectWidth: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) ? postRect.width : null,\n                                            rectHeight: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) ? postRect.height : null\n                                        },\n                                        delta: {\n                                            width: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect.width - textPreviewEndSnapshot.rectWidth : null,\n                                            height: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect.height - textPreviewEndSnapshot.rectHeight : null\n                                        }\n                                    });\n                                } catch (e) {}\n                                requestAnimationFrame(()=>{\n                                    var _elementRefs_current;\n                                    const freshNode2 = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                                    if (!freshNode2) return;\n                                    try {\n                                        const postRect2 = freshNode2.getClientRect({\n                                            skipTransform: false,\n                                            skipShadow: true,\n                                            skipStroke: true\n                                        });\n                                        TXTDBG(\"post-commit:raf2\", {\n                                            id: idSel,\n                                            post: {\n                                                x: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.x) === \"function\" ? freshNode2.x() : null,\n                                                y: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.y) === \"function\" ? freshNode2.y() : null,\n                                                scaleX: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleX) === \"function\" ? freshNode2.scaleX() : null,\n                                                scaleY: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleY) === \"function\" ? freshNode2.scaleY() : null,\n                                                fontSize: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.fontSize) === \"function\" ? freshNode2.fontSize() : null,\n                                                rectWidth: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) ? postRect2.width : null,\n                                                rectHeight: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) ? postRect2.height : null\n                                            },\n                                            deltaFromPre: {\n                                                width: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect2.width - textPreviewEndSnapshot.rectWidth : null,\n                                                height: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect2.height - textPreviewEndSnapshot.rectHeight : null\n                                            }\n                                        });\n                                    } catch (e) {}\n                                });\n                            }\n                        } catch (e) {}\n                    });\n                } catch (e) {}\n            } catch (error) {\n                console.warn(\"Error en onTransformEnd:\", error);\n                window._resizeData = null;\n            } finally{\n                isTransformingResizeRef.current = false;\n                setIsResizeGestureActive(false);\n                clearResizeAnchorPressFeedback();\n                notifyTransformInteractionEnd();\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 611,\n        columnNumber: 5\n    }, this);\n}\n_s1(SelectionBounds, \"IMqo/S4ZLseQxerUTPZnWjua6f8=\");\n_c3 = SelectionBounds;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"TRDBG\");\n$RefreshReg$(_c1, \"TXTDBG\");\n$RefreshReg$(_c2, \"BoundsIndicator\");\n$RefreshReg$(_c3, \"SelectionBounds\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NlbGVjdGlvbkJvdW5kcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsc0JBQXNCOzs7QUFDOEI7QUFDSjtBQUloRCxNQUFNSyx5QkFBeUI7QUFFL0IsTUFBTUMsUUFBUTtxQ0FBSUM7UUFBQUE7O0lBQ2hCLElBQUksQ0FBQ0Ysd0JBQXdCO0lBQzdCRyxRQUFRQyxHQUFHLENBQUMsV0FBV0Y7QUFDekI7QUFDQSxNQUFNRyxPQUFPSjtBQUViLE1BQU1LLFFBQVE7cUNBQUlKO1FBQUFBOztJQUNoQixJQUFJLENBQUNLLE9BQU9DLFFBQVEsRUFBRTtJQUN0QkwsUUFBUUMsR0FBRyxDQUFDLGNBQWNGO0FBQzVCO0tBSE1JO0FBS04sTUFBTUcsU0FBUztxQ0FBSVA7UUFBQUE7O0lBQ2pCLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBQzFDLElBQUksQ0FBQ0ssT0FBT0csaUJBQWlCLEVBQUU7SUFDL0JQLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JGO0FBQzlCO01BSk1PO0FBT04sU0FBU0UsY0FBY0MsS0FBSztJQUMxQixJQUFJQyxPQUFPQyxVQUFVQyxPQUFPRCxVQUFVRSxPQUFPLENBQUNGLFVBQVVHLE9BQU8sQ0FBQ0g7SUFFaEUsS0FBSyxNQUFNSSxLQUFLTixNQUFPO1FBQ3JCLElBQUksRUFBQ00sY0FBQUEsd0JBQUFBLEVBQUdDLGFBQWEsR0FBRTtRQUN2QixNQUFNQyxJQUFJRixFQUFFQyxhQUFhLENBQUM7WUFBRUUsZUFBZTtZQUFPQyxZQUFZO1lBQU1DLFlBQVk7UUFBSztRQUNyRlYsT0FBT1csS0FBS0MsR0FBRyxDQUFDWixNQUFNTyxFQUFFTSxDQUFDO1FBQ3pCWCxPQUFPUyxLQUFLQyxHQUFHLENBQUNWLE1BQU1LLEVBQUVPLENBQUM7UUFDekJYLE9BQU9RLEtBQUtJLEdBQUcsQ0FBQ1osTUFBTUksRUFBRU0sQ0FBQyxHQUFHTixFQUFFUyxLQUFLO1FBQ25DWixPQUFPTyxLQUFLSSxH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QU9DLFFBQVEsQ0FBQ3lWLHNCQUFBQSxnQ0FBQUEsVUFBV3hXLEtBQUssS0FDaENjLE9BQU9DLFFBQVEsQ0FBQzZULHVCQUF1QkssU0FBUyxJQUMzQ3VCLFVBQVV4VyxLQUFLLEdBQUc0VSx1QkFBdUJLLFNBQVMsR0FDbkQ7Z0RBQ05oVixRQUNFYSxPQUFPQyxRQUFRLENBQUN5VixzQkFBQUEsZ0NBQUFBLFVBQVd2VyxNQUFNLEtBQ2pDYSxPQUFPQyxRQUFRLENBQUM2VCx1QkFBdUJNLFVBQVUsSUFDNUNzQixVQUFVdlcsTUFBTSxHQUFHMlUsdUJBQXVCTSxVQUFVLEdBQ3JEOzRDQUNSO3dDQUNGO29DQUNGLEVBQUUsVUFBTSxDQUFDO2dDQUNYOzRCQUNGO3dCQUNGLEVBQUUsVUFBTSxDQUFFO29CQUNaO2dCQUNGLEVBQUUsVUFBTSxDQUFFO1lBR1osRUFBRSxPQUFPMVIsT0FBTztnQkFDZGxGLFFBQVFxVixJQUFJLENBQUMsNEJBQTRCblE7Z0JBQ3pDOUUsT0FBT29QLFdBQVcsR0FBRztZQUN2QixTQUFVO2dCQUNSdkksd0JBQXdCaEUsT0FBTyxHQUFHO2dCQUNsQ2tFLHlCQUF5QjtnQkFDekI2QztnQkFDQXdMO1lBQ0Y7UUFDRjs7Ozs7O0FBSU47SUEvNkN3QnRQO01BQUFBIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxzcmNcXGNvbXBvbmVudHNcXFNlbGVjdGlvbkJvdW5kcy5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2VsZWN0aW9uQm91bmRzLmpzeFxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgVHJhbnNmb3JtZXIsIFJlY3QgfSBmcm9tIFwicmVhY3Qta29udmFcIjtcclxuXHJcblxyXG5cclxuY29uc3QgREVCVUdfU0VMRUNUSU9OX0JPVU5EUyA9IGZhbHNlO1xyXG5cclxuY29uc3Qgc2JMb2cgPSAoLi4uYXJncykgPT4ge1xyXG4gIGlmICghREVCVUdfU0VMRUNUSU9OX0JPVU5EUykgcmV0dXJuO1xyXG4gIGNvbnNvbGUubG9nKFwiW1NCXVwiLCAuLi5hcmdzKTtcclxufTtcclxuY29uc3Qgc2xvZyA9IHNiTG9nO1xyXG5cclxuY29uc3QgVFJEQkcgPSAoLi4uYXJncykgPT4ge1xyXG4gIGlmICghd2luZG93Ll9fREJHX1RSKSByZXR1cm47XHJcbiAgY29uc29sZS5sb2coXCJbVFJEQkddXCIsIC4uLmFyZ3MpO1xyXG59O1xyXG5cclxuY29uc3QgVFhUREJHID0gKC4uLmFyZ3MpID0+IHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xyXG4gIGlmICghd2luZG93Ll9fREJHX1RFWFRfUkVTSVpFKSByZXR1cm47XHJcbiAgY29uc29sZS5sb2coXCJbVEVYVC1UUl1cIiwgLi4uYXJncyk7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gcmVjdEZyb21Ob2Rlcyhub2Rlcykge1xyXG4gIGxldCBtaW5YID0gSW5maW5pdHksIG1pblkgPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcclxuXHJcbiAgZm9yIChjb25zdCBuIG9mIG5vZGVzKSB7XHJcbiAgICBpZiAoIW4/LmdldENsaWVudFJlY3QpIGNvbnRpbnVlO1xyXG4gICAgY29uc3QgciA9IG4uZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xyXG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHIueCk7XHJcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgci55KTtcclxuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCByLnggKyByLndpZHRoKTtcclxuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCByLnkgKyByLmhlaWdodCk7XHJcbiAgfVxyXG5cclxuICBpZiAobWluWCA9PT0gSW5maW5pdHkpIHJldHVybiBudWxsO1xyXG4gIHJldHVybiB7IHg6IG1pblgsIHk6IG1pblksIHdpZHRoOiBtYXhYIC0gbWluWCwgaGVpZ2h0OiBtYXhZIC0gbWluWSB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb3VudGRvd25TY2FsZWRTaXplKG5vZGUpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgaGl0Ym94ID0gbm9kZT8uZmluZE9uZT8uKFwiLmNvdW50ZG93bi1oaXRib3hcIik7XHJcbiAgICBjb25zdCBiYXNlVyA9IHR5cGVvZiBoaXRib3g/LndpZHRoID09PSBcImZ1bmN0aW9uXCIgPyBoaXRib3gud2lkdGgoKSA6IE5hTjtcclxuICAgIGNvbnN0IGJhc2VIID0gdHlwZW9mIGhpdGJveD8uaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIgPyBoaXRib3guaGVpZ2h0KCkgOiBOYU47XHJcbiAgICBjb25zdCBzeCA9IE1hdGguYWJzKHR5cGVvZiBub2RlPy5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnNjYWxlWCgpIHx8IDEpIDogMSk7XHJcbiAgICBjb25zdCBzeSA9IE1hdGguYWJzKHR5cGVvZiBub2RlPy5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnNjYWxlWSgpIHx8IDEpIDogMSk7XHJcblxyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShiYXNlVykgJiYgTnVtYmVyLmlzRmluaXRlKGJhc2VIKSAmJiBiYXNlVyA+IDAgJiYgYmFzZUggPiAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgd2lkdGg6IE1hdGguYWJzKGJhc2VXICogc3gpLFxyXG4gICAgICAgIGhlaWdodDogTWF0aC5hYnMoYmFzZUggKiBzeSksXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSBjYXRjaCB7fVxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgciA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIHsgd2lkdGg6IE1hdGguYWJzKHIud2lkdGgpLCBoZWlnaHQ6IE1hdGguYWJzKHIuaGVpZ2h0KSB9O1xyXG4gIH0gY2F0Y2gge31cclxuXHJcbiAgcmV0dXJuIHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiA1MCB9O1xyXG59XHJcblxyXG5cclxuLy8g8J+OqCBDb21wb25lbnRlIHBhcmEgbW9zdHJhciBib3VuZHMgc2luIHRyYW5zZm9ybWVyIChsw61uZWFzLCBldGMuKVxyXG5jb25zdCBCb3VuZHNJbmRpY2F0b3IgPSAoeyBzZWxlY3RlZEVsZW1lbnRzLCBlbGVtZW50UmVmcywgb2JqZXRvcyB9KSA9PiB7XHJcbiAgY29uc3QgW2ZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGZpcnN0UmVmID0gZWxlbWVudFJlZnMuY3VycmVudD8uW3NlbGVjdGVkRWxlbWVudHNbMF1dO1xyXG4gICAgY29uc3Qgc3RhZ2UgPSBmaXJzdFJlZj8uZ2V0U3RhZ2U/LigpO1xyXG4gICAgaWYgKCFzdGFnZSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZURyYWdNb3ZlID0gKCkgPT4ge1xyXG4gICAgICBzZXRGb3JjZVVwZGF0ZSgocCkgPT4gcCArIDEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGFnZS5vbihcImRyYWdtb3ZlXCIsIGhhbmRsZURyYWdNb3ZlKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHN0YWdlLm9mZihcImRyYWdtb3ZlXCIsIGhhbmRsZURyYWdNb3ZlKTtcclxuICAgIH07XHJcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIildKTtcclxuXHJcbiAgY29uc3QgZWxlbWVudG9zRGF0YSA9IHNlbGVjdGVkRWxlbWVudHNcclxuICAgIC5tYXAoKGlkKSA9PiBvYmpldG9zLmZpbmQoKG9iaikgPT4gb2JqLmlkID09PSBpZCkpXHJcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICBpZiAoZWxlbWVudG9zRGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgbGV0IG1pblggPSBJbmZpbml0eSxcclxuICAgIG1pblkgPSBJbmZpbml0eSxcclxuICAgIG1heFggPSAtSW5maW5pdHksXHJcbiAgICBtYXhZID0gLUluZmluaXR5O1xyXG5cclxuICBlbGVtZW50b3NEYXRhLmZvckVhY2goKG9iaikgPT4ge1xyXG4gICAgY29uc3Qgbm9kZSA9IGVsZW1lbnRSZWZzLmN1cnJlbnRbb2JqLmlkXTtcclxuICAgIGlmICghbm9kZSkgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwibGluZVwiKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gb2JqLnBvaW50cyB8fCBbMCwgMCwgMTAwLCAwXTtcclxuXHJcbiAgICAgICAgY29uc3QgY2xlYW5Qb2ludHMgPSBbXHJcbiAgICAgICAgICBwYXJzZUZsb2F0KHBvaW50c1swXSkgfHwgMCxcclxuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzFdKSB8fCAwLFxyXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbMl0pIHx8IDEwMCxcclxuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzNdKSB8fCAwLFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGNvbnN0IHJlYWxYID0gbm9kZS54KCk7XHJcbiAgICAgICAgY29uc3QgcmVhbFkgPSBub2RlLnkoKTtcclxuXHJcbiAgICAgICAgY29uc3QgeDEgPSByZWFsWCArIGNsZWFuUG9pbnRzWzBdO1xyXG4gICAgICAgIGNvbnN0IHkxID0gcmVhbFkgKyBjbGVhblBvaW50c1sxXTtcclxuICAgICAgICBjb25zdCB4MiA9IHJlYWxYICsgY2xlYW5Qb2ludHNbMl07XHJcbiAgICAgICAgY29uc3QgeTIgPSByZWFsWSArIGNsZWFuUG9pbnRzWzNdO1xyXG5cclxuICAgICAgICBjb25zdCBsaW5lUGFkZGluZyA9IDU7XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4MSAtIGxpbmVQYWRkaW5nLCB4MiAtIGxpbmVQYWRkaW5nKTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeTEgLSBsaW5lUGFkZGluZywgeTIgLSBsaW5lUGFkZGluZyk7XHJcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgxICsgbGluZVBhZGRpbmcsIHgyICsgbGluZVBhZGRpbmcpO1xyXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5MSArIGxpbmVQYWRkaW5nLCB5MiArIGxpbmVQYWRkaW5nKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBib3ggPSBub2RlLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCByID0gYm94O1xyXG4gICAgICAgIGNvbnN0IHN4ID0gKG5vZGU/LnNjYWxlWD8uKCkgPz8gMSk7XHJcbiAgICAgICAgY29uc3Qgc3kgPSAobm9kZT8uc2NhbGVZPy4oKSA/PyAxKTtcclxuICAgICAgICBzbG9nKFxyXG4gICAgICAgICAgXCJbQkldXCIsXHJcbiAgICAgICAgICBgaWQ9JHtvYmouaWR9YCxcclxuICAgICAgICAgIGB0aXBvPSR7b2JqLnRpcG99YCxcclxuICAgICAgICAgIGBzeD0ke3N4LnRvRml4ZWQoMyl9YCxcclxuICAgICAgICAgIGBzeT0ke3N5LnRvRml4ZWQoMyl9YCxcclxuICAgICAgICAgIGByZWN0KHc9JHtyLndpZHRoLnRvRml4ZWQoMSl9LGg9JHtyLmhlaWdodC50b0ZpeGVkKDEpfSlgXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVhbFggPSBib3gueDtcclxuICAgICAgICBjb25zdCByZWFsWSA9IGJveC55O1xyXG4gICAgICAgIGxldCB3aWR0aCA9IGJveC53aWR0aDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gYm94LmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKG9iai50aXBvID09PSBcInRleHRvXCIgJiYgbm9kZS5nZXRUZXh0SGVpZ2h0KSB7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gbm9kZS5nZXRUZXh0SGVpZ2h0KCk7XHJcbiAgICAgICAgICBpZiAodGV4dEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgPSB0ZXh0SGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHJlYWxYKTtcclxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVhbFkpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCByZWFsWCArIHdpZHRoKTtcclxuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcmVhbFkgKyBoZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBmYWxsYmFja1ggPSBvYmoueCB8fCAwO1xyXG4gICAgICBjb25zdCBmYWxsYmFja1kgPSBvYmoueSB8fCAwO1xyXG4gICAgICBjb25zdCBmYWxsYmFja1NpemUgPSAyMDtcclxuXHJcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBmYWxsYmFja1gpO1xyXG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgZmFsbGJhY2tZKTtcclxuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGZhbGxiYWNrWCArIGZhbGxiYWNrU2l6ZSk7XHJcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBmYWxsYmFja1kgKyBmYWxsYmFja1NpemUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAobWluWCA9PT0gSW5maW5pdHkgfHwgbWF4WCA9PT0gLUluZmluaXR5KSB7XHJcbiAgICBjb25zdCBwcmltZXJFbGVtZW50byA9IGVsZW1lbnRvc0RhdGFbMF07XHJcbiAgICBpZiAoIXByaW1lckVsZW1lbnRvKSByZXR1cm4gbnVsbDtcclxuICAgIG1pblggPSBwcmltZXJFbGVtZW50by54IHx8IDA7XHJcbiAgICBtaW5ZID0gcHJpbWVyRWxlbWVudG8ueSB8fCAwO1xyXG4gICAgbWF4WCA9IG1pblggKyAxMDA7XHJcbiAgICBtYXhZID0gbWluWSArIDUwO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcGFkZGluZyA9IDEwO1xyXG4gIGNvbnN0IGZpbmFsWCA9IG1pblggLSBwYWRkaW5nO1xyXG4gIGNvbnN0IGZpbmFsWSA9IG1pblkgLSBwYWRkaW5nO1xyXG4gIGNvbnN0IGZpbmFsV2lkdGggPSBtYXhYIC0gbWluWCArIHBhZGRpbmcgKiAyO1xyXG4gIGNvbnN0IGZpbmFsSGVpZ2h0ID0gbWF4WSAtIG1pblkgKyBwYWRkaW5nICogMjtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxSZWN0XHJcbiAgICAgIG5hbWU9XCJ1aVwiXHJcbiAgICAgIHg9e2ZpbmFsWH1cclxuICAgICAgeT17ZmluYWxZfVxyXG4gICAgICB3aWR0aD17ZmluYWxXaWR0aH1cclxuICAgICAgaGVpZ2h0PXtmaW5hbEhlaWdodH1cclxuICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcclxuICAgICAgc3Ryb2tlPVwiIzkzMzNFQVwiXHJcbiAgICAgIHN0cm9rZVdpZHRoPXsxfVxyXG4gICAgICBsaXN0ZW5pbmc9e2ZhbHNlfVxyXG4gICAgICBvcGFjaXR5PXswLjd9XHJcbiAgICAvPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3Rpb25Cb3VuZHMoe1xyXG4gIHNlbGVjdGVkRWxlbWVudHMsXHJcbiAgZWxlbWVudFJlZnMsXHJcbiAgb2JqZXRvcyxcclxuICBvblRyYW5zZm9ybSxcclxuICBvblRyYW5zZm9ybUludGVyYWN0aW9uU3RhcnQgPSBudWxsLFxyXG4gIG9uVHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQgPSBudWxsLFxyXG4gIGlzRHJhZ2dpbmcsXHJcbiAgaXNNb2JpbGUgPSBmYWxzZSxcclxufSkge1xyXG4gIGNvbnN0IHRyYW5zZm9ybWVyUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IFt0cmFuc2Zvcm1UaWNrLCBzZXRUcmFuc2Zvcm1UaWNrXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IGxhc3ROb2Rlc1JlZiA9IHVzZVJlZihbXSk7XHJcbiAgY29uc3QgY2lyY2xlQW5jaG9yUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3QgdHJhbnNmb3JtR2VzdHVyZVJlZiA9IHVzZVJlZih7XHJcbiAgICBpc1JvdGF0ZTogZmFsc2UsXHJcbiAgICBhY3RpdmVBbmNob3I6IG51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgaXNUcmFuc2Zvcm1pbmdSZXNpemVSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc1Jlc2l6ZUdlc3R1cmVBY3RpdmUsIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3ByZXNzZWRSZXNpemVBbmNob3JOYW1lLCBzZXRQcmVzc2VkUmVzaXplQW5jaG9yTmFtZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICBjb25zdCBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YSA9IHNlbGVjdGVkRWxlbWVudHNcclxuICAgIC5tYXAoKGlkKSA9PiBvYmpldG9zLmZpbmQoKG9iaikgPT4gb2JqLmlkID09PSBpZCkpXHJcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICBjb25zdCBwcmltZXJFbGVtZW50byA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhWzBdIHx8IG51bGw7XHJcbiAgY29uc3QgZXNUZXh0byA9IHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcInRleHRvXCI7XHJcbiAgY29uc3QgZXNDb3VudGRvd24gPSBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJjb3VudGRvd25cIjtcclxuICBjb25zdCBlc0dhbGVyaWEgPSBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJnYWxlcmlhXCI7XHJcbiAgY29uc3QgbG9ja0FzcGVjdENvdW50ZG93biA9IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIGVzQ291bnRkb3duO1xyXG4gIGNvbnN0IGxvY2tBc3BlY3RUZXh0ID0gc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZXNUZXh0bztcclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclNpemUgPSBpc01vYmlsZSA/IDMyIDogMTQ7IC8vdGFtYcOxbyB2aXN1YWwgZGVsIG5vZG8gKG3DoXMgZ3JhbmRlIGVuIG1vYmlsZSkuXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJSb3RhdGVPZmZzZXQgPSBpc01vYmlsZSA/IDM0IDogMjQ7IC8vIGRpc3RhbmNpYSBkZWwgaGFuZGxlIGRlIHJvdGFjacOzbiBhbCBib3JkZS5cclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclJhZGl1cyA9IDk5OTsgLy9yYWRpbyBkZSBlc3F1aW5hIGRlbCBub2RvICg5OTkgbG8gaGFjZSBjaXJjdWxhcikuXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJQYWRkaW5nID0gaXNNb2JpbGUgPyAxNCA6IDQ7IC8vIGVzcGFjaW8gZXh0cmEgZW50cmUgYm9yZGUgZGVsIHRyYW5zZm9ybWVyIHkgZWxlbWVudG8uXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJCb3JkZXJTdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gMS41IDogMTsgLy9ncm9zb3IgZGVsIGJvcmRlIGRlbCB0cmFuc2Zvcm1lci5cclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvckZpbGxDb2xvciA9IFwiIzkzMzNFQVwiO1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclN0cm9rZVdpZHRoID0gaXNNb2JpbGUgPyAxLjQgOiAyLjU7IC8vZ3Jvc29yIGRlbCBib3JkZSBkZWwgbm9kby5cbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dCbHVyID0gaXNNb2JpbGUgPyA5IDogNjsgLy8gcXXDqSB0YW4gZGlmdXNhIGVzIGxhIHNvbWJyYSBiYXNlIGRlbCBub2RvLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSA9IGlzTW9iaWxlID8gNCA6IDM7IC8vIGRlc3BsYXphbWllbnRvIHZlcnRpY2FsIGRlIGVzYSBzb21icmEuXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JIaXRTdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gNjIgOiAyMDtcclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIaXRTdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gOTYgOiAyNDtcclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclN0cm9rZUNvbG9yID0gXCIjZmZmZmZmXCI7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGFsb1N0cm9rZUNvbG9yID0gaXNNb2JpbGVcbiAgICA/IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KVwiXG4gICAgOiB0cmFuc2Zvcm1lckFuY2hvclN0cm9rZUNvbG9yO1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIYWxvU3Ryb2tlV2lkdGggPSBpc01vYmlsZSA/IDIuMiA6IDMuMjtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dDb2xvciA9IFwicmdiYSgxNDcsIDUxLCAyMzQsIDAuMylcIjtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93Q29sb3IgPSBpc01vYmlsZVxuICAgID8gXCJyZ2JhKDIyNCwgMTY4LCAyNTUsIDEpXCJcbiAgICA6IFwicmdiYSgxNDcsIDUxLCAyMzQsIDAuNylcIjtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93Qmx1ciA9IGlzTW9iaWxlID8gMTgwIDogMTg7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd09mZnNldFkgPVxyXG4gICAgaXNNb2JpbGUgPyAwIDogdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dPZmZzZXRZICsgMTtcclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTY2FsZSA9IGlzTW9iaWxlID8gMS4wMyA6IDEuMTtcclxuICBjb25zdCB0cmFuc2Zvcm1lclJvdGF0aW9uU25hcFRvbGVyYW5jZSA9IGlzTW9iaWxlID8gOCA6IDU7IC8vdG9sZXJhbmNpYSBwYXJhIOKAnGVuY2FqYXLigJ0gcm90YWNpw7NuIGVuIMOhbmd1bG9zIGZpam9zLlxyXG4gIGNvbnN0IGVzVHJpYW5ndWxvID1cclxuICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImZvcm1hXCIgJiZcclxuICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwidHJpYW5nbGVcIjtcclxuXHJcbiAgY29uc3QgaGFzR2FsbGVyeSA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhLnNvbWUoXHJcbiAgICAobykgPT4gby50aXBvID09PSBcImdhbGVyaWFcIlxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGhheUxpbmVhcyA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhLnNvbWUoXHJcbiAgICAob2JqKSA9PiBvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwibGluZVwiXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YS5maWx0ZXIoXHJcbiAgICAob2JqKSA9PiAhKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJsaW5lXCIpXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgZGViZXJpYVVzYXJUcmFuc2Zvcm1lciA9XHJcbiAgICBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPiAwO1xyXG5cclxuICBjb25zdCBzZWxlY3RlZEdlb21LZXkgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YVxyXG4gICAgLm1hcCgobykgPT5cclxuICAgICAgW1xyXG4gICAgICAgIG8uaWQsXHJcbiAgICAgICAgby54ID8/IDAsXHJcbiAgICAgICAgby55ID8/IDAsXHJcbiAgICAgICAgby53aWR0aCA/PyBcIlwiLFxyXG4gICAgICAgIG8uaGVpZ2h0ID8/IFwiXCIsXHJcbiAgICAgICAgby5zY2FsZVggPz8gMSxcclxuICAgICAgICBvLnNjYWxlWSA/PyAxLFxyXG4gICAgICAgIG8ucm90YXRpb24gPz8gMCxcclxuICAgICAgICBvLmNoaXBXaWR0aCA/PyBcIlwiLFxyXG4gICAgICAgIG8uZ2FwID8/IFwiXCIsXHJcbiAgICAgICAgby5wYWRkaW5nWCA/PyBcIlwiLFxyXG4gICAgICAgIG8ucGFkZGluZ1kgPz8gXCJcIixcclxuICAgICAgXS5qb2luKFwiOlwiKVxyXG4gICAgKVxyXG4gICAgLmpvaW4oXCJ8XCIpO1xyXG5cclxuICBjb25zdCBnZXRUcmFuc2Zvcm1Qb3NlID0gKG5vZGUpID0+IHtcclxuICAgIGlmICghbm9kZSkgcmV0dXJuIHsgeDogMCwgeTogMCwgcm90YXRpb246IDAgfTtcclxuXHJcbiAgICBpZiAoZXNHYWxlcmlhICYmIHR5cGVvZiBub2RlLmdldFBhcmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDogdHlwZW9mIHBhcmVudC54ID09PSBcImZ1bmN0aW9uXCIgPyBwYXJlbnQueCgpIDogMCxcclxuICAgICAgICAgIHk6IHR5cGVvZiBwYXJlbnQueSA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LnkoKSA6IDAsXHJcbiAgICAgICAgICByb3RhdGlvbjogdHlwZW9mIHBhcmVudC5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LnJvdGF0aW9uKCkgfHwgMCA6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHR5cGVvZiBub2RlLnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogMCxcclxuICAgICAgeTogdHlwZW9mIG5vZGUueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiAwLFxyXG4gICAgICByb3RhdGlvbjogdHlwZW9mIG5vZGUucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUucm90YXRpb24oKSB8fCAwIDogMCxcclxuICAgIH07XHJcbiAgfTtcclxuXHJcblxyXG4gIGNvbnN0IGNsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFjayA9ICgpID0+IHtcclxuICAgIGlmIChpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmUoZmFsc2UpO1xyXG4gICAgc2V0UHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUoKGN1cnJlbnQpID0+IChjdXJyZW50ID8gbnVsbCA6IGN1cnJlbnQpKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRSZXNpemVBbmNob3JOYW1lRnJvbVRhcmdldCA9ICh0YXJnZXQpID0+IHtcclxuICAgIGlmICghdGFyZ2V0KSByZXR1cm4gbnVsbDtcclxuICAgIGNvbnN0IGlzQW5jaG9yVGFyZ2V0ID1cclxuICAgICAgdHlwZW9mIHRhcmdldC5oYXNOYW1lID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/IHRhcmdldC5oYXNOYW1lKFwiX2FuY2hvclwiKVxyXG4gICAgICAgIDogdHlwZW9mIHRhcmdldC5uYW1lID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgIFN0cmluZyh0YXJnZXQubmFtZSgpIHx8IFwiXCIpLmluY2x1ZGVzKFwiX2FuY2hvclwiKTtcclxuICAgIGlmICghaXNBbmNob3JUYXJnZXQpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IHJhd05hbWUgPVxyXG4gICAgICB0eXBlb2YgdGFyZ2V0Lm5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IFN0cmluZyh0YXJnZXQubmFtZSgpIHx8IFwiXCIpIDogXCJcIjtcclxuICAgIGNvbnN0IGFuY2hvck5hbWUgPSByYXdOYW1lLnNwbGl0KFwiIFwiKVswXSB8fCBudWxsO1xyXG4gICAgaWYgKCFhbmNob3JOYW1lKSByZXR1cm4gbnVsbDtcclxuICAgIGlmIChhbmNob3JOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJyb3RhdFwiKSkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gYW5jaG9yTmFtZTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVSZXNpemVBbmNob3JQcmVzc1N0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICBsZXQgYW5jaG9yTmFtZSA9IGdldFJlc2l6ZUFuY2hvck5hbWVGcm9tVGFyZ2V0KGV2ZW50Py50YXJnZXQpO1xyXG4gICAgaWYgKCFhbmNob3JOYW1lKSB7XHJcbiAgICAgIGNvbnN0IGFjdGl2ZUFuY2hvciA9XHJcbiAgICAgICAgdHlwZW9mIHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ/LmdldEFjdGl2ZUFuY2hvciA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICA/IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQuZ2V0QWN0aXZlQW5jaG9yKClcclxuICAgICAgICAgIDogbnVsbDtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR5cGVvZiBhY3RpdmVBbmNob3IgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgICAhYWN0aXZlQW5jaG9yLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJyb3RhdFwiKVxyXG4gICAgICApIHtcclxuICAgICAgICBhbmNob3JOYW1lID0gYWN0aXZlQW5jaG9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWFuY2hvck5hbWUpIHJldHVybjtcclxuICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZSh0cnVlKTtcclxuICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PlxyXG4gICAgICBjdXJyZW50ID09PSBhbmNob3JOYW1lID8gY3VycmVudCA6IGFuY2hvck5hbWVcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0Qm94T3ZlcmZsb3dBbW91bnQgPSAoYm94LCBzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCkgPT4ge1xyXG4gICAgaWYgKCFib3gpIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICBjb25zdCB4ID0gTnVtYmVyKGJveC54KTtcclxuICAgIGNvbnN0IHkgPSBOdW1iZXIoYm94LnkpO1xyXG4gICAgY29uc3Qgd2lkdGggPSBOdW1iZXIoYm94LndpZHRoKTtcclxuICAgIGNvbnN0IGhlaWdodCA9IE51bWJlcihib3guaGVpZ2h0KTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICFOdW1iZXIuaXNGaW5pdGUoeCkgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZSh5KSB8fFxyXG4gICAgICAhTnVtYmVyLmlzRmluaXRlKHdpZHRoKSB8fFxyXG4gICAgICAhTnVtYmVyLmlzRmluaXRlKGhlaWdodClcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbih4LCB4ICsgd2lkdGgpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heCh4LCB4ICsgd2lkdGgpO1xyXG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4oeSwgeSArIGhlaWdodCk7XHJcbiAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heCh5LCB5ICsgaGVpZ2h0KTtcclxuXHJcbiAgICBjb25zdCBvdmVyZmxvd0xlZnQgPSBNYXRoLm1heCgwLCAtbGVmdCk7XHJcbiAgICBjb25zdCBvdmVyZmxvd1RvcCA9IE1hdGgubWF4KDAsIC10b3ApO1xyXG4gICAgY29uc3Qgb3ZlcmZsb3dSaWdodCA9IE1hdGgubWF4KDAsIHJpZ2h0IC0gc3RhZ2VXaWR0aCk7XHJcbiAgICBjb25zdCBvdmVyZmxvd0JvdHRvbSA9IE1hdGgubWF4KDAsIGJvdHRvbSAtIHN0YWdlSGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gb3ZlcmZsb3dMZWZ0ICsgb3ZlcmZsb3dUb3AgKyBvdmVyZmxvd1JpZ2h0ICsgb3ZlcmZsb3dCb3R0b207XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qga2VlcEJveEluc2lkZVN0YWdlID0gKG9sZEJveCwgbmV4dEJveCkgPT4ge1xyXG4gICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgY29uc3Qgc3RhZ2UgPSB0cj8uZ2V0U3RhZ2U/LigpO1xyXG4gICAgY29uc3Qgc3RhZ2VXaWR0aCA9XHJcbiAgICAgIHR5cGVvZiBzdGFnZT8ud2lkdGggPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgID8gTnVtYmVyKHN0YWdlLndpZHRoKCkpXHJcbiAgICAgICAgOiBOdW1iZXIoc3RhZ2U/LmF0dHJzPy53aWR0aCk7XHJcbiAgICBjb25zdCBzdGFnZUhlaWdodCA9XHJcbiAgICAgIHR5cGVvZiBzdGFnZT8uaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/IE51bWJlcihzdGFnZS5oZWlnaHQoKSlcclxuICAgICAgICA6IE51bWJlcihzdGFnZT8uYXR0cnM/LmhlaWdodCk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAhTnVtYmVyLmlzRmluaXRlKHN0YWdlV2lkdGgpIHx8XHJcbiAgICAgIHN0YWdlV2lkdGggPD0gMCB8fFxyXG4gICAgICAhTnVtYmVyLmlzRmluaXRlKHN0YWdlSGVpZ2h0KSB8fFxyXG4gICAgICBzdGFnZUhlaWdodCA8PSAwXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIG5leHRCb3g7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb2xkT3ZlcmZsb3cgPSBnZXRCb3hPdmVyZmxvd0Ftb3VudChvbGRCb3gsIHN0YWdlV2lkdGgsIHN0YWdlSGVpZ2h0KTtcclxuICAgIGNvbnN0IG5leHRPdmVyZmxvdyA9IGdldEJveE92ZXJmbG93QW1vdW50KG5leHRCb3gsIHN0YWdlV2lkdGgsIHN0YWdlSGVpZ2h0KTtcclxuICAgIGNvbnN0IGVwc2lsb24gPSAwLjU7XHJcblxyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobmV4dE92ZXJmbG93KSkge1xyXG4gICAgICByZXR1cm4gb2xkQm94O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuZXh0T3ZlcmZsb3cgPD0gZXBzaWxvbikge1xyXG4gICAgICByZXR1cm4gbmV4dEJveDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQZXJtaXRpciB0cmFuc2Zvcm1hciBkZSB2dWVsdGEgaGFjaWEgYWRlbnRybyBkZWwgY2FudmFzLlxyXG4gICAgaWYgKG5leHRPdmVyZmxvdyA8PSBvbGRPdmVyZmxvdyArIGVwc2lsb24pIHtcclxuICAgICAgcmV0dXJuIG5leHRCb3g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2kgZWwgcmVzaXplIGVtcHVqYSBtw6FzIGFmdWVyYSBkZWwgY2FudmFzLCBtYW50ZW5lciBlbCBlc3RhZG8gYW50ZXJpb3IuXHJcbiAgICByZXR1cm4gb2xkQm94O1xyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDAgfHwgIWRlYmVyaWFVc2FyVHJhbnNmb3JtZXIpIHtcclxuICAgICAgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgc2V0UHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUoKGN1cnJlbnQpID0+IChjdXJyZW50ID8gbnVsbCA6IGN1cnJlbnQpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRHJhZ2dpbmcgJiYgIWlzVHJhbnNmb3JtaW5nUmVzaXplUmVmLmN1cnJlbnQpIHtcclxuICAgICAgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgc2V0UHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUoKGN1cnJlbnQpID0+IChjdXJyZW50ID8gbnVsbCA6IGN1cnJlbnQpKTtcclxuICAgIH1cclxuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGgsIGlzRHJhZ2dpbmcsIGRlYmVyaWFVc2FyVHJhbnNmb3JtZXJdKTtcclxuXHJcbiAgLy8g8J+UpSBFZmVjdG8gcHJpbmNpcGFsIGRlbCBUcmFuc2Zvcm1lciAoU0lOIHJldHJ5IC8gU0lOIGZsaWNrZXIpXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgIGlmICghdHIpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBzZWxLZXkgPSBzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpO1xyXG4gICAgVFJEQkcoXCJFRkZFQ1Qgc3RhcnRcIiwge1xyXG4gICAgICBzZWxLZXksXHJcbiAgICAgIGlzRHJhZ2dpbmcsXHJcbiAgICAgIGRlYmVyaWFVc2FyVHJhbnNmb3JtZXIsXHJcbiAgICAgIGhhc0dhbGxlcnksXHJcbiAgICAgIGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzTGVuOiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGgsXHJcbiAgICAgIHRyYW5zZm9ybVRpY2ssXHJcbiAgICAgIGVkaXRpbmdJZDogd2luZG93LmVkaXRpbmc/LmlkIHx8IG51bGwsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTaSBubyBjb3JyZXNwb25kZSB0cmFuc2Zvcm1lciwgbm8gaGFnYXMgZGV0YWNoIGFncmVzaXZvIChldml0YSBmbGlja2VyKVxyXG4gICAgaWYgKCFkZWJlcmlhVXNhclRyYW5zZm9ybWVyKSB7XHJcbiAgICAgIFRSREJHKFwiRUZGRUNUIGV4aXQ6IG5vIHRyYW5zZm9ybWVyIG9yIGdhbGxlcnlcIiwgeyBzZWxLZXkgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUmVzb2x2ZXIgbm9kZXMgZGVzZGUgcmVmcyAoZnVlbnRlIGRlIHZlcmRhZClcclxuICAgIGxldCBub2Rvc1RyYW5zZm9ybWFibGVzID0gZWxlbWVudG9zVHJhbnNmb3JtYWJsZXNcclxuICAgICAgLm1hcCgobykgPT4gZWxlbWVudFJlZnMuY3VycmVudD8uW28uaWRdKVxyXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICAgIC8vIFNpbmdsZSBzZWxlY3Q6IHVzYXIgcmVmIGZyZXNjbyBTSUVNUFJFXHJcbiAgICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgY29uc3QgaWRTZWwgPSBzZWxlY3RlZEVsZW1lbnRzWzBdO1xyXG4gICAgICBjb25zdCByZWZOb2RlID0gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkU2VsXSB8fCBudWxsO1xyXG4gICAgICBpZiAocmVmTm9kZSAmJiB0eXBlb2YgcmVmTm9kZS5nZXRDbGllbnRSZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBpZiAoZXNHYWxlcmlhICYmIHR5cGVvZiByZWZOb2RlLmZpbmRPbmUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgY29uc3QgZ2FsbGVyeUZyYW1lID0gcmVmTm9kZS5maW5kT25lKFwiLmdhbGxlcnktdHJhbnNmb3JtLWZyYW1lXCIpO1xyXG4gICAgICAgICAgaWYgKGdhbGxlcnlGcmFtZSAmJiB0eXBlb2YgZ2FsbGVyeUZyYW1lLmdldENsaWVudFJlY3QgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBub2Rvc1RyYW5zZm9ybWFibGVzID0gW2dhbGxlcnlGcmFtZV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2Rvc1RyYW5zZm9ybWFibGVzID0gW3JlZk5vZGVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBub2Rvc1RyYW5zZm9ybWFibGVzID0gW3JlZk5vZGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpIGHDum4gbm8gaGF5IG5vZG9zIChpbWFnZW4gY2FyZ2FuZG8sIGV0Yy4pLCBOTyBkZXNwZWdhciAoZXZpdGEgcGFycGFkZW8pXHJcbiAgICBpZiAobm9kb3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgVFJEQkcoXCJFRkZFQ1QgZXhpdDogbm8gbm9kZXMgeWV0XCIsIHtcclxuICAgICAgICBzZWxLZXksXHJcbiAgICAgICAgd2FudGVkSWRzOiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5tYXAobyA9PiBvLmlkKSxcclxuICAgICAgICByZWZzUHJlc2VudDogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubWFwKG8gPT4gISFlbGVtZW50UmVmcy5jdXJyZW50Py5bby5pZF0pLFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBdHRhY2ggZXN0YWJsZVxyXG4gICAgVFJEQkcoXCJBVFRBQ0ggdHJ5XCIsIHtcclxuICAgICAgc2VsS2V5LFxyXG4gICAgICBub2Rlc0NvdW50OiBub2Rvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCxcclxuICAgICAgbm9kZUlkczogbm9kb3NUcmFuc2Zvcm1hYmxlcy5tYXAobiA9PiAodHlwZW9mIG4uaWQgPT09IFwiZnVuY3Rpb25cIiA/IG4uaWQoKSA6IG4uYXR0cnM/LmlkKSksXHJcbiAgICB9KTtcclxuXHJcbiAgICB0ci5ub2Rlcyhub2Rvc1RyYW5zZm9ybWFibGVzKTtcclxuXHJcbiAgICBUUkRCRyhcIkFUVEFDSCBkb25lXCIsIHtcclxuICAgICAgc2VsS2V5LFxyXG4gICAgICB0ck5vZGVzQ291bnQ6IHRyLm5vZGVzPy4oKT8ubGVuZ3RoIHx8IDAsXHJcbiAgICB9KTtcclxuXHJcbiAgICB0cnkgeyB0ci5mb3JjZVVwZGF0ZT8uKCk7IH0gY2F0Y2ggeyB9XHJcbiAgICB0ci5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcclxuXHJcbiAgfSwgW1xyXG4gICAgLy8gRGVwZW5kZW5jaWFzIG3DrW5pbWFzIHJlYWxlc1xyXG4gICAgc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcclxuICAgIGRlYmVyaWFVc2FyVHJhbnNmb3JtZXIsXHJcbiAgICBoYXNHYWxsZXJ5LFxyXG4gICAgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoLFxyXG4gICAgc2VsZWN0ZWRHZW9tS2V5LFxyXG4gICAgdHJhbnNmb3JtVGljayxcclxuICAgIGVsZW1lbnRSZWZzLFxyXG4gIF0pO1xyXG5cclxuXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gKGUpID0+IHtcclxuICAgICAgY29uc3QgaWQgPSBlPy5kZXRhaWw/LmlkO1xyXG4gICAgICBpZiAoIWlkKSByZXR1cm47XHJcblxyXG4gICAgICBUUkRCRyhcIlJFRiBldmVudFwiLCB7XHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgaXNTZWxlY3RlZDogc2VsZWN0ZWRFbGVtZW50cy5pbmNsdWRlcyhpZCksXHJcbiAgICAgICAgc2VsS2V5OiBzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghc2VsZWN0ZWRFbGVtZW50cy5pbmNsdWRlcyhpZCkpIHJldHVybjtcclxuICAgICAgc2V0VHJhbnNmb3JtVGljayh0ID0+IHQgKyAxKTtcclxuICAgIH07XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlbGVtZW50LXJlZi1yZWdpc3RyYWRvXCIsIGhhbmRsZXIpO1xyXG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZWxlbWVudC1yZWYtcmVnaXN0cmFkb1wiLCBoYW5kbGVyKTtcclxuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKV0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgZmlyc3RJZCA9IHNlbGVjdGVkRWxlbWVudHM/LlswXTtcclxuICAgIGlmICghZmlyc3RJZCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltmaXJzdElkXTtcclxuICAgIGNvbnN0IHN0YWdlID0gZmlyc3ROb2RlPy5nZXRTdGFnZT8uKCk7XHJcbiAgICBpZiAoIXN0YWdlKSByZXR1cm47XHJcblxyXG4gICAgbGV0IHJhZklkID0gbnVsbDtcclxuICAgIGNvbnN0IHN5bmNUcmFuc2Zvcm1lciA9ICgpID0+IHtcclxuICAgICAgaWYgKHJhZklkICE9IG51bGwpIHJldHVybjtcclxuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJhZklkID0gbnVsbDtcclxuICAgICAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKCF0cikgcmV0dXJuO1xyXG4gICAgICAgIHRyeSB7IHRyLmZvcmNlVXBkYXRlPy4oKTsgfSBjYXRjaCB7IH1cclxuICAgICAgICB0ci5nZXRMYXllcj8uKCk/LmJhdGNoRHJhdz8uKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGFnZS5vbihcImRyYWdtb3ZlXCIsIHN5bmNUcmFuc2Zvcm1lcik7XHJcbiAgICBzdGFnZS5vbihcImRyYWdlbmRcIiwgc3luY1RyYW5zZm9ybWVyKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBzdGFnZS5vZmYoXCJkcmFnbW92ZVwiLCBzeW5jVHJhbnNmb3JtZXIpO1xyXG4gICAgICBzdGFnZS5vZmYoXCJkcmFnZW5kXCIsIHN5bmNUcmFuc2Zvcm1lcik7XHJcbiAgICAgIGlmIChyYWZJZCAhPSBudWxsKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XHJcbiAgICB9O1xyXG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpLCBlbGVtZW50UmVmc10pO1xyXG5cclxuXHJcblxyXG5cclxuICAvLyDwn5SlIFJlbmRlclxyXG5cclxuICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG5cclxuICBpZiAoaGF5TGluZWFzICYmIGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPEJvdW5kc0luZGljYXRvclxyXG4gICAgICAgIHNlbGVjdGVkRWxlbWVudHM9e3NlbGVjdGVkRWxlbWVudHN9XHJcbiAgICAgICAgZWxlbWVudFJlZnM9e2VsZW1lbnRSZWZzfVxyXG4gICAgICAgIG9iamV0b3M9e29iamV0b3N9XHJcbiAgICAgIC8+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGhheUxpbmVhcyAmJiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8Qm91bmRzSW5kaWNhdG9yXHJcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50cz17c2VsZWN0ZWRFbGVtZW50c31cclxuICAgICAgICBlbGVtZW50UmVmcz17ZWxlbWVudFJlZnN9XHJcbiAgICAgICAgb2JqZXRvcz17b2JqZXRvc31cclxuICAgICAgLz5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFRyYW5zZm9ybWVyXHJcbiAgICAgIG5hbWU9XCJ1aVwiXHJcbiAgICAgIHJlZj17dHJhbnNmb3JtZXJSZWZ9XHJcblxyXG4gICAgICAvLyDwn5S1IGJvcmRlIHNpZW1wcmUgdmlzaWJsZVxyXG4gICAgICBib3JkZXJFbmFibGVkPXt0cnVlfVxyXG5cclxuICAgICAgYm9yZGVyU3Ryb2tlPVwiIzkzMzNFQVwiXHJcblxyXG5cclxuICAgICAgYm9yZGVyU3Ryb2tlV2lkdGg9e3RyYW5zZm9ybWVyQm9yZGVyU3Ryb2tlV2lkdGh9XHJcbiAgICAgIHBhZGRpbmc9e3RyYW5zZm9ybWVyUGFkZGluZ31cclxuXHJcbiAgICAgIC8vIOKdjCBub2RvcyB5IHJvdGFjacOzbiBPRkYgZHVyYW50ZSBkcmFnXHJcbiAgICAgIGVuYWJsZWRBbmNob3JzPXtpc0RyYWdnaW5nICYmICFpc1Jlc2l6ZUdlc3R1cmVBY3RpdmUgPyBbXSA6IFtcImJvdHRvbS1yaWdodFwiXX1cclxuICAgICAgcm90YXRlRW5hYmxlZD17IWlzRHJhZ2dpbmcgJiYgIWVzR2FsZXJpYX1cclxuICAgICAgb25Nb3VzZURvd249e2hhbmRsZVJlc2l6ZUFuY2hvclByZXNzU3RhcnR9XHJcbiAgICAgIG9uVG91Y2hTdGFydD17aGFuZGxlUmVzaXplQW5jaG9yUHJlc3NTdGFydH1cclxuICAgICAgb25Qb2ludGVyRG93bj17aGFuZGxlUmVzaXplQW5jaG9yUHJlc3NTdGFydH1cclxuICAgICAgb25Nb3VzZVVwPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcbiAgICAgIG9uVG91Y2hFbmQ9e2NsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFja31cclxuICAgICAgb25Qb2ludGVyVXA9e2NsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFja31cclxuICAgICAgb25Ub3VjaENhbmNlbD17Y2xlYXJSZXNpemVBbmNob3JQcmVzc0ZlZWRiYWNrfVxyXG4gICAgICBvblBvaW50ZXJDYW5jZWw9e2NsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFja31cclxuXHJcbiAgICAgIGFuY2hvckZpbGw9e3RyYW5zZm9ybWVyQW5jaG9yRmlsbENvbG9yfVxuICAgICAgYW5jaG9yU3Ryb2tlPXt0cmFuc2Zvcm1lckFuY2hvclN0cm9rZUNvbG9yfVxyXG4gICAgICBhbmNob3JTdHJva2VXaWR0aD17dHJhbnNmb3JtZXJBbmNob3JTdHJva2VXaWR0aH1cclxuICAgICAgYW5jaG9yU2l6ZT17dHJhbnNmb3JtZXJBbmNob3JTaXplfVxyXG4gICAgICBhbmNob3JDb3JuZXJSYWRpdXM9e3RyYW5zZm9ybWVyQW5jaG9yUmFkaXVzfVxyXG4gICAgICBhbmNob3JTaGFkb3dDb2xvcj17dHJhbnNmb3JtZXJBbmNob3JTaGFkb3dDb2xvcn1cclxuICAgICAgYW5jaG9yU2hhZG93Qmx1cj17dHJhbnNmb3JtZXJBbmNob3JTaGFkb3dCbHVyfVxyXG4gICAgICBhbmNob3JTaGFkb3dPZmZzZXQ9e3sgeDogMCwgeTogdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dPZmZzZXRZIH19XHJcbiAgICAgIGFuY2hvclN0eWxlRnVuYz17KGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFuY2hvck5hbWUgPVxyXG4gICAgICAgICAgdHlwZW9mIGFuY2hvcj8ubmFtZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgID8gU3RyaW5nKGFuY2hvci5uYW1lKCkgfHwgXCJcIikuc3BsaXQoXCIgXCIpWzBdXHJcbiAgICAgICAgICAgIDogXCJcIjtcclxuICAgICAgICBjb25zdCBpc1Jlc2l6ZUFuY2hvck5vZGUgPVxyXG4gICAgICAgICAgQm9vbGVhbihhbmNob3JOYW1lKSAmJiAhYW5jaG9yTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIik7XHJcbiAgICAgICAgY29uc3QgaXNSZXNpemVBY3RpdmVGYWxsYmFjayA9XHJcbiAgICAgICAgICBpc1Jlc2l6ZUdlc3R1cmVBY3RpdmUgfHxcclxuICAgICAgICAgIGlzVHJhbnNmb3JtaW5nUmVzaXplUmVmLmN1cnJlbnQgfHxcclxuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgICAgIEJvb2xlYW4od2luZG93Ll9yZXNpemVEYXRhPy5pc1Jlc2l6aW5nKSk7XHJcbiAgICAgICAgY29uc3QgaXNQcmVzc2VkUmVzaXplQW5jaG9yID1cclxuICAgICAgICAgIGlzUmVzaXplQWN0aXZlRmFsbGJhY2sgJiZcclxuICAgICAgICAgIGlzUmVzaXplQW5jaG9yTm9kZSAmJlxyXG4gICAgICAgICAgKCFwcmVzc2VkUmVzaXplQW5jaG9yTmFtZSB8fCBhbmNob3JOYW1lID09PSBwcmVzc2VkUmVzaXplQW5jaG9yTmFtZSk7XHJcblxyXG4gICAgICAgIGFuY2hvci5zaGFkb3dDb2xvcihcbiAgICAgICAgICBpc1ByZXNzZWRSZXNpemVBbmNob3JcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93Q29sb3JcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dDb2xvclxuICAgICAgICApO1xuICAgICAgICBhbmNob3IuZmlsbChcbiAgICAgICAgICBpc1ByZXNzZWRSZXNpemVBbmNob3JcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkQ29yZUNvbG9yXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yRmlsbENvbG9yXG4gICAgICAgICk7XG4gICAgICAgIGFuY2hvci5zaGFkb3dFbmFibGVkKHRydWUpO1xuICAgICAgICAvLyBIYWxvIG5hY2UgZGVzZGUgZWwgY2VudHJvIChmaWxsKSB5IHNlIGRlc3ZhbmVjZSBoYWNpYSBhZnVlcmEuXG4gICAgICAgIGFuY2hvci5zaGFkb3dGb3JTdHJva2VFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgYW5jaG9yLnNoYWRvd09wYWNpdHkoaXNQcmVzc2VkUmVzaXplQW5jaG9yID8gMC45NiA6IDAuMjgpO1xuICAgICAgICBhbmNob3Iuc2hhZG93Qmx1cihcclxuICAgICAgICAgIGlzUHJlc3NlZFJlc2l6ZUFuY2hvclxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0JsdXJcclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lckFuY2hvclNoYWRvd0JsdXJcclxuICAgICAgICApO1xyXG4gICAgICAgIGFuY2hvci5zaGFkb3dPZmZzZXQoe1xyXG4gICAgICAgICAgeDogMCxcclxuICAgICAgICAgIHk6IGlzUHJlc3NlZFJlc2l6ZUFuY2hvclxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd09mZnNldFlcclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lckFuY2hvclNoYWRvd09mZnNldFksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYW5jaG9yLmhpdFN0cm9rZVdpZHRoKFxyXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXHJcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGl0U3Ryb2tlV2lkdGhcclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lckFuY2hvckhpdFN0cm9rZVdpZHRoXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbmNob3Iuc3Ryb2tlKFxyXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXHJcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGFsb1N0cm9rZUNvbG9yXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZXJBbmNob3JTdHJva2VDb2xvclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYW5jaG9yLnN0cm9rZVdpZHRoKFxyXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXHJcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGFsb1N0cm9rZVdpZHRoXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZXJBbmNob3JTdHJva2VXaWR0aFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yU2NhbGUgPSBpc1ByZXNzZWRSZXNpemVBbmNob3JcclxuICAgICAgICAgID8gdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2NhbGVcclxuICAgICAgICAgIDogMTtcclxuICAgICAgICBhbmNob3Iuc2NhbGUoeyB4OiBhbmNob3JTY2FsZSwgeTogYW5jaG9yU2NhbGUgfSk7XHJcbiAgICAgIH19XHJcbiAgICAgIGtlZXBSYXRpbz17bG9ja0FzcGVjdENvdW50ZG93biB8fCBlc0dhbGVyaWEgfHwgbG9ja0FzcGVjdFRleHR9XHJcbiAgICAgIGNlbnRlcmVkU2NhbGluZz17c2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZXNUZXh0b31cclxuICAgICAgZmxpcEVuYWJsZWQ9e2ZhbHNlfVxyXG4gICAgICByZXNpemVFbmFibGVkPXshaXNEcmFnZ2luZyB8fCBpc1Jlc2l6ZUdlc3R1cmVBY3RpdmV9XHJcbiAgICAgIHJvdGF0aW9uU25hcHM9e1swLCA0NSwgOTAsIDEzNSwgMTgwLCAyMjUsIDI3MCwgMzE1XX1cclxuICAgICAgcm90YXRlQW5jaG9yT2Zmc2V0PXt0cmFuc2Zvcm1lclJvdGF0ZU9mZnNldH1cclxuICAgICAgcm90YXRpb25TbmFwVG9sZXJhbmNlPXt0cmFuc2Zvcm1lclJvdGF0aW9uU25hcFRvbGVyYW5jZX1cclxuICAgICAgYm91bmRCb3hGdW5jPXsob2xkQm94LCBuZXdCb3gpID0+IHtcclxuICAgICAgICBjb25zdCBtaW5TaXplID0gZXNUZXh0byA/IDIwIDogMTA7XHJcbiAgICAgICAgY29uc3QgbWF4U2l6ZSA9IDgwMDtcclxuICAgICAgICBpZiAoZXNHYWxlcmlhKSB7XHJcbiAgICAgICAgICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgTnVtYmVyKHByaW1lckVsZW1lbnRvPy5yb3dzKSB8fCAxKTtcclxuICAgICAgICAgIGNvbnN0IGNvbHMgPSBNYXRoLm1heCgxLCBOdW1iZXIocHJpbWVyRWxlbWVudG8/LmNvbHMpIHx8IDEpO1xyXG4gICAgICAgICAgY29uc3QgZ2FwID0gTWF0aC5tYXgoMCwgTnVtYmVyKHByaW1lckVsZW1lbnRvPy5nYXApIHx8IDApO1xyXG4gICAgICAgICAgY29uc3QgY2VsbFJhdGlvID1cclxuICAgICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnJhdGlvID09PSBcIjQ6M1wiXHJcbiAgICAgICAgICAgICAgPyAzIC8gNFxyXG4gICAgICAgICAgICAgIDogcHJpbWVyRWxlbWVudG8/LnJhdGlvID09PSBcIjE2OjlcIlxyXG4gICAgICAgICAgICAgICAgPyA5IC8gMTZcclxuICAgICAgICAgICAgICAgIDogMTtcclxuXHJcbiAgICAgICAgICBjb25zdCBtaW5HcmlkV2lkdGggPSBnYXAgKiAoY29scyAtIDEpICsgY29scztcclxuICAgICAgICAgIGNvbnN0IG5leHRXaWR0aCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBtYXhTaXplLFxyXG4gICAgICAgICAgICBNYXRoLm1heChtaW5TaXplLCBtaW5HcmlkV2lkdGgsIE1hdGguYWJzKG5ld0JveC53aWR0aCkpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY29uc3QgY2VsbFcgPSBNYXRoLm1heCgxLCAobmV4dFdpZHRoIC0gZ2FwICogKGNvbHMgLSAxKSkgLyBjb2xzKTtcclxuICAgICAgICAgIGNvbnN0IGNlbGxIID0gY2VsbFcgKiBjZWxsUmF0aW87XHJcbiAgICAgICAgICBjb25zdCBuZXh0SGVpZ2h0ID0gcm93cyAqIGNlbGxIICsgZ2FwICogKHJvd3MgLSAxKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4ga2VlcEJveEluc2lkZVN0YWdlKG9sZEJveCwge1xyXG4gICAgICAgICAgICAuLi5uZXdCb3gsXHJcbiAgICAgICAgICAgIHdpZHRoOiBuZXh0V2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgobWluU2l6ZSwgbmV4dEhlaWdodCksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdCb3gud2lkdGggPCBtaW5TaXplIHx8IG5ld0JveC5oZWlnaHQgPCBtaW5TaXplKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2xkQm94O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxvY2tBc3BlY3RDb3VudGRvd24pIHtcclxuICAgICAgICAgIGNvbnN0IGJhc2VXID0gTWF0aC5tYXgoMSwgb2xkQm94LndpZHRoKTtcclxuICAgICAgICAgIGNvbnN0IGJhc2VIID0gTWF0aC5tYXgoMSwgb2xkQm94LmhlaWdodCk7XHJcbiAgICAgICAgICBjb25zdCByYXRpbyA9IGJhc2VXIC8gYmFzZUg7XHJcblxyXG4gICAgICAgICAgY29uc3QgZHcgPSBNYXRoLmFicyhuZXdCb3gud2lkdGggLSBvbGRCb3gud2lkdGgpIC8gYmFzZVc7XHJcbiAgICAgICAgICBjb25zdCBkaCA9IE1hdGguYWJzKG5ld0JveC5oZWlnaHQgLSBvbGRCb3guaGVpZ2h0KSAvIGJhc2VIO1xyXG5cclxuICAgICAgICAgIGxldCB3aWR0aCA9IG5ld0JveC53aWR0aDtcclxuICAgICAgICAgIGxldCBoZWlnaHQgPSBuZXdCb3guaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmIChkaCA+IGR3KSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogcmF0aW87XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIHJhdGlvO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBrZWVwQm94SW5zaWRlU3RhZ2Uob2xkQm94LCB7XHJcbiAgICAgICAgICAgIC4uLm5ld0JveCxcclxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBtaW5TaXplKSwgbWF4U2l6ZSksXHJcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5taW4oTWF0aC5tYXgoaGVpZ2h0LCBtaW5TaXplKSwgbWF4U2l6ZSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImZvcm1hXCIgJiZcclxuICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCJcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heChuZXdCb3gud2lkdGgsIG5ld0JveC5oZWlnaHQpO1xyXG4gICAgICAgICAgY29uc3QgZmluYWxTaXplID0gTWF0aC5taW4oc2l6ZSwgbWF4U2l6ZSk7XHJcbiAgICAgICAgICByZXR1cm4ga2VlcEJveEluc2lkZVN0YWdlKG9sZEJveCwge1xyXG4gICAgICAgICAgICAuLi5uZXdCb3gsXHJcbiAgICAgICAgICAgIHdpZHRoOiBmaW5hbFNpemUsXHJcbiAgICAgICAgICAgIGhlaWdodDogZmluYWxTaXplLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXNUcmlhbmd1bG8pIHtcclxuICAgICAgICAgIGNvbnN0IHNhZmVPbGRXID0gTWF0aC5tYXgoMSwgTWF0aC5hYnMob2xkQm94LndpZHRoIHx8IG1pblNpemUpKTtcclxuICAgICAgICAgIGNvbnN0IHNhZmVPbGRIID0gTWF0aC5tYXgoMSwgTWF0aC5hYnMob2xkQm94LmhlaWdodCB8fCBtaW5TaXplKSk7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhuZXdCb3gud2lkdGgpIC8gc2FmZU9sZFc7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBNYXRoLmFicyhuZXdCb3guaGVpZ2h0KSAvIHNhZmVPbGRIO1xyXG4gICAgICAgICAgY29uc3QgdW5pZm9ybVNjYWxlID0gTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKTtcclxuXHJcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGgubWF4KHNhZmVPbGRXICogdW5pZm9ybVNjYWxlLCBtaW5TaXplKSwgbWF4U2l6ZSk7XHJcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChzYWZlT2xkSCAqIHVuaWZvcm1TY2FsZSwgbWluU2l6ZSksIG1heFNpemUpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBrZWVwQm94SW5zaWRlU3RhZ2Uob2xkQm94LCB7XHJcbiAgICAgICAgICAgIC4uLm5ld0JveCxcclxuICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiaW1hZ2VuXCIgfHxcclxuICAgICAgICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImljb25vXCJcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IG5ld0JveC53aWR0aCAvIG9sZEJveC53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG5ld0JveC5oZWlnaHQgLyBvbGRCb3guaGVpZ2h0O1xyXG4gICAgICAgICAgY29uc3QgdW5pZm9ybVNjYWxlID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gb2xkQm94LndpZHRoICogdW5pZm9ybVNjYWxlO1xyXG4gICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gb2xkQm94LmhlaWdodCAqIHVuaWZvcm1TY2FsZTtcclxuXHJcbiAgICAgICAgICByZXR1cm4ga2VlcEJveEluc2lkZVN0YWdlKG9sZEJveCwge1xyXG4gICAgICAgICAgICAuLi5uZXdCb3gsXHJcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihNYXRoLm1heChuZXdXaWR0aCwgbWluU2l6ZSksIG1heFNpemUpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKE1hdGgubWF4KG5ld0hlaWdodCwgbWluU2l6ZSksIG1heFNpemUpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ga2VlcEJveEluc2lkZVN0YWdlKG9sZEJveCwge1xyXG4gICAgICAgICAgLi4ubmV3Qm94LFxyXG4gICAgICAgICAgd2lkdGg6IE1hdGgubWluKG5ld0JveC53aWR0aCwgbWF4U2l6ZSksXHJcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKG5ld0JveC5oZWlnaHQsIG1heFNpemUpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9fVxyXG4gICAgICBvblRyYW5zZm9ybVN0YXJ0PXsoZSkgPT4ge1xyXG4gICAgICAgIGlzVHJhbnNmb3JtaW5nUmVzaXplUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IHsgaXNSZXNpemluZzogdHJ1ZSB9O1xyXG4gICAgICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBhY3RpdmVBbmNob3IgPVxyXG4gICAgICAgICAgdHlwZW9mIHRyPy5nZXRBY3RpdmVBbmNob3IgPT09IFwiZnVuY3Rpb25cIiA/IHRyLmdldEFjdGl2ZUFuY2hvcigpIDogbnVsbDtcclxuICAgICAgICBjb25zdCBpc1JvdGF0ZUdlc3R1cmUgPVxyXG4gICAgICAgICAgdHlwZW9mIGFjdGl2ZUFuY2hvciA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgYWN0aXZlQW5jaG9yLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJyb3RhdFwiKTtcclxuICAgICAgICB0cmFuc2Zvcm1HZXN0dXJlUmVmLmN1cnJlbnQgPSB7XHJcbiAgICAgICAgICBpc1JvdGF0ZTogaXNSb3RhdGVHZXN0dXJlLFxyXG4gICAgICAgICAgYWN0aXZlQW5jaG9yOiBhY3RpdmVBbmNob3IgPz8gbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghaXNSb3RhdGVHZXN0dXJlKSB7XHJcbiAgICAgICAgICBzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSb3RhdGVHZXN0dXJlICYmIGFjdGl2ZUFuY2hvcikge1xyXG4gICAgICAgICAgc2V0UHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUoKGN1cnJlbnQpID0+XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPT09IGFjdGl2ZUFuY2hvciA/IGN1cnJlbnQgOiBhY3RpdmVBbmNob3JcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb25UcmFuc2Zvcm1JbnRlcmFjdGlvblN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIG9uVHJhbnNmb3JtSW50ZXJhY3Rpb25TdGFydCh7XHJcbiAgICAgICAgICAgIGlzUm90YXRlOiBpc1JvdGF0ZUdlc3R1cmUsXHJcbiAgICAgICAgICAgIGFjdGl2ZUFuY2hvcjogYWN0aXZlQW5jaG9yID8/IG51bGwsXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBlPy5ldnQ/LnBvaW50ZXJUeXBlID8/IG51bGwsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG5vZGVzID0gdHI/Lm5vZGVzPy4oKSB8fCBbXTtcclxuICAgICAgICAgIGNpcmNsZUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBub2Rlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZm9ybWFcIiAmJlxyXG4gICAgICAgICAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCByMCA9IG5vZGVzWzBdLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjaXJjbGVBbmNob3JSZWYuY3VycmVudCA9IHsgbGVmdDogcjAueCwgdG9wOiByMC55IH07XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxICYmIGVzVGV4dG8pIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdO1xyXG4gICAgICAgICAgICBsZXQgY2VudGVyWCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBjZW50ZXJZID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGJhc2VXaWR0aCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBiYXNlSGVpZ2h0ID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGJhc2VWaXN1YWxXaWR0aCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ueCkgJiYgTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IHJlY3QueCArIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ueSkgJiYgTnVtYmVyLmlzRmluaXRlKHJlY3Q/LmhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIGNlbnRlclkgPSByZWN0LnkgKyAocmVjdC5oZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkgJiYgcmVjdC53aWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJhc2VXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBiYXNlVmlzdWFsV2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LmhlaWdodCkgJiYgcmVjdC5oZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgIGNvbnN0IHNhZmVCYXNlRm9udFNpemUgPVxyXG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwcmltZXJFbGVtZW50bz8uZm9udFNpemUpICYmIHByaW1lckVsZW1lbnRvLmZvbnRTaXplID4gMFxyXG4gICAgICAgICAgICAgICAgPyBwcmltZXJFbGVtZW50by5mb250U2l6ZVxyXG4gICAgICAgICAgICAgICAgOiAyNDtcclxuICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50ID0ge1xyXG4gICAgICAgICAgICAgIHk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IDAsXHJcbiAgICAgICAgICAgICAgYmFzZVJvdGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGU/LnJvdGF0aW9uID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5yb3RhdGlvbigpIHx8IDApIDogMCxcclxuICAgICAgICAgICAgICBjZW50ZXJYLFxyXG4gICAgICAgICAgICAgIGNlbnRlclksXHJcbiAgICAgICAgICAgICAgYmFzZVdpZHRoLFxyXG4gICAgICAgICAgICAgIGJhc2VIZWlnaHQsXHJcbiAgICAgICAgICAgICAgYmFzZUZvbnRTaXplOiBzYWZlQmFzZUZvbnRTaXplLFxyXG4gICAgICAgICAgICAgIGxhc3RQcmV2aWV3Rm9udFNpemU6IHNhZmVCYXNlRm9udFNpemUsXHJcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdDZW50ZXJYOiBjZW50ZXJYLFxyXG4gICAgICAgICAgICAgIGxhc3RQcmV2aWV3Q2VudGVyWTogY2VudGVyWSxcclxuICAgICAgICAgICAgICBsYXN0UHJldmlld1Zpc3VhbFdpZHRoOiBiYXNlVmlzdWFsV2lkdGgsXHJcbiAgICAgICAgICAgICAgcHJldmlld1RpY2s6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRYVERCRyhcInN0YXJ0XCIsIHtcclxuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgYmFzZUZvbnRTaXplOiBzYWZlQmFzZUZvbnRTaXplLFxyXG4gICAgICAgICAgICAgIGJhc2VXaWR0aCxcclxuICAgICAgICAgICAgICBiYXNlSGVpZ2h0LFxyXG4gICAgICAgICAgICAgIGNlbnRlclgsXHJcbiAgICAgICAgICAgICAgY2VudGVyWSxcclxuICAgICAgICAgICAgICBub2RlWDogdHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICBub2RlWTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICBub2RlU2NhbGVYOiB0eXBlb2Ygbm9kZT8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICBub2RlU2NhbGVZOiB0eXBlb2Ygbm9kZT8uc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgdW5pb24gPSByZWN0RnJvbU5vZGVzKG5vZGVzKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBwYWQgPSB0eXBlb2YgdHI/LnBhZGRpbmcgPT09IFwiZnVuY3Rpb25cIiA/IHRyLnBhZGRpbmcoKSA6IDA7XHJcbiAgICAgICAgICBjb25zdCBib3JkZXJSZWN0ID0gdW5pb25cclxuICAgICAgICAgICAgPyB7IHg6IHVuaW9uLnggLSBwYWQsIHk6IHVuaW9uLnkgLSBwYWQsIHdpZHRoOiB1bmlvbi53aWR0aCArIHBhZCAqIDIsIGhlaWdodDogdW5pb24uaGVpZ2h0ICsgcGFkICogMiB9XHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuXHJcbiAgICAgICAgICBjb25zdCBuID0gbm9kZXNbMF07XHJcbiAgICAgICAgICBjb25zdCBpZCA9IG4gPyAodHlwZW9mIG4uaWQgPT09IFwiZnVuY3Rpb25cIiA/IG4uaWQoKSA6IG4uYXR0cnM/LmlkKSA6IFwi4oiFXCI7XHJcbiAgICAgICAgICBjb25zdCB0clJlY3QgPSB0cj8uZ2V0Q2xpZW50UmVjdD8uKHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XHJcblxyXG4gICAgICAgICAgc2xvZyhcclxuICAgICAgICAgICAgXCJbVFJdIHN0YXJ0XCIsXHJcbiAgICAgICAgICAgIGBpZD0ke2lkfWAsXHJcbiAgICAgICAgICAgIGBub2Rlcz0ke25vZGVzLmxlbmd0aH1gLFxyXG4gICAgICAgICAgICB1bmlvbiA/IGB1bmlvbih3PSR7dW5pb24ud2lkdGgudG9GaXhlZCgxKX0saD0ke3VuaW9uLmhlaWdodC50b0ZpeGVkKDEpfSlgIDogXCJ1bmlvbihudWxsKVwiLFxyXG4gICAgICAgICAgICBib3JkZXJSZWN0ID8gYGJvcmRlcih3PSR7Ym9yZGVyUmVjdC53aWR0aC50b0ZpeGVkKDEpfSxoPSR7Ym9yZGVyUmVjdC5oZWlnaHQudG9GaXhlZCgxKX0pYCA6IFwiYm9yZGVyKG51bGwpXCIsXHJcbiAgICAgICAgICAgIHRyUmVjdCA/IGB0clJlY3Qodz0ke3RyUmVjdC53aWR0aC50b0ZpeGVkKDEpfSxoPSR7dHJSZWN0LmhlaWdodC50b0ZpeGVkKDEpfSlgIDogXCJ0clJlY3QobnVsbClcIixcclxuICAgICAgICAgICAgYHBhZD0ke3BhZH1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggeyB9XHJcbiAgICAgIH19XHJcblxyXG4gICAgICBvblRyYW5zZm9ybT17KGUpID0+IHtcclxuICAgICAgICBpZiAoIW9uVHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm1lclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBub2RlcyA9IHR5cGVvZiB0ci5ub2RlcyA9PT0gXCJmdW5jdGlvblwiID8gdHIubm9kZXMoKSB8fCBbXSA6IFtdO1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTsgLy8g4pyFIG5vZG8gcmVhbCAoc2luZ2xlIHNlbGVjdClcclxuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHBvc2UgPSBnZXRUcmFuc2Zvcm1Qb3NlKG5vZGUpO1xyXG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtRGF0YSA9IHtcclxuICAgICAgICAgICAgeDogcG9zZS54LFxyXG4gICAgICAgICAgICB5OiBwb3NlLnksXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBwb3NlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICBpc1ByZXZpZXc6IHRydWUsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGlmIChlc1RleHRvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRm9udFNpemUgPSBwcmltZXJFbGVtZW50by5mb250U2l6ZSB8fCAyNDtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yRGF0YSA9IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCB8fCBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlRm9udFNpemUgPVxyXG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5iYXNlRm9udFNpemUpICYmXHJcbiAgICAgICAgICAgICAgYW5jaG9yRGF0YS5iYXNlRm9udFNpemUgPiAwXHJcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEuYmFzZUZvbnRTaXplXHJcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRm9udFNpemU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGVGcm9tUmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBsaXZlUmVjdFdpZHRoID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFJvdGF0aW9uID1cclxuICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUucm90YXRpb24oKSB8fCAwKSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VSb3RhdGlvbiA9IE51bWJlcihhbmNob3JEYXRhPy5iYXNlUm90YXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGlvbkRlbHRhID0gTnVtYmVyLmlzRmluaXRlKGJhc2VSb3RhdGlvbilcclxuICAgICAgICAgICAgICA/IE1hdGguYWJzKGN1cnJlbnRSb3RhdGlvbiAtIGJhc2VSb3RhdGlvbilcclxuICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsaXZlUmVjdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVdpZHRoID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VXaWR0aCk7XHJcbiAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGJhc2VXaWR0aCkgJiZcclxuICAgICAgICAgICAgICAgIGJhc2VXaWR0aCA+IDAgJiZcclxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkgJiZcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPiAwXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZUZyb21SZWN0ID0gcmVjdC53aWR0aCAvIGJhc2VXaWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgY29uc3QgY2FuVXNlUmVjdFNjYWxlID0gcm90YXRpb25EZWx0YSA8IDAuMTtcclxuICAgICAgICAgICAgY29uc3QgZWZmZWN0aXZlU2NhbGUgPVxyXG4gICAgICAgICAgICAgIGNhblVzZVJlY3RTY2FsZSAmJiBOdW1iZXIuaXNGaW5pdGUoc2NhbGVGcm9tUmVjdCkgJiYgc2NhbGVGcm9tUmVjdCA+IDBcclxuICAgICAgICAgICAgICAgID8gc2NhbGVGcm9tUmVjdFxyXG4gICAgICAgICAgICAgICAgOiBhdmdTY2FsZTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5mb250U2l6ZSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgIDYsXHJcbiAgICAgICAgICAgICAgTnVtYmVyKChiYXNlRm9udFNpemUgKiBlZmZlY3RpdmVTY2FsZSkudG9GaXhlZCgzKSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRpY2sgPSBOdW1iZXIodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LnByZXZpZXdUaWNrIHx8IDApICsgMTtcclxuICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQucHJldmlld1RpY2sgPSB0aWNrO1xyXG4gICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld0ZvbnRTaXplID0gdHJhbnNmb3JtRGF0YS5mb250U2l6ZTtcclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGxpdmVSZWN0V2lkdGgpICYmIGxpdmVSZWN0V2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdWaXN1YWxXaWR0aCA9IGxpdmVSZWN0V2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh0aWNrIDw9IDIgfHwgdGljayAlIDUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIFRYVERCRyhcInByZXZpZXdcIiwge1xyXG4gICAgICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIHRpY2ssXHJcbiAgICAgICAgICAgICAgICAgIHNjYWxlWCxcclxuICAgICAgICAgICAgICAgICAgc2NhbGVZLFxyXG4gICAgICAgICAgICAgICAgICBhdmdTY2FsZSxcclxuICAgICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCxcclxuICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlU2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgIGJhc2VGb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHRyYW5zZm9ybURhdGEuZm9udFNpemUsXHJcbiAgICAgICAgICAgICAgICAgIGxpdmVSZWN0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgIGNlbnRlclhUYXJnZXQ6IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudD8uY2VudGVyWCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBub2RlWDogdHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgbm9kZVk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChjYW5Vc2VSZWN0U2NhbGUgJiYgTnVtYmVyLmlzRmluaXRlKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudD8ueSkpIHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnkgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudD8uY2VudGVyWCkpIHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRleHRDZW50ZXJYID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclg7XHJcbiAgICAgICAgICAgICAgaWYgKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Lmxhc3RQcmV2aWV3Q2VudGVyWCA9XHJcbiAgICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5jZW50ZXJYO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudD8uY2VudGVyWSkpIHtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRleHRDZW50ZXJZID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclk7XHJcbiAgICAgICAgICAgICAgaWYgKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Lmxhc3RQcmV2aWV3Q2VudGVyWSA9XHJcbiAgICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcclxuXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWSA9IHNjYWxlWTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50ZG93blNpemUgPSBnZXRDb3VudGRvd25TY2FsZWRTaXplKG5vZGUpO1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEud2lkdGggPSBjb3VudGRvd25TaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuaGVpZ2h0ID0gY291bnRkb3duU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXNUcmlhbmd1bG8pIHtcclxuICAgICAgICAgICAgICBjb25zdCBiYXNlUmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKHByaW1lckVsZW1lbnRvPy5yYWRpdXMpXHJcbiAgICAgICAgICAgICAgICA/IHByaW1lckVsZW1lbnRvLnJhZGl1c1xyXG4gICAgICAgICAgICAgICAgOiA2MDtcclxuICAgICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEucmFkaXVzID0gTWF0aC5tYXgoMSwgYmFzZVJhZGl1cyAqIGF2Z1NjYWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gcHJpbWVyRWxlbWVudG8ud2lkdGggfHwgMTAwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcHJpbWVyRWxlbWVudG8uaGVpZ2h0IHx8IDEwMDtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLndpZHRoID0gTWF0aC5hYnMob3JpZ2luYWxXaWR0aCAqIHNjYWxlWCk7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5oZWlnaHQgPSBNYXRoLmFicyhvcmlnaW5hbEhlaWdodCAqIHNjYWxlWSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiKSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpdmVSZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpYW1ldGVyID0gTWF0aC5tYXgoMSwgTWF0aC5tYXgobGl2ZVJlY3Qud2lkdGgsIGxpdmVSZWN0LmhlaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5yYWRpdXMgPSBkaWFtZXRlciAvIDI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBjaXJjbGVBbmNob3JSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS54ID0gYW5jaG9yLmxlZnQgKyB0cmFuc2Zvcm1EYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS55ID0gYW5jaG9yLnRvcCArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS54ID0gbGl2ZVJlY3QueCArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnkgPSBsaXZlUmVjdC55ICsgdHJhbnNmb3JtRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgb25UcmFuc2Zvcm0odHJhbnNmb3JtRGF0YSk7XHJcblxyXG4gICAgICAgICAgLy8gLS0tIExPRyBDT01QQUNUTyAob3BjaW9uYWwpIC0tLVxyXG4gICAgICAgICAgY29uc3QgaWQgPSAodHlwZW9mIG5vZGUuaWQgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuaWQoKSA6IG5vZGUuYXR0cnM/LmlkKSB8fCBcIuKIhVwiO1xyXG4gICAgICAgICAgY29uc3Qgc3ggPSBub2RlLnNjYWxlWD8uKCkgPz8gMTtcclxuICAgICAgICAgIGNvbnN0IHN5ID0gbm9kZS5zY2FsZVk/LigpID8/IDE7XHJcbiAgICAgICAgICBjb25zdCByID0gbm9kZS5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XHJcbiAgICAgICAgICBzbG9nKFxyXG4gICAgICAgICAgICBcIltUUl0gbGl2ZVwiLFxyXG4gICAgICAgICAgICBgaWQ9JHtpZH1gLFxyXG4gICAgICAgICAgICBgdGlwbz0ke3ByaW1lckVsZW1lbnRvPy50aXBvIHx8IFwi4oiFXCJ9YCxcclxuICAgICAgICAgICAgYHN4PSR7c3gudG9GaXhlZCgzKX1gLFxyXG4gICAgICAgICAgICBgc3k9JHtzeS50b0ZpeGVkKDMpfWAsXHJcbiAgICAgICAgICAgIGB4PSR7KG5vZGUueD8uKCkgPz8gMCkudG9GaXhlZCgxKX1gLFxyXG4gICAgICAgICAgICBgeT0keyhub2RlLnk/LigpID8/IDApLnRvRml4ZWQoMSl9YCxcclxuICAgICAgICAgICAgYG5vZGVSZWN0KHc9JHtyLndpZHRoLnRvRml4ZWQoMSl9LGg9JHtyLmhlaWdodC50b0ZpeGVkKDEpfSlgLFxyXG4gICAgICAgICAgICBgdz0ke3RyYW5zZm9ybURhdGEud2lkdGggPz8gXCLiiIVcIn1gLFxyXG4gICAgICAgICAgICBgaD0ke3RyYW5zZm9ybURhdGEuaGVpZ2h0ID8/IFwi4oiFXCJ9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZW4gb25UcmFuc2Zvcm06XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH19XHJcbiAgICAgIG9uVHJhbnNmb3JtRW5kPXsoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uU25hcHNob3QgPSB7XHJcbiAgICAgICAgICBpc1JvdGF0ZTogQm9vbGVhbih0cmFuc2Zvcm1HZXN0dXJlUmVmLmN1cnJlbnQ/LmlzUm90YXRlKSxcclxuICAgICAgICAgIGFjdGl2ZUFuY2hvcjogdHJhbnNmb3JtR2VzdHVyZVJlZi5jdXJyZW50Py5hY3RpdmVBbmNob3IgPz8gbnVsbCxcclxuICAgICAgICAgIHBvaW50ZXJUeXBlOiBlPy5ldnQ/LnBvaW50ZXJUeXBlID8/IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBub3RpZnlUcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCA9ICgpID0+IHtcclxuICAgICAgICAgIGlmICh0eXBlb2Ygb25UcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQoaW50ZXJhY3Rpb25TbmFwc2hvdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0cmFuc2Zvcm1HZXN0dXJlUmVmLmN1cnJlbnQgPSB7XHJcbiAgICAgICAgICAgIGlzUm90YXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgYWN0aXZlQW5jaG9yOiBudWxsLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1lclJlZi5jdXJyZW50IHx8ICFvblRyYW5zZm9ybSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgICAgICAgIGNvbnN0IG5vZGVzID0gdHlwZW9mIHRyLm5vZGVzID09PSBcImZ1bmN0aW9uXCIgPyB0ci5ub2RlcygpIHx8IFtdIDogW107XHJcblxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyBNVUxUSS1TRUxFQ0NJw5NOXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB0U2NhbGVYID0gdHlwZW9mIHRyLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gdHIuc2NhbGVYKCkgfHwgMSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHRTY2FsZVkgPSB0eXBlb2YgdHIuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyB0ci5zY2FsZVkoKSB8fCAxIDogMTtcclxuICAgICAgICAgICAgY29uc3QgYXZnID0gKE1hdGguYWJzKHRTY2FsZVgpICsgTWF0aC5hYnModFNjYWxlWSkpIC8gMjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBub2Rlc1xyXG4gICAgICAgICAgICAgIC5tYXAoKG4pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICBpZCA9ICh0eXBlb2Ygbi5pZCA9PT0gXCJmdW5jdGlvblwiID8gbi5pZCgpIDogbi5hdHRycz8uaWQpIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gKG9iamV0b3MgfHwgW10pLmZpbmQoKG8pID0+IG8uaWQgPT09IGlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghb2JqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGQgPSB7XHJcbiAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICB4OiB0eXBlb2Ygbi54ID09PSBcImZ1bmN0aW9uXCIgPyBuLngoKSA6IG9iai54LFxyXG4gICAgICAgICAgICAgICAgICB5OiB0eXBlb2Ygbi55ID09PSBcImZ1bmN0aW9uXCIgPyBuLnkoKSA6IG9iai55LFxyXG4gICAgICAgICAgICAgICAgICByb3RhdGlvbjogdHlwZW9mIG4ucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IG4ucm90YXRpb24oKSB8fCAwIDogKG9iai5yb3RhdGlvbiB8fCAwKSxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcInRleHRvXCIpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IG9iai5mb250U2l6ZSB8fCAyNDtcclxuICAgICAgICAgICAgICAgICAgdXBkLmZvbnRTaXplID0gTWF0aC5tYXgoNiwgTWF0aC5yb3VuZChiYXNlICogYXZnKSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVZKDEpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUiA9IG9iai5yYWRpdXMgfHwgNTA7XHJcbiAgICAgICAgICAgICAgICAgIHVwZC5yYWRpdXMgPSBiYXNlUiAqIGF2ZztcclxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcInRyaWFuZ2xlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVIgPSBvYmoucmFkaXVzIHx8IDYwO1xyXG4gICAgICAgICAgICAgICAgICB1cGQucmFkaXVzID0gTWF0aC5tYXgoMSwgYmFzZVIgKiBhdmcpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG4uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjb3VudGRvd25TaXplID0gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShuKTtcclxuICAgICAgICAgICAgICAgICAgdXBkLndpZHRoID0gY291bnRkb3duU2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgdXBkLmhlaWdodCA9IGNvdW50ZG93blNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VXID1cclxuICAgICAgICAgICAgICAgICAgb2JqLndpZHRoICE9IG51bGwgPyBvYmoud2lkdGggOiAodHlwZW9mIG4ud2lkdGggPT09IFwiZnVuY3Rpb25cIiA/IG4ud2lkdGgoKSA6IDEwMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSCA9XHJcbiAgICAgICAgICAgICAgICAgIG9iai5oZWlnaHQgIT0gbnVsbCA/IG9iai5oZWlnaHQgOiAodHlwZW9mIG4uaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIgPyBuLmhlaWdodCgpIDogMTAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICB1cGQud2lkdGggPSBNYXRoLmFicyhiYXNlVyAqIHRTY2FsZVgpO1xyXG4gICAgICAgICAgICAgICAgdXBkLmhlaWdodCA9IE1hdGguYWJzKGJhc2VIICogdFNjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICAgICAgICAgICAgb25UcmFuc2Zvcm0oeyBpc0ZpbmFsOiB0cnVlLCBiYXRjaDogdXBkYXRlcyB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHIuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICB0ci5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgdHIuc2NhbGVZKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xyXG5cclxuICAgICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0geyBpc1Jlc2l6aW5nOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICB9LCAxMDApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGVuIG9uVHJhbnNmb3JtRW5kIChtdWx0aSk6XCIsIGVycik7XHJcbiAgICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyBTSU5HTEUtU0VMRUNDScOTTlxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbMF07XHJcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHBvc2UgPSBnZXRUcmFuc2Zvcm1Qb3NlKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsRGF0YSA9IHtcclxuICAgICAgICAgICAgeDogcG9zZS54LFxyXG4gICAgICAgICAgICB5OiBwb3NlLnksXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBwb3NlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICBpc0ZpbmFsOiB0cnVlLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGxldCB0ZXh0UHJldmlld0VuZFNuYXBzaG90ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICBpZiAoZXNUZXh0bykge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcHJpbWVyRWxlbWVudG8uZm9udFNpemUgfHwgMjQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHR5cGVvZiBub2RlLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvckRhdGEgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgfHwgbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgYmFzZUZvbnRTaXplID1cclxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8uYmFzZUZvbnRTaXplKSAmJlxyXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEuYmFzZUZvbnRTaXplID4gMFxyXG4gICAgICAgICAgICAgICAgPyBhbmNob3JEYXRhLmJhc2VGb250U2l6ZVxyXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEZvbnRTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGVGcm9tUmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCB2aXN1YWxXaWR0aEZyb21SZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFJvdGF0aW9uID1cclxuICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUucm90YXRpb24oKSB8fCAwKSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VSb3RhdGlvbiA9IE51bWJlcihhbmNob3JEYXRhPy5iYXNlUm90YXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGlvbkRlbHRhID0gTnVtYmVyLmlzRmluaXRlKGJhc2VSb3RhdGlvbilcclxuICAgICAgICAgICAgICA/IE1hdGguYWJzKGN1cnJlbnRSb3RhdGlvbiAtIGJhc2VSb3RhdGlvbilcclxuICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2aXN1YWxXaWR0aEZyb21SZWN0ID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVdpZHRoID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VXaWR0aCk7XHJcbiAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGJhc2VXaWR0aCkgJiZcclxuICAgICAgICAgICAgICAgIGJhc2VXaWR0aCA+IDAgJiZcclxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkgJiZcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPiAwXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZUZyb21SZWN0ID0gcmVjdC53aWR0aCAvIGJhc2VXaWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgY29uc3QgY2FuVXNlUmVjdFNjYWxlID0gcm90YXRpb25EZWx0YSA8IDAuMTtcclxuICAgICAgICAgICAgY29uc3QgZWZmZWN0aXZlU2NhbGUgPVxyXG4gICAgICAgICAgICAgIGNhblVzZVJlY3RTY2FsZSAmJiBOdW1iZXIuaXNGaW5pdGUoc2NhbGVGcm9tUmVjdCkgJiYgc2NhbGVGcm9tUmVjdCA+IDBcclxuICAgICAgICAgICAgICAgID8gc2NhbGVGcm9tUmVjdFxyXG4gICAgICAgICAgICAgICAgOiBhdmdTY2FsZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgICA2LFxyXG4gICAgICAgICAgICAgIE51bWJlcigoYmFzZUZvbnRTaXplICogZWZmZWN0aXZlU2NhbGUpLnRvRml4ZWQoMykpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGZpbmFsRGF0YS5mb250U2l6ZSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgIDYsXHJcbiAgICAgICAgICAgICAgTnVtYmVyKFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3Rm9udFNpemUpICYmXHJcbiAgICAgICAgICAgICAgICAgIGFuY2hvckRhdGEubGFzdFByZXZpZXdGb250U2l6ZSA+IDBcclxuICAgICAgICAgICAgICAgICAgPyBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Rm9udFNpemVcclxuICAgICAgICAgICAgICAgICAgOiBjb21wdXRlZEZvbnRTaXplXHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChjYW5Vc2VSZWN0U2NhbGUgJiYgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LnkpKSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnkgPSBhbmNob3JEYXRhLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5sYXN0UHJldmlld0NlbnRlclgpKSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnRleHRDZW50ZXJYID0gYW5jaG9yRGF0YS5sYXN0UHJldmlld0NlbnRlclg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmNlbnRlclgpKSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnRleHRDZW50ZXJYID0gYW5jaG9yRGF0YS5jZW50ZXJYO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdDZW50ZXJZKSkge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWSA9IGFuY2hvckRhdGEubGFzdFByZXZpZXdDZW50ZXJZO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5jZW50ZXJZKSkge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWSA9IGFuY2hvckRhdGEuY2VudGVyWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2aXN1YWxXaWR0aCA9XHJcbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3VmlzdWFsV2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgYW5jaG9yRGF0YS5sYXN0UHJldmlld1Zpc3VhbFdpZHRoID4gMFxyXG4gICAgICAgICAgICAgICAgPyBhbmNob3JEYXRhLmxhc3RQcmV2aWV3VmlzdWFsV2lkdGhcclxuICAgICAgICAgICAgICAgIDogdmlzdWFsV2lkdGhGcm9tUmVjdDtcclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2aXN1YWxXaWR0aCkgJiYgdmlzdWFsV2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnRleHRWaXN1YWxXaWR0aCA9IHZpc3VhbFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHRQcmV2aWV3RW5kU25hcHNob3QgPSB7XHJcbiAgICAgICAgICAgICAgaWQ6IHByaW1lckVsZW1lbnRvPy5pZCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIHg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgeTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICBzY2FsZVgsXHJcbiAgICAgICAgICAgICAgc2NhbGVZLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiB0eXBlb2Ygbm9kZT8uZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuZm9udFNpemUoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgcmVjdFdpZHRoOiBOdW1iZXIuaXNGaW5pdGUodmlzdWFsV2lkdGhGcm9tUmVjdCkgPyB2aXN1YWxXaWR0aEZyb21SZWN0IDogbnVsbCxcclxuICAgICAgICAgICAgICByZWN0SGVpZ2h0OiBudWxsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlY3RGb3JTbmFwc2hvdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdEZvclNuYXBzaG90Py5oZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQgPSByZWN0Rm9yU25hcHNob3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICBUWFREQkcoXCJlbmRcIiwge1xyXG4gICAgICAgICAgICAgIGlkOiBwcmltZXJFbGVtZW50bz8uaWQgPz8gbnVsbCxcclxuICAgICAgICAgICAgICBzY2FsZVgsXHJcbiAgICAgICAgICAgICAgc2NhbGVZLFxyXG4gICAgICAgICAgICAgIGF2Z1NjYWxlLFxyXG4gICAgICAgICAgICAgIHNjYWxlRnJvbVJlY3QsXHJcbiAgICAgICAgICAgICAgZWZmZWN0aXZlU2NhbGUsXHJcbiAgICAgICAgICAgICAgY29tcHV0ZWRGb250U2l6ZSxcclxuICAgICAgICAgICAgICBmaW5hbEZvbnRTaXplOiBmaW5hbERhdGEuZm9udFNpemUsXHJcbiAgICAgICAgICAgICAgdGV4dENlbnRlclg6IGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIHRleHRDZW50ZXJZOiBmaW5hbERhdGEudGV4dENlbnRlclkgPz8gbnVsbCxcclxuICAgICAgICAgICAgICB0ZXh0VmlzdWFsV2lkdGg6IGZpbmFsRGF0YS50ZXh0VmlzdWFsV2lkdGggPz8gbnVsbCxcclxuICAgICAgICAgICAgICBub2RlUmVjdFdpZHRoOiB2aXN1YWxXaWR0aEZyb21SZWN0LFxyXG4gICAgICAgICAgICAgIG5vZGVYOiB0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIG5vZGVZOiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwbGFuYXIgZXNjYWxhIGRlbCB0ZXh0byBlbiBlbCByZWxlYXNlIHBhcmEgZXZpdGFyIGRvYmxlIGVzY2FsYWRvXHJcbiAgICAgICAgICAgIC8vIChlc2NhbGEgZGVsIG5vZG8gKyBmb250U2l6ZSBwZXJzaXN0aWRvKS5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIG5vZGUuc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIikgbm9kZS5zY2FsZVkoMSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmaW5hbERhdGEuZm9udFNpemUpICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5mb250U2l6ZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmZvbnRTaXplKGZpbmFsRGF0YS5mb250U2l6ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldENlbnRlclggPSBOdW1iZXIoZmluYWxEYXRhLnRleHRDZW50ZXJYKTtcclxuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDZW50ZXJZID0gTnVtYmVyKGZpbmFsRGF0YS50ZXh0Q2VudGVyWSk7XHJcbiAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgKE51bWJlci5pc0Zpbml0ZSh0YXJnZXRDZW50ZXJYKSB8fCBOdW1iZXIuaXNGaW5pdGUodGFyZ2V0Q2VudGVyWSkpICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS54ID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLnkgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkUmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkQ2VudGVyWCA9XHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZsYXR0ZW5lZFJlY3Q/LngpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZsYXR0ZW5lZFJlY3Q/LndpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgPyBmbGF0dGVuZWRSZWN0LnggKyAoZmxhdHRlbmVkUmVjdC53aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZENlbnRlclkgPVxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRSZWN0Py55KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRSZWN0Py5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IGZsYXR0ZW5lZFJlY3QueSArIChmbGF0dGVuZWRSZWN0LmhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZsYXR0ZW5lZENlbnRlclgpICYmIE51bWJlci5pc0Zpbml0ZSh0YXJnZXRDZW50ZXJYKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUueChub2RlLngoKSArICh0YXJnZXRDZW50ZXJYIC0gZmxhdHRlbmVkQ2VudGVyWCkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkQ2VudGVyWSkgJiYgTnVtYmVyLmlzRmluaXRlKHRhcmdldENlbnRlclkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS55KG5vZGUueSgpICsgKHRhcmdldENlbnRlclkgLSBmbGF0dGVuZWRDZW50ZXJZKSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIG5vZGUuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGFwbGFuYW5kbyBlc2NhbGEgZGUgdGV4dG8gKHN5bmMpOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNhblVzZVJlY3RTY2FsZSkge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbERhdGEueCA9IG5vZGUueCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgZmluYWxEYXRhLnkgPSBub2RlLnkoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBhcmEgdGV4dG8gZXZpdGFtb3MgYXBsYW5hciBhbnRlcyBkZWwgY29tbWl0IGVuIFJlYWN0LFxyXG4gICAgICAgICAgICAvLyBhc8OtIG5vIGFwYXJlY2UgdW4gZnJhbWUgaW50ZXJtZWRpbyBjb24gdGFtYcOxbyBcInNhbHRhZG9cIi5cclxuICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHR5cGVvZiBub2RlLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XHJcbiAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xyXG4gICAgICAgICAgICAgIC8vIENvdW50ZG93bjogcGVyc2lzdGlyIGVzY2FsYSByZWFsIHBhcmEgcXVlIGVsIHJlc3VsdGFkbyBmaW5hbFxyXG4gICAgICAgICAgICAgIC8vIHNlYSBleGFjdGFtZW50ZSBlbCBtaXNtbyBxdWUgc2UgdmUgYWwgc29sdGFyLlxyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IHNjYWxlWTtcclxuICAgICAgICAgICAgICBjb25zdCBjb3VudGRvd25TaXplID0gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShub2RlKTtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEud2lkdGggPSBjb3VudGRvd25TaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5oZWlnaHQgPSBjb3VudGRvd25TaXplLmhlaWdodDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlc1RyaWFuZ3Vsbykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VSYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUocHJpbWVyRWxlbWVudG8/LnJhZGl1cylcclxuICAgICAgICAgICAgICAgID8gcHJpbWVyRWxlbWVudG8ucmFkaXVzXHJcbiAgICAgICAgICAgICAgICA6IDYwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGF2Z1NjYWxlID0gKE1hdGguYWJzKHNjYWxlWCkgKyBNYXRoLmFicyhzY2FsZVkpKSAvIDI7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnJhZGl1cyA9IE1hdGgubWF4KDEsIGJhc2VSYWRpdXMgKiBhdmdTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2NhbGVZKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBub2RlLnJhZGl1cyhmaW5hbERhdGEucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBhcGxhbmFuZG8gZXNjYWxhIGRlIHRyacOhbmd1bG8gKHN5bmMpOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gcHJpbWVyRWxlbWVudG8ud2lkdGggfHwgMTAwO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcHJpbWVyRWxlbWVudG8uaGVpZ2h0IHx8IDEwMDtcclxuXHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLndpZHRoID0gTWF0aC5hYnMob3JpZ2luYWxXaWR0aCAqIHNjYWxlWCk7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLmhlaWdodCA9IE1hdGguYWJzKG9yaWdpbmFsSGVpZ2h0ICogc2NhbGVZKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCIpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpdmVSZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBkaWFtZXRlciA9IE1hdGgubWF4KDEsIE1hdGgubWF4KGxpdmVSZWN0LndpZHRoLCBsaXZlUmVjdC5oZWlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnJhZGl1cyA9IGRpYW1ldGVyIC8gMjtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChhbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueCA9IGFuY2hvci5sZWZ0ICsgZmluYWxEYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IGFuY2hvci50b3AgKyBmaW5hbERhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS54ID0gbGl2ZVJlY3QueCArIGZpbmFsRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnkgPSBsaXZlUmVjdC55ICsgZmluYWxEYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8g4pyFIEFwbGFuYXIgZXNjYWxhIElOTUVESUFUT1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmdyA9IGZpbmFsRGF0YS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZoID0gZmluYWxEYXRhLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2NhbGVZKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmdyAhPSBudWxsICYmIHR5cGVvZiBub2RlLndpZHRoID09PSBcImZ1bmN0aW9uXCIpIG5vZGUud2lkdGgoZncpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZoICE9IG51bGwgJiYgdHlwZW9mIG5vZGUuaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIpIG5vZGUuaGVpZ2h0KGZoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCIgJiZcclxuICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnJhZGl1cyAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLnJhZGl1cyA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgbm9kZS5yYWRpdXMoZmluYWxEYXRhLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGFwbGFuYW5kbyBlc2NhbGFzIChzeW5jKTpcIiwgZXJyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBvblRyYW5zZm9ybShmaW5hbERhdGEpO1xyXG4gICAgICAgICAgY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xyXG5cclxuXHJcbiAgICAgICAgICAvLyDinIUgUmVhdGFjaGFyIDEgdmV6LCBjb24gcmVmIGZyZXNjbywgZW4gZWwgcHLDs3hpbW8gZnJhbWVcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyMiA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGlmICghdHIyKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIC0+IHNjaGVkdWxlIFJBRiByZWF0dGFjaFwiLCB7XHJcbiAgICAgICAgICAgICAgc2VsS2V5OiBzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpLFxyXG4gICAgICAgICAgICAgIGlkU2VsOiBzZWxlY3RlZEVsZW1lbnRzPy5bMF0gfHwgbnVsbFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgaWRTZWwgPSBzZWxlY3RlZEVsZW1lbnRzPy5bMF07XHJcbiAgICAgICAgICAgICAgY29uc3QgZnJlc2hOb2RlID0gaWRTZWwgPyBlbGVtZW50UmVmcy5jdXJyZW50Py5baWRTZWxdIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCBSQUZcIiwge1xyXG4gICAgICAgICAgICAgICAgaWRTZWwsXHJcbiAgICAgICAgICAgICAgICBoYXNGcmVzaDogISFmcmVzaE5vZGUsXHJcbiAgICAgICAgICAgICAgICBkZXN0cm95ZWQ6ICEhZnJlc2hOb2RlPy5fZGVzdHJveWVkLFxyXG4gICAgICAgICAgICAgICAgaGFzU3RhZ2U6ICEhZnJlc2hOb2RlPy5nZXRTdGFnZT8uKCksXHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFNpIGVsIG5vZG8gbm8gZXN0w6EgbGlzdG8sIGRlc3BlZ2FyIHkgc2FsaXJcclxuICAgICAgICAgICAgICBpZiAoIWZyZXNoTm9kZSB8fCBmcmVzaE5vZGUuX2Rlc3Ryb3llZCB8fCAhZnJlc2hOb2RlLmdldFN0YWdlPy4oKSkge1xyXG4gICAgICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCBSQUYgLT4gREVUQUNIIG5vZGVzKFtdKVwiLCB7IGlkU2VsIH0pO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHsgdHIyLm5vZGVzKFtdKTsgdHIyLmdldExheWVyPy4oKT8uYmF0Y2hEcmF3KCk7IH0gY2F0Y2ggeyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCBSQUYgLT4gREVUQUNIIG5vZGVzKFtdKVwiLCB7IGlkU2VsIH0pO1xyXG4gICAgICAgICAgICAgICAgdHIyLm5vZGVzKFtmcmVzaE5vZGVdKTtcclxuICAgICAgICAgICAgICAgIHRyMi5mb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdHIyLmdldExheWVyPy4oKT8uYmF0Y2hEcmF3KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRQcmV2aWV3RW5kU25hcHNob3QgJiYgZnJlc2hOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdFJlY3QgPSBmcmVzaE5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIFRYVERCRyhcInBvc3QtY29tbWl0OnJhZjFcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkU2VsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcHJlOiB0ZXh0UHJldmlld0VuZFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgcG9zdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0eXBlb2YgZnJlc2hOb2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUueCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdHlwZW9mIGZyZXNoTm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLnkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWDogdHlwZW9mIGZyZXNoTm9kZT8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUuc2NhbGVYKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IHR5cGVvZiBmcmVzaE5vZGU/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLnNjYWxlWSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHR5cGVvZiBmcmVzaE5vZGU/LmZvbnRTaXplID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUuZm9udFNpemUoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaWR0aDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Py53aWR0aCkgPyBwb3N0UmVjdC53aWR0aCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIZWlnaHQ6IE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8uaGVpZ2h0KSA/IHBvc3RSZWN0LmhlaWdodCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Py53aWR0aCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChwb3N0UmVjdC53aWR0aCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Py5oZWlnaHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKHBvc3RSZWN0LmhlaWdodCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmVzaE5vZGUyID0gaWRTZWwgPyBlbGVtZW50UmVmcy5jdXJyZW50Py5baWRTZWxdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZyZXNoTm9kZTIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdFJlY3QyID0gZnJlc2hOb2RlMi5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgIFRYVERCRyhcInBvc3QtY29tbWl0OnJhZjJcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRTZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB0eXBlb2YgZnJlc2hOb2RlMj8ueCA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi54KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHR5cGVvZiBmcmVzaE5vZGUyPy55ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLnkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVYOiB0eXBlb2YgZnJlc2hOb2RlMj8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLnNjYWxlWCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IHR5cGVvZiBmcmVzaE5vZGUyPy5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZTIuc2NhbGVZKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0eXBlb2YgZnJlc2hOb2RlMj8uZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZTIuZm9udFNpemUoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpZHRoOiBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3QyPy53aWR0aCkgPyBwb3N0UmVjdDIud2lkdGggOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIZWlnaHQ6IE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdDI/LmhlaWdodCkgPyBwb3N0UmVjdDIuaGVpZ2h0IDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFGcm9tUHJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3QyPy53aWR0aCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3QyLndpZHRoIC0gdGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3QyPy5oZWlnaHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChwb3N0UmVjdDIuaGVpZ2h0IC0gdGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggeyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBjYXRjaCB7IH1cclxuXHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBlbiBvblRyYW5zZm9ybUVuZDpcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0gbnVsbDtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaXNUcmFuc2Zvcm1pbmdSZXNpemVSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlKGZhbHNlKTtcclxuICAgICAgICAgIGNsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFjaygpO1xyXG4gICAgICAgICAgbm90aWZ5VHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH19XHJcblxyXG4gICAgLz5cclxuICApO1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJUcmFuc2Zvcm1lciIsIlJlY3QiLCJERUJVR19TRUxFQ1RJT05fQk9VTkRTIiwic2JMb2ciLCJhcmdzIiwiY29uc29sZSIsImxvZyIsInNsb2ciLCJUUkRCRyIsIndpbmRvdyIsIl9fREJHX1RSIiwiVFhUREJHIiwiX19EQkdfVEVYVF9SRVNJWkUiLCJyZWN0RnJvbU5vZGVzIiwibm9kZXMiLCJtaW5YIiwiSW5maW5pdHkiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJuIiwiZ2V0Q2xpZW50UmVjdCIsInIiLCJza2lwVHJhbnNmb3JtIiwic2tpcFNoYWRvdyIsInNraXBTdHJva2UiLCJNYXRoIiwibWluIiwieCIsInkiLCJtYXgiLCJ3aWR0aCIsImhlaWdodCIsImdldENvdW50ZG93blNjYWxlZFNpemUiLCJub2RlIiwiaGl0Ym94IiwiZmluZE9uZSIsImJhc2VXIiwiTmFOIiwiYmFzZUgiLCJzeCIsImFicyIsInNjYWxlWCIsInN5Iiwic2NhbGVZIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJCb3VuZHNJbmRpY2F0b3IiLCJzZWxlY3RlZEVsZW1lbnRzIiwiZWxlbWVudFJlZnMiLCJvYmpldG9zIiwiZm9yY2VVcGRhdGUiLCJzZXRGb3JjZVVwZGF0ZSIsImZpcnN0UmVmIiwiY3VycmVudCIsInN0YWdlIiwiZ2V0U3RhZ2UiLCJoYW5kbGVEcmFnTW92ZSIsInAiLCJvbiIsIm9mZiIsImpvaW4iLCJlbGVtZW50b3NEYXRhIiwibWFwIiwiaWQiLCJmaW5kIiwib2JqIiwiZmlsdGVyIiwiQm9vbGVhbiIsImxlbmd0aCIsImZvckVhY2giLCJ0aXBvIiwiZmlndXJhIiwicG9pbnRzIiwiY2xlYW5Qb2ludHMiLCJwYXJzZUZsb2F0IiwicmVhbFgiLCJyZWFsWSIsIngxIiwieTEiLCJ4MiIsInkyIiwibGluZVBhZGRpbmciLCJib3giLCJ0b0ZpeGVkIiwiZ2V0VGV4dEhlaWdodCIsInRleHRIZWlnaHQiLCJlcnJvciIsImZhbGxiYWNrWCIsImZhbGxiYWNrWSIsImZhbGxiYWNrU2l6ZSIsInByaW1lckVsZW1lbnRvIiwicGFkZGluZyIsImZpbmFsWCIsImZpbmFsWSIsImZpbmFsV2lkdGgiLCJmaW5hbEhlaWdodCIsIm5hbWUiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJsaXN0ZW5pbmciLCJvcGFjaXR5IiwiU2VsZWN0aW9uQm91bmRzIiwib25UcmFuc2Zvcm0iLCJvblRyYW5zZm9ybUludGVyYWN0aW9uU3RhcnQiLCJvblRyYW5zZm9ybUludGVyYWN0aW9uRW5kIiwiaXNEcmFnZ2luZyIsImlzTW9iaWxlIiwidHJhbnNmb3JtZXJSZWYiLCJ0cmFuc2Zvcm1UaWNrIiwic2V0VHJhbnNmb3JtVGljayIsImxhc3ROb2Rlc1JlZiIsImNpcmNsZUFuY2hvclJlZiIsInRleHRUcmFuc2Zvcm1BbmNob3JSZWYiLCJ0cmFuc2Zvcm1HZXN0dXJlUmVmIiwiaXNSb3RhdGUiLCJhY3RpdmVBbmNob3IiLCJpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZiIsImlzUmVzaXplR2VzdHVyZUFjdGl2ZSIsInNldElzUmVzaXplR2VzdHVyZUFjdGl2ZSIsInByZXNzZWRSZXNpemVBbmNob3JOYW1lIiwic2V0UHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUiLCJlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YSIsImVzVGV4dG8iLCJlc0NvdW50ZG93biIsImVzR2FsZXJpYSIsImxvY2tBc3BlY3RDb3VudGRvd24iLCJsb2NrQXNwZWN0VGV4dCIsInRyYW5zZm9ybWVyQW5jaG9yU2l6ZSIsInRyYW5zZm9ybWVyUm90YXRlT2Zmc2V0IiwidHJhbnNmb3JtZXJBbmNob3JSYWRpdXMiLCJ0cmFuc2Zvcm1lclBhZGRpbmciLCJ0cmFuc2Zvcm1lckJvcmRlclN0cm9rZVdpZHRoIiwidHJhbnNmb3JtZXJBbmNob3JGaWxsQ29sb3IiLCJ0cmFuc2Zvcm1lckFuY2hvclN0cm9rZVdpZHRoIiwidHJhbnNmb3JtZXJBbmNob3JTaGFkb3dCbHVyIiwidHJhbnNmb3JtZXJBbmNob3JTaGFkb3dPZmZzZXRZIiwidHJhbnNmb3JtZXJBbmNob3JIaXRTdHJva2VXaWR0aCIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhpdFN0cm9rZVdpZHRoIiwidHJhbnNmb3JtZXJBbmNob3JTdHJva2VDb2xvciIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhhbG9TdHJva2VDb2xvciIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhhbG9TdHJva2VXaWR0aCIsInRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Q29sb3IiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dDb2xvciIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0JsdXIiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dPZmZzZXRZIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2NhbGUiLCJ0cmFuc2Zvcm1lclJvdGF0aW9uU25hcFRvbGVyYW5jZSIsImVzVHJpYW5ndWxvIiwiaGFzR2FsbGVyeSIsInNvbWUiLCJvIiwiaGF5TGluZWFzIiwiZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMiLCJkZWJlcmlhVXNhclRyYW5zZm9ybWVyIiwic2VsZWN0ZWRHZW9tS2V5Iiwicm90YXRpb24iLCJjaGlwV2lkdGgiLCJnYXAiLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwiZ2V0VHJhbnNmb3JtUG9zZSIsImdldFBhcmVudCIsInBhcmVudCIsImNsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFjayIsImdldFJlc2l6ZUFuY2hvck5hbWVGcm9tVGFyZ2V0IiwidGFyZ2V0IiwiaXNBbmNob3JUYXJnZXQiLCJoYXNOYW1lIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJyYXdOYW1lIiwiYW5jaG9yTmFtZSIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJoYW5kbGVSZXNpemVBbmNob3JQcmVzc1N0YXJ0IiwiZXZlbnQiLCJnZXRBY3RpdmVBbmNob3IiLCJnZXRCb3hPdmVyZmxvd0Ftb3VudCIsInN0YWdlV2lkdGgiLCJzdGFnZUhlaWdodCIsIlBPU0lUSVZFX0lORklOSVRZIiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwib3ZlcmZsb3dMZWZ0Iiwib3ZlcmZsb3dUb3AiLCJvdmVyZmxvd1JpZ2h0Iiwib3ZlcmZsb3dCb3R0b20iLCJrZWVwQm94SW5zaWRlU3RhZ2UiLCJvbGRCb3giLCJuZXh0Qm94IiwidHIiLCJhdHRycyIsIm9sZE92ZXJmbG93IiwibmV4dE92ZXJmbG93IiwiZXBzaWxvbiIsInNlbEtleSIsImVsZW1lbnRvc1RyYW5zZm9ybWFibGVzTGVuIiwiZWRpdGluZ0lkIiwiZWRpdGluZyIsIm5vZG9zVHJhbnNmb3JtYWJsZXMiLCJpZFNlbCIsInJlZk5vZGUiLCJnYWxsZXJ5RnJhbWUiLCJ3YW50ZWRJZHMiLCJyZWZzUHJlc2VudCIsIm5vZGVzQ291bnQiLCJub2RlSWRzIiwidHJOb2Rlc0NvdW50IiwiZ2V0TGF5ZXIiLCJiYXRjaERyYXciLCJoYW5kbGVyIiwiZSIsImRldGFpbCIsImlzU2VsZWN0ZWQiLCJ0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaXJzdE5vZGUiLCJmaXJzdElkIiwicmFmSWQiLCJzeW5jVHJhbnNmb3JtZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlZiIsImJvcmRlckVuYWJsZWQiLCJib3JkZXJTdHJva2UiLCJib3JkZXJTdHJva2VXaWR0aCIsImVuYWJsZWRBbmNob3JzIiwicm90YXRlRW5hYmxlZCIsIm9uTW91c2VEb3duIiwib25Ub3VjaFN0YXJ0Iiwib25Qb2ludGVyRG93biIsIm9uTW91c2VVcCIsIm9uVG91Y2hFbmQiLCJvblBvaW50ZXJVcCIsIm9uVG91Y2hDYW5jZWwiLCJvblBvaW50ZXJDYW5jZWwiLCJhbmNob3JGaWxsIiwiYW5jaG9yU3Ryb2tlIiwiYW5jaG9yU3Ryb2tlV2lkdGgiLCJhbmNob3JTaXplIiwiYW5jaG9yQ29ybmVyUmFkaXVzIiwiYW5jaG9yU2hhZG93Q29sb3IiLCJhbmNob3JTaGFkb3dCbHVyIiwiYW5jaG9yU2hhZG93T2Zmc2V0IiwiYW5jaG9yU3R5bGVGdW5jIiwiYW5jaG9yIiwiaXNSZXNpemVBbmNob3JOb2RlIiwiaXNSZXNpemVBY3RpdmVGYWxsYmFjayIsIl9yZXNpemVEYXRhIiwiaXNSZXNpemluZyIsImlzUHJlc3NlZFJlc2l6ZUFuY2hvciIsInNoYWRvd0NvbG9yIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkQ29yZUNvbG9yIiwic2hhZG93RW5hYmxlZCIsInNoYWRvd0ZvclN0cm9rZUVuYWJsZWQiLCJzaGFkb3dPcGFjaXR5Iiwic2hhZG93Qmx1ciIsInNoYWRvd09mZnNldCIsImhpdFN0cm9rZVdpZHRoIiwiYW5jaG9yU2NhbGUiLCJzY2FsZSIsImtlZXBSYXRpbyIsImNlbnRlcmVkU2NhbGluZyIsImZsaXBFbmFibGVkIiwicmVzaXplRW5hYmxlZCIsInJvdGF0aW9uU25hcHMiLCJyb3RhdGVBbmNob3JPZmZzZXQiLCJyb3RhdGlvblNuYXBUb2xlcmFuY2UiLCJib3VuZEJveEZ1bmMiLCJuZXdCb3giLCJtaW5TaXplIiwibWF4U2l6ZSIsInJvd3MiLCJjb2xzIiwiY2VsbFJhdGlvIiwicmF0aW8iLCJtaW5HcmlkV2lkdGgiLCJuZXh0V2lkdGgiLCJjZWxsVyIsImNlbGxIIiwibmV4dEhlaWdodCIsImR3IiwiZGgiLCJzaXplIiwiZmluYWxTaXplIiwic2FmZU9sZFciLCJzYWZlT2xkSCIsInVuaWZvcm1TY2FsZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0Iiwib25UcmFuc2Zvcm1TdGFydCIsImlzUm90YXRlR2VzdHVyZSIsInBvaW50ZXJUeXBlIiwiZXZ0IiwicjAiLCJjZW50ZXJYIiwiY2VudGVyWSIsImJhc2VXaWR0aCIsImJhc2VIZWlnaHQiLCJiYXNlVmlzdWFsV2lkdGgiLCJyZWN0Iiwic2FmZUJhc2VGb250U2l6ZSIsImZvbnRTaXplIiwiYmFzZVJvdGF0aW9uIiwiYmFzZUZvbnRTaXplIiwibGFzdFByZXZpZXdGb250U2l6ZSIsImxhc3RQcmV2aWV3Q2VudGVyWCIsImxhc3RQcmV2aWV3Q2VudGVyWSIsImxhc3RQcmV2aWV3VmlzdWFsV2lkdGgiLCJwcmV2aWV3VGljayIsIm5vZGVYIiwibm9kZVkiLCJub2RlU2NhbGVYIiwibm9kZVNjYWxlWSIsInVuaW9uIiwicGFkIiwiYm9yZGVyUmVjdCIsInRyUmVjdCIsInBvc2UiLCJ0cmFuc2Zvcm1EYXRhIiwiaXNQcmV2aWV3Iiwib3JpZ2luYWxGb250U2l6ZSIsImFuY2hvckRhdGEiLCJhdmdTY2FsZSIsInNjYWxlRnJvbVJlY3QiLCJsaXZlUmVjdFdpZHRoIiwiY3VycmVudFJvdGF0aW9uIiwicm90YXRpb25EZWx0YSIsImNhblVzZVJlY3RTY2FsZSIsImVmZmVjdGl2ZVNjYWxlIiwidGljayIsImNlbnRlclhUYXJnZXQiLCJ0ZXh0Q2VudGVyWCIsInRleHRDZW50ZXJZIiwiY291bnRkb3duU2l6ZSIsImJhc2VSYWRpdXMiLCJyYWRpdXMiLCJvcmlnaW5hbFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJsaXZlUmVjdCIsImRpYW1ldGVyIiwid2FybiIsIm9uVHJhbnNmb3JtRW5kIiwiaW50ZXJhY3Rpb25TbmFwc2hvdCIsIm5vdGlmeVRyYW5zZm9ybUludGVyYWN0aW9uRW5kIiwidFNjYWxlWCIsInRTY2FsZVkiLCJhdmciLCJ1cGRhdGVzIiwidXBkIiwiYmFzZSIsInJvdW5kIiwiYmFzZVIiLCJpc0ZpbmFsIiwiYmF0Y2giLCJzZXRUaW1lb3V0IiwiZXJyIiwiZmluYWxEYXRhIiwidGV4dFByZXZpZXdFbmRTbmFwc2hvdCIsInZpc3VhbFdpZHRoRnJvbVJlY3QiLCJjb21wdXRlZEZvbnRTaXplIiwidmlzdWFsV2lkdGgiLCJ0ZXh0VmlzdWFsV2lkdGgiLCJyZWN0V2lkdGgiLCJyZWN0SGVpZ2h0IiwicmVjdEZvclNuYXBzaG90IiwiZmluYWxGb250U2l6ZSIsIm5vZGVSZWN0V2lkdGgiLCJ0YXJnZXRDZW50ZXJYIiwidGFyZ2V0Q2VudGVyWSIsImZsYXR0ZW5lZFJlY3QiLCJmbGF0dGVuZWRDZW50ZXJYIiwiZmxhdHRlbmVkQ2VudGVyWSIsImZ3IiwiZmgiLCJ0cjIiLCJmcmVzaE5vZGUiLCJoYXNGcmVzaCIsImRlc3Ryb3llZCIsIl9kZXN0cm95ZWQiLCJoYXNTdGFnZSIsInBvc3RSZWN0IiwicHJlIiwicG9zdCIsImRlbHRhIiwiZnJlc2hOb2RlMiIsInBvc3RSZWN0MiIsImRlbHRhRnJvbVByZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/SelectionBounds.jsx\n"));

/***/ })

});