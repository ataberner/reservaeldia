"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/components/SelectionBounds.jsx":
/*!********************************************!*\
  !*** ./src/components/SelectionBounds.jsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectionBounds)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-konva */ \"(pages-dir-browser)/./node_modules/react-konva/es/ReactKonva.js\");\n// SelectionBounds.jsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst DEBUG_SELECTION_BOUNDS = false;\nconst sbLog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!DEBUG_SELECTION_BOUNDS) return;\n    console.log(\"[SB]\", ...args);\n};\nconst slog = sbLog;\nconst TRDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!window.__DBG_TR) return;\n    console.log(\"[TRDBG]\", ...args);\n};\n_c = TRDBG;\nconst TXTDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n    if (!window.__DBG_TEXT_RESIZE) return;\n    console.log(\"[TEXT-TR]\", ...args);\n};\n_c1 = TXTDBG;\nfunction rectFromNodes(nodes) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for (const n of nodes){\n        if (!(n === null || n === void 0 ? void 0 : n.getClientRect)) continue;\n        const r = n.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        minX = Math.min(minX, r.x);\n        minY = Math.min(minY, r.y);\n        maxX = Math.max(maxX, r.x + r.width);\n        maxY = Math.max(maxY, r.y + r.height);\n    }\n    if (minX === Infinity) return null;\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getCountdownScaledSize(node) {\n    try {\n        var _node_findOne;\n        const hitbox = node === null || node === void 0 ? void 0 : (_node_findOne = node.findOne) === null || _node_findOne === void 0 ? void 0 : _node_findOne.call(node, \".countdown-hitbox\");\n        const baseW = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.width) === \"function\" ? hitbox.width() : NaN;\n        const baseH = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.height) === \"function\" ? hitbox.height() : NaN;\n        const sx = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() || 1 : 1);\n        const sy = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() || 1 : 1);\n        if (Number.isFinite(baseW) && Number.isFinite(baseH) && baseW > 0 && baseH > 0) {\n            return {\n                width: Math.abs(baseW * sx),\n                height: Math.abs(baseH * sy)\n            };\n        }\n    } catch (e) {}\n    try {\n        const r = node.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        return {\n            width: Math.abs(r.width),\n            height: Math.abs(r.height)\n        };\n    } catch (e) {}\n    return {\n        width: 100,\n        height: 50\n    };\n}\n// ðŸŽ¨ Componente para mostrar bounds sin transformer (lÃ­neas, etc.)\nconst BoundsIndicator = (param)=>{\n    let { selectedElements, elementRefs, objetos } = param;\n    _s();\n    const [forceUpdate, setForceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"BoundsIndicator.useEffect\": ()=>{\n            var _elementRefs_current, _firstRef_getStage;\n            const firstRef = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[selectedElements[0]];\n            const stage = firstRef === null || firstRef === void 0 ? void 0 : (_firstRef_getStage = firstRef.getStage) === null || _firstRef_getStage === void 0 ? void 0 : _firstRef_getStage.call(firstRef);\n            if (!stage) return;\n            const handleDragMove = {\n                \"BoundsIndicator.useEffect.handleDragMove\": ()=>{\n                    setForceUpdate({\n                        \"BoundsIndicator.useEffect.handleDragMove\": (p)=>p + 1\n                    }[\"BoundsIndicator.useEffect.handleDragMove\"]);\n                }\n            }[\"BoundsIndicator.useEffect.handleDragMove\"];\n            stage.on(\"dragmove\", handleDragMove);\n            return ({\n                \"BoundsIndicator.useEffect\": ()=>{\n                    stage.off(\"dragmove\", handleDragMove);\n                }\n            })[\"BoundsIndicator.useEffect\"];\n        }\n    }[\"BoundsIndicator.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    const elementosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    if (elementosData.length === 0) {\n        return null;\n    }\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    elementosData.forEach((obj)=>{\n        const node = elementRefs.current[obj.id];\n        if (!node) return;\n        try {\n            if (obj.tipo === \"forma\" && obj.figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    100,\n                    0\n                ];\n                const cleanPoints = [\n                    parseFloat(points[0]) || 0,\n                    parseFloat(points[1]) || 0,\n                    parseFloat(points[2]) || 100,\n                    parseFloat(points[3]) || 0\n                ];\n                const realX = node.x();\n                const realY = node.y();\n                const x1 = realX + cleanPoints[0];\n                const y1 = realY + cleanPoints[1];\n                const x2 = realX + cleanPoints[2];\n                const y2 = realY + cleanPoints[3];\n                const linePadding = 5;\n                minX = Math.min(minX, x1 - linePadding, x2 - linePadding);\n                minY = Math.min(minY, y1 - linePadding, y2 - linePadding);\n                maxX = Math.max(maxX, x1 + linePadding, x2 + linePadding);\n                maxY = Math.max(maxY, y1 + linePadding, y2 + linePadding);\n            } else {\n                var _node_scaleX, _node_scaleY;\n                const box = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                const r = box;\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = node === null || node === void 0 ? void 0 : (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = node === null || node === void 0 ? void 0 : (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                slog(\"[BI]\", \"id=\".concat(obj.id), \"tipo=\".concat(obj.tipo), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"rect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"));\n                const realX = box.x;\n                const realY = box.y;\n                let width = box.width;\n                let height = box.height;\n                if (obj.tipo === \"texto\" && node.getTextHeight) {\n                    const textHeight = node.getTextHeight();\n                    if (textHeight) {\n                        height = textHeight;\n                    }\n                }\n                minX = Math.min(minX, realX);\n                minY = Math.min(minY, realY);\n                maxX = Math.max(maxX, realX + width);\n                maxY = Math.max(maxY, realY + height);\n            }\n        } catch (error) {\n            const fallbackX = obj.x || 0;\n            const fallbackY = obj.y || 0;\n            const fallbackSize = 20;\n            minX = Math.min(minX, fallbackX);\n            minY = Math.min(minY, fallbackY);\n            maxX = Math.max(maxX, fallbackX + fallbackSize);\n            maxY = Math.max(maxY, fallbackY + fallbackSize);\n        }\n    });\n    if (minX === Infinity || maxX === -Infinity) {\n        const primerElemento = elementosData[0];\n        if (!primerElemento) return null;\n        minX = primerElemento.x || 0;\n        minY = primerElemento.y || 0;\n        maxX = minX + 100;\n        maxY = minY + 50;\n    }\n    const padding = 10;\n    const finalX = minX - padding;\n    const finalY = minY - padding;\n    const finalWidth = maxX - minX + padding * 2;\n    const finalHeight = maxY - minY + padding * 2;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, {\n        name: \"ui\",\n        x: finalX,\n        y: finalY,\n        width: finalWidth,\n        height: finalHeight,\n        fill: \"transparent\",\n        stroke: \"#9333EA\",\n        strokeWidth: 1,\n        listening: false,\n        opacity: 0.7\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 188,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BoundsIndicator, \"X1gDcjpboC/BQr7oI4aemyzw8+o=\");\n_c2 = BoundsIndicator;\nfunction SelectionBounds(param) {\n    let { selectedElements, elementRefs, objetos, onTransform, onTransformInteractionStart = null, onTransformInteractionEnd = null, isDragging, isMobile = false } = param;\n    _s1();\n    const transformerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [transformTick, setTransformTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const lastNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const circleAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textTransformAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const transformGestureRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        isRotate: false,\n        activeAnchor: null\n    });\n    const isTransformingResizeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const [isResizeGestureActive, setIsResizeGestureActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [pressedResizeAnchorName, setPressedResizeAnchorName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const elementosSeleccionadosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    const primerElemento = elementosSeleccionadosData[0] || null;\n    const esTexto = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"texto\";\n    const esCountdown = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\";\n    const esGaleria = selectedElements.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"galeria\";\n    const lockAspectCountdown = selectedElements.length === 1 && esCountdown;\n    const lockAspectText = selectedElements.length === 1 && esTexto;\n    const transformerAnchorSize = isMobile ? 32 : 14; //tamaÃ±o visual del nodo (mÃ¡s grande en mobile).\n    const transformerRotateOffset = isMobile ? 34 : 24; // distancia del handle de rotaciÃ³n al borde.\n    const transformerAnchorRadius = 999; //radio de esquina del nodo (999 lo hace circular).\n    const transformerPadding = isMobile ? 14 : 4; // espacio extra entre borde del transformer y elemento.\n    const transformerBorderStrokeWidth = isMobile ? 1.5 : 1; //grosor del borde del transformer.\n    const transformerAnchorFillColor = \"#9333EA\";\n    const transformerAnchorStrokeWidth = isMobile ? 1.4 : 2.5; //grosor del borde del nodo.\n    const transformerAnchorShadowBlur = isMobile ? 9 : 6; // quÃ© tan difusa es la sombra base del nodo.\n    const transformerAnchorShadowOffsetY = isMobile ? 4 : 3; // desplazamiento vertical de esa sombra.\n    const transformerAnchorHitStrokeWidth = isMobile ? 62 : 20;\n    const transformerAnchorPressedHitStrokeWidth = isMobile ? 96 : 24;\n    const transformerAnchorStrokeColor = \"#ffffff\";\n    const transformerAnchorPressedHaloStrokeColor = isMobile ? \"rgba(255, 255, 255, 0.95)\" : transformerAnchorStrokeColor;\n    const transformerAnchorPressedHaloStrokeWidth = isMobile ? 2.6 : 3.2;\n    const transformerAnchorPressedCoreColor = isMobile ? \"rgba(224, 168, 255, 1)\" : transformerAnchorFillColor;\n    const transformerAnchorShadowColor = \"rgba(147, 51, 234, 0.3)\";\n    const transformerAnchorPressedShadowColor = isMobile ? \"rgba(224, 168, 255, 0.95)\" : \"rgba(147, 51, 234, 0.7)\";\n    const transformerAnchorPressedShadowBlur = isMobile ? 180 : 18;\n    const transformerAnchorPressedShadowOffsetY = isMobile ? 0 : transformerAnchorShadowOffsetY + 1;\n    const transformerAnchorPressedScale = isMobile ? 1.03 : 1.1;\n    const transformerRotationSnapTolerance = isMobile ? 8 : 5; //tolerancia para â€œencajarâ€ rotaciÃ³n en Ã¡ngulos fijos.\n    const esTriangulo = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"triangle\";\n    const hasGallery = elementosSeleccionadosData.some((o)=>o.tipo === \"galeria\");\n    const hayLineas = elementosSeleccionadosData.some((obj)=>obj.tipo === \"forma\" && obj.figura === \"line\");\n    const elementosTransformables = elementosSeleccionadosData.filter((obj)=>!(obj.tipo === \"forma\" && obj.figura === \"line\"));\n    const deberiaUsarTransformer = elementosTransformables.length > 0;\n    const selectedGeomKey = elementosSeleccionadosData.map((o)=>{\n        var _o_x, _o_y, _o_width, _o_height, _o_scaleX, _o_scaleY, _o_rotation, _o_chipWidth, _o_gap, _o_paddingX, _o_paddingY;\n        return [\n            o.id,\n            (_o_x = o.x) !== null && _o_x !== void 0 ? _o_x : 0,\n            (_o_y = o.y) !== null && _o_y !== void 0 ? _o_y : 0,\n            (_o_width = o.width) !== null && _o_width !== void 0 ? _o_width : \"\",\n            (_o_height = o.height) !== null && _o_height !== void 0 ? _o_height : \"\",\n            (_o_scaleX = o.scaleX) !== null && _o_scaleX !== void 0 ? _o_scaleX : 1,\n            (_o_scaleY = o.scaleY) !== null && _o_scaleY !== void 0 ? _o_scaleY : 1,\n            (_o_rotation = o.rotation) !== null && _o_rotation !== void 0 ? _o_rotation : 0,\n            (_o_chipWidth = o.chipWidth) !== null && _o_chipWidth !== void 0 ? _o_chipWidth : \"\",\n            (_o_gap = o.gap) !== null && _o_gap !== void 0 ? _o_gap : \"\",\n            (_o_paddingX = o.paddingX) !== null && _o_paddingX !== void 0 ? _o_paddingX : \"\",\n            (_o_paddingY = o.paddingY) !== null && _o_paddingY !== void 0 ? _o_paddingY : \"\"\n        ].join(\":\");\n    }).join(\"|\");\n    const getTransformPose = (node)=>{\n        if (!node) return {\n            x: 0,\n            y: 0,\n            rotation: 0\n        };\n        if (esGaleria && typeof node.getParent === \"function\") {\n            const parent = node.getParent();\n            if (parent) {\n                return {\n                    x: typeof parent.x === \"function\" ? parent.x() : 0,\n                    y: typeof parent.y === \"function\" ? parent.y() : 0,\n                    rotation: typeof parent.rotation === \"function\" ? parent.rotation() || 0 : 0\n                };\n            }\n        }\n        return {\n            x: typeof node.x === \"function\" ? node.x() : 0,\n            y: typeof node.y === \"function\" ? node.y() : 0,\n            rotation: typeof node.rotation === \"function\" ? node.rotation() || 0 : 0\n        };\n    };\n    const clearResizeAnchorPressFeedback = ()=>{\n        if (isTransformingResizeRef.current) return;\n        setIsResizeGestureActive(false);\n        setPressedResizeAnchorName((current)=>current ? null : current);\n    };\n    const getResizeAnchorNameFromTarget = (target)=>{\n        if (!target) return null;\n        const isAnchorTarget = typeof target.hasName === \"function\" ? target.hasName(\"_anchor\") : typeof target.name === \"function\" && String(target.name() || \"\").includes(\"_anchor\");\n        if (!isAnchorTarget) return null;\n        const rawName = typeof target.name === \"function\" ? String(target.name() || \"\") : \"\";\n        const anchorName = rawName.split(\" \")[0] || null;\n        if (!anchorName) return null;\n        if (anchorName.toLowerCase().includes(\"rotat\")) return null;\n        return anchorName;\n    };\n    const handleResizeAnchorPressStart = (event)=>{\n        let anchorName = getResizeAnchorNameFromTarget(event === null || event === void 0 ? void 0 : event.target);\n        if (!anchorName) {\n            var _transformerRef_current;\n            const activeAnchor = typeof ((_transformerRef_current = transformerRef.current) === null || _transformerRef_current === void 0 ? void 0 : _transformerRef_current.getActiveAnchor) === \"function\" ? transformerRef.current.getActiveAnchor() : null;\n            if (typeof activeAnchor === \"string\" && !activeAnchor.toLowerCase().includes(\"rotat\")) {\n                anchorName = activeAnchor;\n            }\n        }\n        if (!anchorName) return;\n        setIsResizeGestureActive(true);\n        setPressedResizeAnchorName((current)=>current === anchorName ? current : anchorName);\n    };\n    const getBoxOverflowAmount = (box, stageWidth, stageHeight)=>{\n        if (!box) return Number.POSITIVE_INFINITY;\n        const x = Number(box.x);\n        const y = Number(box.y);\n        const width = Number(box.width);\n        const height = Number(box.height);\n        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height)) {\n            return Number.POSITIVE_INFINITY;\n        }\n        const left = Math.min(x, x + width);\n        const right = Math.max(x, x + width);\n        const top = Math.min(y, y + height);\n        const bottom = Math.max(y, y + height);\n        const overflowLeft = Math.max(0, -left);\n        const overflowTop = Math.max(0, -top);\n        const overflowRight = Math.max(0, right - stageWidth);\n        const overflowBottom = Math.max(0, bottom - stageHeight);\n        return overflowLeft + overflowTop + overflowRight + overflowBottom;\n    };\n    const keepBoxInsideStage = (oldBox, nextBox)=>{\n        var _tr_getStage, _stage_attrs, _stage_attrs1;\n        const tr = transformerRef.current;\n        const stage = tr === null || tr === void 0 ? void 0 : (_tr_getStage = tr.getStage) === null || _tr_getStage === void 0 ? void 0 : _tr_getStage.call(tr);\n        const stageWidth = typeof (stage === null || stage === void 0 ? void 0 : stage.width) === \"function\" ? Number(stage.width()) : Number(stage === null || stage === void 0 ? void 0 : (_stage_attrs = stage.attrs) === null || _stage_attrs === void 0 ? void 0 : _stage_attrs.width);\n        const stageHeight = typeof (stage === null || stage === void 0 ? void 0 : stage.height) === \"function\" ? Number(stage.height()) : Number(stage === null || stage === void 0 ? void 0 : (_stage_attrs1 = stage.attrs) === null || _stage_attrs1 === void 0 ? void 0 : _stage_attrs1.height);\n        if (!Number.isFinite(stageWidth) || stageWidth <= 0 || !Number.isFinite(stageHeight) || stageHeight <= 0) {\n            return nextBox;\n        }\n        const oldOverflow = getBoxOverflowAmount(oldBox, stageWidth, stageHeight);\n        const nextOverflow = getBoxOverflowAmount(nextBox, stageWidth, stageHeight);\n        const epsilon = 0.5;\n        if (!Number.isFinite(nextOverflow)) {\n            return oldBox;\n        }\n        if (nextOverflow <= epsilon) {\n            return nextBox;\n        }\n        // Permitir transformar de vuelta hacia adentro del canvas.\n        if (nextOverflow <= oldOverflow + epsilon) {\n            return nextBox;\n        }\n        // Si el resize empuja mÃ¡s afuera del canvas, mantener el estado anterior.\n        return oldBox;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            if (selectedElements.length === 0 || !deberiaUsarTransformer) {\n                setIsResizeGestureActive(false);\n                setPressedResizeAnchorName({\n                    \"SelectionBounds.useEffect\": (current)=>current ? null : current\n                }[\"SelectionBounds.useEffect\"]);\n                return;\n            }\n            if (isDragging && !isTransformingResizeRef.current) {\n                setIsResizeGestureActive(false);\n                setPressedResizeAnchorName({\n                    \"SelectionBounds.useEffect\": (current)=>current ? null : current\n                }[\"SelectionBounds.useEffect\"]);\n            }\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.length,\n        isDragging,\n        deberiaUsarTransformer\n    ]);\n    // ðŸ”¥ Efecto principal del Transformer (SIN retry / SIN flicker)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _window_editing, _tr_nodes, _tr_nodes1, _tr_getLayer;\n            const tr = transformerRef.current;\n            if (!tr) return;\n            const selKey = selectedElements.join(\",\");\n            TRDBG(\"EFFECT start\", {\n                selKey,\n                isDragging,\n                deberiaUsarTransformer,\n                hasGallery,\n                elementosTransformablesLen: elementosTransformables.length,\n                transformTick,\n                editingId: ((_window_editing = window.editing) === null || _window_editing === void 0 ? void 0 : _window_editing.id) || null\n            });\n            // Si no corresponde transformer, no hagas detach agresivo (evita flicker)\n            if (!deberiaUsarTransformer) {\n                TRDBG(\"EFFECT exit: no transformer or gallery\", {\n                    selKey\n                });\n                return;\n            }\n            // Resolver nodes desde refs (fuente de verdad)\n            let nodosTransformables = elementosTransformables.map({\n                \"SelectionBounds.useEffect.nodosTransformables\": (o)=>{\n                    var _elementRefs_current;\n                    return (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id];\n                }\n            }[\"SelectionBounds.useEffect.nodosTransformables\"]).filter(Boolean);\n            // Single select: usar ref fresco SIEMPRE\n            if (selectedElements.length === 1) {\n                var _elementRefs_current;\n                const idSel = selectedElements[0];\n                const refNode = ((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel]) || null;\n                if (refNode && typeof refNode.getClientRect === \"function\") {\n                    if (esGaleria && typeof refNode.findOne === \"function\") {\n                        const galleryFrame = refNode.findOne(\".gallery-transform-frame\");\n                        if (galleryFrame && typeof galleryFrame.getClientRect === \"function\") {\n                            nodosTransformables = [\n                                galleryFrame\n                            ];\n                        } else {\n                            nodosTransformables = [\n                                refNode\n                            ];\n                        }\n                    } else {\n                        nodosTransformables = [\n                            refNode\n                        ];\n                    }\n                }\n            }\n            // Si aÃºn no hay nodos (imagen cargando, etc.), NO despegar (evita parpadeo)\n            if (nodosTransformables.length === 0) {\n                TRDBG(\"EFFECT exit: no nodes yet\", {\n                    selKey,\n                    wantedIds: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>o.id\n                    }[\"SelectionBounds.useEffect\"]),\n                    refsPresent: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>{\n                            var _elementRefs_current;\n                            return !!((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id]);\n                        }\n                    }[\"SelectionBounds.useEffect\"])\n                });\n                return;\n            }\n            // Attach estable\n            TRDBG(\"ATTACH try\", {\n                selKey,\n                nodesCount: nodosTransformables.length,\n                nodeIds: nodosTransformables.map({\n                    \"SelectionBounds.useEffect\": (n)=>{\n                        var _n_attrs;\n                        return typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id;\n                    }\n                }[\"SelectionBounds.useEffect\"])\n            });\n            tr.nodes(nodosTransformables);\n            TRDBG(\"ATTACH done\", {\n                selKey,\n                trNodesCount: ((_tr_nodes1 = tr.nodes) === null || _tr_nodes1 === void 0 ? void 0 : (_tr_nodes = _tr_nodes1.call(tr)) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.length) || 0\n            });\n            try {\n                var _tr_forceUpdate;\n                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n            } catch (e) {}\n            (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        // Dependencias mÃ­nimas reales\n        selectedElements.join(\",\"),\n        deberiaUsarTransformer,\n        hasGallery,\n        elementosTransformables.length,\n        selectedGeomKey,\n        transformTick,\n        elementRefs\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            const handler = {\n                \"SelectionBounds.useEffect.handler\": (e)=>{\n                    var _e_detail;\n                    const id = e === null || e === void 0 ? void 0 : (_e_detail = e.detail) === null || _e_detail === void 0 ? void 0 : _e_detail.id;\n                    if (!id) return;\n                    TRDBG(\"REF event\", {\n                        id,\n                        isSelected: selectedElements.includes(id),\n                        selKey: selectedElements.join(\",\")\n                    });\n                    if (!selectedElements.includes(id)) return;\n                    setTransformTick({\n                        \"SelectionBounds.useEffect.handler\": (t)=>t + 1\n                    }[\"SelectionBounds.useEffect.handler\"]);\n                }\n            }[\"SelectionBounds.useEffect.handler\"];\n            window.addEventListener(\"element-ref-registrado\", handler);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>window.removeEventListener(\"element-ref-registrado\", handler)\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _elementRefs_current, _firstNode_getStage;\n            const firstId = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n            if (!firstId) return;\n            const firstNode = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[firstId];\n            const stage = firstNode === null || firstNode === void 0 ? void 0 : (_firstNode_getStage = firstNode.getStage) === null || _firstNode_getStage === void 0 ? void 0 : _firstNode_getStage.call(firstNode);\n            if (!stage) return;\n            let rafId = null;\n            const syncTransformer = {\n                \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                    if (rafId != null) return;\n                    rafId = requestAnimationFrame({\n                        \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                            var _tr_getLayer_batchDraw, _tr_getLayer, _tr_getLayer1;\n                            rafId = null;\n                            const tr = transformerRef.current;\n                            if (!tr) return;\n                            try {\n                                var _tr_forceUpdate;\n                                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n                            } catch (e) {}\n                            (_tr_getLayer1 = tr.getLayer) === null || _tr_getLayer1 === void 0 ? void 0 : (_tr_getLayer = _tr_getLayer1.call(tr)) === null || _tr_getLayer === void 0 ? void 0 : (_tr_getLayer_batchDraw = _tr_getLayer.batchDraw) === null || _tr_getLayer_batchDraw === void 0 ? void 0 : _tr_getLayer_batchDraw.call(_tr_getLayer);\n                        }\n                    }[\"SelectionBounds.useEffect.syncTransformer\"]);\n                }\n            }[\"SelectionBounds.useEffect.syncTransformer\"];\n            stage.on(\"dragmove\", syncTransformer);\n            stage.on(\"dragend\", syncTransformer);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>{\n                    stage.off(\"dragmove\", syncTransformer);\n                    stage.off(\"dragend\", syncTransformer);\n                    if (rafId != null) cancelAnimationFrame(rafId);\n                }\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\"),\n        elementRefs\n    ]);\n    // ðŸ”¥ Render\n    if (selectedElements.length === 0) return null;\n    if (hayLineas && elementosTransformables.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 595,\n            columnNumber: 7\n        }, this);\n    }\n    if (hayLineas && elementosTransformables.length > 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 605,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Transformer, {\n        name: \"ui\",\n        ref: transformerRef,\n        // ðŸ”µ borde siempre visible\n        borderEnabled: true,\n        borderStroke: \"#9333EA\",\n        borderStrokeWidth: transformerBorderStrokeWidth,\n        padding: transformerPadding,\n        // âŒ nodos y rotaciÃ³n OFF durante drag\n        enabledAnchors: isDragging && !isResizeGestureActive ? [] : [\n            \"bottom-right\"\n        ],\n        rotateEnabled: !isDragging && !esGaleria,\n        onMouseDown: handleResizeAnchorPressStart,\n        onTouchStart: handleResizeAnchorPressStart,\n        onPointerDown: handleResizeAnchorPressStart,\n        onMouseUp: clearResizeAnchorPressFeedback,\n        onTouchEnd: clearResizeAnchorPressFeedback,\n        onPointerUp: clearResizeAnchorPressFeedback,\n        onTouchCancel: clearResizeAnchorPressFeedback,\n        onPointerCancel: clearResizeAnchorPressFeedback,\n        anchorFill: transformerAnchorFillColor,\n        anchorStroke: transformerAnchorStrokeColor,\n        anchorStrokeWidth: transformerAnchorStrokeWidth,\n        anchorSize: transformerAnchorSize,\n        anchorCornerRadius: transformerAnchorRadius,\n        anchorShadowColor: transformerAnchorShadowColor,\n        anchorShadowBlur: transformerAnchorShadowBlur,\n        anchorShadowOffset: {\n            x: 0,\n            y: transformerAnchorShadowOffsetY\n        },\n        anchorStyleFunc: (anchor)=>{\n            var _window__resizeData;\n            const anchorName = typeof (anchor === null || anchor === void 0 ? void 0 : anchor.name) === \"function\" ? String(anchor.name() || \"\").split(\" \")[0] : \"\";\n            const isResizeAnchorNode = Boolean(anchorName) && !anchorName.toLowerCase().includes(\"rotat\");\n            const isResizeActiveFallback = isResizeGestureActive || isTransformingResizeRef.current ||  true && Boolean((_window__resizeData = window._resizeData) === null || _window__resizeData === void 0 ? void 0 : _window__resizeData.isResizing);\n            const isPressedResizeAnchor = isResizeActiveFallback && isResizeAnchorNode && (!pressedResizeAnchorName || anchorName === pressedResizeAnchorName);\n            anchor.shadowColor(isPressedResizeAnchor ? transformerAnchorPressedShadowColor : transformerAnchorShadowColor);\n            anchor.fill(isPressedResizeAnchor ? transformerAnchorPressedCoreColor : transformerAnchorFillColor);\n            anchor.shadowEnabled(true);\n            // Halo nace desde el centro (fill) y se desvanece hacia afuera.\n            anchor.shadowForStrokeEnabled(false);\n            anchor.shadowOpacity(isPressedResizeAnchor ? 0.96 : 0.28);\n            anchor.shadowBlur(isPressedResizeAnchor ? transformerAnchorPressedShadowBlur : transformerAnchorShadowBlur);\n            anchor.shadowOffset({\n                x: 0,\n                y: isPressedResizeAnchor ? transformerAnchorPressedShadowOffsetY : transformerAnchorShadowOffsetY\n            });\n            anchor.hitStrokeWidth(isPressedResizeAnchor ? transformerAnchorPressedHitStrokeWidth : transformerAnchorHitStrokeWidth);\n            anchor.stroke(isPressedResizeAnchor ? transformerAnchorPressedHaloStrokeColor : transformerAnchorStrokeColor);\n            anchor.strokeWidth(isPressedResizeAnchor ? transformerAnchorPressedHaloStrokeWidth : transformerAnchorStrokeWidth);\n            const anchorScale = isPressedResizeAnchor ? transformerAnchorPressedScale : 1;\n            anchor.scale({\n                x: anchorScale,\n                y: anchorScale\n            });\n        },\n        keepRatio: lockAspectCountdown || esGaleria || lockAspectText,\n        centeredScaling: selectedElements.length === 1 && esTexto,\n        flipEnabled: false,\n        resizeEnabled: !isDragging || isResizeGestureActive,\n        rotationSnaps: [\n            0,\n            45,\n            90,\n            135,\n            180,\n            225,\n            270,\n            315\n        ],\n        rotateAnchorOffset: transformerRotateOffset,\n        rotationSnapTolerance: transformerRotationSnapTolerance,\n        boundBoxFunc: (oldBox, newBox)=>{\n            const minSize = esTexto ? 20 : 10;\n            const maxSize = 800;\n            if (esGaleria) {\n                const rows = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.rows) || 1);\n                const cols = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.cols) || 1);\n                const gap = Math.max(0, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.gap) || 0);\n                const cellRatio = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"4:3\" ? 3 / 4 : (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"16:9\" ? 9 / 16 : 1;\n                const minGridWidth = gap * (cols - 1) + cols;\n                const nextWidth = Math.min(maxSize, Math.max(minSize, minGridWidth, Math.abs(newBox.width)));\n                const cellW = Math.max(1, (nextWidth - gap * (cols - 1)) / cols);\n                const cellH = cellW * cellRatio;\n                const nextHeight = rows * cellH + gap * (rows - 1);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: nextWidth,\n                    height: Math.max(minSize, nextHeight)\n                });\n            }\n            if (newBox.width < minSize || newBox.height < minSize) {\n                return oldBox;\n            }\n            if (lockAspectCountdown) {\n                const baseW = Math.max(1, oldBox.width);\n                const baseH = Math.max(1, oldBox.height);\n                const ratio = baseW / baseH;\n                const dw = Math.abs(newBox.width - oldBox.width) / baseW;\n                const dh = Math.abs(newBox.height - oldBox.height) / baseH;\n                let width = newBox.width;\n                let height = newBox.height;\n                if (dh > dw) {\n                    width = height * ratio;\n                } else {\n                    height = width / ratio;\n                }\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: Math.min(Math.max(width, minSize), maxSize),\n                    height: Math.min(Math.max(height, minSize), maxSize)\n                });\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                const size = Math.max(newBox.width, newBox.height);\n                const finalSize = Math.min(size, maxSize);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: finalSize,\n                    height: finalSize\n                });\n            }\n            if (esTriangulo) {\n                const safeOldW = Math.max(1, Math.abs(oldBox.width || minSize));\n                const safeOldH = Math.max(1, Math.abs(oldBox.height || minSize));\n                const scaleX = Math.abs(newBox.width) / safeOldW;\n                const scaleY = Math.abs(newBox.height) / safeOldH;\n                const uniformScale = Math.max(0.05, Math.min(scaleX, scaleY));\n                const width = Math.min(Math.max(safeOldW * uniformScale, minSize), maxSize);\n                const height = Math.min(Math.max(safeOldH * uniformScale, minSize), maxSize);\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width,\n                    height\n                });\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"imagen\" || (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"icono\") {\n                const scaleX = newBox.width / oldBox.width;\n                const scaleY = newBox.height / oldBox.height;\n                const uniformScale = Math.min(scaleX, scaleY);\n                const newWidth = oldBox.width * uniformScale;\n                const newHeight = oldBox.height * uniformScale;\n                return keepBoxInsideStage(oldBox, {\n                    ...newBox,\n                    width: Math.min(Math.max(newWidth, minSize), maxSize),\n                    height: Math.min(Math.max(newHeight, minSize), maxSize)\n                });\n            }\n            return keepBoxInsideStage(oldBox, {\n                ...newBox,\n                width: Math.min(newBox.width, maxSize),\n                height: Math.min(newBox.height, maxSize)\n            });\n        },\n        onTransformStart: (e)=>{\n            isTransformingResizeRef.current = true;\n            window._resizeData = {\n                isResizing: true\n            };\n            const tr = transformerRef.current;\n            const activeAnchor = typeof (tr === null || tr === void 0 ? void 0 : tr.getActiveAnchor) === \"function\" ? tr.getActiveAnchor() : null;\n            const isRotateGesture = typeof activeAnchor === \"string\" && activeAnchor.toLowerCase().includes(\"rotat\");\n            transformGestureRef.current = {\n                isRotate: isRotateGesture,\n                activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null\n            };\n            if (!isRotateGesture) {\n                setIsResizeGestureActive(true);\n            }\n            if (!isRotateGesture && activeAnchor) {\n                setPressedResizeAnchorName((current)=>current === activeAnchor ? current : activeAnchor);\n            }\n            if (typeof onTransformInteractionStart === \"function\") {\n                var _e_evt;\n                var _e_evt_pointerType;\n                onTransformInteractionStart({\n                    isRotate: isRotateGesture,\n                    activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null,\n                    pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n                });\n            }\n            try {\n                var _tr_nodes, _n_attrs, _tr_getClientRect;\n                const nodes = (tr === null || tr === void 0 ? void 0 : (_tr_nodes = tr.nodes) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.call(tr)) || [];\n                circleAnchorRef.current = null;\n                textTransformAnchorRef.current = null;\n                if (nodes.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                    try {\n                        const r0 = nodes[0].getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        circleAnchorRef.current = {\n                            left: r0.x,\n                            top: r0.y\n                        };\n                    } catch (e) {}\n                }\n                if (nodes.length === 1 && esTexto) {\n                    const node = nodes[0];\n                    let centerX = null;\n                    let centerY = null;\n                    let baseWidth = null;\n                    let baseHeight = null;\n                    let baseVisualWidth = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.x) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width)) {\n                            centerX = rect.x + rect.width / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.y) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height)) {\n                            centerY = rect.y + rect.height / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            baseWidth = rect.width;\n                            baseVisualWidth = rect.width;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height) && rect.height > 0) {\n                            baseHeight = rect.height;\n                        }\n                    } catch (e) {}\n                    const safeBaseFontSize = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.fontSize) && primerElemento.fontSize > 0 ? primerElemento.fontSize : 24;\n                    textTransformAnchorRef.current = {\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : 0,\n                        baseRotation: typeof (node === null || node === void 0 ? void 0 : node.rotation) === \"function\" ? node.rotation() || 0 : 0,\n                        centerX,\n                        centerY,\n                        baseWidth,\n                        baseHeight,\n                        baseFontSize: safeBaseFontSize,\n                        lastPreviewFontSize: safeBaseFontSize,\n                        lastPreviewCenterX: centerX,\n                        lastPreviewCenterY: centerY,\n                        lastPreviewVisualWidth: baseVisualWidth,\n                        previewTick: 0\n                    };\n                    var _primerElemento_id;\n                    TXTDBG(\"start\", {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        baseFontSize: safeBaseFontSize,\n                        baseWidth,\n                        baseHeight,\n                        centerX,\n                        centerY,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        nodeScaleX: typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() : null,\n                        nodeScaleY: typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() : null\n                    });\n                }\n                const union = rectFromNodes(nodes);\n                const pad = typeof (tr === null || tr === void 0 ? void 0 : tr.padding) === \"function\" ? tr.padding() : 0;\n                const borderRect = union ? {\n                    x: union.x - pad,\n                    y: union.y - pad,\n                    width: union.width + pad * 2,\n                    height: union.height + pad * 2\n                } : null;\n                const n = nodes[0];\n                const id = n ? typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id : \"âˆ…\";\n                const trRect = tr === null || tr === void 0 ? void 0 : (_tr_getClientRect = tr.getClientRect) === null || _tr_getClientRect === void 0 ? void 0 : _tr_getClientRect.call(tr, {\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                slog(\"[TR] start\", \"id=\".concat(id), \"nodes=\".concat(nodes.length), union ? \"union(w=\".concat(union.width.toFixed(1), \",h=\").concat(union.height.toFixed(1), \")\") : \"union(null)\", borderRect ? \"border(w=\".concat(borderRect.width.toFixed(1), \",h=\").concat(borderRect.height.toFixed(1), \")\") : \"border(null)\", trRect ? \"trRect(w=\".concat(trRect.width.toFixed(1), \",h=\").concat(trRect.height.toFixed(1), \")\") : \"trRect(null)\", \"pad=\".concat(pad));\n            } catch (e) {}\n        },\n        onTransform: (e)=>{\n            if (!onTransform || !transformerRef.current) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            const node = nodes[0]; // âœ… nodo real (single select)\n            if (!node) return;\n            try {\n                var _node_attrs, _node_scaleX, _node_scaleY, _node_x, _node_y;\n                const pose = getTransformPose(node);\n                const transformData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isPreview: true\n                };\n                if (esTexto) {\n                    var _textTransformAnchorRef_current, _textTransformAnchorRef_current1, _textTransformAnchorRef_current2;\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let liveRectWidth = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            liveRectWidth = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    transformData.fontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    if (textTransformAnchorRef.current) {\n                        const tick = Number(textTransformAnchorRef.current.previewTick || 0) + 1;\n                        textTransformAnchorRef.current.previewTick = tick;\n                        textTransformAnchorRef.current.lastPreviewFontSize = transformData.fontSize;\n                        if (Number.isFinite(liveRectWidth) && liveRectWidth > 0) {\n                            textTransformAnchorRef.current.lastPreviewVisualWidth = liveRectWidth;\n                        }\n                        if (tick <= 2 || tick % 5 === 0) {\n                            var _textTransformAnchorRef_current3;\n                            var _primerElemento_id, _textTransformAnchorRef_current_centerX;\n                            TXTDBG(\"preview\", {\n                                id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                                tick,\n                                scaleX,\n                                scaleY,\n                                avgScale,\n                                scaleFromRect,\n                                effectiveScale,\n                                baseFontSize,\n                                fontSize: transformData.fontSize,\n                                liveRectWidth,\n                                centerXTarget: (_textTransformAnchorRef_current_centerX = (_textTransformAnchorRef_current3 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current3 === void 0 ? void 0 : _textTransformAnchorRef_current3.centerX) !== null && _textTransformAnchorRef_current_centerX !== void 0 ? _textTransformAnchorRef_current_centerX : null,\n                                nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                                nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                            });\n                        }\n                    }\n                    transformData.scaleX = 1;\n                    transformData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite((_textTransformAnchorRef_current = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current === void 0 ? void 0 : _textTransformAnchorRef_current.y)) {\n                        transformData.y = textTransformAnchorRef.current.y;\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current1 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current1 === void 0 ? void 0 : _textTransformAnchorRef_current1.centerX)) {\n                        transformData.textCenterX = textTransformAnchorRef.current.centerX;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterX = textTransformAnchorRef.current.centerX;\n                        }\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current2 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current2 === void 0 ? void 0 : _textTransformAnchorRef_current2.centerY)) {\n                        transformData.textCenterY = textTransformAnchorRef.current.centerY;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterY = textTransformAnchorRef.current.centerY;\n                        }\n                    }\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    transformData.scaleX = scaleX;\n                    transformData.scaleY = scaleY;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        const countdownSize = getCountdownScaledSize(node);\n                        transformData.width = countdownSize.width;\n                        transformData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        transformData.radius = Math.max(1, baseRadius * avgScale);\n                    } else {\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        transformData.width = Math.abs(originalWidth * scaleX);\n                        transformData.height = Math.abs(originalHeight * scaleY);\n                    }\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                        try {\n                            const liveRect = node.getClientRect({\n                                skipTransform: false,\n                                skipShadow: true,\n                                skipStroke: true\n                            });\n                            const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                            transformData.radius = diameter / 2;\n                            const anchor = circleAnchorRef.current;\n                            if (anchor) {\n                                transformData.x = anchor.left + transformData.radius;\n                                transformData.y = anchor.top + transformData.radius;\n                            } else {\n                                transformData.x = liveRect.x + transformData.radius;\n                                transformData.y = liveRect.y + transformData.radius;\n                            }\n                        } catch (e) {}\n                    }\n                }\n                onTransform(transformData);\n                // --- LOG COMPACTO (opcional) ---\n                const id = (typeof node.id === \"function\" ? node.id() : (_node_attrs = node.attrs) === null || _node_attrs === void 0 ? void 0 : _node_attrs.id) || \"âˆ…\";\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                const r = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                var _node_x1, _node_y1, _transformData_width, _transformData_height;\n                slog(\"[TR] live\", \"id=\".concat(id), \"tipo=\".concat((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) || \"âˆ…\"), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"x=\".concat(((_node_x1 = (_node_x = node.x) === null || _node_x === void 0 ? void 0 : _node_x.call(node)) !== null && _node_x1 !== void 0 ? _node_x1 : 0).toFixed(1)), \"y=\".concat(((_node_y1 = (_node_y = node.y) === null || _node_y === void 0 ? void 0 : _node_y.call(node)) !== null && _node_y1 !== void 0 ? _node_y1 : 0).toFixed(1)), \"nodeRect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"), \"w=\".concat((_transformData_width = transformData.width) !== null && _transformData_width !== void 0 ? _transformData_width : \"âˆ…\"), \"h=\".concat((_transformData_height = transformData.height) !== null && _transformData_height !== void 0 ? _transformData_height : \"âˆ…\"));\n            } catch (error) {\n                console.warn(\"Error en onTransform:\", error);\n            }\n        },\n        onTransformEnd: (e)=>{\n            var _transformGestureRef_current, _transformGestureRef_current1, _e_evt;\n            var _transformGestureRef_current_activeAnchor, _e_evt_pointerType;\n            const interactionSnapshot = {\n                isRotate: Boolean((_transformGestureRef_current = transformGestureRef.current) === null || _transformGestureRef_current === void 0 ? void 0 : _transformGestureRef_current.isRotate),\n                activeAnchor: (_transformGestureRef_current_activeAnchor = (_transformGestureRef_current1 = transformGestureRef.current) === null || _transformGestureRef_current1 === void 0 ? void 0 : _transformGestureRef_current1.activeAnchor) !== null && _transformGestureRef_current_activeAnchor !== void 0 ? _transformGestureRef_current_activeAnchor : null,\n                pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n            };\n            const notifyTransformInteractionEnd = ()=>{\n                if (typeof onTransformInteractionEnd === \"function\") {\n                    onTransformInteractionEnd(interactionSnapshot);\n                }\n                transformGestureRef.current = {\n                    isRotate: false,\n                    activeAnchor: null\n                };\n            };\n            try {\n                if (!transformerRef.current || !onTransform) return;\n                const tr = transformerRef.current;\n                const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n                // -------------------------\n                // MULTI-SELECCIÃ“N\n                // -------------------------\n                if (nodes.length > 1) {\n                    try {\n                        var _tr_getLayer;\n                        const tScaleX = typeof tr.scaleX === \"function\" ? tr.scaleX() || 1 : 1;\n                        const tScaleY = typeof tr.scaleY === \"function\" ? tr.scaleY() || 1 : 1;\n                        const avg = (Math.abs(tScaleX) + Math.abs(tScaleY)) / 2;\n                        const updates = nodes.map((n)=>{\n                            let id = null;\n                            try {\n                                var _n_attrs;\n                                id = (typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id) || null;\n                            } catch (e) {}\n                            if (!id) return null;\n                            const obj = (objetos || []).find((o)=>o.id === id);\n                            if (!obj) return null;\n                            const upd = {\n                                id,\n                                x: typeof n.x === \"function\" ? n.x() : obj.x,\n                                y: typeof n.y === \"function\" ? n.y() : obj.y,\n                                rotation: typeof n.rotation === \"function\" ? n.rotation() || 0 : obj.rotation || 0\n                            };\n                            if (obj.tipo === \"texto\") {\n                                const base = obj.fontSize || 24;\n                                upd.fontSize = Math.max(6, Math.round(base * avg));\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"forma\" && obj.figura === \"circle\") {\n                                const baseR = obj.radius || 50;\n                                upd.radius = baseR * avg;\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"forma\" && obj.figura === \"triangle\") {\n                                const baseR = obj.radius || 60;\n                                upd.radius = Math.max(1, baseR * avg);\n                                if (typeof n.scaleX === \"function\") {\n                                    n.scaleX(1);\n                                    n.scaleY(1);\n                                }\n                                return upd;\n                            }\n                            if (obj.tipo === \"countdown\") {\n                                const countdownSize = getCountdownScaledSize(n);\n                                upd.width = countdownSize.width;\n                                upd.height = countdownSize.height;\n                                return upd;\n                            }\n                            const baseW = obj.width != null ? obj.width : typeof n.width === \"function\" ? n.width() : 100;\n                            const baseH = obj.height != null ? obj.height : typeof n.height === \"function\" ? n.height() : 100;\n                            upd.width = Math.abs(baseW * tScaleX);\n                            upd.height = Math.abs(baseH * tScaleY);\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }).filter(Boolean);\n                        onTransform({\n                            isFinal: true,\n                            batch: updates\n                        });\n                        if (typeof tr.scaleX === \"function\") {\n                            tr.scaleX(1);\n                            tr.scaleY(1);\n                        }\n                        (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n                        window._resizeData = {\n                            isResizing: false\n                        };\n                        setTimeout(()=>{\n                            window._resizeData = null;\n                        }, 100);\n                        return;\n                    } catch (err) {\n                        console.warn(\"Error en onTransformEnd (multi):\", err);\n                        window._resizeData = null;\n                        return;\n                    }\n                }\n                // -------------------------\n                // SINGLE-SELECCIÃ“N\n                // -------------------------\n                const node = nodes[0];\n                if (!node) return;\n                const pose = getTransformPose(node);\n                const finalData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isFinal: true\n                };\n                let textPreviewEndSnapshot = null;\n                if (esTexto) {\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let visualWidthFromRect = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            visualWidthFromRect = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    const computedFontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    finalData.fontSize = Math.max(6, Number(Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewFontSize) && anchorData.lastPreviewFontSize > 0 ? anchorData.lastPreviewFontSize : computedFontSize));\n                    finalData.scaleX = 1;\n                    finalData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.y)) {\n                        finalData.y = anchorData.y;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterX)) {\n                        finalData.textCenterX = anchorData.lastPreviewCenterX;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerX)) {\n                        finalData.textCenterX = anchorData.centerX;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterY)) {\n                        finalData.textCenterY = anchorData.lastPreviewCenterY;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerY)) {\n                        finalData.textCenterY = anchorData.centerY;\n                    }\n                    const visualWidth = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewVisualWidth) && anchorData.lastPreviewVisualWidth > 0 ? anchorData.lastPreviewVisualWidth : visualWidthFromRect;\n                    if (Number.isFinite(visualWidth) && visualWidth > 0) {\n                        finalData.textVisualWidth = visualWidth;\n                    }\n                    var _primerElemento_id;\n                    textPreviewEndSnapshot = {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        x: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        scaleX,\n                        scaleY,\n                        fontSize: typeof (node === null || node === void 0 ? void 0 : node.fontSize) === \"function\" ? node.fontSize() : null,\n                        rectWidth: Number.isFinite(visualWidthFromRect) ? visualWidthFromRect : null,\n                        rectHeight: null\n                    };\n                    try {\n                        const rectForSnapshot = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rectForSnapshot === null || rectForSnapshot === void 0 ? void 0 : rectForSnapshot.height)) {\n                            textPreviewEndSnapshot.rectHeight = rectForSnapshot.height;\n                        }\n                    } catch (e) {}\n                    var _primerElemento_id1, _finalData_textCenterX, _finalData_textCenterY, _finalData_textVisualWidth;\n                    TXTDBG(\"end\", {\n                        id: (_primerElemento_id1 = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id1 !== void 0 ? _primerElemento_id1 : null,\n                        scaleX,\n                        scaleY,\n                        avgScale,\n                        scaleFromRect,\n                        effectiveScale,\n                        computedFontSize,\n                        finalFontSize: finalData.fontSize,\n                        textCenterX: (_finalData_textCenterX = finalData.textCenterX) !== null && _finalData_textCenterX !== void 0 ? _finalData_textCenterX : null,\n                        textCenterY: (_finalData_textCenterY = finalData.textCenterY) !== null && _finalData_textCenterY !== void 0 ? _finalData_textCenterY : null,\n                        textVisualWidth: (_finalData_textVisualWidth = finalData.textVisualWidth) !== null && _finalData_textVisualWidth !== void 0 ? _finalData_textVisualWidth : null,\n                        nodeRectWidth: visualWidthFromRect,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                    });\n                    // Aplanar escala del texto en el release para evitar doble escalado\n                    // (escala del nodo + fontSize persistido).\n                    try {\n                        var _node_getLayer;\n                        if (typeof node.scaleX === \"function\") node.scaleX(1);\n                        if (typeof node.scaleY === \"function\") node.scaleY(1);\n                        if (Number.isFinite(finalData.fontSize) && typeof node.fontSize === \"function\") {\n                            node.fontSize(finalData.fontSize);\n                        }\n                        const targetCenterX = Number(finalData.textCenterX);\n                        const targetCenterY = Number(finalData.textCenterY);\n                        if ((Number.isFinite(targetCenterX) || Number.isFinite(targetCenterY)) && typeof node.x === \"function\" && typeof node.y === \"function\") {\n                            try {\n                                const flattenedRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const flattenedCenterX = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.x) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.width) ? flattenedRect.x + flattenedRect.width / 2 : null;\n                                const flattenedCenterY = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.y) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.height) ? flattenedRect.y + flattenedRect.height / 2 : null;\n                                if (Number.isFinite(flattenedCenterX) && Number.isFinite(targetCenterX)) {\n                                    node.x(node.x() + (targetCenterX - flattenedCenterX));\n                                }\n                                if (Number.isFinite(flattenedCenterY) && Number.isFinite(targetCenterY)) {\n                                    node.y(node.y() + (targetCenterY - flattenedCenterY));\n                                }\n                            } catch (e) {}\n                        }\n                        (_node_getLayer = node.getLayer()) === null || _node_getLayer === void 0 ? void 0 : _node_getLayer.batchDraw();\n                    } catch (err) {\n                        console.warn(\"Error aplanando escala de texto (sync):\", err);\n                    }\n                    if (!canUseRectScale) {\n                        if (typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\") {\n                            finalData.x = node.x();\n                        }\n                        if (typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\") {\n                            finalData.y = node.y();\n                        }\n                    }\n                    // Para texto evitamos aplanar antes del commit en React,\n                    // asÃ­ no aparece un frame intermedio con tamaÃ±o \"saltado\".\n                    textTransformAnchorRef.current = null;\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        // Countdown: persistir escala real para que el resultado final\n                        // sea exactamente el mismo que se ve al soltar.\n                        finalData.scaleX = scaleX;\n                        finalData.scaleY = scaleY;\n                        const countdownSize = getCountdownScaledSize(node);\n                        finalData.width = countdownSize.width;\n                        finalData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        finalData.radius = Math.max(1, baseRadius * avgScale);\n                        try {\n                            var _node_getLayer1;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (typeof node.radius === \"function\") node.radius(finalData.radius);\n                            (_node_getLayer1 = node.getLayer()) === null || _node_getLayer1 === void 0 ? void 0 : _node_getLayer1.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escala de triÃ¡ngulo (sync):\", err);\n                        }\n                    } else {\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        finalData.width = Math.abs(originalWidth * scaleX);\n                        finalData.height = Math.abs(originalHeight * scaleY);\n                        if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                            try {\n                                const liveRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                                finalData.radius = diameter / 2;\n                                const anchor = circleAnchorRef.current;\n                                if (anchor) {\n                                    finalData.x = anchor.left + finalData.radius;\n                                    finalData.y = anchor.top + finalData.radius;\n                                } else {\n                                    finalData.x = liveRect.x + finalData.radius;\n                                    finalData.y = liveRect.y + finalData.radius;\n                                }\n                            } catch (e) {}\n                        }\n                        // âœ… Aplanar escala INMEDIATO\n                        try {\n                            var _node_getLayer2;\n                            const fw = finalData.width;\n                            const fh = finalData.height;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (fw != null && typeof node.width === \"function\") node.width(fw);\n                            if (fh != null && typeof node.height === \"function\") node.height(fh);\n                            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\" && finalData.radius != null && typeof node.radius === \"function\") {\n                                node.radius(finalData.radius);\n                            }\n                            (_node_getLayer2 = node.getLayer()) === null || _node_getLayer2 === void 0 ? void 0 : _node_getLayer2.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escalas (sync):\", err);\n                        }\n                    }\n                }\n                onTransform(finalData);\n                circleAnchorRef.current = null;\n                // âœ… Reatachar 1 vez, con ref fresco, en el prÃ³ximo frame\n                try {\n                    const tr2 = transformerRef.current;\n                    if (!tr2) return;\n                    TRDBG(\"onTransformEnd -> schedule RAF reattach\", {\n                        selKey: selectedElements.join(\",\"),\n                        idSel: (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0]) || null\n                    });\n                    requestAnimationFrame(()=>{\n                        var _elementRefs_current, _freshNode_getStage, _freshNode_getStage1;\n                        const idSel = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n                        const freshNode = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                        TRDBG(\"onTransformEnd RAF\", {\n                            idSel,\n                            hasFresh: !!freshNode,\n                            destroyed: !!(freshNode === null || freshNode === void 0 ? void 0 : freshNode._destroyed),\n                            hasStage: !!(freshNode === null || freshNode === void 0 ? void 0 : (_freshNode_getStage = freshNode.getStage) === null || _freshNode_getStage === void 0 ? void 0 : _freshNode_getStage.call(freshNode))\n                        });\n                        // Si el nodo no estÃ¡ listo, despegar y salir\n                        if (!freshNode || freshNode._destroyed || !((_freshNode_getStage1 = freshNode.getStage) === null || _freshNode_getStage1 === void 0 ? void 0 : _freshNode_getStage1.call(freshNode))) {\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            try {\n                                var _tr2_getLayer, _tr2_getLayer1;\n                                tr2.nodes([]);\n                                (_tr2_getLayer1 = tr2.getLayer) === null || _tr2_getLayer1 === void 0 ? void 0 : (_tr2_getLayer = _tr2_getLayer1.call(tr2)) === null || _tr2_getLayer === void 0 ? void 0 : _tr2_getLayer.batchDraw();\n                            } catch (e) {}\n                            return;\n                        }\n                        try {\n                            var _tr2_getLayer2, _tr2_getLayer3;\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            tr2.nodes([\n                                freshNode\n                            ]);\n                            tr2.forceUpdate();\n                            (_tr2_getLayer3 = tr2.getLayer) === null || _tr2_getLayer3 === void 0 ? void 0 : (_tr2_getLayer2 = _tr2_getLayer3.call(tr2)) === null || _tr2_getLayer2 === void 0 ? void 0 : _tr2_getLayer2.batchDraw();\n                            if (textPreviewEndSnapshot && freshNode) {\n                                try {\n                                    const postRect = freshNode.getClientRect({\n                                        skipTransform: false,\n                                        skipShadow: true,\n                                        skipStroke: true\n                                    });\n                                    TXTDBG(\"post-commit:raf1\", {\n                                        id: idSel,\n                                        pre: textPreviewEndSnapshot,\n                                        post: {\n                                            x: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.x) === \"function\" ? freshNode.x() : null,\n                                            y: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.y) === \"function\" ? freshNode.y() : null,\n                                            scaleX: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleX) === \"function\" ? freshNode.scaleX() : null,\n                                            scaleY: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleY) === \"function\" ? freshNode.scaleY() : null,\n                                            fontSize: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.fontSize) === \"function\" ? freshNode.fontSize() : null,\n                                            rectWidth: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) ? postRect.width : null,\n                                            rectHeight: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) ? postRect.height : null\n                                        },\n                                        delta: {\n                                            width: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect.width - textPreviewEndSnapshot.rectWidth : null,\n                                            height: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect.height - textPreviewEndSnapshot.rectHeight : null\n                                        }\n                                    });\n                                } catch (e) {}\n                                requestAnimationFrame(()=>{\n                                    var _elementRefs_current;\n                                    const freshNode2 = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                                    if (!freshNode2) return;\n                                    try {\n                                        const postRect2 = freshNode2.getClientRect({\n                                            skipTransform: false,\n                                            skipShadow: true,\n                                            skipStroke: true\n                                        });\n                                        TXTDBG(\"post-commit:raf2\", {\n                                            id: idSel,\n                                            post: {\n                                                x: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.x) === \"function\" ? freshNode2.x() : null,\n                                                y: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.y) === \"function\" ? freshNode2.y() : null,\n                                                scaleX: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleX) === \"function\" ? freshNode2.scaleX() : null,\n                                                scaleY: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleY) === \"function\" ? freshNode2.scaleY() : null,\n                                                fontSize: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.fontSize) === \"function\" ? freshNode2.fontSize() : null,\n                                                rectWidth: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) ? postRect2.width : null,\n                                                rectHeight: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) ? postRect2.height : null\n                                            },\n                                            deltaFromPre: {\n                                                width: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect2.width - textPreviewEndSnapshot.rectWidth : null,\n                                                height: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect2.height - textPreviewEndSnapshot.rectHeight : null\n                                            }\n                                        });\n                                    } catch (e) {}\n                                });\n                            }\n                        } catch (e) {}\n                    });\n                } catch (e) {}\n            } catch (error) {\n                console.warn(\"Error en onTransformEnd:\", error);\n                window._resizeData = null;\n            } finally{\n                isTransformingResizeRef.current = false;\n                setIsResizeGestureActive(false);\n                clearResizeAnchorPressFeedback();\n                notifyTransformInteractionEnd();\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 614,\n        columnNumber: 5\n    }, this);\n}\n_s1(SelectionBounds, \"IMqo/S4ZLseQxerUTPZnWjua6f8=\");\n_c3 = SelectionBounds;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"TRDBG\");\n$RefreshReg$(_c1, \"TXTDBG\");\n$RefreshReg$(_c2, \"BoundsIndicator\");\n$RefreshReg$(_c3, \"SelectionBounds\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NlbGVjdGlvbkJvdW5kcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsc0JBQXNCOzs7QUFDOEI7QUFDSjtBQUloRCxNQUFNSyx5QkFBeUI7QUFFL0IsTUFBTUMsUUFBUTtxQ0FBSUM7UUFBQUE7O0lBQ2hCLElBQUksQ0FBQ0Ysd0JBQXdCO0lBQzdCRyxRQUFRQyxHQUFHLENBQUMsV0FBV0Y7QUFDekI7QUFDQSxNQUFNRyxPQUFPSjtBQUViLE1BQU1LLFFBQVE7cUNBQUlKO1FBQUFBOztJQUNoQixJQUFJLENBQUNLLE9BQU9DLFFBQVEsRUFBRTtJQUN0QkwsUUFBUUMsR0FBRyxDQUFDLGNBQWNGO0FBQzVCO0tBSE1JO0FBS04sTUFBTUcsU0FBUztxQ0FBSVA7UUFBQUE7O0lBQ2pCLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBQzFDLElBQUksQ0FBQ0ssT0FBT0csaUJBQWlCLEVBQUU7SUFDL0JQLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JGO0FBQzlCO01BSk1PO0FBT04sU0FBU0UsY0FBY0MsS0FBSztJQUMxQixJQUFJQyxPQUFPQyxVQUFVQyxPQUFPRCxVQUFVRSxPQUFPLENBQUNGLFVBQVVHLE9BQU8sQ0FBQ0g7SUFFaEUsS0FBSyxNQUFNSSxLQUFLTixNQUFPO1FBQ3JCLElBQUksRUFBQ00sY0FBQUEsd0JBQUFBLEVBQUdDLGFBQWEsR0FBRTtRQUN2QixNQUFNQyxJQUFJRixFQUFFQyxhQUFhLENBQUM7WUFBRUUsZUFBZTtZQUFPQyxZQUFZO1lBQU1DLFlBQVk7UUFBSztRQUNyRlYsT0FBT1csS0FBS0MsR0FBRyxDQUFDWixNQUFNTyxFQUFFTSxDQUFDO1FBQ3pCWCxPQUFPUyxLQUFLQyxHQUFHLENBQUNWLE1BQU1LLEVBQUVPLENBQUM7UUFDekJYLE9BQU9RLEtBQUtJLEdBQUcsQ0FBQ1osTUFBTUksRUFBRU0sQ0FBQyxHQUFHTixFQUFFUyxLQUFLO1FBQ25DWixPQUFPTyxLQUFLSSxH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QUN0RTs0Q0FDQXdXLGNBQWM7Z0RBQ1p6VyxPQUNFYyxPQUFPQyxRQUFRLENBQUN5VixzQkFBQUEsZ0NBQUFBLFVBQVd4VyxLQUFLLEtBQ2hDYyxPQUFPQyxRQUFRLENBQUM2VCx1QkFBdUJLLFNBQVMsSUFDM0N1QixVQUFVeFcsS0FBSyxHQUFHNFUsdUJBQXVCSyxTQUFTLEdBQ25EO2dEQUNOaFYsUUFDRWEsT0FBT0MsUUFBUSxDQUFDeVYsc0JBQUFBLGdDQUFBQSxVQUFXdlcsTUFBTSxLQUNqQ2EsT0FBT0MsUUFBUSxDQUFDNlQsdUJBQXVCTSxVQUFVLElBQzVDc0IsVUFBVXZXLE1BQU0sR0FBRzJVLHVCQUF1Qk0sVUFBVSxHQUNyRDs0Q0FDUjt3Q0FDRjtvQ0FDRixFQUFFLFVBQU0sQ0FBQztnQ0FDWDs0QkFDRjt3QkFDRixFQUFFLFVBQU0sQ0FBRTtvQkFDWjtnQkFDRixFQUFFLFVBQU0sQ0FBRTtZQUdaLEVBQUUsT0FBTzFSLE9BQU87Z0JBQ2RsRixRQUFRcVYsSUFBSSxDQUFDLDRCQUE0Qm5RO2dCQUN6QzlFLE9BQU9xUCxXQUFXLEdBQUc7WUFDdkIsU0FBVTtnQkFDUnhJLHdCQUF3QmhFLE9BQU8sR0FBRztnQkFDbENrRSx5QkFBeUI7Z0JBQ3pCOEM7Z0JBQ0F1TDtZQUNGO1FBQ0Y7Ozs7OztBQUlOO0lBbDdDd0J0UDtNQUFBQSIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcc3JjXFxjb21wb25lbnRzXFxTZWxlY3Rpb25Cb3VuZHMuanN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNlbGVjdGlvbkJvdW5kcy5qc3hcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IFRyYW5zZm9ybWVyLCBSZWN0IH0gZnJvbSBcInJlYWN0LWtvbnZhXCI7XHJcblxyXG5cclxuXHJcbmNvbnN0IERFQlVHX1NFTEVDVElPTl9CT1VORFMgPSBmYWxzZTtcclxuXHJcbmNvbnN0IHNiTG9nID0gKC4uLmFyZ3MpID0+IHtcclxuICBpZiAoIURFQlVHX1NFTEVDVElPTl9CT1VORFMpIHJldHVybjtcclxuICBjb25zb2xlLmxvZyhcIltTQl1cIiwgLi4uYXJncyk7XHJcbn07XHJcbmNvbnN0IHNsb2cgPSBzYkxvZztcclxuXHJcbmNvbnN0IFRSREJHID0gKC4uLmFyZ3MpID0+IHtcclxuICBpZiAoIXdpbmRvdy5fX0RCR19UUikgcmV0dXJuO1xyXG4gIGNvbnNvbGUubG9nKFwiW1RSREJHXVwiLCAuLi5hcmdzKTtcclxufTtcclxuXHJcbmNvbnN0IFRYVERCRyA9ICguLi5hcmdzKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuICBpZiAoIXdpbmRvdy5fX0RCR19URVhUX1JFU0laRSkgcmV0dXJuO1xyXG4gIGNvbnNvbGUubG9nKFwiW1RFWFQtVFJdXCIsIC4uLmFyZ3MpO1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlY3RGcm9tTm9kZXMobm9kZXMpIHtcclxuICBsZXQgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XHJcblxyXG4gIGZvciAoY29uc3QgbiBvZiBub2Rlcykge1xyXG4gICAgaWYgKCFuPy5nZXRDbGllbnRSZWN0KSBjb250aW51ZTtcclxuICAgIGNvbnN0IHIgPSBuLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcclxuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByLngpO1xyXG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHIueSk7XHJcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgci54ICsgci53aWR0aCk7XHJcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgci55ICsgci5oZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG1pblggPT09IEluZmluaXR5KSByZXR1cm4gbnVsbDtcclxuICByZXR1cm4geyB4OiBtaW5YLCB5OiBtaW5ZLCB3aWR0aDogbWF4WCAtIG1pblgsIGhlaWdodDogbWF4WSAtIG1pblkgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShub2RlKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGhpdGJveCA9IG5vZGU/LmZpbmRPbmU/LihcIi5jb3VudGRvd24taGl0Ym94XCIpO1xyXG4gICAgY29uc3QgYmFzZVcgPSB0eXBlb2YgaGl0Ym94Py53aWR0aCA9PT0gXCJmdW5jdGlvblwiID8gaGl0Ym94LndpZHRoKCkgOiBOYU47XHJcbiAgICBjb25zdCBiYXNlSCA9IHR5cGVvZiBoaXRib3g/LmhlaWdodCA9PT0gXCJmdW5jdGlvblwiID8gaGl0Ym94LmhlaWdodCgpIDogTmFOO1xyXG4gICAgY29uc3Qgc3ggPSBNYXRoLmFicyh0eXBlb2Ygbm9kZT8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5zY2FsZVgoKSB8fCAxKSA6IDEpO1xyXG4gICAgY29uc3Qgc3kgPSBNYXRoLmFicyh0eXBlb2Ygbm9kZT8uc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5zY2FsZVkoKSB8fCAxKSA6IDEpO1xyXG5cclxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYmFzZVcpICYmIE51bWJlci5pc0Zpbml0ZShiYXNlSCkgJiYgYmFzZVcgPiAwICYmIGJhc2VIID4gMCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiBNYXRoLmFicyhiYXNlVyAqIHN4KSxcclxuICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKGJhc2VIICogc3kpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gY2F0Y2gge31cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHIgPSBub2RlLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcclxuICAgIHJldHVybiB7IHdpZHRoOiBNYXRoLmFicyhyLndpZHRoKSwgaGVpZ2h0OiBNYXRoLmFicyhyLmhlaWdodCkgfTtcclxuICB9IGNhdGNoIHt9XHJcblxyXG4gIHJldHVybiB7IHdpZHRoOiAxMDAsIGhlaWdodDogNTAgfTtcclxufVxyXG5cclxuXHJcbi8vIPCfjqggQ29tcG9uZW50ZSBwYXJhIG1vc3RyYXIgYm91bmRzIHNpbiB0cmFuc2Zvcm1lciAobMOtbmVhcywgZXRjLilcclxuY29uc3QgQm91bmRzSW5kaWNhdG9yID0gKHsgc2VsZWN0ZWRFbGVtZW50cywgZWxlbWVudFJlZnMsIG9iamV0b3MgfSkgPT4ge1xyXG4gIGNvbnN0IFtmb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBmaXJzdFJlZiA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltzZWxlY3RlZEVsZW1lbnRzWzBdXTtcclxuICAgIGNvbnN0IHN0YWdlID0gZmlyc3RSZWY/LmdldFN0YWdlPy4oKTtcclxuICAgIGlmICghc3RhZ2UpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVEcmFnTW92ZSA9ICgpID0+IHtcclxuICAgICAgc2V0Rm9yY2VVcGRhdGUoKHApID0+IHAgKyAxKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhZ2Uub24oXCJkcmFnbW92ZVwiLCBoYW5kbGVEcmFnTW92ZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBzdGFnZS5vZmYoXCJkcmFnbW92ZVwiLCBoYW5kbGVEcmFnTW92ZSk7XHJcbiAgICB9O1xyXG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpXSk7XHJcblxyXG4gIGNvbnN0IGVsZW1lbnRvc0RhdGEgPSBzZWxlY3RlZEVsZW1lbnRzXHJcbiAgICAubWFwKChpZCkgPT4gb2JqZXRvcy5maW5kKChvYmopID0+IG9iai5pZCA9PT0gaWQpKVxyXG4gICAgLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgaWYgKGVsZW1lbnRvc0RhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGxldCBtaW5YID0gSW5maW5pdHksXHJcbiAgICBtaW5ZID0gSW5maW5pdHksXHJcbiAgICBtYXhYID0gLUluZmluaXR5LFxyXG4gICAgbWF4WSA9IC1JbmZpbml0eTtcclxuXHJcbiAgZWxlbWVudG9zRGF0YS5mb3JFYWNoKChvYmopID0+IHtcclxuICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50UmVmcy5jdXJyZW50W29iai5pZF07XHJcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAob2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImxpbmVcIikge1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG9iai5wb2ludHMgfHwgWzAsIDAsIDEwMCwgMF07XHJcblxyXG4gICAgICAgIGNvbnN0IGNsZWFuUG9pbnRzID0gW1xyXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbMF0pIHx8IDAsXHJcbiAgICAgICAgICBwYXJzZUZsb2F0KHBvaW50c1sxXSkgfHwgMCxcclxuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzJdKSB8fCAxMDAsXHJcbiAgICAgICAgICBwYXJzZUZsb2F0KHBvaW50c1szXSkgfHwgMCxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBjb25zdCByZWFsWCA9IG5vZGUueCgpO1xyXG4gICAgICAgIGNvbnN0IHJlYWxZID0gbm9kZS55KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHgxID0gcmVhbFggKyBjbGVhblBvaW50c1swXTtcclxuICAgICAgICBjb25zdCB5MSA9IHJlYWxZICsgY2xlYW5Qb2ludHNbMV07XHJcbiAgICAgICAgY29uc3QgeDIgPSByZWFsWCArIGNsZWFuUG9pbnRzWzJdO1xyXG4gICAgICAgIGNvbnN0IHkyID0gcmVhbFkgKyBjbGVhblBvaW50c1szXTtcclxuXHJcbiAgICAgICAgY29uc3QgbGluZVBhZGRpbmcgPSA1O1xyXG5cclxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeDEgLSBsaW5lUGFkZGluZywgeDIgLSBsaW5lUGFkZGluZyk7XHJcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkxIC0gbGluZVBhZGRpbmcsIHkyIC0gbGluZVBhZGRpbmcpO1xyXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4MSArIGxpbmVQYWRkaW5nLCB4MiArIGxpbmVQYWRkaW5nKTtcclxuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeTEgKyBsaW5lUGFkZGluZywgeTIgKyBsaW5lUGFkZGluZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYm94ID0gbm9kZS5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XHJcbiAgICAgICAgY29uc3QgciA9IGJveDtcclxuICAgICAgICBjb25zdCBzeCA9IChub2RlPy5zY2FsZVg/LigpID8/IDEpO1xyXG4gICAgICAgIGNvbnN0IHN5ID0gKG5vZGU/LnNjYWxlWT8uKCkgPz8gMSk7XHJcbiAgICAgICAgc2xvZyhcclxuICAgICAgICAgIFwiW0JJXVwiLFxyXG4gICAgICAgICAgYGlkPSR7b2JqLmlkfWAsXHJcbiAgICAgICAgICBgdGlwbz0ke29iai50aXBvfWAsXHJcbiAgICAgICAgICBgc3g9JHtzeC50b0ZpeGVkKDMpfWAsXHJcbiAgICAgICAgICBgc3k9JHtzeS50b0ZpeGVkKDMpfWAsXHJcbiAgICAgICAgICBgcmVjdCh3PSR7ci53aWR0aC50b0ZpeGVkKDEpfSxoPSR7ci5oZWlnaHQudG9GaXhlZCgxKX0pYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlYWxYID0gYm94Lng7XHJcbiAgICAgICAgY29uc3QgcmVhbFkgPSBib3gueTtcclxuICAgICAgICBsZXQgd2lkdGggPSBib3gud2lkdGg7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IGJveC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJ0ZXh0b1wiICYmIG5vZGUuZ2V0VGV4dEhlaWdodCkge1xyXG4gICAgICAgICAgY29uc3QgdGV4dEhlaWdodCA9IG5vZGUuZ2V0VGV4dEhlaWdodCgpO1xyXG4gICAgICAgICAgaWYgKHRleHRIZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dEhlaWdodDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByZWFsWCk7XHJcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHJlYWxZKTtcclxuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcmVhbFggKyB3aWR0aCk7XHJcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHJlYWxZICsgaGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc3QgZmFsbGJhY2tYID0gb2JqLnggfHwgMDtcclxuICAgICAgY29uc3QgZmFsbGJhY2tZID0gb2JqLnkgfHwgMDtcclxuICAgICAgY29uc3QgZmFsbGJhY2tTaXplID0gMjA7XHJcblxyXG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgZmFsbGJhY2tYKTtcclxuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGZhbGxiYWNrWSk7XHJcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBmYWxsYmFja1ggKyBmYWxsYmFja1NpemUpO1xyXG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgZmFsbGJhY2tZICsgZmFsbGJhY2tTaXplKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKG1pblggPT09IEluZmluaXR5IHx8IG1heFggPT09IC1JbmZpbml0eSkge1xyXG4gICAgY29uc3QgcHJpbWVyRWxlbWVudG8gPSBlbGVtZW50b3NEYXRhWzBdO1xyXG4gICAgaWYgKCFwcmltZXJFbGVtZW50bykgcmV0dXJuIG51bGw7XHJcbiAgICBtaW5YID0gcHJpbWVyRWxlbWVudG8ueCB8fCAwO1xyXG4gICAgbWluWSA9IHByaW1lckVsZW1lbnRvLnkgfHwgMDtcclxuICAgIG1heFggPSBtaW5YICsgMTAwO1xyXG4gICAgbWF4WSA9IG1pblkgKyA1MDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHBhZGRpbmcgPSAxMDtcclxuICBjb25zdCBmaW5hbFggPSBtaW5YIC0gcGFkZGluZztcclxuICBjb25zdCBmaW5hbFkgPSBtaW5ZIC0gcGFkZGluZztcclxuICBjb25zdCBmaW5hbFdpZHRoID0gbWF4WCAtIG1pblggKyBwYWRkaW5nICogMjtcclxuICBjb25zdCBmaW5hbEhlaWdodCA9IG1heFkgLSBtaW5ZICsgcGFkZGluZyAqIDI7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8UmVjdFxyXG4gICAgICBuYW1lPVwidWlcIlxyXG4gICAgICB4PXtmaW5hbFh9XHJcbiAgICAgIHk9e2ZpbmFsWX1cclxuICAgICAgd2lkdGg9e2ZpbmFsV2lkdGh9XHJcbiAgICAgIGhlaWdodD17ZmluYWxIZWlnaHR9XHJcbiAgICAgIGZpbGw9XCJ0cmFuc3BhcmVudFwiXHJcbiAgICAgIHN0cm9rZT1cIiM5MzMzRUFcIlxyXG4gICAgICBzdHJva2VXaWR0aD17MX1cclxuICAgICAgbGlzdGVuaW5nPXtmYWxzZX1cclxuICAgICAgb3BhY2l0eT17MC43fVxyXG4gICAgLz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VsZWN0aW9uQm91bmRzKHtcclxuICBzZWxlY3RlZEVsZW1lbnRzLFxyXG4gIGVsZW1lbnRSZWZzLFxyXG4gIG9iamV0b3MsXHJcbiAgb25UcmFuc2Zvcm0sXHJcbiAgb25UcmFuc2Zvcm1JbnRlcmFjdGlvblN0YXJ0ID0gbnVsbCxcclxuICBvblRyYW5zZm9ybUludGVyYWN0aW9uRW5kID0gbnVsbCxcclxuICBpc0RyYWdnaW5nLFxyXG4gIGlzTW9iaWxlID0gZmFsc2UsXHJcbn0pIHtcclxuICBjb25zdCB0cmFuc2Zvcm1lclJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCBbdHJhbnNmb3JtVGljaywgc2V0VHJhbnNmb3JtVGlja10gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBsYXN0Tm9kZXNSZWYgPSB1c2VSZWYoW10pO1xyXG4gIGNvbnN0IGNpcmNsZUFuY2hvclJlZiA9IHVzZVJlZihudWxsKTtcclxuICBjb25zdCB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IHRyYW5zZm9ybUdlc3R1cmVSZWYgPSB1c2VSZWYoe1xyXG4gICAgaXNSb3RhdGU6IGZhbHNlLFxyXG4gICAgYWN0aXZlQW5jaG9yOiBudWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IGlzVHJhbnNmb3JtaW5nUmVzaXplUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICBjb25zdCBbaXNSZXNpemVHZXN0dXJlQWN0aXZlLCBzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtwcmVzc2VkUmVzaXplQW5jaG9yTmFtZSwgc2V0UHJlc3NlZFJlc2l6ZUFuY2hvck5hbWVdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgY29uc3QgZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEgPSBzZWxlY3RlZEVsZW1lbnRzXHJcbiAgICAubWFwKChpZCkgPT4gb2JqZXRvcy5maW5kKChvYmopID0+IG9iai5pZCA9PT0gaWQpKVxyXG4gICAgLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgY29uc3QgcHJpbWVyRWxlbWVudG8gPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YVswXSB8fCBudWxsO1xyXG4gIGNvbnN0IGVzVGV4dG8gPSBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJ0ZXh0b1wiO1xyXG4gIGNvbnN0IGVzQ291bnRkb3duID0gcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiY291bnRkb3duXCI7XHJcbiAgY29uc3QgZXNHYWxlcmlhID0gc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZ2FsZXJpYVwiO1xyXG4gIGNvbnN0IGxvY2tBc3BlY3RDb3VudGRvd24gPSBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBlc0NvdW50ZG93bjtcclxuICBjb25zdCBsb2NrQXNwZWN0VGV4dCA9IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIGVzVGV4dG87XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTaXplID0gaXNNb2JpbGUgPyAzMiA6IDE0OyAvL3RhbWHDsW8gdmlzdWFsIGRlbCBub2RvIChtw6FzIGdyYW5kZSBlbiBtb2JpbGUpLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyUm90YXRlT2Zmc2V0ID0gaXNNb2JpbGUgPyAzNCA6IDI0OyAvLyBkaXN0YW5jaWEgZGVsIGhhbmRsZSBkZSByb3RhY2nDs24gYWwgYm9yZGUuXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JSYWRpdXMgPSA5OTk7IC8vcmFkaW8gZGUgZXNxdWluYSBkZWwgbm9kbyAoOTk5IGxvIGhhY2UgY2lyY3VsYXIpLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyUGFkZGluZyA9IGlzTW9iaWxlID8gMTQgOiA0OyAvLyBlc3BhY2lvIGV4dHJhIGVudHJlIGJvcmRlIGRlbCB0cmFuc2Zvcm1lciB5IGVsZW1lbnRvLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQm9yZGVyU3Ryb2tlV2lkdGggPSBpc01vYmlsZSA/IDEuNSA6IDE7IC8vZ3Jvc29yIGRlbCBib3JkZSBkZWwgdHJhbnNmb3JtZXIuXHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JGaWxsQ29sb3IgPSBcIiM5MzMzRUFcIjtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gMS40IDogMi41OyAvL2dyb3NvciBkZWwgYm9yZGUgZGVsIG5vZG8uXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Qmx1ciA9IGlzTW9iaWxlID8gOSA6IDY7IC8vIHF1w6kgdGFuIGRpZnVzYSBlcyBsYSBzb21icmEgYmFzZSBkZWwgbm9kby5cclxuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclNoYWRvd09mZnNldFkgPSBpc01vYmlsZSA/IDQgOiAzOyAvLyBkZXNwbGF6YW1pZW50byB2ZXJ0aWNhbCBkZSBlc2Egc29tYnJhLlxyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9ySGl0U3Ryb2tlV2lkdGggPSBpc01vYmlsZSA/IDYyIDogMjA7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGl0U3Ryb2tlV2lkdGggPSBpc01vYmlsZSA/IDk2IDogMjQ7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTdHJva2VDb2xvciA9IFwiI2ZmZmZmZlwiO1xyXG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhhbG9TdHJva2VDb2xvciA9IGlzTW9iaWxlXG4gICAgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSlcIlxuICAgIDogdHJhbnNmb3JtZXJBbmNob3JTdHJva2VDb2xvcjtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkSGFsb1N0cm9rZVdpZHRoID0gaXNNb2JpbGUgPyAyLjYgOiAzLjI7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZENvcmVDb2xvciA9IGlzTW9iaWxlXG4gICAgPyBcInJnYmEoMjI0LCAxNjgsIDI1NSwgMSlcIlxuICAgIDogdHJhbnNmb3JtZXJBbmNob3JGaWxsQ29sb3I7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Q29sb3IgPSBcInJnYmEoMTQ3LCA1MSwgMjM0LCAwLjMpXCI7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0NvbG9yID0gaXNNb2JpbGVcbiAgICA/IFwicmdiYSgyMjQsIDE2OCwgMjU1LCAwLjk1KVwiXG4gICAgOiBcInJnYmEoMTQ3LCA1MSwgMjM0LCAwLjcpXCI7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0JsdXIgPSBpc01vYmlsZSA/IDE4MCA6IDE4O1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dPZmZzZXRZID1cclxuICAgIGlzTW9iaWxlID8gMCA6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSArIDE7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2NhbGUgPSBpc01vYmlsZSA/IDEuMDMgOiAxLjE7XHJcbiAgY29uc3QgdHJhbnNmb3JtZXJSb3RhdGlvblNuYXBUb2xlcmFuY2UgPSBpc01vYmlsZSA/IDggOiA1OyAvL3RvbGVyYW5jaWEgcGFyYSDigJxlbmNhamFy4oCdIHJvdGFjacOzbiBlbiDDoW5ndWxvcyBmaWpvcy5cclxuICBjb25zdCBlc1RyaWFuZ3VsbyA9XHJcbiAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJmb3JtYVwiICYmXHJcbiAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcInRyaWFuZ2xlXCI7XHJcblxyXG4gIGNvbnN0IGhhc0dhbGxlcnkgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YS5zb21lKFxyXG4gICAgKG8pID0+IG8udGlwbyA9PT0gXCJnYWxlcmlhXCJcclxuICApO1xyXG5cclxuICBjb25zdCBoYXlMaW5lYXMgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YS5zb21lKFxyXG4gICAgKG9iaikgPT4gb2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImxpbmVcIlxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEuZmlsdGVyKFxyXG4gICAgKG9iaikgPT4gIShvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwibGluZVwiKVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGRlYmVyaWFVc2FyVHJhbnNmb3JtZXIgPVxyXG4gICAgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID4gMDtcclxuXHJcbiAgY29uc3Qgc2VsZWN0ZWRHZW9tS2V5ID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGFcclxuICAgIC5tYXAoKG8pID0+XHJcbiAgICAgIFtcclxuICAgICAgICBvLmlkLFxyXG4gICAgICAgIG8ueCA/PyAwLFxyXG4gICAgICAgIG8ueSA/PyAwLFxyXG4gICAgICAgIG8ud2lkdGggPz8gXCJcIixcclxuICAgICAgICBvLmhlaWdodCA/PyBcIlwiLFxyXG4gICAgICAgIG8uc2NhbGVYID8/IDEsXHJcbiAgICAgICAgby5zY2FsZVkgPz8gMSxcclxuICAgICAgICBvLnJvdGF0aW9uID8/IDAsXHJcbiAgICAgICAgby5jaGlwV2lkdGggPz8gXCJcIixcclxuICAgICAgICBvLmdhcCA/PyBcIlwiLFxyXG4gICAgICAgIG8ucGFkZGluZ1ggPz8gXCJcIixcclxuICAgICAgICBvLnBhZGRpbmdZID8/IFwiXCIsXHJcbiAgICAgIF0uam9pbihcIjpcIilcclxuICAgIClcclxuICAgIC5qb2luKFwifFwiKTtcclxuXHJcbiAgY29uc3QgZ2V0VHJhbnNmb3JtUG9zZSA9IChub2RlKSA9PiB7XHJcbiAgICBpZiAoIW5vZGUpIHJldHVybiB7IHg6IDAsIHk6IDAsIHJvdGF0aW9uOiAwIH07XHJcblxyXG4gICAgaWYgKGVzR2FsZXJpYSAmJiB0eXBlb2Ygbm9kZS5nZXRQYXJlbnQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHg6IHR5cGVvZiBwYXJlbnQueCA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LngoKSA6IDAsXHJcbiAgICAgICAgICB5OiB0eXBlb2YgcGFyZW50LnkgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmVudC55KCkgOiAwLFxyXG4gICAgICAgICAgcm90YXRpb246IHR5cGVvZiBwYXJlbnQucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IHBhcmVudC5yb3RhdGlvbigpIHx8IDAgOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB0eXBlb2Ygbm9kZS54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IDAsXHJcbiAgICAgIHk6IHR5cGVvZiBub2RlLnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogMCxcclxuICAgICAgcm90YXRpb246IHR5cGVvZiBub2RlLnJvdGF0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnJvdGF0aW9uKCkgfHwgMCA6IDAsXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICBjb25zdCBjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2sgPSAoKSA9PiB7XHJcbiAgICBpZiAoaXNUcmFuc2Zvcm1pbmdSZXNpemVSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlKGZhbHNlKTtcclxuICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PiAoY3VycmVudCA/IG51bGwgOiBjdXJyZW50KSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0UmVzaXplQW5jaG9yTmFtZUZyb21UYXJnZXQgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBpc0FuY2hvclRhcmdldCA9XHJcbiAgICAgIHR5cGVvZiB0YXJnZXQuaGFzTmFtZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgPyB0YXJnZXQuaGFzTmFtZShcIl9hbmNob3JcIilcclxuICAgICAgICA6IHR5cGVvZiB0YXJnZXQubmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICBTdHJpbmcodGFyZ2V0Lm5hbWUoKSB8fCBcIlwiKS5pbmNsdWRlcyhcIl9hbmNob3JcIik7XHJcbiAgICBpZiAoIWlzQW5jaG9yVGFyZ2V0KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCByYXdOYW1lID1cclxuICAgICAgdHlwZW9mIHRhcmdldC5uYW1lID09PSBcImZ1bmN0aW9uXCIgPyBTdHJpbmcodGFyZ2V0Lm5hbWUoKSB8fCBcIlwiKSA6IFwiXCI7XHJcbiAgICBjb25zdCBhbmNob3JOYW1lID0gcmF3TmFtZS5zcGxpdChcIiBcIilbMF0gfHwgbnVsbDtcclxuICAgIGlmICghYW5jaG9yTmFtZSkgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoYW5jaG9yTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIikpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGFuY2hvck5hbWU7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlUmVzaXplQW5jaG9yUHJlc3NTdGFydCA9IChldmVudCkgPT4ge1xyXG4gICAgbGV0IGFuY2hvck5hbWUgPSBnZXRSZXNpemVBbmNob3JOYW1lRnJvbVRhcmdldChldmVudD8udGFyZ2V0KTtcclxuICAgIGlmICghYW5jaG9yTmFtZSkge1xyXG4gICAgICBjb25zdCBhY3RpdmVBbmNob3IgPVxyXG4gICAgICAgIHR5cGVvZiB0cmFuc2Zvcm1lclJlZi5jdXJyZW50Py5nZXRBY3RpdmVBbmNob3IgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgPyB0cmFuc2Zvcm1lclJlZi5jdXJyZW50LmdldEFjdGl2ZUFuY2hvcigpXHJcbiAgICAgICAgICA6IG51bGw7XHJcbiAgICAgIGlmIChcclxuICAgICAgICB0eXBlb2YgYWN0aXZlQW5jaG9yID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgIWFjdGl2ZUFuY2hvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIilcclxuICAgICAgKSB7XHJcbiAgICAgICAgYW5jaG9yTmFtZSA9IGFjdGl2ZUFuY2hvcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFhbmNob3JOYW1lKSByZXR1cm47XHJcbiAgICBzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmUodHJ1ZSk7XHJcbiAgICBzZXRQcmVzc2VkUmVzaXplQW5jaG9yTmFtZSgoY3VycmVudCkgPT5cclxuICAgICAgY3VycmVudCA9PT0gYW5jaG9yTmFtZSA/IGN1cnJlbnQgOiBhbmNob3JOYW1lXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEJveE92ZXJmbG93QW1vdW50ID0gKGJveCwgc3RhZ2VXaWR0aCwgc3RhZ2VIZWlnaHQpID0+IHtcclxuICAgIGlmICghYm94KSByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgY29uc3QgeCA9IE51bWJlcihib3gueCk7XHJcbiAgICBjb25zdCB5ID0gTnVtYmVyKGJveC55KTtcclxuICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKGJveC53aWR0aCk7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBOdW1iZXIoYm94LmhlaWdodCk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAhTnVtYmVyLmlzRmluaXRlKHgpIHx8XHJcbiAgICAgICFOdW1iZXIuaXNGaW5pdGUoeSkgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZSh3aWR0aCkgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZShoZWlnaHQpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeCwgeCArIHdpZHRoKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeCwgeCArIHdpZHRoKTtcclxuICAgIGNvbnN0IHRvcCA9IE1hdGgubWluKHksIHkgKyBoZWlnaHQpO1xyXG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoeSwgeSArIGhlaWdodCk7XHJcblxyXG4gICAgY29uc3Qgb3ZlcmZsb3dMZWZ0ID0gTWF0aC5tYXgoMCwgLWxlZnQpO1xyXG4gICAgY29uc3Qgb3ZlcmZsb3dUb3AgPSBNYXRoLm1heCgwLCAtdG9wKTtcclxuICAgIGNvbnN0IG92ZXJmbG93UmlnaHQgPSBNYXRoLm1heCgwLCByaWdodCAtIHN0YWdlV2lkdGgpO1xyXG4gICAgY29uc3Qgb3ZlcmZsb3dCb3R0b20gPSBNYXRoLm1heCgwLCBib3R0b20gLSBzdGFnZUhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIG92ZXJmbG93TGVmdCArIG92ZXJmbG93VG9wICsgb3ZlcmZsb3dSaWdodCArIG92ZXJmbG93Qm90dG9tO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGtlZXBCb3hJbnNpZGVTdGFnZSA9IChvbGRCb3gsIG5leHRCb3gpID0+IHtcclxuICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IHN0YWdlID0gdHI/LmdldFN0YWdlPy4oKTtcclxuICAgIGNvbnN0IHN0YWdlV2lkdGggPVxyXG4gICAgICB0eXBlb2Ygc3RhZ2U/LndpZHRoID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/IE51bWJlcihzdGFnZS53aWR0aCgpKVxyXG4gICAgICAgIDogTnVtYmVyKHN0YWdlPy5hdHRycz8ud2lkdGgpO1xyXG4gICAgY29uc3Qgc3RhZ2VIZWlnaHQgPVxyXG4gICAgICB0eXBlb2Ygc3RhZ2U/LmhlaWdodCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgPyBOdW1iZXIoc3RhZ2UuaGVpZ2h0KCkpXHJcbiAgICAgICAgOiBOdW1iZXIoc3RhZ2U/LmF0dHJzPy5oZWlnaHQpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZShzdGFnZVdpZHRoKSB8fFxyXG4gICAgICBzdGFnZVdpZHRoIDw9IDAgfHxcclxuICAgICAgIU51bWJlci5pc0Zpbml0ZShzdGFnZUhlaWdodCkgfHxcclxuICAgICAgc3RhZ2VIZWlnaHQgPD0gMFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBuZXh0Qm94O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9sZE92ZXJmbG93ID0gZ2V0Qm94T3ZlcmZsb3dBbW91bnQob2xkQm94LCBzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XHJcbiAgICBjb25zdCBuZXh0T3ZlcmZsb3cgPSBnZXRCb3hPdmVyZmxvd0Ftb3VudChuZXh0Qm94LCBzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XHJcbiAgICBjb25zdCBlcHNpbG9uID0gMC41O1xyXG5cclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5leHRPdmVyZmxvdykpIHtcclxuICAgICAgcmV0dXJuIG9sZEJveDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV4dE92ZXJmbG93IDw9IGVwc2lsb24pIHtcclxuICAgICAgcmV0dXJuIG5leHRCb3g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVybWl0aXIgdHJhbnNmb3JtYXIgZGUgdnVlbHRhIGhhY2lhIGFkZW50cm8gZGVsIGNhbnZhcy5cclxuICAgIGlmIChuZXh0T3ZlcmZsb3cgPD0gb2xkT3ZlcmZsb3cgKyBlcHNpbG9uKSB7XHJcbiAgICAgIHJldHVybiBuZXh0Qm94O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpIGVsIHJlc2l6ZSBlbXB1amEgbcOhcyBhZnVlcmEgZGVsIGNhbnZhcywgbWFudGVuZXIgZWwgZXN0YWRvIGFudGVyaW9yLlxyXG4gICAgcmV0dXJuIG9sZEJveDtcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAwIHx8ICFkZWJlcmlhVXNhclRyYW5zZm9ybWVyKSB7XHJcbiAgICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PiAoY3VycmVudCA/IG51bGwgOiBjdXJyZW50KSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0RyYWdnaW5nICYmICFpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PiAoY3VycmVudCA/IG51bGwgOiBjdXJyZW50KSk7XHJcbiAgICB9XHJcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMubGVuZ3RoLCBpc0RyYWdnaW5nLCBkZWJlcmlhVXNhclRyYW5zZm9ybWVyXSk7XHJcblxyXG4gIC8vIPCflKUgRWZlY3RvIHByaW5jaXBhbCBkZWwgVHJhbnNmb3JtZXIgKFNJTiByZXRyeSAvIFNJTiBmbGlja2VyKVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIXRyKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgc2VsS2V5ID0gc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKTtcclxuICAgIFRSREJHKFwiRUZGRUNUIHN0YXJ0XCIsIHtcclxuICAgICAgc2VsS2V5LFxyXG4gICAgICBpc0RyYWdnaW5nLFxyXG4gICAgICBkZWJlcmlhVXNhclRyYW5zZm9ybWVyLFxyXG4gICAgICBoYXNHYWxsZXJ5LFxyXG4gICAgICBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlc0xlbjogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoLFxyXG4gICAgICB0cmFuc2Zvcm1UaWNrLFxyXG4gICAgICBlZGl0aW5nSWQ6IHdpbmRvdy5lZGl0aW5nPy5pZCB8fCBudWxsLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2kgbm8gY29ycmVzcG9uZGUgdHJhbnNmb3JtZXIsIG5vIGhhZ2FzIGRldGFjaCBhZ3Jlc2l2byAoZXZpdGEgZmxpY2tlcilcclxuICAgIGlmICghZGViZXJpYVVzYXJUcmFuc2Zvcm1lcikge1xyXG4gICAgICBUUkRCRyhcIkVGRkVDVCBleGl0OiBubyB0cmFuc2Zvcm1lciBvciBnYWxsZXJ5XCIsIHsgc2VsS2V5IH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFJlc29sdmVyIG5vZGVzIGRlc2RlIHJlZnMgKGZ1ZW50ZSBkZSB2ZXJkYWQpXHJcbiAgICBsZXQgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzXHJcbiAgICAgIC5tYXAoKG8pID0+IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltvLmlkXSlcclxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgICAvLyBTaW5nbGUgc2VsZWN0OiB1c2FyIHJlZiBmcmVzY28gU0lFTVBSRVxyXG4gICAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGNvbnN0IGlkU2VsID0gc2VsZWN0ZWRFbGVtZW50c1swXTtcclxuICAgICAgY29uc3QgcmVmTm9kZSA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltpZFNlbF0gfHwgbnVsbDtcclxuICAgICAgaWYgKHJlZk5vZGUgJiYgdHlwZW9mIHJlZk5vZGUuZ2V0Q2xpZW50UmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGVzR2FsZXJpYSAmJiB0eXBlb2YgcmVmTm9kZS5maW5kT25lID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIGNvbnN0IGdhbGxlcnlGcmFtZSA9IHJlZk5vZGUuZmluZE9uZShcIi5nYWxsZXJ5LXRyYW5zZm9ybS1mcmFtZVwiKTtcclxuICAgICAgICAgIGlmIChnYWxsZXJ5RnJhbWUgJiYgdHlwZW9mIGdhbGxlcnlGcmFtZS5nZXRDbGllbnRSZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtnYWxsZXJ5RnJhbWVdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtyZWZOb2RlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtyZWZOb2RlXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTaSBhw7puIG5vIGhheSBub2RvcyAoaW1hZ2VuIGNhcmdhbmRvLCBldGMuKSwgTk8gZGVzcGVnYXIgKGV2aXRhIHBhcnBhZGVvKVxyXG4gICAgaWYgKG5vZG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIFRSREJHKFwiRUZGRUNUIGV4aXQ6IG5vIG5vZGVzIHlldFwiLCB7XHJcbiAgICAgICAgc2VsS2V5LFxyXG4gICAgICAgIHdhbnRlZElkczogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubWFwKG8gPT4gby5pZCksXHJcbiAgICAgICAgcmVmc1ByZXNlbnQ6IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLm1hcChvID0+ICEhZWxlbWVudFJlZnMuY3VycmVudD8uW28uaWRdKSxcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQXR0YWNoIGVzdGFibGVcclxuICAgIFRSREJHKFwiQVRUQUNIIHRyeVwiLCB7XHJcbiAgICAgIHNlbEtleSxcclxuICAgICAgbm9kZXNDb3VudDogbm9kb3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGgsXHJcbiAgICAgIG5vZGVJZHM6IG5vZG9zVHJhbnNmb3JtYWJsZXMubWFwKG4gPT4gKHR5cGVvZiBuLmlkID09PSBcImZ1bmN0aW9uXCIgPyBuLmlkKCkgOiBuLmF0dHJzPy5pZCkpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdHIubm9kZXMobm9kb3NUcmFuc2Zvcm1hYmxlcyk7XHJcblxyXG4gICAgVFJEQkcoXCJBVFRBQ0ggZG9uZVwiLCB7XHJcbiAgICAgIHNlbEtleSxcclxuICAgICAgdHJOb2Rlc0NvdW50OiB0ci5ub2Rlcz8uKCk/Lmxlbmd0aCB8fCAwLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdHJ5IHsgdHIuZm9yY2VVcGRhdGU/LigpOyB9IGNhdGNoIHsgfVxyXG4gICAgdHIuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XHJcblxyXG4gIH0sIFtcclxuICAgIC8vIERlcGVuZGVuY2lhcyBtw61uaW1hcyByZWFsZXNcclxuICAgIHNlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIiksXHJcbiAgICBkZWJlcmlhVXNhclRyYW5zZm9ybWVyLFxyXG4gICAgaGFzR2FsbGVyeSxcclxuICAgIGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCxcclxuICAgIHNlbGVjdGVkR2VvbUtleSxcclxuICAgIHRyYW5zZm9ybVRpY2ssXHJcbiAgICBlbGVtZW50UmVmcyxcclxuICBdKTtcclxuXHJcblxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IChlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlkID0gZT8uZGV0YWlsPy5pZDtcclxuICAgICAgaWYgKCFpZCkgcmV0dXJuO1xyXG5cclxuICAgICAgVFJEQkcoXCJSRUYgZXZlbnRcIiwge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdGVkRWxlbWVudHMuaW5jbHVkZXMoaWQpLFxyXG4gICAgICAgIHNlbEtleTogc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudHMuaW5jbHVkZXMoaWQpKSByZXR1cm47XHJcbiAgICAgIHNldFRyYW5zZm9ybVRpY2sodCA9PiB0ICsgMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZWxlbWVudC1yZWYtcmVnaXN0cmFkb1wiLCBoYW5kbGVyKTtcclxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVsZW1lbnQtcmVmLXJlZ2lzdHJhZG9cIiwgaGFuZGxlcik7XHJcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIildKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGZpcnN0SWQgPSBzZWxlY3RlZEVsZW1lbnRzPy5bMF07XHJcbiAgICBpZiAoIWZpcnN0SWQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBlbGVtZW50UmVmcy5jdXJyZW50Py5bZmlyc3RJZF07XHJcbiAgICBjb25zdCBzdGFnZSA9IGZpcnN0Tm9kZT8uZ2V0U3RhZ2U/LigpO1xyXG4gICAgaWYgKCFzdGFnZSkgcmV0dXJuO1xyXG5cclxuICAgIGxldCByYWZJZCA9IG51bGw7XHJcbiAgICBjb25zdCBzeW5jVHJhbnNmb3JtZXIgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChyYWZJZCAhPSBudWxsKSByZXR1cm47XHJcbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICByYWZJZCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghdHIpIHJldHVybjtcclxuICAgICAgICB0cnkgeyB0ci5mb3JjZVVwZGF0ZT8uKCk7IH0gY2F0Y2ggeyB9XHJcbiAgICAgICAgdHIuZ2V0TGF5ZXI/LigpPy5iYXRjaERyYXc/LigpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhZ2Uub24oXCJkcmFnbW92ZVwiLCBzeW5jVHJhbnNmb3JtZXIpO1xyXG4gICAgc3RhZ2Uub24oXCJkcmFnZW5kXCIsIHN5bmNUcmFuc2Zvcm1lcik7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ21vdmVcIiwgc3luY1RyYW5zZm9ybWVyKTtcclxuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ2VuZFwiLCBzeW5jVHJhbnNmb3JtZXIpO1xyXG4gICAgICBpZiAocmFmSWQgIT0gbnVsbCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xyXG4gICAgfTtcclxuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSwgZWxlbWVudFJlZnNdKTtcclxuXHJcblxyXG5cclxuXHJcbiAgLy8g8J+UpSBSZW5kZXJcclxuXHJcbiAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgaWYgKGhheUxpbmVhcyAmJiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxCb3VuZHNJbmRpY2F0b3JcclxuICAgICAgICBzZWxlY3RlZEVsZW1lbnRzPXtzZWxlY3RlZEVsZW1lbnRzfVxyXG4gICAgICAgIGVsZW1lbnRSZWZzPXtlbGVtZW50UmVmc31cclxuICAgICAgICBvYmpldG9zPXtvYmpldG9zfVxyXG4gICAgICAvPlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmIChoYXlMaW5lYXMgJiYgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPEJvdW5kc0luZGljYXRvclxyXG4gICAgICAgIHNlbGVjdGVkRWxlbWVudHM9e3NlbGVjdGVkRWxlbWVudHN9XHJcbiAgICAgICAgZWxlbWVudFJlZnM9e2VsZW1lbnRSZWZzfVxyXG4gICAgICAgIG9iamV0b3M9e29iamV0b3N9XHJcbiAgICAgIC8+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxUcmFuc2Zvcm1lclxyXG4gICAgICBuYW1lPVwidWlcIlxyXG4gICAgICByZWY9e3RyYW5zZm9ybWVyUmVmfVxyXG5cclxuICAgICAgLy8g8J+UtSBib3JkZSBzaWVtcHJlIHZpc2libGVcclxuICAgICAgYm9yZGVyRW5hYmxlZD17dHJ1ZX1cclxuXHJcbiAgICAgIGJvcmRlclN0cm9rZT1cIiM5MzMzRUFcIlxyXG5cclxuXHJcbiAgICAgIGJvcmRlclN0cm9rZVdpZHRoPXt0cmFuc2Zvcm1lckJvcmRlclN0cm9rZVdpZHRofVxyXG4gICAgICBwYWRkaW5nPXt0cmFuc2Zvcm1lclBhZGRpbmd9XHJcblxyXG4gICAgICAvLyDinYwgbm9kb3MgeSByb3RhY2nDs24gT0ZGIGR1cmFudGUgZHJhZ1xyXG4gICAgICBlbmFibGVkQW5jaG9ycz17aXNEcmFnZ2luZyAmJiAhaXNSZXNpemVHZXN0dXJlQWN0aXZlID8gW10gOiBbXCJib3R0b20tcmlnaHRcIl19XHJcbiAgICAgIHJvdGF0ZUVuYWJsZWQ9eyFpc0RyYWdnaW5nICYmICFlc0dhbGVyaWF9XHJcbiAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVSZXNpemVBbmNob3JQcmVzc1N0YXJ0fVxyXG4gICAgICBvblRvdWNoU3RhcnQ9e2hhbmRsZVJlc2l6ZUFuY2hvclByZXNzU3RhcnR9XHJcbiAgICAgIG9uUG9pbnRlckRvd249e2hhbmRsZVJlc2l6ZUFuY2hvclByZXNzU3RhcnR9XHJcbiAgICAgIG9uTW91c2VVcD17Y2xlYXJSZXNpemVBbmNob3JQcmVzc0ZlZWRiYWNrfVxyXG4gICAgICBvblRvdWNoRW5kPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcbiAgICAgIG9uUG9pbnRlclVwPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcbiAgICAgIG9uVG91Y2hDYW5jZWw9e2NsZWFyUmVzaXplQW5jaG9yUHJlc3NGZWVkYmFja31cclxuICAgICAgb25Qb2ludGVyQ2FuY2VsPXtjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2t9XHJcblxyXG4gICAgICBhbmNob3JGaWxsPXt0cmFuc2Zvcm1lckFuY2hvckZpbGxDb2xvcn1cbiAgICAgIGFuY2hvclN0cm9rZT17dHJhbnNmb3JtZXJBbmNob3JTdHJva2VDb2xvcn1cclxuICAgICAgYW5jaG9yU3Ryb2tlV2lkdGg9e3RyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlV2lkdGh9XHJcbiAgICAgIGFuY2hvclNpemU9e3RyYW5zZm9ybWVyQW5jaG9yU2l6ZX1cclxuICAgICAgYW5jaG9yQ29ybmVyUmFkaXVzPXt0cmFuc2Zvcm1lckFuY2hvclJhZGl1c31cclxuICAgICAgYW5jaG9yU2hhZG93Q29sb3I9e3RyYW5zZm9ybWVyQW5jaG9yU2hhZG93Q29sb3J9XHJcbiAgICAgIGFuY2hvclNoYWRvd0JsdXI9e3RyYW5zZm9ybWVyQW5jaG9yU2hhZG93Qmx1cn1cclxuICAgICAgYW5jaG9yU2hhZG93T2Zmc2V0PXt7IHg6IDAsIHk6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSB9fVxyXG4gICAgICBhbmNob3JTdHlsZUZ1bmM9eyhhbmNob3IpID0+IHtcclxuICAgICAgICBjb25zdCBhbmNob3JOYW1lID1cclxuICAgICAgICAgIHR5cGVvZiBhbmNob3I/Lm5hbWUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICA/IFN0cmluZyhhbmNob3IubmFtZSgpIHx8IFwiXCIpLnNwbGl0KFwiIFwiKVswXVxyXG4gICAgICAgICAgICA6IFwiXCI7XHJcbiAgICAgICAgY29uc3QgaXNSZXNpemVBbmNob3JOb2RlID1cclxuICAgICAgICAgIEJvb2xlYW4oYW5jaG9yTmFtZSkgJiYgIWFuY2hvck5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInJvdGF0XCIpO1xyXG4gICAgICAgIGNvbnN0IGlzUmVzaXplQWN0aXZlRmFsbGJhY2sgPVxyXG4gICAgICAgICAgaXNSZXNpemVHZXN0dXJlQWN0aXZlIHx8XHJcbiAgICAgICAgICBpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50IHx8XHJcbiAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICBCb29sZWFuKHdpbmRvdy5fcmVzaXplRGF0YT8uaXNSZXNpemluZykpO1xyXG4gICAgICAgIGNvbnN0IGlzUHJlc3NlZFJlc2l6ZUFuY2hvciA9XHJcbiAgICAgICAgICBpc1Jlc2l6ZUFjdGl2ZUZhbGxiYWNrICYmXHJcbiAgICAgICAgICBpc1Jlc2l6ZUFuY2hvck5vZGUgJiZcclxuICAgICAgICAgICghcHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUgfHwgYW5jaG9yTmFtZSA9PT0gcHJlc3NlZFJlc2l6ZUFuY2hvck5hbWUpO1xyXG5cclxuICAgICAgICBhbmNob3Iuc2hhZG93Q29sb3IoXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNoYWRvd0NvbG9yXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Q29sb3JcbiAgICAgICAgKTtcbiAgICAgICAgYW5jaG9yLmZpbGwoXG4gICAgICAgICAgaXNQcmVzc2VkUmVzaXplQW5jaG9yXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZENvcmVDb2xvclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lckFuY2hvckZpbGxDb2xvclxuICAgICAgICApO1xuICAgICAgICBhbmNob3Iuc2hhZG93RW5hYmxlZCh0cnVlKTtcbiAgICAgICAgLy8gSGFsbyBuYWNlIGRlc2RlIGVsIGNlbnRybyAoZmlsbCkgeSBzZSBkZXN2YW5lY2UgaGFjaWEgYWZ1ZXJhLlxuICAgICAgICBhbmNob3Iuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIGFuY2hvci5zaGFkb3dPcGFjaXR5KGlzUHJlc3NlZFJlc2l6ZUFuY2hvciA/IDAuOTYgOiAwLjI4KTtcbiAgICAgICAgYW5jaG9yLnNoYWRvd0JsdXIoXHJcbiAgICAgICAgICBpc1ByZXNzZWRSZXNpemVBbmNob3JcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dCbHVyXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dCbHVyXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbmNob3Iuc2hhZG93T2Zmc2V0KHtcclxuICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICB5OiBpc1ByZXNzZWRSZXNpemVBbmNob3JcclxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dPZmZzZXRZXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dPZmZzZXRZLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFuY2hvci5oaXRTdHJva2VXaWR0aChcclxuICAgICAgICAgIGlzUHJlc3NlZFJlc2l6ZUFuY2hvclxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhpdFN0cm9rZVdpZHRoXHJcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZXJBbmNob3JIaXRTdHJva2VXaWR0aFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYW5jaG9yLnN0cm9rZShcclxuICAgICAgICAgIGlzUHJlc3NlZFJlc2l6ZUFuY2hvclxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhhbG9TdHJva2VDb2xvclxyXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlQ29sb3JcclxuICAgICAgICApO1xyXG4gICAgICAgIGFuY2hvci5zdHJva2VXaWR0aChcclxuICAgICAgICAgIGlzUHJlc3NlZFJlc2l6ZUFuY2hvclxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZEhhbG9TdHJva2VXaWR0aFxyXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlV2lkdGhcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGFuY2hvclNjYWxlID0gaXNQcmVzc2VkUmVzaXplQW5jaG9yXHJcbiAgICAgICAgICA/IHRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNjYWxlXHJcbiAgICAgICAgICA6IDE7XHJcbiAgICAgICAgYW5jaG9yLnNjYWxlKHsgeDogYW5jaG9yU2NhbGUsIHk6IGFuY2hvclNjYWxlIH0pO1xyXG4gICAgICB9fVxyXG4gICAgICBrZWVwUmF0aW89e2xvY2tBc3BlY3RDb3VudGRvd24gfHwgZXNHYWxlcmlhIHx8IGxvY2tBc3BlY3RUZXh0fVxyXG4gICAgICBjZW50ZXJlZFNjYWxpbmc9e3NlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIGVzVGV4dG99XHJcbiAgICAgIGZsaXBFbmFibGVkPXtmYWxzZX1cclxuICAgICAgcmVzaXplRW5hYmxlZD17IWlzRHJhZ2dpbmcgfHwgaXNSZXNpemVHZXN0dXJlQWN0aXZlfVxyXG4gICAgICByb3RhdGlvblNuYXBzPXtbMCwgNDUsIDkwLCAxMzUsIDE4MCwgMjI1LCAyNzAsIDMxNV19XHJcbiAgICAgIHJvdGF0ZUFuY2hvck9mZnNldD17dHJhbnNmb3JtZXJSb3RhdGVPZmZzZXR9XHJcbiAgICAgIHJvdGF0aW9uU25hcFRvbGVyYW5jZT17dHJhbnNmb3JtZXJSb3RhdGlvblNuYXBUb2xlcmFuY2V9XHJcbiAgICAgIGJvdW5kQm94RnVuYz17KG9sZEJveCwgbmV3Qm94KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IGVzVGV4dG8gPyAyMCA6IDEwO1xyXG4gICAgICAgIGNvbnN0IG1heFNpemUgPSA4MDA7XHJcbiAgICAgICAgaWYgKGVzR2FsZXJpYSkge1xyXG4gICAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIE51bWJlcihwcmltZXJFbGVtZW50bz8ucm93cykgfHwgMSk7XHJcbiAgICAgICAgICBjb25zdCBjb2xzID0gTWF0aC5tYXgoMSwgTnVtYmVyKHByaW1lckVsZW1lbnRvPy5jb2xzKSB8fCAxKTtcclxuICAgICAgICAgIGNvbnN0IGdhcCA9IE1hdGgubWF4KDAsIE51bWJlcihwcmltZXJFbGVtZW50bz8uZ2FwKSB8fCAwKTtcclxuICAgICAgICAgIGNvbnN0IGNlbGxSYXRpbyA9XHJcbiAgICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5yYXRpbyA9PT0gXCI0OjNcIlxyXG4gICAgICAgICAgICAgID8gMyAvIDRcclxuICAgICAgICAgICAgICA6IHByaW1lckVsZW1lbnRvPy5yYXRpbyA9PT0gXCIxNjo5XCJcclxuICAgICAgICAgICAgICAgID8gOSAvIDE2XHJcbiAgICAgICAgICAgICAgICA6IDE7XHJcblxyXG4gICAgICAgICAgY29uc3QgbWluR3JpZFdpZHRoID0gZ2FwICogKGNvbHMgLSAxKSArIGNvbHM7XHJcbiAgICAgICAgICBjb25zdCBuZXh0V2lkdGggPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgbWF4U2l6ZSxcclxuICAgICAgICAgICAgTWF0aC5tYXgobWluU2l6ZSwgbWluR3JpZFdpZHRoLCBNYXRoLmFicyhuZXdCb3gud2lkdGgpKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNvbnN0IGNlbGxXID0gTWF0aC5tYXgoMSwgKG5leHRXaWR0aCAtIGdhcCAqIChjb2xzIC0gMSkpIC8gY29scyk7XHJcbiAgICAgICAgICBjb25zdCBjZWxsSCA9IGNlbGxXICogY2VsbFJhdGlvO1xyXG4gICAgICAgICAgY29uc3QgbmV4dEhlaWdodCA9IHJvd3MgKiBjZWxsSCArIGdhcCAqIChyb3dzIC0gMSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGtlZXBCb3hJbnNpZGVTdGFnZShvbGRCb3gsIHtcclxuICAgICAgICAgICAgLi4ubmV3Qm94LFxyXG4gICAgICAgICAgICB3aWR0aDogbmV4dFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KG1pblNpemUsIG5leHRIZWlnaHQpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV3Qm94LndpZHRoIDwgbWluU2l6ZSB8fCBuZXdCb3guaGVpZ2h0IDwgbWluU2l6ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIG9sZEJveDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChsb2NrQXNwZWN0Q291bnRkb3duKSB7XHJcbiAgICAgICAgICBjb25zdCBiYXNlVyA9IE1hdGgubWF4KDEsIG9sZEJveC53aWR0aCk7XHJcbiAgICAgICAgICBjb25zdCBiYXNlSCA9IE1hdGgubWF4KDEsIG9sZEJveC5oZWlnaHQpO1xyXG4gICAgICAgICAgY29uc3QgcmF0aW8gPSBiYXNlVyAvIGJhc2VIO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGR3ID0gTWF0aC5hYnMobmV3Qm94LndpZHRoIC0gb2xkQm94LndpZHRoKSAvIGJhc2VXO1xyXG4gICAgICAgICAgY29uc3QgZGggPSBNYXRoLmFicyhuZXdCb3guaGVpZ2h0IC0gb2xkQm94LmhlaWdodCkgLyBiYXNlSDtcclxuXHJcbiAgICAgICAgICBsZXQgd2lkdGggPSBuZXdCb3gud2lkdGg7XHJcbiAgICAgICAgICBsZXQgaGVpZ2h0ID0gbmV3Qm94LmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoZGggPiBkdykge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHJhdGlvO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyByYXRpbztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4ga2VlcEJveEluc2lkZVN0YWdlKG9sZEJveCwge1xyXG4gICAgICAgICAgICAuLi5uZXdCb3gsXHJcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihNYXRoLm1heCh3aWR0aCwgbWluU2l6ZSksIG1heFNpemUpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKE1hdGgubWF4KGhlaWdodCwgbWluU2l6ZSksIG1heFNpemUpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJmb3JtYVwiICYmXHJcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgobmV3Qm94LndpZHRoLCBuZXdCb3guaGVpZ2h0KTtcclxuICAgICAgICAgIGNvbnN0IGZpbmFsU2l6ZSA9IE1hdGgubWluKHNpemUsIG1heFNpemUpO1xyXG4gICAgICAgICAgcmV0dXJuIGtlZXBCb3hJbnNpZGVTdGFnZShvbGRCb3gsIHtcclxuICAgICAgICAgICAgLi4ubmV3Qm94LFxyXG4gICAgICAgICAgICB3aWR0aDogZmluYWxTaXplLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGZpbmFsU2l6ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVzVHJpYW5ndWxvKSB7XHJcbiAgICAgICAgICBjb25zdCBzYWZlT2xkVyA9IE1hdGgubWF4KDEsIE1hdGguYWJzKG9sZEJveC53aWR0aCB8fCBtaW5TaXplKSk7XHJcbiAgICAgICAgICBjb25zdCBzYWZlT2xkSCA9IE1hdGgubWF4KDEsIE1hdGguYWJzKG9sZEJveC5oZWlnaHQgfHwgbWluU2l6ZSkpO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMobmV3Qm94LndpZHRoKSAvIHNhZmVPbGRXO1xyXG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gTWF0aC5hYnMobmV3Qm94LmhlaWdodCkgLyBzYWZlT2xkSDtcclxuICAgICAgICAgIGNvbnN0IHVuaWZvcm1TY2FsZSA9IE1hdGgubWF4KDAuMDUsIE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSk7XHJcblxyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChzYWZlT2xkVyAqIHVuaWZvcm1TY2FsZSwgbWluU2l6ZSksIG1heFNpemUpO1xyXG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgoc2FmZU9sZEggKiB1bmlmb3JtU2NhbGUsIG1pblNpemUpLCBtYXhTaXplKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4ga2VlcEJveEluc2lkZVN0YWdlKG9sZEJveCwge1xyXG4gICAgICAgICAgICAuLi5uZXdCb3gsXHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImltYWdlblwiIHx8XHJcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJpY29ub1wiXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVggPSBuZXdCb3gud2lkdGggLyBvbGRCb3gud2lkdGg7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBuZXdCb3guaGVpZ2h0IC8gb2xkQm94LmhlaWdodDtcclxuICAgICAgICAgIGNvbnN0IHVuaWZvcm1TY2FsZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IG9sZEJveC53aWR0aCAqIHVuaWZvcm1TY2FsZTtcclxuICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IG9sZEJveC5oZWlnaHQgKiB1bmlmb3JtU2NhbGU7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGtlZXBCb3hJbnNpZGVTdGFnZShvbGRCb3gsIHtcclxuICAgICAgICAgICAgLi4ubmV3Qm94LFxyXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oTWF0aC5tYXgobmV3V2lkdGgsIG1pblNpemUpLCBtYXhTaXplKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihNYXRoLm1heChuZXdIZWlnaHQsIG1pblNpemUpLCBtYXhTaXplKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGtlZXBCb3hJbnNpZGVTdGFnZShvbGRCb3gsIHtcclxuICAgICAgICAgIC4uLm5ld0JveCxcclxuICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihuZXdCb3gud2lkdGgsIG1heFNpemUpLFxyXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihuZXdCb3guaGVpZ2h0LCBtYXhTaXplKSxcclxuICAgICAgICB9KTtcclxuICAgICAgfX1cclxuICAgICAgb25UcmFuc2Zvcm1TdGFydD17KGUpID0+IHtcclxuICAgICAgICBpc1RyYW5zZm9ybWluZ1Jlc2l6ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSB7IGlzUmVzaXppbmc6IHRydWUgfTtcclxuICAgICAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlQW5jaG9yID1cclxuICAgICAgICAgIHR5cGVvZiB0cj8uZ2V0QWN0aXZlQW5jaG9yID09PSBcImZ1bmN0aW9uXCIgPyB0ci5nZXRBY3RpdmVBbmNob3IoKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgaXNSb3RhdGVHZXN0dXJlID1cclxuICAgICAgICAgIHR5cGVvZiBhY3RpdmVBbmNob3IgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgICAgIGFjdGl2ZUFuY2hvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIik7XHJcbiAgICAgICAgdHJhbnNmb3JtR2VzdHVyZVJlZi5jdXJyZW50ID0ge1xyXG4gICAgICAgICAgaXNSb3RhdGU6IGlzUm90YXRlR2VzdHVyZSxcclxuICAgICAgICAgIGFjdGl2ZUFuY2hvcjogYWN0aXZlQW5jaG9yID8/IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWlzUm90YXRlR2VzdHVyZSkge1xyXG4gICAgICAgICAgc2V0SXNSZXNpemVHZXN0dXJlQWN0aXZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUm90YXRlR2VzdHVyZSAmJiBhY3RpdmVBbmNob3IpIHtcclxuICAgICAgICAgIHNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lKChjdXJyZW50KSA9PlxyXG4gICAgICAgICAgICBjdXJyZW50ID09PSBhY3RpdmVBbmNob3IgPyBjdXJyZW50IDogYWN0aXZlQW5jaG9yXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9uVHJhbnNmb3JtSW50ZXJhY3Rpb25TdGFydCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICBvblRyYW5zZm9ybUludGVyYWN0aW9uU3RhcnQoe1xyXG4gICAgICAgICAgICBpc1JvdGF0ZTogaXNSb3RhdGVHZXN0dXJlLFxyXG4gICAgICAgICAgICBhY3RpdmVBbmNob3I6IGFjdGl2ZUFuY2hvciA/PyBudWxsLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogZT8uZXZ0Py5wb2ludGVyVHlwZSA/PyBudWxsLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBub2RlcyA9IHRyPy5ub2Rlcz8uKCkgfHwgW107XHJcbiAgICAgICAgICBjaXJjbGVBbmNob3JSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgbm9kZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImZvcm1hXCIgJiZcclxuICAgICAgICAgICAgcHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIlxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcjAgPSBub2Rlc1swXS5nZXRDbGllbnRSZWN0KHtcclxuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQgPSB7IGxlZnQ6IHIwLngsIHRvcDogcjAueSB9O1xyXG4gICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBlc1RleHRvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTtcclxuICAgICAgICAgICAgbGV0IGNlbnRlclggPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgY2VudGVyWSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBiYXNlV2lkdGggPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgYmFzZUhlaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBiYXNlVmlzdWFsV2lkdGggPSBudWxsO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LngpICYmIE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNlbnRlclggPSByZWN0LnggKyAocmVjdC53aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LnkpICYmIE51bWJlci5pc0Zpbml0ZShyZWN0Py5oZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJZID0gcmVjdC55ICsgKHJlY3QuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlV2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgYmFzZVZpc3VhbFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py5oZWlnaHQpICYmIHJlY3QuaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYmFzZUhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICBjb25zdCBzYWZlQmFzZUZvbnRTaXplID1cclxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocHJpbWVyRWxlbWVudG8/LmZvbnRTaXplKSAmJiBwcmltZXJFbGVtZW50by5mb250U2l6ZSA+IDBcclxuICAgICAgICAgICAgICAgID8gcHJpbWVyRWxlbWVudG8uZm9udFNpemVcclxuICAgICAgICAgICAgICAgIDogMjQ7XHJcbiAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCA9IHtcclxuICAgICAgICAgICAgICB5OiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiAwLFxyXG4gICAgICAgICAgICAgIGJhc2VSb3RhdGlvbjpcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlPy5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUucm90YXRpb24oKSB8fCAwKSA6IDAsXHJcbiAgICAgICAgICAgICAgY2VudGVyWCxcclxuICAgICAgICAgICAgICBjZW50ZXJZLFxyXG4gICAgICAgICAgICAgIGJhc2VXaWR0aCxcclxuICAgICAgICAgICAgICBiYXNlSGVpZ2h0LFxyXG4gICAgICAgICAgICAgIGJhc2VGb250U2l6ZTogc2FmZUJhc2VGb250U2l6ZSxcclxuICAgICAgICAgICAgICBsYXN0UHJldmlld0ZvbnRTaXplOiBzYWZlQmFzZUZvbnRTaXplLFxyXG4gICAgICAgICAgICAgIGxhc3RQcmV2aWV3Q2VudGVyWDogY2VudGVyWCxcclxuICAgICAgICAgICAgICBsYXN0UHJldmlld0NlbnRlclk6IGNlbnRlclksXHJcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdWaXN1YWxXaWR0aDogYmFzZVZpc3VhbFdpZHRoLFxyXG4gICAgICAgICAgICAgIHByZXZpZXdUaWNrOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUWFREQkcoXCJzdGFydFwiLCB7XHJcbiAgICAgICAgICAgICAgaWQ6IHByaW1lckVsZW1lbnRvPy5pZCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgIGJhc2VGb250U2l6ZTogc2FmZUJhc2VGb250U2l6ZSxcclxuICAgICAgICAgICAgICBiYXNlV2lkdGgsXHJcbiAgICAgICAgICAgICAgYmFzZUhlaWdodCxcclxuICAgICAgICAgICAgICBjZW50ZXJYLFxyXG4gICAgICAgICAgICAgIGNlbnRlclksXHJcbiAgICAgICAgICAgICAgbm9kZVg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgbm9kZVk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgbm9kZVNjYWxlWDogdHlwZW9mIG5vZGU/LnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgbm9kZVNjYWxlWTogdHlwZW9mIG5vZGU/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IHVuaW9uID0gcmVjdEZyb21Ob2Rlcyhub2Rlcyk7XHJcblxyXG4gICAgICAgICAgY29uc3QgcGFkID0gdHlwZW9mIHRyPy5wYWRkaW5nID09PSBcImZ1bmN0aW9uXCIgPyB0ci5wYWRkaW5nKCkgOiAwO1xyXG4gICAgICAgICAgY29uc3QgYm9yZGVyUmVjdCA9IHVuaW9uXHJcbiAgICAgICAgICAgID8geyB4OiB1bmlvbi54IC0gcGFkLCB5OiB1bmlvbi55IC0gcGFkLCB3aWR0aDogdW5pb24ud2lkdGggKyBwYWQgKiAyLCBoZWlnaHQ6IHVuaW9uLmhlaWdodCArIHBhZCAqIDIgfVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcblxyXG4gICAgICAgICAgY29uc3QgbiA9IG5vZGVzWzBdO1xyXG4gICAgICAgICAgY29uc3QgaWQgPSBuID8gKHR5cGVvZiBuLmlkID09PSBcImZ1bmN0aW9uXCIgPyBuLmlkKCkgOiBuLmF0dHJzPy5pZCkgOiBcIuKIhVwiO1xyXG4gICAgICAgICAgY29uc3QgdHJSZWN0ID0gdHI/LmdldENsaWVudFJlY3Q/Lih7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAgIHNsb2coXHJcbiAgICAgICAgICAgIFwiW1RSXSBzdGFydFwiLFxyXG4gICAgICAgICAgICBgaWQ9JHtpZH1gLFxyXG4gICAgICAgICAgICBgbm9kZXM9JHtub2Rlcy5sZW5ndGh9YCxcclxuICAgICAgICAgICAgdW5pb24gPyBgdW5pb24odz0ke3VuaW9uLndpZHRoLnRvRml4ZWQoMSl9LGg9JHt1bmlvbi5oZWlnaHQudG9GaXhlZCgxKX0pYCA6IFwidW5pb24obnVsbClcIixcclxuICAgICAgICAgICAgYm9yZGVyUmVjdCA/IGBib3JkZXIodz0ke2JvcmRlclJlY3Qud2lkdGgudG9GaXhlZCgxKX0saD0ke2JvcmRlclJlY3QuaGVpZ2h0LnRvRml4ZWQoMSl9KWAgOiBcImJvcmRlcihudWxsKVwiLFxyXG4gICAgICAgICAgICB0clJlY3QgPyBgdHJSZWN0KHc9JHt0clJlY3Qud2lkdGgudG9GaXhlZCgxKX0saD0ke3RyUmVjdC5oZWlnaHQudG9GaXhlZCgxKX0pYCA6IFwidHJSZWN0KG51bGwpXCIsXHJcbiAgICAgICAgICAgIGBwYWQ9JHtwYWR9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIHsgfVxyXG4gICAgICB9fVxyXG5cclxuICAgICAgb25UcmFuc2Zvcm09eyhlKSA9PiB7XHJcbiAgICAgICAgaWYgKCFvblRyYW5zZm9ybSB8fCAhdHJhbnNmb3JtZXJSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0eXBlb2YgdHIubm9kZXMgPT09IFwiZnVuY3Rpb25cIiA/IHRyLm5vZGVzKCkgfHwgW10gOiBbXTtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbMF07IC8vIOKchSBub2RvIHJlYWwgKHNpbmdsZSBzZWxlY3QpXHJcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwb3NlID0gZ2V0VHJhbnNmb3JtUG9zZShub2RlKTtcclxuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybURhdGEgPSB7XHJcbiAgICAgICAgICAgIHg6IHBvc2UueCxcclxuICAgICAgICAgICAgeTogcG9zZS55LFxyXG4gICAgICAgICAgICByb3RhdGlvbjogcG9zZS5yb3RhdGlvbixcclxuICAgICAgICAgICAgaXNQcmV2aWV3OiB0cnVlLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBpZiAoZXNUZXh0bykge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcHJpbWVyRWxlbWVudG8uZm9udFNpemUgfHwgMjQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHR5cGVvZiBub2RlLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvckRhdGEgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgfHwgbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgYmFzZUZvbnRTaXplID1cclxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8uYmFzZUZvbnRTaXplKSAmJlxyXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEuYmFzZUZvbnRTaXplID4gMFxyXG4gICAgICAgICAgICAgICAgPyBhbmNob3JEYXRhLmJhc2VGb250U2l6ZVxyXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEZvbnRTaXplO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYXZnU2NhbGUgPSAoTWF0aC5hYnMoc2NhbGVYKSArIE1hdGguYWJzKHNjYWxlWSkpIC8gMjtcclxuICAgICAgICAgICAgbGV0IHNjYWxlRnJvbVJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgbGl2ZVJlY3RXaWR0aCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSb3RhdGlvbiA9XHJcbiAgICAgICAgICAgICAgdHlwZW9mIG5vZGUucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnJvdGF0aW9uKCkgfHwgMCkgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlUm90YXRpb24gPSBOdW1iZXIoYW5jaG9yRGF0YT8uYmFzZVJvdGF0aW9uKTtcclxuICAgICAgICAgICAgY29uc3Qgcm90YXRpb25EZWx0YSA9IE51bWJlci5pc0Zpbml0ZShiYXNlUm90YXRpb24pXHJcbiAgICAgICAgICAgICAgPyBNYXRoLmFicyhjdXJyZW50Um90YXRpb24gLSBiYXNlUm90YXRpb24pXHJcbiAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJiByZWN0LndpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGl2ZVJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VXaWR0aCA9IE51bWJlcihhbmNob3JEYXRhPy5iYXNlV2lkdGgpO1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShiYXNlV2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICBiYXNlV2lkdGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID4gMFxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCA9IHJlY3Qud2lkdGggLyBiYXNlV2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgIGNvbnN0IGNhblVzZVJlY3RTY2FsZSA9IHJvdGF0aW9uRGVsdGEgPCAwLjE7XHJcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVNjYWxlID1cclxuICAgICAgICAgICAgICBjYW5Vc2VSZWN0U2NhbGUgJiYgTnVtYmVyLmlzRmluaXRlKHNjYWxlRnJvbVJlY3QpICYmIHNjYWxlRnJvbVJlY3QgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHNjYWxlRnJvbVJlY3RcclxuICAgICAgICAgICAgICAgIDogYXZnU2NhbGU7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuZm9udFNpemUgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgICA2LFxyXG4gICAgICAgICAgICAgIE51bWJlcigoYmFzZUZvbnRTaXplICogZWZmZWN0aXZlU2NhbGUpLnRvRml4ZWQoMykpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBjb25zdCB0aWNrID0gTnVtYmVyKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5wcmV2aWV3VGljayB8fCAwKSArIDE7XHJcbiAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LnByZXZpZXdUaWNrID0gdGljaztcclxuICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdGb250U2l6ZSA9IHRyYW5zZm9ybURhdGEuZm9udFNpemU7XHJcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShsaXZlUmVjdFdpZHRoKSAmJiBsaXZlUmVjdFdpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Lmxhc3RQcmV2aWV3VmlzdWFsV2lkdGggPSBsaXZlUmVjdFdpZHRoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAodGljayA8PSAyIHx8IHRpY2sgJSA1ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBUWFREQkcoXCJwcmV2aWV3XCIsIHtcclxuICAgICAgICAgICAgICAgICAgaWQ6IHByaW1lckVsZW1lbnRvPy5pZCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgICAgICB0aWNrLFxyXG4gICAgICAgICAgICAgICAgICBzY2FsZVgsXHJcbiAgICAgICAgICAgICAgICAgIHNjYWxlWSxcclxuICAgICAgICAgICAgICAgICAgYXZnU2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgIHNjYWxlRnJvbVJlY3QsXHJcbiAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICBiYXNlRm9udFNpemUsXHJcbiAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0cmFuc2Zvcm1EYXRhLmZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICBsaXZlUmVjdFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICBjZW50ZXJYVGFyZ2V0OiB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LmNlbnRlclggPz8gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgbm9kZVg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIG5vZGVZOiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICBpZiAoY2FuVXNlUmVjdFNjYWxlICYmIE51bWJlci5pc0Zpbml0ZSh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LnkpKSB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS55ID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Lnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LmNlbnRlclgpKSB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS50ZXh0Q2VudGVyWCA9IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5jZW50ZXJYO1xyXG4gICAgICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld0NlbnRlclggPVxyXG4gICAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQuY2VudGVyWDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LmNlbnRlclkpKSB7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS50ZXh0Q2VudGVyWSA9IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld0NlbnRlclkgPVxyXG4gICAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQuY2VudGVyWTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHR5cGVvZiBub2RlLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XHJcblxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWCA9IHNjYWxlWDtcclxuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5zY2FsZVkgPSBzY2FsZVk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiY291bnRkb3duXCIpIHtcclxuICAgICAgICAgICAgICBjb25zdCBjb3VudGRvd25TaXplID0gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShub2RlKTtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLndpZHRoID0gY291bnRkb3duU2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLmhlaWdodCA9IGNvdW50ZG93blNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVzVHJpYW5ndWxvKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVJhZGl1cyA9IE51bWJlci5pc0Zpbml0ZShwcmltZXJFbGVtZW50bz8ucmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgPyBwcmltZXJFbGVtZW50by5yYWRpdXNcclxuICAgICAgICAgICAgICAgIDogNjA7XHJcbiAgICAgICAgICAgICAgY29uc3QgYXZnU2NhbGUgPSAoTWF0aC5hYnMoc2NhbGVYKSArIE1hdGguYWJzKHNjYWxlWSkpIC8gMjtcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnJhZGl1cyA9IE1hdGgubWF4KDEsIGJhc2VSYWRpdXMgKiBhdmdTY2FsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHByaW1lckVsZW1lbnRvLndpZHRoIHx8IDEwMDtcclxuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHByaW1lckVsZW1lbnRvLmhlaWdodCB8fCAxMDA7XHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS53aWR0aCA9IE1hdGguYWJzKG9yaWdpbmFsV2lkdGggKiBzY2FsZVgpO1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuaGVpZ2h0ID0gTWF0aC5hYnMob3JpZ2luYWxIZWlnaHQgKiBzY2FsZVkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaXZlUmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaWFtZXRlciA9IE1hdGgubWF4KDEsIE1hdGgubWF4KGxpdmVSZWN0LndpZHRoLCBsaXZlUmVjdC5oZWlnaHQpKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEucmFkaXVzID0gZGlhbWV0ZXIgLyAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueCA9IGFuY2hvci5sZWZ0ICsgdHJhbnNmb3JtRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueSA9IGFuY2hvci50b3AgKyB0cmFuc2Zvcm1EYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueCA9IGxpdmVSZWN0LnggKyB0cmFuc2Zvcm1EYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS55ID0gbGl2ZVJlY3QueSArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG9uVHJhbnNmb3JtKHRyYW5zZm9ybURhdGEpO1xyXG5cclxuICAgICAgICAgIC8vIC0tLSBMT0cgQ09NUEFDVE8gKG9wY2lvbmFsKSAtLS1cclxuICAgICAgICAgIGNvbnN0IGlkID0gKHR5cGVvZiBub2RlLmlkID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLmlkKCkgOiBub2RlLmF0dHJzPy5pZCkgfHwgXCLiiIVcIjtcclxuICAgICAgICAgIGNvbnN0IHN4ID0gbm9kZS5zY2FsZVg/LigpID8/IDE7XHJcbiAgICAgICAgICBjb25zdCBzeSA9IG5vZGUuc2NhbGVZPy4oKSA/PyAxO1xyXG4gICAgICAgICAgY29uc3QgciA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgc2xvZyhcclxuICAgICAgICAgICAgXCJbVFJdIGxpdmVcIixcclxuICAgICAgICAgICAgYGlkPSR7aWR9YCxcclxuICAgICAgICAgICAgYHRpcG89JHtwcmltZXJFbGVtZW50bz8udGlwbyB8fCBcIuKIhVwifWAsXHJcbiAgICAgICAgICAgIGBzeD0ke3N4LnRvRml4ZWQoMyl9YCxcclxuICAgICAgICAgICAgYHN5PSR7c3kudG9GaXhlZCgzKX1gLFxyXG4gICAgICAgICAgICBgeD0keyhub2RlLng/LigpID8/IDApLnRvRml4ZWQoMSl9YCxcclxuICAgICAgICAgICAgYHk9JHsobm9kZS55Py4oKSA/PyAwKS50b0ZpeGVkKDEpfWAsXHJcbiAgICAgICAgICAgIGBub2RlUmVjdCh3PSR7ci53aWR0aC50b0ZpeGVkKDEpfSxoPSR7ci5oZWlnaHQudG9GaXhlZCgxKX0pYCxcclxuICAgICAgICAgICAgYHc9JHt0cmFuc2Zvcm1EYXRhLndpZHRoID8/IFwi4oiFXCJ9YCxcclxuICAgICAgICAgICAgYGg9JHt0cmFuc2Zvcm1EYXRhLmhlaWdodCA/PyBcIuKIhVwifWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGVuIG9uVHJhbnNmb3JtOlwiLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9fVxyXG4gICAgICBvblRyYW5zZm9ybUVuZD17KGUpID0+IHtcclxuICAgICAgICBjb25zdCBpbnRlcmFjdGlvblNuYXBzaG90ID0ge1xyXG4gICAgICAgICAgaXNSb3RhdGU6IEJvb2xlYW4odHJhbnNmb3JtR2VzdHVyZVJlZi5jdXJyZW50Py5pc1JvdGF0ZSksXHJcbiAgICAgICAgICBhY3RpdmVBbmNob3I6IHRyYW5zZm9ybUdlc3R1cmVSZWYuY3VycmVudD8uYWN0aXZlQW5jaG9yID8/IG51bGwsXHJcbiAgICAgICAgICBwb2ludGVyVHlwZTogZT8uZXZ0Py5wb2ludGVyVHlwZSA/PyBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgbm90aWZ5VHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIG9uVHJhbnNmb3JtSW50ZXJhY3Rpb25FbmQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBvblRyYW5zZm9ybUludGVyYWN0aW9uRW5kKGludGVyYWN0aW9uU25hcHNob3QpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdHJhbnNmb3JtR2VzdHVyZVJlZi5jdXJyZW50ID0ge1xyXG4gICAgICAgICAgICBpc1JvdGF0ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFjdGl2ZUFuY2hvcjogbnVsbCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICghdHJhbnNmb3JtZXJSZWYuY3VycmVudCB8fCAhb25UcmFuc2Zvcm0pIHJldHVybjtcclxuXHJcbiAgICAgICAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICBjb25zdCBub2RlcyA9IHR5cGVvZiB0ci5ub2RlcyA9PT0gXCJmdW5jdGlvblwiID8gdHIubm9kZXMoKSB8fCBbXSA6IFtdO1xyXG5cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gTVVMVEktU0VMRUNDScOTTlxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdFNjYWxlWCA9IHR5cGVvZiB0ci5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IHRyLnNjYWxlWCgpIHx8IDEgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCB0U2NhbGVZID0gdHlwZW9mIHRyLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gdHIuc2NhbGVZKCkgfHwgMSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2ZyA9IChNYXRoLmFicyh0U2NhbGVYKSArIE1hdGguYWJzKHRTY2FsZVkpKSAvIDI7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVzID0gbm9kZXNcclxuICAgICAgICAgICAgICAubWFwKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgaWQgPSAodHlwZW9mIG4uaWQgPT09IFwiZnVuY3Rpb25cIiA/IG4uaWQoKSA6IG4uYXR0cnM/LmlkKSB8fCBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7IH1cclxuICAgICAgICAgICAgICAgIGlmICghaWQpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IChvYmpldG9zIHx8IFtdKS5maW5kKChvKSA9PiBvLmlkID09PSBpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkID0ge1xyXG4gICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgeDogdHlwZW9mIG4ueCA9PT0gXCJmdW5jdGlvblwiID8gbi54KCkgOiBvYmoueCxcclxuICAgICAgICAgICAgICAgICAgeTogdHlwZW9mIG4ueSA9PT0gXCJmdW5jdGlvblwiID8gbi55KCkgOiBvYmoueSxcclxuICAgICAgICAgICAgICAgICAgcm90YXRpb246IHR5cGVvZiBuLnJvdGF0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBuLnJvdGF0aW9uKCkgfHwgMCA6IChvYmoucm90YXRpb24gfHwgMCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJ0ZXh0b1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBvYmouZm9udFNpemUgfHwgMjQ7XHJcbiAgICAgICAgICAgICAgICAgIHVwZC5mb250U2l6ZSA9IE1hdGgubWF4KDYsIE1hdGgucm91bmQoYmFzZSAqIGF2ZykpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG4uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwiY2lyY2xlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVIgPSBvYmoucmFkaXVzIHx8IDUwO1xyXG4gICAgICAgICAgICAgICAgICB1cGQucmFkaXVzID0gYmFzZVIgKiBhdmc7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVZKDEpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJ0cmlhbmdsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VSID0gb2JqLnJhZGl1cyB8fCA2MDtcclxuICAgICAgICAgICAgICAgICAgdXBkLnJhZGl1cyA9IE1hdGgubWF4KDEsIGJhc2VSICogYXZnKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwiY291bnRkb3duXCIpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY291bnRkb3duU2l6ZSA9IGdldENvdW50ZG93blNjYWxlZFNpemUobik7XHJcbiAgICAgICAgICAgICAgICAgIHVwZC53aWR0aCA9IGNvdW50ZG93blNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgIHVwZC5oZWlnaHQgPSBjb3VudGRvd25TaXplLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVyA9XHJcbiAgICAgICAgICAgICAgICAgIG9iai53aWR0aCAhPSBudWxsID8gb2JqLndpZHRoIDogKHR5cGVvZiBuLndpZHRoID09PSBcImZ1bmN0aW9uXCIgPyBuLndpZHRoKCkgOiAxMDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUggPVxyXG4gICAgICAgICAgICAgICAgICBvYmouaGVpZ2h0ICE9IG51bGwgPyBvYmouaGVpZ2h0IDogKHR5cGVvZiBuLmhlaWdodCA9PT0gXCJmdW5jdGlvblwiID8gbi5oZWlnaHQoKSA6IDEwMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkLndpZHRoID0gTWF0aC5hYnMoYmFzZVcgKiB0U2NhbGVYKTtcclxuICAgICAgICAgICAgICAgIHVwZC5oZWlnaHQgPSBNYXRoLmFicyhiYXNlSCAqIHRTY2FsZVkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtKHsgaXNGaW5hbDogdHJ1ZSwgYmF0Y2g6IHVwZGF0ZXMgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRyLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgdHIuc2NhbGVYKDEpO1xyXG4gICAgICAgICAgICAgIHRyLnNjYWxlWSgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ci5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IHsgaXNSZXNpemluZzogZmFsc2UgfTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgfSwgMTAwKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBlbiBvblRyYW5zZm9ybUVuZCAobXVsdGkpOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gU0lOR0xFLVNFTEVDQ0nDk05cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdO1xyXG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBwb3NlID0gZ2V0VHJhbnNmb3JtUG9zZShub2RlKTtcclxuICAgICAgICBjb25zdCBmaW5hbERhdGEgPSB7XHJcbiAgICAgICAgICAgIHg6IHBvc2UueCxcclxuICAgICAgICAgICAgeTogcG9zZS55LFxyXG4gICAgICAgICAgICByb3RhdGlvbjogcG9zZS5yb3RhdGlvbixcclxuICAgICAgICAgICAgaXNGaW5hbDogdHJ1ZSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBsZXQgdGV4dFByZXZpZXdFbmRTbmFwc2hvdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgaWYgKGVzVGV4dG8pIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHByaW1lckVsZW1lbnRvLmZvbnRTaXplIHx8IDI0O1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVkgPSB0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3JEYXRhID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50IHx8IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VGb250U2l6ZSA9XHJcbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmJhc2VGb250U2l6ZSkgJiZcclxuICAgICAgICAgICAgICBhbmNob3JEYXRhLmJhc2VGb250U2l6ZSA+IDBcclxuICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5iYXNlRm9udFNpemVcclxuICAgICAgICAgICAgICAgIDogb3JpZ2luYWxGb250U2l6ZTtcclxuICAgICAgICAgICAgY29uc3QgYXZnU2NhbGUgPSAoTWF0aC5hYnMoc2NhbGVYKSArIE1hdGguYWJzKHNjYWxlWSkpIC8gMjtcclxuICAgICAgICAgICAgbGV0IHNjYWxlRnJvbVJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgdmlzdWFsV2lkdGhGcm9tUmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSb3RhdGlvbiA9XHJcbiAgICAgICAgICAgICAgdHlwZW9mIG5vZGUucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnJvdGF0aW9uKCkgfHwgMCkgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlUm90YXRpb24gPSBOdW1iZXIoYW5jaG9yRGF0YT8uYmFzZVJvdGF0aW9uKTtcclxuICAgICAgICAgICAgY29uc3Qgcm90YXRpb25EZWx0YSA9IE51bWJlci5pc0Zpbml0ZShiYXNlUm90YXRpb24pXHJcbiAgICAgICAgICAgICAgPyBNYXRoLmFicyhjdXJyZW50Um90YXRpb24gLSBiYXNlUm90YXRpb24pXHJcbiAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJiByZWN0LndpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmlzdWFsV2lkdGhGcm9tUmVjdCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VXaWR0aCA9IE51bWJlcihhbmNob3JEYXRhPy5iYXNlV2lkdGgpO1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShiYXNlV2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICBiYXNlV2lkdGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID4gMFxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCA9IHJlY3Qud2lkdGggLyBiYXNlV2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgIGNvbnN0IGNhblVzZVJlY3RTY2FsZSA9IHJvdGF0aW9uRGVsdGEgPCAwLjE7XHJcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVNjYWxlID1cclxuICAgICAgICAgICAgICBjYW5Vc2VSZWN0U2NhbGUgJiYgTnVtYmVyLmlzRmluaXRlKHNjYWxlRnJvbVJlY3QpICYmIHNjYWxlRnJvbVJlY3QgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHNjYWxlRnJvbVJlY3RcclxuICAgICAgICAgICAgICAgIDogYXZnU2NhbGU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgNixcclxuICAgICAgICAgICAgICBOdW1iZXIoKGJhc2VGb250U2l6ZSAqIGVmZmVjdGl2ZVNjYWxlKS50b0ZpeGVkKDMpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBmaW5hbERhdGEuZm9udFNpemUgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgICA2LFxyXG4gICAgICAgICAgICAgIE51bWJlcihcclxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5sYXN0UHJldmlld0ZvbnRTaXplKSAmJlxyXG4gICAgICAgICAgICAgICAgICBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Rm9udFNpemUgPiAwXHJcbiAgICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5sYXN0UHJldmlld0ZvbnRTaXplXHJcbiAgICAgICAgICAgICAgICAgIDogY29tcHV0ZWRGb250U2l6ZVxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICBpZiAoY2FuVXNlUmVjdFNjYWxlICYmIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy55KSkge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS55ID0gYW5jaG9yRGF0YS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdDZW50ZXJYKSkge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA9IGFuY2hvckRhdGEubGFzdFByZXZpZXdDZW50ZXJYO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5jZW50ZXJYKSkge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA9IGFuY2hvckRhdGEuY2VudGVyWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3Q2VudGVyWSkpIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclkgPSBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Q2VudGVyWTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8uY2VudGVyWSkpIHtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclkgPSBhbmNob3JEYXRhLmNlbnRlclk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmlzdWFsV2lkdGggPVxyXG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5sYXN0UHJldmlld1Zpc3VhbFdpZHRoKSAmJlxyXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEubGFzdFByZXZpZXdWaXN1YWxXaWR0aCA+IDBcclxuICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5sYXN0UHJldmlld1Zpc3VhbFdpZHRoXHJcbiAgICAgICAgICAgICAgICA6IHZpc3VhbFdpZHRoRnJvbVJlY3Q7XHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmlzdWFsV2lkdGgpICYmIHZpc3VhbFdpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0VmlzdWFsV2lkdGggPSB2aXN1YWxXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0UHJldmlld0VuZFNuYXBzaG90ID0ge1xyXG4gICAgICAgICAgICAgIGlkOiBwcmltZXJFbGVtZW50bz8uaWQgPz8gbnVsbCxcclxuICAgICAgICAgICAgICB4OiB0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIHk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgc2NhbGVYLFxyXG4gICAgICAgICAgICAgIHNjYWxlWSxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogdHlwZW9mIG5vZGU/LmZvbnRTaXplID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLmZvbnRTaXplKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgIHJlY3RXaWR0aDogTnVtYmVyLmlzRmluaXRlKHZpc3VhbFdpZHRoRnJvbVJlY3QpID8gdmlzdWFsV2lkdGhGcm9tUmVjdCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgcmVjdEhlaWdodDogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCByZWN0Rm9yU25hcHNob3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3RGb3JTbmFwc2hvdD8uaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0ID0gcmVjdEZvclNuYXBzaG90LmhlaWdodDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgVFhUREJHKFwiZW5kXCIsIHtcclxuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgc2NhbGVYLFxyXG4gICAgICAgICAgICAgIHNjYWxlWSxcclxuICAgICAgICAgICAgICBhdmdTY2FsZSxcclxuICAgICAgICAgICAgICBzY2FsZUZyb21SZWN0LFxyXG4gICAgICAgICAgICAgIGVmZmVjdGl2ZVNjYWxlLFxyXG4gICAgICAgICAgICAgIGNvbXB1dGVkRm9udFNpemUsXHJcbiAgICAgICAgICAgICAgZmluYWxGb250U2l6ZTogZmluYWxEYXRhLmZvbnRTaXplLFxyXG4gICAgICAgICAgICAgIHRleHRDZW50ZXJYOiBmaW5hbERhdGEudGV4dENlbnRlclggPz8gbnVsbCxcclxuICAgICAgICAgICAgICB0ZXh0Q2VudGVyWTogZmluYWxEYXRhLnRleHRDZW50ZXJZID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgdGV4dFZpc3VhbFdpZHRoOiBmaW5hbERhdGEudGV4dFZpc3VhbFdpZHRoID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgbm9kZVJlY3RXaWR0aDogdmlzdWFsV2lkdGhGcm9tUmVjdCxcclxuICAgICAgICAgICAgICBub2RlWDogdHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICBub2RlWTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcGxhbmFyIGVzY2FsYSBkZWwgdGV4dG8gZW4gZWwgcmVsZWFzZSBwYXJhIGV2aXRhciBkb2JsZSBlc2NhbGFkb1xyXG4gICAgICAgICAgICAvLyAoZXNjYWxhIGRlbCBub2RvICsgZm9udFNpemUgcGVyc2lzdGlkbykuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSBub2RlLnNjYWxlWCgxKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIpIG5vZGUuc2NhbGVZKDEpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmluYWxEYXRhLmZvbnRTaXplKSAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUuZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5mb250U2l6ZShmaW5hbERhdGEuZm9udFNpemUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDZW50ZXJYID0gTnVtYmVyKGZpbmFsRGF0YS50ZXh0Q2VudGVyWCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2VudGVyWSA9IE51bWJlcihmaW5hbERhdGEudGV4dENlbnRlclkpO1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIChOdW1iZXIuaXNGaW5pdGUodGFyZ2V0Q2VudGVyWCkgfHwgTnVtYmVyLmlzRmluaXRlKHRhcmdldENlbnRlclkpKSAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUueCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS55ID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZFJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZENlbnRlclggPVxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRSZWN0Py54KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRSZWN0Py53aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgID8gZmxhdHRlbmVkUmVjdC54ICsgKGZsYXR0ZW5lZFJlY3Qud2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuZWRDZW50ZXJZID1cclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkUmVjdD8ueSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkUmVjdD8uaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgPyBmbGF0dGVuZWRSZWN0LnkgKyAoZmxhdHRlbmVkUmVjdC5oZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRDZW50ZXJYKSAmJiBOdW1iZXIuaXNGaW5pdGUodGFyZ2V0Q2VudGVyWCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLngobm9kZS54KCkgKyAodGFyZ2V0Q2VudGVyWCAtIGZsYXR0ZW5lZENlbnRlclgpKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZsYXR0ZW5lZENlbnRlclkpICYmIE51bWJlci5pc0Zpbml0ZSh0YXJnZXRDZW50ZXJZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUueShub2RlLnkoKSArICh0YXJnZXRDZW50ZXJZIC0gZmxhdHRlbmVkQ2VudGVyWSkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBub2RlLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBhcGxhbmFuZG8gZXNjYWxhIGRlIHRleHRvIChzeW5jKTpcIiwgZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjYW5Vc2VSZWN0U2NhbGUpIHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgZmluYWxEYXRhLnggPSBub2RlLngoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGZpbmFsRGF0YS55ID0gbm9kZS55KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJhIHRleHRvIGV2aXRhbW9zIGFwbGFuYXIgYW50ZXMgZGVsIGNvbW1pdCBlbiBSZWFjdCxcclxuICAgICAgICAgICAgLy8gYXPDrSBubyBhcGFyZWNlIHVuIGZyYW1lIGludGVybWVkaW8gY29uIHRhbWHDsW8gXCJzYWx0YWRvXCIuXHJcbiAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZVkgPSB0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiAxO1xyXG4gICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiY291bnRkb3duXCIpIHtcclxuICAgICAgICAgICAgICAvLyBDb3VudGRvd246IHBlcnNpc3RpciBlc2NhbGEgcmVhbCBwYXJhIHF1ZSBlbCByZXN1bHRhZG8gZmluYWxcclxuICAgICAgICAgICAgICAvLyBzZWEgZXhhY3RhbWVudGUgZWwgbWlzbW8gcXVlIHNlIHZlIGFsIHNvbHRhci5cclxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVkgPSBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY291bnRkb3duU2l6ZSA9IGdldENvdW50ZG93blNjYWxlZFNpemUobm9kZSk7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLndpZHRoID0gY291bnRkb3duU2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICBmaW5hbERhdGEuaGVpZ2h0ID0gY291bnRkb3duU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXNUcmlhbmd1bG8pIHtcclxuICAgICAgICAgICAgICBjb25zdCBiYXNlUmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKHByaW1lckVsZW1lbnRvPy5yYWRpdXMpXHJcbiAgICAgICAgICAgICAgICA/IHByaW1lckVsZW1lbnRvLnJhZGl1c1xyXG4gICAgICAgICAgICAgICAgOiA2MDtcclxuICAgICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSAxO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5yYWRpdXMgPSBNYXRoLm1heCgxLCBiYXNlUmFkaXVzICogYXZnU2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWSgxKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5yYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgbm9kZS5yYWRpdXMoZmluYWxEYXRhLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgYXBsYW5hbmRvIGVzY2FsYSBkZSB0cmnDoW5ndWxvIChzeW5jKTpcIiwgZXJyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHByaW1lckVsZW1lbnRvLndpZHRoIHx8IDEwMDtcclxuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHByaW1lckVsZW1lbnRvLmhlaWdodCB8fCAxMDA7XHJcblxyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS53aWR0aCA9IE1hdGguYWJzKG9yaWdpbmFsV2lkdGggKiBzY2FsZVgpO1xyXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5oZWlnaHQgPSBNYXRoLmFicyhvcmlnaW5hbEhlaWdodCAqIHNjYWxlWSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBsaXZlUmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgZGlhbWV0ZXIgPSBNYXRoLm1heCgxLCBNYXRoLm1heChsaXZlUmVjdC53aWR0aCwgbGl2ZVJlY3QuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS5yYWRpdXMgPSBkaWFtZXRlciAvIDI7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGNpcmNsZUFuY2hvclJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnggPSBhbmNob3IubGVmdCArIGZpbmFsRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnkgPSBhbmNob3IudG9wICsgZmluYWxEYXRhLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueCA9IGxpdmVSZWN0LnggKyBmaW5hbERhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS55ID0gbGl2ZVJlY3QueSArIGZpbmFsRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIOKchSBBcGxhbmFyIGVzY2FsYSBJTk1FRElBVE9cclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZncgPSBmaW5hbERhdGEud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaCA9IGZpbmFsRGF0YS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgbm9kZS5zY2FsZVgoMSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWSgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZncgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZS53aWR0aCA9PT0gXCJmdW5jdGlvblwiKSBub2RlLndpZHRoKGZ3KTtcclxuICAgICAgICAgICAgICAgIGlmIChmaCAhPSBudWxsICYmIHR5cGVvZiBub2RlLmhlaWdodCA9PT0gXCJmdW5jdGlvblwiKSBub2RlLmhlaWdodChmaCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiICYmXHJcbiAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS5yYWRpdXMgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5yYWRpdXMgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5vZGUucmFkaXVzKGZpbmFsRGF0YS5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBhcGxhbmFuZG8gZXNjYWxhcyAoc3luYyk6XCIsIGVycik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgb25UcmFuc2Zvcm0oZmluYWxEYXRhKTtcclxuICAgICAgICAgIGNpcmNsZUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcclxuXHJcblxyXG4gICAgICAgICAgLy8g4pyFIFJlYXRhY2hhciAxIHZleiwgY29uIHJlZiBmcmVzY28sIGVuIGVsIHByw7N4aW1vIGZyYW1lXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB0cjIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICBpZiAoIXRyMikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCAtPiBzY2hlZHVsZSBSQUYgcmVhdHRhY2hcIiwge1xyXG4gICAgICAgICAgICAgIHNlbEtleTogc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcclxuICAgICAgICAgICAgICBpZFNlbDogc2VsZWN0ZWRFbGVtZW50cz8uWzBdIHx8IG51bGxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGlkU2VsID0gc2VsZWN0ZWRFbGVtZW50cz8uWzBdO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGZyZXNoTm9kZSA9IGlkU2VsID8gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkU2VsXSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgIFRSREJHKFwib25UcmFuc2Zvcm1FbmQgUkFGXCIsIHtcclxuICAgICAgICAgICAgICAgIGlkU2VsLFxyXG4gICAgICAgICAgICAgICAgaGFzRnJlc2g6ICEhZnJlc2hOb2RlLFxyXG4gICAgICAgICAgICAgICAgZGVzdHJveWVkOiAhIWZyZXNoTm9kZT8uX2Rlc3Ryb3llZCxcclxuICAgICAgICAgICAgICAgIGhhc1N0YWdlOiAhIWZyZXNoTm9kZT8uZ2V0U3RhZ2U/LigpLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTaSBlbCBub2RvIG5vIGVzdMOhIGxpc3RvLCBkZXNwZWdhciB5IHNhbGlyXHJcbiAgICAgICAgICAgICAgaWYgKCFmcmVzaE5vZGUgfHwgZnJlc2hOb2RlLl9kZXN0cm95ZWQgfHwgIWZyZXNoTm9kZS5nZXRTdGFnZT8uKCkpIHtcclxuICAgICAgICAgICAgICAgIFRSREJHKFwib25UcmFuc2Zvcm1FbmQgUkFGIC0+IERFVEFDSCBub2RlcyhbXSlcIiwgeyBpZFNlbCB9KTtcclxuICAgICAgICAgICAgICAgIHRyeSB7IHRyMi5ub2RlcyhbXSk7IHRyMi5nZXRMYXllcj8uKCk/LmJhdGNoRHJhdygpOyB9IGNhdGNoIHsgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIFRSREJHKFwib25UcmFuc2Zvcm1FbmQgUkFGIC0+IERFVEFDSCBub2RlcyhbXSlcIiwgeyBpZFNlbCB9KTtcclxuICAgICAgICAgICAgICAgIHRyMi5ub2RlcyhbZnJlc2hOb2RlXSk7XHJcbiAgICAgICAgICAgICAgICB0cjIuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRyMi5nZXRMYXllcj8uKCk/LmJhdGNoRHJhdygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0UHJldmlld0VuZFNuYXBzaG90ICYmIGZyZXNoTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RSZWN0ID0gZnJlc2hOb2RlLmdldENsaWVudFJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBUWFREQkcoXCJwb3N0LWNvbW1pdDpyYWYxXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFNlbCxcclxuICAgICAgICAgICAgICAgICAgICAgIHByZTogdGV4dFByZXZpZXdFbmRTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgIHBvc3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogdHlwZW9mIGZyZXNoTm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLngoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHR5cGVvZiBmcmVzaE5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS55KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVg6IHR5cGVvZiBmcmVzaE5vZGU/LnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLnNjYWxlWCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZOiB0eXBlb2YgZnJlc2hOb2RlPy5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS5zY2FsZVkoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0eXBlb2YgZnJlc2hOb2RlPy5mb250U2l6ZSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLmZvbnRTaXplKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2lkdGg6IE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8ud2lkdGgpID8gcG9zdFJlY3Qud2lkdGggOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0SGVpZ2h0OiBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LmhlaWdodCkgPyBwb3N0UmVjdC5oZWlnaHQgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8ud2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3Qud2lkdGggLSB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8uaGVpZ2h0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChwb3N0UmVjdC5oZWlnaHQgLSB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIHt9XHJcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJlc2hOb2RlMiA9IGlkU2VsID8gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkU2VsXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmVzaE5vZGUyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RSZWN0MiA9IGZyZXNoTm9kZTIuZ2V0Q2xpZW50UmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBUWFREQkcoXCJwb3N0LWNvbW1pdDpyYWYyXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkU2VsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdHlwZW9mIGZyZXNoTm9kZTI/LnggPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZTIueCgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0eXBlb2YgZnJlc2hOb2RlMj8ueSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi55KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWDogdHlwZW9mIGZyZXNoTm9kZTI/LnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi5zY2FsZVgoKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZOiB0eXBlb2YgZnJlc2hOb2RlMj8uc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLnNjYWxlWSgpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogdHlwZW9mIGZyZXNoTm9kZTI/LmZvbnRTaXplID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLmZvbnRTaXplKCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaWR0aDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Mj8ud2lkdGgpID8gcG9zdFJlY3QyLndpZHRoIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0SGVpZ2h0OiBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3QyPy5oZWlnaHQpID8gcG9zdFJlY3QyLmhlaWdodCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhRnJvbVByZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Mj8ud2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKHBvc3RSZWN0Mi53aWR0aCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Mj8uaGVpZ2h0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3QyLmhlaWdodCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIHsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggeyB9XHJcblxyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZW4gb25UcmFuc2Zvcm1FbmQ6XCIsIGVycm9yKTtcclxuICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IG51bGw7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlzVHJhbnNmb3JtaW5nUmVzaXplUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgIHNldElzUmVzaXplR2VzdHVyZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgICBjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2soKTtcclxuICAgICAgICAgIG5vdGlmeVRyYW5zZm9ybUludGVyYWN0aW9uRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9fVxyXG5cclxuICAgIC8+XHJcbiAgKTtcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiVHJhbnNmb3JtZXIiLCJSZWN0IiwiREVCVUdfU0VMRUNUSU9OX0JPVU5EUyIsInNiTG9nIiwiYXJncyIsImNvbnNvbGUiLCJsb2ciLCJzbG9nIiwiVFJEQkciLCJ3aW5kb3ciLCJfX0RCR19UUiIsIlRYVERCRyIsIl9fREJHX1RFWFRfUkVTSVpFIiwicmVjdEZyb21Ob2RlcyIsIm5vZGVzIiwibWluWCIsIkluZmluaXR5IiwibWluWSIsIm1heFgiLCJtYXhZIiwibiIsImdldENsaWVudFJlY3QiLCJyIiwic2tpcFRyYW5zZm9ybSIsInNraXBTaGFkb3ciLCJza2lwU3Ryb2tlIiwiTWF0aCIsIm1pbiIsIngiLCJ5IiwibWF4Iiwid2lkdGgiLCJoZWlnaHQiLCJnZXRDb3VudGRvd25TY2FsZWRTaXplIiwibm9kZSIsImhpdGJveCIsImZpbmRPbmUiLCJiYXNlVyIsIk5hTiIsImJhc2VIIiwic3giLCJhYnMiLCJzY2FsZVgiLCJzeSIsInNjYWxlWSIsIk51bWJlciIsImlzRmluaXRlIiwiQm91bmRzSW5kaWNhdG9yIiwic2VsZWN0ZWRFbGVtZW50cyIsImVsZW1lbnRSZWZzIiwib2JqZXRvcyIsImZvcmNlVXBkYXRlIiwic2V0Rm9yY2VVcGRhdGUiLCJmaXJzdFJlZiIsImN1cnJlbnQiLCJzdGFnZSIsImdldFN0YWdlIiwiaGFuZGxlRHJhZ01vdmUiLCJwIiwib24iLCJvZmYiLCJqb2luIiwiZWxlbWVudG9zRGF0YSIsIm1hcCIsImlkIiwiZmluZCIsIm9iaiIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJmb3JFYWNoIiwidGlwbyIsImZpZ3VyYSIsInBvaW50cyIsImNsZWFuUG9pbnRzIiwicGFyc2VGbG9hdCIsInJlYWxYIiwicmVhbFkiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbmVQYWRkaW5nIiwiYm94IiwidG9GaXhlZCIsImdldFRleHRIZWlnaHQiLCJ0ZXh0SGVpZ2h0IiwiZXJyb3IiLCJmYWxsYmFja1giLCJmYWxsYmFja1kiLCJmYWxsYmFja1NpemUiLCJwcmltZXJFbGVtZW50byIsInBhZGRpbmciLCJmaW5hbFgiLCJmaW5hbFkiLCJmaW5hbFdpZHRoIiwiZmluYWxIZWlnaHQiLCJuYW1lIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwibGlzdGVuaW5nIiwib3BhY2l0eSIsIlNlbGVjdGlvbkJvdW5kcyIsIm9uVHJhbnNmb3JtIiwib25UcmFuc2Zvcm1JbnRlcmFjdGlvblN0YXJ0Iiwib25UcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCIsImlzRHJhZ2dpbmciLCJpc01vYmlsZSIsInRyYW5zZm9ybWVyUmVmIiwidHJhbnNmb3JtVGljayIsInNldFRyYW5zZm9ybVRpY2siLCJsYXN0Tm9kZXNSZWYiLCJjaXJjbGVBbmNob3JSZWYiLCJ0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmIiwidHJhbnNmb3JtR2VzdHVyZVJlZiIsImlzUm90YXRlIiwiYWN0aXZlQW5jaG9yIiwiaXNUcmFuc2Zvcm1pbmdSZXNpemVSZWYiLCJpc1Jlc2l6ZUdlc3R1cmVBY3RpdmUiLCJzZXRJc1Jlc2l6ZUdlc3R1cmVBY3RpdmUiLCJwcmVzc2VkUmVzaXplQW5jaG9yTmFtZSIsInNldFByZXNzZWRSZXNpemVBbmNob3JOYW1lIiwiZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEiLCJlc1RleHRvIiwiZXNDb3VudGRvd24iLCJlc0dhbGVyaWEiLCJsb2NrQXNwZWN0Q291bnRkb3duIiwibG9ja0FzcGVjdFRleHQiLCJ0cmFuc2Zvcm1lckFuY2hvclNpemUiLCJ0cmFuc2Zvcm1lclJvdGF0ZU9mZnNldCIsInRyYW5zZm9ybWVyQW5jaG9yUmFkaXVzIiwidHJhbnNmb3JtZXJQYWRkaW5nIiwidHJhbnNmb3JtZXJCb3JkZXJTdHJva2VXaWR0aCIsInRyYW5zZm9ybWVyQW5jaG9yRmlsbENvbG9yIiwidHJhbnNmb3JtZXJBbmNob3JTdHJva2VXaWR0aCIsInRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Qmx1ciIsInRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSIsInRyYW5zZm9ybWVyQW5jaG9ySGl0U3Ryb2tlV2lkdGgiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIaXRTdHJva2VXaWR0aCIsInRyYW5zZm9ybWVyQW5jaG9yU3Ryb2tlQ29sb3IiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIYWxvU3Ryb2tlQ29sb3IiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRIYWxvU3Ryb2tlV2lkdGgiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRDb3JlQ29sb3IiLCJ0cmFuc2Zvcm1lckFuY2hvclNoYWRvd0NvbG9yIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93Q29sb3IiLCJ0cmFuc2Zvcm1lckFuY2hvclByZXNzZWRTaGFkb3dCbHVyIiwidHJhbnNmb3JtZXJBbmNob3JQcmVzc2VkU2hhZG93T2Zmc2V0WSIsInRyYW5zZm9ybWVyQW5jaG9yUHJlc3NlZFNjYWxlIiwidHJhbnNmb3JtZXJSb3RhdGlvblNuYXBUb2xlcmFuY2UiLCJlc1RyaWFuZ3VsbyIsImhhc0dhbGxlcnkiLCJzb21lIiwibyIsImhheUxpbmVhcyIsImVsZW1lbnRvc1RyYW5zZm9ybWFibGVzIiwiZGViZXJpYVVzYXJUcmFuc2Zvcm1lciIsInNlbGVjdGVkR2VvbUtleSIsInJvdGF0aW9uIiwiY2hpcFdpZHRoIiwiZ2FwIiwicGFkZGluZ1giLCJwYWRkaW5nWSIsImdldFRyYW5zZm9ybVBvc2UiLCJnZXRQYXJlbnQiLCJwYXJlbnQiLCJjbGVhclJlc2l6ZUFuY2hvclByZXNzRmVlZGJhY2siLCJnZXRSZXNpemVBbmNob3JOYW1lRnJvbVRhcmdldCIsInRhcmdldCIsImlzQW5jaG9yVGFyZ2V0IiwiaGFzTmFtZSIsIlN0cmluZyIsImluY2x1ZGVzIiwicmF3TmFtZSIsImFuY2hvck5hbWUiLCJzcGxpdCIsInRvTG93ZXJDYXNlIiwiaGFuZGxlUmVzaXplQW5jaG9yUHJlc3NTdGFydCIsImV2ZW50IiwiZ2V0QWN0aXZlQW5jaG9yIiwiZ2V0Qm94T3ZlcmZsb3dBbW91bnQiLCJzdGFnZVdpZHRoIiwic3RhZ2VIZWlnaHQiLCJQT1NJVElWRV9JTkZJTklUWSIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsIm92ZXJmbG93TGVmdCIsIm92ZXJmbG93VG9wIiwib3ZlcmZsb3dSaWdodCIsIm92ZXJmbG93Qm90dG9tIiwia2VlcEJveEluc2lkZVN0YWdlIiwib2xkQm94IiwibmV4dEJveCIsInRyIiwiYXR0cnMiLCJvbGRPdmVyZmxvdyIsIm5leHRPdmVyZmxvdyIsImVwc2lsb24iLCJzZWxLZXkiLCJlbGVtZW50b3NUcmFuc2Zvcm1hYmxlc0xlbiIsImVkaXRpbmdJZCIsImVkaXRpbmciLCJub2Rvc1RyYW5zZm9ybWFibGVzIiwiaWRTZWwiLCJyZWZOb2RlIiwiZ2FsbGVyeUZyYW1lIiwid2FudGVkSWRzIiwicmVmc1ByZXNlbnQiLCJub2Rlc0NvdW50Iiwibm9kZUlkcyIsInRyTm9kZXNDb3VudCIsImdldExheWVyIiwiYmF0Y2hEcmF3IiwiaGFuZGxlciIsImUiLCJkZXRhaWwiLCJpc1NlbGVjdGVkIiwidCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZmlyc3ROb2RlIiwiZmlyc3RJZCIsInJhZklkIiwic3luY1RyYW5zZm9ybWVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZWYiLCJib3JkZXJFbmFibGVkIiwiYm9yZGVyU3Ryb2tlIiwiYm9yZGVyU3Ryb2tlV2lkdGgiLCJlbmFibGVkQW5jaG9ycyIsInJvdGF0ZUVuYWJsZWQiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsIm9uUG9pbnRlckRvd24iLCJvbk1vdXNlVXAiLCJvblRvdWNoRW5kIiwib25Qb2ludGVyVXAiLCJvblRvdWNoQ2FuY2VsIiwib25Qb2ludGVyQ2FuY2VsIiwiYW5jaG9yRmlsbCIsImFuY2hvclN0cm9rZSIsImFuY2hvclN0cm9rZVdpZHRoIiwiYW5jaG9yU2l6ZSIsImFuY2hvckNvcm5lclJhZGl1cyIsImFuY2hvclNoYWRvd0NvbG9yIiwiYW5jaG9yU2hhZG93Qmx1ciIsImFuY2hvclNoYWRvd09mZnNldCIsImFuY2hvclN0eWxlRnVuYyIsImFuY2hvciIsImlzUmVzaXplQW5jaG9yTm9kZSIsImlzUmVzaXplQWN0aXZlRmFsbGJhY2siLCJfcmVzaXplRGF0YSIsImlzUmVzaXppbmciLCJpc1ByZXNzZWRSZXNpemVBbmNob3IiLCJzaGFkb3dDb2xvciIsInNoYWRvd0VuYWJsZWQiLCJzaGFkb3dGb3JTdHJva2VFbmFibGVkIiwic2hhZG93T3BhY2l0eSIsInNoYWRvd0JsdXIiLCJzaGFkb3dPZmZzZXQiLCJoaXRTdHJva2VXaWR0aCIsImFuY2hvclNjYWxlIiwic2NhbGUiLCJrZWVwUmF0aW8iLCJjZW50ZXJlZFNjYWxpbmciLCJmbGlwRW5hYmxlZCIsInJlc2l6ZUVuYWJsZWQiLCJyb3RhdGlvblNuYXBzIiwicm90YXRlQW5jaG9yT2Zmc2V0Iiwicm90YXRpb25TbmFwVG9sZXJhbmNlIiwiYm91bmRCb3hGdW5jIiwibmV3Qm94IiwibWluU2l6ZSIsIm1heFNpemUiLCJyb3dzIiwiY29scyIsImNlbGxSYXRpbyIsInJhdGlvIiwibWluR3JpZFdpZHRoIiwibmV4dFdpZHRoIiwiY2VsbFciLCJjZWxsSCIsIm5leHRIZWlnaHQiLCJkdyIsImRoIiwic2l6ZSIsImZpbmFsU2l6ZSIsInNhZmVPbGRXIiwic2FmZU9sZEgiLCJ1bmlmb3JtU2NhbGUiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsIm9uVHJhbnNmb3JtU3RhcnQiLCJpc1JvdGF0ZUdlc3R1cmUiLCJwb2ludGVyVHlwZSIsImV2dCIsInIwIiwiY2VudGVyWCIsImNlbnRlclkiLCJiYXNlV2lkdGgiLCJiYXNlSGVpZ2h0IiwiYmFzZVZpc3VhbFdpZHRoIiwicmVjdCIsInNhZmVCYXNlRm9udFNpemUiLCJmb250U2l6ZSIsImJhc2VSb3RhdGlvbiIsImJhc2VGb250U2l6ZSIsImxhc3RQcmV2aWV3Rm9udFNpemUiLCJsYXN0UHJldmlld0NlbnRlclgiLCJsYXN0UHJldmlld0NlbnRlclkiLCJsYXN0UHJldmlld1Zpc3VhbFdpZHRoIiwicHJldmlld1RpY2siLCJub2RlWCIsIm5vZGVZIiwibm9kZVNjYWxlWCIsIm5vZGVTY2FsZVkiLCJ1bmlvbiIsInBhZCIsImJvcmRlclJlY3QiLCJ0clJlY3QiLCJwb3NlIiwidHJhbnNmb3JtRGF0YSIsImlzUHJldmlldyIsIm9yaWdpbmFsRm9udFNpemUiLCJhbmNob3JEYXRhIiwiYXZnU2NhbGUiLCJzY2FsZUZyb21SZWN0IiwibGl2ZVJlY3RXaWR0aCIsImN1cnJlbnRSb3RhdGlvbiIsInJvdGF0aW9uRGVsdGEiLCJjYW5Vc2VSZWN0U2NhbGUiLCJlZmZlY3RpdmVTY2FsZSIsInRpY2siLCJjZW50ZXJYVGFyZ2V0IiwidGV4dENlbnRlclgiLCJ0ZXh0Q2VudGVyWSIsImNvdW50ZG93blNpemUiLCJiYXNlUmFkaXVzIiwicmFkaXVzIiwib3JpZ2luYWxXaWR0aCIsIm9yaWdpbmFsSGVpZ2h0IiwibGl2ZVJlY3QiLCJkaWFtZXRlciIsIndhcm4iLCJvblRyYW5zZm9ybUVuZCIsImludGVyYWN0aW9uU25hcHNob3QiLCJub3RpZnlUcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCIsInRTY2FsZVgiLCJ0U2NhbGVZIiwiYXZnIiwidXBkYXRlcyIsInVwZCIsImJhc2UiLCJyb3VuZCIsImJhc2VSIiwiaXNGaW5hbCIsImJhdGNoIiwic2V0VGltZW91dCIsImVyciIsImZpbmFsRGF0YSIsInRleHRQcmV2aWV3RW5kU25hcHNob3QiLCJ2aXN1YWxXaWR0aEZyb21SZWN0IiwiY29tcHV0ZWRGb250U2l6ZSIsInZpc3VhbFdpZHRoIiwidGV4dFZpc3VhbFdpZHRoIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsInJlY3RGb3JTbmFwc2hvdCIsImZpbmFsRm9udFNpemUiLCJub2RlUmVjdFdpZHRoIiwidGFyZ2V0Q2VudGVyWCIsInRhcmdldENlbnRlclkiLCJmbGF0dGVuZWRSZWN0IiwiZmxhdHRlbmVkQ2VudGVyWCIsImZsYXR0ZW5lZENlbnRlclkiLCJmdyIsImZoIiwidHIyIiwiZnJlc2hOb2RlIiwiaGFzRnJlc2giLCJkZXN0cm95ZWQiLCJfZGVzdHJveWVkIiwiaGFzU3RhZ2UiLCJwb3N0UmVjdCIsInByZSIsInBvc3QiLCJkZWx0YSIsImZyZXNoTm9kZTIiLCJwb3N0UmVjdDIiLCJkZWx0YUZyb21QcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/SelectionBounds.jsx\n"));

/***/ })

});