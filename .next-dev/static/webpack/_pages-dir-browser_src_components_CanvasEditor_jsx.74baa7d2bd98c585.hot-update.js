"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/components/SelectionBounds.jsx":
/*!********************************************!*\
  !*** ./src/components/SelectionBounds.jsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectionBounds)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-konva */ \"(pages-dir-browser)/./node_modules/react-konva/es/ReactKonva.js\");\n// SelectionBounds.jsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst DEBUG_SELECTION_BOUNDS = false;\nconst sbLog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!DEBUG_SELECTION_BOUNDS) return;\n    console.log(\"[SB]\", ...args);\n};\nconst slog = sbLog;\nconst TRDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!window.__DBG_TR) return;\n    console.log(\"[TRDBG]\", ...args);\n};\n_c = TRDBG;\nconst TXTDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n    if (!window.__DBG_TEXT_RESIZE) return;\n    console.log(\"[TEXT-TR]\", ...args);\n};\n_c1 = TXTDBG;\nfunction rectFromNodes(nodes) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for (const n of nodes){\n        if (!(n === null || n === void 0 ? void 0 : n.getClientRect)) continue;\n        const r = n.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        minX = Math.min(minX, r.x);\n        minY = Math.min(minY, r.y);\n        maxX = Math.max(maxX, r.x + r.width);\n        maxY = Math.max(maxY, r.y + r.height);\n    }\n    if (minX === Infinity) return null;\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getCountdownScaledSize(node) {\n    try {\n        var _node_findOne;\n        const hitbox = node === null || node === void 0 ? void 0 : (_node_findOne = node.findOne) === null || _node_findOne === void 0 ? void 0 : _node_findOne.call(node, \".countdown-hitbox\");\n        const baseW = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.width) === \"function\" ? hitbox.width() : NaN;\n        const baseH = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.height) === \"function\" ? hitbox.height() : NaN;\n        const sx = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() || 1 : 1);\n        const sy = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() || 1 : 1);\n        if (Number.isFinite(baseW) && Number.isFinite(baseH) && baseW > 0 && baseH > 0) {\n            return {\n                width: Math.abs(baseW * sx),\n                height: Math.abs(baseH * sy)\n            };\n        }\n    } catch (e) {}\n    try {\n        const r = node.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        return {\n            width: Math.abs(r.width),\n            height: Math.abs(r.height)\n        };\n    } catch (e) {}\n    return {\n        width: 100,\n        height: 50\n    };\n}\n// ðŸŽ¨ Componente para mostrar bounds sin transformer (lÃ­neas, etc.)\nconst BoundsIndicator = (param)=>{\n    let { selectedElements, elementRefs, objetos } = param;\n    _s();\n    const [forceUpdate, setForceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"BoundsIndicator.useEffect\": ()=>{\n            var _elementRefs_current, _firstRef_getStage;\n            const firstRef = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[selectedElements[0]];\n            const stage = firstRef === null || firstRef === void 0 ? void 0 : (_firstRef_getStage = firstRef.getStage) === null || _firstRef_getStage === void 0 ? void 0 : _firstRef_getStage.call(firstRef);\n            if (!stage) return;\n            const handleDragMove = {\n                \"BoundsIndicator.useEffect.handleDragMove\": ()=>{\n                    setForceUpdate({\n                        \"BoundsIndicator.useEffect.handleDragMove\": (p)=>p + 1\n                    }[\"BoundsIndicator.useEffect.handleDragMove\"]);\n                }\n            }[\"BoundsIndicator.useEffect.handleDragMove\"];\n            stage.on(\"dragmove\", handleDragMove);\n            return ({\n                \"BoundsIndicator.useEffect\": ()=>{\n                    stage.off(\"dragmove\", handleDragMove);\n                }\n            })[\"BoundsIndicator.useEffect\"];\n        }\n    }[\"BoundsIndicator.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    const elementosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    if (elementosData.length === 0) {\n        return null;\n    }\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    elementosData.forEach((obj)=>{\n        const node = elementRefs.current[obj.id];\n        if (!node) return;\n        try {\n            if (obj.tipo === \"forma\" && obj.figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    100,\n                    0\n                ];\n                const cleanPoints = [\n                    parseFloat(points[0]) || 0,\n                    parseFloat(points[1]) || 0,\n                    parseFloat(points[2]) || 100,\n                    parseFloat(points[3]) || 0\n                ];\n                const realX = node.x();\n                const realY = node.y();\n                const x1 = realX + cleanPoints[0];\n                const y1 = realY + cleanPoints[1];\n                const x2 = realX + cleanPoints[2];\n                const y2 = realY + cleanPoints[3];\n                const linePadding = 5;\n                minX = Math.min(minX, x1 - linePadding, x2 - linePadding);\n                minY = Math.min(minY, y1 - linePadding, y2 - linePadding);\n                maxX = Math.max(maxX, x1 + linePadding, x2 + linePadding);\n                maxY = Math.max(maxY, y1 + linePadding, y2 + linePadding);\n            } else {\n                var _node_scaleX, _node_scaleY;\n                const box = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                const r = box;\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = node === null || node === void 0 ? void 0 : (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = node === null || node === void 0 ? void 0 : (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                slog(\"[BI]\", \"id=\".concat(obj.id), \"tipo=\".concat(obj.tipo), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"rect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"));\n                const realX = box.x;\n                const realY = box.y;\n                let width = box.width;\n                let height = box.height;\n                if (obj.tipo === \"texto\" && node.getTextHeight) {\n                    const textHeight = node.getTextHeight();\n                    if (textHeight) {\n                        height = textHeight;\n                    }\n                }\n                minX = Math.min(minX, realX);\n                minY = Math.min(minY, realY);\n                maxX = Math.max(maxX, realX + width);\n                maxY = Math.max(maxY, realY + height);\n            }\n        } catch (error) {\n            const fallbackX = obj.x || 0;\n            const fallbackY = obj.y || 0;\n            const fallbackSize = 20;\n            minX = Math.min(minX, fallbackX);\n            minY = Math.min(minY, fallbackY);\n            maxX = Math.max(maxX, fallbackX + fallbackSize);\n            maxY = Math.max(maxY, fallbackY + fallbackSize);\n        }\n    });\n    if (minX === Infinity || maxX === -Infinity) {\n        const primerElemento = elementosData[0];\n        if (!primerElemento) return null;\n        minX = primerElemento.x || 0;\n        minY = primerElemento.y || 0;\n        maxX = minX + 100;\n        maxY = minY + 50;\n    }\n    const padding = 10;\n    const finalX = minX - padding;\n    const finalY = minY - padding;\n    const finalWidth = maxX - minX + padding * 2;\n    const finalHeight = maxY - minY + padding * 2;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, {\n        name: \"ui\",\n        x: finalX,\n        y: finalY,\n        width: finalWidth,\n        height: finalHeight,\n        fill: \"transparent\",\n        stroke: \"#9333EA\",\n        strokeWidth: 1,\n        listening: false,\n        opacity: 0.7\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 188,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BoundsIndicator, \"X1gDcjpboC/BQr7oI4aemyzw8+o=\");\n_c2 = BoundsIndicator;\nfunction SelectionBounds(param) {\n    let { selectedElements, elementRefs, objetos, onTransform, onTransformInteractionStart = null, onTransformInteractionEnd = null, isDragging, isMobile = false } = param;\n    _s1();\n    const transformerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [transformTick, setTransformTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const lastNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const circleAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textTransformAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const transformGestureRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        isRotate: false,\n        activeAnchor: null\n    });\n    const elementosSeleccionadosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    const primerElemento = elementosSeleccionadosData[0] || null;\n    const esTexto = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"texto\";\n    const esCountdown = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\";\n    const esGaleria = selectedElements.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"galeria\";\n    const lockAspectCountdown = selectedElements.length === 1 && esCountdown;\n    const lockAspectText = selectedElements.length === 1 && esTexto;\n    const transformerAnchorSize = isMobile ? 24 : 14;\n    const transformerRotateOffset = isMobile ? 34 : 24;\n    const transformerAnchorRadius = 999;\n    const transformerPadding = isMobile ? 10 : 4;\n    const transformerBorderStrokeWidth = isMobile ? 1.5 : 1;\n    const transformerAnchorStrokeWidth = isMobile ? 3 : 2.5;\n    const transformerAnchorShadowBlur = isMobile ? 9 : 6;\n    const transformerAnchorShadowOffsetY = isMobile ? 4 : 3;\n    const transformerRotationSnapTolerance = isMobile ? 8 : 5;\n    const esTriangulo = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"triangle\";\n    const hasGallery = elementosSeleccionadosData.some((o)=>o.tipo === \"galeria\");\n    const hayLineas = elementosSeleccionadosData.some((obj)=>obj.tipo === \"forma\" && obj.figura === \"line\");\n    const elementosTransformables = elementosSeleccionadosData.filter((obj)=>!(obj.tipo === \"forma\" && obj.figura === \"line\"));\n    const deberiaUsarTransformer = elementosTransformables.length > 0;\n    const selectedGeomKey = elementosSeleccionadosData.map((o)=>{\n        var _o_x, _o_y, _o_width, _o_height, _o_scaleX, _o_scaleY, _o_rotation, _o_chipWidth, _o_gap, _o_paddingX, _o_paddingY;\n        return [\n            o.id,\n            (_o_x = o.x) !== null && _o_x !== void 0 ? _o_x : 0,\n            (_o_y = o.y) !== null && _o_y !== void 0 ? _o_y : 0,\n            (_o_width = o.width) !== null && _o_width !== void 0 ? _o_width : \"\",\n            (_o_height = o.height) !== null && _o_height !== void 0 ? _o_height : \"\",\n            (_o_scaleX = o.scaleX) !== null && _o_scaleX !== void 0 ? _o_scaleX : 1,\n            (_o_scaleY = o.scaleY) !== null && _o_scaleY !== void 0 ? _o_scaleY : 1,\n            (_o_rotation = o.rotation) !== null && _o_rotation !== void 0 ? _o_rotation : 0,\n            (_o_chipWidth = o.chipWidth) !== null && _o_chipWidth !== void 0 ? _o_chipWidth : \"\",\n            (_o_gap = o.gap) !== null && _o_gap !== void 0 ? _o_gap : \"\",\n            (_o_paddingX = o.paddingX) !== null && _o_paddingX !== void 0 ? _o_paddingX : \"\",\n            (_o_paddingY = o.paddingY) !== null && _o_paddingY !== void 0 ? _o_paddingY : \"\"\n        ].join(\":\");\n    }).join(\"|\");\n    const getTransformPose = (node)=>{\n        if (!node) return {\n            x: 0,\n            y: 0,\n            rotation: 0\n        };\n        if (esGaleria && typeof node.getParent === \"function\") {\n            const parent = node.getParent();\n            if (parent) {\n                return {\n                    x: typeof parent.x === \"function\" ? parent.x() : 0,\n                    y: typeof parent.y === \"function\" ? parent.y() : 0,\n                    rotation: typeof parent.rotation === \"function\" ? parent.rotation() || 0 : 0\n                };\n            }\n        }\n        return {\n            x: typeof node.x === \"function\" ? node.x() : 0,\n            y: typeof node.y === \"function\" ? node.y() : 0,\n            rotation: typeof node.rotation === \"function\" ? node.rotation() || 0 : 0\n        };\n    };\n    // ðŸ”¥ Efecto principal del Transformer (SIN retry / SIN flicker)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _window_editing, _tr_nodes, _tr_nodes1, _tr_getLayer;\n            const tr = transformerRef.current;\n            if (!tr) return;\n            const selKey = selectedElements.join(\",\");\n            TRDBG(\"EFFECT start\", {\n                selKey,\n                isDragging,\n                deberiaUsarTransformer,\n                hasGallery,\n                elementosTransformablesLen: elementosTransformables.length,\n                transformTick,\n                editingId: ((_window_editing = window.editing) === null || _window_editing === void 0 ? void 0 : _window_editing.id) || null\n            });\n            // Si no corresponde transformer, no hagas detach agresivo (evita flicker)\n            if (!deberiaUsarTransformer) {\n                TRDBG(\"EFFECT exit: no transformer or gallery\", {\n                    selKey\n                });\n                return;\n            }\n            // Resolver nodes desde refs (fuente de verdad)\n            let nodosTransformables = elementosTransformables.map({\n                \"SelectionBounds.useEffect.nodosTransformables\": (o)=>{\n                    var _elementRefs_current;\n                    return (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id];\n                }\n            }[\"SelectionBounds.useEffect.nodosTransformables\"]).filter(Boolean);\n            // Single select: usar ref fresco SIEMPRE\n            if (selectedElements.length === 1) {\n                var _elementRefs_current;\n                const idSel = selectedElements[0];\n                const refNode = ((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel]) || null;\n                if (refNode && typeof refNode.getClientRect === \"function\") {\n                    if (esGaleria && typeof refNode.findOne === \"function\") {\n                        const galleryFrame = refNode.findOne(\".gallery-transform-frame\");\n                        if (galleryFrame && typeof galleryFrame.getClientRect === \"function\") {\n                            nodosTransformables = [\n                                galleryFrame\n                            ];\n                        } else {\n                            nodosTransformables = [\n                                refNode\n                            ];\n                        }\n                    } else {\n                        nodosTransformables = [\n                            refNode\n                        ];\n                    }\n                }\n            }\n            // Si aÃºn no hay nodos (imagen cargando, etc.), NO despegar (evita parpadeo)\n            if (nodosTransformables.length === 0) {\n                TRDBG(\"EFFECT exit: no nodes yet\", {\n                    selKey,\n                    wantedIds: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>o.id\n                    }[\"SelectionBounds.useEffect\"]),\n                    refsPresent: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>{\n                            var _elementRefs_current;\n                            return !!((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id]);\n                        }\n                    }[\"SelectionBounds.useEffect\"])\n                });\n                return;\n            }\n            // Attach estable\n            TRDBG(\"ATTACH try\", {\n                selKey,\n                nodesCount: nodosTransformables.length,\n                nodeIds: nodosTransformables.map({\n                    \"SelectionBounds.useEffect\": (n)=>{\n                        var _n_attrs;\n                        return typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id;\n                    }\n                }[\"SelectionBounds.useEffect\"])\n            });\n            tr.nodes(nodosTransformables);\n            TRDBG(\"ATTACH done\", {\n                selKey,\n                trNodesCount: ((_tr_nodes1 = tr.nodes) === null || _tr_nodes1 === void 0 ? void 0 : (_tr_nodes = _tr_nodes1.call(tr)) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.length) || 0\n            });\n            try {\n                var _tr_forceUpdate;\n                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n            } catch (e) {}\n            (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        // Dependencias mÃ­nimas reales\n        selectedElements.join(\",\"),\n        deberiaUsarTransformer,\n        hasGallery,\n        elementosTransformables.length,\n        selectedGeomKey,\n        transformTick,\n        elementRefs\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            const handler = {\n                \"SelectionBounds.useEffect.handler\": (e)=>{\n                    var _e_detail;\n                    const id = e === null || e === void 0 ? void 0 : (_e_detail = e.detail) === null || _e_detail === void 0 ? void 0 : _e_detail.id;\n                    if (!id) return;\n                    TRDBG(\"REF event\", {\n                        id,\n                        isSelected: selectedElements.includes(id),\n                        selKey: selectedElements.join(\",\")\n                    });\n                    if (!selectedElements.includes(id)) return;\n                    setTransformTick({\n                        \"SelectionBounds.useEffect.handler\": (t)=>t + 1\n                    }[\"SelectionBounds.useEffect.handler\"]);\n                }\n            }[\"SelectionBounds.useEffect.handler\"];\n            window.addEventListener(\"element-ref-registrado\", handler);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>window.removeEventListener(\"element-ref-registrado\", handler)\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _elementRefs_current, _firstNode_getStage;\n            const firstId = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n            if (!firstId) return;\n            const firstNode = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[firstId];\n            const stage = firstNode === null || firstNode === void 0 ? void 0 : (_firstNode_getStage = firstNode.getStage) === null || _firstNode_getStage === void 0 ? void 0 : _firstNode_getStage.call(firstNode);\n            if (!stage) return;\n            let rafId = null;\n            const syncTransformer = {\n                \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                    if (rafId != null) return;\n                    rafId = requestAnimationFrame({\n                        \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                            var _tr_getLayer_batchDraw, _tr_getLayer, _tr_getLayer1;\n                            rafId = null;\n                            const tr = transformerRef.current;\n                            if (!tr) return;\n                            try {\n                                var _tr_forceUpdate;\n                                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n                            } catch (e) {}\n                            (_tr_getLayer1 = tr.getLayer) === null || _tr_getLayer1 === void 0 ? void 0 : (_tr_getLayer = _tr_getLayer1.call(tr)) === null || _tr_getLayer === void 0 ? void 0 : (_tr_getLayer_batchDraw = _tr_getLayer.batchDraw) === null || _tr_getLayer_batchDraw === void 0 ? void 0 : _tr_getLayer_batchDraw.call(_tr_getLayer);\n                        }\n                    }[\"SelectionBounds.useEffect.syncTransformer\"]);\n                }\n            }[\"SelectionBounds.useEffect.syncTransformer\"];\n            stage.on(\"dragmove\", syncTransformer);\n            stage.on(\"dragend\", syncTransformer);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>{\n                    stage.off(\"dragmove\", syncTransformer);\n                    stage.off(\"dragend\", syncTransformer);\n                    if (rafId != null) cancelAnimationFrame(rafId);\n                }\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\"),\n        elementRefs\n    ]);\n    // ðŸ”¥ Render\n    if (selectedElements.length === 0) return null;\n    if (hayLineas && elementosTransformables.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 446,\n            columnNumber: 7\n        }, this);\n    }\n    if (hayLineas && elementosTransformables.length > 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 456,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Transformer, {\n        name: \"ui\",\n        ref: transformerRef,\n        // ðŸ”µ borde siempre visible\n        borderEnabled: true,\n        borderStroke: \"#9333EA\",\n        borderStrokeWidth: transformerBorderStrokeWidth,\n        padding: transformerPadding,\n        // âŒ nodos y rotaciÃ³n OFF durante drag\n        enabledAnchors: isDragging ? [] : [\n            \"bottom-right\"\n        ],\n        rotateEnabled: !isDragging && !esGaleria,\n        anchorFill: \"#9333EA\",\n        anchorStroke: \"#ffffff\",\n        anchorStrokeWidth: transformerAnchorStrokeWidth,\n        anchorSize: transformerAnchorSize,\n        anchorCornerRadius: transformerAnchorRadius,\n        anchorShadowColor: \"rgba(147, 51, 234, 0.3)\",\n        anchorShadowBlur: transformerAnchorShadowBlur,\n        anchorShadowOffset: {\n            x: 0,\n            y: transformerAnchorShadowOffsetY\n        },\n        keepRatio: lockAspectCountdown || esGaleria || lockAspectText,\n        centeredScaling: selectedElements.length === 1 && esTexto,\n        flipEnabled: false,\n        resizeEnabled: !isDragging,\n        rotationSnaps: [\n            0,\n            45,\n            90,\n            135,\n            180,\n            225,\n            270,\n            315\n        ],\n        rotateAnchorOffset: transformerRotateOffset,\n        rotationSnapTolerance: transformerRotationSnapTolerance,\n        boundBoxFunc: (oldBox, newBox)=>{\n            const minSize = esTexto ? 20 : 10;\n            const maxSize = 800;\n            if (esGaleria) {\n                const rows = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.rows) || 1);\n                const cols = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.cols) || 1);\n                const gap = Math.max(0, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.gap) || 0);\n                const cellRatio = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"4:3\" ? 3 / 4 : (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"16:9\" ? 9 / 16 : 1;\n                const minGridWidth = gap * (cols - 1) + cols;\n                const nextWidth = Math.min(maxSize, Math.max(minSize, minGridWidth, Math.abs(newBox.width)));\n                const cellW = Math.max(1, (nextWidth - gap * (cols - 1)) / cols);\n                const cellH = cellW * cellRatio;\n                const nextHeight = rows * cellH + gap * (rows - 1);\n                return {\n                    ...newBox,\n                    width: nextWidth,\n                    height: Math.max(minSize, nextHeight)\n                };\n            }\n            if (newBox.width < minSize || newBox.height < minSize) {\n                return oldBox;\n            }\n            if (lockAspectCountdown) {\n                const baseW = Math.max(1, oldBox.width);\n                const baseH = Math.max(1, oldBox.height);\n                const ratio = baseW / baseH;\n                const dw = Math.abs(newBox.width - oldBox.width) / baseW;\n                const dh = Math.abs(newBox.height - oldBox.height) / baseH;\n                let width = newBox.width;\n                let height = newBox.height;\n                if (dh > dw) {\n                    width = height * ratio;\n                } else {\n                    height = width / ratio;\n                }\n                return {\n                    ...newBox,\n                    width: Math.min(Math.max(width, minSize), maxSize),\n                    height: Math.min(Math.max(height, minSize), maxSize)\n                };\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                const size = Math.max(newBox.width, newBox.height);\n                const finalSize = Math.min(size, maxSize);\n                return {\n                    ...newBox,\n                    width: finalSize,\n                    height: finalSize\n                };\n            }\n            if (esTriangulo) {\n                const safeOldW = Math.max(1, Math.abs(oldBox.width || minSize));\n                const safeOldH = Math.max(1, Math.abs(oldBox.height || minSize));\n                const scaleX = Math.abs(newBox.width) / safeOldW;\n                const scaleY = Math.abs(newBox.height) / safeOldH;\n                const uniformScale = Math.max(0.05, Math.min(scaleX, scaleY));\n                const width = Math.min(Math.max(safeOldW * uniformScale, minSize), maxSize);\n                const height = Math.min(Math.max(safeOldH * uniformScale, minSize), maxSize);\n                return {\n                    ...newBox,\n                    width,\n                    height\n                };\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"imagen\" || (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"icono\") {\n                const scaleX = newBox.width / oldBox.width;\n                const scaleY = newBox.height / oldBox.height;\n                const uniformScale = Math.min(scaleX, scaleY);\n                const newWidth = oldBox.width * uniformScale;\n                const newHeight = oldBox.height * uniformScale;\n                return {\n                    ...newBox,\n                    width: Math.min(Math.max(newWidth, minSize), maxSize),\n                    height: Math.min(Math.max(newHeight, minSize), maxSize)\n                };\n            }\n            return {\n                ...newBox,\n                width: Math.min(newBox.width, maxSize),\n                height: Math.min(newBox.height, maxSize)\n            };\n        },\n        onTransformStart: (e)=>{\n            window._resizeData = {\n                isResizing: true\n            };\n            const tr = transformerRef.current;\n            const activeAnchor = typeof (tr === null || tr === void 0 ? void 0 : tr.getActiveAnchor) === \"function\" ? tr.getActiveAnchor() : null;\n            const isRotateGesture = typeof activeAnchor === \"string\" && activeAnchor.toLowerCase().includes(\"rotat\");\n            transformGestureRef.current = {\n                isRotate: isRotateGesture,\n                activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null\n            };\n            if (typeof onTransformInteractionStart === \"function\") {\n                var _e_evt;\n                var _e_evt_pointerType;\n                onTransformInteractionStart({\n                    isRotate: isRotateGesture,\n                    activeAnchor: activeAnchor !== null && activeAnchor !== void 0 ? activeAnchor : null,\n                    pointerType: (_e_evt_pointerType = e === null || e === void 0 ? void 0 : (_e_evt = e.evt) === null || _e_evt === void 0 ? void 0 : _e_evt.pointerType) !== null && _e_evt_pointerType !== void 0 ? _e_evt_pointerType : null\n                });\n            }\n            try {\n                var _tr_nodes, _n_attrs, _tr_getClientRect;\n                const nodes = (tr === null || tr === void 0 ? void 0 : (_tr_nodes = tr.nodes) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.call(tr)) || [];\n                circleAnchorRef.current = null;\n                textTransformAnchorRef.current = null;\n                if (nodes.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                    try {\n                        const r0 = nodes[0].getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        circleAnchorRef.current = {\n                            left: r0.x,\n                            top: r0.y\n                        };\n                    } catch (e) {}\n                }\n                if (nodes.length === 1 && esTexto) {\n                    const node = nodes[0];\n                    let centerX = null;\n                    let centerY = null;\n                    let baseWidth = null;\n                    let baseHeight = null;\n                    let baseVisualWidth = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.x) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width)) {\n                            centerX = rect.x + rect.width / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.y) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height)) {\n                            centerY = rect.y + rect.height / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            baseWidth = rect.width;\n                            baseVisualWidth = rect.width;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height) && rect.height > 0) {\n                            baseHeight = rect.height;\n                        }\n                    } catch (e) {}\n                    const safeBaseFontSize = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.fontSize) && primerElemento.fontSize > 0 ? primerElemento.fontSize : 24;\n                    textTransformAnchorRef.current = {\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : 0,\n                        baseRotation: typeof (node === null || node === void 0 ? void 0 : node.rotation) === \"function\" ? node.rotation() || 0 : 0,\n                        centerX,\n                        centerY,\n                        baseWidth,\n                        baseHeight,\n                        baseFontSize: safeBaseFontSize,\n                        lastPreviewFontSize: safeBaseFontSize,\n                        lastPreviewCenterX: centerX,\n                        lastPreviewCenterY: centerY,\n                        lastPreviewVisualWidth: baseVisualWidth,\n                        previewTick: 0\n                    };\n                    var _primerElemento_id;\n                    TXTDBG(\"start\", {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        baseFontSize: safeBaseFontSize,\n                        baseWidth,\n                        baseHeight,\n                        centerX,\n                        centerY,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        nodeScaleX: typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() : null,\n                        nodeScaleY: typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() : null\n                    });\n                }\n                const union = rectFromNodes(nodes);\n                const pad = typeof (tr === null || tr === void 0 ? void 0 : tr.padding) === \"function\" ? tr.padding() : 0;\n                const borderRect = union ? {\n                    x: union.x - pad,\n                    y: union.y - pad,\n                    width: union.width + pad * 2,\n                    height: union.height + pad * 2\n                } : null;\n                const n = nodes[0];\n                const id = n ? typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id : \"âˆ…\";\n                const trRect = tr === null || tr === void 0 ? void 0 : (_tr_getClientRect = tr.getClientRect) === null || _tr_getClientRect === void 0 ? void 0 : _tr_getClientRect.call(tr, {\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                slog(\"[TR] start\", \"id=\".concat(id), \"nodes=\".concat(nodes.length), union ? \"union(w=\".concat(union.width.toFixed(1), \",h=\").concat(union.height.toFixed(1), \")\") : \"union(null)\", borderRect ? \"border(w=\".concat(borderRect.width.toFixed(1), \",h=\").concat(borderRect.height.toFixed(1), \")\") : \"border(null)\", trRect ? \"trRect(w=\".concat(trRect.width.toFixed(1), \",h=\").concat(trRect.height.toFixed(1), \")\") : \"trRect(null)\", \"pad=\".concat(pad));\n            } catch (e) {}\n        },\n        onTransform: (e)=>{\n            if (!onTransform || !transformerRef.current) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            const node = nodes[0]; // âœ… nodo real (single select)\n            if (!node) return;\n            try {\n                var _node_attrs, _node_scaleX, _node_scaleY, _node_x, _node_y;\n                const pose = getTransformPose(node);\n                const transformData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isPreview: true\n                };\n                if (esTexto) {\n                    var _textTransformAnchorRef_current, _textTransformAnchorRef_current1, _textTransformAnchorRef_current2;\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let liveRectWidth = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            liveRectWidth = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    transformData.fontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    if (textTransformAnchorRef.current) {\n                        const tick = Number(textTransformAnchorRef.current.previewTick || 0) + 1;\n                        textTransformAnchorRef.current.previewTick = tick;\n                        textTransformAnchorRef.current.lastPreviewFontSize = transformData.fontSize;\n                        if (Number.isFinite(liveRectWidth) && liveRectWidth > 0) {\n                            textTransformAnchorRef.current.lastPreviewVisualWidth = liveRectWidth;\n                        }\n                        if (tick <= 2 || tick % 5 === 0) {\n                            var _textTransformAnchorRef_current3;\n                            var _primerElemento_id, _textTransformAnchorRef_current_centerX;\n                            TXTDBG(\"preview\", {\n                                id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                                tick,\n                                scaleX,\n                                scaleY,\n                                avgScale,\n                                scaleFromRect,\n                                effectiveScale,\n                                baseFontSize,\n                                fontSize: transformData.fontSize,\n                                liveRectWidth,\n                                centerXTarget: (_textTransformAnchorRef_current_centerX = (_textTransformAnchorRef_current3 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current3 === void 0 ? void 0 : _textTransformAnchorRef_current3.centerX) !== null && _textTransformAnchorRef_current_centerX !== void 0 ? _textTransformAnchorRef_current_centerX : null,\n                                nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                                nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                            });\n                        }\n                    }\n                    transformData.scaleX = 1;\n                    transformData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite((_textTransformAnchorRef_current = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current === void 0 ? void 0 : _textTransformAnchorRef_current.y)) {\n                        transformData.y = textTransformAnchorRef.current.y;\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current1 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current1 === void 0 ? void 0 : _textTransformAnchorRef_current1.centerX)) {\n                        transformData.textCenterX = textTransformAnchorRef.current.centerX;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterX = textTransformAnchorRef.current.centerX;\n                        }\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current2 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current2 === void 0 ? void 0 : _textTransformAnchorRef_current2.centerY)) {\n                        transformData.textCenterY = textTransformAnchorRef.current.centerY;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterY = textTransformAnchorRef.current.centerY;\n                        }\n                    }\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    transformData.scaleX = scaleX;\n                    transformData.scaleY = scaleY;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        const countdownSize = getCountdownScaledSize(node);\n                        transformData.width = countdownSize.width;\n                        transformData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        transformData.radius = Math.max(1, baseRadius * avgScale);\n                    } else {\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        transformData.width = Math.abs(originalWidth * scaleX);\n                        transformData.height = Math.abs(originalHeight * scaleY);\n                    }\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                        try {\n                            const liveRect = node.getClientRect({\n                                skipTransform: false,\n                                skipShadow: true,\n                                skipStroke: true\n                            });\n                            const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                            transformData.radius = diameter / 2;\n                            const anchor = circleAnchorRef.current;\n                            if (anchor) {\n                                transformData.x = anchor.left + transformData.radius;\n                                transformData.y = anchor.top + transformData.radius;\n                            } else {\n                                transformData.x = liveRect.x + transformData.radius;\n                                transformData.y = liveRect.y + transformData.radius;\n                            }\n                        } catch (e) {}\n                    }\n                }\n                onTransform(transformData);\n                // --- LOG COMPACTO (opcional) ---\n                const id = (typeof node.id === \"function\" ? node.id() : (_node_attrs = node.attrs) === null || _node_attrs === void 0 ? void 0 : _node_attrs.id) || \"âˆ…\";\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                const r = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                var _node_x1, _node_y1, _transformData_width, _transformData_height;\n                slog(\"[TR] live\", \"id=\".concat(id), \"tipo=\".concat((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) || \"âˆ…\"), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"x=\".concat(((_node_x1 = (_node_x = node.x) === null || _node_x === void 0 ? void 0 : _node_x.call(node)) !== null && _node_x1 !== void 0 ? _node_x1 : 0).toFixed(1)), \"y=\".concat(((_node_y1 = (_node_y = node.y) === null || _node_y === void 0 ? void 0 : _node_y.call(node)) !== null && _node_y1 !== void 0 ? _node_y1 : 0).toFixed(1)), \"nodeRect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"), \"w=\".concat((_transformData_width = transformData.width) !== null && _transformData_width !== void 0 ? _transformData_width : \"âˆ…\"), \"h=\".concat((_transformData_height = transformData.height) !== null && _transformData_height !== void 0 ? _transformData_height : \"âˆ…\"));\n            } catch (error) {\n                console.warn(\"Error en onTransform:\", error);\n            }\n        },\n        onTransformEnd: (e)=>{\n            if (!transformerRef.current || !onTransform) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            // -------------------------\n            // MULTI-SELECCIÃ“N\n            // -------------------------\n            if (nodes.length > 1) {\n                try {\n                    var _tr_getLayer;\n                    const tScaleX = typeof tr.scaleX === \"function\" ? tr.scaleX() || 1 : 1;\n                    const tScaleY = typeof tr.scaleY === \"function\" ? tr.scaleY() || 1 : 1;\n                    const avg = (Math.abs(tScaleX) + Math.abs(tScaleY)) / 2;\n                    const updates = nodes.map((n)=>{\n                        let id = null;\n                        try {\n                            var _n_attrs;\n                            id = (typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id) || null;\n                        } catch (e) {}\n                        if (!id) return null;\n                        const obj = (objetos || []).find((o)=>o.id === id);\n                        if (!obj) return null;\n                        const upd = {\n                            id,\n                            x: typeof n.x === \"function\" ? n.x() : obj.x,\n                            y: typeof n.y === \"function\" ? n.y() : obj.y,\n                            rotation: typeof n.rotation === \"function\" ? n.rotation() || 0 : obj.rotation || 0\n                        };\n                        if (obj.tipo === \"texto\") {\n                            const base = obj.fontSize || 24;\n                            upd.fontSize = Math.max(6, Math.round(base * avg));\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }\n                        if (obj.tipo === \"forma\" && obj.figura === \"circle\") {\n                            const baseR = obj.radius || 50;\n                            upd.radius = baseR * avg;\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }\n                        if (obj.tipo === \"forma\" && obj.figura === \"triangle\") {\n                            const baseR = obj.radius || 60;\n                            upd.radius = Math.max(1, baseR * avg);\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }\n                        if (obj.tipo === \"countdown\") {\n                            const countdownSize = getCountdownScaledSize(n);\n                            upd.width = countdownSize.width;\n                            upd.height = countdownSize.height;\n                            return upd;\n                        }\n                        const baseW = obj.width != null ? obj.width : typeof n.width === \"function\" ? n.width() : 100;\n                        const baseH = obj.height != null ? obj.height : typeof n.height === \"function\" ? n.height() : 100;\n                        upd.width = Math.abs(baseW * tScaleX);\n                        upd.height = Math.abs(baseH * tScaleY);\n                        if (typeof n.scaleX === \"function\") {\n                            n.scaleX(1);\n                            n.scaleY(1);\n                        }\n                        return upd;\n                    }).filter(Boolean);\n                    onTransform({\n                        isFinal: true,\n                        batch: updates\n                    });\n                    if (typeof tr.scaleX === \"function\") {\n                        tr.scaleX(1);\n                        tr.scaleY(1);\n                    }\n                    (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n                    window._resizeData = {\n                        isResizing: false\n                    };\n                    setTimeout(()=>{\n                        window._resizeData = null;\n                    }, 100);\n                    return;\n                } catch (err) {\n                    console.warn(\"Error en onTransformEnd (multi):\", err);\n                    window._resizeData = null;\n                    return;\n                }\n            }\n            // -------------------------\n            // SINGLE-SELECCIÃ“N\n            // -------------------------\n            const node = nodes[0];\n            if (!node) return;\n            try {\n                const pose = getTransformPose(node);\n                const finalData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isFinal: true\n                };\n                let textPreviewEndSnapshot = null;\n                if (esTexto) {\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let visualWidthFromRect = null;\n                    const currentRotation = typeof node.rotation === \"function\" ? node.rotation() || 0 : 0;\n                    const baseRotation = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseRotation);\n                    const rotationDelta = Number.isFinite(baseRotation) ? Math.abs(currentRotation - baseRotation) : 0;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            visualWidthFromRect = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const canUseRectScale = rotationDelta < 0.1;\n                    const effectiveScale = canUseRectScale && Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    const computedFontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    finalData.fontSize = Math.max(6, Number(Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewFontSize) && anchorData.lastPreviewFontSize > 0 ? anchorData.lastPreviewFontSize : computedFontSize));\n                    finalData.scaleX = 1;\n                    finalData.scaleY = 1;\n                    if (canUseRectScale && Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.y)) {\n                        finalData.y = anchorData.y;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterX)) {\n                        finalData.textCenterX = anchorData.lastPreviewCenterX;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerX)) {\n                        finalData.textCenterX = anchorData.centerX;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterY)) {\n                        finalData.textCenterY = anchorData.lastPreviewCenterY;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerY)) {\n                        finalData.textCenterY = anchorData.centerY;\n                    }\n                    const visualWidth = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewVisualWidth) && anchorData.lastPreviewVisualWidth > 0 ? anchorData.lastPreviewVisualWidth : visualWidthFromRect;\n                    if (Number.isFinite(visualWidth) && visualWidth > 0) {\n                        finalData.textVisualWidth = visualWidth;\n                    }\n                    var _primerElemento_id;\n                    textPreviewEndSnapshot = {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        x: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        scaleX,\n                        scaleY,\n                        fontSize: typeof (node === null || node === void 0 ? void 0 : node.fontSize) === \"function\" ? node.fontSize() : null,\n                        rectWidth: Number.isFinite(visualWidthFromRect) ? visualWidthFromRect : null,\n                        rectHeight: null\n                    };\n                    try {\n                        const rectForSnapshot = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rectForSnapshot === null || rectForSnapshot === void 0 ? void 0 : rectForSnapshot.height)) {\n                            textPreviewEndSnapshot.rectHeight = rectForSnapshot.height;\n                        }\n                    } catch (e) {}\n                    var _primerElemento_id1, _finalData_textCenterX, _finalData_textCenterY, _finalData_textVisualWidth;\n                    TXTDBG(\"end\", {\n                        id: (_primerElemento_id1 = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id1 !== void 0 ? _primerElemento_id1 : null,\n                        scaleX,\n                        scaleY,\n                        avgScale,\n                        scaleFromRect,\n                        effectiveScale,\n                        computedFontSize,\n                        finalFontSize: finalData.fontSize,\n                        textCenterX: (_finalData_textCenterX = finalData.textCenterX) !== null && _finalData_textCenterX !== void 0 ? _finalData_textCenterX : null,\n                        textCenterY: (_finalData_textCenterY = finalData.textCenterY) !== null && _finalData_textCenterY !== void 0 ? _finalData_textCenterY : null,\n                        textVisualWidth: (_finalData_textVisualWidth = finalData.textVisualWidth) !== null && _finalData_textVisualWidth !== void 0 ? _finalData_textVisualWidth : null,\n                        nodeRectWidth: visualWidthFromRect,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                    });\n                    // Aplanar escala del texto en el release para evitar doble escalado\n                    // (escala del nodo + fontSize persistido).\n                    try {\n                        var _node_getLayer;\n                        if (typeof node.scaleX === \"function\") node.scaleX(1);\n                        if (typeof node.scaleY === \"function\") node.scaleY(1);\n                        if (Number.isFinite(finalData.fontSize) && typeof node.fontSize === \"function\") {\n                            node.fontSize(finalData.fontSize);\n                        }\n                        const targetCenterX = Number(finalData.textCenterX);\n                        const targetCenterY = Number(finalData.textCenterY);\n                        if ((Number.isFinite(targetCenterX) || Number.isFinite(targetCenterY)) && typeof node.x === \"function\" && typeof node.y === \"function\") {\n                            try {\n                                const flattenedRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const flattenedCenterX = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.x) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.width) ? flattenedRect.x + flattenedRect.width / 2 : null;\n                                const flattenedCenterY = Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.y) && Number.isFinite(flattenedRect === null || flattenedRect === void 0 ? void 0 : flattenedRect.height) ? flattenedRect.y + flattenedRect.height / 2 : null;\n                                if (Number.isFinite(flattenedCenterX) && Number.isFinite(targetCenterX)) {\n                                    node.x(node.x() + (targetCenterX - flattenedCenterX));\n                                }\n                                if (Number.isFinite(flattenedCenterY) && Number.isFinite(targetCenterY)) {\n                                    node.y(node.y() + (targetCenterY - flattenedCenterY));\n                                }\n                            } catch (e) {}\n                        }\n                        (_node_getLayer = node.getLayer()) === null || _node_getLayer === void 0 ? void 0 : _node_getLayer.batchDraw();\n                    } catch (err) {\n                        console.warn(\"Error aplanando escala de texto (sync):\", err);\n                    }\n                    if (!canUseRectScale) {\n                        if (typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\") {\n                            finalData.x = node.x();\n                        }\n                        if (typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\") {\n                            finalData.y = node.y();\n                        }\n                    }\n                    // Para texto evitamos aplanar antes del commit en React,\n                    // asÃ­ no aparece un frame intermedio con tamaÃ±o \"saltado\".\n                    textTransformAnchorRef.current = null;\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        // Countdown: persistir escala real para que el resultado final\n                        // sea exactamente el mismo que se ve al soltar.\n                        finalData.scaleX = scaleX;\n                        finalData.scaleY = scaleY;\n                        const countdownSize = getCountdownScaledSize(node);\n                        finalData.width = countdownSize.width;\n                        finalData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        finalData.radius = Math.max(1, baseRadius * avgScale);\n                        try {\n                            var _node_getLayer1;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (typeof node.radius === \"function\") node.radius(finalData.radius);\n                            (_node_getLayer1 = node.getLayer()) === null || _node_getLayer1 === void 0 ? void 0 : _node_getLayer1.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escala de triÃ¡ngulo (sync):\", err);\n                        }\n                    } else {\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        finalData.width = Math.abs(originalWidth * scaleX);\n                        finalData.height = Math.abs(originalHeight * scaleY);\n                        if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                            try {\n                                const liveRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                                finalData.radius = diameter / 2;\n                                const anchor = circleAnchorRef.current;\n                                if (anchor) {\n                                    finalData.x = anchor.left + finalData.radius;\n                                    finalData.y = anchor.top + finalData.radius;\n                                } else {\n                                    finalData.x = liveRect.x + finalData.radius;\n                                    finalData.y = liveRect.y + finalData.radius;\n                                }\n                            } catch (e) {}\n                        }\n                        // âœ… Aplanar escala INMEDIATO\n                        try {\n                            var _node_getLayer2;\n                            const fw = finalData.width;\n                            const fh = finalData.height;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (fw != null && typeof node.width === \"function\") node.width(fw);\n                            if (fh != null && typeof node.height === \"function\") node.height(fh);\n                            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\" && finalData.radius != null && typeof node.radius === \"function\") {\n                                node.radius(finalData.radius);\n                            }\n                            (_node_getLayer2 = node.getLayer()) === null || _node_getLayer2 === void 0 ? void 0 : _node_getLayer2.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escalas (sync):\", err);\n                        }\n                    }\n                }\n                onTransform(finalData);\n                circleAnchorRef.current = null;\n                // âœ… Reatachar 1 vez, con ref fresco, en el prÃ³ximo frame\n                try {\n                    const tr2 = transformerRef.current;\n                    if (!tr2) return;\n                    TRDBG(\"onTransformEnd -> schedule RAF reattach\", {\n                        selKey: selectedElements.join(\",\"),\n                        idSel: (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0]) || null\n                    });\n                    requestAnimationFrame(()=>{\n                        var _elementRefs_current, _freshNode_getStage, _freshNode_getStage1;\n                        const idSel = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n                        const freshNode = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                        TRDBG(\"onTransformEnd RAF\", {\n                            idSel,\n                            hasFresh: !!freshNode,\n                            destroyed: !!(freshNode === null || freshNode === void 0 ? void 0 : freshNode._destroyed),\n                            hasStage: !!(freshNode === null || freshNode === void 0 ? void 0 : (_freshNode_getStage = freshNode.getStage) === null || _freshNode_getStage === void 0 ? void 0 : _freshNode_getStage.call(freshNode))\n                        });\n                        // Si el nodo no estÃ¡ listo, despegar y salir\n                        if (!freshNode || freshNode._destroyed || !((_freshNode_getStage1 = freshNode.getStage) === null || _freshNode_getStage1 === void 0 ? void 0 : _freshNode_getStage1.call(freshNode))) {\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            try {\n                                var _tr2_getLayer, _tr2_getLayer1;\n                                tr2.nodes([]);\n                                (_tr2_getLayer1 = tr2.getLayer) === null || _tr2_getLayer1 === void 0 ? void 0 : (_tr2_getLayer = _tr2_getLayer1.call(tr2)) === null || _tr2_getLayer === void 0 ? void 0 : _tr2_getLayer.batchDraw();\n                            } catch (e) {}\n                            return;\n                        }\n                        try {\n                            var _tr2_getLayer2, _tr2_getLayer3;\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            tr2.nodes([\n                                freshNode\n                            ]);\n                            tr2.forceUpdate();\n                            (_tr2_getLayer3 = tr2.getLayer) === null || _tr2_getLayer3 === void 0 ? void 0 : (_tr2_getLayer2 = _tr2_getLayer3.call(tr2)) === null || _tr2_getLayer2 === void 0 ? void 0 : _tr2_getLayer2.batchDraw();\n                            if (textPreviewEndSnapshot && freshNode) {\n                                try {\n                                    const postRect = freshNode.getClientRect({\n                                        skipTransform: false,\n                                        skipShadow: true,\n                                        skipStroke: true\n                                    });\n                                    TXTDBG(\"post-commit:raf1\", {\n                                        id: idSel,\n                                        pre: textPreviewEndSnapshot,\n                                        post: {\n                                            x: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.x) === \"function\" ? freshNode.x() : null,\n                                            y: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.y) === \"function\" ? freshNode.y() : null,\n                                            scaleX: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleX) === \"function\" ? freshNode.scaleX() : null,\n                                            scaleY: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleY) === \"function\" ? freshNode.scaleY() : null,\n                                            fontSize: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.fontSize) === \"function\" ? freshNode.fontSize() : null,\n                                            rectWidth: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) ? postRect.width : null,\n                                            rectHeight: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) ? postRect.height : null\n                                        },\n                                        delta: {\n                                            width: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect.width - textPreviewEndSnapshot.rectWidth : null,\n                                            height: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect.height - textPreviewEndSnapshot.rectHeight : null\n                                        }\n                                    });\n                                } catch (e) {}\n                                requestAnimationFrame(()=>{\n                                    var _elementRefs_current;\n                                    const freshNode2 = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                                    if (!freshNode2) return;\n                                    try {\n                                        const postRect2 = freshNode2.getClientRect({\n                                            skipTransform: false,\n                                            skipShadow: true,\n                                            skipStroke: true\n                                        });\n                                        TXTDBG(\"post-commit:raf2\", {\n                                            id: idSel,\n                                            post: {\n                                                x: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.x) === \"function\" ? freshNode2.x() : null,\n                                                y: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.y) === \"function\" ? freshNode2.y() : null,\n                                                scaleX: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleX) === \"function\" ? freshNode2.scaleX() : null,\n                                                scaleY: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.scaleY) === \"function\" ? freshNode2.scaleY() : null,\n                                                fontSize: typeof (freshNode2 === null || freshNode2 === void 0 ? void 0 : freshNode2.fontSize) === \"function\" ? freshNode2.fontSize() : null,\n                                                rectWidth: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) ? postRect2.width : null,\n                                                rectHeight: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) ? postRect2.height : null\n                                            },\n                                            deltaFromPre: {\n                                                width: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect2.width - textPreviewEndSnapshot.rectWidth : null,\n                                                height: Number.isFinite(postRect2 === null || postRect2 === void 0 ? void 0 : postRect2.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect2.height - textPreviewEndSnapshot.rectHeight : null\n                                            }\n                                        });\n                                    } catch (e) {}\n                                });\n                            }\n                        } catch (e) {}\n                    });\n                } catch (e) {}\n            } catch (error) {\n                console.warn(\"Error en onTransformEnd:\", error);\n                window._resizeData = null;\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 465,\n        columnNumber: 5\n    }, this);\n}\n_s1(SelectionBounds, \"lrM1nT4Gd8O7aGNWhNCH3vOGx1Y=\");\n_c3 = SelectionBounds;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"TRDBG\");\n$RefreshReg$(_c1, \"TXTDBG\");\n$RefreshReg$(_c2, \"BoundsIndicator\");\n$RefreshReg$(_c3, \"SelectionBounds\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NlbGVjdGlvbkJvdW5kcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsc0JBQXNCOzs7QUFDOEI7QUFDSjtBQUloRCxNQUFNSyx5QkFBeUI7QUFFL0IsTUFBTUMsUUFBUTtxQ0FBSUM7UUFBQUE7O0lBQ2hCLElBQUksQ0FBQ0Ysd0JBQXdCO0lBQzdCRyxRQUFRQyxHQUFHLENBQUMsV0FBV0Y7QUFDekI7QUFDQSxNQUFNRyxPQUFPSjtBQUViLE1BQU1LLFFBQVE7cUNBQUlKO1FBQUFBOztJQUNoQixJQUFJLENBQUNLLE9BQU9DLFFBQVEsRUFBRTtJQUN0QkwsUUFBUUMsR0FBRyxDQUFDLGNBQWNGO0FBQzVCO0tBSE1JO0FBS04sTUFBTUcsU0FBUztxQ0FBSVA7UUFBQUE7O0lBQ2pCLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBQzFDLElBQUksQ0FBQ0ssT0FBT0csaUJBQWlCLEVBQUU7SUFDL0JQLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JGO0FBQzlCO01BSk1PO0FBT04sU0FBU0UsY0FBY0MsS0FBSztJQUMxQixJQUFJQyxPQUFPQyxVQUFVQyxPQUFPRCxVQUFVRSxPQUFPLENBQUNGLFVBQVVHLE9BQU8sQ0FBQ0g7SUFFaEUsS0FBSyxNQUFNSSxLQUFLTixNQUFPO1FBQ3JCLElBQUksRUFBQ00sY0FBQUEsd0JBQUFBLEVBQUdDLGFBQWEsR0FBRTtRQUN2QixNQUFNQyxJQUFJRixFQUFFQyxhQUFhLENBQUM7WUFBRUUsZUFBZTtZQUFPQyxZQUFZO1lBQU1DLFlBQVk7UUFBSztRQUNyRlYsT0FBT1csS0FBS0MsR0FBRyxDQUFDWixNQUFNTyxFQUFFTSxDQUFDO1FBQ3pCWCxPQUFPUyxLQUFLQyxHQUFHLENBQUNWLE1BQU1LLEVBQUVPLENBQUM7UUFDekJYLE9BQU9RLEtBQUtJLEdBQUcsQ0FBQ1osTUFBTUksRUFBRU0sQ0FBQyxHQUFHTixFQUFFUyxLQUFLO1FBQ25DWixPQUFPTyxLQUFLSSxH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QUFDdVIsc0JBQUFBLGdDQUFBQSxVQUFXclMsTUFBTSxJQUFJcVMsVUFBVXJTLE1BQU0sR0FBRzs0Q0FDdEU7NENBQ0FzUyxjQUFjO2dEQUNadlMsT0FDRWMsT0FBT0MsUUFBUSxDQUFDdVIsc0JBQUFBLGdDQUFBQSxVQUFXdFMsS0FBSyxLQUNoQ2MsT0FBT0MsUUFBUSxDQUFDMlAsdUJBQXVCSyxTQUFTLElBQzNDdUIsVUFBVXRTLEtBQUssR0FBRzBRLHVCQUF1QkssU0FBUyxHQUNuRDtnREFDTjlRLFFBQ0VhLE9BQU9DLFFBQVEsQ0FBQ3VSLHNCQUFBQSxnQ0FBQUEsVUFBV3JTLE1BQU0sS0FDakNhLE9BQU9DLFFBQVEsQ0FBQzJQLHVCQUF1Qk0sVUFBVSxJQUM1Q3NCLFVBQVVyUyxNQUFNLEdBQUd5USx1QkFBdUJNLFVBQVUsR0FDckQ7NENBQ1I7d0NBQ0Y7b0NBQ0YsRUFBRSxVQUFNLENBQUM7Z0NBQ1g7NEJBQ0Y7d0JBQ0YsRUFBRSxVQUFNLENBQUU7b0JBQ1o7Z0JBQ0YsRUFBRSxVQUFNLENBQUU7WUFHWixFQUFFLE9BQU94TixPQUFPO2dCQUNkbEYsUUFBUXFSLElBQUksQ0FBQyw0QkFBNEJuTTtnQkFDekM5RSxPQUFPd04sV0FBVyxHQUFHO1lBQ3ZCO1FBQ0Y7Ozs7OztBQUlOO0lBMXJDd0IxSDtNQUFBQSIsInNvdXJjZXMiOlsiQzpcXFJlc2VydmFlbGRpYVxcc3JjXFxjb21wb25lbnRzXFxTZWxlY3Rpb25Cb3VuZHMuanN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNlbGVjdGlvbkJvdW5kcy5qc3hcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVHJhbnNmb3JtZXIsIFJlY3QgfSBmcm9tIFwicmVhY3Qta29udmFcIjtcblxuXG5cbmNvbnN0IERFQlVHX1NFTEVDVElPTl9CT1VORFMgPSBmYWxzZTtcblxuY29uc3Qgc2JMb2cgPSAoLi4uYXJncykgPT4ge1xuICBpZiAoIURFQlVHX1NFTEVDVElPTl9CT1VORFMpIHJldHVybjtcbiAgY29uc29sZS5sb2coXCJbU0JdXCIsIC4uLmFyZ3MpO1xufTtcbmNvbnN0IHNsb2cgPSBzYkxvZztcblxuY29uc3QgVFJEQkcgPSAoLi4uYXJncykgPT4ge1xuICBpZiAoIXdpbmRvdy5fX0RCR19UUikgcmV0dXJuO1xuICBjb25zb2xlLmxvZyhcIltUUkRCR11cIiwgLi4uYXJncyk7XG59O1xuXG5jb25zdCBUWFREQkcgPSAoLi4uYXJncykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICBpZiAoIXdpbmRvdy5fX0RCR19URVhUX1JFU0laRSkgcmV0dXJuO1xuICBjb25zb2xlLmxvZyhcIltURVhULVRSXVwiLCAuLi5hcmdzKTtcbn07XG5cblxuZnVuY3Rpb24gcmVjdEZyb21Ob2Rlcyhub2Rlcykge1xuICBsZXQgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZm9yIChjb25zdCBuIG9mIG5vZGVzKSB7XG4gICAgaWYgKCFuPy5nZXRDbGllbnRSZWN0KSBjb250aW51ZTtcbiAgICBjb25zdCByID0gbi5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHIueCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHIueSk7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHIueCArIHIud2lkdGgpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCByLnkgKyByLmhlaWdodCk7XG4gIH1cblxuICBpZiAobWluWCA9PT0gSW5maW5pdHkpIHJldHVybiBudWxsO1xuICByZXR1cm4geyB4OiBtaW5YLCB5OiBtaW5ZLCB3aWR0aDogbWF4WCAtIG1pblgsIGhlaWdodDogbWF4WSAtIG1pblkgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShub2RlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaGl0Ym94ID0gbm9kZT8uZmluZE9uZT8uKFwiLmNvdW50ZG93bi1oaXRib3hcIik7XG4gICAgY29uc3QgYmFzZVcgPSB0eXBlb2YgaGl0Ym94Py53aWR0aCA9PT0gXCJmdW5jdGlvblwiID8gaGl0Ym94LndpZHRoKCkgOiBOYU47XG4gICAgY29uc3QgYmFzZUggPSB0eXBlb2YgaGl0Ym94Py5oZWlnaHQgPT09IFwiZnVuY3Rpb25cIiA/IGhpdGJveC5oZWlnaHQoKSA6IE5hTjtcbiAgICBjb25zdCBzeCA9IE1hdGguYWJzKHR5cGVvZiBub2RlPy5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnNjYWxlWCgpIHx8IDEpIDogMSk7XG4gICAgY29uc3Qgc3kgPSBNYXRoLmFicyh0eXBlb2Ygbm9kZT8uc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5zY2FsZVkoKSB8fCAxKSA6IDEpO1xuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShiYXNlVykgJiYgTnVtYmVyLmlzRmluaXRlKGJhc2VIKSAmJiBiYXNlVyA+IDAgJiYgYmFzZUggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogTWF0aC5hYnMoYmFzZVcgKiBzeCksXG4gICAgICAgIGhlaWdodDogTWF0aC5hYnMoYmFzZUggKiBzeSksXG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgY29uc3QgciA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xuICAgIHJldHVybiB7IHdpZHRoOiBNYXRoLmFicyhyLndpZHRoKSwgaGVpZ2h0OiBNYXRoLmFicyhyLmhlaWdodCkgfTtcbiAgfSBjYXRjaCB7fVxuXG4gIHJldHVybiB7IHdpZHRoOiAxMDAsIGhlaWdodDogNTAgfTtcbn1cblxuXG4vLyDwn46oIENvbXBvbmVudGUgcGFyYSBtb3N0cmFyIGJvdW5kcyBzaW4gdHJhbnNmb3JtZXIgKGzDrW5lYXMsIGV0Yy4pXG5jb25zdCBCb3VuZHNJbmRpY2F0b3IgPSAoeyBzZWxlY3RlZEVsZW1lbnRzLCBlbGVtZW50UmVmcywgb2JqZXRvcyB9KSA9PiB7XG4gIGNvbnN0IFtmb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlU3RhdGUoMCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmaXJzdFJlZiA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltzZWxlY3RlZEVsZW1lbnRzWzBdXTtcbiAgICBjb25zdCBzdGFnZSA9IGZpcnN0UmVmPy5nZXRTdGFnZT8uKCk7XG4gICAgaWYgKCFzdGFnZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgaGFuZGxlRHJhZ01vdmUgPSAoKSA9PiB7XG4gICAgICBzZXRGb3JjZVVwZGF0ZSgocCkgPT4gcCArIDEpO1xuICAgIH07XG5cbiAgICBzdGFnZS5vbihcImRyYWdtb3ZlXCIsIGhhbmRsZURyYWdNb3ZlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ21vdmVcIiwgaGFuZGxlRHJhZ01vdmUpO1xuICAgIH07XG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpXSk7XG5cbiAgY29uc3QgZWxlbWVudG9zRGF0YSA9IHNlbGVjdGVkRWxlbWVudHNcbiAgICAubWFwKChpZCkgPT4gb2JqZXRvcy5maW5kKChvYmopID0+IG9iai5pZCA9PT0gaWQpKVxuICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgaWYgKGVsZW1lbnRvc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbWluWCA9IEluZmluaXR5LFxuICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICBtYXhYID0gLUluZmluaXR5LFxuICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZWxlbWVudG9zRGF0YS5mb3JFYWNoKChvYmopID0+IHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudFJlZnMuY3VycmVudFtvYmouaWRdO1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwibGluZVwiKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG9iai5wb2ludHMgfHwgWzAsIDAsIDEwMCwgMF07XG5cbiAgICAgICAgY29uc3QgY2xlYW5Qb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbMF0pIHx8IDAsXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbMV0pIHx8IDAsXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbMl0pIHx8IDEwMCxcbiAgICAgICAgICBwYXJzZUZsb2F0KHBvaW50c1szXSkgfHwgMCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCByZWFsWCA9IG5vZGUueCgpO1xuICAgICAgICBjb25zdCByZWFsWSA9IG5vZGUueSgpO1xuXG4gICAgICAgIGNvbnN0IHgxID0gcmVhbFggKyBjbGVhblBvaW50c1swXTtcbiAgICAgICAgY29uc3QgeTEgPSByZWFsWSArIGNsZWFuUG9pbnRzWzFdO1xuICAgICAgICBjb25zdCB4MiA9IHJlYWxYICsgY2xlYW5Qb2ludHNbMl07XG4gICAgICAgIGNvbnN0IHkyID0gcmVhbFkgKyBjbGVhblBvaW50c1szXTtcblxuICAgICAgICBjb25zdCBsaW5lUGFkZGluZyA9IDU7XG5cbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgxIC0gbGluZVBhZGRpbmcsIHgyIC0gbGluZVBhZGRpbmcpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeTEgLSBsaW5lUGFkZGluZywgeTIgLSBsaW5lUGFkZGluZyk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4MSArIGxpbmVQYWRkaW5nLCB4MiArIGxpbmVQYWRkaW5nKTtcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkxICsgbGluZVBhZGRpbmcsIHkyICsgbGluZVBhZGRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYm94ID0gbm9kZS5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHIgPSBib3g7XG4gICAgICAgIGNvbnN0IHN4ID0gKG5vZGU/LnNjYWxlWD8uKCkgPz8gMSk7XG4gICAgICAgIGNvbnN0IHN5ID0gKG5vZGU/LnNjYWxlWT8uKCkgPz8gMSk7XG4gICAgICAgIHNsb2coXG4gICAgICAgICAgXCJbQkldXCIsXG4gICAgICAgICAgYGlkPSR7b2JqLmlkfWAsXG4gICAgICAgICAgYHRpcG89JHtvYmoudGlwb31gLFxuICAgICAgICAgIGBzeD0ke3N4LnRvRml4ZWQoMyl9YCxcbiAgICAgICAgICBgc3k9JHtzeS50b0ZpeGVkKDMpfWAsXG4gICAgICAgICAgYHJlY3Qodz0ke3Iud2lkdGgudG9GaXhlZCgxKX0saD0ke3IuaGVpZ2h0LnRvRml4ZWQoMSl9KWBcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZWFsWCA9IGJveC54O1xuICAgICAgICBjb25zdCByZWFsWSA9IGJveC55O1xuICAgICAgICBsZXQgd2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQgPSBib3guaGVpZ2h0O1xuXG4gICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJ0ZXh0b1wiICYmIG5vZGUuZ2V0VGV4dEhlaWdodCkge1xuICAgICAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSBub2RlLmdldFRleHRIZWlnaHQoKTtcbiAgICAgICAgICBpZiAodGV4dEhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dEhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcmVhbFgpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVhbFkpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcmVhbFggKyB3aWR0aCk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCByZWFsWSArIGhlaWdodCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrWCA9IG9iai54IHx8IDA7XG4gICAgICBjb25zdCBmYWxsYmFja1kgPSBvYmoueSB8fCAwO1xuICAgICAgY29uc3QgZmFsbGJhY2tTaXplID0gMjA7XG5cbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBmYWxsYmFja1gpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGZhbGxiYWNrWSk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgZmFsbGJhY2tYICsgZmFsbGJhY2tTaXplKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBmYWxsYmFja1kgKyBmYWxsYmFja1NpemUpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG1pblggPT09IEluZmluaXR5IHx8IG1heFggPT09IC1JbmZpbml0eSkge1xuICAgIGNvbnN0IHByaW1lckVsZW1lbnRvID0gZWxlbWVudG9zRGF0YVswXTtcbiAgICBpZiAoIXByaW1lckVsZW1lbnRvKSByZXR1cm4gbnVsbDtcbiAgICBtaW5YID0gcHJpbWVyRWxlbWVudG8ueCB8fCAwO1xuICAgIG1pblkgPSBwcmltZXJFbGVtZW50by55IHx8IDA7XG4gICAgbWF4WCA9IG1pblggKyAxMDA7XG4gICAgbWF4WSA9IG1pblkgKyA1MDtcbiAgfVxuXG4gIGNvbnN0IHBhZGRpbmcgPSAxMDtcbiAgY29uc3QgZmluYWxYID0gbWluWCAtIHBhZGRpbmc7XG4gIGNvbnN0IGZpbmFsWSA9IG1pblkgLSBwYWRkaW5nO1xuICBjb25zdCBmaW5hbFdpZHRoID0gbWF4WCAtIG1pblggKyBwYWRkaW5nICogMjtcbiAgY29uc3QgZmluYWxIZWlnaHQgPSBtYXhZIC0gbWluWSArIHBhZGRpbmcgKiAyO1xuXG4gIHJldHVybiAoXG4gICAgPFJlY3RcbiAgICAgIG5hbWU9XCJ1aVwiXG4gICAgICB4PXtmaW5hbFh9XG4gICAgICB5PXtmaW5hbFl9XG4gICAgICB3aWR0aD17ZmluYWxXaWR0aH1cbiAgICAgIGhlaWdodD17ZmluYWxIZWlnaHR9XG4gICAgICBmaWxsPVwidHJhbnNwYXJlbnRcIlxuICAgICAgc3Ryb2tlPVwiIzkzMzNFQVwiXG4gICAgICBzdHJva2VXaWR0aD17MX1cbiAgICAgIGxpc3RlbmluZz17ZmFsc2V9XG4gICAgICBvcGFjaXR5PXswLjd9XG4gICAgLz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbGVjdGlvbkJvdW5kcyh7XG4gIHNlbGVjdGVkRWxlbWVudHMsXG4gIGVsZW1lbnRSZWZzLFxuICBvYmpldG9zLFxuICBvblRyYW5zZm9ybSxcbiAgb25UcmFuc2Zvcm1JbnRlcmFjdGlvblN0YXJ0ID0gbnVsbCxcbiAgb25UcmFuc2Zvcm1JbnRlcmFjdGlvbkVuZCA9IG51bGwsXG4gIGlzRHJhZ2dpbmcsXG4gIGlzTW9iaWxlID0gZmFsc2UsXG59KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbdHJhbnNmb3JtVGljaywgc2V0VHJhbnNmb3JtVGlja10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgbGFzdE5vZGVzUmVmID0gdXNlUmVmKFtdKTtcbiAgY29uc3QgY2lyY2xlQW5jaG9yUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0cmFuc2Zvcm1HZXN0dXJlUmVmID0gdXNlUmVmKHtcbiAgICBpc1JvdGF0ZTogZmFsc2UsXG4gICAgYWN0aXZlQW5jaG9yOiBudWxsLFxuICB9KTtcbiAgY29uc3QgZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEgPSBzZWxlY3RlZEVsZW1lbnRzXG4gICAgLm1hcCgoaWQpID0+IG9iamV0b3MuZmluZCgob2JqKSA9PiBvYmouaWQgPT09IGlkKSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIGNvbnN0IHByaW1lckVsZW1lbnRvID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGFbMF0gfHwgbnVsbDtcbiAgY29uc3QgZXNUZXh0byA9IHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcInRleHRvXCI7XG4gIGNvbnN0IGVzQ291bnRkb3duID0gcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiY291bnRkb3duXCI7XG4gIGNvbnN0IGVzR2FsZXJpYSA9IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImdhbGVyaWFcIjtcbiAgY29uc3QgbG9ja0FzcGVjdENvdW50ZG93biA9IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIGVzQ291bnRkb3duO1xuICBjb25zdCBsb2NrQXNwZWN0VGV4dCA9IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxICYmIGVzVGV4dG87XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU2l6ZSA9IGlzTW9iaWxlID8gMjQgOiAxNDtcbiAgY29uc3QgdHJhbnNmb3JtZXJSb3RhdGVPZmZzZXQgPSBpc01vYmlsZSA/IDM0IDogMjQ7XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yUmFkaXVzID0gOTk5O1xuICBjb25zdCB0cmFuc2Zvcm1lclBhZGRpbmcgPSBpc01vYmlsZSA/IDEwIDogNDtcbiAgY29uc3QgdHJhbnNmb3JtZXJCb3JkZXJTdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gMS41IDogMTtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTdHJva2VXaWR0aCA9IGlzTW9iaWxlID8gMyA6IDIuNTtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dCbHVyID0gaXNNb2JpbGUgPyA5IDogNjtcbiAgY29uc3QgdHJhbnNmb3JtZXJBbmNob3JTaGFkb3dPZmZzZXRZID0gaXNNb2JpbGUgPyA0IDogMztcbiAgY29uc3QgdHJhbnNmb3JtZXJSb3RhdGlvblNuYXBUb2xlcmFuY2UgPSBpc01vYmlsZSA/IDggOiA1O1xuICBjb25zdCBlc1RyaWFuZ3VsbyA9XG4gICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZm9ybWFcIiAmJlxuICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwidHJpYW5nbGVcIjtcblxuICBjb25zdCBoYXNHYWxsZXJ5ID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEuc29tZShcbiAgICAobykgPT4gby50aXBvID09PSBcImdhbGVyaWFcIlxuICApO1xuXG4gIGNvbnN0IGhheUxpbmVhcyA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhLnNvbWUoXG4gICAgKG9iaikgPT4gb2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImxpbmVcIlxuICApO1xuXG4gIGNvbnN0IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzID0gZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEuZmlsdGVyKFxuICAgIChvYmopID0+ICEob2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImxpbmVcIilcbiAgKTtcblxuICBjb25zdCBkZWJlcmlhVXNhclRyYW5zZm9ybWVyID1cbiAgICBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPiAwO1xuXG4gIGNvbnN0IHNlbGVjdGVkR2VvbUtleSA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhXG4gICAgLm1hcCgobykgPT5cbiAgICAgIFtcbiAgICAgICAgby5pZCxcbiAgICAgICAgby54ID8/IDAsXG4gICAgICAgIG8ueSA/PyAwLFxuICAgICAgICBvLndpZHRoID8/IFwiXCIsXG4gICAgICAgIG8uaGVpZ2h0ID8/IFwiXCIsXG4gICAgICAgIG8uc2NhbGVYID8/IDEsXG4gICAgICAgIG8uc2NhbGVZID8/IDEsXG4gICAgICAgIG8ucm90YXRpb24gPz8gMCxcbiAgICAgICAgby5jaGlwV2lkdGggPz8gXCJcIixcbiAgICAgICAgby5nYXAgPz8gXCJcIixcbiAgICAgICAgby5wYWRkaW5nWCA/PyBcIlwiLFxuICAgICAgICBvLnBhZGRpbmdZID8/IFwiXCIsXG4gICAgICBdLmpvaW4oXCI6XCIpXG4gICAgKVxuICAgIC5qb2luKFwifFwiKTtcblxuICBjb25zdCBnZXRUcmFuc2Zvcm1Qb3NlID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUpIHJldHVybiB7IHg6IDAsIHk6IDAsIHJvdGF0aW9uOiAwIH07XG5cbiAgICBpZiAoZXNHYWxlcmlhICYmIHR5cGVvZiBub2RlLmdldFBhcmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHR5cGVvZiBwYXJlbnQueCA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LngoKSA6IDAsXG4gICAgICAgICAgeTogdHlwZW9mIHBhcmVudC55ID09PSBcImZ1bmN0aW9uXCIgPyBwYXJlbnQueSgpIDogMCxcbiAgICAgICAgICByb3RhdGlvbjogdHlwZW9mIHBhcmVudC5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LnJvdGF0aW9uKCkgfHwgMCA6IDAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHR5cGVvZiBub2RlLnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogMCxcbiAgICAgIHk6IHR5cGVvZiBub2RlLnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogMCxcbiAgICAgIHJvdGF0aW9uOiB0eXBlb2Ygbm9kZS5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5yb3RhdGlvbigpIHx8IDAgOiAwLFxuICAgIH07XG4gIH07XG5cblxuICAvLyDwn5SlIEVmZWN0byBwcmluY2lwYWwgZGVsIFRyYW5zZm9ybWVyIChTSU4gcmV0cnkgLyBTSU4gZmxpY2tlcilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCF0cikgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2VsS2V5ID0gc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKTtcbiAgICBUUkRCRyhcIkVGRkVDVCBzdGFydFwiLCB7XG4gICAgICBzZWxLZXksXG4gICAgICBpc0RyYWdnaW5nLFxuICAgICAgZGViZXJpYVVzYXJUcmFuc2Zvcm1lcixcbiAgICAgIGhhc0dhbGxlcnksXG4gICAgICBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlc0xlbjogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoLFxuICAgICAgdHJhbnNmb3JtVGljayxcbiAgICAgIGVkaXRpbmdJZDogd2luZG93LmVkaXRpbmc/LmlkIHx8IG51bGwsXG4gICAgfSk7XG5cbiAgICAvLyBTaSBubyBjb3JyZXNwb25kZSB0cmFuc2Zvcm1lciwgbm8gaGFnYXMgZGV0YWNoIGFncmVzaXZvIChldml0YSBmbGlja2VyKVxuICAgIGlmICghZGViZXJpYVVzYXJUcmFuc2Zvcm1lcikge1xuICAgICAgVFJEQkcoXCJFRkZFQ1QgZXhpdDogbm8gdHJhbnNmb3JtZXIgb3IgZ2FsbGVyeVwiLCB7IHNlbEtleSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIFJlc29sdmVyIG5vZGVzIGRlc2RlIHJlZnMgKGZ1ZW50ZSBkZSB2ZXJkYWQpXG4gICAgbGV0IG5vZG9zVHJhbnNmb3JtYWJsZXMgPSBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlc1xuICAgICAgLm1hcCgobykgPT4gZWxlbWVudFJlZnMuY3VycmVudD8uW28uaWRdKVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcblxuICAgIC8vIFNpbmdsZSBzZWxlY3Q6IHVzYXIgcmVmIGZyZXNjbyBTSUVNUFJFXG4gICAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBpZFNlbCA9IHNlbGVjdGVkRWxlbWVudHNbMF07XG4gICAgICBjb25zdCByZWZOb2RlID0gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkU2VsXSB8fCBudWxsO1xuICAgICAgaWYgKHJlZk5vZGUgJiYgdHlwZW9mIHJlZk5vZGUuZ2V0Q2xpZW50UmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChlc0dhbGVyaWEgJiYgdHlwZW9mIHJlZk5vZGUuZmluZE9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgZ2FsbGVyeUZyYW1lID0gcmVmTm9kZS5maW5kT25lKFwiLmdhbGxlcnktdHJhbnNmb3JtLWZyYW1lXCIpO1xuICAgICAgICAgIGlmIChnYWxsZXJ5RnJhbWUgJiYgdHlwZW9mIGdhbGxlcnlGcmFtZS5nZXRDbGllbnRSZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5vZG9zVHJhbnNmb3JtYWJsZXMgPSBbZ2FsbGVyeUZyYW1lXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtyZWZOb2RlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kb3NUcmFuc2Zvcm1hYmxlcyA9IFtyZWZOb2RlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNpIGHDum4gbm8gaGF5IG5vZG9zIChpbWFnZW4gY2FyZ2FuZG8sIGV0Yy4pLCBOTyBkZXNwZWdhciAoZXZpdGEgcGFycGFkZW8pXG4gICAgaWYgKG5vZG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBUUkRCRyhcIkVGRkVDVCBleGl0OiBubyBub2RlcyB5ZXRcIiwge1xuICAgICAgICBzZWxLZXksXG4gICAgICAgIHdhbnRlZElkczogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubWFwKG8gPT4gby5pZCksXG4gICAgICAgIHJlZnNQcmVzZW50OiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5tYXAobyA9PiAhIWVsZW1lbnRSZWZzLmN1cnJlbnQ/LltvLmlkXSksXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIEF0dGFjaCBlc3RhYmxlXG4gICAgVFJEQkcoXCJBVFRBQ0ggdHJ5XCIsIHtcbiAgICAgIHNlbEtleSxcbiAgICAgIG5vZGVzQ291bnQ6IG5vZG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoLFxuICAgICAgbm9kZUlkczogbm9kb3NUcmFuc2Zvcm1hYmxlcy5tYXAobiA9PiAodHlwZW9mIG4uaWQgPT09IFwiZnVuY3Rpb25cIiA/IG4uaWQoKSA6IG4uYXR0cnM/LmlkKSksXG4gICAgfSk7XG5cbiAgICB0ci5ub2Rlcyhub2Rvc1RyYW5zZm9ybWFibGVzKTtcblxuICAgIFRSREJHKFwiQVRUQUNIIGRvbmVcIiwge1xuICAgICAgc2VsS2V5LFxuICAgICAgdHJOb2Rlc0NvdW50OiB0ci5ub2Rlcz8uKCk/Lmxlbmd0aCB8fCAwLFxuICAgIH0pO1xuXG4gICAgdHJ5IHsgdHIuZm9yY2VVcGRhdGU/LigpOyB9IGNhdGNoIHsgfVxuICAgIHRyLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xuXG4gIH0sIFtcbiAgICAvLyBEZXBlbmRlbmNpYXMgbcOtbmltYXMgcmVhbGVzXG4gICAgc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcbiAgICBkZWJlcmlhVXNhclRyYW5zZm9ybWVyLFxuICAgIGhhc0dhbGxlcnksXG4gICAgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoLFxuICAgIHNlbGVjdGVkR2VvbUtleSxcbiAgICB0cmFuc2Zvcm1UaWNrLFxuICAgIGVsZW1lbnRSZWZzLFxuICBdKTtcblxuXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gZT8uZGV0YWlsPy5pZDtcbiAgICAgIGlmICghaWQpIHJldHVybjtcblxuICAgICAgVFJEQkcoXCJSRUYgZXZlbnRcIiwge1xuICAgICAgICBpZCxcbiAgICAgICAgaXNTZWxlY3RlZDogc2VsZWN0ZWRFbGVtZW50cy5pbmNsdWRlcyhpZCksXG4gICAgICAgIHNlbEtleTogc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudHMuaW5jbHVkZXMoaWQpKSByZXR1cm47XG4gICAgICBzZXRUcmFuc2Zvcm1UaWNrKHQgPT4gdCArIDEpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVsZW1lbnQtcmVmLXJlZ2lzdHJhZG9cIiwgaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZWxlbWVudC1yZWYtcmVnaXN0cmFkb1wiLCBoYW5kbGVyKTtcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIildKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZpcnN0SWQgPSBzZWxlY3RlZEVsZW1lbnRzPy5bMF07XG4gICAgaWYgKCFmaXJzdElkKSByZXR1cm47XG5cbiAgICBjb25zdCBmaXJzdE5vZGUgPSBlbGVtZW50UmVmcy5jdXJyZW50Py5bZmlyc3RJZF07XG4gICAgY29uc3Qgc3RhZ2UgPSBmaXJzdE5vZGU/LmdldFN0YWdlPy4oKTtcbiAgICBpZiAoIXN0YWdlKSByZXR1cm47XG5cbiAgICBsZXQgcmFmSWQgPSBudWxsO1xuICAgIGNvbnN0IHN5bmNUcmFuc2Zvcm1lciA9ICgpID0+IHtcbiAgICAgIGlmIChyYWZJZCAhPSBudWxsKSByZXR1cm47XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHJhZklkID0gbnVsbDtcbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXRyKSByZXR1cm47XG4gICAgICAgIHRyeSB7IHRyLmZvcmNlVXBkYXRlPy4oKTsgfSBjYXRjaCB7IH1cbiAgICAgICAgdHIuZ2V0TGF5ZXI/LigpPy5iYXRjaERyYXc/LigpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHN0YWdlLm9uKFwiZHJhZ21vdmVcIiwgc3luY1RyYW5zZm9ybWVyKTtcbiAgICBzdGFnZS5vbihcImRyYWdlbmRcIiwgc3luY1RyYW5zZm9ybWVyKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdGFnZS5vZmYoXCJkcmFnbW92ZVwiLCBzeW5jVHJhbnNmb3JtZXIpO1xuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ2VuZFwiLCBzeW5jVHJhbnNmb3JtZXIpO1xuICAgICAgaWYgKHJhZklkICE9IG51bGwpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSwgZWxlbWVudFJlZnNdKTtcblxuXG5cblxuICAvLyDwn5SlIFJlbmRlclxuXG4gIGlmIChzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGhheUxpbmVhcyAmJiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEJvdW5kc0luZGljYXRvclxuICAgICAgICBzZWxlY3RlZEVsZW1lbnRzPXtzZWxlY3RlZEVsZW1lbnRzfVxuICAgICAgICBlbGVtZW50UmVmcz17ZWxlbWVudFJlZnN9XG4gICAgICAgIG9iamV0b3M9e29iamV0b3N9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICBpZiAoaGF5TGluZWFzICYmIGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEJvdW5kc0luZGljYXRvclxuICAgICAgICBzZWxlY3RlZEVsZW1lbnRzPXtzZWxlY3RlZEVsZW1lbnRzfVxuICAgICAgICBlbGVtZW50UmVmcz17ZWxlbWVudFJlZnN9XG4gICAgICAgIG9iamV0b3M9e29iamV0b3N9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxUcmFuc2Zvcm1lclxuICAgICAgbmFtZT1cInVpXCJcbiAgICAgIHJlZj17dHJhbnNmb3JtZXJSZWZ9XG5cbiAgICAgIC8vIPCflLUgYm9yZGUgc2llbXByZSB2aXNpYmxlXG4gICAgICBib3JkZXJFbmFibGVkPXt0cnVlfVxuXG4gICAgICBib3JkZXJTdHJva2U9XCIjOTMzM0VBXCJcblxuXG4gICAgICBib3JkZXJTdHJva2VXaWR0aD17dHJhbnNmb3JtZXJCb3JkZXJTdHJva2VXaWR0aH1cbiAgICAgIHBhZGRpbmc9e3RyYW5zZm9ybWVyUGFkZGluZ31cblxuICAgICAgLy8g4p2MIG5vZG9zIHkgcm90YWNpw7NuIE9GRiBkdXJhbnRlIGRyYWdcbiAgICAgIGVuYWJsZWRBbmNob3JzPXtpc0RyYWdnaW5nID8gW10gOiBbXCJib3R0b20tcmlnaHRcIl19XG4gICAgICByb3RhdGVFbmFibGVkPXshaXNEcmFnZ2luZyAmJiAhZXNHYWxlcmlhfVxuXG4gICAgICBhbmNob3JGaWxsPVwiIzkzMzNFQVwiXG4gICAgICBhbmNob3JTdHJva2U9XCIjZmZmZmZmXCJcbiAgICAgIGFuY2hvclN0cm9rZVdpZHRoPXt0cmFuc2Zvcm1lckFuY2hvclN0cm9rZVdpZHRofVxuICAgICAgYW5jaG9yU2l6ZT17dHJhbnNmb3JtZXJBbmNob3JTaXplfVxuICAgICAgYW5jaG9yQ29ybmVyUmFkaXVzPXt0cmFuc2Zvcm1lckFuY2hvclJhZGl1c31cbiAgICAgIGFuY2hvclNoYWRvd0NvbG9yPVwicmdiYSgxNDcsIDUxLCAyMzQsIDAuMylcIlxuICAgICAgYW5jaG9yU2hhZG93Qmx1cj17dHJhbnNmb3JtZXJBbmNob3JTaGFkb3dCbHVyfVxuICAgICAgYW5jaG9yU2hhZG93T2Zmc2V0PXt7IHg6IDAsIHk6IHRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSB9fVxuICAgICAga2VlcFJhdGlvPXtsb2NrQXNwZWN0Q291bnRkb3duIHx8IGVzR2FsZXJpYSB8fCBsb2NrQXNwZWN0VGV4dH1cbiAgICAgIGNlbnRlcmVkU2NhbGluZz17c2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZXNUZXh0b31cbiAgICAgIGZsaXBFbmFibGVkPXtmYWxzZX1cbiAgICAgIHJlc2l6ZUVuYWJsZWQ9eyFpc0RyYWdnaW5nfVxuICAgICAgcm90YXRpb25TbmFwcz17WzAsIDQ1LCA5MCwgMTM1LCAxODAsIDIyNSwgMjcwLCAzMTVdfVxuICAgICAgcm90YXRlQW5jaG9yT2Zmc2V0PXt0cmFuc2Zvcm1lclJvdGF0ZU9mZnNldH1cbiAgICAgIHJvdGF0aW9uU25hcFRvbGVyYW5jZT17dHJhbnNmb3JtZXJSb3RhdGlvblNuYXBUb2xlcmFuY2V9XG4gICAgICBib3VuZEJveEZ1bmM9eyhvbGRCb3gsIG5ld0JveCkgPT4ge1xuICAgICAgICBjb25zdCBtaW5TaXplID0gZXNUZXh0byA/IDIwIDogMTA7XG4gICAgICAgIGNvbnN0IG1heFNpemUgPSA4MDA7XG4gICAgICAgIGlmIChlc0dhbGVyaWEpIHtcbiAgICAgICAgICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgTnVtYmVyKHByaW1lckVsZW1lbnRvPy5yb3dzKSB8fCAxKTtcbiAgICAgICAgICBjb25zdCBjb2xzID0gTWF0aC5tYXgoMSwgTnVtYmVyKHByaW1lckVsZW1lbnRvPy5jb2xzKSB8fCAxKTtcbiAgICAgICAgICBjb25zdCBnYXAgPSBNYXRoLm1heCgwLCBOdW1iZXIocHJpbWVyRWxlbWVudG8/LmdhcCkgfHwgMCk7XG4gICAgICAgICAgY29uc3QgY2VsbFJhdGlvID1cbiAgICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5yYXRpbyA9PT0gXCI0OjNcIlxuICAgICAgICAgICAgICA/IDMgLyA0XG4gICAgICAgICAgICAgIDogcHJpbWVyRWxlbWVudG8/LnJhdGlvID09PSBcIjE2OjlcIlxuICAgICAgICAgICAgICAgID8gOSAvIDE2XG4gICAgICAgICAgICAgICAgOiAxO1xuXG4gICAgICAgICAgY29uc3QgbWluR3JpZFdpZHRoID0gZ2FwICogKGNvbHMgLSAxKSArIGNvbHM7XG4gICAgICAgICAgY29uc3QgbmV4dFdpZHRoID0gTWF0aC5taW4oXG4gICAgICAgICAgICBtYXhTaXplLFxuICAgICAgICAgICAgTWF0aC5tYXgobWluU2l6ZSwgbWluR3JpZFdpZHRoLCBNYXRoLmFicyhuZXdCb3gud2lkdGgpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgY2VsbFcgPSBNYXRoLm1heCgxLCAobmV4dFdpZHRoIC0gZ2FwICogKGNvbHMgLSAxKSkgLyBjb2xzKTtcbiAgICAgICAgICBjb25zdCBjZWxsSCA9IGNlbGxXICogY2VsbFJhdGlvO1xuICAgICAgICAgIGNvbnN0IG5leHRIZWlnaHQgPSByb3dzICogY2VsbEggKyBnYXAgKiAocm93cyAtIDEpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld0JveCxcbiAgICAgICAgICAgIHdpZHRoOiBuZXh0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KG1pblNpemUsIG5leHRIZWlnaHQpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3Qm94LndpZHRoIDwgbWluU2l6ZSB8fCBuZXdCb3guaGVpZ2h0IDwgbWluU2l6ZSkge1xuICAgICAgICAgIHJldHVybiBvbGRCb3g7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9ja0FzcGVjdENvdW50ZG93bikge1xuICAgICAgICAgIGNvbnN0IGJhc2VXID0gTWF0aC5tYXgoMSwgb2xkQm94LndpZHRoKTtcbiAgICAgICAgICBjb25zdCBiYXNlSCA9IE1hdGgubWF4KDEsIG9sZEJveC5oZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gYmFzZVcgLyBiYXNlSDtcblxuICAgICAgICAgIGNvbnN0IGR3ID0gTWF0aC5hYnMobmV3Qm94LndpZHRoIC0gb2xkQm94LndpZHRoKSAvIGJhc2VXO1xuICAgICAgICAgIGNvbnN0IGRoID0gTWF0aC5hYnMobmV3Qm94LmhlaWdodCAtIG9sZEJveC5oZWlnaHQpIC8gYmFzZUg7XG5cbiAgICAgICAgICBsZXQgd2lkdGggPSBuZXdCb3gud2lkdGg7XG4gICAgICAgICAgbGV0IGhlaWdodCA9IG5ld0JveC5oZWlnaHQ7XG5cbiAgICAgICAgICBpZiAoZGggPiBkdykge1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiByYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyByYXRpbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubmV3Qm94LFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBtaW5TaXplKSwgbWF4U2l6ZSksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKE1hdGgubWF4KGhlaWdodCwgbWluU2l6ZSksIG1heFNpemUpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZm9ybWFcIiAmJlxuICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KG5ld0JveC53aWR0aCwgbmV3Qm94LmhlaWdodCk7XG4gICAgICAgICAgY29uc3QgZmluYWxTaXplID0gTWF0aC5taW4oc2l6ZSwgbWF4U2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld0JveCxcbiAgICAgICAgICAgIHdpZHRoOiBmaW5hbFNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IGZpbmFsU2l6ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVzVHJpYW5ndWxvKSB7XG4gICAgICAgICAgY29uc3Qgc2FmZU9sZFcgPSBNYXRoLm1heCgxLCBNYXRoLmFicyhvbGRCb3gud2lkdGggfHwgbWluU2l6ZSkpO1xuICAgICAgICAgIGNvbnN0IHNhZmVPbGRIID0gTWF0aC5tYXgoMSwgTWF0aC5hYnMob2xkQm94LmhlaWdodCB8fCBtaW5TaXplKSk7XG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMobmV3Qm94LndpZHRoKSAvIHNhZmVPbGRXO1xuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IE1hdGguYWJzKG5ld0JveC5oZWlnaHQpIC8gc2FmZU9sZEg7XG4gICAgICAgICAgY29uc3QgdW5pZm9ybVNjYWxlID0gTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKTtcblxuICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoc2FmZU9sZFcgKiB1bmlmb3JtU2NhbGUsIG1pblNpemUpLCBtYXhTaXplKTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChzYWZlT2xkSCAqIHVuaWZvcm1TY2FsZSwgbWluU2l6ZSksIG1heFNpemUpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld0JveCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiaW1hZ2VuXCIgfHxcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJpY29ub1wiXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IG5ld0JveC53aWR0aCAvIG9sZEJveC53aWR0aDtcbiAgICAgICAgICBjb25zdCBzY2FsZVkgPSBuZXdCb3guaGVpZ2h0IC8gb2xkQm94LmhlaWdodDtcbiAgICAgICAgICBjb25zdCB1bmlmb3JtU2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG5cbiAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IG9sZEJveC53aWR0aCAqIHVuaWZvcm1TY2FsZTtcbiAgICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBvbGRCb3guaGVpZ2h0ICogdW5pZm9ybVNjYWxlO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld0JveCxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihNYXRoLm1heChuZXdXaWR0aCwgbWluU2l6ZSksIG1heFNpemUpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihNYXRoLm1heChuZXdIZWlnaHQsIG1pblNpemUpLCBtYXhTaXplKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdCb3gsXG4gICAgICAgICAgd2lkdGg6IE1hdGgubWluKG5ld0JveC53aWR0aCwgbWF4U2l6ZSksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihuZXdCb3guaGVpZ2h0LCBtYXhTaXplKSxcbiAgICAgICAgfTtcbiAgICAgIH19XG4gICAgICBvblRyYW5zZm9ybVN0YXJ0PXsoZSkgPT4ge1xuICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSB7IGlzUmVzaXppbmc6IHRydWUgfTtcbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBhY3RpdmVBbmNob3IgPVxuICAgICAgICAgIHR5cGVvZiB0cj8uZ2V0QWN0aXZlQW5jaG9yID09PSBcImZ1bmN0aW9uXCIgPyB0ci5nZXRBY3RpdmVBbmNob3IoKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGlzUm90YXRlR2VzdHVyZSA9XG4gICAgICAgICAgdHlwZW9mIGFjdGl2ZUFuY2hvciA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgIGFjdGl2ZUFuY2hvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicm90YXRcIik7XG4gICAgICAgIHRyYW5zZm9ybUdlc3R1cmVSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICBpc1JvdGF0ZTogaXNSb3RhdGVHZXN0dXJlLFxuICAgICAgICAgIGFjdGl2ZUFuY2hvcjogYWN0aXZlQW5jaG9yID8/IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygb25UcmFuc2Zvcm1JbnRlcmFjdGlvblN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBvblRyYW5zZm9ybUludGVyYWN0aW9uU3RhcnQoe1xuICAgICAgICAgICAgaXNSb3RhdGU6IGlzUm90YXRlR2VzdHVyZSxcbiAgICAgICAgICAgIGFjdGl2ZUFuY2hvcjogYWN0aXZlQW5jaG9yID8/IG51bGwsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogZT8uZXZ0Py5wb2ludGVyVHlwZSA/PyBudWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSB0cj8ubm9kZXM/LigpIHx8IFtdO1xuICAgICAgICAgIGNpcmNsZUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJmb3JtYVwiICYmXG4gICAgICAgICAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByMCA9IG5vZGVzWzBdLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNpcmNsZUFuY2hvclJlZi5jdXJyZW50ID0geyBsZWZ0OiByMC54LCB0b3A6IHIwLnkgfTtcbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxICYmIGVzVGV4dG8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGxldCBjZW50ZXJYID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBjZW50ZXJZID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBiYXNlV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgbGV0IGJhc2VIZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGJhc2VWaXN1YWxXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LngpICYmIE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXJYID0gcmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LnkpICYmIE51bWJlci5pc0Zpbml0ZShyZWN0Py5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyWSA9IHJlY3QueSArIChyZWN0LmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYmFzZVdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICBiYXNlVmlzdWFsV2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8uaGVpZ2h0KSAmJiByZWN0LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBiYXNlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgIGNvbnN0IHNhZmVCYXNlRm9udFNpemUgPVxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocHJpbWVyRWxlbWVudG8/LmZvbnRTaXplKSAmJiBwcmltZXJFbGVtZW50by5mb250U2l6ZSA+IDBcbiAgICAgICAgICAgICAgICA/IHByaW1lckVsZW1lbnRvLmZvbnRTaXplXG4gICAgICAgICAgICAgICAgOiAyNDtcbiAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgeTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogMCxcbiAgICAgICAgICAgICAgYmFzZVJvdGF0aW9uOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlPy5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUucm90YXRpb24oKSB8fCAwKSA6IDAsXG4gICAgICAgICAgICAgIGNlbnRlclgsXG4gICAgICAgICAgICAgIGNlbnRlclksXG4gICAgICAgICAgICAgIGJhc2VXaWR0aCxcbiAgICAgICAgICAgICAgYmFzZUhlaWdodCxcbiAgICAgICAgICAgICAgYmFzZUZvbnRTaXplOiBzYWZlQmFzZUZvbnRTaXplLFxuICAgICAgICAgICAgICBsYXN0UHJldmlld0ZvbnRTaXplOiBzYWZlQmFzZUZvbnRTaXplLFxuICAgICAgICAgICAgICBsYXN0UHJldmlld0NlbnRlclg6IGNlbnRlclgsXG4gICAgICAgICAgICAgIGxhc3RQcmV2aWV3Q2VudGVyWTogY2VudGVyWSxcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdWaXN1YWxXaWR0aDogYmFzZVZpc3VhbFdpZHRoLFxuICAgICAgICAgICAgICBwcmV2aWV3VGljazogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBUWFREQkcoXCJzdGFydFwiLCB7XG4gICAgICAgICAgICAgIGlkOiBwcmltZXJFbGVtZW50bz8uaWQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgYmFzZUZvbnRTaXplOiBzYWZlQmFzZUZvbnRTaXplLFxuICAgICAgICAgICAgICBiYXNlV2lkdGgsXG4gICAgICAgICAgICAgIGJhc2VIZWlnaHQsXG4gICAgICAgICAgICAgIGNlbnRlclgsXG4gICAgICAgICAgICAgIGNlbnRlclksXG4gICAgICAgICAgICAgIG5vZGVYOiB0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiBudWxsLFxuICAgICAgICAgICAgICBub2RlWTogdHlwZW9mIG5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogbnVsbCxcbiAgICAgICAgICAgICAgbm9kZVNjYWxlWDogdHlwZW9mIG5vZGU/LnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5vZGVTY2FsZVk6IHR5cGVvZiBub2RlPy5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdW5pb24gPSByZWN0RnJvbU5vZGVzKG5vZGVzKTtcblxuICAgICAgICAgIGNvbnN0IHBhZCA9IHR5cGVvZiB0cj8ucGFkZGluZyA9PT0gXCJmdW5jdGlvblwiID8gdHIucGFkZGluZygpIDogMDtcbiAgICAgICAgICBjb25zdCBib3JkZXJSZWN0ID0gdW5pb25cbiAgICAgICAgICAgID8geyB4OiB1bmlvbi54IC0gcGFkLCB5OiB1bmlvbi55IC0gcGFkLCB3aWR0aDogdW5pb24ud2lkdGggKyBwYWQgKiAyLCBoZWlnaHQ6IHVuaW9uLmhlaWdodCArIHBhZCAqIDIgfVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgICAgY29uc3QgbiA9IG5vZGVzWzBdO1xuICAgICAgICAgIGNvbnN0IGlkID0gbiA/ICh0eXBlb2Ygbi5pZCA9PT0gXCJmdW5jdGlvblwiID8gbi5pZCgpIDogbi5hdHRycz8uaWQpIDogXCLiiIVcIjtcbiAgICAgICAgICBjb25zdCB0clJlY3QgPSB0cj8uZ2V0Q2xpZW50UmVjdD8uKHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XG5cbiAgICAgICAgICBzbG9nKFxuICAgICAgICAgICAgXCJbVFJdIHN0YXJ0XCIsXG4gICAgICAgICAgICBgaWQ9JHtpZH1gLFxuICAgICAgICAgICAgYG5vZGVzPSR7bm9kZXMubGVuZ3RofWAsXG4gICAgICAgICAgICB1bmlvbiA/IGB1bmlvbih3PSR7dW5pb24ud2lkdGgudG9GaXhlZCgxKX0saD0ke3VuaW9uLmhlaWdodC50b0ZpeGVkKDEpfSlgIDogXCJ1bmlvbihudWxsKVwiLFxuICAgICAgICAgICAgYm9yZGVyUmVjdCA/IGBib3JkZXIodz0ke2JvcmRlclJlY3Qud2lkdGgudG9GaXhlZCgxKX0saD0ke2JvcmRlclJlY3QuaGVpZ2h0LnRvRml4ZWQoMSl9KWAgOiBcImJvcmRlcihudWxsKVwiLFxuICAgICAgICAgICAgdHJSZWN0ID8gYHRyUmVjdCh3PSR7dHJSZWN0LndpZHRoLnRvRml4ZWQoMSl9LGg9JHt0clJlY3QuaGVpZ2h0LnRvRml4ZWQoMSl9KWAgOiBcInRyUmVjdChudWxsKVwiLFxuICAgICAgICAgICAgYHBhZD0ke3BhZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7IH1cbiAgICAgIH19XG5cbiAgICAgIG9uVHJhbnNmb3JtPXsoZSkgPT4ge1xuICAgICAgICBpZiAoIW9uVHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm1lclJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBub2RlcyA9IHR5cGVvZiB0ci5ub2RlcyA9PT0gXCJmdW5jdGlvblwiID8gdHIubm9kZXMoKSB8fCBbXSA6IFtdO1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbMF07IC8vIOKchSBub2RvIHJlYWwgKHNpbmdsZSBzZWxlY3QpXG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcG9zZSA9IGdldFRyYW5zZm9ybVBvc2Uobm9kZSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtRGF0YSA9IHtcbiAgICAgICAgICAgIHg6IHBvc2UueCxcbiAgICAgICAgICAgIHk6IHBvc2UueSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBwb3NlLnJvdGF0aW9uLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiB0cnVlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoZXNUZXh0bykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHByaW1lckVsZW1lbnRvLmZvbnRTaXplIHx8IDI0O1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JEYXRhID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50IHx8IG51bGw7XG4gICAgICAgICAgICBjb25zdCBiYXNlRm9udFNpemUgPVxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8uYmFzZUZvbnRTaXplKSAmJlxuICAgICAgICAgICAgICBhbmNob3JEYXRhLmJhc2VGb250U2l6ZSA+IDBcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEuYmFzZUZvbnRTaXplXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEZvbnRTaXplO1xuXG4gICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHNjYWxlRnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGxpdmVSZWN0V2lkdGggPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFJvdGF0aW9uID1cbiAgICAgICAgICAgICAgdHlwZW9mIG5vZGUucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnJvdGF0aW9uKCkgfHwgMCkgOiAwO1xuICAgICAgICAgICAgY29uc3QgYmFzZVJvdGF0aW9uID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VSb3RhdGlvbik7XG4gICAgICAgICAgICBjb25zdCByb3RhdGlvbkRlbHRhID0gTnVtYmVyLmlzRmluaXRlKGJhc2VSb3RhdGlvbilcbiAgICAgICAgICAgICAgPyBNYXRoLmFicyhjdXJyZW50Um90YXRpb24gLSBiYXNlUm90YXRpb24pXG4gICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGl2ZVJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYmFzZVdpZHRoID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VXaWR0aCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYmFzZVdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIGJhc2VXaWR0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA+IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCA9IHJlY3Qud2lkdGggLyBiYXNlV2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgIGNvbnN0IGNhblVzZVJlY3RTY2FsZSA9IHJvdGF0aW9uRGVsdGEgPCAwLjE7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVTY2FsZSA9XG4gICAgICAgICAgICAgIGNhblVzZVJlY3RTY2FsZSAmJiBOdW1iZXIuaXNGaW5pdGUoc2NhbGVGcm9tUmVjdCkgJiYgc2NhbGVGcm9tUmVjdCA+IDBcbiAgICAgICAgICAgICAgICA/IHNjYWxlRnJvbVJlY3RcbiAgICAgICAgICAgICAgICA6IGF2Z1NjYWxlO1xuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5mb250U2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICBOdW1iZXIoKGJhc2VGb250U2l6ZSAqIGVmZmVjdGl2ZVNjYWxlKS50b0ZpeGVkKDMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGljayA9IE51bWJlcih0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQucHJldmlld1RpY2sgfHwgMCkgKyAxO1xuICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQucHJldmlld1RpY2sgPSB0aWNrO1xuICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdGb250U2l6ZSA9IHRyYW5zZm9ybURhdGEuZm9udFNpemU7XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobGl2ZVJlY3RXaWR0aCkgJiYgbGl2ZVJlY3RXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdWaXN1YWxXaWR0aCA9IGxpdmVSZWN0V2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRpY2sgPD0gMiB8fCB0aWNrICUgNSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIFRYVERCRyhcInByZXZpZXdcIiwge1xuICAgICAgICAgICAgICAgICAgaWQ6IHByaW1lckVsZW1lbnRvPy5pZCA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgdGljayxcbiAgICAgICAgICAgICAgICAgIHNjYWxlWCxcbiAgICAgICAgICAgICAgICAgIHNjYWxlWSxcbiAgICAgICAgICAgICAgICAgIGF2Z1NjYWxlLFxuICAgICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCxcbiAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVNjYWxlLFxuICAgICAgICAgICAgICAgICAgYmFzZUZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHRyYW5zZm9ybURhdGEuZm9udFNpemUsXG4gICAgICAgICAgICAgICAgICBsaXZlUmVjdFdpZHRoLFxuICAgICAgICAgICAgICAgICAgY2VudGVyWFRhcmdldDogdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py5jZW50ZXJYID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICBub2RlWDogdHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5vZGVZOiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWCA9IDE7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpZiAoY2FuVXNlUmVjdFNjYWxlICYmIE51bWJlci5pc0Zpbml0ZSh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LnkpKSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueSA9IHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LmNlbnRlclgpKSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudGV4dENlbnRlclggPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQuY2VudGVyWDtcbiAgICAgICAgICAgICAgaWYgKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld0NlbnRlclggPVxuICAgICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py5jZW50ZXJZKSkge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRleHRDZW50ZXJZID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclk7XG4gICAgICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdDZW50ZXJZID1cbiAgICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5jZW50ZXJZO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IHR5cGVvZiBub2RlLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVgoKSA6IDE7XG4gICAgICAgICAgICBjb25zdCBzY2FsZVkgPSB0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVZKCkgOiAxO1xuXG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVZID0gc2NhbGVZO1xuXG4gICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiY291bnRkb3duXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgY291bnRkb3duU2l6ZSA9IGdldENvdW50ZG93blNjYWxlZFNpemUobm9kZSk7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEud2lkdGggPSBjb3VudGRvd25TaXplLndpZHRoO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLmhlaWdodCA9IGNvdW50ZG93blNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlc1RyaWFuZ3Vsbykge1xuICAgICAgICAgICAgICBjb25zdCBiYXNlUmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKHByaW1lckVsZW1lbnRvPy5yYWRpdXMpXG4gICAgICAgICAgICAgICAgPyBwcmltZXJFbGVtZW50by5yYWRpdXNcbiAgICAgICAgICAgICAgICA6IDYwO1xuICAgICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnJhZGl1cyA9IE1hdGgubWF4KDEsIGJhc2VSYWRpdXMgKiBhdmdTY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gcHJpbWVyRWxlbWVudG8ud2lkdGggfHwgMTAwO1xuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHByaW1lckVsZW1lbnRvLmhlaWdodCB8fCAxMDA7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEud2lkdGggPSBNYXRoLmFicyhvcmlnaW5hbFdpZHRoICogc2NhbGVYKTtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5oZWlnaHQgPSBNYXRoLmFicyhvcmlnaW5hbEhlaWdodCAqIHNjYWxlWSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGl2ZVJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWFtZXRlciA9IE1hdGgubWF4KDEsIE1hdGgubWF4KGxpdmVSZWN0LndpZHRoLCBsaXZlUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnJhZGl1cyA9IGRpYW1ldGVyIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBjaXJjbGVBbmNob3JSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnggPSBhbmNob3IubGVmdCArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS55ID0gYW5jaG9yLnRvcCArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnggPSBsaXZlUmVjdC54ICsgdHJhbnNmb3JtRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnkgPSBsaXZlUmVjdC55ICsgdHJhbnNmb3JtRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb25UcmFuc2Zvcm0odHJhbnNmb3JtRGF0YSk7XG5cbiAgICAgICAgICAvLyAtLS0gTE9HIENPTVBBQ1RPIChvcGNpb25hbCkgLS0tXG4gICAgICAgICAgY29uc3QgaWQgPSAodHlwZW9mIG5vZGUuaWQgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuaWQoKSA6IG5vZGUuYXR0cnM/LmlkKSB8fCBcIuKIhVwiO1xuICAgICAgICAgIGNvbnN0IHN4ID0gbm9kZS5zY2FsZVg/LigpID8/IDE7XG4gICAgICAgICAgY29uc3Qgc3kgPSBub2RlLnNjYWxlWT8uKCkgPz8gMTtcbiAgICAgICAgICBjb25zdCByID0gbm9kZS5nZXRDbGllbnRSZWN0KHsgc2tpcFRyYW5zZm9ybTogZmFsc2UsIHNraXBTaGFkb3c6IHRydWUsIHNraXBTdHJva2U6IHRydWUgfSk7XG4gICAgICAgICAgc2xvZyhcbiAgICAgICAgICAgIFwiW1RSXSBsaXZlXCIsXG4gICAgICAgICAgICBgaWQ9JHtpZH1gLFxuICAgICAgICAgICAgYHRpcG89JHtwcmltZXJFbGVtZW50bz8udGlwbyB8fCBcIuKIhVwifWAsXG4gICAgICAgICAgICBgc3g9JHtzeC50b0ZpeGVkKDMpfWAsXG4gICAgICAgICAgICBgc3k9JHtzeS50b0ZpeGVkKDMpfWAsXG4gICAgICAgICAgICBgeD0keyhub2RlLng/LigpID8/IDApLnRvRml4ZWQoMSl9YCxcbiAgICAgICAgICAgIGB5PSR7KG5vZGUueT8uKCkgPz8gMCkudG9GaXhlZCgxKX1gLFxuICAgICAgICAgICAgYG5vZGVSZWN0KHc9JHtyLndpZHRoLnRvRml4ZWQoMSl9LGg9JHtyLmhlaWdodC50b0ZpeGVkKDEpfSlgLFxuICAgICAgICAgICAgYHc9JHt0cmFuc2Zvcm1EYXRhLndpZHRoID8/IFwi4oiFXCJ9YCxcbiAgICAgICAgICAgIGBoPSR7dHJhbnNmb3JtRGF0YS5oZWlnaHQgPz8gXCLiiIVcIn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBlbiBvblRyYW5zZm9ybTpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9fVxuICAgICAgb25UcmFuc2Zvcm1FbmQ9eyhlKSA9PiB7XG4gICAgICAgIGlmICghdHJhbnNmb3JtZXJSZWYuY3VycmVudCB8fCAhb25UcmFuc2Zvcm0pIHJldHVybjtcblxuICAgICAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdHlwZW9mIHRyLm5vZGVzID09PSBcImZ1bmN0aW9uXCIgPyB0ci5ub2RlcygpIHx8IFtdIDogW107XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBNVUxUSS1TRUxFQ0NJw5NOXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdFNjYWxlWCA9IHR5cGVvZiB0ci5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IHRyLnNjYWxlWCgpIHx8IDEgOiAxO1xuICAgICAgICAgICAgY29uc3QgdFNjYWxlWSA9IHR5cGVvZiB0ci5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IHRyLnNjYWxlWSgpIHx8IDEgOiAxO1xuICAgICAgICAgICAgY29uc3QgYXZnID0gKE1hdGguYWJzKHRTY2FsZVgpICsgTWF0aC5hYnModFNjYWxlWSkpIC8gMjtcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5vZGVzXG4gICAgICAgICAgICAgIC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZCA9ICh0eXBlb2Ygbi5pZCA9PT0gXCJmdW5jdGlvblwiID8gbi5pZCgpIDogbi5hdHRycz8uaWQpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7IH1cbiAgICAgICAgICAgICAgICBpZiAoIWlkKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IChvYmpldG9zIHx8IFtdKS5maW5kKChvKSA9PiBvLmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkID0ge1xuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICB4OiB0eXBlb2Ygbi54ID09PSBcImZ1bmN0aW9uXCIgPyBuLngoKSA6IG9iai54LFxuICAgICAgICAgICAgICAgICAgeTogdHlwZW9mIG4ueSA9PT0gXCJmdW5jdGlvblwiID8gbi55KCkgOiBvYmoueSxcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0eXBlb2Ygbi5yb3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gbi5yb3RhdGlvbigpIHx8IDAgOiAob2JqLnJvdGF0aW9uIHx8IDApLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwidGV4dG9cIikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IG9iai5mb250U2l6ZSB8fCAyNDtcbiAgICAgICAgICAgICAgICAgIHVwZC5mb250U2l6ZSA9IE1hdGgubWF4KDYsIE1hdGgucm91bmQoYmFzZSAqIGF2ZykpO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVIgPSBvYmoucmFkaXVzIHx8IDUwO1xuICAgICAgICAgICAgICAgICAgdXBkLnJhZGl1cyA9IGJhc2VSICogYXZnO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJ0cmlhbmdsZVwiKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUiA9IG9iai5yYWRpdXMgfHwgNjA7XG4gICAgICAgICAgICAgICAgICB1cGQucmFkaXVzID0gTWF0aC5tYXgoMSwgYmFzZVIgKiBhdmcpO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWSgxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcImNvdW50ZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjb3VudGRvd25TaXplID0gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShuKTtcbiAgICAgICAgICAgICAgICAgIHVwZC53aWR0aCA9IGNvdW50ZG93blNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICB1cGQuaGVpZ2h0ID0gY291bnRkb3duU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VXID1cbiAgICAgICAgICAgICAgICAgIG9iai53aWR0aCAhPSBudWxsID8gb2JqLndpZHRoIDogKHR5cGVvZiBuLndpZHRoID09PSBcImZ1bmN0aW9uXCIgPyBuLndpZHRoKCkgOiAxMDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VIID1cbiAgICAgICAgICAgICAgICAgIG9iai5oZWlnaHQgIT0gbnVsbCA/IG9iai5oZWlnaHQgOiAodHlwZW9mIG4uaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIgPyBuLmhlaWdodCgpIDogMTAwKTtcblxuICAgICAgICAgICAgICAgIHVwZC53aWR0aCA9IE1hdGguYWJzKGJhc2VXICogdFNjYWxlWCk7XG4gICAgICAgICAgICAgICAgdXBkLmhlaWdodCA9IE1hdGguYWJzKGJhc2VIICogdFNjYWxlWSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG4uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIG4uc2NhbGVYKDEpO1xuICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1cGQ7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgICAgICAgIG9uVHJhbnNmb3JtKHsgaXNGaW5hbDogdHJ1ZSwgYmF0Y2g6IHVwZGF0ZXMgfSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHIuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdHIuc2NhbGVYKDEpO1xuICAgICAgICAgICAgICB0ci5zY2FsZVkoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcblxuICAgICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0geyBpc1Jlc2l6aW5nOiBmYWxzZSB9O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBlbiBvblRyYW5zZm9ybUVuZCAobXVsdGkpOlwiLCBlcnIpO1xuICAgICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNJTkdMRS1TRUxFQ0NJw5NOXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBvc2UgPSBnZXRUcmFuc2Zvcm1Qb3NlKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IGZpbmFsRGF0YSA9IHtcbiAgICAgICAgICAgIHg6IHBvc2UueCxcbiAgICAgICAgICAgIHk6IHBvc2UueSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBwb3NlLnJvdGF0aW9uLFxuICAgICAgICAgICAgaXNGaW5hbDogdHJ1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCB0ZXh0UHJldmlld0VuZFNuYXBzaG90ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChlc1RleHRvKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcHJpbWVyRWxlbWVudG8uZm9udFNpemUgfHwgMjQ7XG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvckRhdGEgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VGb250U2l6ZSA9XG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5iYXNlRm9udFNpemUpICYmXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEuYmFzZUZvbnRTaXplID4gMFxuICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5iYXNlRm9udFNpemVcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRm9udFNpemU7XG4gICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHNjYWxlRnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHZpc3VhbFdpZHRoRnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFJvdGF0aW9uID1cbiAgICAgICAgICAgICAgdHlwZW9mIG5vZGUucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IChub2RlLnJvdGF0aW9uKCkgfHwgMCkgOiAwO1xuICAgICAgICAgICAgY29uc3QgYmFzZVJvdGF0aW9uID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VSb3RhdGlvbik7XG4gICAgICAgICAgICBjb25zdCByb3RhdGlvbkRlbHRhID0gTnVtYmVyLmlzRmluaXRlKGJhc2VSb3RhdGlvbilcbiAgICAgICAgICAgICAgPyBNYXRoLmFicyhjdXJyZW50Um90YXRpb24gLSBiYXNlUm90YXRpb24pXG4gICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsV2lkdGhGcm9tUmVjdCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYmFzZVdpZHRoID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VXaWR0aCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYmFzZVdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIGJhc2VXaWR0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA+IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCA9IHJlY3Qud2lkdGggLyBiYXNlV2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgIGNvbnN0IGNhblVzZVJlY3RTY2FsZSA9IHJvdGF0aW9uRGVsdGEgPCAwLjE7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVTY2FsZSA9XG4gICAgICAgICAgICAgIGNhblVzZVJlY3RTY2FsZSAmJiBOdW1iZXIuaXNGaW5pdGUoc2NhbGVGcm9tUmVjdCkgJiYgc2NhbGVGcm9tUmVjdCA+IDBcbiAgICAgICAgICAgICAgICA/IHNjYWxlRnJvbVJlY3RcbiAgICAgICAgICAgICAgICA6IGF2Z1NjYWxlO1xuXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgIE51bWJlcigoYmFzZUZvbnRTaXplICogZWZmZWN0aXZlU2NhbGUpLnRvRml4ZWQoMykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluYWxEYXRhLmZvbnRTaXplID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgIE51bWJlcihcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdGb250U2l6ZSkgJiZcbiAgICAgICAgICAgICAgICAgIGFuY2hvckRhdGEubGFzdFByZXZpZXdGb250U2l6ZSA+IDBcbiAgICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5sYXN0UHJldmlld0ZvbnRTaXplXG4gICAgICAgICAgICAgICAgICA6IGNvbXB1dGVkRm9udFNpemVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSAxO1xuICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpZiAoY2FuVXNlUmVjdFNjYWxlICYmIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy55KSkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IGFuY2hvckRhdGEueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdDZW50ZXJYKSkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclggPSBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Q2VudGVyWDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmNlbnRlclgpKSB7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA9IGFuY2hvckRhdGEuY2VudGVyWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdDZW50ZXJZKSkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclkgPSBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Q2VudGVyWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmNlbnRlclkpKSB7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWSA9IGFuY2hvckRhdGEuY2VudGVyWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbFdpZHRoID1cbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3VmlzdWFsV2lkdGgpICYmXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEubGFzdFByZXZpZXdWaXN1YWxXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEubGFzdFByZXZpZXdWaXN1YWxXaWR0aFxuICAgICAgICAgICAgICAgIDogdmlzdWFsV2lkdGhGcm9tUmVjdDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmlzdWFsV2lkdGgpICYmIHZpc3VhbFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dFZpc3VhbFdpZHRoID0gdmlzdWFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0UHJldmlld0VuZFNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXG4gICAgICAgICAgICAgIHg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXG4gICAgICAgICAgICAgIHk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXG4gICAgICAgICAgICAgIHNjYWxlWCxcbiAgICAgICAgICAgICAgc2NhbGVZLFxuICAgICAgICAgICAgICBmb250U2l6ZTogdHlwZW9mIG5vZGU/LmZvbnRTaXplID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLmZvbnRTaXplKCkgOiBudWxsLFxuICAgICAgICAgICAgICByZWN0V2lkdGg6IE51bWJlci5pc0Zpbml0ZSh2aXN1YWxXaWR0aEZyb21SZWN0KSA/IHZpc3VhbFdpZHRoRnJvbVJlY3QgOiBudWxsLFxuICAgICAgICAgICAgICByZWN0SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY3RGb3JTbmFwc2hvdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Rm9yU25hcHNob3Q/LmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQgPSByZWN0Rm9yU25hcHNob3QuaGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgICBUWFREQkcoXCJlbmRcIiwge1xuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXG4gICAgICAgICAgICAgIHNjYWxlWCxcbiAgICAgICAgICAgICAgc2NhbGVZLFxuICAgICAgICAgICAgICBhdmdTY2FsZSxcbiAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCxcbiAgICAgICAgICAgICAgZWZmZWN0aXZlU2NhbGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkRm9udFNpemUsXG4gICAgICAgICAgICAgIGZpbmFsRm9udFNpemU6IGZpbmFsRGF0YS5mb250U2l6ZSxcbiAgICAgICAgICAgICAgdGV4dENlbnRlclg6IGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA/PyBudWxsLFxuICAgICAgICAgICAgICB0ZXh0Q2VudGVyWTogZmluYWxEYXRhLnRleHRDZW50ZXJZID8/IG51bGwsXG4gICAgICAgICAgICAgIHRleHRWaXN1YWxXaWR0aDogZmluYWxEYXRhLnRleHRWaXN1YWxXaWR0aCA/PyBudWxsLFxuICAgICAgICAgICAgICBub2RlUmVjdFdpZHRoOiB2aXN1YWxXaWR0aEZyb21SZWN0LFxuICAgICAgICAgICAgICBub2RlWDogdHlwZW9mIG5vZGU/LnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgbm9kZVk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXBsYW5hciBlc2NhbGEgZGVsIHRleHRvIGVuIGVsIHJlbGVhc2UgcGFyYSBldml0YXIgZG9ibGUgZXNjYWxhZG9cbiAgICAgICAgICAgIC8vIChlc2NhbGEgZGVsIG5vZG8gKyBmb250U2l6ZSBwZXJzaXN0aWRvKS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikgbm9kZS5zY2FsZVgoMSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIikgbm9kZS5zY2FsZVkoMSk7XG5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmaW5hbERhdGEuZm9udFNpemUpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUuZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBub2RlLmZvbnRTaXplKGZpbmFsRGF0YS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2VudGVyWCA9IE51bWJlcihmaW5hbERhdGEudGV4dENlbnRlclgpO1xuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDZW50ZXJZID0gTnVtYmVyKGZpbmFsRGF0YS50ZXh0Q2VudGVyWSk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoTnVtYmVyLmlzRmluaXRlKHRhcmdldENlbnRlclgpIHx8IE51bWJlci5pc0Zpbml0ZSh0YXJnZXRDZW50ZXJZKSkgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS54ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS55ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZFJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkQ2VudGVyWCA9XG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRSZWN0Py54KSAmJlxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkUmVjdD8ud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgPyBmbGF0dGVuZWRSZWN0LnggKyAoZmxhdHRlbmVkUmVjdC53aWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkQ2VudGVyWSA9XG4gICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRSZWN0Py55KSAmJlxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkUmVjdD8uaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgID8gZmxhdHRlbmVkUmVjdC55ICsgKGZsYXR0ZW5lZFJlY3QuaGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZmxhdHRlbmVkQ2VudGVyWCkgJiYgTnVtYmVyLmlzRmluaXRlKHRhcmdldENlbnRlclgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUueChub2RlLngoKSArICh0YXJnZXRDZW50ZXJYIC0gZmxhdHRlbmVkQ2VudGVyWCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmbGF0dGVuZWRDZW50ZXJZKSAmJiBOdW1iZXIuaXNGaW5pdGUodGFyZ2V0Q2VudGVyWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS55KG5vZGUueSgpICsgKHRhcmdldENlbnRlclkgLSBmbGF0dGVuZWRDZW50ZXJZKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbm9kZS5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBhcGxhbmFuZG8gZXNjYWxhIGRlIHRleHRvIChzeW5jKTpcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjYW5Vc2VSZWN0U2NhbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBmaW5hbERhdGEueCA9IG5vZGUueCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZmluYWxEYXRhLnkgPSBub2RlLnkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXJhIHRleHRvIGV2aXRhbW9zIGFwbGFuYXIgYW50ZXMgZGVsIGNvbW1pdCBlbiBSZWFjdCxcbiAgICAgICAgICAgIC8vIGFzw60gbm8gYXBhcmVjZSB1biBmcmFtZSBpbnRlcm1lZGlvIGNvbiB0YW1hw7FvIFwic2FsdGFkb1wiLlxuICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XG4gICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiY291bnRkb3duXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ291bnRkb3duOiBwZXJzaXN0aXIgZXNjYWxhIHJlYWwgcGFyYSBxdWUgZWwgcmVzdWx0YWRvIGZpbmFsXG4gICAgICAgICAgICAgIC8vIHNlYSBleGFjdGFtZW50ZSBlbCBtaXNtbyBxdWUgc2UgdmUgYWwgc29sdGFyLlxuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgICBjb25zdCBjb3VudGRvd25TaXplID0gZ2V0Q291bnRkb3duU2NhbGVkU2l6ZShub2RlKTtcbiAgICAgICAgICAgICAgZmluYWxEYXRhLndpZHRoID0gY291bnRkb3duU2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgZmluYWxEYXRhLmhlaWdodCA9IGNvdW50ZG93blNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlc1RyaWFuZ3Vsbykge1xuICAgICAgICAgICAgICBjb25zdCBiYXNlUmFkaXVzID0gTnVtYmVyLmlzRmluaXRlKHByaW1lckVsZW1lbnRvPy5yYWRpdXMpXG4gICAgICAgICAgICAgICAgPyBwcmltZXJFbGVtZW50by5yYWRpdXNcbiAgICAgICAgICAgICAgICA6IDYwO1xuICAgICAgICAgICAgICBjb25zdCBhdmdTY2FsZSA9IChNYXRoLmFicyhzY2FsZVgpICsgTWF0aC5hYnMoc2NhbGVZKSkgLyAyO1xuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gMTtcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5yYWRpdXMgPSBNYXRoLm1heCgxLCBiYXNlUmFkaXVzICogYXZnU2NhbGUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zY2FsZVgoMSk7XG4gICAgICAgICAgICAgICAgbm9kZS5zY2FsZVkoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBub2RlLnJhZGl1cyhmaW5hbERhdGEucmFkaXVzKTtcbiAgICAgICAgICAgICAgICBub2RlLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBhcGxhbmFuZG8gZXNjYWxhIGRlIHRyacOhbmd1bG8gKHN5bmMpOlwiLCBlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gMTtcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsV2lkdGggPSBwcmltZXJFbGVtZW50by53aWR0aCB8fCAxMDA7XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcHJpbWVyRWxlbWVudG8uaGVpZ2h0IHx8IDEwMDtcblxuICAgICAgICAgICAgICBmaW5hbERhdGEud2lkdGggPSBNYXRoLmFicyhvcmlnaW5hbFdpZHRoICogc2NhbGVYKTtcbiAgICAgICAgICAgICAgZmluYWxEYXRhLmhlaWdodCA9IE1hdGguYWJzKG9yaWdpbmFsSGVpZ2h0ICogc2NhbGVZKTtcblxuICAgICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsaXZlUmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkaWFtZXRlciA9IE1hdGgubWF4KDEsIE1hdGgubWF4KGxpdmVSZWN0LndpZHRoLCBsaXZlUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS5yYWRpdXMgPSBkaWFtZXRlciAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBjaXJjbGVBbmNob3JSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnggPSBhbmNob3IubGVmdCArIGZpbmFsRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS55ID0gYW5jaG9yLnRvcCArIGZpbmFsRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueCA9IGxpdmVSZWN0LnggKyBmaW5hbERhdGEucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IGxpdmVSZWN0LnkgKyBmaW5hbERhdGEucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIOKchSBBcGxhbmFyIGVzY2FsYSBJTk1FRElBVE9cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdyA9IGZpbmFsRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBmaCA9IGZpbmFsRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWSgxKTtcblxuICAgICAgICAgICAgICAgIGlmIChmdyAhPSBudWxsICYmIHR5cGVvZiBub2RlLndpZHRoID09PSBcImZ1bmN0aW9uXCIpIG5vZGUud2lkdGgoZncpO1xuICAgICAgICAgICAgICAgIGlmIChmaCAhPSBudWxsICYmIHR5cGVvZiBub2RlLmhlaWdodCA9PT0gXCJmdW5jdGlvblwiKSBub2RlLmhlaWdodChmaCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiICYmXG4gICAgICAgICAgICAgICAgICBmaW5hbERhdGEucmFkaXVzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLnJhZGl1cyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBub2RlLnJhZGl1cyhmaW5hbERhdGEucmFkaXVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLmdldExheWVyKCk/LmJhdGNoRHJhdygpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBhcGxhbmFuZG8gZXNjYWxhcyAoc3luYyk6XCIsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvblRyYW5zZm9ybShmaW5hbERhdGEpO1xuICAgICAgICAgIGNpcmNsZUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcblxuXG4gICAgICAgICAgLy8g4pyFIFJlYXRhY2hhciAxIHZleiwgY29uIHJlZiBmcmVzY28sIGVuIGVsIHByw7N4aW1vIGZyYW1lXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyMiA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXRyMikgcmV0dXJuO1xuXG4gICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIC0+IHNjaGVkdWxlIFJBRiByZWF0dGFjaFwiLCB7XG4gICAgICAgICAgICAgIHNlbEtleTogc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgaWRTZWw6IHNlbGVjdGVkRWxlbWVudHM/LlswXSB8fCBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaWRTZWwgPSBzZWxlY3RlZEVsZW1lbnRzPy5bMF07XG4gICAgICAgICAgICAgIGNvbnN0IGZyZXNoTm9kZSA9IGlkU2VsID8gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkU2VsXSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCBSQUZcIiwge1xuICAgICAgICAgICAgICAgIGlkU2VsLFxuICAgICAgICAgICAgICAgIGhhc0ZyZXNoOiAhIWZyZXNoTm9kZSxcbiAgICAgICAgICAgICAgICBkZXN0cm95ZWQ6ICEhZnJlc2hOb2RlPy5fZGVzdHJveWVkLFxuICAgICAgICAgICAgICAgIGhhc1N0YWdlOiAhIWZyZXNoTm9kZT8uZ2V0U3RhZ2U/LigpLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBTaSBlbCBub2RvIG5vIGVzdMOhIGxpc3RvLCBkZXNwZWdhciB5IHNhbGlyXG4gICAgICAgICAgICAgIGlmICghZnJlc2hOb2RlIHx8IGZyZXNoTm9kZS5fZGVzdHJveWVkIHx8ICFmcmVzaE5vZGUuZ2V0U3RhZ2U/LigpKSB7XG4gICAgICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCBSQUYgLT4gREVUQUNIIG5vZGVzKFtdKVwiLCB7IGlkU2VsIH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7IHRyMi5ub2RlcyhbXSk7IHRyMi5nZXRMYXllcj8uKCk/LmJhdGNoRHJhdygpOyB9IGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgVFJEQkcoXCJvblRyYW5zZm9ybUVuZCBSQUYgLT4gREVUQUNIIG5vZGVzKFtdKVwiLCB7IGlkU2VsIH0pO1xuICAgICAgICAgICAgICAgIHRyMi5ub2RlcyhbZnJlc2hOb2RlXSk7XG4gICAgICAgICAgICAgICAgdHIyLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgdHIyLmdldExheWVyPy4oKT8uYmF0Y2hEcmF3KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dFByZXZpZXdFbmRTbmFwc2hvdCAmJiBmcmVzaE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RSZWN0ID0gZnJlc2hOb2RlLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFRYVERCRyhcInBvc3QtY29tbWl0OnJhZjFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFNlbCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmU6IHRleHRQcmV2aWV3RW5kU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgcG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdHlwZW9mIGZyZXNoTm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLngoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0eXBlb2YgZnJlc2hOb2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUueSgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWDogdHlwZW9mIGZyZXNoTm9kZT8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUuc2NhbGVYKCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZOiB0eXBlb2YgZnJlc2hOb2RlPy5zY2FsZVkgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS5zY2FsZVkoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogdHlwZW9mIGZyZXNoTm9kZT8uZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS5mb250U2l6ZSgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaWR0aDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Py53aWR0aCkgPyBwb3N0UmVjdC53aWR0aCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0SGVpZ2h0OiBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LmhlaWdodCkgPyBwb3N0UmVjdC5oZWlnaHQgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LndpZHRoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3Qud2lkdGggLSB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8uaGVpZ2h0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKHBvc3RSZWN0LmhlaWdodCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmVzaE5vZGUyID0gaWRTZWwgPyBlbGVtZW50UmVmcy5jdXJyZW50Py5baWRTZWxdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmVzaE5vZGUyKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdFJlY3QyID0gZnJlc2hOb2RlMi5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgVFhUREJHKFwicG9zdC1jb21taXQ6cmFmMlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRTZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHR5cGVvZiBmcmVzaE5vZGUyPy54ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLngoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHR5cGVvZiBmcmVzaE5vZGUyPy55ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUyLnkoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWDogdHlwZW9mIGZyZXNoTm9kZTI/LnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi5zY2FsZVgoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWTogdHlwZW9mIGZyZXNoTm9kZTI/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlMi5zY2FsZVkoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0eXBlb2YgZnJlc2hOb2RlMj8uZm9udFNpemUgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZTIuZm9udFNpemUoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaWR0aDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Mj8ud2lkdGgpID8gcG9zdFJlY3QyLndpZHRoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdEhlaWdodDogTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Mj8uaGVpZ2h0KSA/IHBvc3RSZWN0Mi5oZWlnaHQgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhRnJvbVByZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3QyPy53aWR0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChwb3N0UmVjdDIud2lkdGggLSB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdDI/LmhlaWdodCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUodGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3QyLmhlaWdodCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggeyB9XG5cblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGVuIG9uVHJhbnNmb3JtRW5kOlwiLCBlcnJvcik7XG4gICAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfX1cblxuICAgIC8+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJUcmFuc2Zvcm1lciIsIlJlY3QiLCJERUJVR19TRUxFQ1RJT05fQk9VTkRTIiwic2JMb2ciLCJhcmdzIiwiY29uc29sZSIsImxvZyIsInNsb2ciLCJUUkRCRyIsIndpbmRvdyIsIl9fREJHX1RSIiwiVFhUREJHIiwiX19EQkdfVEVYVF9SRVNJWkUiLCJyZWN0RnJvbU5vZGVzIiwibm9kZXMiLCJtaW5YIiwiSW5maW5pdHkiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJuIiwiZ2V0Q2xpZW50UmVjdCIsInIiLCJza2lwVHJhbnNmb3JtIiwic2tpcFNoYWRvdyIsInNraXBTdHJva2UiLCJNYXRoIiwibWluIiwieCIsInkiLCJtYXgiLCJ3aWR0aCIsImhlaWdodCIsImdldENvdW50ZG93blNjYWxlZFNpemUiLCJub2RlIiwiaGl0Ym94IiwiZmluZE9uZSIsImJhc2VXIiwiTmFOIiwiYmFzZUgiLCJzeCIsImFicyIsInNjYWxlWCIsInN5Iiwic2NhbGVZIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJCb3VuZHNJbmRpY2F0b3IiLCJzZWxlY3RlZEVsZW1lbnRzIiwiZWxlbWVudFJlZnMiLCJvYmpldG9zIiwiZm9yY2VVcGRhdGUiLCJzZXRGb3JjZVVwZGF0ZSIsImZpcnN0UmVmIiwiY3VycmVudCIsInN0YWdlIiwiZ2V0U3RhZ2UiLCJoYW5kbGVEcmFnTW92ZSIsInAiLCJvbiIsIm9mZiIsImpvaW4iLCJlbGVtZW50b3NEYXRhIiwibWFwIiwiaWQiLCJmaW5kIiwib2JqIiwiZmlsdGVyIiwiQm9vbGVhbiIsImxlbmd0aCIsImZvckVhY2giLCJ0aXBvIiwiZmlndXJhIiwicG9pbnRzIiwiY2xlYW5Qb2ludHMiLCJwYXJzZUZsb2F0IiwicmVhbFgiLCJyZWFsWSIsIngxIiwieTEiLCJ4MiIsInkyIiwibGluZVBhZGRpbmciLCJib3giLCJ0b0ZpeGVkIiwiZ2V0VGV4dEhlaWdodCIsInRleHRIZWlnaHQiLCJlcnJvciIsImZhbGxiYWNrWCIsImZhbGxiYWNrWSIsImZhbGxiYWNrU2l6ZSIsInByaW1lckVsZW1lbnRvIiwicGFkZGluZyIsImZpbmFsWCIsImZpbmFsWSIsImZpbmFsV2lkdGgiLCJmaW5hbEhlaWdodCIsIm5hbWUiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJsaXN0ZW5pbmciLCJvcGFjaXR5IiwiU2VsZWN0aW9uQm91bmRzIiwib25UcmFuc2Zvcm0iLCJvblRyYW5zZm9ybUludGVyYWN0aW9uU3RhcnQiLCJvblRyYW5zZm9ybUludGVyYWN0aW9uRW5kIiwiaXNEcmFnZ2luZyIsImlzTW9iaWxlIiwidHJhbnNmb3JtZXJSZWYiLCJ0cmFuc2Zvcm1UaWNrIiwic2V0VHJhbnNmb3JtVGljayIsImxhc3ROb2Rlc1JlZiIsImNpcmNsZUFuY2hvclJlZiIsInRleHRUcmFuc2Zvcm1BbmNob3JSZWYiLCJ0cmFuc2Zvcm1HZXN0dXJlUmVmIiwiaXNSb3RhdGUiLCJhY3RpdmVBbmNob3IiLCJlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YSIsImVzVGV4dG8iLCJlc0NvdW50ZG93biIsImVzR2FsZXJpYSIsImxvY2tBc3BlY3RDb3VudGRvd24iLCJsb2NrQXNwZWN0VGV4dCIsInRyYW5zZm9ybWVyQW5jaG9yU2l6ZSIsInRyYW5zZm9ybWVyUm90YXRlT2Zmc2V0IiwidHJhbnNmb3JtZXJBbmNob3JSYWRpdXMiLCJ0cmFuc2Zvcm1lclBhZGRpbmciLCJ0cmFuc2Zvcm1lckJvcmRlclN0cm9rZVdpZHRoIiwidHJhbnNmb3JtZXJBbmNob3JTdHJva2VXaWR0aCIsInRyYW5zZm9ybWVyQW5jaG9yU2hhZG93Qmx1ciIsInRyYW5zZm9ybWVyQW5jaG9yU2hhZG93T2Zmc2V0WSIsInRyYW5zZm9ybWVyUm90YXRpb25TbmFwVG9sZXJhbmNlIiwiZXNUcmlhbmd1bG8iLCJoYXNHYWxsZXJ5Iiwic29tZSIsIm8iLCJoYXlMaW5lYXMiLCJlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcyIsImRlYmVyaWFVc2FyVHJhbnNmb3JtZXIiLCJzZWxlY3RlZEdlb21LZXkiLCJyb3RhdGlvbiIsImNoaXBXaWR0aCIsImdhcCIsInBhZGRpbmdYIiwicGFkZGluZ1kiLCJnZXRUcmFuc2Zvcm1Qb3NlIiwiZ2V0UGFyZW50IiwicGFyZW50IiwidHIiLCJzZWxLZXkiLCJlbGVtZW50b3NUcmFuc2Zvcm1hYmxlc0xlbiIsImVkaXRpbmdJZCIsImVkaXRpbmciLCJub2Rvc1RyYW5zZm9ybWFibGVzIiwiaWRTZWwiLCJyZWZOb2RlIiwiZ2FsbGVyeUZyYW1lIiwid2FudGVkSWRzIiwicmVmc1ByZXNlbnQiLCJub2Rlc0NvdW50Iiwibm9kZUlkcyIsImF0dHJzIiwidHJOb2Rlc0NvdW50IiwiZ2V0TGF5ZXIiLCJiYXRjaERyYXciLCJoYW5kbGVyIiwiZSIsImRldGFpbCIsImlzU2VsZWN0ZWQiLCJpbmNsdWRlcyIsInQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZpcnN0Tm9kZSIsImZpcnN0SWQiLCJyYWZJZCIsInN5bmNUcmFuc2Zvcm1lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIiwiYm9yZGVyRW5hYmxlZCIsImJvcmRlclN0cm9rZSIsImJvcmRlclN0cm9rZVdpZHRoIiwiZW5hYmxlZEFuY2hvcnMiLCJyb3RhdGVFbmFibGVkIiwiYW5jaG9yRmlsbCIsImFuY2hvclN0cm9rZSIsImFuY2hvclN0cm9rZVdpZHRoIiwiYW5jaG9yU2l6ZSIsImFuY2hvckNvcm5lclJhZGl1cyIsImFuY2hvclNoYWRvd0NvbG9yIiwiYW5jaG9yU2hhZG93Qmx1ciIsImFuY2hvclNoYWRvd09mZnNldCIsImtlZXBSYXRpbyIsImNlbnRlcmVkU2NhbGluZyIsImZsaXBFbmFibGVkIiwicmVzaXplRW5hYmxlZCIsInJvdGF0aW9uU25hcHMiLCJyb3RhdGVBbmNob3JPZmZzZXQiLCJyb3RhdGlvblNuYXBUb2xlcmFuY2UiLCJib3VuZEJveEZ1bmMiLCJvbGRCb3giLCJuZXdCb3giLCJtaW5TaXplIiwibWF4U2l6ZSIsInJvd3MiLCJjb2xzIiwiY2VsbFJhdGlvIiwicmF0aW8iLCJtaW5HcmlkV2lkdGgiLCJuZXh0V2lkdGgiLCJjZWxsVyIsImNlbGxIIiwibmV4dEhlaWdodCIsImR3IiwiZGgiLCJzaXplIiwiZmluYWxTaXplIiwic2FmZU9sZFciLCJzYWZlT2xkSCIsInVuaWZvcm1TY2FsZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0Iiwib25UcmFuc2Zvcm1TdGFydCIsIl9yZXNpemVEYXRhIiwiaXNSZXNpemluZyIsImdldEFjdGl2ZUFuY2hvciIsImlzUm90YXRlR2VzdHVyZSIsInRvTG93ZXJDYXNlIiwicG9pbnRlclR5cGUiLCJldnQiLCJyMCIsImxlZnQiLCJ0b3AiLCJjZW50ZXJYIiwiY2VudGVyWSIsImJhc2VXaWR0aCIsImJhc2VIZWlnaHQiLCJiYXNlVmlzdWFsV2lkdGgiLCJyZWN0Iiwic2FmZUJhc2VGb250U2l6ZSIsImZvbnRTaXplIiwiYmFzZVJvdGF0aW9uIiwiYmFzZUZvbnRTaXplIiwibGFzdFByZXZpZXdGb250U2l6ZSIsImxhc3RQcmV2aWV3Q2VudGVyWCIsImxhc3RQcmV2aWV3Q2VudGVyWSIsImxhc3RQcmV2aWV3VmlzdWFsV2lkdGgiLCJwcmV2aWV3VGljayIsIm5vZGVYIiwibm9kZVkiLCJub2RlU2NhbGVYIiwibm9kZVNjYWxlWSIsInVuaW9uIiwicGFkIiwiYm9yZGVyUmVjdCIsInRyUmVjdCIsInBvc2UiLCJ0cmFuc2Zvcm1EYXRhIiwiaXNQcmV2aWV3Iiwib3JpZ2luYWxGb250U2l6ZSIsImFuY2hvckRhdGEiLCJhdmdTY2FsZSIsInNjYWxlRnJvbVJlY3QiLCJsaXZlUmVjdFdpZHRoIiwiY3VycmVudFJvdGF0aW9uIiwicm90YXRpb25EZWx0YSIsImNhblVzZVJlY3RTY2FsZSIsImVmZmVjdGl2ZVNjYWxlIiwidGljayIsImNlbnRlclhUYXJnZXQiLCJ0ZXh0Q2VudGVyWCIsInRleHRDZW50ZXJZIiwiY291bnRkb3duU2l6ZSIsImJhc2VSYWRpdXMiLCJyYWRpdXMiLCJvcmlnaW5hbFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJsaXZlUmVjdCIsImRpYW1ldGVyIiwiYW5jaG9yIiwid2FybiIsIm9uVHJhbnNmb3JtRW5kIiwidFNjYWxlWCIsInRTY2FsZVkiLCJhdmciLCJ1cGRhdGVzIiwidXBkIiwiYmFzZSIsInJvdW5kIiwiYmFzZVIiLCJpc0ZpbmFsIiwiYmF0Y2giLCJzZXRUaW1lb3V0IiwiZXJyIiwiZmluYWxEYXRhIiwidGV4dFByZXZpZXdFbmRTbmFwc2hvdCIsInZpc3VhbFdpZHRoRnJvbVJlY3QiLCJjb21wdXRlZEZvbnRTaXplIiwidmlzdWFsV2lkdGgiLCJ0ZXh0VmlzdWFsV2lkdGgiLCJyZWN0V2lkdGgiLCJyZWN0SGVpZ2h0IiwicmVjdEZvclNuYXBzaG90IiwiZmluYWxGb250U2l6ZSIsIm5vZGVSZWN0V2lkdGgiLCJ0YXJnZXRDZW50ZXJYIiwidGFyZ2V0Q2VudGVyWSIsImZsYXR0ZW5lZFJlY3QiLCJmbGF0dGVuZWRDZW50ZXJYIiwiZmxhdHRlbmVkQ2VudGVyWSIsImZ3IiwiZmgiLCJ0cjIiLCJmcmVzaE5vZGUiLCJoYXNGcmVzaCIsImRlc3Ryb3llZCIsIl9kZXN0cm95ZWQiLCJoYXNTdGFnZSIsInBvc3RSZWN0IiwicHJlIiwicG9zdCIsImRlbHRhIiwiZnJlc2hOb2RlMiIsInBvc3RSZWN0MiIsImRlbHRhRnJvbVByZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/SelectionBounds.jsx\n"));

/***/ })

});