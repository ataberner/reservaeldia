"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/hooks/useGuiasCentrado.js":
/*!***************************************!*\
  !*** ./src/hooks/useGuiasCentrado.js ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useGuiasCentrado)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n// hooks/useGuiasCentrado.js\nvar _s = $RefreshSig$();\n\n/**\n * Gu√≠as con:\n * - Secci√≥n: muestra CX/CY solo cuando el elemento qued√≥ centrado.\n * - Elementos: SOLO misma secci√≥n, l√≠neas punteadas tipo \"reach\" hasta el otro elemento.\n * - Nada de otras secciones.\n */ function useGuiasCentrado(param) {\n    let { anchoCanvas = 800, altoCanvas = 800, magnetRadius = 16, elementMagnetRadius = null, sectionMagnetRadius = null, sectionShowRadius = 18, sectionPriorityBias = 4, snapStrength = 1, sectionSnapStrength = null, elementSnapStrength = null, sectionLineTolerance = 0.75, seccionesOrdenadas = [] } = param;\n    _s();\n    const [guiaLineas, setGuiaLineas] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const effElementMagnetRadius = elementMagnetRadius !== null && elementMagnetRadius !== void 0 ? elementMagnetRadius : magnetRadius;\n    const effSectionMagnetRadius = sectionMagnetRadius !== null && sectionMagnetRadius !== void 0 ? sectionMagnetRadius : magnetRadius;\n    const effSectionSnapStrength = sectionSnapStrength !== null && sectionSnapStrength !== void 0 ? sectionSnapStrength : snapStrength;\n    const effElementSnapStrength = elementSnapStrength !== null && elementSnapStrength !== void 0 ? elementSnapStrength : snapStrength;\n    // ---- Utilidades de secciones ----\n    const calcularOffsetSeccion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGuiasCentrado.useCallback[calcularOffsetSeccion]\": (seccionId)=>{\n            let offsetY = 0;\n            for (const s of seccionesOrdenadas){\n                if (s.id === seccionId) break;\n                offsetY += s.altura;\n            }\n            return offsetY;\n        }\n    }[\"useGuiasCentrado.useCallback[calcularOffsetSeccion]\"], [\n        seccionesOrdenadas\n    ]);\n    const obtenerSeccionElemento = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGuiasCentrado.useCallback[obtenerSeccionElemento]\": (objId, objetos)=>{\n            const obj = objetos.find({\n                \"useGuiasCentrado.useCallback[obtenerSeccionElemento].obj\": (o)=>o.id === objId\n            }[\"useGuiasCentrado.useCallback[obtenerSeccionElemento].obj\"]);\n            if (!(obj === null || obj === void 0 ? void 0 : obj.seccionId)) return null;\n            return seccionesOrdenadas.find({\n                \"useGuiasCentrado.useCallback[obtenerSeccionElemento]\": (s)=>s.id === obj.seccionId\n            }[\"useGuiasCentrado.useCallback[obtenerSeccionElemento]\"]) || null;\n        }\n    }[\"useGuiasCentrado.useCallback[obtenerSeccionElemento]\"], [\n        seccionesOrdenadas\n    ]);\n    // ---- Segmentos \"reach\" entre cajas (va hasta el otro elemento) ----\n    const reachVertical = function(x, selfBox, otherBox) {\n        let gap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 6;\n        const selfCy = selfBox.y + selfBox.height / 2;\n        const otherCy = otherBox.y + otherBox.height / 2;\n        let y1, y2;\n        if (otherCy <= selfCy) {\n            y1 = otherBox.y + otherBox.height + gap; // desde borde inferior del otro\n            y2 = selfBox.y - gap; // hasta borde superior del self\n        } else {\n            y1 = selfBox.y + selfBox.height + gap;\n            y2 = otherBox.y - gap;\n        }\n        return [\n            x,\n            y1,\n            x,\n            y2\n        ];\n    };\n    const reachHorizontal = function(y, selfBox, otherBox) {\n        let gap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 6;\n        const selfCx = selfBox.x + selfBox.width / 2;\n        const otherCx = otherBox.x + otherBox.width / 2;\n        let x1, x2;\n        if (otherCx <= selfCx) {\n            x1 = otherBox.x + otherBox.width + gap; // desde borde derecho del otro\n            x2 = selfBox.x - gap; // hasta borde izquierdo del self\n        } else {\n            x1 = selfBox.x + selfBox.width + gap;\n            x2 = otherBox.x - gap;\n        }\n        return [\n            x1,\n            y,\n            x2,\n            y\n        ];\n    };\n    // ---- Delta para alinear a la gu√≠a m√°s cercana ----\n    const deltaForGuide = (axis, guideValue, box)=>{\n        if (axis === \"x\") {\n            const center = box.x + box.width / 2;\n            const left = box.x;\n            const right = box.x + box.width;\n            const opts = [\n                {\n                    dist: Math.abs(center - guideValue),\n                    delta: guideValue - center\n                },\n                {\n                    dist: Math.abs(left - guideValue),\n                    delta: guideValue - left\n                },\n                {\n                    dist: Math.abs(right - guideValue),\n                    delta: guideValue - right\n                }\n            ].sort((a, b)=>a.dist - b.dist)[0];\n            return opts.delta;\n        } else {\n            const center = box.y + box.height / 2;\n            const top = box.y;\n            const bottom = box.y + box.height;\n            const opts = [\n                {\n                    dist: Math.abs(center - guideValue),\n                    delta: guideValue - center\n                },\n                {\n                    dist: Math.abs(top - guideValue),\n                    delta: guideValue - top\n                },\n                {\n                    dist: Math.abs(bottom - guideValue),\n                    delta: guideValue - bottom\n                }\n            ].sort((a, b)=>a.dist - b.dist)[0];\n            return opts.delta;\n        }\n    };\n    // Misma heur√≠stica que deltaForGuide, pero devuelve distancia m√≠nima\n    const distForGuide = (axis, guideValue, box)=>{\n        if (axis === \"x\") {\n            const center = box.x + box.width / 2;\n            const left = box.x;\n            const right = box.x + box.width;\n            return Math.min(Math.abs(center - guideValue), Math.abs(left - guideValue), Math.abs(right - guideValue));\n        }\n        const center = box.y + box.height / 2;\n        const top = box.y;\n        const bottom = box.y + box.height;\n        return Math.min(Math.abs(center - guideValue), Math.abs(top - guideValue), Math.abs(bottom - guideValue));\n    };\n    // ---- Candidatos de la MISMA secci√≥n (centros + bordes) ----\n    const getNodeBox = function(node, stage) {\n        let obj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        if (!node || !stage || typeof node.getClientRect !== \"function\") return null;\n        const rectOpts = {\n            relativeTo: stage\n        };\n        if ((obj === null || obj === void 0 ? void 0 : obj.tipo) === \"galeria\" && Number.isFinite(Number(obj === null || obj === void 0 ? void 0 : obj.width)) && Number.isFinite(Number(obj === null || obj === void 0 ? void 0 : obj.height))) {\n            const xFromNode = typeof node.x === \"function\" ? node.x() : null;\n            const yFromNode = typeof node.y === \"function\" ? node.y() : null;\n            const absPos = typeof node.getAbsolutePosition === \"function\" ? node.getAbsolutePosition(stage) : null;\n            const x = Number.isFinite(xFromNode) ? xFromNode : Number.isFinite(absPos === null || absPos === void 0 ? void 0 : absPos.x) ? absPos.x : typeof node.x === \"function\" ? node.x() : 0;\n            const y = Number.isFinite(yFromNode) ? yFromNode : Number.isFinite(absPos === null || absPos === void 0 ? void 0 : absPos.y) ? absPos.y : typeof node.y === \"function\" ? node.y() : 0;\n            return {\n                x,\n                y,\n                width: Number(obj.width),\n                height: Number(obj.height)\n            };\n        }\n        // La galeria usa overlays por celda; medir su frame base evita offsets falsos.\n        if ((obj === null || obj === void 0 ? void 0 : obj.tipo) === \"galeria\" && typeof node.findOne === \"function\") {\n            const galleryFrame = node.findOne(\".gallery-transform-frame\");\n            if (galleryFrame && typeof galleryFrame.getClientRect === \"function\") {\n                try {\n                    return galleryFrame.getClientRect({\n                        relativeTo: stage,\n                        skipShadow: true,\n                        skipStroke: true\n                    });\n                } catch (e) {\n                // fallback al rect completo\n                }\n            }\n        }\n        try {\n            return node.getClientRect(rectOpts);\n        } catch (e) {\n            return null;\n        }\n    };\n    const buildSameSectionGuides = (node, stage, objetos, elementRefs, idSelf, seccionId, objById)=>{\n        const selfObj = objById.get(idSelf) || null;\n        const selfBox = getNodeBox(node, stage, selfObj);\n        if (!selfBox) return [];\n        const candidates = objetos.filter((o)=>o.id !== idSelf && o.seccionId === seccionId) // üîí MISMA SECCI√ìN\n        .map((o)=>{\n            var _elementRefs_current;\n            const n = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id];\n            if (!n) return null;\n            try {\n                const b = getNodeBox(n, stage, objById.get(o.id) || null);\n                if (!b) return null;\n                const d = Math.abs(selfBox.x + selfBox.width / 2 - (b.x + b.width / 2)) + Math.abs(selfBox.y + selfBox.height / 2 - (b.y + b.height / 2));\n                return {\n                    box: b,\n                    d\n                };\n            } catch (e) {\n                return null;\n            }\n        }).filter(Boolean).sort((a, b)=>a.d - b.d).slice(0, 3); // pocos vecinos ‚Üí menos ruido\n        const g = [];\n        for (const { box } of candidates){\n            const cx = box.x + box.width / 2;\n            const cy = box.y + box.height / 2;\n            const left = box.x;\n            const right = box.x + box.width;\n            const top = box.y;\n            const bottom = box.y + box.height;\n            // Centros\n            g.push({\n                axis: \"x\",\n                value: cx,\n                type: \"el-cx\",\n                targetBox: box,\n                priority: \"elemento\",\n                style: \"dashed\"\n            });\n            g.push({\n                axis: \"y\",\n                value: cy,\n                type: \"el-cy\",\n                targetBox: box,\n                priority: \"elemento\",\n                style: \"dashed\"\n            });\n            // Bordes\n            g.push({\n                axis: \"x\",\n                value: left,\n                type: \"el-left\",\n                targetBox: box,\n                priority: \"elemento\",\n                style: \"dashed\"\n            });\n            g.push({\n                axis: \"x\",\n                value: right,\n                type: \"el-right\",\n                targetBox: box,\n                priority: \"elemento\",\n                style: \"dashed\"\n            });\n            g.push({\n                axis: \"y\",\n                value: top,\n                type: \"el-top\",\n                targetBox: box,\n                priority: \"elemento\",\n                style: \"dashed\"\n            });\n            g.push({\n                axis: \"y\",\n                value: bottom,\n                type: \"el-bottom\",\n                targetBox: box,\n                priority: \"elemento\",\n                style: \"dashed\"\n            });\n        }\n        return g;\n    };\n    const getUnionBox = (ids, stage, elementRefs, objById)=>{\n        if (!Array.isArray(ids) || ids.length === 0) return null;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n        ids.forEach((id)=>{\n            var _elementRefs_current;\n            const n = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[id];\n            if (!n) return;\n            const b = getNodeBox(n, stage, objById.get(id) || null);\n            if (!b) return;\n            minX = Math.min(minX, b.x);\n            minY = Math.min(minY, b.y);\n            maxX = Math.max(maxX, b.x + b.width);\n            maxY = Math.max(maxY, b.y + b.height);\n        });\n        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {\n            return null;\n        }\n        return {\n            x: minX,\n            y: minY,\n            width: Math.max(0, maxX - minX),\n            height: Math.max(0, maxY - minY)\n        };\n    };\n    const shiftNodes = (ids, axis, delta, elementRefs)=>{\n        if (!Array.isArray(ids) || ids.length === 0 || !Number.isFinite(delta)) return;\n        if (Math.abs(delta) < 0.0001) return;\n        const shiftSingle = (node)=>{\n            if (!node) return;\n            try {\n                if (axis === \"x\") {\n                    node.x(node.x() + delta);\n                } else {\n                    node.y(node.y() + delta);\n                }\n            } catch (e) {\n            // silencioso para no cortar drag\n            }\n        };\n        ids.forEach((id)=>{\n            var _elementRefs_current, _elementRefs_current1;\n            const n = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[id];\n            shiftSingle(n);\n            // Algunas formas (rect/rsvp) renderizan el texto como nodo separado.\n            shiftSingle((_elementRefs_current1 = elementRefs.current) === null || _elementRefs_current1 === void 0 ? void 0 : _elementRefs_current1[\"\".concat(id, \"-text\")]);\n        });\n    };\n    // ---- Mostrar gu√≠as durante el drag ----\n    const mostrarGuias = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGuiasCentrado.useCallback[mostrarGuias]\": (pos, idActual, objetos, elementRefs)=>{\n            var _elementRefs_current, _node_getStage;\n            const node = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idActual];\n            if (!node) return;\n            const stage = (_node_getStage = node.getStage) === null || _node_getStage === void 0 ? void 0 : _node_getStage.call(node);\n            if (!stage) return;\n            try {\n                var _snapResX_near_g, _snapResX_near, _snapResY_near_g, _snapResY_near;\n                const objById = new Map(objetos.map({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (o)=>[\n                            o.id,\n                            o\n                        ]\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"]));\n                const objActual = objById.get(idActual) || null;\n                const isGroupLeader = window._grupoLider && idActual === window._grupoLider;\n                const rawGroupIds = Array.isArray(window._grupoElementos) && window._grupoElementos.length > 1 ? window._grupoElementos : Array.isArray(window._elementosSeleccionados) ? window._elementosSeleccionados : [];\n                const groupIds = isGroupLeader ? [\n                    ...new Set(rawGroupIds.filter(Boolean))\n                ] : [];\n                const isGroupDrag = isGroupLeader && groupIds.length > 1;\n                const selfBoxBefore = isGroupDrag ? getUnionBox(groupIds, stage, elementRefs, objById) : getNodeBox(node, stage, objActual);\n                if (!selfBoxBefore) return;\n                const selfCx = selfBoxBefore.x + selfBoxBefore.width / 2;\n                const selfCy = selfBoxBefore.y + selfBoxBefore.height / 2;\n                const seccion = obtenerSeccionElemento(idActual, objetos);\n                if (!seccion) {\n                    setGuiaLineas([]);\n                    return;\n                }\n                const offY = calcularOffsetSeccion(seccion.id);\n                const secCx = anchoCanvas / 2;\n                const secCy = offY + seccion.altura / 2;\n                const lines = [];\n                // 1) SECCI√ìN: el snap eval√∫a el centro de la secci√≥n.\n                const distSecX = Math.abs(selfCx - secCx);\n                const distSecY = Math.abs(selfCy - secCy);\n                // 2) ELEMENTOS (MISMA SECCI√ìN): elegir mejor candidato por eje\n                const elementGuides = isGroupDrag ? [] : buildSameSectionGuides(node, stage, objetos, elementRefs, idActual, seccion.id, objById);\n                const bestElX = isGroupDrag ? null : elementGuides.filter({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (g)=>g.axis === \"x\"\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"]).map({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (g)=>({\n                            g,\n                            dist: distForGuide(\"x\", g.value, selfBoxBefore)\n                        })\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"]).sort({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (a, b)=>a.dist - b.dist\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"])[0];\n                const bestElY = isGroupDrag ? null : elementGuides.filter({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (g)=>g.axis === \"y\"\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"]).map({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (g)=>({\n                            g,\n                            dist: distForGuide(\"y\", g.value, selfBoxBefore)\n                        })\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"]).sort({\n                    \"useGuiasCentrado.useCallback[mostrarGuias]\": (a, b)=>a.dist - b.dist\n                }[\"useGuiasCentrado.useCallback[mostrarGuias]\"])[0];\n                // Decidir qu√© gu√≠a ‚Äúgana‚Äù por eje (secci√≥n vs elemento)\n                const decidirSnap = {\n                    \"useGuiasCentrado.useCallback[mostrarGuias].decidirSnap\": (secDistCenter, bestEl)=>{\n                        const secOk = secDistCenter <= effSectionMagnetRadius;\n                        const elOk = !!bestEl && bestEl.dist <= effElementMagnetRadius;\n                        if (!secOk && !elOk) return null;\n                        if (secOk && !elOk) return {\n                            source: \"seccion\"\n                        };\n                        if (!secOk && elOk) return {\n                            source: \"elemento\",\n                            near: bestEl\n                        };\n                        // ambos aplican: la secci√≥n tiene ventaja (bias)\n                        const elBeatsSection = bestEl.dist + sectionPriorityBias < secDistCenter;\n                        return elBeatsSection ? {\n                            source: \"elemento\",\n                            near: bestEl\n                        } : {\n                            source: \"seccion\"\n                        };\n                    }\n                }[\"useGuiasCentrado.useCallback[mostrarGuias].decidirSnap\"];\n                const decisionX = decidirSnap(distSecX, bestElX);\n                const decisionY = decidirSnap(distSecY, bestElY);\n                const applySnap = {\n                    \"useGuiasCentrado.useCallback[mostrarGuias].applySnap\": (axis, decision)=>{\n                        if (!decision) return {\n                            snapped: false\n                        };\n                        const fresh = isGroupDrag ? getUnionBox(groupIds, stage, elementRefs, objById) : getNodeBox(node, stage, objActual);\n                        if (!fresh) return {\n                            snapped: false\n                        };\n                        if (decision.source === \"seccion\") {\n                            const nextCenter = axis === \"x\" ? fresh.x + fresh.width / 2 : fresh.y + fresh.height / 2;\n                            const targetCenter = axis === \"x\" ? secCx : secCy;\n                            const delta = (targetCenter - nextCenter) * effSectionSnapStrength;\n                            if (axis === \"x\") {\n                                if (isGroupDrag) shiftNodes(groupIds, \"x\", delta, elementRefs);\n                                else node.x(node.x() + delta);\n                            } else {\n                                if (isGroupDrag) shiftNodes(groupIds, \"y\", delta, elementRefs);\n                                else node.y(node.y() + delta);\n                            }\n                            return {\n                                snapped: true,\n                                source: \"seccion\"\n                            };\n                        }\n                        if (isGroupDrag) return {\n                            snapped: false\n                        };\n                        const delta = deltaForGuide(axis, decision.near.g.value, fresh);\n                        if (axis === \"x\") node.x(node.x() + delta * effElementSnapStrength);\n                        else node.y(node.y() + delta * effElementSnapStrength);\n                        return {\n                            snapped: true,\n                            source: \"elemento\",\n                            near: decision.near\n                        };\n                    }\n                }[\"useGuiasCentrado.useCallback[mostrarGuias].applySnap\"];\n                const snapResX = applySnap(\"x\", decisionX);\n                const snapResY = applySnap(\"y\", decisionY);\n                // Recalcular box luego del snap para dibujar reach exacta\n                const selfBoxAfter = isGroupDrag ? getUnionBox(groupIds, stage, elementRefs, objById) : getNodeBox(node, stage, objActual);\n                if (!selfBoxAfter) return;\n                const selfCxAfter = selfBoxAfter.x + selfBoxAfter.width / 2;\n                const selfCyAfter = selfBoxAfter.y + selfBoxAfter.height / 2;\n                // 2) SECCI√ìN: mostrar gu√≠a SOLO cuando qued√≥ efectivamente alineado.\n                if (snapResX.snapped && snapResX.source === \"seccion\" && Math.abs(selfCxAfter - secCx) <= sectionLineTolerance) {\n                    lines.push({\n                        type: \"seccion-cx\",\n                        priority: \"seccion\",\n                        style: \"solid\",\n                        points: [\n                            secCx,\n                            offY,\n                            secCx,\n                            offY + seccion.altura\n                        ]\n                    });\n                }\n                if (snapResY.snapped && snapResY.source === \"seccion\" && Math.abs(selfCyAfter - secCy) <= sectionLineTolerance) {\n                    lines.push({\n                        type: \"seccion-cy\",\n                        priority: \"seccion\",\n                        style: \"solid\",\n                        points: [\n                            0,\n                            secCy,\n                            anchoCanvas,\n                            secCy\n                        ]\n                    });\n                }\n                if (!isGroupDrag && snapResX.snapped && snapResX.source === \"elemento\" && ((_snapResX_near = snapResX.near) === null || _snapResX_near === void 0 ? void 0 : (_snapResX_near_g = _snapResX_near.g) === null || _snapResX_near_g === void 0 ? void 0 : _snapResX_near_g.targetBox)) {\n                    lines.push({\n                        type: \"reach-x\",\n                        priority: \"elemento\",\n                        style: \"dashed\",\n                        points: reachVertical(snapResX.near.g.value, selfBoxAfter, snapResX.near.g.targetBox)\n                    });\n                }\n                if (!isGroupDrag && snapResY.snapped && snapResY.source === \"elemento\" && ((_snapResY_near = snapResY.near) === null || _snapResY_near === void 0 ? void 0 : (_snapResY_near_g = _snapResY_near.g) === null || _snapResY_near_g === void 0 ? void 0 : _snapResY_near_g.targetBox)) {\n                    lines.push({\n                        type: \"reach-y\",\n                        priority: \"elemento\",\n                        style: \"dashed\",\n                        points: reachHorizontal(snapResY.near.g.value, selfBoxAfter, snapResY.near.g.targetBox)\n                    });\n                }\n                setGuiaLineas(lines);\n            } catch (e) {\n            // silencioso para no cortar el drag\n            }\n        }\n    }[\"useGuiasCentrado.useCallback[mostrarGuias]\"], [\n        anchoCanvas,\n        altoCanvas,\n        magnetRadius,\n        sectionShowRadius,\n        snapStrength,\n        seccionesOrdenadas,\n        obtenerSeccionElemento,\n        calcularOffsetSeccion,\n        elementMagnetRadius,\n        sectionMagnetRadius,\n        sectionPriorityBias,\n        sectionSnapStrength,\n        elementSnapStrength,\n        sectionLineTolerance\n    ]);\n    const limpiarGuias = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGuiasCentrado.useCallback[limpiarGuias]\": ()=>setGuiaLineas([])\n    }[\"useGuiasCentrado.useCallback[limpiarGuias]\"], []);\n    const configurarDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useGuiasCentrado.useCallback[configurarDragEnd]\": ()=>setGuiaLineas([])\n    }[\"useGuiasCentrado.useCallback[configurarDragEnd]\"], []);\n    return {\n        guiaLineas,\n        mostrarGuias,\n        limpiarGuias,\n        configurarDragEnd\n    };\n}\n_s(useGuiasCentrado, \"7XAGzDCLmQDWul3rGpuxjLULroo=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9ob29rcy91c2VHdWlhc0NlbnRyYWRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsNEJBQTRCOztBQUNrQjtBQUU5Qzs7Ozs7Q0FLQyxHQUNjLFNBQVNFLGlCQUFpQixLQWF4QztRQWJ3QyxFQUNyQ0MsY0FBYyxHQUFHLEVBQ2pCQyxhQUFhLEdBQUcsRUFDaEJDLGVBQWUsRUFBRSxFQUNqQkMsc0JBQXNCLElBQUksRUFDMUJDLHNCQUFzQixJQUFJLEVBQzFCQyxvQkFBb0IsRUFBRSxFQUN0QkMsc0JBQXNCLENBQUMsRUFDdkJDLGVBQWUsQ0FBQyxFQUNoQkMsc0JBQXNCLElBQUksRUFDMUJDLHNCQUFzQixJQUFJLEVBQzFCQyx1QkFBdUIsSUFBSSxFQUMzQkMscUJBQXFCLEVBQUUsRUFDMUIsR0Fid0M7O0lBY3JDLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHaEIsK0NBQVFBLENBQUMsRUFBRTtJQUcvQyxNQUFNaUIseUJBQXlCWCxnQ0FBQUEsaUNBQUFBLHNCQUF1QkQ7SUFDdEQsTUFBTWEseUJBQXlCWCxnQ0FBQUEsaUNBQUFBLHNCQUF1QkY7SUFDdEQsTUFBTWMseUJBQXlCUixnQ0FBQUEsaUNBQUFBLHNCQUF1QkQ7SUFDdEQsTUFBTVUseUJBQXlCUixnQ0FBQUEsaUNBQUFBLHNCQUF1QkY7SUFHdEQsb0NBQW9DO0lBQ3BDLE1BQU1XLHdCQUF3QnBCLGtEQUFXQTsrREFBQyxDQUFDcUI7WUFDdkMsSUFBSUMsVUFBVTtZQUNkLEtBQUssTUFBTUMsS0FBS1YsbUJBQW9CO2dCQUNoQyxJQUFJVSxFQUFFQyxFQUFFLEtBQUtILFdBQVc7Z0JBQ3hCQyxXQUFXQyxFQUFFRSxNQUFNO1lBQ3ZCO1lBQ0EsT0FBT0g7UUFDWDs4REFBRztRQUFDVDtLQUFtQjtJQUV2QixNQUFNYSx5QkFBeUIxQixrREFBV0E7Z0VBQUMsQ0FBQzJCLE9BQU9DO1lBQy9DLE1BQU1DLE1BQU1ELFFBQVFFLElBQUk7NEVBQUNDLENBQUFBLElBQUtBLEVBQUVQLEVBQUUsS0FBS0c7O1lBQ3ZDLElBQUksRUFBQ0UsZ0JBQUFBLDBCQUFBQSxJQUFLUixTQUFTLEdBQUUsT0FBTztZQUM1QixPQUFPUixtQkFBbUJpQixJQUFJO3dFQUFDUCxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtLLElBQUlSLFNBQVM7MEVBQUs7UUFDbkU7K0RBQUc7UUFBQ1I7S0FBbUI7SUFFdkIsc0VBQXNFO0lBQ3RFLE1BQU1tQixnQkFBZ0IsU0FBQ0MsR0FBR0MsU0FBU0M7WUFBVUMsdUVBQU07UUFDL0MsTUFBTUMsU0FBU0gsUUFBUUksQ0FBQyxHQUFHSixRQUFRSyxNQUFNLEdBQUc7UUFDNUMsTUFBTUMsVUFBVUwsU0FBU0csQ0FBQyxHQUFHSCxTQUFTSSxNQUFNLEdBQUc7UUFDL0MsSUFBSUUsSUFBSUM7UUFDUixJQUFJRixXQUFXSCxRQUFRO1lBQ25CSSxLQUFLTixTQUFTRyxDQUFDLEdBQUdILFNBQVNJLE1BQU0sR0FBR0gsS0FBSyxnQ0FBZ0M7WUFDekVNLEtBQUtSLFFBQVFJLENBQUMsR0FBR0YsS0FBeUIsZ0NBQWdDO1FBQzlFLE9BQU87WUFDSEssS0FBS1AsUUFBUUksQ0FBQyxHQUFHSixRQUFRSyxNQUFNLEdBQUdIO1lBQ2xDTSxLQUFLUCxTQUFTRyxDQUFDLEdBQUdGO1FBQ3RCO1FBQ0EsT0FBTztZQUFDSDtZQUFHUTtZQUFJUjtZQUFHUztTQUFHO0lBQ3pCO0lBRUEsTUFBTUMsa0JBQWtCLFNBQUNMLEdBQUdKLFNBQVNDO1lBQVVDLHVFQUFNO1FBQ2pELE1BQU1RLFNBQVNWLFFBQVFELENBQUMsR0FBR0MsUUFBUVcsS0FBSyxHQUFHO1FBQzNDLE1BQU1DLFVBQVVYLFNBQVNGLENBQUMsR0FBR0UsU0FBU1UsS0FBSyxHQUFHO1FBQzlDLElBQUlFLElBQUlDO1FBQ1IsSUFBSUYsV0FBV0YsUUFBUTtZQUNuQkcsS0FBS1osU0FBU0YsQ0FBQyxHQUFHRSxTQUFTVSxLQUFLLEdBQUdULEtBQUssK0JBQStCO1lBQ3ZFWSxLQUFLZCxRQUFRRCxDQUFDLEdBQUdHLEtBQXdCLGlDQUFpQztRQUM5RSxPQUFPO1lBQ0hXLEtBQUtiLFFBQVFELENBQUMsR0FBR0MsUUFBUVcsS0FBSyxHQUFHVDtZQUNqQ1ksS0FBS2IsU0FBU0YsQ0FBQyxHQUFHRztRQUN0QjtRQUNBLE9BQU87WUFBQ1c7WUFBSVQ7WUFBR1U7WUFBSVY7U0FBRTtJQUN6QjtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNVyxnQkFBZ0IsQ0FBQ0MsTUFBTUMsWUFBWUM7UUFDckMsSUFBSUYsU0FBUyxLQUFLO1lBQ2QsTUFBTUcsU0FBU0QsSUFBSW5CLENBQUMsR0FBR21CLElBQUlQLEtBQUssR0FBRztZQUNuQyxNQUFNUyxPQUFPRixJQUFJbkIsQ0FBQztZQUNsQixNQUFNc0IsUUFBUUgsSUFBSW5CLENBQUMsR0FBR21CLElBQUlQLEtBQUs7WUFDL0IsTUFBTVcsT0FBTztnQkFDVDtvQkFBRUMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDTixTQUFTRjtvQkFBYVMsT0FBT1QsYUFBYUU7Z0JBQU87Z0JBQ2xFO29CQUFFSSxNQUFNQyxLQUFLQyxHQUFHLENBQUNMLE9BQU9IO29CQUFhUyxPQUFPVCxhQUFhRztnQkFBSztnQkFDOUQ7b0JBQUVHLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQ0osUUFBUUo7b0JBQWFTLE9BQU9ULGFBQWFJO2dCQUFNO2FBQ25FLENBQUNNLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFTCxJQUFJLEdBQUdNLEVBQUVOLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDcEMsT0FBT0QsS0FBS0ksS0FBSztRQUNyQixPQUFPO1lBQ0gsTUFBTVAsU0FBU0QsSUFBSWQsQ0FBQyxHQUFHYyxJQUFJYixNQUFNLEdBQUc7WUFDcEMsTUFBTXlCLE1BQU1aLElBQUlkLENBQUM7WUFDakIsTUFBTTJCLFNBQVNiLElBQUlkLENBQUMsR0FBR2MsSUFBSWIsTUFBTTtZQUNqQyxNQUFNaUIsT0FBTztnQkFDVDtvQkFBRUMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDTixTQUFTRjtvQkFBYVMsT0FBT1QsYUFBYUU7Z0JBQU87Z0JBQ2xFO29CQUFFSSxNQUFNQyxLQUFLQyxHQUFHLENBQUNLLE1BQU1iO29CQUFhUyxPQUFPVCxhQUFhYTtnQkFBSTtnQkFDNUQ7b0JBQUVQLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQ00sU0FBU2Q7b0JBQWFTLE9BQU9ULGFBQWFjO2dCQUFPO2FBQ3JFLENBQUNKLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFTCxJQUFJLEdBQUdNLEVBQUVOLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDcEMsT0FBT0QsS0FBS0ksS0FBSztRQUNyQjtJQUNKO0lBRUEscUVBQXFFO0lBQ3JFLE1BQU1NLGVBQWUsQ0FBQ2hCLE1BQU1DLFlBQVlDO1FBQ3BDLElBQUlGLFNBQVMsS0FBSztZQUNkLE1BQU1HLFNBQVNELElBQUluQixDQUFDLEdBQUdtQixJQUFJUCxLQUFLLEdBQUc7WUFDbkMsTUFBTVMsT0FBT0YsSUFBSW5CLENBQUM7WUFDbEIsTUFBTXNCLFFBQVFILElBQUluQixDQUFDLEdBQUdtQixJQUFJUCxLQUFLO1lBQy9CLE9BQU9hLEtBQUtTLEdBQUcsQ0FDWFQsS0FBS0MsR0FBRyxDQUFDTixTQUFTRixhQUNsQk8sS0FBS0MsR0FBRyxDQUFDTCxPQUFPSCxhQUNoQk8sS0FBS0MsR0FBRyxDQUFDSixRQUFRSjtRQUV6QjtRQUNBLE1BQU1FLFNBQVNELElBQUlkLENBQUMsR0FBR2MsSUFBSWIsTUFBTSxHQUFHO1FBQ3BDLE1BQU15QixNQUFNWixJQUFJZCxDQUFDO1FBQ2pCLE1BQU0yQixTQUFTYixJQUFJZCxDQUFDLEdBQUdjLElBQUliLE1BQU07UUFDakMsT0FBT21CLEtBQUtTLEdBQUcsQ0FDWFQsS0FBS0MsR0FBRyxDQUFDTixTQUFTRixhQUNsQk8sS0FBS0MsR0FBRyxDQUFDSyxNQUFNYixhQUNmTyxLQUFLQyxHQUFHLENBQUNNLFNBQVNkO0lBRTFCO0lBRUEsOERBQThEO0lBQzlELE1BQU1pQixhQUFhLFNBQUNDLE1BQU1DO1lBQU96Qyx1RUFBTTtRQUNuQyxJQUFJLENBQUN3QyxRQUFRLENBQUNDLFNBQVMsT0FBT0QsS0FBS0UsYUFBYSxLQUFLLFlBQVksT0FBTztRQUV4RSxNQUFNQyxXQUFXO1lBQUVDLFlBQVlIO1FBQU07UUFFckMsSUFDSXpDLENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBSzZDLElBQUksTUFBSyxhQUNkQyxPQUFPQyxRQUFRLENBQUNELE9BQU85QyxnQkFBQUEsMEJBQUFBLElBQUtnQixLQUFLLE1BQ2pDOEIsT0FBT0MsUUFBUSxDQUFDRCxPQUFPOUMsZ0JBQUFBLDBCQUFBQSxJQUFLVSxNQUFNLElBQ3BDO1lBQ0UsTUFBTXNDLFlBQVksT0FBT1IsS0FBS3BDLENBQUMsS0FBSyxhQUFhb0MsS0FBS3BDLENBQUMsS0FBSztZQUM1RCxNQUFNNkMsWUFBWSxPQUFPVCxLQUFLL0IsQ0FBQyxLQUFLLGFBQWErQixLQUFLL0IsQ0FBQyxLQUFLO1lBQzVELE1BQU15QyxTQUNGLE9BQU9WLEtBQUtXLG1CQUFtQixLQUFLLGFBQzlCWCxLQUFLVyxtQkFBbUIsQ0FBQ1YsU0FDekI7WUFDVixNQUFNckMsSUFDRjBDLE9BQU9DLFFBQVEsQ0FBQ0MsYUFDVkEsWUFDQUYsT0FBT0MsUUFBUSxDQUFDRyxtQkFBQUEsNkJBQUFBLE9BQVE5QyxDQUFDLElBQ3pCOEMsT0FBTzlDLENBQUMsR0FDUCxPQUFPb0MsS0FBS3BDLENBQUMsS0FBSyxhQUFhb0MsS0FBS3BDLENBQUMsS0FBSztZQUNyRCxNQUFNSyxJQUNGcUMsT0FBT0MsUUFBUSxDQUFDRSxhQUNWQSxZQUNBSCxPQUFPQyxRQUFRLENBQUNHLG1CQUFBQSw2QkFBQUEsT0FBUXpDLENBQUMsSUFDekJ5QyxPQUFPekMsQ0FBQyxHQUNQLE9BQU8rQixLQUFLL0IsQ0FBQyxLQUFLLGFBQWErQixLQUFLL0IsQ0FBQyxLQUFLO1lBRXJELE9BQU87Z0JBQ0hMO2dCQUNBSztnQkFDQU8sT0FBTzhCLE9BQU85QyxJQUFJZ0IsS0FBSztnQkFDdkJOLFFBQVFvQyxPQUFPOUMsSUFBSVUsTUFBTTtZQUM3QjtRQUNKO1FBRUEsK0VBQStFO1FBQy9FLElBQUlWLENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBSzZDLElBQUksTUFBSyxhQUFhLE9BQU9MLEtBQUtZLE9BQU8sS0FBSyxZQUFZO1lBQy9ELE1BQU1DLGVBQWViLEtBQUtZLE9BQU8sQ0FBQztZQUNsQyxJQUFJQyxnQkFBZ0IsT0FBT0EsYUFBYVgsYUFBYSxLQUFLLFlBQVk7Z0JBQ2xFLElBQUk7b0JBQ0EsT0FBT1csYUFBYVgsYUFBYSxDQUFDO3dCQUM5QkUsWUFBWUg7d0JBQ1phLFlBQVk7d0JBQ1pDLFlBQVk7b0JBQ2hCO2dCQUNKLEVBQUUsVUFBTTtnQkFDSiw0QkFBNEI7Z0JBQ2hDO1lBQ0o7UUFDSjtRQUVBLElBQUk7WUFDQSxPQUFPZixLQUFLRSxhQUFhLENBQUNDO1FBQzlCLEVBQUUsVUFBTTtZQUNKLE9BQU87UUFDWDtJQUNKO0lBRUEsTUFBTWEseUJBQXlCLENBQUNoQixNQUFNQyxPQUFPMUMsU0FBUzBELGFBQWFDLFFBQVFsRSxXQUFXbUU7UUFDbEYsTUFBTUMsVUFBVUQsUUFBUUUsR0FBRyxDQUFDSCxXQUFXO1FBQ3ZDLE1BQU1yRCxVQUFVa0MsV0FBV0MsTUFBTUMsT0FBT21CO1FBQ3hDLElBQUksQ0FBQ3ZELFNBQVMsT0FBTyxFQUFFO1FBQ3ZCLE1BQU15RCxhQUFhL0QsUUFDZGdFLE1BQU0sQ0FBQzdELENBQUFBLElBQUtBLEVBQUVQLEVBQUUsS0FBSytELFVBQVV4RCxFQUFFVixTQUFTLEtBQUtBLFdBQVcsbUJBQW1CO1NBQzdFd0UsR0FBRyxDQUFDOUQsQ0FBQUE7Z0JBQ1N1RDtZQUFWLE1BQU1RLEtBQUlSLHVCQUFBQSxZQUFZUyxPQUFPLGNBQW5CVCwyQ0FBQUEsb0JBQXFCLENBQUN2RCxFQUFFUCxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDc0UsR0FBRyxPQUFPO1lBQ2YsSUFBSTtnQkFDQSxNQUFNL0IsSUFBSUssV0FBVzBCLEdBQUd4QixPQUFPa0IsUUFBUUUsR0FBRyxDQUFDM0QsRUFBRVAsRUFBRSxLQUFLO2dCQUNwRCxJQUFJLENBQUN1QyxHQUFHLE9BQU87Z0JBQ2YsTUFBTWlDLElBQUl0QyxLQUFLQyxHQUFHLENBQUMsUUFBUzFCLENBQUMsR0FBR0MsUUFBUVcsS0FBSyxHQUFHLElBQU1rQixDQUFBQSxFQUFFOUIsQ0FBQyxHQUFHOEIsRUFBRWxCLEtBQUssR0FBRyxNQUNoRWEsS0FBS0MsR0FBRyxDQUFDLFFBQVNyQixDQUFDLEdBQUdKLFFBQVFLLE1BQU0sR0FBRyxJQUFNd0IsQ0FBQUEsRUFBRXpCLENBQUMsR0FBR3lCLEVBQUV4QixNQUFNLEdBQUc7Z0JBQ3BFLE9BQU87b0JBQUVhLEtBQUtXO29CQUFHaUM7Z0JBQUU7WUFDdkIsRUFBRSxVQUFNO2dCQUFFLE9BQU87WUFBTTtRQUMzQixHQUNDSixNQUFNLENBQUNLLFNBQ1BwQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRWtDLENBQUMsR0FBR2pDLEVBQUVpQyxDQUFDLEVBQ3hCRSxLQUFLLENBQUMsR0FBRyxJQUFJLDhCQUE4QjtRQUVoRCxNQUFNQyxJQUFJLEVBQUU7UUFDWixLQUFLLE1BQU0sRUFBRS9DLEdBQUcsRUFBRSxJQUFJdUMsV0FBWTtZQUM5QixNQUFNUyxLQUFLaEQsSUFBSW5CLENBQUMsR0FBR21CLElBQUlQLEtBQUssR0FBRztZQUMvQixNQUFNd0QsS0FBS2pELElBQUlkLENBQUMsR0FBR2MsSUFBSWIsTUFBTSxHQUFHO1lBQ2hDLE1BQU1lLE9BQU9GLElBQUluQixDQUFDO1lBQ2xCLE1BQU1zQixRQUFRSCxJQUFJbkIsQ0FBQyxHQUFHbUIsSUFBSVAsS0FBSztZQUMvQixNQUFNbUIsTUFBTVosSUFBSWQsQ0FBQztZQUNqQixNQUFNMkIsU0FBU2IsSUFBSWQsQ0FBQyxHQUFHYyxJQUFJYixNQUFNO1lBRWpDLFVBQVU7WUFDVjRELEVBQUVHLElBQUksQ0FBQztnQkFBRXBELE1BQU07Z0JBQUtxRCxPQUFPSDtnQkFBSUksTUFBTTtnQkFBU0MsV0FBV3JEO2dCQUFLc0QsVUFBVTtnQkFBWUMsT0FBTztZQUFTO1lBQ3BHUixFQUFFRyxJQUFJLENBQUM7Z0JBQUVwRCxNQUFNO2dCQUFLcUQsT0FBT0Y7Z0JBQUlHLE1BQU07Z0JBQVNDLFdBQVdyRDtnQkFBS3NELFVBQVU7Z0JBQVlDLE9BQU87WUFBUztZQUNwRyxTQUFTO1lBQ1RSLEVBQUVHLElBQUksQ0FBQztnQkFBRXBELE1BQU07Z0JBQUtxRCxPQUFPakQ7Z0JBQU1rRCxNQUFNO2dCQUFXQyxXQUFXckQ7Z0JBQUtzRCxVQUFVO2dCQUFZQyxPQUFPO1lBQVM7WUFDeEdSLEVBQUVHLElBQUksQ0FBQztnQkFBRXBELE1BQU07Z0JBQUtxRCxPQUFPaEQ7Z0JBQU9pRCxNQUFNO2dCQUFZQyxXQUFXckQ7Z0JBQUtzRCxVQUFVO2dCQUFZQyxPQUFPO1lBQVM7WUFDMUdSLEVBQUVHLElBQUksQ0FBQztnQkFBRXBELE1BQU07Z0JBQUtxRCxPQUFPdkM7Z0JBQUt3QyxNQUFNO2dCQUFVQyxXQUFXckQ7Z0JBQUtzRCxVQUFVO2dCQUFZQyxPQUFPO1lBQVM7WUFDdEdSLEVBQUVHLElBQUksQ0FBQztnQkFBRXBELE1BQU07Z0JBQUtxRCxPQUFPdEM7Z0JBQVF1QyxNQUFNO2dCQUFhQyxXQUFXckQ7Z0JBQUtzRCxVQUFVO2dCQUFZQyxPQUFPO1lBQVM7UUFDaEg7UUFDQSxPQUFPUjtJQUNYO0lBRUEsTUFBTVMsY0FBYyxDQUFDQyxLQUFLdkMsT0FBT2dCLGFBQWFFO1FBQzFDLElBQUksQ0FBQ3NCLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUUEsSUFBSUcsTUFBTSxLQUFLLEdBQUcsT0FBTztRQUVwRCxJQUFJQyxPQUFPdEMsT0FBT3VDLGlCQUFpQjtRQUNuQyxJQUFJQyxPQUFPeEMsT0FBT3VDLGlCQUFpQjtRQUNuQyxJQUFJRSxPQUFPekMsT0FBTzBDLGlCQUFpQjtRQUNuQyxJQUFJQyxPQUFPM0MsT0FBTzBDLGlCQUFpQjtRQUVuQ1IsSUFBSVUsT0FBTyxDQUFDLENBQUMvRjtnQkFDQzhEO1lBQVYsTUFBTVEsS0FBSVIsdUJBQUFBLFlBQVlTLE9BQU8sY0FBbkJULDJDQUFBQSxvQkFBcUIsQ0FBQzlELEdBQUc7WUFDbkMsSUFBSSxDQUFDc0UsR0FBRztZQUNSLE1BQU0vQixJQUFJSyxXQUFXMEIsR0FBR3hCLE9BQU9rQixRQUFRRSxHQUFHLENBQUNsRSxPQUFPO1lBQ2xELElBQUksQ0FBQ3VDLEdBQUc7WUFDUmtELE9BQU92RCxLQUFLUyxHQUFHLENBQUM4QyxNQUFNbEQsRUFBRTlCLENBQUM7WUFDekJrRixPQUFPekQsS0FBS1MsR0FBRyxDQUFDZ0QsTUFBTXBELEVBQUV6QixDQUFDO1lBQ3pCOEUsT0FBTzFELEtBQUs4RCxHQUFHLENBQUNKLE1BQU1yRCxFQUFFOUIsQ0FBQyxHQUFHOEIsRUFBRWxCLEtBQUs7WUFDbkN5RSxPQUFPNUQsS0FBSzhELEdBQUcsQ0FBQ0YsTUFBTXZELEVBQUV6QixDQUFDLEdBQUd5QixFQUFFeEIsTUFBTTtRQUN4QztRQUVBLElBQ0ksQ0FBQ29DLE9BQU9DLFFBQVEsQ0FBQ3FDLFNBQ2pCLENBQUN0QyxPQUFPQyxRQUFRLENBQUN1QyxTQUNqQixDQUFDeEMsT0FBT0MsUUFBUSxDQUFDd0MsU0FDakIsQ0FBQ3pDLE9BQU9DLFFBQVEsQ0FBQzBDLE9BQ25CO1lBQ0UsT0FBTztRQUNYO1FBRUEsT0FBTztZQUNIckYsR0FBR2dGO1lBQ0gzRSxHQUFHNkU7WUFDSHRFLE9BQU9hLEtBQUs4RCxHQUFHLENBQUMsR0FBR0osT0FBT0g7WUFDMUIxRSxRQUFRbUIsS0FBSzhELEdBQUcsQ0FBQyxHQUFHRixPQUFPSDtRQUMvQjtJQUNKO0lBRUEsTUFBTU0sYUFBYSxDQUFDWixLQUFLM0QsTUFBTVUsT0FBTzBCO1FBQ2xDLElBQUksQ0FBQ3dCLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUUEsSUFBSUcsTUFBTSxLQUFLLEtBQUssQ0FBQ3JDLE9BQU9DLFFBQVEsQ0FBQ2hCLFFBQVE7UUFDeEUsSUFBSUYsS0FBS0MsR0FBRyxDQUFDQyxTQUFTLFFBQVE7UUFFOUIsTUFBTThELGNBQWMsQ0FBQ3JEO1lBQ2pCLElBQUksQ0FBQ0EsTUFBTTtZQUNYLElBQUk7Z0JBQ0EsSUFBSW5CLFNBQVMsS0FBSztvQkFDZG1CLEtBQUtwQyxDQUFDLENBQUNvQyxLQUFLcEMsQ0FBQyxLQUFLMkI7Z0JBQ3RCLE9BQU87b0JBQ0hTLEtBQUsvQixDQUFDLENBQUMrQixLQUFLL0IsQ0FBQyxLQUFLc0I7Z0JBQ3RCO1lBQ0osRUFBRSxVQUFNO1lBQ0osaUNBQWlDO1lBQ3JDO1FBQ0o7UUFFQWlELElBQUlVLE9BQU8sQ0FBQyxDQUFDL0Y7Z0JBQ0M4RCxzQkFHRUE7WUFIWixNQUFNUSxLQUFJUix1QkFBQUEsWUFBWVMsT0FBTyxjQUFuQlQsMkNBQUFBLG9CQUFxQixDQUFDOUQsR0FBRztZQUNuQ2tHLFlBQVk1QjtZQUNaLHFFQUFxRTtZQUNyRTRCLGFBQVlwQyx3QkFBQUEsWUFBWVMsT0FBTyxjQUFuQlQsNENBQUFBLHFCQUFxQixDQUFDLEdBQU0sT0FBSDlELElBQUcsU0FBTztRQUNuRDtJQUNKO0lBRUEsMENBQTBDO0lBQzFDLE1BQU1tRyxlQUFlM0gsa0RBQVdBO3NEQUFDLENBQUM0SCxLQUFLQyxVQUFVakcsU0FBUzBEO2dCQUN6Q0Esc0JBRUNqQjtZQUZkLE1BQU1BLFFBQU9pQix1QkFBQUEsWUFBWVMsT0FBTyxjQUFuQlQsMkNBQUFBLG9CQUFxQixDQUFDdUMsU0FBUztZQUM1QyxJQUFJLENBQUN4RCxNQUFNO1lBQ1gsTUFBTUMsU0FBUUQsaUJBQUFBLEtBQUt5RCxRQUFRLGNBQWJ6RCxxQ0FBQUEsb0JBQUFBO1lBQ2QsSUFBSSxDQUFDQyxPQUFPO1lBRVosSUFBSTtvQkFxSjBFeUQsa0JBQUFBLGdCQVFBQyxrQkFBQUE7Z0JBNUoxRSxNQUFNeEMsVUFBVSxJQUFJeUMsSUFBSXJHLFFBQVFpRSxHQUFHO2tFQUFDLENBQUM5RCxJQUFNOzRCQUFDQSxFQUFFUCxFQUFFOzRCQUFFTzt5QkFBRTs7Z0JBQ3BELE1BQU1tRyxZQUFZMUMsUUFBUUUsR0FBRyxDQUFDbUMsYUFBYTtnQkFDM0MsTUFBTU0sZ0JBQWdCQyxPQUFPQyxXQUFXLElBQUlSLGFBQWFPLE9BQU9DLFdBQVc7Z0JBQzNFLE1BQU1DLGNBQWN4QixNQUFNQyxPQUFPLENBQUNxQixPQUFPRyxlQUFlLEtBQUtILE9BQU9HLGVBQWUsQ0FBQ3ZCLE1BQU0sR0FBRyxJQUN2Rm9CLE9BQU9HLGVBQWUsR0FDckJ6QixNQUFNQyxPQUFPLENBQUNxQixPQUFPSSx1QkFBdUIsSUFBSUosT0FBT0ksdUJBQXVCLEdBQUcsRUFBRTtnQkFDMUYsTUFBTUMsV0FBV04sZ0JBQ1g7dUJBQUksSUFBSU8sSUFBSUosWUFBWTFDLE1BQU0sQ0FBQ0s7aUJBQVUsR0FDekMsRUFBRTtnQkFDUixNQUFNMEMsY0FBY1IsaUJBQWlCTSxTQUFTekIsTUFBTSxHQUFHO2dCQUV2RCxNQUFNNEIsZ0JBQWdCRCxjQUNoQi9CLFlBQVk2QixVQUFVbkUsT0FBT2dCLGFBQWFFLFdBQzFDcEIsV0FBV0MsTUFBTUMsT0FBTzREO2dCQUM5QixJQUFJLENBQUNVLGVBQWU7Z0JBQ3BCLE1BQU1oRyxTQUFTZ0csY0FBYzNHLENBQUMsR0FBRzJHLGNBQWMvRixLQUFLLEdBQUc7Z0JBQ3ZELE1BQU1SLFNBQVN1RyxjQUFjdEcsQ0FBQyxHQUFHc0csY0FBY3JHLE1BQU0sR0FBRztnQkFFeEQsTUFBTXNHLFVBQVVuSCx1QkFBdUJtRyxVQUFVakc7Z0JBQ2pELElBQUksQ0FBQ2lILFNBQVM7b0JBQ1Y5SCxjQUFjLEVBQUU7b0JBQ2hCO2dCQUNKO2dCQUNBLE1BQU0rSCxPQUFPMUgsc0JBQXNCeUgsUUFBUXJILEVBQUU7Z0JBQzdDLE1BQU11SCxRQUFRN0ksY0FBYztnQkFDNUIsTUFBTThJLFFBQVFGLE9BQU9ELFFBQVFwSCxNQUFNLEdBQUc7Z0JBRXRDLE1BQU13SCxRQUFRLEVBQUU7Z0JBRWhCLHNEQUFzRDtnQkFDdEQsTUFBTUMsV0FBV3hGLEtBQUtDLEdBQUcsQ0FBQ2YsU0FBU21HO2dCQUNuQyxNQUFNSSxXQUFXekYsS0FBS0MsR0FBRyxDQUFDdEIsU0FBUzJHO2dCQUVuQywrREFBK0Q7Z0JBQy9ELE1BQU1JLGdCQUFnQlQsY0FDaEIsRUFBRSxHQUNGdEQsdUJBQ0VoQixNQUNBQyxPQUNBMUMsU0FDQTBELGFBQ0F1QyxVQUNBZ0IsUUFBUXJILEVBQUUsRUFDVmdFO2dCQUdSLE1BQU02RCxVQUFVVixjQUNWLE9BQ0FTLGNBQ0d4RCxNQUFNO2tFQUFDTyxDQUFBQSxJQUFLQSxFQUFFakQsSUFBSSxLQUFLO2lFQUN2QjJDLEdBQUc7a0VBQUNNLENBQUFBLElBQU07NEJBQUVBOzRCQUFHMUMsTUFBTVMsYUFBYSxLQUFLaUMsRUFBRUksS0FBSyxFQUFFcUM7d0JBQWU7aUVBQy9EL0UsSUFBSTtrRUFBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFTCxJQUFJLEdBQUdNLEVBQUVOLElBQUk7Z0VBQUMsQ0FBQyxFQUFFO2dCQUUzQyxNQUFNNkYsVUFBVVgsY0FDVixPQUNBUyxjQUNHeEQsTUFBTTtrRUFBQ08sQ0FBQUEsSUFBS0EsRUFBRWpELElBQUksS0FBSztpRUFDdkIyQyxHQUFHO2tFQUFDTSxDQUFBQSxJQUFNOzRCQUFFQTs0QkFBRzFDLE1BQU1TLGFBQWEsS0FBS2lDLEVBQUVJLEtBQUssRUFBRXFDO3dCQUFlO2lFQUMvRC9FLElBQUk7a0VBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUwsSUFBSSxHQUFHTSxFQUFFTixJQUFJO2dFQUFDLENBQUMsRUFBRTtnQkFFM0Msd0RBQXdEO2dCQUN4RCxNQUFNOEY7OEVBQWMsQ0FBQ0MsZUFBZUM7d0JBQ2hDLE1BQU1DLFFBQVFGLGlCQUFpQnZJO3dCQUMvQixNQUFNMEksT0FBTyxDQUFDLENBQUNGLFVBQVVBLE9BQU9oRyxJQUFJLElBQUl6Qzt3QkFDeEMsSUFBSSxDQUFDMEksU0FBUyxDQUFDQyxNQUFNLE9BQU87d0JBQzVCLElBQUlELFNBQVMsQ0FBQ0MsTUFBTSxPQUFPOzRCQUFFQyxRQUFRO3dCQUFVO3dCQUMvQyxJQUFJLENBQUNGLFNBQVNDLE1BQU0sT0FBTzs0QkFBRUMsUUFBUTs0QkFBWUMsTUFBTUo7d0JBQU87d0JBRTlELGlEQUFpRDt3QkFDakQsTUFBTUssaUJBQWlCLE9BQVFyRyxJQUFJLEdBQUdqRCxzQkFBdUJnSjt3QkFDN0QsT0FBT00saUJBQ0Q7NEJBQUVGLFFBQVE7NEJBQVlDLE1BQU1KO3dCQUFPLElBQ25DOzRCQUFFRyxRQUFRO3dCQUFVO29CQUM5Qjs7Z0JBRUEsTUFBTUcsWUFBWVIsWUFBWUwsVUFBVUc7Z0JBQ3hDLE1BQU1XLFlBQVlULFlBQVlKLFVBQVVHO2dCQUd4QyxNQUFNVzs0RUFBWSxDQUFDL0csTUFBTWdIO3dCQUNyQixJQUFJLENBQUNBLFVBQVUsT0FBTzs0QkFBRUMsU0FBUzt3QkFBTTt3QkFDdkMsTUFBTUMsUUFBUXpCLGNBQ1IvQixZQUFZNkIsVUFBVW5FLE9BQU9nQixhQUFhRSxXQUMxQ3BCLFdBQVdDLE1BQU1DLE9BQU80RDt3QkFDOUIsSUFBSSxDQUFDa0MsT0FBTyxPQUFPOzRCQUFFRCxTQUFTO3dCQUFNO3dCQUVwQyxJQUFJRCxTQUFTTixNQUFNLEtBQUssV0FBVzs0QkFDL0IsTUFBTVMsYUFBYW5ILFNBQVMsTUFDdEJrSCxNQUFNbkksQ0FBQyxHQUFHbUksTUFBTXZILEtBQUssR0FBRyxJQUN4QnVILE1BQU05SCxDQUFDLEdBQUc4SCxNQUFNN0gsTUFBTSxHQUFHOzRCQUMvQixNQUFNK0gsZUFBZXBILFNBQVMsTUFBTTZGLFFBQVFDOzRCQUM1QyxNQUFNcEYsUUFBUSxDQUFDMEcsZUFBZUQsVUFBUyxJQUFLbko7NEJBRTVDLElBQUlnQyxTQUFTLEtBQUs7Z0NBQ2QsSUFBSXlGLGFBQWFsQixXQUFXZ0IsVUFBVSxLQUFLN0UsT0FBTzBCO3FDQUM3Q2pCLEtBQUtwQyxDQUFDLENBQUNvQyxLQUFLcEMsQ0FBQyxLQUFLMkI7NEJBQzNCLE9BQU87Z0NBQ0gsSUFBSStFLGFBQWFsQixXQUFXZ0IsVUFBVSxLQUFLN0UsT0FBTzBCO3FDQUM3Q2pCLEtBQUsvQixDQUFDLENBQUMrQixLQUFLL0IsQ0FBQyxLQUFLc0I7NEJBQzNCOzRCQUNBLE9BQU87Z0NBQUV1RyxTQUFTO2dDQUFNUCxRQUFROzRCQUFVO3dCQUM5Qzt3QkFFQSxJQUFJakIsYUFBYSxPQUFPOzRCQUFFd0IsU0FBUzt3QkFBTTt3QkFFekMsTUFBTXZHLFFBQVFYLGNBQWNDLE1BQU1nSCxTQUFTTCxJQUFJLENBQUMxRCxDQUFDLENBQUNJLEtBQUssRUFBRTZEO3dCQUN6RCxJQUFJbEgsU0FBUyxLQUFLbUIsS0FBS3BDLENBQUMsQ0FBQ29DLEtBQUtwQyxDQUFDLEtBQUsyQixRQUFRekM7NkJBQ3ZDa0QsS0FBSy9CLENBQUMsQ0FBQytCLEtBQUsvQixDQUFDLEtBQUtzQixRQUFRekM7d0JBQy9CLE9BQU87NEJBQUVnSixTQUFTOzRCQUFNUCxRQUFROzRCQUFZQyxNQUFNSyxTQUFTTCxJQUFJO3dCQUFDO29CQUNwRTs7Z0JBRUEsTUFBTTlCLFdBQVdrQyxVQUFVLEtBQUtGO2dCQUNoQyxNQUFNL0IsV0FBV2lDLFVBQVUsS0FBS0Q7Z0JBRWhDLDBEQUEwRDtnQkFDMUQsTUFBTU8sZUFBZTVCLGNBQ2YvQixZQUFZNkIsVUFBVW5FLE9BQU9nQixhQUFhRSxXQUMxQ3BCLFdBQVdDLE1BQU1DLE9BQU80RDtnQkFDOUIsSUFBSSxDQUFDcUMsY0FBYztnQkFDbkIsTUFBTUMsY0FBY0QsYUFBYXRJLENBQUMsR0FBR3NJLGFBQWExSCxLQUFLLEdBQUc7Z0JBQzFELE1BQU00SCxjQUFjRixhQUFhakksQ0FBQyxHQUFHaUksYUFBYWhJLE1BQU0sR0FBRztnQkFFM0QscUVBQXFFO2dCQUNyRSxJQUNJd0YsU0FBU29DLE9BQU8sSUFDaEJwQyxTQUFTNkIsTUFBTSxLQUFLLGFBQ3BCbEcsS0FBS0MsR0FBRyxDQUFDNkcsY0FBY3pCLFVBQVVuSSxzQkFDbkM7b0JBQ0VxSSxNQUFNM0MsSUFBSSxDQUFDO3dCQUNQRSxNQUFNO3dCQUNORSxVQUFVO3dCQUNWQyxPQUFPO3dCQUNQK0QsUUFBUTs0QkFBQzNCOzRCQUFPRDs0QkFBTUM7NEJBQU9ELE9BQU9ELFFBQVFwSCxNQUFNO3lCQUFDO29CQUN2RDtnQkFDSjtnQkFDQSxJQUNJdUcsU0FBU21DLE9BQU8sSUFDaEJuQyxTQUFTNEIsTUFBTSxLQUFLLGFBQ3BCbEcsS0FBS0MsR0FBRyxDQUFDOEcsY0FBY3pCLFVBQVVwSSxzQkFDbkM7b0JBQ0VxSSxNQUFNM0MsSUFBSSxDQUFDO3dCQUNQRSxNQUFNO3dCQUNORSxVQUFVO3dCQUNWQyxPQUFPO3dCQUNQK0QsUUFBUTs0QkFBQzs0QkFBRzFCOzRCQUFPOUk7NEJBQWE4STt5QkFBTTtvQkFDMUM7Z0JBQ0o7Z0JBRUEsSUFBSSxDQUFDTCxlQUFlWixTQUFTb0MsT0FBTyxJQUFJcEMsU0FBUzZCLE1BQU0sS0FBSyxnQkFBYzdCLGlCQUFBQSxTQUFTOEIsSUFBSSxjQUFiOUIsc0NBQUFBLG1CQUFBQSxlQUFlNUIsQ0FBQyxjQUFoQjRCLHVDQUFBQSxpQkFBa0J0QixTQUFTLEdBQUU7b0JBQ25Hd0MsTUFBTTNDLElBQUksQ0FBQzt3QkFDUEUsTUFBTTt3QkFDTkUsVUFBVTt3QkFDVkMsT0FBTzt3QkFDUCtELFFBQVExSSxjQUFjK0YsU0FBUzhCLElBQUksQ0FBQzFELENBQUMsQ0FBQ0ksS0FBSyxFQUFFZ0UsY0FBY3hDLFNBQVM4QixJQUFJLENBQUMxRCxDQUFDLENBQUNNLFNBQVM7b0JBQ3hGO2dCQUNKO2dCQUNBLElBQUksQ0FBQ2tDLGVBQWVYLFNBQVNtQyxPQUFPLElBQUluQyxTQUFTNEIsTUFBTSxLQUFLLGdCQUFjNUIsaUJBQUFBLFNBQVM2QixJQUFJLGNBQWI3QixzQ0FBQUEsbUJBQUFBLGVBQWU3QixDQUFDLGNBQWhCNkIsdUNBQUFBLGlCQUFrQnZCLFNBQVMsR0FBRTtvQkFDbkd3QyxNQUFNM0MsSUFBSSxDQUFDO3dCQUNQRSxNQUFNO3dCQUNORSxVQUFVO3dCQUNWQyxPQUFPO3dCQUNQK0QsUUFBUS9ILGdCQUFnQnFGLFNBQVM2QixJQUFJLENBQUMxRCxDQUFDLENBQUNJLEtBQUssRUFBRWdFLGNBQWN2QyxTQUFTNkIsSUFBSSxDQUFDMUQsQ0FBQyxDQUFDTSxTQUFTO29CQUMxRjtnQkFDSjtnQkFHQTFGLGNBQWNrSTtZQUNsQixFQUFFLE9BQU8wQixHQUFHO1lBQ1Isb0NBQW9DO1lBQ3hDO1FBQ0o7cURBQUc7UUFDQ3pLO1FBQWFDO1FBQ2JDO1FBQWNHO1FBQW1CRTtRQUNqQ0k7UUFDQWE7UUFBd0JOO1FBQ3hCZjtRQUFxQkM7UUFBcUJFO1FBQzFDRTtRQUFxQkM7UUFBcUJDO0tBQzdDO0lBRUQsTUFBTWdLLGVBQWU1SyxrREFBV0E7c0RBQUMsSUFBTWUsY0FBYyxFQUFFO3FEQUFHLEVBQUU7SUFDNUQsTUFBTThKLG9CQUFvQjdLLGtEQUFXQTsyREFBQyxJQUFNZSxjQUFjLEVBQUU7MERBQUcsRUFBRTtJQUVqRSxPQUFPO1FBQ0hEO1FBQ0E2RztRQUNBaUQ7UUFDQUM7SUFDSjtBQUNKO0dBM2R3QjVLIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxzcmNcXGhvb2tzXFx1c2VHdWlhc0NlbnRyYWRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGhvb2tzL3VzZUd1aWFzQ2VudHJhZG8uanNcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5cclxuLyoqXG4gKiBHdcOtYXMgY29uOlxuICogLSBTZWNjacOzbjogbXVlc3RyYSBDWC9DWSBzb2xvIGN1YW5kbyBlbCBlbGVtZW50byBxdWVkw7MgY2VudHJhZG8uXG4gKiAtIEVsZW1lbnRvczogU09MTyBtaXNtYSBzZWNjacOzbiwgbMOtbmVhcyBwdW50ZWFkYXMgdGlwbyBcInJlYWNoXCIgaGFzdGEgZWwgb3RybyBlbGVtZW50by5cbiAqIC0gTmFkYSBkZSBvdHJhcyBzZWNjaW9uZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUd1aWFzQ2VudHJhZG8oe1xuICAgIGFuY2hvQ2FudmFzID0gODAwLFxuICAgIGFsdG9DYW52YXMgPSA4MDAsXG4gICAgbWFnbmV0UmFkaXVzID0gMTYsICAgICAgIC8vIGRpc3RhbmNpYSBwYXJhIGFjdGl2YXIgZWwgc25hcFxuICAgIGVsZW1lbnRNYWduZXRSYWRpdXMgPSBudWxsLCAgIC8vIG51bGwgPT4gbWFnbmV0UmFkaXVzXG4gICAgc2VjdGlvbk1hZ25ldFJhZGl1cyA9IG51bGwsICAgLy8gbnVsbCA9PiBtYWduZXRSYWRpdXNcbiAgICBzZWN0aW9uU2hvd1JhZGl1cyA9IDE4LCAgLy8gbGVnYWRvIChubyB1c2FkbyBwYXJhIG1vc3RyYXIgbMOtbmVhcyBkZSBzZWNjacOzbilcbiAgICBzZWN0aW9uUHJpb3JpdHlCaWFzID0gNCwgICAgICAvLyB2ZW50YWphIGV4dHJhIHBhcmEgcXVlIGdhbmUgc2VjY2nDs24gdnMgZWxlbWVudG9zXG4gICAgc25hcFN0cmVuZ3RoID0gMSwgICAgICAgIC8vIDEgPSBwZWdhZG8gZXhhY3RvOyAwLjQtMC42ID0gdHJhY2Npw7NuIHN1YXZlXG4gICAgc2VjdGlvblNuYXBTdHJlbmd0aCA9IG51bGwsICAgLy8gbnVsbCA9PiBzbmFwU3RyZW5ndGhcbiAgICBlbGVtZW50U25hcFN0cmVuZ3RoID0gbnVsbCwgICAvLyBudWxsID0+IHNuYXBTdHJlbmd0aFxuICAgIHNlY3Rpb25MaW5lVG9sZXJhbmNlID0gMC43NSwgIC8vIHNvbG8gbW9zdHJhciBndcOtYSBkZSBzZWNjacOzbiBjdWFuZG8gZXN0w6EgcmVhbG1lbnRlIGNlbnRyYWRvXG4gICAgc2VjY2lvbmVzT3JkZW5hZGFzID0gW11cbn0pIHtcbiAgICBjb25zdCBbZ3VpYUxpbmVhcywgc2V0R3VpYUxpbmVhc10gPSB1c2VTdGF0ZShbXSk7XG5cclxuXHJcbiAgICBjb25zdCBlZmZFbGVtZW50TWFnbmV0UmFkaXVzID0gZWxlbWVudE1hZ25ldFJhZGl1cyA/PyBtYWduZXRSYWRpdXM7XG4gICAgY29uc3QgZWZmU2VjdGlvbk1hZ25ldFJhZGl1cyA9IHNlY3Rpb25NYWduZXRSYWRpdXMgPz8gbWFnbmV0UmFkaXVzO1xuICAgIGNvbnN0IGVmZlNlY3Rpb25TbmFwU3RyZW5ndGggPSBzZWN0aW9uU25hcFN0cmVuZ3RoID8/IHNuYXBTdHJlbmd0aDtcbiAgICBjb25zdCBlZmZFbGVtZW50U25hcFN0cmVuZ3RoID0gZWxlbWVudFNuYXBTdHJlbmd0aCA/PyBzbmFwU3RyZW5ndGg7XG5cclxuXHJcbiAgICAvLyAtLS0tIFV0aWxpZGFkZXMgZGUgc2VjY2lvbmVzIC0tLS1cclxuICAgIGNvbnN0IGNhbGN1bGFyT2Zmc2V0U2VjY2lvbiA9IHVzZUNhbGxiYWNrKChzZWNjaW9uSWQpID0+IHtcclxuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHNlY2Npb25lc09yZGVuYWRhcykge1xyXG4gICAgICAgICAgICBpZiAocy5pZCA9PT0gc2VjY2lvbklkKSBicmVhaztcclxuICAgICAgICAgICAgb2Zmc2V0WSArPSBzLmFsdHVyYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldFk7XHJcbiAgICB9LCBbc2VjY2lvbmVzT3JkZW5hZGFzXSk7XHJcblxyXG4gICAgY29uc3Qgb2J0ZW5lclNlY2Npb25FbGVtZW50byA9IHVzZUNhbGxiYWNrKChvYmpJZCwgb2JqZXRvcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG9iamV0b3MuZmluZChvID0+IG8uaWQgPT09IG9iaklkKTtcclxuICAgICAgICBpZiAoIW9iaj8uc2VjY2lvbklkKSByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gc2VjY2lvbmVzT3JkZW5hZGFzLmZpbmQocyA9PiBzLmlkID09PSBvYmouc2VjY2lvbklkKSB8fCBudWxsO1xyXG4gICAgfSwgW3NlY2Npb25lc09yZGVuYWRhc10pO1xyXG5cclxuICAgIC8vIC0tLS0gU2VnbWVudG9zIFwicmVhY2hcIiBlbnRyZSBjYWphcyAodmEgaGFzdGEgZWwgb3RybyBlbGVtZW50bykgLS0tLVxyXG4gICAgY29uc3QgcmVhY2hWZXJ0aWNhbCA9ICh4LCBzZWxmQm94LCBvdGhlckJveCwgZ2FwID0gNikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbGZDeSA9IHNlbGZCb3gueSArIHNlbGZCb3guaGVpZ2h0IC8gMjtcclxuICAgICAgICBjb25zdCBvdGhlckN5ID0gb3RoZXJCb3gueSArIG90aGVyQm94LmhlaWdodCAvIDI7XHJcbiAgICAgICAgbGV0IHkxLCB5MjtcclxuICAgICAgICBpZiAob3RoZXJDeSA8PSBzZWxmQ3kpIHtcclxuICAgICAgICAgICAgeTEgPSBvdGhlckJveC55ICsgb3RoZXJCb3guaGVpZ2h0ICsgZ2FwOyAvLyBkZXNkZSBib3JkZSBpbmZlcmlvciBkZWwgb3Ryb1xyXG4gICAgICAgICAgICB5MiA9IHNlbGZCb3gueSAtIGdhcDsgICAgICAgICAgICAgICAgICAgICAvLyBoYXN0YSBib3JkZSBzdXBlcmlvciBkZWwgc2VsZlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkxID0gc2VsZkJveC55ICsgc2VsZkJveC5oZWlnaHQgKyBnYXA7XHJcbiAgICAgICAgICAgIHkyID0gb3RoZXJCb3gueSAtIGdhcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt4LCB5MSwgeCwgeTJdO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByZWFjaEhvcml6b250YWwgPSAoeSwgc2VsZkJveCwgb3RoZXJCb3gsIGdhcCA9IDYpID0+IHtcclxuICAgICAgICBjb25zdCBzZWxmQ3ggPSBzZWxmQm94LnggKyBzZWxmQm94LndpZHRoIC8gMjtcclxuICAgICAgICBjb25zdCBvdGhlckN4ID0gb3RoZXJCb3gueCArIG90aGVyQm94LndpZHRoIC8gMjtcclxuICAgICAgICBsZXQgeDEsIHgyO1xyXG4gICAgICAgIGlmIChvdGhlckN4IDw9IHNlbGZDeCkge1xyXG4gICAgICAgICAgICB4MSA9IG90aGVyQm94LnggKyBvdGhlckJveC53aWR0aCArIGdhcDsgLy8gZGVzZGUgYm9yZGUgZGVyZWNobyBkZWwgb3Ryb1xyXG4gICAgICAgICAgICB4MiA9IHNlbGZCb3gueCAtIGdhcDsgICAgICAgICAgICAgICAgICAgIC8vIGhhc3RhIGJvcmRlIGl6cXVpZXJkbyBkZWwgc2VsZlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHgxID0gc2VsZkJveC54ICsgc2VsZkJveC53aWR0aCArIGdhcDtcclxuICAgICAgICAgICAgeDIgPSBvdGhlckJveC54IC0gZ2FwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3gxLCB5LCB4MiwgeV07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIC0tLS0gRGVsdGEgcGFyYSBhbGluZWFyIGEgbGEgZ3XDrWEgbcOhcyBjZXJjYW5hIC0tLS1cclxuICAgIGNvbnN0IGRlbHRhRm9yR3VpZGUgPSAoYXhpcywgZ3VpZGVWYWx1ZSwgYm94KSA9PiB7XHJcbiAgICAgICAgaWYgKGF4aXMgPT09IFwieFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGJveC54ICsgYm94LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGJveC54O1xyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGJveC54ICsgYm94LndpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBvcHRzID0gW1xyXG4gICAgICAgICAgICAgICAgeyBkaXN0OiBNYXRoLmFicyhjZW50ZXIgLSBndWlkZVZhbHVlKSwgZGVsdGE6IGd1aWRlVmFsdWUgLSBjZW50ZXIgfSxcclxuICAgICAgICAgICAgICAgIHsgZGlzdDogTWF0aC5hYnMobGVmdCAtIGd1aWRlVmFsdWUpLCBkZWx0YTogZ3VpZGVWYWx1ZSAtIGxlZnQgfSxcclxuICAgICAgICAgICAgICAgIHsgZGlzdDogTWF0aC5hYnMocmlnaHQgLSBndWlkZVZhbHVlKSwgZGVsdGE6IGd1aWRlVmFsdWUgLSByaWdodCB9LFxyXG4gICAgICAgICAgICBdLnNvcnQoKGEsIGIpID0+IGEuZGlzdCAtIGIuZGlzdClbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRzLmRlbHRhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGJveC55ICsgYm94LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGJveC55O1xyXG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBib3gueSArIGJveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IGRpc3Q6IE1hdGguYWJzKGNlbnRlciAtIGd1aWRlVmFsdWUpLCBkZWx0YTogZ3VpZGVWYWx1ZSAtIGNlbnRlciB9LFxyXG4gICAgICAgICAgICAgICAgeyBkaXN0OiBNYXRoLmFicyh0b3AgLSBndWlkZVZhbHVlKSwgZGVsdGE6IGd1aWRlVmFsdWUgLSB0b3AgfSxcclxuICAgICAgICAgICAgICAgIHsgZGlzdDogTWF0aC5hYnMoYm90dG9tIC0gZ3VpZGVWYWx1ZSksIGRlbHRhOiBndWlkZVZhbHVlIC0gYm90dG9tIH0sXHJcbiAgICAgICAgICAgIF0uc29ydCgoYSwgYikgPT4gYS5kaXN0IC0gYi5kaXN0KVswXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdHMuZGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBNaXNtYSBoZXVyw61zdGljYSBxdWUgZGVsdGFGb3JHdWlkZSwgcGVybyBkZXZ1ZWx2ZSBkaXN0YW5jaWEgbcOtbmltYVxyXG4gICAgY29uc3QgZGlzdEZvckd1aWRlID0gKGF4aXMsIGd1aWRlVmFsdWUsIGJveCkgPT4ge1xyXG4gICAgICAgIGlmIChheGlzID09PSBcInhcIikge1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBib3gueCArIGJveC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBib3gueDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBib3gueCArIGJveC53aWR0aDtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoY2VudGVyIC0gZ3VpZGVWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhsZWZ0IC0gZ3VpZGVWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhyaWdodCAtIGd1aWRlVmFsdWUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJveC55ICsgYm94LmhlaWdodCAvIDI7XHJcbiAgICAgICAgY29uc3QgdG9wID0gYm94Lnk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gYm94LnkgKyBib3guaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihcclxuICAgICAgICAgICAgTWF0aC5hYnMoY2VudGVyIC0gZ3VpZGVWYWx1ZSksXHJcbiAgICAgICAgICAgIE1hdGguYWJzKHRvcCAtIGd1aWRlVmFsdWUpLFxyXG4gICAgICAgICAgICBNYXRoLmFicyhib3R0b20gLSBndWlkZVZhbHVlKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIC0tLS0gQ2FuZGlkYXRvcyBkZSBsYSBNSVNNQSBzZWNjacOzbiAoY2VudHJvcyArIGJvcmRlcykgLS0tLVxyXG4gICAgY29uc3QgZ2V0Tm9kZUJveCA9IChub2RlLCBzdGFnZSwgb2JqID0gbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXN0YWdlIHx8IHR5cGVvZiBub2RlLmdldENsaWVudFJlY3QgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgcmVjdE9wdHMgPSB7IHJlbGF0aXZlVG86IHN0YWdlIH07XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2JqPy50aXBvID09PSBcImdhbGVyaWFcIiAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKE51bWJlcihvYmo/LndpZHRoKSkgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShOdW1iZXIob2JqPy5oZWlnaHQpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHhGcm9tTm9kZSA9IHR5cGVvZiBub2RlLnggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueCgpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHlGcm9tTm9kZSA9IHR5cGVvZiBub2RlLnkgPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUueSgpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGFic1BvcyA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUuZ2V0QWJzb2x1dGVQb3NpdGlvbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZS5nZXRBYnNvbHV0ZVBvc2l0aW9uKHN0YWdlKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB4ID1cbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoeEZyb21Ob2RlKVxuICAgICAgICAgICAgICAgICAgICA/IHhGcm9tTm9kZVxuICAgICAgICAgICAgICAgICAgICA6IE51bWJlci5pc0Zpbml0ZShhYnNQb3M/LngpXG4gICAgICAgICAgICAgICAgICAgID8gYWJzUG9zLnhcbiAgICAgICAgICAgICAgICAgICAgOiAodHlwZW9mIG5vZGUueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiAwKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPVxuICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh5RnJvbU5vZGUpXG4gICAgICAgICAgICAgICAgICAgID8geUZyb21Ob2RlXG4gICAgICAgICAgICAgICAgICAgIDogTnVtYmVyLmlzRmluaXRlKGFic1Bvcz8ueSlcbiAgICAgICAgICAgICAgICAgICAgPyBhYnNQb3MueVxuICAgICAgICAgICAgICAgICAgICA6ICh0eXBlb2Ygbm9kZS55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IDApO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTnVtYmVyKG9iai53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIob2JqLmhlaWdodCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGEgZ2FsZXJpYSB1c2Egb3ZlcmxheXMgcG9yIGNlbGRhOyBtZWRpciBzdSBmcmFtZSBiYXNlIGV2aXRhIG9mZnNldHMgZmFsc29zLlxuICAgICAgICBpZiAob2JqPy50aXBvID09PSBcImdhbGVyaWFcIiAmJiB0eXBlb2Ygbm9kZS5maW5kT25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhbGxlcnlGcmFtZSA9IG5vZGUuZmluZE9uZShcIi5nYWxsZXJ5LXRyYW5zZm9ybS1mcmFtZVwiKTtcbiAgICAgICAgICAgIGlmIChnYWxsZXJ5RnJhbWUgJiYgdHlwZW9mIGdhbGxlcnlGcmFtZS5nZXRDbGllbnRSZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2FsbGVyeUZyYW1lLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogc3RhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIGFsIHJlY3QgY29tcGxldG9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0Q2xpZW50UmVjdChyZWN0T3B0cyk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYnVpbGRTYW1lU2VjdGlvbkd1aWRlcyA9IChub2RlLCBzdGFnZSwgb2JqZXRvcywgZWxlbWVudFJlZnMsIGlkU2VsZiwgc2VjY2lvbklkLCBvYmpCeUlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGZPYmogPSBvYmpCeUlkLmdldChpZFNlbGYpIHx8IG51bGw7XG4gICAgICAgIGNvbnN0IHNlbGZCb3ggPSBnZXROb2RlQm94KG5vZGUsIHN0YWdlLCBzZWxmT2JqKTtcbiAgICAgICAgaWYgKCFzZWxmQm94KSByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBvYmpldG9zXHJcbiAgICAgICAgICAgIC5maWx0ZXIobyA9PiBvLmlkICE9PSBpZFNlbGYgJiYgby5zZWNjaW9uSWQgPT09IHNlY2Npb25JZCkgLy8g8J+UkiBNSVNNQSBTRUNDScOTTlxyXG4gICAgICAgICAgICAubWFwKG8gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltvLmlkXTtcclxuICAgICAgICAgICAgICAgIGlmICghbikgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBnZXROb2RlQm94KG4sIHN0YWdlLCBvYmpCeUlkLmdldChvLmlkKSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IE1hdGguYWJzKChzZWxmQm94LnggKyBzZWxmQm94LndpZHRoIC8gMikgLSAoYi54ICsgYi53aWR0aCAvIDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIE1hdGguYWJzKChzZWxmQm94LnkgKyBzZWxmQm94LmhlaWdodCAvIDIpIC0gKGIueSArIGIuaGVpZ2h0IC8gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJveDogYiwgZCB9O1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7IHJldHVybiBudWxsOyB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcclxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZCAtIGIuZClcclxuICAgICAgICAgICAgLnNsaWNlKDAsIDMpOyAvLyBwb2NvcyB2ZWNpbm9zIOKGkiBtZW5vcyBydWlkb1xyXG5cclxuICAgICAgICBjb25zdCBnID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGJveCB9IG9mIGNhbmRpZGF0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY3ggPSBib3gueCArIGJveC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gYm94LnkgKyBib3guaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGJveC54O1xyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGJveC54ICsgYm94LndpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBib3gueTtcclxuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gYm94LnkgKyBib3guaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ2VudHJvc1xyXG4gICAgICAgICAgICBnLnB1c2goeyBheGlzOiBcInhcIiwgdmFsdWU6IGN4LCB0eXBlOiBcImVsLWN4XCIsIHRhcmdldEJveDogYm94LCBwcmlvcml0eTogXCJlbGVtZW50b1wiLCBzdHlsZTogXCJkYXNoZWRcIiB9KTtcclxuICAgICAgICAgICAgZy5wdXNoKHsgYXhpczogXCJ5XCIsIHZhbHVlOiBjeSwgdHlwZTogXCJlbC1jeVwiLCB0YXJnZXRCb3g6IGJveCwgcHJpb3JpdHk6IFwiZWxlbWVudG9cIiwgc3R5bGU6IFwiZGFzaGVkXCIgfSk7XHJcbiAgICAgICAgICAgIC8vIEJvcmRlc1xyXG4gICAgICAgICAgICBnLnB1c2goeyBheGlzOiBcInhcIiwgdmFsdWU6IGxlZnQsIHR5cGU6IFwiZWwtbGVmdFwiLCB0YXJnZXRCb3g6IGJveCwgcHJpb3JpdHk6IFwiZWxlbWVudG9cIiwgc3R5bGU6IFwiZGFzaGVkXCIgfSk7XHJcbiAgICAgICAgICAgIGcucHVzaCh7IGF4aXM6IFwieFwiLCB2YWx1ZTogcmlnaHQsIHR5cGU6IFwiZWwtcmlnaHRcIiwgdGFyZ2V0Qm94OiBib3gsIHByaW9yaXR5OiBcImVsZW1lbnRvXCIsIHN0eWxlOiBcImRhc2hlZFwiIH0pO1xyXG4gICAgICAgICAgICBnLnB1c2goeyBheGlzOiBcInlcIiwgdmFsdWU6IHRvcCwgdHlwZTogXCJlbC10b3BcIiwgdGFyZ2V0Qm94OiBib3gsIHByaW9yaXR5OiBcImVsZW1lbnRvXCIsIHN0eWxlOiBcImRhc2hlZFwiIH0pO1xyXG4gICAgICAgICAgICBnLnB1c2goeyBheGlzOiBcInlcIiwgdmFsdWU6IGJvdHRvbSwgdHlwZTogXCJlbC1ib3R0b21cIiwgdGFyZ2V0Qm94OiBib3gsIHByaW9yaXR5OiBcImVsZW1lbnRvXCIsIHN0eWxlOiBcImRhc2hlZFwiIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZztcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0VW5pb25Cb3ggPSAoaWRzLCBzdGFnZSwgZWxlbWVudFJlZnMsIG9iakJ5SWQpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykgfHwgaWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgbGV0IG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGxldCBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBsZXQgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgbGV0IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgICAgaWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkXTtcbiAgICAgICAgICAgIGlmICghbikgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYiA9IGdldE5vZGVCb3gobiwgc3RhZ2UsIG9iakJ5SWQuZ2V0KGlkKSB8fCBudWxsKTtcbiAgICAgICAgICAgIGlmICghYikgcmV0dXJuO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIGIueCk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgYi55KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBiLnggKyBiLndpZHRoKTtcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBiLnkgKyBiLmhlaWdodCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUobWluWCkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUobWluWSkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUobWF4WCkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUobWF4WSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgICAgeTogbWluWSxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKSxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hpZnROb2RlcyA9IChpZHMsIGF4aXMsIGRlbHRhLCBlbGVtZW50UmVmcykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSB8fCBpZHMubGVuZ3RoID09PSAwIHx8ICFOdW1iZXIuaXNGaW5pdGUoZGVsdGEpKSByZXR1cm47XG4gICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPCAwLjAwMDEpIHJldHVybjtcblxuICAgICAgICBjb25zdCBzaGlmdFNpbmdsZSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUueChub2RlLngoKSArIGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnkobm9kZS55KCkgKyBkZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gc2lsZW5jaW9zbyBwYXJhIG5vIGNvcnRhciBkcmFnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gZWxlbWVudFJlZnMuY3VycmVudD8uW2lkXTtcbiAgICAgICAgICAgIHNoaWZ0U2luZ2xlKG4pO1xuICAgICAgICAgICAgLy8gQWxndW5hcyBmb3JtYXMgKHJlY3QvcnN2cCkgcmVuZGVyaXphbiBlbCB0ZXh0byBjb21vIG5vZG8gc2VwYXJhZG8uXG4gICAgICAgICAgICBzaGlmdFNpbmdsZShlbGVtZW50UmVmcy5jdXJyZW50Py5bYCR7aWR9LXRleHRgXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyAtLS0tIE1vc3RyYXIgZ3XDrWFzIGR1cmFudGUgZWwgZHJhZyAtLS0tXG4gICAgY29uc3QgbW9zdHJhckd1aWFzID0gdXNlQ2FsbGJhY2soKHBvcywgaWRBY3R1YWwsIG9iamV0b3MsIGVsZW1lbnRSZWZzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50UmVmcy5jdXJyZW50Py5baWRBY3R1YWxdO1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc3RhZ2UgPSBub2RlLmdldFN0YWdlPy4oKTtcbiAgICAgICAgaWYgKCFzdGFnZSkgcmV0dXJuO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvYmpCeUlkID0gbmV3IE1hcChvYmpldG9zLm1hcCgobykgPT4gW28uaWQsIG9dKSk7XG4gICAgICAgICAgICBjb25zdCBvYmpBY3R1YWwgPSBvYmpCeUlkLmdldChpZEFjdHVhbCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGlzR3JvdXBMZWFkZXIgPSB3aW5kb3cuX2dydXBvTGlkZXIgJiYgaWRBY3R1YWwgPT09IHdpbmRvdy5fZ3J1cG9MaWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHJhd0dyb3VwSWRzID0gQXJyYXkuaXNBcnJheSh3aW5kb3cuX2dydXBvRWxlbWVudG9zKSAmJiB3aW5kb3cuX2dydXBvRWxlbWVudG9zLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5fZ3J1cG9FbGVtZW50b3NcbiAgICAgICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KHdpbmRvdy5fZWxlbWVudG9zU2VsZWNjaW9uYWRvcykgPyB3aW5kb3cuX2VsZW1lbnRvc1NlbGVjY2lvbmFkb3MgOiBbXSk7XG4gICAgICAgICAgICBjb25zdCBncm91cElkcyA9IGlzR3JvdXBMZWFkZXJcbiAgICAgICAgICAgICAgICA/IFsuLi5uZXcgU2V0KHJhd0dyb3VwSWRzLmZpbHRlcihCb29sZWFuKSldXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGlzR3JvdXBEcmFnID0gaXNHcm91cExlYWRlciAmJiBncm91cElkcy5sZW5ndGggPiAxO1xuXG4gICAgICAgICAgICBjb25zdCBzZWxmQm94QmVmb3JlID0gaXNHcm91cERyYWdcbiAgICAgICAgICAgICAgICA/IGdldFVuaW9uQm94KGdyb3VwSWRzLCBzdGFnZSwgZWxlbWVudFJlZnMsIG9iakJ5SWQpXG4gICAgICAgICAgICAgICAgOiBnZXROb2RlQm94KG5vZGUsIHN0YWdlLCBvYmpBY3R1YWwpO1xuICAgICAgICAgICAgaWYgKCFzZWxmQm94QmVmb3JlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzZWxmQ3ggPSBzZWxmQm94QmVmb3JlLnggKyBzZWxmQm94QmVmb3JlLndpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHNlbGZDeSA9IHNlbGZCb3hCZWZvcmUueSArIHNlbGZCb3hCZWZvcmUuaGVpZ2h0IC8gMjtcblxyXG4gICAgICAgICAgICBjb25zdCBzZWNjaW9uID0gb2J0ZW5lclNlY2Npb25FbGVtZW50byhpZEFjdHVhbCwgb2JqZXRvcyk7XHJcbiAgICAgICAgICAgIGlmICghc2VjY2lvbikge1xyXG4gICAgICAgICAgICAgICAgc2V0R3VpYUxpbmVhcyhbXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb2ZmWSA9IGNhbGN1bGFyT2Zmc2V0U2VjY2lvbihzZWNjaW9uLmlkKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VjQ3ggPSBhbmNob0NhbnZhcyAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY0N5ID0gb2ZmWSArIHNlY2Npb24uYWx0dXJhIC8gMjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gW107XG5cclxuICAgICAgICAgICAgLy8gMSkgU0VDQ0nDk046IGVsIHNuYXAgZXZhbMO6YSBlbCBjZW50cm8gZGUgbGEgc2VjY2nDs24uXG4gICAgICAgICAgICBjb25zdCBkaXN0U2VjWCA9IE1hdGguYWJzKHNlbGZDeCAtIHNlY0N4KTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RTZWNZID0gTWF0aC5hYnMoc2VsZkN5IC0gc2VjQ3kpO1xuXHJcbiAgICAgICAgICAgIC8vIDIpIEVMRU1FTlRPUyAoTUlTTUEgU0VDQ0nDk04pOiBlbGVnaXIgbWVqb3IgY2FuZGlkYXRvIHBvciBlamVcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudEd1aWRlcyA9IGlzR3JvdXBEcmFnXG4gICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgIDogYnVpbGRTYW1lU2VjdGlvbkd1aWRlcyhcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9iamV0b3MsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRSZWZzLFxuICAgICAgICAgICAgICAgICAgICBpZEFjdHVhbCxcbiAgICAgICAgICAgICAgICAgICAgc2VjY2lvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgb2JqQnlJZFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJlc3RFbFggPSBpc0dyb3VwRHJhZ1xuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogZWxlbWVudEd1aWRlc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGcgPT4gZy5heGlzID09PSBcInhcIilcbiAgICAgICAgICAgICAgICAgICAgLm1hcChnID0+ICh7IGcsIGRpc3Q6IGRpc3RGb3JHdWlkZShcInhcIiwgZy52YWx1ZSwgc2VsZkJveEJlZm9yZSkgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRpc3QgLSBiLmRpc3QpWzBdO1xuXG4gICAgICAgICAgICBjb25zdCBiZXN0RWxZID0gaXNHcm91cERyYWdcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnRHdWlkZXNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihnID0+IGcuYXhpcyA9PT0gXCJ5XCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZyA9PiAoeyBnLCBkaXN0OiBkaXN0Rm9yR3VpZGUoXCJ5XCIsIGcudmFsdWUsIHNlbGZCb3hCZWZvcmUpIH0pKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5kaXN0IC0gYi5kaXN0KVswXTtcblxyXG4gICAgICAgICAgICAvLyBEZWNpZGlyIHF1w6kgZ3XDrWEg4oCcZ2FuYeKAnSBwb3IgZWplIChzZWNjacOzbiB2cyBlbGVtZW50bylcclxuICAgICAgICAgICAgY29uc3QgZGVjaWRpclNuYXAgPSAoc2VjRGlzdENlbnRlciwgYmVzdEVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNPayA9IHNlY0Rpc3RDZW50ZXIgPD0gZWZmU2VjdGlvbk1hZ25ldFJhZGl1cztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsT2sgPSAhIWJlc3RFbCAmJiBiZXN0RWwuZGlzdCA8PSBlZmZFbGVtZW50TWFnbmV0UmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWNPayAmJiAhZWxPaykgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VjT2sgJiYgIWVsT2spIHJldHVybiB7IHNvdXJjZTogXCJzZWNjaW9uXCIgfTtcclxuICAgICAgICAgICAgICAgIGlmICghc2VjT2sgJiYgZWxPaykgcmV0dXJuIHsgc291cmNlOiBcImVsZW1lbnRvXCIsIG5lYXI6IGJlc3RFbCB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFtYm9zIGFwbGljYW46IGxhIHNlY2Npw7NuIHRpZW5lIHZlbnRhamEgKGJpYXMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbEJlYXRzU2VjdGlvbiA9IChiZXN0RWwuZGlzdCArIHNlY3Rpb25Qcmlvcml0eUJpYXMpIDwgc2VjRGlzdENlbnRlcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbEJlYXRzU2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgID8geyBzb3VyY2U6IFwiZWxlbWVudG9cIiwgbmVhcjogYmVzdEVsIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHsgc291cmNlOiBcInNlY2Npb25cIiB9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZGVjaXNpb25YID0gZGVjaWRpclNuYXAoZGlzdFNlY1gsIGJlc3RFbFgpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvblkgPSBkZWNpZGlyU25hcChkaXN0U2VjWSwgYmVzdEVsWSk7XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgYXBwbHlTbmFwID0gKGF4aXMsIGRlY2lzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNpc2lvbikgcmV0dXJuIHsgc25hcHBlZDogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVzaCA9IGlzR3JvdXBEcmFnXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0VW5pb25Cb3goZ3JvdXBJZHMsIHN0YWdlLCBlbGVtZW50UmVmcywgb2JqQnlJZClcbiAgICAgICAgICAgICAgICAgICAgOiBnZXROb2RlQm94KG5vZGUsIHN0YWdlLCBvYmpBY3R1YWwpO1xuICAgICAgICAgICAgICAgIGlmICghZnJlc2gpIHJldHVybiB7IHNuYXBwZWQ6IGZhbHNlIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVjaXNpb24uc291cmNlID09PSBcInNlY2Npb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2VudGVyID0gYXhpcyA9PT0gXCJ4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZnJlc2gueCArIGZyZXNoLndpZHRoIC8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmcmVzaC55ICsgZnJlc2guaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2VudGVyID0gYXhpcyA9PT0gXCJ4XCIgPyBzZWNDeCA6IHNlY0N5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9ICh0YXJnZXRDZW50ZXIgLSBuZXh0Q2VudGVyKSAqIGVmZlNlY3Rpb25TbmFwU3RyZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNHcm91cERyYWcpIHNoaWZ0Tm9kZXMoZ3JvdXBJZHMsIFwieFwiLCBkZWx0YSwgZWxlbWVudFJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBub2RlLngobm9kZS54KCkgKyBkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNHcm91cERyYWcpIHNoaWZ0Tm9kZXMoZ3JvdXBJZHMsIFwieVwiLCBkZWx0YSwgZWxlbWVudFJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBub2RlLnkobm9kZS55KCkgKyBkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc25hcHBlZDogdHJ1ZSwgc291cmNlOiBcInNlY2Npb25cIiB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0dyb3VwRHJhZykgcmV0dXJuIHsgc25hcHBlZDogZmFsc2UgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZGVsdGFGb3JHdWlkZShheGlzLCBkZWNpc2lvbi5uZWFyLmcudmFsdWUsIGZyZXNoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcyA9PT0gXCJ4XCIpIG5vZGUueChub2RlLngoKSArIGRlbHRhICogZWZmRWxlbWVudFNuYXBTdHJlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBub2RlLnkobm9kZS55KCkgKyBkZWx0YSAqIGVmZkVsZW1lbnRTbmFwU3RyZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHNuYXBwZWQ6IHRydWUsIHNvdXJjZTogXCJlbGVtZW50b1wiLCBuZWFyOiBkZWNpc2lvbi5uZWFyIH07XG4gICAgICAgICAgICB9O1xuXHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXBSZXNYID0gYXBwbHlTbmFwKFwieFwiLCBkZWNpc2lvblgpO1xyXG4gICAgICAgICAgICBjb25zdCBzbmFwUmVzWSA9IGFwcGx5U25hcChcInlcIiwgZGVjaXNpb25ZKTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhciBib3ggbHVlZ28gZGVsIHNuYXAgcGFyYSBkaWJ1amFyIHJlYWNoIGV4YWN0YVxuICAgICAgICAgICAgY29uc3Qgc2VsZkJveEFmdGVyID0gaXNHcm91cERyYWdcbiAgICAgICAgICAgICAgICA/IGdldFVuaW9uQm94KGdyb3VwSWRzLCBzdGFnZSwgZWxlbWVudFJlZnMsIG9iakJ5SWQpXG4gICAgICAgICAgICAgICAgOiBnZXROb2RlQm94KG5vZGUsIHN0YWdlLCBvYmpBY3R1YWwpO1xuICAgICAgICAgICAgaWYgKCFzZWxmQm94QWZ0ZXIpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNlbGZDeEFmdGVyID0gc2VsZkJveEFmdGVyLnggKyBzZWxmQm94QWZ0ZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3Qgc2VsZkN5QWZ0ZXIgPSBzZWxmQm94QWZ0ZXIueSArIHNlbGZCb3hBZnRlci5oZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICAvLyAyKSBTRUNDScOTTjogbW9zdHJhciBndcOtYSBTT0xPIGN1YW5kbyBxdWVkw7MgZWZlY3RpdmFtZW50ZSBhbGluZWFkby5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzbmFwUmVzWC5zbmFwcGVkICYmXG4gICAgICAgICAgICAgICAgc25hcFJlc1guc291cmNlID09PSBcInNlY2Npb25cIiAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNlbGZDeEFmdGVyIC0gc2VjQ3gpIDw9IHNlY3Rpb25MaW5lVG9sZXJhbmNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZWNjaW9uLWN4XCIsXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBcInNlY2Npb25cIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbc2VjQ3gsIG9mZlksIHNlY0N4LCBvZmZZICsgc2VjY2lvbi5hbHR1cmFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc25hcFJlc1kuc25hcHBlZCAmJlxuICAgICAgICAgICAgICAgIHNuYXBSZXNZLnNvdXJjZSA9PT0gXCJzZWNjaW9uXCIgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhzZWxmQ3lBZnRlciAtIHNlY0N5KSA8PSBzZWN0aW9uTGluZVRvbGVyYW5jZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2VjY2lvbi1jeVwiLFxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogXCJzZWNjaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogWzAsIHNlY0N5LCBhbmNob0NhbnZhcywgc2VjQ3ldXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNHcm91cERyYWcgJiYgc25hcFJlc1guc25hcHBlZCAmJiBzbmFwUmVzWC5zb3VyY2UgPT09IFwiZWxlbWVudG9cIiAmJiBzbmFwUmVzWC5uZWFyPy5nPy50YXJnZXRCb3gpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFjaC14XCIsXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBcImVsZW1lbnRvXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImRhc2hlZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHJlYWNoVmVydGljYWwoc25hcFJlc1gubmVhci5nLnZhbHVlLCBzZWxmQm94QWZ0ZXIsIHNuYXBSZXNYLm5lYXIuZy50YXJnZXRCb3gpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzR3JvdXBEcmFnICYmIHNuYXBSZXNZLnNuYXBwZWQgJiYgc25hcFJlc1kuc291cmNlID09PSBcImVsZW1lbnRvXCIgJiYgc25hcFJlc1kubmVhcj8uZz8udGFyZ2V0Qm94KSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhY2gteVwiLFxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogXCJlbGVtZW50b1wiLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJkYXNoZWRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiByZWFjaEhvcml6b250YWwoc25hcFJlc1kubmVhci5nLnZhbHVlLCBzZWxmQm94QWZ0ZXIsIHNuYXBSZXNZLm5lYXIuZy50YXJnZXRCb3gpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cclxuXHJcbiAgICAgICAgICAgIHNldEd1aWFMaW5lYXMobGluZXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gc2lsZW5jaW9zbyBwYXJhIG5vIGNvcnRhciBlbCBkcmFnXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW1xuICAgICAgICBhbmNob0NhbnZhcywgYWx0b0NhbnZhcyxcbiAgICAgICAgbWFnbmV0UmFkaXVzLCBzZWN0aW9uU2hvd1JhZGl1cywgc25hcFN0cmVuZ3RoLFxuICAgICAgICBzZWNjaW9uZXNPcmRlbmFkYXMsXG4gICAgICAgIG9idGVuZXJTZWNjaW9uRWxlbWVudG8sIGNhbGN1bGFyT2Zmc2V0U2VjY2lvbixcbiAgICAgICAgZWxlbWVudE1hZ25ldFJhZGl1cywgc2VjdGlvbk1hZ25ldFJhZGl1cywgc2VjdGlvblByaW9yaXR5QmlhcyxcbiAgICAgICAgc2VjdGlvblNuYXBTdHJlbmd0aCwgZWxlbWVudFNuYXBTdHJlbmd0aCwgc2VjdGlvbkxpbmVUb2xlcmFuY2VcbiAgICBdKTtcblxyXG4gICAgY29uc3QgbGltcGlhckd1aWFzID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0R3VpYUxpbmVhcyhbXSksIFtdKTtcclxuICAgIGNvbnN0IGNvbmZpZ3VyYXJEcmFnRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0R3VpYUxpbmVhcyhbXSksIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGd1aWFMaW5lYXMsXHJcbiAgICAgICAgbW9zdHJhckd1aWFzLFxyXG4gICAgICAgIGxpbXBpYXJHdWlhcyxcclxuICAgICAgICBjb25maWd1cmFyRHJhZ0VuZFxyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUd1aWFzQ2VudHJhZG8iLCJhbmNob0NhbnZhcyIsImFsdG9DYW52YXMiLCJtYWduZXRSYWRpdXMiLCJlbGVtZW50TWFnbmV0UmFkaXVzIiwic2VjdGlvbk1hZ25ldFJhZGl1cyIsInNlY3Rpb25TaG93UmFkaXVzIiwic2VjdGlvblByaW9yaXR5QmlhcyIsInNuYXBTdHJlbmd0aCIsInNlY3Rpb25TbmFwU3RyZW5ndGgiLCJlbGVtZW50U25hcFN0cmVuZ3RoIiwic2VjdGlvbkxpbmVUb2xlcmFuY2UiLCJzZWNjaW9uZXNPcmRlbmFkYXMiLCJndWlhTGluZWFzIiwic2V0R3VpYUxpbmVhcyIsImVmZkVsZW1lbnRNYWduZXRSYWRpdXMiLCJlZmZTZWN0aW9uTWFnbmV0UmFkaXVzIiwiZWZmU2VjdGlvblNuYXBTdHJlbmd0aCIsImVmZkVsZW1lbnRTbmFwU3RyZW5ndGgiLCJjYWxjdWxhck9mZnNldFNlY2Npb24iLCJzZWNjaW9uSWQiLCJvZmZzZXRZIiwicyIsImlkIiwiYWx0dXJhIiwib2J0ZW5lclNlY2Npb25FbGVtZW50byIsIm9iaklkIiwib2JqZXRvcyIsIm9iaiIsImZpbmQiLCJvIiwicmVhY2hWZXJ0aWNhbCIsIngiLCJzZWxmQm94Iiwib3RoZXJCb3giLCJnYXAiLCJzZWxmQ3kiLCJ5IiwiaGVpZ2h0Iiwib3RoZXJDeSIsInkxIiwieTIiLCJyZWFjaEhvcml6b250YWwiLCJzZWxmQ3giLCJ3aWR0aCIsIm90aGVyQ3giLCJ4MSIsIngyIiwiZGVsdGFGb3JHdWlkZSIsImF4aXMiLCJndWlkZVZhbHVlIiwiYm94IiwiY2VudGVyIiwibGVmdCIsInJpZ2h0Iiwib3B0cyIsImRpc3QiLCJNYXRoIiwiYWJzIiwiZGVsdGEiLCJzb3J0IiwiYSIsImIiLCJ0b3AiLCJib3R0b20iLCJkaXN0Rm9yR3VpZGUiLCJtaW4iLCJnZXROb2RlQm94Iiwibm9kZSIsInN0YWdlIiwiZ2V0Q2xpZW50UmVjdCIsInJlY3RPcHRzIiwicmVsYXRpdmVUbyIsInRpcG8iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInhGcm9tTm9kZSIsInlGcm9tTm9kZSIsImFic1BvcyIsImdldEFic29sdXRlUG9zaXRpb24iLCJmaW5kT25lIiwiZ2FsbGVyeUZyYW1lIiwic2tpcFNoYWRvdyIsInNraXBTdHJva2UiLCJidWlsZFNhbWVTZWN0aW9uR3VpZGVzIiwiZWxlbWVudFJlZnMiLCJpZFNlbGYiLCJvYmpCeUlkIiwic2VsZk9iaiIsImdldCIsImNhbmRpZGF0ZXMiLCJmaWx0ZXIiLCJtYXAiLCJuIiwiY3VycmVudCIsImQiLCJCb29sZWFuIiwic2xpY2UiLCJnIiwiY3giLCJjeSIsInB1c2giLCJ2YWx1ZSIsInR5cGUiLCJ0YXJnZXRCb3giLCJwcmlvcml0eSIsInN0eWxlIiwiZ2V0VW5pb25Cb3giLCJpZHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJtaW5YIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJtaW5ZIiwibWF4WCIsIk5FR0FUSVZFX0lORklOSVRZIiwibWF4WSIsImZvckVhY2giLCJtYXgiLCJzaGlmdE5vZGVzIiwic2hpZnRTaW5nbGUiLCJtb3N0cmFyR3VpYXMiLCJwb3MiLCJpZEFjdHVhbCIsImdldFN0YWdlIiwic25hcFJlc1giLCJzbmFwUmVzWSIsIk1hcCIsIm9iakFjdHVhbCIsImlzR3JvdXBMZWFkZXIiLCJ3aW5kb3ciLCJfZ3J1cG9MaWRlciIsInJhd0dyb3VwSWRzIiwiX2dydXBvRWxlbWVudG9zIiwiX2VsZW1lbnRvc1NlbGVjY2lvbmFkb3MiLCJncm91cElkcyIsIlNldCIsImlzR3JvdXBEcmFnIiwic2VsZkJveEJlZm9yZSIsInNlY2Npb24iLCJvZmZZIiwic2VjQ3giLCJzZWNDeSIsImxpbmVzIiwiZGlzdFNlY1giLCJkaXN0U2VjWSIsImVsZW1lbnRHdWlkZXMiLCJiZXN0RWxYIiwiYmVzdEVsWSIsImRlY2lkaXJTbmFwIiwic2VjRGlzdENlbnRlciIsImJlc3RFbCIsInNlY09rIiwiZWxPayIsInNvdXJjZSIsIm5lYXIiLCJlbEJlYXRzU2VjdGlvbiIsImRlY2lzaW9uWCIsImRlY2lzaW9uWSIsImFwcGx5U25hcCIsImRlY2lzaW9uIiwic25hcHBlZCIsImZyZXNoIiwibmV4dENlbnRlciIsInRhcmdldENlbnRlciIsInNlbGZCb3hBZnRlciIsInNlbGZDeEFmdGVyIiwic2VsZkN5QWZ0ZXIiLCJwb2ludHMiLCJlIiwibGltcGlhckd1aWFzIiwiY29uZmlndXJhckRyYWdFbmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/hooks/useGuiasCentrado.js\n"));

/***/ })

});