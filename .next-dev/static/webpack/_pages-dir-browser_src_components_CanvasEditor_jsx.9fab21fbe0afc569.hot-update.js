"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/utils/fontManager.js":
/*!**********************************!*\
  !*** ./src/utils/fontManager.js ***!
  \**********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fontManager: () => (/* binding */ fontManager)\n/* harmony export */ });\n/* harmony import */ var webfontloader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webfontloader */ \"(pages-dir-browser)/./node_modules/webfontloader/webfontloader.js\");\n/* harmony import */ var _config_fonts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/config/fonts */ \"(pages-dir-browser)/./src/config/fonts.js\");\n\n\nconst SYSTEM_FONTS = new Set([\n    'arial',\n    'helvetica',\n    'verdana',\n    'tahoma',\n    'trebuchet ms',\n    'georgia',\n    'times new roman',\n    'courier new',\n    'lucida console',\n    'comic sans ms',\n    'impact',\n    'sans-serif',\n    'serif',\n    'monospace'\n]);\nconst DEFAULT_TIMEOUT_MS = 12000;\nclass FontManager {\n    normalizeFontName(fontFamily) {\n        if (!fontFamily) return '';\n        return String(fontFamily).replace(/['\"]/g, '').split(',')[0].trim();\n    }\n    categorizeFont(fontFamily) {\n        const fontName = this.normalizeFontName(fontFamily);\n        if (!fontName) {\n            return {\n                type: 'system',\n                name: 'sans-serif'\n            };\n        }\n        if (SYSTEM_FONTS.has(fontName.toLowerCase())) {\n            return {\n                type: 'system',\n                name: fontName\n            };\n        }\n        if (this.googleFontSet.has(fontName)) {\n            return {\n                type: 'google',\n                name: fontName\n            };\n        }\n        return {\n            type: 'custom',\n            name: fontName\n        };\n    }\n    waitForDocumentFont(fontName) {\n        let timeoutMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_TIMEOUT_MS;\n        var _document_fonts;\n        if (typeof document === 'undefined' || !((_document_fonts = document.fonts) === null || _document_fonts === void 0 ? void 0 : _document_fonts.load)) {\n            return Promise.resolve();\n        }\n        const loadPromise = document.fonts.load('16px \"'.concat(fontName, '\"'));\n        if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {\n            return loadPromise.then(()=>undefined);\n        }\n        const timeoutPromise = new Promise((resolve)=>{\n            setTimeout(resolve, timeoutMs);\n        });\n        return Promise.race([\n            loadPromise,\n            timeoutPromise\n        ]).then(()=>undefined);\n    }\n    async loadGoogleFont(fontName) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const normalizedName = this.normalizeFontName(fontName);\n        const timeoutMs = Number.isFinite(options.timeoutMs) && options.timeoutMs > 0 ? options.timeoutMs : DEFAULT_TIMEOUT_MS;\n        if (!normalizedName) return Promise.resolve();\n        if (this.loadedFonts.has(normalizedName)) {\n            this.loadedFonts.add(normalizedName);\n            this.failedFonts.delete(normalizedName);\n            return Promise.resolve();\n        }\n        if (this.loadingPromises.has(normalizedName)) {\n            return this.loadingPromises.get(normalizedName);\n        }\n        const loadPromise = new Promise((resolve, reject)=>{\n            webfontloader__WEBPACK_IMPORTED_MODULE_0__.load({\n                google: {\n                    families: [\n                        \"\".concat(normalizedName, \":400,700\")\n                    ]\n                },\n                active: ()=>{\n                    this.waitForDocumentFont(normalizedName, timeoutMs).finally(()=>{\n                        this.loadedFonts.add(normalizedName);\n                        this.failedFonts.delete(normalizedName);\n                        this.loadingPromises.delete(normalizedName);\n                        this.forceCanvasRedraw();\n                        resolve();\n                    });\n                },\n                inactive: ()=>{\n                    this.loadingPromises.delete(normalizedName);\n                    this.failedFonts.add(normalizedName);\n                    reject(new Error(\"No se pudo cargar la fuente: \".concat(normalizedName)));\n                },\n                timeout: timeoutMs\n            });\n        });\n        this.loadingPromises.set(normalizedName, loadPromise);\n        return loadPromise;\n    }\n    async loadFonts() {\n        let fontFamilies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const loaded = [];\n        const failed = [];\n        const uniqueFonts = [\n            ...new Set(fontFamilies.map((font)=>String(font || '').trim()))\n        ].filter(Boolean);\n        if (!uniqueFonts.length) {\n            return {\n                loaded,\n                failed\n            };\n        }\n        const pendingNames = [];\n        const pendingPromises = [];\n        uniqueFonts.forEach((fontFamily)=>{\n            const { type, name } = this.categorizeFont(fontFamily);\n            if (!name) return;\n            if (type === 'system') {\n                this.loadedFonts.add(name);\n                this.failedFonts.delete(name);\n                loaded.push(name);\n                return;\n            }\n            if (this.loadedFonts.has(name)) {\n                this.loadedFonts.add(name);\n                this.failedFonts.delete(name);\n                loaded.push(name);\n                return;\n            }\n            if (type !== 'google') {\n                this.failedFonts.add(name);\n                failed.push(name);\n                return;\n            }\n            pendingNames.push(name);\n            pendingPromises.push(this.loadGoogleFont(name, options));\n        });\n        if (!pendingPromises.length) {\n            return {\n                loaded: [\n                    ...new Set(loaded)\n                ],\n                failed: [\n                    ...new Set(failed)\n                ]\n            };\n        }\n        const settled = await Promise.allSettled(pendingPromises);\n        settled.forEach((result, index)=>{\n            const fontName = pendingNames[index];\n            const ready = this.isFontAvailable(fontName);\n            if (result.status === 'fulfilled' || ready) {\n                this.loadedFonts.add(fontName);\n                this.failedFonts.delete(fontName);\n                loaded.push(fontName);\n            } else {\n                this.failedFonts.add(fontName);\n                failed.push(fontName);\n            }\n        });\n        return {\n            loaded: [\n                ...new Set(loaded)\n            ],\n            failed: [\n                ...new Set(failed)\n            ]\n        };\n    }\n    async preloadPopularFonts() {\n        const popularFonts = [\n            'Poppins',\n            'Roboto',\n            'Open Sans',\n            'Montserrat',\n            'Raleway',\n            'Lato',\n            'Playfair Display',\n            'Oswald',\n            'Libre Bodoni',\n            'Bodoni Moda'\n        ];\n        return this.loadFonts(popularFonts);\n    }\n    forceCanvasRedraw() {\n        if (false) {}\n        window.dispatchEvent(new CustomEvent('fonts-loaded'));\n    }\n    isFontAvailable(fontFamily) {\n        var _document_fonts;\n        const { type, name } = this.categorizeFont(fontFamily);\n        if (type === 'system') return true;\n        if (!name) return false;\n        if (this.loadedFonts.has(name)) return true;\n        if (type === 'google') return false;\n        if (typeof document !== 'undefined' && ((_document_fonts = document.fonts) === null || _document_fonts === void 0 ? void 0 : _document_fonts.check)) {\n            try {\n                const available = document.fonts.check('16px \"'.concat(name, '\"'));\n                if (available) {\n                    this.loadedFonts.add(name);\n                    this.failedFonts.delete(name);\n                    return true;\n                }\n            } catch (e) {\n                return false;\n            }\n        }\n        return false;\n    }\n    getGoogleFontsLink() {\n        let fontFamilies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n        const families = fontFamilies.map((font)=>this.normalizeFontName(font)).filter((name)=>this.googleFontSet.has(name)).map((name)=>\"family=\".concat(encodeURIComponent(\"\".concat(name, \":wght@400;700\").replace(/ /g, '+')))).join('&');\n        if (!families) return '';\n        const url = \"https://fonts.googleapis.com/css2?\".concat(families, \"&display=swap\");\n        return '\\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\\n<link href=\"'.concat(url, '\" rel=\"stylesheet\">').trim();\n    }\n    getLoadedFontsCSS() {\n        const googleFonts = Array.from(this.loadedFonts);\n        if (googleFonts.length === 0) return '';\n        const families = googleFonts.map((font)=>\"family=\".concat(encodeURIComponent(\"\".concat(font, \":wght@300;400;500;600;700\").replace(/ /g, '+')))).join('&');\n        return \"https://fonts.googleapis.com/css2?\".concat(families, \"&display=swap\");\n    }\n    constructor(){\n        this.loadedFonts = new Set();\n        this.fontCache = new Map();\n        this.loadingPromises = new Map();\n        this.failedFonts = new Set();\n        this.googleFontSet = new Set(_config_fonts__WEBPACK_IMPORTED_MODULE_1__.GOOGLE_FONTS.map((font)=>this.normalizeFontName(font === null || font === void 0 ? void 0 : font.nombre)));\n    }\n}\nconst fontManager = new FontManager();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9mb250TWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDVTtBQUU5QyxNQUFNRSxlQUFlLElBQUlDLElBQUk7SUFDM0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMscUJBQXFCO0FBRTNCLE1BQU1DO0lBV0pDLGtCQUFrQkMsVUFBVSxFQUFFO1FBQzVCLElBQUksQ0FBQ0EsWUFBWSxPQUFPO1FBQ3hCLE9BQU9DLE9BQU9ELFlBQ1hFLE9BQU8sQ0FBQyxTQUFTLElBQ2pCQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FDYkMsSUFBSTtJQUNUO0lBRUFDLGVBQWVMLFVBQVUsRUFBRTtRQUN6QixNQUFNTSxXQUFXLElBQUksQ0FBQ1AsaUJBQWlCLENBQUNDO1FBRXhDLElBQUksQ0FBQ00sVUFBVTtZQUNiLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVDLE1BQU07WUFBYTtRQUM5QztRQUVBLElBQUliLGFBQWFjLEdBQUcsQ0FBQ0gsU0FBU0ksV0FBVyxLQUFLO1lBQzVDLE9BQU87Z0JBQUVILE1BQU07Z0JBQVVDLE1BQU1GO1lBQVM7UUFDMUM7UUFFQSxJQUFJLElBQUksQ0FBQ0ssYUFBYSxDQUFDRixHQUFHLENBQUNILFdBQVc7WUFDcEMsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUMsTUFBTUY7WUFBUztRQUMxQztRQUVBLE9BQU87WUFBRUMsTUFBTTtZQUFVQyxNQUFNRjtRQUFTO0lBQzFDO0lBRUFNLG9CQUFvQk4sUUFBUSxFQUFrQztZQUFoQ08sWUFBQUEsaUVBQVloQjtZQUNBaUI7UUFBeEMsSUFBSSxPQUFPQSxhQUFhLGVBQWUsR0FBQ0Esa0JBQUFBLFNBQVNDLEtBQUssY0FBZEQsc0NBQUFBLGdCQUFnQkUsSUFBSSxHQUFFO1lBQzVELE9BQU9DLFFBQVFDLE9BQU87UUFDeEI7UUFFQSxN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QUFXLEdBQUcsSUFBSXBDO1FBQ3ZCLElBQUksQ0FBQ2UsYUFBYSxHQUFHLElBQUlmLElBQ3ZCRix1REFBWUEsQ0FBQ3lELEdBQUcsQ0FBQyxDQUFDQyxPQUFTLElBQUksQ0FBQ3JELGlCQUFpQixDQUFDcUQsaUJBQUFBLDJCQUFBQSxLQUFNaUMsTUFBTTtJQUVsRTtBQXdPRjtBQUVPLE1BQU1DLGNBQWMsSUFBSXhGLGNBQWMiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXHNyY1xcdXRpbHNcXGZvbnRNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJGb250IGZyb20gJ3dlYmZvbnRsb2FkZXInO1xuaW1wb3J0IHsgR09PR0xFX0ZPTlRTIH0gZnJvbSAnQC9jb25maWcvZm9udHMnO1xuXG5jb25zdCBTWVNURU1fRk9OVFMgPSBuZXcgU2V0KFtcbiAgJ2FyaWFsJyxcbiAgJ2hlbHZldGljYScsXG4gICd2ZXJkYW5hJyxcbiAgJ3RhaG9tYScsXG4gICd0cmVidWNoZXQgbXMnLFxuICAnZ2VvcmdpYScsXG4gICd0aW1lcyBuZXcgcm9tYW4nLFxuICAnY291cmllciBuZXcnLFxuICAnbHVjaWRhIGNvbnNvbGUnLFxuICAnY29taWMgc2FucyBtcycsXG4gICdpbXBhY3QnLFxuICAnc2Fucy1zZXJpZicsXG4gICdzZXJpZicsXG4gICdtb25vc3BhY2UnLFxuXSk7XG5cbmNvbnN0IERFRkFVTFRfVElNRU9VVF9NUyA9IDEyMDAwO1xuXG5jbGFzcyBGb250TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9hZGVkRm9udHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5mb250Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5sb2FkaW5nUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mYWlsZWRGb250cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmdvb2dsZUZvbnRTZXQgPSBuZXcgU2V0KFxuICAgICAgR09PR0xFX0ZPTlRTLm1hcCgoZm9udCkgPT4gdGhpcy5ub3JtYWxpemVGb250TmFtZShmb250Py5ub21icmUpKVxuICAgICk7XG4gIH1cblxuICBub3JtYWxpemVGb250TmFtZShmb250RmFtaWx5KSB7XG4gICAgaWYgKCFmb250RmFtaWx5KSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIFN0cmluZyhmb250RmFtaWx5KVxuICAgICAgLnJlcGxhY2UoL1snXCJdL2csICcnKVxuICAgICAgLnNwbGl0KCcsJylbMF1cbiAgICAgIC50cmltKCk7XG4gIH1cblxuICBjYXRlZ29yaXplRm9udChmb250RmFtaWx5KSB7XG4gICAgY29uc3QgZm9udE5hbWUgPSB0aGlzLm5vcm1hbGl6ZUZvbnROYW1lKGZvbnRGYW1pbHkpO1xuXG4gICAgaWYgKCFmb250TmFtZSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogJ3N5c3RlbScsIG5hbWU6ICdzYW5zLXNlcmlmJyB9O1xuICAgIH1cblxuICAgIGlmIChTWVNURU1fRk9OVFMuaGFzKGZvbnROYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiAnc3lzdGVtJywgbmFtZTogZm9udE5hbWUgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nb29nbGVGb250U2V0Lmhhcyhmb250TmFtZSkpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6ICdnb29nbGUnLCBuYW1lOiBmb250TmFtZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdjdXN0b20nLCBuYW1lOiBmb250TmFtZSB9O1xuICB9XG5cbiAgd2FpdEZvckRvY3VtZW50Rm9udChmb250TmFtZSwgdGltZW91dE1zID0gREVGQVVMVF9USU1FT1VUX01TKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50LmZvbnRzPy5sb2FkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9hZFByb21pc2UgPSBkb2N1bWVudC5mb250cy5sb2FkKGAxNnB4IFwiJHtmb250TmFtZX1cImApO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRpbWVvdXRNcykgfHwgdGltZW91dE1zIDw9IDApIHtcbiAgICAgIHJldHVybiBsb2FkUHJvbWlzZS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbbG9hZFByb21pc2UsIHRpbWVvdXRQcm9taXNlXSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICB9XG5cbiAgYXN5bmMgbG9hZEdvb2dsZUZvbnQoZm9udE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVGb250TmFtZShmb250TmFtZSk7XG4gICAgY29uc3QgdGltZW91dE1zID1cbiAgICAgIE51bWJlci5pc0Zpbml0ZShvcHRpb25zLnRpbWVvdXRNcykgJiYgb3B0aW9ucy50aW1lb3V0TXMgPiAwXG4gICAgICAgID8gb3B0aW9ucy50aW1lb3V0TXNcbiAgICAgICAgOiBERUZBVUxUX1RJTUVPVVRfTVM7XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWROYW1lKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBpZiAodGhpcy5sb2FkZWRGb250cy5oYXMobm9ybWFsaXplZE5hbWUpKSB7XG4gICAgICB0aGlzLmxvYWRlZEZvbnRzLmFkZChub3JtYWxpemVkTmFtZSk7XG4gICAgICB0aGlzLmZhaWxlZEZvbnRzLmRlbGV0ZShub3JtYWxpemVkTmFtZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubG9hZGluZ1Byb21pc2VzLmhhcyhub3JtYWxpemVkTmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRpbmdQcm9taXNlcy5nZXQobm9ybWFsaXplZE5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgV2ViRm9udC5sb2FkKHtcbiAgICAgICAgZ29vZ2xlOiB7XG4gICAgICAgICAgZmFtaWxpZXM6IFtgJHtub3JtYWxpemVkTmFtZX06NDAwLDcwMGBdLFxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLndhaXRGb3JEb2N1bWVudEZvbnQobm9ybWFsaXplZE5hbWUsIHRpbWVvdXRNcylcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2FkZWRGb250cy5hZGQobm9ybWFsaXplZE5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLmZhaWxlZEZvbnRzLmRlbGV0ZShub3JtYWxpemVkTmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMubG9hZGluZ1Byb21pc2VzLmRlbGV0ZShub3JtYWxpemVkTmFtZSk7XG4gICAgICAgICAgICAgIHRoaXMuZm9yY2VDYW52YXNSZWRyYXcoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluYWN0aXZlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2FkaW5nUHJvbWlzZXMuZGVsZXRlKG5vcm1hbGl6ZWROYW1lKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZEZvbnRzLmFkZChub3JtYWxpemVkTmFtZSk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm8gc2UgcHVkbyBjYXJnYXIgbGEgZnVlbnRlOiAke25vcm1hbGl6ZWROYW1lfWApKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGltZW91dDogdGltZW91dE1zLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxvYWRpbmdQcm9taXNlcy5zZXQobm9ybWFsaXplZE5hbWUsIGxvYWRQcm9taXNlKTtcbiAgICByZXR1cm4gbG9hZFByb21pc2U7XG4gIH1cblxuICBhc3luYyBsb2FkRm9udHMoZm9udEZhbWlsaWVzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGxvYWRlZCA9IFtdO1xuICAgIGNvbnN0IGZhaWxlZCA9IFtdO1xuICAgIGNvbnN0IHVuaXF1ZUZvbnRzID0gWy4uLm5ldyBTZXQoZm9udEZhbWlsaWVzLm1hcCgoZm9udCkgPT4gU3RyaW5nKGZvbnQgfHwgJycpLnRyaW0oKSkpXS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBpZiAoIXVuaXF1ZUZvbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgbG9hZGVkLCBmYWlsZWQgfTtcbiAgICB9XG5cbiAgICBjb25zdCBwZW5kaW5nTmFtZXMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nUHJvbWlzZXMgPSBbXTtcblxuICAgIHVuaXF1ZUZvbnRzLmZvckVhY2goKGZvbnRGYW1pbHkpID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgbmFtZSB9ID0gdGhpcy5jYXRlZ29yaXplRm9udChmb250RmFtaWx5KTtcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3N5c3RlbScpIHtcbiAgICAgICAgdGhpcy5sb2FkZWRGb250cy5hZGQobmFtZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkRm9udHMuZGVsZXRlKG5hbWUpO1xuICAgICAgICBsb2FkZWQucHVzaChuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sb2FkZWRGb250cy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5sb2FkZWRGb250cy5hZGQobmFtZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkRm9udHMuZGVsZXRlKG5hbWUpO1xuICAgICAgICBsb2FkZWQucHVzaChuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSAhPT0gJ2dvb2dsZScpIHtcbiAgICAgICAgdGhpcy5mYWlsZWRGb250cy5hZGQobmFtZSk7XG4gICAgICAgIGZhaWxlZC5wdXNoKG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBlbmRpbmdOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgcGVuZGluZ1Byb21pc2VzLnB1c2godGhpcy5sb2FkR29vZ2xlRm9udChuYW1lLCBvcHRpb25zKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXBlbmRpbmdQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvYWRlZDogWy4uLm5ldyBTZXQobG9hZGVkKV0sXG4gICAgICAgIGZhaWxlZDogWy4uLm5ldyBTZXQoZmFpbGVkKV0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHNldHRsZWQgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocGVuZGluZ1Byb21pc2VzKTtcblxuICAgIHNldHRsZWQuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZm9udE5hbWUgPSBwZW5kaW5nTmFtZXNbaW5kZXhdO1xuICAgICAgY29uc3QgcmVhZHkgPSB0aGlzLmlzRm9udEF2YWlsYWJsZShmb250TmFtZSk7XG5cbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyB8fCByZWFkeSkge1xuICAgICAgICB0aGlzLmxvYWRlZEZvbnRzLmFkZChmb250TmFtZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkRm9udHMuZGVsZXRlKGZvbnROYW1lKTtcbiAgICAgICAgbG9hZGVkLnB1c2goZm9udE5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mYWlsZWRGb250cy5hZGQoZm9udE5hbWUpO1xuICAgICAgICBmYWlsZWQucHVzaChmb250TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGVkOiBbLi4ubmV3IFNldChsb2FkZWQpXSxcbiAgICAgIGZhaWxlZDogWy4uLm5ldyBTZXQoZmFpbGVkKV0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHByZWxvYWRQb3B1bGFyRm9udHMoKSB7XG4gICAgY29uc3QgcG9wdWxhckZvbnRzID0gW1xuICAgICAgJ1BvcHBpbnMnLFxuICAgICAgJ1JvYm90bycsXG4gICAgICAnT3BlbiBTYW5zJyxcbiAgICAgICdNb250c2VycmF0JyxcbiAgICAgICdSYWxld2F5JyxcbiAgICAgICdMYXRvJyxcbiAgICAgICdQbGF5ZmFpciBEaXNwbGF5JyxcbiAgICAgICdPc3dhbGQnLFxuICAgICAgJ0xpYnJlIEJvZG9uaScsXG4gICAgICAnQm9kb25pIE1vZGEnLFxuICAgIF07XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkRm9udHMocG9wdWxhckZvbnRzKTtcbiAgfVxuXG4gIGZvcmNlQ2FudmFzUmVkcmF3KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZm9udHMtbG9hZGVkJykpO1xuICB9XG5cbiAgaXNGb250QXZhaWxhYmxlKGZvbnRGYW1pbHkpIHtcbiAgICBjb25zdCB7IHR5cGUsIG5hbWUgfSA9IHRoaXMuY2F0ZWdvcml6ZUZvbnQoZm9udEZhbWlseSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N5c3RlbScpIHJldHVybiB0cnVlO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmxvYWRlZEZvbnRzLmhhcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdnb29nbGUnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5mb250cz8uY2hlY2spIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IGRvY3VtZW50LmZvbnRzLmNoZWNrKGAxNnB4IFwiJHtuYW1lfVwiYCk7XG4gICAgICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlZEZvbnRzLmFkZChuYW1lKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZEZvbnRzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXRHb29nbGVGb250c0xpbmsoZm9udEZhbWlsaWVzID0gW10pIHtcbiAgICBjb25zdCBmYW1pbGllcyA9IGZvbnRGYW1pbGllc1xuICAgICAgLm1hcCgoZm9udCkgPT4gdGhpcy5ub3JtYWxpemVGb250TmFtZShmb250KSlcbiAgICAgIC5maWx0ZXIoKG5hbWUpID0+IHRoaXMuZ29vZ2xlRm9udFNldC5oYXMobmFtZSkpXG4gICAgICAubWFwKChuYW1lKSA9PiBgZmFtaWx5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGAke25hbWV9OndnaHRANDAwOzcwMGAucmVwbGFjZSgvIC9nLCAnKycpKX1gKVxuICAgICAgLmpvaW4oJyYnKTtcblxuICAgIGlmICghZmFtaWxpZXMpIHJldHVybiAnJztcblxuICAgIGNvbnN0IHVybCA9IGBodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/JHtmYW1pbGllc30mZGlzcGxheT1zd2FwYDtcbiAgICByZXR1cm4gYFxuPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tXCIgY3Jvc3NvcmlnaW4+XG48bGluayBocmVmPVwiJHt1cmx9XCIgcmVsPVwic3R5bGVzaGVldFwiPmAudHJpbSgpO1xuICB9XG5cbiAgZ2V0TG9hZGVkRm9udHNDU1MoKSB7XG4gICAgY29uc3QgZ29vZ2xlRm9udHMgPSBBcnJheS5mcm9tKHRoaXMubG9hZGVkRm9udHMpO1xuICAgIGlmIChnb29nbGVGb250cy5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICAgIGNvbnN0IGZhbWlsaWVzID0gZ29vZ2xlRm9udHNcbiAgICAgIC5tYXAoKGZvbnQpID0+IGBmYW1pbHk9JHtlbmNvZGVVUklDb21wb25lbnQoYCR7Zm9udH06d2dodEAzMDA7NDAwOzUwMDs2MDA7NzAwYC5yZXBsYWNlKC8gL2csICcrJykpfWApXG4gICAgICAuam9pbignJicpO1xuXG4gICAgcmV0dXJuIGBodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/JHtmYW1pbGllc30mZGlzcGxheT1zd2FwYDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZm9udE1hbmFnZXIgPSBuZXcgRm9udE1hbmFnZXIoKTtcclxuIl0sIm5hbWVzIjpbIldlYkZvbnQiLCJHT09HTEVfRk9OVFMiLCJTWVNURU1fRk9OVFMiLCJTZXQiLCJERUZBVUxUX1RJTUVPVVRfTVMiLCJGb250TWFuYWdlciIsIm5vcm1hbGl6ZUZvbnROYW1lIiwiZm9udEZhbWlseSIsIlN0cmluZyIsInJlcGxhY2UiLCJzcGxpdCIsInRyaW0iLCJjYXRlZ29yaXplRm9udCIsImZvbnROYW1lIiwidHlwZSIsIm5hbWUiLCJoYXMiLCJ0b0xvd2VyQ2FzZSIsImdvb2dsZUZvbnRTZXQiLCJ3YWl0Rm9yRG9jdW1lbnRGb250IiwidGltZW91dE1zIiwiZG9jdW1lbnQiLCJmb250cyIsImxvYWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxvYWRQcm9taXNlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0aGVuIiwidW5kZWZpbmVkIiwidGltZW91dFByb21pc2UiLCJzZXRUaW1lb3V0IiwicmFjZSIsImxvYWRHb29nbGVGb250Iiwib3B0aW9ucyIsIm5vcm1hbGl6ZWROYW1lIiwibG9hZGVkRm9udHMiLCJhZGQiLCJmYWlsZWRGb250cyIsImRlbGV0ZSIsImxvYWRpbmdQcm9taXNlcyIsImdldCIsInJlamVjdCIsImdvb2dsZSIsImZhbWlsaWVzIiwiYWN0aXZlIiwiZmluYWxseSIsImZvcmNlQ2FudmFzUmVkcmF3IiwiaW5hY3RpdmUiLCJFcnJvciIsInRpbWVvdXQiLCJzZXQiLCJsb2FkRm9udHMiLCJmb250RmFtaWxpZXMiLCJsb2FkZWQiLCJmYWlsZWQiLCJ1bmlxdWVGb250cyIsIm1hcCIsImZvbnQiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwicGVuZGluZ05hbWVzIiwicGVuZGluZ1Byb21pc2VzIiwiZm9yRWFjaCIsInB1c2giLCJzZXR0bGVkIiwiYWxsU2V0dGxlZCIsInJlc3VsdCIsImluZGV4IiwicmVhZHkiLCJpc0ZvbnRBdmFpbGFibGUiLCJzdGF0dXMiLCJwcmVsb2FkUG9wdWxhckZvbnRzIiwicG9wdWxhckZvbnRzIiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiY2hlY2siLCJhdmFpbGFibGUiLCJnZXRHb29nbGVGb250c0xpbmsiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwidXJsIiwiZ2V0TG9hZGVkRm9udHNDU1MiLCJnb29nbGVGb250cyIsIkFycmF5IiwiZnJvbSIsImNvbnN0cnVjdG9yIiwiZm9udENhY2hlIiwiTWFwIiwibm9tYnJlIiwiZm9udE1hbmFnZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/fontManager.js\n"));

/***/ })

});