"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/drag/dragGrupal.js":
/*!********************************!*\
  !*** ./src/drag/dragGrupal.js ***!
  \********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   endDragGrupal: () => (/* binding */ endDragGrupal),\n/* harmony export */   previewDragGrupal: () => (/* binding */ previewDragGrupal),\n/* harmony export */   startDragGrupalLider: () => (/* binding */ startDragGrupalLider)\n/* harmony export */ });\n/* harmony import */ var _utils_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/layout */ \"(pages-dir-browser)/./src/utils/layout.ts\");\n// C:\\Reservaeldia\\src\\drag\\dragGrupal.js\n\nconst isDragGrupalDebugEnabled = ()=> true && window.__DBG_DRAG_GRUPAL === true;\nconst dlog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!isDragGrupalDebugEnabled()) return;\n    console.log(...args);\n};\nconst dwarn = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!isDragGrupalDebugEnabled()) return;\n    console.warn(...args);\n};\nfunction getGrupoElementos() {\n    if (Array.isArray(window._grupoElementos) && window._grupoElementos.length > 0) {\n        return window._grupoElementos;\n    }\n    return window._elementosSeleccionados || [];\n}\nfunction calcularDeltaGrupal(stage) {\n    var _window__elementRefs, _stage_getPointerPosition;\n    const leaderId = window._grupoLider;\n    const dragInicial = window._dragInicial || null;\n    const posInicialLider = leaderId && dragInicial ? dragInicial[leaderId] : null;\n    const leaderNode = leaderId ? (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[leaderId] : null;\n    if (leaderNode && posInicialLider && typeof leaderNode.x === \"function\" && typeof leaderNode.y === \"function\") {\n        return {\n            deltaX: leaderNode.x() - posInicialLider.x,\n            deltaY: leaderNode.y() - posInicialLider.y,\n            source: \"leader-node\"\n        };\n    }\n    const currentPos = stage === null || stage === void 0 ? void 0 : (_stage_getPointerPosition = stage.getPointerPosition) === null || _stage_getPointerPosition === void 0 ? void 0 : _stage_getPointerPosition.call(stage);\n    const startPos = window._dragStartPos;\n    if (currentPos && startPos) {\n        return {\n            deltaX: currentPos.x - startPos.x,\n            deltaY: currentPos.y - startPos.y,\n            source: \"pointer\"\n        };\n    }\n    return null;\n}\nfunction applyPreviewDragGrupal(stage, leaderId, deltaX, deltaY) {\n    if (!stage || !window._dragInicial) return;\n    const last = window._groupPreviewLastDelta;\n    if (last && Math.abs(last.deltaX - deltaX) < 0.01 && Math.abs(last.deltaY - deltaY) < 0.01) {\n        return;\n    }\n    window._groupPreviewLastDelta = {\n        deltaX,\n        deltaY\n    };\n    const seguidores = Array.isArray(window._grupoSeguidores) ? window._grupoSeguidores : getGrupoElementos().filter((id)=>id !== leaderId);\n    const syncAttachedTextNode = (elementId, x, y)=>{\n        var _window__elementRefs;\n        const textNode = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[\"\".concat(elementId, \"-text\")];\n        if (!textNode || typeof textNode.position !== \"function\") return;\n        textNode.position({\n            x,\n            y\n        });\n    };\n    seguidores.forEach((elementId)=>{\n        var _window__elementRefs;\n        const node = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[elementId];\n        const posInicial = window._dragInicial[elementId];\n        if (!node || !posInicial) return;\n        const nextX = posInicial.x + deltaX;\n        const nextY = posInicial.y + deltaY;\n        node.position({\n            x: nextX,\n            y: nextY\n        });\n        syncAttachedTextNode(elementId, nextX, nextY);\n    });\n    if (!window._groupPreviewRaf) {\n        window._groupPreviewRaf = requestAnimationFrame(()=>{\n            window._groupPreviewRaf = null;\n            stage.batchDraw();\n        });\n    }\n}\nfunction startDragGrupalLider(e, obj) {\n    dlog(\"ðŸš€ [DRAG GRUPAL] Iniciando drag grupal - Objeto:\", {\n        id: obj.id,\n        tipo: obj.tipo,\n        figura: obj.figura\n    });\n    const seleccion = window._elementosSeleccionados || [];\n    dlog(\"ðŸ“‹ [DRAG GRUPAL] SelecciÃ³n actual:\", seleccion);\n    if (seleccion.length > 1 && seleccion.includes(obj.id)) {\n        var _e_target_getStage, _e_target, _stage_find, _stage_find1;\n        dlog(\"âœ… [DRAG GRUPAL] Condiciones cumplidas para drag grupal\");\n        const stage = e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : (_e_target_getStage = _e_target.getStage) === null || _e_target_getStage === void 0 ? void 0 : _e_target_getStage.call(_e_target);\n        var _stage_find_length;\n        const hoverCountBeforeStart = (_stage_find_length = stage === null || stage === void 0 ? void 0 : (_stage_find1 = stage.find) === null || _stage_find1 === void 0 ? void 0 : (_stage_find = _stage_find1.call(stage, \".ui-hover-indicator\")) === null || _stage_find === void 0 ? void 0 : _stage_find.length) !== null && _stage_find_length !== void 0 ? _stage_find_length : 0;\n        dlog(\"ðŸ§ª [HOVER][GROUP-CANDIDATE]\", {\n            leaderCandidate: obj.id,\n            seleccionSize: seleccion.length,\n            hoverCountBeforeStart,\n            windowIsDragging: window._isDragging,\n            grupoLider: window._grupoLider || null\n        });\n        // ðŸ”¥ DETECTAR LÃNEAS EN LA SELECCIÃ“N\n        const elementosDetallados = seleccion.map((id)=>{\n            var _window__objetosActuales, _window__elementRefs;\n            const objeto = (_window__objetosActuales = window._objetosActuales) === null || _window__objetosActuales === void 0 ? void 0 : _window__objetosActuales.find((o)=>o.id === id);\n            const node = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[id];\n            return {\n                id,\n                objeto: objeto ? {\n                    tipo: objeto.tipo,\n                    figura: objeto.figura\n                } : null,\n                nodeExists: !!node,\n                nodeDraggable: node ? node.draggable() : null\n            };\n        });\n        dlog(\"ðŸ“Š [DRAG GRUPAL] AnÃ¡lisis detallado de elementos:\", elementosDetallados);\n        const hayLineas = seleccion.some((id)=>{\n            var _window__objetosActuales;\n            const objeto = (_window__objetosActuales = window._objetosActuales) === null || _window__objetosActuales === void 0 ? void 0 : _window__objetosActuales.find((o)=>o.id === id);\n            return (objeto === null || objeto === void 0 ? void 0 : objeto.tipo) === 'forma' && (objeto === null || objeto === void 0 ? void 0 : objeto.figura) === 'line';\n        });\n        dlog(\"ðŸ“ [DRAG GRUPAL] Â¿Hay lÃ­neas en la selecciÃ³n?\", hayLineas);\n        if (hayLineas) {\n            dlog(\"ðŸ”§ [DRAG GRUPAL] Preparando lÃ­neas para drag grupal...\");\n            seleccion.forEach((id)=>{\n                var _window__objetosActuales;\n                const objeto = (_window__objetosActuales = window._objetosActuales) === null || _window__objetosActuales === void 0 ? void 0 : _window__objetosActuales.find((o)=>o.id === id);\n                if ((objeto === null || objeto === void 0 ? void 0 : objeto.tipo) === 'forma' && (objeto === null || objeto === void 0 ? void 0 : objeto.figura) === 'line') {\n                    var _window__elementRefs;\n                    const node = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[id];\n                    dlog(\"\\uD83D\\uDCCF [DRAG GRUPAL] L\\xednea \".concat(id, \":\"), {\n                        nodeExists: !!node,\n                        draggableBefore: node ? node.draggable() : null\n                    });\n                    if (node && node.draggable) {\n                        node.draggable(true);\n                        dlog(\"âœ… [DRAG GRUPAL] L\\xednea \".concat(id, \" habilitada para drag\"));\n                    }\n                }\n            });\n        }\n        if (!window._grupoLider) {\n            var _stage_find2, _stage_find3;\n            dlog(\"ðŸ‘‘ [DRAG GRUPAL] Estableciendo lÃ­der:\", obj.id);\n            if (window._groupPreviewRaf) {\n                cancelAnimationFrame(window._groupPreviewRaf);\n                window._groupPreviewRaf = null;\n            }\n            window._groupPreviewLastDelta = null;\n            window._grupoLider = obj.id;\n            window._grupoElementos = [\n                ...seleccion\n            ];\n            window._grupoSeguidores = seleccion.filter((id)=>id !== obj.id);\n            window._dragStartPos = e.target.getStage().getPointerPosition();\n            window._dragInicial = {};\n            window._skipIndividualEnd = new Set(seleccion);\n            window._skipUntil = 0;\n            window._isDragging = true;\n            try {\n                document.body.style.cursor = \"grabbing\";\n            } catch (e) {}\n            window.dispatchEvent(new Event(\"dragging-start\"));\n            var _stage_find_length1;\n            const hoverCountAfterGlobalStart = (_stage_find_length1 = stage === null || stage === void 0 ? void 0 : (_stage_find3 = stage.find) === null || _stage_find3 === void 0 ? void 0 : (_stage_find2 = _stage_find3.call(stage, \".ui-hover-indicator\")) === null || _stage_find2 === void 0 ? void 0 : _stage_find2.length) !== null && _stage_find_length1 !== void 0 ? _stage_find_length1 : 0;\n            dlog(\"ðŸ§ª [HOVER][GROUP-START-DISPATCH]\", {\n                leader: obj.id,\n                hoverCountAfterGlobalStart,\n                windowIsDragging: window._isDragging,\n                grupoLider: window._grupoLider || null\n            });\n            if (typeof requestAnimationFrame === \"function\") {\n                requestAnimationFrame(()=>{\n                    var _stage_find, _stage_find1;\n                    var _stage_find_length;\n                    const hoverCountRaf = (_stage_find_length = stage === null || stage === void 0 ? void 0 : (_stage_find1 = stage.find) === null || _stage_find1 === void 0 ? void 0 : (_stage_find = _stage_find1.call(stage, \".ui-hover-indicator\")) === null || _stage_find === void 0 ? void 0 : _stage_find.length) !== null && _stage_find_length !== void 0 ? _stage_find_length : 0;\n                    dlog(\"ðŸ§ª [HOVER][GROUP-START-DISPATCH][RAF]\", {\n                        leader: obj.id,\n                        hoverCountRaf,\n                        windowIsDragging: window._isDragging,\n                        grupoLider: window._grupoLider || null\n                    });\n                });\n            }\n            // Bloqueo de drag individual en seguidores + snapshot inicial\n            seleccion.forEach((id)=>{\n                var _window__objetosActuales, _window__elementRefs;\n                const objeto = (_window__objetosActuales = window._objetosActuales) === null || _window__objetosActuales === void 0 ? void 0 : _window__objetosActuales.find((o)=>o.id === id);\n                const node = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[id];\n                dlog(\"\\uD83D\\uDD04 [DRAG GRUPAL] Procesando elemento \".concat(id, \":\"), {\n                    esLider: id === obj.id,\n                    nodeExists: !!node,\n                    objetoType: objeto === null || objeto === void 0 ? void 0 : objeto.tipo\n                });\n                if (node && id !== obj.id) {\n                    const draggableBefore = node.draggable();\n                    try {\n                        node.draggable(false);\n                        dlog(\"\\uD83D\\uDEAB [DRAG GRUPAL] Deshabilitado drag para seguidor \".concat(id, \" (era: \").concat(draggableBefore, \")\"));\n                    } catch (err) {\n                        console.error(\"âŒ [DRAG GRUPAL] Error deshabilitando \".concat(id, \":\"), err);\n                    }\n                }\n                if (objeto) {\n                    const yAbsIni = (()=>{\n                        if (node && node.y) return node.y();\n                        const idx = (window._seccionesOrdenadas || []).findIndex((s)=>s.id === objeto.seccionId);\n                        const offsetY = idx >= 0 ? (window._seccionesOrdenadas || []).slice(0, idx).reduce((sum, s)=>sum + (s.altura || 0), 0) : 0;\n                        return (objeto.y || 0) + offsetY;\n                    })();\n                    window._dragInicial[id] = {\n                        x: (node === null || node === void 0 ? void 0 : node.x) ? node.x() : objeto.x || 0,\n                        y: yAbsIni\n                    };\n                    dlog(\"\\uD83D\\uDCCD [DRAG GRUPAL] Posici\\xf3n inicial guardada para \".concat(id, \":\"), window._dragInicial[id]);\n                }\n            });\n            dlog(\"ðŸŽ¯ [DRAG GRUPAL] Drag grupal iniciado correctamente\");\n        } else {\n            dlog(\"âš ï¸ [DRAG GRUPAL] Ya hay un lÃ­der activo:\", window._grupoLider);\n        }\n        return true;\n    }\n    // ðŸ” DEBUG CLAVE: si NO se inicia drag grupal, NO deberÃ­amos tocar estado global\n    dlog(\"ðŸ§ª [DRAG GRUPAL] NO-START snapshot\", {\n        objId: obj.id,\n        seleccion,\n        grupoLider: window._grupoLider,\n        isDragging: window._isDragging,\n        skipIndividualEndSize: window._skipIndividualEnd ? window._skipIndividualEnd.size : null,\n        skipUntil: window._skipUntil,\n        dragStartPos: window._dragStartPos\n    });\n    dlog(\"âŒ [DRAG GRUPAL] Condiciones no cumplidas para drag grupal\");\n    return false;\n}\nfunction previewDragGrupal(e, obj, onChange) {\n    var _e_target_getStage, _e_target;\n    // Solo el lÃ­der debe mover visualmente al resto durante el preview.\n    if (!window._grupoLider || (obj === null || obj === void 0 ? void 0 : obj.id) !== window._grupoLider) return;\n    const stage = e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : (_e_target_getStage = _e_target.getStage) === null || _e_target_getStage === void 0 ? void 0 : _e_target_getStage.call(_e_target);\n    if (!stage || !window._dragInicial) return;\n    const deltaData = calcularDeltaGrupal(stage);\n    if (!deltaData) return;\n    const { deltaX, deltaY } = deltaData;\n    applyPreviewDragGrupal(stage, obj.id, deltaX, deltaY);\n}\nfunction endDragGrupal(e, obj, onChange, hasDragged, setIsDragging) {\n    dlog(\"ðŸ [DRAG GRUPAL] endDragGrupal llamado:\", {\n        objId: obj.id,\n        esLider: obj.id === window._grupoLider,\n        grupoLider: window._grupoLider,\n        isDragging: window._isDragging,\n        skipIndividualEndSize: window._skipIndividualEnd ? window._skipIndividualEnd.size : null,\n        skipUntil: window._skipUntil\n    });\n    // Solo procesa el lÃ­der\n    if (window._grupoLider && obj.id === window._grupoLider) {\n        dlog(\"ðŸ‘‘ [DRAG GRUPAL] Procesando como lÃ­der...\");\n        const stage = e.target.getStage();\n        const deltaData = window._dragInicial ? calcularDeltaGrupal(stage) : null;\n        if (deltaData && window._dragInicial) {\n            if (window._groupPreviewRaf) {\n                cancelAnimationFrame(window._groupPreviewRaf);\n                window._groupPreviewRaf = null;\n            }\n            window._groupPreviewLastDelta = null;\n            const { deltaX, deltaY, source } = deltaData;\n            dlog(\"ðŸ“ [DRAG GRUPAL] Delta calculado:\", {\n                deltaX,\n                deltaY,\n                source\n            });\n            const elementosGrupo = getGrupoElementos();\n            // ðŸ”¥ APLICAR EL DELTA A CADA ELEMENTO (incluyendo al lÃ­der)\n            elementosGrupo.forEach((elementId)=>{\n                var _window__objetosActuales, _window__elementRefs;\n                const objeto = (_window__objetosActuales = window._objetosActuales) === null || _window__objetosActuales === void 0 ? void 0 : _window__objetosActuales.find((o)=>o.id === elementId);\n                if (!objeto) return;\n                const posInicial = window._dragInicial[elementId];\n                if (!posInicial) return;\n                const nuevaX = posInicial.x + deltaX;\n                const nuevaY = posInicial.y + deltaY;\n                dlog(\"\\uD83D\\uDC65 [DRAG GRUPAL] Elemento \".concat(elementId, \":\"), {\n                    posInicial,\n                    delta: {\n                        deltaX,\n                        deltaY\n                    },\n                    nuevaPos: {\n                        x: nuevaX,\n                        y: nuevaY\n                    }\n                });\n                const node = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[elementId];\n                const { nuevaSeccion } = (0,_utils_layout__WEBPACK_IMPORTED_MODULE_0__.determinarNuevaSeccion)(nuevaY, objeto.seccionId, window._seccionesOrdenadas || []);\n                try {\n                    (node === null || node === void 0 ? void 0 : node.setAttr) && node.setAttr(\"_muteNextEnd\", true);\n                } catch (e) {}\n                const cambios = {\n                    x: nuevaX,\n                    y: nuevaY,\n                    ...nuevaSeccion ? {\n                        seccionId: nuevaSeccion\n                    } : {},\n                    finalizoDrag: true,\n                    causa: \"drag-grupal\"\n                };\n                onChange(elementId, cambios);\n            });\n        } else {\n            dwarn(\"âš ï¸ [DRAG GRUPAL] No se pudo calcular delta final del grupo\");\n        }\n        // Cleanup\n        window._skipUntil = performance.now() + 400;\n        const seleccion = getGrupoElementos();\n        seleccion.forEach((id)=>{\n            var _window__elementRefs;\n            const elNode = (_window__elementRefs = window._elementRefs) === null || _window__elementRefs === void 0 ? void 0 : _window__elementRefs[id];\n            if (!elNode) return;\n            setTimeout(()=>{\n                try {\n                    const before = elNode.draggable();\n                    elNode.draggable(true);\n                    const after = elNode.draggable();\n                    dlog(\"ðŸ§© [DRAG GRUPAL] restore draggable\", {\n                        id,\n                        before,\n                        after\n                    });\n                } catch (err) {\n                    dwarn(\"âŒ [DRAG GRUPAL] restore draggable error\", {\n                        id,\n                        err\n                    });\n                }\n            }, 24);\n        });\n        window._grupoLider = null;\n        window._grupoElementos = null;\n        window._grupoSeguidores = null;\n        window._dragStartPos = null;\n        window._dragInicial = null;\n        // ðŸ”¥ RESETEAR CURSOR AL FINALIZAR DRAG GRUPAL\n        try {\n            document.body.style.cursor = \"default\";\n        } catch (e) {}\n        setTimeout(()=>{\n            window._skipIndividualEnd = null;\n            window._skipUntil = 0;\n        }, 450);\n        setTimeout(()=>{\n            hasDragged.current = false;\n        }, 40);\n        return true;\n    }\n    // Seguidores\n    if (window._grupoLider) {\n        const seleccion = window._elementosSeleccionados || [];\n        if (seleccion.includes(obj.id)) {\n            setTimeout(()=>{\n                hasDragged.current = false;\n            }, 40);\n            return true;\n        }\n    }\n    return false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9kcmFnL2RyYWdHcnVwYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHlDQUF5QztBQUNlO0FBRXhELE1BQU1DLDJCQUEyQixJQUMvQixLQUE2QixJQUFJQyxPQUFPQyxpQkFBaUIsS0FBSztBQUVoRSxNQUFNQyxPQUFPO3FDQUFJQztRQUFBQTs7SUFDZixJQUFJLENBQUNKLDRCQUE0QjtJQUNqQ0ssUUFBUUMsR0FBRyxJQUFJRjtBQUNqQjtBQUVBLE1BQU1HLFFBQVE7cUNBQUlIO1FBQUFBOztJQUNoQixJQUFJLENBQUNKLDRCQUE0QjtJQUNqQ0ssUUFBUUcsSUFBSSxJQUFJSjtBQUNsQjtBQUVBLFNBQVNLO0lBQ1AsSUFBSUMsTUFBTUMsT0FBTyxDQUFDVixPQUFPVyxlQUFlLEtBQUtYLE9BQU9XLGVBQWUsQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7UUFDOUUsT0FBT1osT0FBT1csZUFBZTtJQUMvQjtJQUNBLE9BQU9YLE9BQU9hLHVCQUF1QixJQUFJLEVBQUU7QUFDN0M7QUFFQSxTQUFTQyxvQkFBb0JDLEtBQUs7UUFJRmYsc0JBZVhlO0lBbEJuQixNQUFNQyxXQUFXaEIsT0FBT2lCLFdBQVc7SUFDbkMsTUFBTUMsY0FBY2xCLE9BQU9tQixZQUFZLElBQUk7SUFDM0MsTUFBTUMsa0JBQWtCSixZQUFZRSxjQUFjQSxXQUFXLENBQUNGLFNBQVMsR0FBRztJQUMxRSxNQUFNSyxhQUFhTCxZQUFXaEIsdUJBQUFBLE9BQU9zQixZQUFZLGNBQW5CdEIsMkNBQUFBLG9CQUFxQixDQUFDZ0IsU0FBUyxHQUFHO0lBRWhFLElBQ0VLLGNBQ0FELG1CQUNBLE9BQU9DLFdBQVdFLENBQUMsS0FBSyxjQUN4QixPQUFPRixXQUFXRyxDQUFDLEtBQUssWUFDeEI7UUFDQSxPQUFPO1lBQ0xDLFFBQVFKLFdBQVdFLENBQUMsS0FBS0gsZ0JBQWdCRyxDQUFDO1lBQzFDRyxRQUFRTCxXQUFXRyxDQUFDLEtBQUtKLGdCQUFnQkksQ0FBQztZ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QUFHO1FBQzFCdEMsT0FBTytCLGFBQWEsR0FBRztRQUN2Qi9CLE9BQU9tQixZQUFZLEdBQUc7UUFFdEIsOENBQThDO1FBQzlDLElBQUk7WUFDRmlFLFNBQVNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxNQUFNLEdBQUc7UUFDL0IsRUFBRSxVQUFNLENBQUU7UUFFVjhDLFdBQVc7WUFDVHJJLE9BQU9pRixrQkFBa0IsR0FBRztZQUM1QmpGLE9BQU9tRixVQUFVLEdBQUc7UUFDdEIsR0FBRztRQUVIa0QsV0FBVztZQUFRZixXQUFXa0IsT0FBTyxHQUFHO1FBQU8sR0FBRztRQUNsRCxPQUFPO0lBQ1Q7SUFFQSxhQUFhO0lBQ2IsSUFBSXhJLE9BQU9pQixXQUFXLEVBQUU7UUFDdEIsTUFBTXlDLFlBQVkxRCxPQUFPYSx1QkFBdUIsSUFBSSxFQUFFO1FBQ3RELElBQUk2QyxVQUFVQyxRQUFRLENBQUNKLElBQUlmLEVBQUUsR0FBRztZQUM5QjZGLFdBQVc7Z0JBQVFmLFdBQVdrQixPQUFPLEdBQUc7WUFBTyxHQUFHO1lBQ2xELE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUIiwic291cmNlcyI6WyJDOlxcUmVzZXJ2YWVsZGlhXFxzcmNcXGRyYWdcXGRyYWdHcnVwYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQzpcXFJlc2VydmFlbGRpYVxcc3JjXFxkcmFnXFxkcmFnR3J1cGFsLmpzXG5pbXBvcnQgeyBkZXRlcm1pbmFyTnVldmFTZWNjaW9uIH0gZnJvbSBcIkAvdXRpbHMvbGF5b3V0XCI7XG5cbmNvbnN0IGlzRHJhZ0dydXBhbERlYnVnRW5hYmxlZCA9ICgpID0+XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fREJHX0RSQUdfR1JVUEFMID09PSB0cnVlO1xuXG5jb25zdCBkbG9nID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFpc0RyYWdHcnVwYWxEZWJ1Z0VuYWJsZWQoKSkgcmV0dXJuO1xuICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbn07XG5cbmNvbnN0IGR3YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFpc0RyYWdHcnVwYWxEZWJ1Z0VuYWJsZWQoKSkgcmV0dXJuO1xuICBjb25zb2xlLndhcm4oLi4uYXJncyk7XG59O1xuXG5mdW5jdGlvbiBnZXRHcnVwb0VsZW1lbnRvcygpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkod2luZG93Ll9ncnVwb0VsZW1lbnRvcykgJiYgd2luZG93Ll9ncnVwb0VsZW1lbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5fZ3J1cG9FbGVtZW50b3M7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5fZWxlbWVudG9zU2VsZWNjaW9uYWRvcyB8fCBbXTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXJEZWx0YUdydXBhbChzdGFnZSkge1xuICBjb25zdCBsZWFkZXJJZCA9IHdpbmRvdy5fZ3J1cG9MaWRlcjtcbiAgY29uc3QgZHJhZ0luaWNpYWwgPSB3aW5kb3cuX2RyYWdJbmljaWFsIHx8IG51bGw7XG4gIGNvbnN0IHBvc0luaWNpYWxMaWRlciA9IGxlYWRlcklkICYmIGRyYWdJbmljaWFsID8gZHJhZ0luaWNpYWxbbGVhZGVySWRdIDogbnVsbDtcbiAgY29uc3QgbGVhZGVyTm9kZSA9IGxlYWRlcklkID8gd2luZG93Ll9lbGVtZW50UmVmcz8uW2xlYWRlcklkXSA6IG51bGw7XG5cbiAgaWYgKFxuICAgIGxlYWRlck5vZGUgJiZcbiAgICBwb3NJbmljaWFsTGlkZXIgJiZcbiAgICB0eXBlb2YgbGVhZGVyTm9kZS54ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2YgbGVhZGVyTm9kZS55ID09PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlbHRhWDogbGVhZGVyTm9kZS54KCkgLSBwb3NJbmljaWFsTGlkZXIueCxcbiAgICAgIGRlbHRhWTogbGVhZGVyTm9kZS55KCkgLSBwb3NJbmljaWFsTGlkZXIueSxcbiAgICAgIHNvdXJjZTogXCJsZWFkZXItbm9kZVwiXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRQb3MgPSBzdGFnZT8uZ2V0UG9pbnRlclBvc2l0aW9uPy4oKTtcbiAgY29uc3Qgc3RhcnRQb3MgPSB3aW5kb3cuX2RyYWdTdGFydFBvcztcbiAgaWYgKGN1cnJlbnRQb3MgJiYgc3RhcnRQb3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVsdGFYOiBjdXJyZW50UG9zLnggLSBzdGFydFBvcy54LFxuICAgICAgZGVsdGFZOiBjdXJyZW50UG9zLnkgLSBzdGFydFBvcy55LFxuICAgICAgc291cmNlOiBcInBvaW50ZXJcIlxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXBwbHlQcmV2aWV3RHJhZ0dydXBhbChzdGFnZSwgbGVhZGVySWQsIGRlbHRhWCwgZGVsdGFZKSB7XG4gIGlmICghc3RhZ2UgfHwgIXdpbmRvdy5fZHJhZ0luaWNpYWwpIHJldHVybjtcblxuICBjb25zdCBsYXN0ID0gd2luZG93Ll9ncm91cFByZXZpZXdMYXN0RGVsdGE7XG4gIGlmIChcbiAgICBsYXN0ICYmXG4gICAgTWF0aC5hYnMobGFzdC5kZWx0YVggLSBkZWx0YVgpIDwgMC4wMSAmJlxuICAgIE1hdGguYWJzKGxhc3QuZGVsdGFZIC0gZGVsdGFZKSA8IDAuMDFcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5fZ3JvdXBQcmV2aWV3TGFzdERlbHRhID0geyBkZWx0YVgsIGRlbHRhWSB9O1xuXG4gIGNvbnN0IHNlZ3VpZG9yZXMgPSBBcnJheS5pc0FycmF5KHdpbmRvdy5fZ3J1cG9TZWd1aWRvcmVzKVxuICAgID8gd2luZG93Ll9ncnVwb1NlZ3VpZG9yZXNcbiAgICA6IGdldEdydXBvRWxlbWVudG9zKCkuZmlsdGVyKChpZCkgPT4gaWQgIT09IGxlYWRlcklkKTtcblxuICBjb25zdCBzeW5jQXR0YWNoZWRUZXh0Tm9kZSA9IChlbGVtZW50SWQsIHgsIHkpID0+IHtcbiAgICBjb25zdCB0ZXh0Tm9kZSA9IHdpbmRvdy5fZWxlbWVudFJlZnM/LltgJHtlbGVtZW50SWR9LXRleHRgXTtcbiAgICBpZiAoIXRleHROb2RlIHx8IHR5cGVvZiB0ZXh0Tm9kZS5wb3NpdGlvbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm47XG4gICAgdGV4dE5vZGUucG9zaXRpb24oeyB4LCB5IH0pO1xuICB9O1xuXG4gIHNlZ3VpZG9yZXMuZm9yRWFjaCgoZWxlbWVudElkKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHdpbmRvdy5fZWxlbWVudFJlZnM/LltlbGVtZW50SWRdO1xuICAgIGNvbnN0IHBvc0luaWNpYWwgPSB3aW5kb3cuX2RyYWdJbmljaWFsW2VsZW1lbnRJZF07XG4gICAgaWYgKCFub2RlIHx8ICFwb3NJbmljaWFsKSByZXR1cm47XG4gICAgY29uc3QgbmV4dFggPSBwb3NJbmljaWFsLnggKyBkZWx0YVg7XG4gICAgY29uc3QgbmV4dFkgPSBwb3NJbmljaWFsLnkgKyBkZWx0YVk7XG4gICAgbm9kZS5wb3NpdGlvbih7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZXG4gICAgfSk7XG4gICAgc3luY0F0dGFjaGVkVGV4dE5vZGUoZWxlbWVudElkLCBuZXh0WCwgbmV4dFkpO1xuICB9KTtcblxuICBpZiAoIXdpbmRvdy5fZ3JvdXBQcmV2aWV3UmFmKSB7XG4gICAgd2luZG93Ll9ncm91cFByZXZpZXdSYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgd2luZG93Ll9ncm91cFByZXZpZXdSYWYgPSBudWxsO1xuICAgICAgc3RhZ2UuYmF0Y2hEcmF3KCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0RHJhZ0dydXBhbExpZGVyKGUsIG9iaikge1xuICBkbG9nKFwi8J+agCBbRFJBRyBHUlVQQUxdIEluaWNpYW5kbyBkcmFnIGdydXBhbCAtIE9iamV0bzpcIiwge1xuICAgIGlkOiBvYmouaWQsXG4gICAgdGlwbzogb2JqLnRpcG8sXG4gICAgZmlndXJhOiBvYmouZmlndXJhXG4gIH0pO1xuXG4gIGNvbnN0IHNlbGVjY2lvbiA9IHdpbmRvdy5fZWxlbWVudG9zU2VsZWNjaW9uYWRvcyB8fCBbXTtcbiAgZGxvZyhcIvCfk4sgW0RSQUcgR1JVUEFMXSBTZWxlY2Npw7NuIGFjdHVhbDpcIiwgc2VsZWNjaW9uKTtcblxuICBpZiAoc2VsZWNjaW9uLmxlbmd0aCA+IDEgJiYgc2VsZWNjaW9uLmluY2x1ZGVzKG9iai5pZCkpIHtcbiAgICBkbG9nKFwi4pyFIFtEUkFHIEdSVVBBTF0gQ29uZGljaW9uZXMgY3VtcGxpZGFzIHBhcmEgZHJhZyBncnVwYWxcIik7XG4gICAgY29uc3Qgc3RhZ2UgPSBlPy50YXJnZXQ/LmdldFN0YWdlPy4oKTtcbiAgICBjb25zdCBob3ZlckNvdW50QmVmb3JlU3RhcnQgPSBzdGFnZT8uZmluZD8uKFwiLnVpLWhvdmVyLWluZGljYXRvclwiKT8ubGVuZ3RoID8/IDA7XG4gICAgZGxvZyhcIvCfp6ogW0hPVkVSXVtHUk9VUC1DQU5ESURBVEVdXCIsIHtcbiAgICAgIGxlYWRlckNhbmRpZGF0ZTogb2JqLmlkLFxuICAgICAgc2VsZWNjaW9uU2l6ZTogc2VsZWNjaW9uLmxlbmd0aCxcbiAgICAgIGhvdmVyQ291bnRCZWZvcmVTdGFydCxcbiAgICAgIHdpbmRvd0lzRHJhZ2dpbmc6IHdpbmRvdy5faXNEcmFnZ2luZyxcbiAgICAgIGdydXBvTGlkZXI6IHdpbmRvdy5fZ3J1cG9MaWRlciB8fCBudWxsLFxuICAgIH0pO1xuXG4gICAgLy8g8J+UpSBERVRFQ1RBUiBMw41ORUFTIEVOIExBIFNFTEVDQ0nDk05cbiAgICBjb25zdCBlbGVtZW50b3NEZXRhbGxhZG9zID0gc2VsZWNjaW9uLm1hcChpZCA9PiB7XG4gICAgICBjb25zdCBvYmpldG8gPSB3aW5kb3cuX29iamV0b3NBY3R1YWxlcz8uZmluZChvID0+IG8uaWQgPT09IGlkKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB3aW5kb3cuX2VsZW1lbnRSZWZzPy5baWRdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9iamV0bzogb2JqZXRvID8ge1xuICAgICAgICAgIHRpcG86IG9iamV0by50aXBvLFxuICAgICAgICAgIGZpZ3VyYTogb2JqZXRvLmZpZ3VyYVxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgbm9kZUV4aXN0czogISFub2RlLFxuICAgICAgICBub2RlRHJhZ2dhYmxlOiBub2RlID8gbm9kZS5kcmFnZ2FibGUoKSA6IG51bGxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkbG9nKFwi8J+TiiBbRFJBRyBHUlVQQUxdIEFuw6FsaXNpcyBkZXRhbGxhZG8gZGUgZWxlbWVudG9zOlwiLCBlbGVtZW50b3NEZXRhbGxhZG9zKTtcblxuICAgIGNvbnN0IGhheUxpbmVhcyA9IHNlbGVjY2lvbi5zb21lKGlkID0+IHtcbiAgICAgIGNvbnN0IG9iamV0byA9IHdpbmRvdy5fb2JqZXRvc0FjdHVhbGVzPy5maW5kKG8gPT4gby5pZCA9PT0gaWQpO1xuICAgICAgcmV0dXJuIG9iamV0bz8udGlwbyA9PT0gJ2Zvcm1hJyAmJiBvYmpldG8/LmZpZ3VyYSA9PT0gJ2xpbmUnO1xuICAgIH0pO1xuXG4gICAgZGxvZyhcIvCfk48gW0RSQUcgR1JVUEFMXSDCv0hheSBsw61uZWFzIGVuIGxhIHNlbGVjY2nDs24/XCIsIGhheUxpbmVhcyk7XG5cbiAgICBpZiAoaGF5TGluZWFzKSB7XG4gICAgICBkbG9nKFwi8J+UpyBbRFJBRyBHUlVQQUxdIFByZXBhcmFuZG8gbMOtbmVhcyBwYXJhIGRyYWcgZ3J1cGFsLi4uXCIpO1xuICAgICAgc2VsZWNjaW9uLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBvYmpldG8gPSB3aW5kb3cuX29iamV0b3NBY3R1YWxlcz8uZmluZChvID0+IG8uaWQgPT09IGlkKTtcbiAgICAgICAgaWYgKG9iamV0bz8udGlwbyA9PT0gJ2Zvcm1hJyAmJiBvYmpldG8/LmZpZ3VyYSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHdpbmRvdy5fZWxlbWVudFJlZnM/LltpZF07XG4gICAgICAgICAgZGxvZyhg8J+TjyBbRFJBRyBHUlVQQUxdIEzDrW5lYSAke2lkfTpgLCB7XG4gICAgICAgICAgICBub2RlRXhpc3RzOiAhIW5vZGUsXG4gICAgICAgICAgICBkcmFnZ2FibGVCZWZvcmU6IG5vZGUgPyBub2RlLmRyYWdnYWJsZSgpIDogbnVsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIG5vZGUuZHJhZ2dhYmxlKHRydWUpO1xuICAgICAgICAgICAgZGxvZyhg4pyFIFtEUkFHIEdSVVBBTF0gTMOtbmVhICR7aWR9IGhhYmlsaXRhZGEgcGFyYSBkcmFnYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXdpbmRvdy5fZ3J1cG9MaWRlcikge1xuICAgICAgZGxvZyhcIvCfkZEgW0RSQUcgR1JVUEFMXSBFc3RhYmxlY2llbmRvIGzDrWRlcjpcIiwgb2JqLmlkKTtcbiAgICAgIGlmICh3aW5kb3cuX2dyb3VwUHJldmlld1JhZikge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh3aW5kb3cuX2dyb3VwUHJldmlld1JhZik7XG4gICAgICAgIHdpbmRvdy5fZ3JvdXBQcmV2aWV3UmFmID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5fZ3JvdXBQcmV2aWV3TGFzdERlbHRhID0gbnVsbDtcbiAgICAgIHdpbmRvdy5fZ3J1cG9MaWRlciA9IG9iai5pZDtcbiAgICAgIHdpbmRvdy5fZ3J1cG9FbGVtZW50b3MgPSBbLi4uc2VsZWNjaW9uXTtcbiAgICAgIHdpbmRvdy5fZ3J1cG9TZWd1aWRvcmVzID0gc2VsZWNjaW9uLmZpbHRlcigoaWQpID0+IGlkICE9PSBvYmouaWQpO1xuICAgICAgd2luZG93Ll9kcmFnU3RhcnRQb3MgPSBlLnRhcmdldC5nZXRTdGFnZSgpLmdldFBvaW50ZXJQb3NpdGlvbigpO1xuICAgICAgd2luZG93Ll9kcmFnSW5pY2lhbCA9IHt9O1xuICAgICAgd2luZG93Ll9za2lwSW5kaXZpZHVhbEVuZCA9IG5ldyBTZXQoc2VsZWNjaW9uKTtcbiAgICAgIHdpbmRvdy5fc2tpcFVudGlsID0gMDtcblxuICAgICAgd2luZG93Ll9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJncmFiYmluZ1wiO1xuICAgICAgfSBjYXRjaCB7IH1cbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImRyYWdnaW5nLXN0YXJ0XCIpKTtcbiAgICAgIGNvbnN0IGhvdmVyQ291bnRBZnRlckdsb2JhbFN0YXJ0ID0gc3RhZ2U/LmZpbmQ/LihcIi51aS1ob3Zlci1pbmRpY2F0b3JcIik/Lmxlbmd0aCA/PyAwO1xuICAgICAgZGxvZyhcIvCfp6ogW0hPVkVSXVtHUk9VUC1TVEFSVC1ESVNQQVRDSF1cIiwge1xuICAgICAgICBsZWFkZXI6IG9iai5pZCxcbiAgICAgICAgaG92ZXJDb3VudEFmdGVyR2xvYmFsU3RhcnQsXG4gICAgICAgIHdpbmRvd0lzRHJhZ2dpbmc6IHdpbmRvdy5faXNEcmFnZ2luZyxcbiAgICAgICAgZ3J1cG9MaWRlcjogd2luZG93Ll9ncnVwb0xpZGVyIHx8IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBob3ZlckNvdW50UmFmID0gc3RhZ2U/LmZpbmQ/LihcIi51aS1ob3Zlci1pbmRpY2F0b3JcIik/Lmxlbmd0aCA/PyAwO1xuICAgICAgICAgIGRsb2coXCLwn6eqIFtIT1ZFUl1bR1JPVVAtU1RBUlQtRElTUEFUQ0hdW1JBRl1cIiwge1xuICAgICAgICAgICAgbGVhZGVyOiBvYmouaWQsXG4gICAgICAgICAgICBob3ZlckNvdW50UmFmLFxuICAgICAgICAgICAgd2luZG93SXNEcmFnZ2luZzogd2luZG93Ll9pc0RyYWdnaW5nLFxuICAgICAgICAgICAgZ3J1cG9MaWRlcjogd2luZG93Ll9ncnVwb0xpZGVyIHx8IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBCbG9xdWVvIGRlIGRyYWcgaW5kaXZpZHVhbCBlbiBzZWd1aWRvcmVzICsgc25hcHNob3QgaW5pY2lhbFxuICAgICAgc2VsZWNjaW9uLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iamV0byA9IHdpbmRvdy5fb2JqZXRvc0FjdHVhbGVzPy5maW5kKG8gPT4gby5pZCA9PT0gaWQpO1xuICAgICAgICBjb25zdCBub2RlID0gd2luZG93Ll9lbGVtZW50UmVmcz8uW2lkXTtcblxuICAgICAgICBkbG9nKGDwn5SEIFtEUkFHIEdSVVBBTF0gUHJvY2VzYW5kbyBlbGVtZW50byAke2lkfTpgLCB7XG4gICAgICAgICAgZXNMaWRlcjogaWQgPT09IG9iai5pZCxcbiAgICAgICAgICBub2RlRXhpc3RzOiAhIW5vZGUsXG4gICAgICAgICAgb2JqZXRvVHlwZTogb2JqZXRvPy50aXBvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChub2RlICYmIGlkICE9PSBvYmouaWQpIHtcbiAgICAgICAgICBjb25zdCBkcmFnZ2FibGVCZWZvcmUgPSBub2RlLmRyYWdnYWJsZSgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlLmRyYWdnYWJsZShmYWxzZSk7XG4gICAgICAgICAgICBkbG9nKGDwn5qrIFtEUkFHIEdSVVBBTF0gRGVzaGFiaWxpdGFkbyBkcmFnIHBhcmEgc2VndWlkb3IgJHtpZH0gKGVyYTogJHtkcmFnZ2FibGVCZWZvcmV9KWApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIFtEUkFHIEdSVVBBTF0gRXJyb3IgZGVzaGFiaWxpdGFuZG8gJHtpZH06YCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZXRvKSB7XG4gICAgICAgICAgY29uc3QgeUFic0luaSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnkpIHJldHVybiBub2RlLnkoKTtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9ICh3aW5kb3cuX3NlY2Npb25lc09yZGVuYWRhcyB8fCBbXSkuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gb2JqZXRvLnNlY2Npb25JZCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gaWR4ID49IDAgPyAod2luZG93Ll9zZWNjaW9uZXNPcmRlbmFkYXMgfHwgW10pXG4gICAgICAgICAgICAgIC5zbGljZSgwLCBpZHgpXG4gICAgICAgICAgICAgIC5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgKHMuYWx0dXJhIHx8IDApLCAwKSA6IDA7XG4gICAgICAgICAgICByZXR1cm4gKG9iamV0by55IHx8IDApICsgb2Zmc2V0WTtcbiAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgd2luZG93Ll9kcmFnSW5pY2lhbFtpZF0gPSB7XG4gICAgICAgICAgICB4OiBub2RlPy54ID8gbm9kZS54KCkgOiAob2JqZXRvLnggfHwgMCksXG4gICAgICAgICAgICB5OiB5QWJzSW5pXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGRsb2coYPCfk40gW0RSQUcgR1JVUEFMXSBQb3NpY2nDs24gaW5pY2lhbCBndWFyZGFkYSBwYXJhICR7aWR9OmAsIHdpbmRvdy5fZHJhZ0luaWNpYWxbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRsb2coXCLwn46vIFtEUkFHIEdSVVBBTF0gRHJhZyBncnVwYWwgaW5pY2lhZG8gY29ycmVjdGFtZW50ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGxvZyhcIuKaoO+4jyBbRFJBRyBHUlVQQUxdIFlhIGhheSB1biBsw61kZXIgYWN0aXZvOlwiLCB3aW5kb3cuX2dydXBvTGlkZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyDwn5SNIERFQlVHIENMQVZFOiBzaSBOTyBzZSBpbmljaWEgZHJhZyBncnVwYWwsIE5PIGRlYmVyw61hbW9zIHRvY2FyIGVzdGFkbyBnbG9iYWxcbiAgZGxvZyhcIvCfp6ogW0RSQUcgR1JVUEFMXSBOTy1TVEFSVCBzbmFwc2hvdFwiLCB7XG4gICAgb2JqSWQ6IG9iai5pZCxcbiAgICBzZWxlY2Npb24sXG4gICAgZ3J1cG9MaWRlcjogd2luZG93Ll9ncnVwb0xpZGVyLFxuICAgIGlzRHJhZ2dpbmc6IHdpbmRvdy5faXNEcmFnZ2luZyxcbiAgICBza2lwSW5kaXZpZHVhbEVuZFNpemU6IHdpbmRvdy5fc2tpcEluZGl2aWR1YWxFbmQgPyB3aW5kb3cuX3NraXBJbmRpdmlkdWFsRW5kLnNpemUgOiBudWxsLFxuICAgIHNraXBVbnRpbDogd2luZG93Ll9za2lwVW50aWwsXG4gICAgZHJhZ1N0YXJ0UG9zOiB3aW5kb3cuX2RyYWdTdGFydFBvcyxcbiAgfSk7XG5cbiAgZGxvZyhcIuKdjCBbRFJBRyBHUlVQQUxdIENvbmRpY2lvbmVzIG5vIGN1bXBsaWRhcyBwYXJhIGRyYWcgZ3J1cGFsXCIpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gcHJldmlld0RyYWdHcnVwYWwoZSwgb2JqLCBvbkNoYW5nZSkge1xuICAvLyBTb2xvIGVsIGzDrWRlciBkZWJlIG1vdmVyIHZpc3VhbG1lbnRlIGFsIHJlc3RvIGR1cmFudGUgZWwgcHJldmlldy5cbiAgaWYgKCF3aW5kb3cuX2dydXBvTGlkZXIgfHwgb2JqPy5pZCAhPT0gd2luZG93Ll9ncnVwb0xpZGVyKSByZXR1cm47XG5cbiAgY29uc3Qgc3RhZ2UgPSBlPy50YXJnZXQ/LmdldFN0YWdlPy4oKTtcbiAgaWYgKCFzdGFnZSB8fCAhd2luZG93Ll9kcmFnSW5pY2lhbCkgcmV0dXJuO1xuXG4gIGNvbnN0IGRlbHRhRGF0YSA9IGNhbGN1bGFyRGVsdGFHcnVwYWwoc3RhZ2UpO1xuICBpZiAoIWRlbHRhRGF0YSkgcmV0dXJuO1xuXG4gIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IGRlbHRhRGF0YTtcbiAgYXBwbHlQcmV2aWV3RHJhZ0dydXBhbChzdGFnZSwgb2JqLmlkLCBkZWx0YVgsIGRlbHRhWSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmREcmFnR3J1cGFsKGUsIG9iaiwgb25DaGFuZ2UsIGhhc0RyYWdnZWQsIHNldElzRHJhZ2dpbmcpIHtcbiAgZGxvZyhcIvCfj4EgW0RSQUcgR1JVUEFMXSBlbmREcmFnR3J1cGFsIGxsYW1hZG86XCIsIHtcbiAgICBvYmpJZDogb2JqLmlkLFxuICAgIGVzTGlkZXI6IG9iai5pZCA9PT0gd2luZG93Ll9ncnVwb0xpZGVyLFxuICAgIGdydXBvTGlkZXI6IHdpbmRvdy5fZ3J1cG9MaWRlcixcbiAgICBpc0RyYWdnaW5nOiB3aW5kb3cuX2lzRHJhZ2dpbmcsXG4gICAgc2tpcEluZGl2aWR1YWxFbmRTaXplOiB3aW5kb3cuX3NraXBJbmRpdmlkdWFsRW5kID8gd2luZG93Ll9za2lwSW5kaXZpZHVhbEVuZC5zaXplIDogbnVsbCxcbiAgICBza2lwVW50aWw6IHdpbmRvdy5fc2tpcFVudGlsLFxuICB9KTtcblxuXG4gIC8vIFNvbG8gcHJvY2VzYSBlbCBsw61kZXJcbiAgaWYgKHdpbmRvdy5fZ3J1cG9MaWRlciAmJiBvYmouaWQgPT09IHdpbmRvdy5fZ3J1cG9MaWRlcikge1xuICAgIGRsb2coXCLwn5GRIFtEUkFHIEdSVVBBTF0gUHJvY2VzYW5kbyBjb21vIGzDrWRlci4uLlwiKTtcblxuICAgIGNvbnN0IHN0YWdlID0gZS50YXJnZXQuZ2V0U3RhZ2UoKTtcbiAgICBjb25zdCBkZWx0YURhdGEgPSB3aW5kb3cuX2RyYWdJbmljaWFsID8gY2FsY3VsYXJEZWx0YUdydXBhbChzdGFnZSkgOiBudWxsO1xuXG4gICAgaWYgKGRlbHRhRGF0YSAmJiB3aW5kb3cuX2RyYWdJbmljaWFsKSB7XG4gICAgICBpZiAod2luZG93Ll9ncm91cFByZXZpZXdSYWYpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUod2luZG93Ll9ncm91cFByZXZpZXdSYWYpO1xuICAgICAgICB3aW5kb3cuX2dyb3VwUHJldmlld1JhZiA9IG51bGw7XG4gICAgICB9XG4gICAgICB3aW5kb3cuX2dyb3VwUHJldmlld0xhc3REZWx0YSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVksIHNvdXJjZSB9ID0gZGVsdGFEYXRhO1xuICAgICAgZGxvZyhcIvCfk48gW0RSQUcgR1JVUEFMXSBEZWx0YSBjYWxjdWxhZG86XCIsIHsgZGVsdGFYLCBkZWx0YVksIHNvdXJjZSB9KTtcblxuICAgICAgY29uc3QgZWxlbWVudG9zR3J1cG8gPSBnZXRHcnVwb0VsZW1lbnRvcygpO1xuXG4gICAgICAvLyDwn5SlIEFQTElDQVIgRUwgREVMVEEgQSBDQURBIEVMRU1FTlRPIChpbmNsdXllbmRvIGFsIGzDrWRlcilcbiAgICAgIGVsZW1lbnRvc0dydXBvLmZvckVhY2goKGVsZW1lbnRJZCkgPT4ge1xuICAgICAgICBjb25zdCBvYmpldG8gPSB3aW5kb3cuX29iamV0b3NBY3R1YWxlcz8uZmluZChvID0+IG8uaWQgPT09IGVsZW1lbnRJZCk7XG4gICAgICAgIGlmICghb2JqZXRvKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcG9zSW5pY2lhbCA9IHdpbmRvdy5fZHJhZ0luaWNpYWxbZWxlbWVudElkXTtcbiAgICAgICAgaWYgKCFwb3NJbmljaWFsKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbnVldmFYID0gcG9zSW5pY2lhbC54ICsgZGVsdGFYO1xuICAgICAgICBjb25zdCBudWV2YVkgPSBwb3NJbmljaWFsLnkgKyBkZWx0YVk7XG5cbiAgICAgICAgZGxvZyhg8J+RpSBbRFJBRyBHUlVQQUxdIEVsZW1lbnRvICR7ZWxlbWVudElkfTpgLCB7XG4gICAgICAgICAgcG9zSW5pY2lhbCxcbiAgICAgICAgICBkZWx0YTogeyBkZWx0YVgsIGRlbHRhWSB9LFxuICAgICAgICAgIG51ZXZhUG9zOiB7IHg6IG51ZXZhWCwgeTogbnVldmFZIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHdpbmRvdy5fZWxlbWVudFJlZnM/LltlbGVtZW50SWRdO1xuICAgICAgICBjb25zdCB7IG51ZXZhU2VjY2lvbiB9ID0gZGV0ZXJtaW5hck51ZXZhU2VjY2lvbihcbiAgICAgICAgICBudWV2YVksXG4gICAgICAgICAgb2JqZXRvLnNlY2Npb25JZCxcbiAgICAgICAgICB3aW5kb3cuX3NlY2Npb25lc09yZGVuYWRhcyB8fCBbXVxuICAgICAgICApO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZT8uc2V0QXR0ciAmJiBub2RlLnNldEF0dHIoXCJfbXV0ZU5leHRFbmRcIiwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggeyB9XG5cbiAgICAgICAgY29uc3QgY2FtYmlvcyA9IHtcbiAgICAgICAgICB4OiBudWV2YVgsXG4gICAgICAgICAgeTogbnVldmFZLFxuICAgICAgICAgIC4uLihudWV2YVNlY2Npb24gPyB7IHNlY2Npb25JZDogbnVldmFTZWNjaW9uIH0gOiB7fSksXG4gICAgICAgICAgZmluYWxpem9EcmFnOiB0cnVlLFxuICAgICAgICAgIGNhdXNhOiBcImRyYWctZ3J1cGFsXCJcbiAgICAgICAgfTtcblxuICAgICAgICBvbkNoYW5nZShlbGVtZW50SWQsIGNhbWJpb3MpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR3YXJuKFwi4pqg77iPIFtEUkFHIEdSVVBBTF0gTm8gc2UgcHVkbyBjYWxjdWxhciBkZWx0YSBmaW5hbCBkZWwgZ3J1cG9cIik7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHdpbmRvdy5fc2tpcFVudGlsID0gcGVyZm9ybWFuY2Uubm93KCkgKyA0MDA7XG5cbiAgICBjb25zdCBzZWxlY2Npb24gPSBnZXRHcnVwb0VsZW1lbnRvcygpO1xuICAgIHNlbGVjY2lvbi5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgY29uc3QgZWxOb2RlID0gd2luZG93Ll9lbGVtZW50UmVmcz8uW2lkXTtcbiAgICAgIGlmICghZWxOb2RlKSByZXR1cm47XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGVsTm9kZS5kcmFnZ2FibGUoKTtcbiAgICAgICAgICBlbE5vZGUuZHJhZ2dhYmxlKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGFmdGVyID0gZWxOb2RlLmRyYWdnYWJsZSgpO1xuICAgICAgICAgIGRsb2coXCLwn6epIFtEUkFHIEdSVVBBTF0gcmVzdG9yZSBkcmFnZ2FibGVcIiwgeyBpZCwgYmVmb3JlLCBhZnRlciB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZHdhcm4oXCLinYwgW0RSQUcgR1JVUEFMXSByZXN0b3JlIGRyYWdnYWJsZSBlcnJvclwiLCB7IGlkLCBlcnIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDI0KTtcbiAgICB9KTtcblxuXG4gICAgd2luZG93Ll9ncnVwb0xpZGVyID0gbnVsbDtcbiAgICB3aW5kb3cuX2dydXBvRWxlbWVudG9zID0gbnVsbDtcbiAgICB3aW5kb3cuX2dydXBvU2VndWlkb3JlcyA9IG51bGw7XG4gICAgd2luZG93Ll9kcmFnU3RhcnRQb3MgPSBudWxsO1xuICAgIHdpbmRvdy5fZHJhZ0luaWNpYWwgPSBudWxsO1xuXG4gICAgLy8g8J+UpSBSRVNFVEVBUiBDVVJTT1IgQUwgRklOQUxJWkFSIERSQUcgR1JVUEFMXG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgfSBjYXRjaCB7IH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93Ll9za2lwSW5kaXZpZHVhbEVuZCA9IG51bGw7XG4gICAgICB3aW5kb3cuX3NraXBVbnRpbCA9IDA7XG4gICAgfSwgNDUwKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4geyBoYXNEcmFnZ2VkLmN1cnJlbnQgPSBmYWxzZTsgfSwgNDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU2VndWlkb3Jlc1xuICBpZiAod2luZG93Ll9ncnVwb0xpZGVyKSB7XG4gICAgY29uc3Qgc2VsZWNjaW9uID0gd2luZG93Ll9lbGVtZW50b3NTZWxlY2Npb25hZG9zIHx8IFtdO1xuICAgIGlmIChzZWxlY2Npb24uaW5jbHVkZXMob2JqLmlkKSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGhhc0RyYWdnZWQuY3VycmVudCA9IGZhbHNlOyB9LCA0MCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuXG4iXSwibmFtZXMiOlsiZGV0ZXJtaW5hck51ZXZhU2VjY2lvbiIsImlzRHJhZ0dydXBhbERlYnVnRW5hYmxlZCIsIndpbmRvdyIsIl9fREJHX0RSQUdfR1JVUEFMIiwiZGxvZyIsImFyZ3MiLCJjb25zb2xlIiwibG9nIiwiZHdhcm4iLCJ3YXJuIiwiZ2V0R3J1cG9FbGVtZW50b3MiLCJBcnJheSIsImlzQXJyYXkiLCJfZ3J1cG9FbGVtZW50b3MiLCJsZW5ndGgiLCJfZWxlbWVudG9zU2VsZWNjaW9uYWRvcyIsImNhbGN1bGFyRGVsdGFHcnVwYWwiLCJzdGFnZSIsImxlYWRlcklkIiwiX2dydXBvTGlkZXIiLCJkcmFnSW5pY2lhbCIsIl9kcmFnSW5pY2lhbCIsInBvc0luaWNpYWxMaWRlciIsImxlYWRlck5vZGUiLCJfZWxlbWVudFJlZnMiLCJ4IiwieSIsImRlbHRhWCIsImRlbHRhWSIsInNvdXJjZSIsImN1cnJlbnRQb3MiLCJnZXRQb2ludGVyUG9zaXRpb24iLCJzdGFydFBvcyIsIl9kcmFnU3RhcnRQb3MiLCJhcHBseVByZXZpZXdEcmFnR3J1cGFsIiwibGFzdCIsIl9ncm91cFByZXZpZXdMYXN0RGVsdGEiLCJNYXRoIiwiYWJzIiwic2VndWlkb3JlcyIsIl9ncnVwb1NlZ3VpZG9yZXMiLCJmaWx0ZXIiLCJpZCIsInN5bmNBdHRhY2hlZFRleHROb2RlIiwiZWxlbWVudElkIiwidGV4dE5vZGUiLCJwb3NpdGlvbiIsImZvckVhY2giLCJub2RlIiwicG9zSW5pY2lhbCIsIm5leHRYIiwibmV4dFkiLCJfZ3JvdXBQcmV2aWV3UmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYmF0Y2hEcmF3Iiwic3RhcnREcmFnR3J1cGFsTGlkZXIiLCJlIiwib2JqIiwidGlwbyIsImZpZ3VyYSIsInNlbGVjY2lvbiIsImluY2x1ZGVzIiwidGFyZ2V0IiwiZ2V0U3RhZ2UiLCJob3ZlckNvdW50QmVmb3JlU3RhcnQiLCJmaW5kIiwibGVhZGVyQ2FuZGlkYXRlIiwic2VsZWNjaW9uU2l6ZSIsIndpbmRvd0lzRHJhZ2dpbmciLCJfaXNEcmFnZ2luZyIsImdydXBvTGlkZXIiLCJlbGVtZW50b3NEZXRhbGxhZG9zIiwibWFwIiwib2JqZXRvIiwiX29iamV0b3NBY3R1YWxlcyIsIm8iLCJub2RlRXhpc3RzIiwibm9kZURyYWdnYWJsZSIsImRyYWdnYWJsZSIsImhheUxpbmVhcyIsInNvbWUiLCJkcmFnZ2FibGVCZWZvcmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9za2lwSW5kaXZpZHVhbEVuZCIsIlNldCIsIl9za2lwVW50aWwiLCJkb2N1bWVudCIsImJvZHkiLCJzdHlsZSIsImN1cnNvciIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsImhvdmVyQ291bnRBZnRlckdsb2JhbFN0YXJ0IiwibGVhZGVyIiwiaG92ZXJDb3VudFJhZiIsImVzTGlkZXIiLCJvYmpldG9UeXBlIiwiZXJyIiwiZXJyb3IiLCJ5QWJzSW5pIiwiaWR4IiwiX3NlY2Npb25lc09yZGVuYWRhcyIsImZpbmRJbmRleCIsInMiLCJzZWNjaW9uSWQiLCJvZmZzZXRZIiwic2xpY2UiLCJyZWR1Y2UiLCJzdW0iLCJhbHR1cmEiLCJvYmpJZCIsImlzRHJhZ2dpbmciLCJza2lwSW5kaXZpZHVhbEVuZFNpemUiLCJzaXplIiwic2tpcFVudGlsIiwiZHJhZ1N0YXJ0UG9zIiwicHJldmlld0RyYWdHcnVwYWwiLCJvbkNoYW5nZSIsImRlbHRhRGF0YSIsImVuZERyYWdHcnVwYWwiLCJoYXNEcmFnZ2VkIiwic2V0SXNEcmFnZ2luZyIsImVsZW1lbnRvc0dydXBvIiwibnVldmFYIiwibnVldmFZIiwiZGVsdGEiLCJudWV2YVBvcyIsIm51ZXZhU2VjY2lvbiIsInNldEF0dHIiLCJjYW1iaW9zIiwiZmluYWxpem9EcmFnIiwiY2F1c2EiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVsTm9kZSIsInNldFRpbWVvdXQiLCJiZWZvcmUiLCJhZnRlciIsImN1cnJlbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/drag/dragGrupal.js\n"));

/***/ })

});