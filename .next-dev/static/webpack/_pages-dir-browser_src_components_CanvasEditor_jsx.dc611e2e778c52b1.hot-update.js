"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_CanvasEditor_jsx",{

/***/ "(pages-dir-browser)/./src/components/SelectionBounds.jsx":
/*!********************************************!*\
  !*** ./src/components/SelectionBounds.jsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectionBounds)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_konva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-konva */ \"(pages-dir-browser)/./node_modules/react-konva/es/ReactKonva.js\");\n// SelectionBounds.jsx\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst DEBUG_SELECTION_BOUNDS = false;\nconst sbLog = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!DEBUG_SELECTION_BOUNDS) return;\n    console.log(\"[SB]\", ...args);\n};\nconst slog = sbLog;\nconst TRDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!window.__DBG_TR) return;\n    console.log(\"[TRDBG]\", ...args);\n};\n_c = TRDBG;\nconst TXTDBG = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n    if (!window.__DBG_TEXT_RESIZE) return;\n    console.log(\"[TEXT-TR]\", ...args);\n};\n_c1 = TXTDBG;\nfunction rectFromNodes(nodes) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for (const n of nodes){\n        if (!(n === null || n === void 0 ? void 0 : n.getClientRect)) continue;\n        const r = n.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        minX = Math.min(minX, r.x);\n        minY = Math.min(minY, r.y);\n        maxX = Math.max(maxX, r.x + r.width);\n        maxY = Math.max(maxY, r.y + r.height);\n    }\n    if (minX === Infinity) return null;\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getCountdownScaledSize(node) {\n    try {\n        var _node_findOne;\n        const hitbox = node === null || node === void 0 ? void 0 : (_node_findOne = node.findOne) === null || _node_findOne === void 0 ? void 0 : _node_findOne.call(node, \".countdown-hitbox\");\n        const baseW = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.width) === \"function\" ? hitbox.width() : NaN;\n        const baseH = typeof (hitbox === null || hitbox === void 0 ? void 0 : hitbox.height) === \"function\" ? hitbox.height() : NaN;\n        const sx = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() || 1 : 1);\n        const sy = Math.abs(typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() || 1 : 1);\n        if (Number.isFinite(baseW) && Number.isFinite(baseH) && baseW > 0 && baseH > 0) {\n            return {\n                width: Math.abs(baseW * sx),\n                height: Math.abs(baseH * sy)\n            };\n        }\n    } catch (e) {}\n    try {\n        const r = node.getClientRect({\n            skipTransform: false,\n            skipShadow: true,\n            skipStroke: true\n        });\n        return {\n            width: Math.abs(r.width),\n            height: Math.abs(r.height)\n        };\n    } catch (e) {}\n    return {\n        width: 100,\n        height: 50\n    };\n}\n// ðŸŽ¨ Componente para mostrar bounds sin transformer (lÃ­neas, etc.)\nconst BoundsIndicator = (param)=>{\n    let { selectedElements, elementRefs, objetos } = param;\n    _s();\n    const [forceUpdate, setForceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"BoundsIndicator.useEffect\": ()=>{\n            var _elementRefs_current, _firstRef_getStage;\n            const firstRef = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[selectedElements[0]];\n            const stage = firstRef === null || firstRef === void 0 ? void 0 : (_firstRef_getStage = firstRef.getStage) === null || _firstRef_getStage === void 0 ? void 0 : _firstRef_getStage.call(firstRef);\n            if (!stage) return;\n            const handleDragMove = {\n                \"BoundsIndicator.useEffect.handleDragMove\": ()=>{\n                    setForceUpdate({\n                        \"BoundsIndicator.useEffect.handleDragMove\": (p)=>p + 1\n                    }[\"BoundsIndicator.useEffect.handleDragMove\"]);\n                }\n            }[\"BoundsIndicator.useEffect.handleDragMove\"];\n            stage.on(\"dragmove\", handleDragMove);\n            return ({\n                \"BoundsIndicator.useEffect\": ()=>{\n                    stage.off(\"dragmove\", handleDragMove);\n                }\n            })[\"BoundsIndicator.useEffect\"];\n        }\n    }[\"BoundsIndicator.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    const elementosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    if (elementosData.length === 0) {\n        return null;\n    }\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    elementosData.forEach((obj)=>{\n        const node = elementRefs.current[obj.id];\n        if (!node) return;\n        try {\n            if (obj.tipo === \"forma\" && obj.figura === \"line\") {\n                const points = obj.points || [\n                    0,\n                    0,\n                    100,\n                    0\n                ];\n                const cleanPoints = [\n                    parseFloat(points[0]) || 0,\n                    parseFloat(points[1]) || 0,\n                    parseFloat(points[2]) || 100,\n                    parseFloat(points[3]) || 0\n                ];\n                const realX = node.x();\n                const realY = node.y();\n                const x1 = realX + cleanPoints[0];\n                const y1 = realY + cleanPoints[1];\n                const x2 = realX + cleanPoints[2];\n                const y2 = realY + cleanPoints[3];\n                const linePadding = 5;\n                minX = Math.min(minX, x1 - linePadding, x2 - linePadding);\n                minY = Math.min(minY, y1 - linePadding, y2 - linePadding);\n                maxX = Math.max(maxX, x1 + linePadding, x2 + linePadding);\n                maxY = Math.max(maxY, y1 + linePadding, y2 + linePadding);\n            } else {\n                var _node_scaleX, _node_scaleY;\n                const box = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                const r = box;\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = node === null || node === void 0 ? void 0 : (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = node === null || node === void 0 ? void 0 : (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                slog(\"[BI]\", \"id=\".concat(obj.id), \"tipo=\".concat(obj.tipo), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"rect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"));\n                const realX = box.x;\n                const realY = box.y;\n                let width = box.width;\n                let height = box.height;\n                if (obj.tipo === \"texto\" && node.getTextHeight) {\n                    const textHeight = node.getTextHeight();\n                    if (textHeight) {\n                        height = textHeight;\n                    }\n                }\n                minX = Math.min(minX, realX);\n                minY = Math.min(minY, realY);\n                maxX = Math.max(maxX, realX + width);\n                maxY = Math.max(maxY, realY + height);\n            }\n        } catch (error) {\n            const fallbackX = obj.x || 0;\n            const fallbackY = obj.y || 0;\n            const fallbackSize = 20;\n            minX = Math.min(minX, fallbackX);\n            minY = Math.min(minY, fallbackY);\n            maxX = Math.max(maxX, fallbackX + fallbackSize);\n            maxY = Math.max(maxY, fallbackY + fallbackSize);\n        }\n    });\n    if (minX === Infinity || maxX === -Infinity) {\n        const primerElemento = elementosData[0];\n        if (!primerElemento) return null;\n        minX = primerElemento.x || 0;\n        minY = primerElemento.y || 0;\n        maxX = minX + 100;\n        maxY = minY + 50;\n    }\n    const padding = 10;\n    const finalX = minX - padding;\n    const finalY = minY - padding;\n    const finalWidth = maxX - minX + padding * 2;\n    const finalHeight = maxY - minY + padding * 2;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Rect, {\n        name: \"ui\",\n        x: finalX,\n        y: finalY,\n        width: finalWidth,\n        height: finalHeight,\n        fill: \"transparent\",\n        stroke: \"#9333EA\",\n        strokeWidth: 1,\n        listening: false,\n        opacity: 0.7\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 188,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BoundsIndicator, \"X1gDcjpboC/BQr7oI4aemyzw8+o=\");\n_c2 = BoundsIndicator;\nfunction SelectionBounds(param) {\n    let { selectedElements, elementRefs, objetos, onTransform, isDragging } = param;\n    _s1();\n    const transformerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [transformTick, setTransformTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const lastNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const circleAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textTransformAnchorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const elementosSeleccionadosData = selectedElements.map((id)=>objetos.find((obj)=>obj.id === id)).filter(Boolean);\n    const primerElemento = elementosSeleccionadosData[0] || null;\n    const esTexto = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"texto\";\n    const esCountdown = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\";\n    const esGaleria = selectedElements.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"galeria\";\n    const lockAspectCountdown = selectedElements.length === 1 && esCountdown;\n    const transformerAnchorSize = 14;\n    const transformerRotateOffset = 24;\n    const transformerAnchorRadius = 999;\n    const esTriangulo = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"triangle\";\n    const hasGallery = elementosSeleccionadosData.some((o)=>o.tipo === \"galeria\");\n    const hayLineas = elementosSeleccionadosData.some((obj)=>obj.tipo === \"forma\" && obj.figura === \"line\");\n    const elementosTransformables = elementosSeleccionadosData.filter((obj)=>!(obj.tipo === \"forma\" && obj.figura === \"line\"));\n    const deberiaUsarTransformer = elementosTransformables.length > 0;\n    const selectedGeomKey = elementosSeleccionadosData.map((o)=>{\n        var _o_x, _o_y, _o_width, _o_height, _o_scaleX, _o_scaleY, _o_rotation, _o_chipWidth, _o_gap, _o_paddingX, _o_paddingY;\n        return [\n            o.id,\n            (_o_x = o.x) !== null && _o_x !== void 0 ? _o_x : 0,\n            (_o_y = o.y) !== null && _o_y !== void 0 ? _o_y : 0,\n            (_o_width = o.width) !== null && _o_width !== void 0 ? _o_width : \"\",\n            (_o_height = o.height) !== null && _o_height !== void 0 ? _o_height : \"\",\n            (_o_scaleX = o.scaleX) !== null && _o_scaleX !== void 0 ? _o_scaleX : 1,\n            (_o_scaleY = o.scaleY) !== null && _o_scaleY !== void 0 ? _o_scaleY : 1,\n            (_o_rotation = o.rotation) !== null && _o_rotation !== void 0 ? _o_rotation : 0,\n            (_o_chipWidth = o.chipWidth) !== null && _o_chipWidth !== void 0 ? _o_chipWidth : \"\",\n            (_o_gap = o.gap) !== null && _o_gap !== void 0 ? _o_gap : \"\",\n            (_o_paddingX = o.paddingX) !== null && _o_paddingX !== void 0 ? _o_paddingX : \"\",\n            (_o_paddingY = o.paddingY) !== null && _o_paddingY !== void 0 ? _o_paddingY : \"\"\n        ].join(\":\");\n    }).join(\"|\");\n    const getTransformPose = (node)=>{\n        if (!node) return {\n            x: 0,\n            y: 0,\n            rotation: 0\n        };\n        if (esGaleria && typeof node.getParent === \"function\") {\n            const parent = node.getParent();\n            if (parent) {\n                return {\n                    x: typeof parent.x === \"function\" ? parent.x() : 0,\n                    y: typeof parent.y === \"function\" ? parent.y() : 0,\n                    rotation: typeof parent.rotation === \"function\" ? parent.rotation() || 0 : 0\n                };\n            }\n        }\n        return {\n            x: typeof node.x === \"function\" ? node.x() : 0,\n            y: typeof node.y === \"function\" ? node.y() : 0,\n            rotation: typeof node.rotation === \"function\" ? node.rotation() || 0 : 0\n        };\n    };\n    // ðŸ”¥ Efecto principal del Transformer (SIN retry / SIN flicker)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _window_editing, _tr_nodes, _tr_nodes1, _tr_getLayer;\n            const tr = transformerRef.current;\n            if (!tr) return;\n            const selKey = selectedElements.join(\",\");\n            TRDBG(\"EFFECT start\", {\n                selKey,\n                isDragging,\n                deberiaUsarTransformer,\n                hasGallery,\n                elementosTransformablesLen: elementosTransformables.length,\n                transformTick,\n                editingId: ((_window_editing = window.editing) === null || _window_editing === void 0 ? void 0 : _window_editing.id) || null\n            });\n            // Si no corresponde transformer, no hagas detach agresivo (evita flicker)\n            if (!deberiaUsarTransformer) {\n                TRDBG(\"EFFECT exit: no transformer or gallery\", {\n                    selKey\n                });\n                return;\n            }\n            // Resolver nodes desde refs (fuente de verdad)\n            let nodosTransformables = elementosTransformables.map({\n                \"SelectionBounds.useEffect.nodosTransformables\": (o)=>{\n                    var _elementRefs_current;\n                    return (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id];\n                }\n            }[\"SelectionBounds.useEffect.nodosTransformables\"]).filter(Boolean);\n            // Single select: usar ref fresco SIEMPRE\n            if (selectedElements.length === 1) {\n                var _elementRefs_current;\n                const idSel = selectedElements[0];\n                const refNode = ((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel]) || null;\n                if (refNode && typeof refNode.getClientRect === \"function\") {\n                    if (esGaleria && typeof refNode.findOne === \"function\") {\n                        const galleryFrame = refNode.findOne(\".gallery-transform-frame\");\n                        if (galleryFrame && typeof galleryFrame.getClientRect === \"function\") {\n                            nodosTransformables = [\n                                galleryFrame\n                            ];\n                        } else {\n                            nodosTransformables = [\n                                refNode\n                            ];\n                        }\n                    } else {\n                        nodosTransformables = [\n                            refNode\n                        ];\n                    }\n                }\n            }\n            // Si aÃºn no hay nodos (imagen cargando, etc.), NO despegar (evita parpadeo)\n            if (nodosTransformables.length === 0) {\n                TRDBG(\"EFFECT exit: no nodes yet\", {\n                    selKey,\n                    wantedIds: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>o.id\n                    }[\"SelectionBounds.useEffect\"]),\n                    refsPresent: elementosTransformables.map({\n                        \"SelectionBounds.useEffect\": (o)=>{\n                            var _elementRefs_current;\n                            return !!((_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[o.id]);\n                        }\n                    }[\"SelectionBounds.useEffect\"])\n                });\n                return;\n            }\n            // Attach estable\n            TRDBG(\"ATTACH try\", {\n                selKey,\n                nodesCount: nodosTransformables.length,\n                nodeIds: nodosTransformables.map({\n                    \"SelectionBounds.useEffect\": (n)=>{\n                        var _n_attrs;\n                        return typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id;\n                    }\n                }[\"SelectionBounds.useEffect\"])\n            });\n            tr.nodes(nodosTransformables);\n            TRDBG(\"ATTACH done\", {\n                selKey,\n                trNodesCount: ((_tr_nodes1 = tr.nodes) === null || _tr_nodes1 === void 0 ? void 0 : (_tr_nodes = _tr_nodes1.call(tr)) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.length) || 0\n            });\n            try {\n                var _tr_forceUpdate;\n                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n            } catch (e) {}\n            (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        // Dependencias mÃ­nimas reales\n        selectedElements.join(\",\"),\n        deberiaUsarTransformer,\n        hasGallery,\n        elementosTransformables.length,\n        selectedGeomKey,\n        transformTick,\n        elementRefs\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            const handler = {\n                \"SelectionBounds.useEffect.handler\": (e)=>{\n                    var _e_detail;\n                    const id = e === null || e === void 0 ? void 0 : (_e_detail = e.detail) === null || _e_detail === void 0 ? void 0 : _e_detail.id;\n                    if (!id) return;\n                    TRDBG(\"REF event\", {\n                        id,\n                        isSelected: selectedElements.includes(id),\n                        selKey: selectedElements.join(\",\")\n                    });\n                    if (!selectedElements.includes(id)) return;\n                    setTransformTick({\n                        \"SelectionBounds.useEffect.handler\": (t)=>t + 1\n                    }[\"SelectionBounds.useEffect.handler\"]);\n                }\n            }[\"SelectionBounds.useEffect.handler\"];\n            window.addEventListener(\"element-ref-registrado\", handler);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>window.removeEventListener(\"element-ref-registrado\", handler)\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\")\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionBounds.useEffect\": ()=>{\n            var _elementRefs_current, _firstNode_getStage;\n            const firstId = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n            if (!firstId) return;\n            const firstNode = (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[firstId];\n            const stage = firstNode === null || firstNode === void 0 ? void 0 : (_firstNode_getStage = firstNode.getStage) === null || _firstNode_getStage === void 0 ? void 0 : _firstNode_getStage.call(firstNode);\n            if (!stage) return;\n            let rafId = null;\n            const syncTransformer = {\n                \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                    if (rafId != null) return;\n                    rafId = requestAnimationFrame({\n                        \"SelectionBounds.useEffect.syncTransformer\": ()=>{\n                            var _tr_getLayer_batchDraw, _tr_getLayer, _tr_getLayer1;\n                            rafId = null;\n                            const tr = transformerRef.current;\n                            if (!tr) return;\n                            try {\n                                var _tr_forceUpdate;\n                                (_tr_forceUpdate = tr.forceUpdate) === null || _tr_forceUpdate === void 0 ? void 0 : _tr_forceUpdate.call(tr);\n                            } catch (e) {}\n                            (_tr_getLayer1 = tr.getLayer) === null || _tr_getLayer1 === void 0 ? void 0 : (_tr_getLayer = _tr_getLayer1.call(tr)) === null || _tr_getLayer === void 0 ? void 0 : (_tr_getLayer_batchDraw = _tr_getLayer.batchDraw) === null || _tr_getLayer_batchDraw === void 0 ? void 0 : _tr_getLayer_batchDraw.call(_tr_getLayer);\n                        }\n                    }[\"SelectionBounds.useEffect.syncTransformer\"]);\n                }\n            }[\"SelectionBounds.useEffect.syncTransformer\"];\n            stage.on(\"dragmove\", syncTransformer);\n            stage.on(\"dragend\", syncTransformer);\n            return ({\n                \"SelectionBounds.useEffect\": ()=>{\n                    stage.off(\"dragmove\", syncTransformer);\n                    stage.off(\"dragend\", syncTransformer);\n                    if (rafId != null) cancelAnimationFrame(rafId);\n                }\n            })[\"SelectionBounds.useEffect\"];\n        }\n    }[\"SelectionBounds.useEffect\"], [\n        selectedElements.join(\",\"),\n        elementRefs\n    ]);\n    // ðŸ”¥ Render\n    if (selectedElements.length === 0) return null;\n    if (hayLineas && elementosTransformables.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 432,\n            columnNumber: 7\n        }, this);\n    }\n    if (hayLineas && elementosTransformables.length > 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BoundsIndicator, {\n            selectedElements: selectedElements,\n            elementRefs: elementRefs,\n            objetos: objetos\n        }, void 0, false, {\n            fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n            lineNumber: 442,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_konva__WEBPACK_IMPORTED_MODULE_2__.Transformer, {\n        name: \"ui\",\n        ref: transformerRef,\n        // ðŸ”µ borde siempre visible\n        borderEnabled: true,\n        borderStroke: \"#9333EA\",\n        borderStrokeWidth: 1,\n        // âŒ nodos y rotaciÃ³n OFF durante drag\n        enabledAnchors: isDragging ? [] : [\n            \"bottom-right\"\n        ],\n        rotateEnabled: !isDragging && !esGaleria,\n        anchorFill: \"#9333EA\",\n        anchorStroke: \"#ffffff\",\n        anchorStrokeWidth: 2.5,\n        anchorSize: transformerAnchorSize,\n        anchorCornerRadius: transformerAnchorRadius,\n        anchorShadowColor: \"rgba(147, 51, 234, 0.3)\",\n        anchorShadowBlur: 6,\n        anchorShadowOffset: {\n            x: 0,\n            y: 3\n        },\n        keepRatio: lockAspectCountdown || esGaleria,\n        centeredScaling: selectedElements.length === 1 && esTexto,\n        flipEnabled: false,\n        resizeEnabled: !isDragging,\n        rotationSnaps: [\n            0,\n            45,\n            90,\n            135,\n            180,\n            225,\n            270,\n            315\n        ],\n        rotateAnchorOffset: transformerRotateOffset,\n        rotationSnapTolerance: 5,\n        boundBoxFunc: (oldBox, newBox)=>{\n            const minSize = esTexto ? 20 : 10;\n            const maxSize = 800;\n            if (esGaleria) {\n                const rows = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.rows) || 1);\n                const cols = Math.max(1, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.cols) || 1);\n                const gap = Math.max(0, Number(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.gap) || 0);\n                const cellRatio = (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"4:3\" ? 3 / 4 : (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.ratio) === \"16:9\" ? 9 / 16 : 1;\n                const minGridWidth = gap * (cols - 1) + cols;\n                const nextWidth = Math.min(maxSize, Math.max(minSize, minGridWidth, Math.abs(newBox.width)));\n                const cellW = Math.max(1, (nextWidth - gap * (cols - 1)) / cols);\n                const cellH = cellW * cellRatio;\n                const nextHeight = rows * cellH + gap * (rows - 1);\n                return {\n                    ...newBox,\n                    width: nextWidth,\n                    height: Math.max(minSize, nextHeight)\n                };\n            }\n            if (newBox.width < minSize || newBox.height < minSize) {\n                return oldBox;\n            }\n            if (lockAspectCountdown) {\n                const baseW = Math.max(1, oldBox.width);\n                const baseH = Math.max(1, oldBox.height);\n                const ratio = baseW / baseH;\n                const dw = Math.abs(newBox.width - oldBox.width) / baseW;\n                const dh = Math.abs(newBox.height - oldBox.height) / baseH;\n                let width = newBox.width;\n                let height = newBox.height;\n                if (dh > dw) {\n                    width = height * ratio;\n                } else {\n                    height = width / ratio;\n                }\n                return {\n                    ...newBox,\n                    width: Math.min(Math.max(width, minSize), maxSize),\n                    height: Math.min(Math.max(height, minSize), maxSize)\n                };\n            }\n            if (esTexto) {\n                const scaleX = newBox.width / oldBox.width;\n                const scaleY = newBox.height / oldBox.height;\n                const uniformScale = Math.min(scaleX, scaleY);\n                const newWidth = oldBox.width * uniformScale;\n                const newHeight = oldBox.height * uniformScale;\n                return {\n                    ...newBox,\n                    width: Math.min(Math.max(newWidth, minSize), maxSize),\n                    height: Math.min(Math.max(newHeight, minSize), maxSize)\n                };\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                const size = Math.max(newBox.width, newBox.height);\n                const finalSize = Math.min(size, maxSize);\n                return {\n                    ...newBox,\n                    width: finalSize,\n                    height: finalSize\n                };\n            }\n            if (esTriangulo) {\n                const safeOldW = Math.max(1, Math.abs(oldBox.width || minSize));\n                const safeOldH = Math.max(1, Math.abs(oldBox.height || minSize));\n                const scaleX = Math.abs(newBox.width) / safeOldW;\n                const scaleY = Math.abs(newBox.height) / safeOldH;\n                const uniformScale = Math.max(0.05, Math.min(scaleX, scaleY));\n                const width = Math.min(Math.max(safeOldW * uniformScale, minSize), maxSize);\n                const height = Math.min(Math.max(safeOldH * uniformScale, minSize), maxSize);\n                return {\n                    ...newBox,\n                    width,\n                    height\n                };\n            }\n            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"imagen\" || (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"icono\") {\n                const scaleX = newBox.width / oldBox.width;\n                const scaleY = newBox.height / oldBox.height;\n                const uniformScale = Math.min(scaleX, scaleY);\n                const newWidth = oldBox.width * uniformScale;\n                const newHeight = oldBox.height * uniformScale;\n                return {\n                    ...newBox,\n                    width: Math.min(Math.max(newWidth, minSize), maxSize),\n                    height: Math.min(Math.max(newHeight, minSize), maxSize)\n                };\n            }\n            return {\n                ...newBox,\n                width: Math.min(newBox.width, maxSize),\n                height: Math.min(newBox.height, maxSize)\n            };\n        },\n        onTransformStart: ()=>{\n            window._resizeData = {\n                isResizing: true\n            };\n            try {\n                var _tr_nodes, _n_attrs, _tr_getClientRect;\n                const tr = transformerRef.current;\n                const nodes = (tr === null || tr === void 0 ? void 0 : (_tr_nodes = tr.nodes) === null || _tr_nodes === void 0 ? void 0 : _tr_nodes.call(tr)) || [];\n                circleAnchorRef.current = null;\n                textTransformAnchorRef.current = null;\n                if (nodes.length === 1 && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"forma\" && (primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                    try {\n                        const r0 = nodes[0].getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        circleAnchorRef.current = {\n                            left: r0.x,\n                            top: r0.y\n                        };\n                    } catch (e) {}\n                }\n                if (nodes.length === 1 && esTexto) {\n                    const node = nodes[0];\n                    let centerX = null;\n                    let baseWidth = null;\n                    let baseHeight = null;\n                    let baseVisualWidth = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.x) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width)) {\n                            centerX = rect.x + rect.width / 2;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            baseWidth = rect.width;\n                            baseVisualWidth = rect.width;\n                        }\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.height) && rect.height > 0) {\n                            baseHeight = rect.height;\n                        }\n                    } catch (e) {}\n                    const safeBaseFontSize = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.fontSize) && primerElemento.fontSize > 0 ? primerElemento.fontSize : 24;\n                    textTransformAnchorRef.current = {\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : 0,\n                        centerX,\n                        baseWidth,\n                        baseHeight,\n                        baseFontSize: safeBaseFontSize,\n                        lastPreviewFontSize: safeBaseFontSize,\n                        lastPreviewCenterX: centerX,\n                        lastPreviewVisualWidth: baseVisualWidth,\n                        previewTick: 0\n                    };\n                    var _primerElemento_id;\n                    TXTDBG(\"start\", {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        baseFontSize: safeBaseFontSize,\n                        baseWidth,\n                        baseHeight,\n                        centerX,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        nodeScaleX: typeof (node === null || node === void 0 ? void 0 : node.scaleX) === \"function\" ? node.scaleX() : null,\n                        nodeScaleY: typeof (node === null || node === void 0 ? void 0 : node.scaleY) === \"function\" ? node.scaleY() : null\n                    });\n                }\n                const union = rectFromNodes(nodes);\n                const pad = typeof (tr === null || tr === void 0 ? void 0 : tr.padding) === \"function\" ? tr.padding() : 0;\n                const borderRect = union ? {\n                    x: union.x - pad,\n                    y: union.y - pad,\n                    width: union.width + pad * 2,\n                    height: union.height + pad * 2\n                } : null;\n                const n = nodes[0];\n                const id = n ? typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id : \"âˆ…\";\n                const trRect = tr === null || tr === void 0 ? void 0 : (_tr_getClientRect = tr.getClientRect) === null || _tr_getClientRect === void 0 ? void 0 : _tr_getClientRect.call(tr, {\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                slog(\"[TR] start\", \"id=\".concat(id), \"nodes=\".concat(nodes.length), union ? \"union(w=\".concat(union.width.toFixed(1), \",h=\").concat(union.height.toFixed(1), \")\") : \"union(null)\", borderRect ? \"border(w=\".concat(borderRect.width.toFixed(1), \",h=\").concat(borderRect.height.toFixed(1), \")\") : \"border(null)\", trRect ? \"trRect(w=\".concat(trRect.width.toFixed(1), \",h=\").concat(trRect.height.toFixed(1), \")\") : \"trRect(null)\", \"pad=\".concat(pad));\n            } catch (e) {}\n        },\n        onTransform: (e)=>{\n            if (!onTransform || !transformerRef.current) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            const node = nodes[0]; // âœ… nodo real (single select)\n            if (!node) return;\n            try {\n                var _node_attrs, _node_scaleX, _node_scaleY, _node_x, _node_y;\n                const pose = getTransformPose(node);\n                const transformData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isPreview: true\n                };\n                if (esTexto) {\n                    var _textTransformAnchorRef_current, _textTransformAnchorRef_current1;\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let liveRectWidth = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            liveRectWidth = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const effectiveScale = Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    transformData.fontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    if (textTransformAnchorRef.current) {\n                        const tick = Number(textTransformAnchorRef.current.previewTick || 0) + 1;\n                        textTransformAnchorRef.current.previewTick = tick;\n                        textTransformAnchorRef.current.lastPreviewFontSize = transformData.fontSize;\n                        if (Number.isFinite(liveRectWidth) && liveRectWidth > 0) {\n                            textTransformAnchorRef.current.lastPreviewVisualWidth = liveRectWidth;\n                        }\n                        if (tick <= 2 || tick % 5 === 0) {\n                            var _textTransformAnchorRef_current2;\n                            var _primerElemento_id, _textTransformAnchorRef_current_centerX;\n                            TXTDBG(\"preview\", {\n                                id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                                tick,\n                                scaleX,\n                                scaleY,\n                                avgScale,\n                                scaleFromRect,\n                                effectiveScale,\n                                baseFontSize,\n                                fontSize: transformData.fontSize,\n                                liveRectWidth,\n                                centerXTarget: (_textTransformAnchorRef_current_centerX = (_textTransformAnchorRef_current2 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current2 === void 0 ? void 0 : _textTransformAnchorRef_current2.centerX) !== null && _textTransformAnchorRef_current_centerX !== void 0 ? _textTransformAnchorRef_current_centerX : null,\n                                nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                                nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                            });\n                        }\n                    }\n                    transformData.scaleX = 1;\n                    transformData.scaleY = 1;\n                    if (Number.isFinite((_textTransformAnchorRef_current = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current === void 0 ? void 0 : _textTransformAnchorRef_current.y)) {\n                        transformData.y = textTransformAnchorRef.current.y;\n                        if (typeof node.y === \"function\") {\n                            node.y(textTransformAnchorRef.current.y);\n                        }\n                    }\n                    if (Number.isFinite((_textTransformAnchorRef_current1 = textTransformAnchorRef.current) === null || _textTransformAnchorRef_current1 === void 0 ? void 0 : _textTransformAnchorRef_current1.centerX)) {\n                        transformData.textCenterX = textTransformAnchorRef.current.centerX;\n                        if (textTransformAnchorRef.current) {\n                            textTransformAnchorRef.current.lastPreviewCenterX = textTransformAnchorRef.current.centerX;\n                        }\n                        try {\n                            const rect = node.getClientRect({\n                                skipTransform: false,\n                                skipShadow: true,\n                                skipStroke: true\n                            });\n                            const currentCenterX = Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.x) && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) ? rect.x + rect.width / 2 : null;\n                            const deltaX = Number.isFinite(currentCenterX) ? textTransformAnchorRef.current.centerX - currentCenterX : null;\n                            if (Number.isFinite(deltaX) && Math.abs(deltaX) > 0.01 && typeof node.x === \"function\") {\n                                var _primerElemento_id1;\n                                TXTDBG(\"preview-center-correction\", {\n                                    id: (_primerElemento_id1 = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id1 !== void 0 ? _primerElemento_id1 : null,\n                                    currentCenterX,\n                                    targetCenterX: textTransformAnchorRef.current.centerX,\n                                    deltaX\n                                });\n                                node.x(node.x() + deltaX);\n                            }\n                        } catch (e) {}\n                    }\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    transformData.scaleX = scaleX;\n                    transformData.scaleY = scaleY;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        const countdownSize = getCountdownScaledSize(node);\n                        transformData.width = countdownSize.width;\n                        transformData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        transformData.radius = Math.max(1, baseRadius * avgScale);\n                    } else {\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        transformData.width = Math.abs(originalWidth * scaleX);\n                        transformData.height = Math.abs(originalHeight * scaleY);\n                    }\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                        try {\n                            const liveRect = node.getClientRect({\n                                skipTransform: false,\n                                skipShadow: true,\n                                skipStroke: true\n                            });\n                            const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                            transformData.radius = diameter / 2;\n                            const anchor = circleAnchorRef.current;\n                            if (anchor) {\n                                transformData.x = anchor.left + transformData.radius;\n                                transformData.y = anchor.top + transformData.radius;\n                            } else {\n                                transformData.x = liveRect.x + transformData.radius;\n                                transformData.y = liveRect.y + transformData.radius;\n                            }\n                        } catch (e) {}\n                    }\n                }\n                onTransform(transformData);\n                // --- LOG COMPACTO (opcional) ---\n                const id = (typeof node.id === \"function\" ? node.id() : (_node_attrs = node.attrs) === null || _node_attrs === void 0 ? void 0 : _node_attrs.id) || \"âˆ…\";\n                var _node_scaleX1;\n                const sx = (_node_scaleX1 = (_node_scaleX = node.scaleX) === null || _node_scaleX === void 0 ? void 0 : _node_scaleX.call(node)) !== null && _node_scaleX1 !== void 0 ? _node_scaleX1 : 1;\n                var _node_scaleY1;\n                const sy = (_node_scaleY1 = (_node_scaleY = node.scaleY) === null || _node_scaleY === void 0 ? void 0 : _node_scaleY.call(node)) !== null && _node_scaleY1 !== void 0 ? _node_scaleY1 : 1;\n                const r = node.getClientRect({\n                    skipTransform: false,\n                    skipShadow: true,\n                    skipStroke: true\n                });\n                var _node_x1, _node_y1, _transformData_width, _transformData_height;\n                slog(\"[TR] live\", \"id=\".concat(id), \"tipo=\".concat((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) || \"âˆ…\"), \"sx=\".concat(sx.toFixed(3)), \"sy=\".concat(sy.toFixed(3)), \"x=\".concat(((_node_x1 = (_node_x = node.x) === null || _node_x === void 0 ? void 0 : _node_x.call(node)) !== null && _node_x1 !== void 0 ? _node_x1 : 0).toFixed(1)), \"y=\".concat(((_node_y1 = (_node_y = node.y) === null || _node_y === void 0 ? void 0 : _node_y.call(node)) !== null && _node_y1 !== void 0 ? _node_y1 : 0).toFixed(1)), \"nodeRect(w=\".concat(r.width.toFixed(1), \",h=\").concat(r.height.toFixed(1), \")\"), \"w=\".concat((_transformData_width = transformData.width) !== null && _transformData_width !== void 0 ? _transformData_width : \"âˆ…\"), \"h=\".concat((_transformData_height = transformData.height) !== null && _transformData_height !== void 0 ? _transformData_height : \"âˆ…\"));\n            } catch (error) {\n                console.warn(\"Error en onTransform:\", error);\n            }\n        },\n        onTransformEnd: (e)=>{\n            if (!transformerRef.current || !onTransform) return;\n            const tr = transformerRef.current;\n            const nodes = typeof tr.nodes === \"function\" ? tr.nodes() || [] : [];\n            // -------------------------\n            // MULTI-SELECCIÃ“N\n            // -------------------------\n            if (nodes.length > 1) {\n                try {\n                    var _tr_getLayer;\n                    const tScaleX = typeof tr.scaleX === \"function\" ? tr.scaleX() || 1 : 1;\n                    const tScaleY = typeof tr.scaleY === \"function\" ? tr.scaleY() || 1 : 1;\n                    const avg = (Math.abs(tScaleX) + Math.abs(tScaleY)) / 2;\n                    const updates = nodes.map((n)=>{\n                        let id = null;\n                        try {\n                            var _n_attrs;\n                            id = (typeof n.id === \"function\" ? n.id() : (_n_attrs = n.attrs) === null || _n_attrs === void 0 ? void 0 : _n_attrs.id) || null;\n                        } catch (e) {}\n                        if (!id) return null;\n                        const obj = (objetos || []).find((o)=>o.id === id);\n                        if (!obj) return null;\n                        const upd = {\n                            id,\n                            x: typeof n.x === \"function\" ? n.x() : obj.x,\n                            y: typeof n.y === \"function\" ? n.y() : obj.y,\n                            rotation: typeof n.rotation === \"function\" ? n.rotation() || 0 : obj.rotation || 0\n                        };\n                        if (obj.tipo === \"texto\") {\n                            const base = obj.fontSize || 24;\n                            upd.fontSize = Math.max(6, Math.round(base * avg));\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }\n                        if (obj.tipo === \"forma\" && obj.figura === \"circle\") {\n                            const baseR = obj.radius || 50;\n                            upd.radius = baseR * avg;\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }\n                        if (obj.tipo === \"forma\" && obj.figura === \"triangle\") {\n                            const baseR = obj.radius || 60;\n                            upd.radius = Math.max(1, baseR * avg);\n                            if (typeof n.scaleX === \"function\") {\n                                n.scaleX(1);\n                                n.scaleY(1);\n                            }\n                            return upd;\n                        }\n                        if (obj.tipo === \"countdown\") {\n                            const countdownSize = getCountdownScaledSize(n);\n                            upd.width = countdownSize.width;\n                            upd.height = countdownSize.height;\n                            return upd;\n                        }\n                        const baseW = obj.width != null ? obj.width : typeof n.width === \"function\" ? n.width() : 100;\n                        const baseH = obj.height != null ? obj.height : typeof n.height === \"function\" ? n.height() : 100;\n                        upd.width = Math.abs(baseW * tScaleX);\n                        upd.height = Math.abs(baseH * tScaleY);\n                        if (typeof n.scaleX === \"function\") {\n                            n.scaleX(1);\n                            n.scaleY(1);\n                        }\n                        return upd;\n                    }).filter(Boolean);\n                    onTransform({\n                        isFinal: true,\n                        batch: updates\n                    });\n                    if (typeof tr.scaleX === \"function\") {\n                        tr.scaleX(1);\n                        tr.scaleY(1);\n                    }\n                    (_tr_getLayer = tr.getLayer()) === null || _tr_getLayer === void 0 ? void 0 : _tr_getLayer.batchDraw();\n                    window._resizeData = {\n                        isResizing: false\n                    };\n                    setTimeout(()=>{\n                        window._resizeData = null;\n                    }, 100);\n                    return;\n                } catch (err) {\n                    console.warn(\"Error en onTransformEnd (multi):\", err);\n                    window._resizeData = null;\n                    return;\n                }\n            }\n            // -------------------------\n            // SINGLE-SELECCIÃ“N\n            // -------------------------\n            const node = nodes[0];\n            if (!node) return;\n            try {\n                const pose = getTransformPose(node);\n                const finalData = {\n                    x: pose.x,\n                    y: pose.y,\n                    rotation: pose.rotation,\n                    isFinal: true\n                };\n                let textPreviewEndSnapshot = null;\n                if (esTexto) {\n                    const originalFontSize = primerElemento.fontSize || 24;\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    const anchorData = textTransformAnchorRef.current || null;\n                    const baseFontSize = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseFontSize) && anchorData.baseFontSize > 0 ? anchorData.baseFontSize : originalFontSize;\n                    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                    let scaleFromRect = null;\n                    let visualWidthFromRect = null;\n                    try {\n                        const rect = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            visualWidthFromRect = rect.width;\n                        }\n                        const baseWidth = Number(anchorData === null || anchorData === void 0 ? void 0 : anchorData.baseWidth);\n                        if (Number.isFinite(baseWidth) && baseWidth > 0 && Number.isFinite(rect === null || rect === void 0 ? void 0 : rect.width) && rect.width > 0) {\n                            scaleFromRect = rect.width / baseWidth;\n                        }\n                    } catch (e) {}\n                    const effectiveScale = Number.isFinite(scaleFromRect) && scaleFromRect > 0 ? scaleFromRect : avgScale;\n                    const computedFontSize = Math.max(6, Number((baseFontSize * effectiveScale).toFixed(3)));\n                    finalData.fontSize = Math.max(6, Number(Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewFontSize) && anchorData.lastPreviewFontSize > 0 ? anchorData.lastPreviewFontSize : computedFontSize));\n                    finalData.scaleX = 1;\n                    finalData.scaleY = 1;\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.y)) {\n                        finalData.y = anchorData.y;\n                    }\n                    if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewCenterX)) {\n                        finalData.textCenterX = anchorData.lastPreviewCenterX;\n                    } else if (Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.centerX)) {\n                        finalData.textCenterX = anchorData.centerX;\n                    }\n                    const visualWidth = Number.isFinite(anchorData === null || anchorData === void 0 ? void 0 : anchorData.lastPreviewVisualWidth) && anchorData.lastPreviewVisualWidth > 0 ? anchorData.lastPreviewVisualWidth : visualWidthFromRect;\n                    if (Number.isFinite(visualWidth) && visualWidth > 0) {\n                        finalData.textVisualWidth = visualWidth;\n                    }\n                    var _primerElemento_id;\n                    textPreviewEndSnapshot = {\n                        id: (_primerElemento_id = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id !== void 0 ? _primerElemento_id : null,\n                        x: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        y: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null,\n                        scaleX,\n                        scaleY,\n                        fontSize: typeof (node === null || node === void 0 ? void 0 : node.fontSize) === \"function\" ? node.fontSize() : null,\n                        rectWidth: Number.isFinite(visualWidthFromRect) ? visualWidthFromRect : null,\n                        rectHeight: null\n                    };\n                    try {\n                        const rectForSnapshot = node.getClientRect({\n                            skipTransform: false,\n                            skipShadow: true,\n                            skipStroke: true\n                        });\n                        if (Number.isFinite(rectForSnapshot === null || rectForSnapshot === void 0 ? void 0 : rectForSnapshot.height)) {\n                            textPreviewEndSnapshot.rectHeight = rectForSnapshot.height;\n                        }\n                    } catch (e) {}\n                    var _primerElemento_id1, _finalData_textCenterX, _finalData_textVisualWidth;\n                    TXTDBG(\"end\", {\n                        id: (_primerElemento_id1 = primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.id) !== null && _primerElemento_id1 !== void 0 ? _primerElemento_id1 : null,\n                        scaleX,\n                        scaleY,\n                        avgScale,\n                        scaleFromRect,\n                        effectiveScale,\n                        computedFontSize,\n                        finalFontSize: finalData.fontSize,\n                        textCenterX: (_finalData_textCenterX = finalData.textCenterX) !== null && _finalData_textCenterX !== void 0 ? _finalData_textCenterX : null,\n                        textVisualWidth: (_finalData_textVisualWidth = finalData.textVisualWidth) !== null && _finalData_textVisualWidth !== void 0 ? _finalData_textVisualWidth : null,\n                        nodeRectWidth: visualWidthFromRect,\n                        nodeX: typeof (node === null || node === void 0 ? void 0 : node.x) === \"function\" ? node.x() : null,\n                        nodeY: typeof (node === null || node === void 0 ? void 0 : node.y) === \"function\" ? node.y() : null\n                    });\n                    // Para texto evitamos aplanar antes del commit en React,\n                    // asÃ­ no aparece un frame intermedio con tamaÃ±o \"saltado\".\n                    textTransformAnchorRef.current = null;\n                } else {\n                    const scaleX = typeof node.scaleX === \"function\" ? node.scaleX() : 1;\n                    const scaleY = typeof node.scaleY === \"function\" ? node.scaleY() : 1;\n                    if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.tipo) === \"countdown\") {\n                        // Countdown: persistir escala real para que el resultado final\n                        // sea exactamente el mismo que se ve al soltar.\n                        finalData.scaleX = scaleX;\n                        finalData.scaleY = scaleY;\n                        const countdownSize = getCountdownScaledSize(node);\n                        finalData.width = countdownSize.width;\n                        finalData.height = countdownSize.height;\n                    } else if (esTriangulo) {\n                        const baseRadius = Number.isFinite(primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.radius) ? primerElemento.radius : 60;\n                        const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        finalData.radius = Math.max(1, baseRadius * avgScale);\n                        try {\n                            var _node_getLayer;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (typeof node.radius === \"function\") node.radius(finalData.radius);\n                            (_node_getLayer = node.getLayer()) === null || _node_getLayer === void 0 ? void 0 : _node_getLayer.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escala de triÃ¡ngulo (sync):\", err);\n                        }\n                    } else {\n                        finalData.scaleX = 1;\n                        finalData.scaleY = 1;\n                        const originalWidth = primerElemento.width || 100;\n                        const originalHeight = primerElemento.height || 100;\n                        finalData.width = Math.abs(originalWidth * scaleX);\n                        finalData.height = Math.abs(originalHeight * scaleY);\n                        if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\") {\n                            try {\n                                const liveRect = node.getClientRect({\n                                    skipTransform: false,\n                                    skipShadow: true,\n                                    skipStroke: true\n                                });\n                                const diameter = Math.max(1, Math.max(liveRect.width, liveRect.height));\n                                finalData.radius = diameter / 2;\n                                const anchor = circleAnchorRef.current;\n                                if (anchor) {\n                                    finalData.x = anchor.left + finalData.radius;\n                                    finalData.y = anchor.top + finalData.radius;\n                                } else {\n                                    finalData.x = liveRect.x + finalData.radius;\n                                    finalData.y = liveRect.y + finalData.radius;\n                                }\n                            } catch (e) {}\n                        }\n                        // âœ… Aplanar escala INMEDIATO\n                        try {\n                            var _node_getLayer1;\n                            const fw = finalData.width;\n                            const fh = finalData.height;\n                            node.scaleX(1);\n                            node.scaleY(1);\n                            if (fw != null && typeof node.width === \"function\") node.width(fw);\n                            if (fh != null && typeof node.height === \"function\") node.height(fh);\n                            if ((primerElemento === null || primerElemento === void 0 ? void 0 : primerElemento.figura) === \"circle\" && finalData.radius != null && typeof node.radius === \"function\") {\n                                node.radius(finalData.radius);\n                            }\n                            (_node_getLayer1 = node.getLayer()) === null || _node_getLayer1 === void 0 ? void 0 : _node_getLayer1.batchDraw();\n                        } catch (err) {\n                            console.warn(\"Error aplanando escalas (sync):\", err);\n                        }\n                    }\n                }\n                onTransform(finalData);\n                circleAnchorRef.current = null;\n                // âœ… Reatachar 1 vez, con ref fresco, en el prÃ³ximo frame\n                try {\n                    const tr2 = transformerRef.current;\n                    if (!tr2) return;\n                    TRDBG(\"onTransformEnd -> schedule RAF reattach\", {\n                        selKey: selectedElements.join(\",\"),\n                        idSel: (selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0]) || null\n                    });\n                    requestAnimationFrame(()=>{\n                        var _elementRefs_current, _freshNode_getStage, _freshNode_getStage1;\n                        const idSel = selectedElements === null || selectedElements === void 0 ? void 0 : selectedElements[0];\n                        const freshNode = idSel ? (_elementRefs_current = elementRefs.current) === null || _elementRefs_current === void 0 ? void 0 : _elementRefs_current[idSel] : null;\n                        TRDBG(\"onTransformEnd RAF\", {\n                            idSel,\n                            hasFresh: !!freshNode,\n                            destroyed: !!(freshNode === null || freshNode === void 0 ? void 0 : freshNode._destroyed),\n                            hasStage: !!(freshNode === null || freshNode === void 0 ? void 0 : (_freshNode_getStage = freshNode.getStage) === null || _freshNode_getStage === void 0 ? void 0 : _freshNode_getStage.call(freshNode))\n                        });\n                        // Si el nodo no estÃ¡ listo, despegar y salir\n                        if (!freshNode || freshNode._destroyed || !((_freshNode_getStage1 = freshNode.getStage) === null || _freshNode_getStage1 === void 0 ? void 0 : _freshNode_getStage1.call(freshNode))) {\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            try {\n                                var _tr2_getLayer, _tr2_getLayer1;\n                                tr2.nodes([]);\n                                (_tr2_getLayer1 = tr2.getLayer) === null || _tr2_getLayer1 === void 0 ? void 0 : (_tr2_getLayer = _tr2_getLayer1.call(tr2)) === null || _tr2_getLayer === void 0 ? void 0 : _tr2_getLayer.batchDraw();\n                            } catch (e) {}\n                            return;\n                        }\n                        try {\n                            var _tr2_getLayer2, _tr2_getLayer3;\n                            TRDBG(\"onTransformEnd RAF -> DETACH nodes([])\", {\n                                idSel\n                            });\n                            tr2.nodes([\n                                freshNode\n                            ]);\n                            tr2.forceUpdate();\n                            (_tr2_getLayer3 = tr2.getLayer) === null || _tr2_getLayer3 === void 0 ? void 0 : (_tr2_getLayer2 = _tr2_getLayer3.call(tr2)) === null || _tr2_getLayer2 === void 0 ? void 0 : _tr2_getLayer2.batchDraw();\n                            if (textPreviewEndSnapshot && freshNode) {\n                                try {\n                                    const postRect = freshNode.getClientRect({\n                                        skipTransform: false,\n                                        skipShadow: true,\n                                        skipStroke: true\n                                    });\n                                    TXTDBG(\"post-commit:raf1\", {\n                                        id: idSel,\n                                        pre: textPreviewEndSnapshot,\n                                        post: {\n                                            x: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.x) === \"function\" ? freshNode.x() : null,\n                                            y: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.y) === \"function\" ? freshNode.y() : null,\n                                            scaleX: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleX) === \"function\" ? freshNode.scaleX() : null,\n                                            scaleY: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.scaleY) === \"function\" ? freshNode.scaleY() : null,\n                                            fontSize: typeof (freshNode === null || freshNode === void 0 ? void 0 : freshNode.fontSize) === \"function\" ? freshNode.fontSize() : null,\n                                            rectWidth: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) ? postRect.width : null,\n                                            rectHeight: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) ? postRect.height : null\n                                        },\n                                        delta: {\n                                            width: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.width) && Number.isFinite(textPreviewEndSnapshot.rectWidth) ? postRect.width - textPreviewEndSnapshot.rectWidth : null,\n                                            height: Number.isFinite(postRect === null || postRect === void 0 ? void 0 : postRect.height) && Number.isFinite(textPreviewEndSnapshot.rectHeight) ? postRect.height - textPreviewEndSnapshot.rectHeight : null\n                                        }\n                                    });\n                                } catch (e) {}\n                            }\n                        } catch (e) {}\n                    });\n                } catch (e) {}\n            } catch (error) {\n                console.warn(\"Error en onTransformEnd:\", error);\n                window._resizeData = null;\n            }\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Reservaeldia\\\\src\\\\components\\\\SelectionBounds.jsx\",\n        lineNumber: 451,\n        columnNumber: 5\n    }, this);\n}\n_s1(SelectionBounds, \"aL8Tv5tXgpPOq48zDABYVtqqs1c=\");\n_c3 = SelectionBounds;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"TRDBG\");\n$RefreshReg$(_c1, \"TXTDBG\");\n$RefreshReg$(_c2, \"BoundsIndicator\");\n$RefreshReg$(_c3, \"SelectionBounds\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NlbGVjdGlvbkJvdW5kcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsc0JBQXNCOzs7QUFDOEI7QUFDSjtBQUloRCxNQUFNSyx5QkFBeUI7QUFFL0IsTUFBTUMsUUFBUTtxQ0FBSUM7UUFBQUE7O0lBQ2hCLElBQUksQ0FBQ0Ysd0JBQXdCO0lBQzdCRyxRQUFRQyxHQUFHLENBQUMsV0FBV0Y7QUFDekI7QUFDQSxNQUFNRyxPQUFPSjtBQUViLE1BQU1LLFFBQVE7cUNBQUlKO1FBQUFBOztJQUNoQixJQUFJLENBQUNLLE9BQU9DLFFBQVEsRUFBRTtJQUN0QkwsUUFBUUMsR0FBRyxDQUFDLGNBQWNGO0FBQzVCO0tBSE1JO0FBS04sTUFBTUcsU0FBUztxQ0FBSVA7UUFBQUE7O0lBQ2pCLElBQUksS0FBNkIsRUFBRSxFQUFPO0lBQzFDLElBQUksQ0FBQ0ssT0FBT0csaUJBQWlCLEVBQUU7SUFDL0JQLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JGO0FBQzlCO01BSk1PO0FBT04sU0FBU0UsY0FBY0MsS0FBSztJQUMxQixJQUFJQyxPQUFPQyxVQUFVQyxPQUFPRCxVQUFVRSxPQUFPLENBQUNGLFVBQVVHLE9BQU8sQ0FBQ0g7SUFFaEUsS0FBSyxNQUFNSSxLQUFLTixNQUFPO1FBQ3JCLElBQUksRUFBQ00sY0FBQUEsd0JBQUFBLEVBQUdDLGFBQWEsR0FBRTtRQUN2QixNQUFNQyxJQUFJRixFQUFFQyxhQUFhLENBQUM7WUFBRUUsZUFBZTtZQUFPQyxZQUFZO1lBQU1DLFlBQVk7UUFBSztRQUNyRlYsT0FBT1csS0FBS0MsR0FBRyxDQUFDWixNQUFNTyxFQUFFTSxDQUFDO1FBQ3pCWCxPQUFPUyxLQUFLQyxHQUFHLENBQUNWLE1BQU1LLEVBQUVPLENBQUM7UUFDekJYLE9BQU9RLEtBQUtJLEdBQUcsQ0FBQ1osTUFBTUksRUFBRU0sQ0FBQyxHQUFHTixFQUFFUyxLQUFLO1FBQ25DWixPQUFPTyxLQUFLSSxH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QXVCSyxTQUFTLEdBQ2xEOzRDQUNOeFAsUUFDRWEsT0FBT0MsUUFBUSxDQUFDdVAscUJBQUFBLCtCQUFBQSxTQUFVclEsTUFBTSxLQUNoQ2EsT0FBT0MsUUFBUSxDQUFDcU8sdUJBQXVCTSxVQUFVLElBQzVDWSxTQUFTclEsTUFBTSxHQUFHbVAsdUJBQXVCTSxVQUFVLEdBQ3BEO3dDQUNSO29DQUNGO2dDQUNGLEVBQUUsVUFBTSxDQUFDOzRCQUNYO3dCQUNGLEVBQUUsVUFBTSxDQUFFO29CQUNaO2dCQUNGLEVBQUUsVUFBTSxDQUFFO1lBR1osRUFBRSxPQUFPbE0sT0FBTztnQkFDZGxGLFFBQVErUCxJQUFJLENBQUMsNEJBQTRCN0s7Z0JBQ3pDOUUsT0FBTzJNLFdBQVcsR0FBRztZQUN2QjtRQUNGOzs7Ozs7QUFJTjtJQW5rQ3dCN0c7TUFBQUEiLCJzb3VyY2VzIjpbIkM6XFxSZXNlcnZhZWxkaWFcXHNyY1xcY29tcG9uZW50c1xcU2VsZWN0aW9uQm91bmRzLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZWxlY3Rpb25Cb3VuZHMuanN4XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFRyYW5zZm9ybWVyLCBSZWN0IH0gZnJvbSBcInJlYWN0LWtvbnZhXCI7XG5cblxuXG5jb25zdCBERUJVR19TRUxFQ1RJT05fQk9VTkRTID0gZmFsc2U7XG5cbmNvbnN0IHNiTG9nID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFERUJVR19TRUxFQ1RJT05fQk9VTkRTKSByZXR1cm47XG4gIGNvbnNvbGUubG9nKFwiW1NCXVwiLCAuLi5hcmdzKTtcbn07XG5jb25zdCBzbG9nID0gc2JMb2c7XG5cbmNvbnN0IFRSREJHID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCF3aW5kb3cuX19EQkdfVFIpIHJldHVybjtcbiAgY29uc29sZS5sb2coXCJbVFJEQkddXCIsIC4uLmFyZ3MpO1xufTtcblxuY29uc3QgVFhUREJHID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgaWYgKCF3aW5kb3cuX19EQkdfVEVYVF9SRVNJWkUpIHJldHVybjtcbiAgY29uc29sZS5sb2coXCJbVEVYVC1UUl1cIiwgLi4uYXJncyk7XG59O1xuXG5cbmZ1bmN0aW9uIHJlY3RGcm9tTm9kZXMobm9kZXMpIHtcbiAgbGV0IG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciAoY29uc3QgbiBvZiBub2Rlcykge1xuICAgIGlmICghbj8uZ2V0Q2xpZW50UmVjdCkgY29udGludWU7XG4gICAgY29uc3QgciA9IG4uZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByLngpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCByLnkpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCByLnggKyByLndpZHRoKTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgci55ICsgci5oZWlnaHQpO1xuICB9XG5cbiAgaWYgKG1pblggPT09IEluZmluaXR5KSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHsgeDogbWluWCwgeTogbWluWSwgd2lkdGg6IG1heFggLSBtaW5YLCBoZWlnaHQ6IG1heFkgLSBtaW5ZIH07XG59XG5cbmZ1bmN0aW9uIGdldENvdW50ZG93blNjYWxlZFNpemUobm9kZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGhpdGJveCA9IG5vZGU/LmZpbmRPbmU/LihcIi5jb3VudGRvd24taGl0Ym94XCIpO1xuICAgIGNvbnN0IGJhc2VXID0gdHlwZW9mIGhpdGJveD8ud2lkdGggPT09IFwiZnVuY3Rpb25cIiA/IGhpdGJveC53aWR0aCgpIDogTmFOO1xuICAgIGNvbnN0IGJhc2VIID0gdHlwZW9mIGhpdGJveD8uaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIgPyBoaXRib3guaGVpZ2h0KCkgOiBOYU47XG4gICAgY29uc3Qgc3ggPSBNYXRoLmFicyh0eXBlb2Ygbm9kZT8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyAobm9kZS5zY2FsZVgoKSB8fCAxKSA6IDEpO1xuICAgIGNvbnN0IHN5ID0gTWF0aC5hYnModHlwZW9mIG5vZGU/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gKG5vZGUuc2NhbGVZKCkgfHwgMSkgOiAxKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYmFzZVcpICYmIE51bWJlci5pc0Zpbml0ZShiYXNlSCkgJiYgYmFzZVcgPiAwICYmIGJhc2VIID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGguYWJzKGJhc2VXICogc3gpLFxuICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKGJhc2VIICogc3kpLFxuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2gge31cblxuICB0cnkge1xuICAgIGNvbnN0IHIgPSBub2RlLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4geyB3aWR0aDogTWF0aC5hYnMoci53aWR0aCksIGhlaWdodDogTWF0aC5hYnMoci5oZWlnaHQpIH07XG4gIH0gY2F0Y2gge31cblxuICByZXR1cm4geyB3aWR0aDogMTAwLCBoZWlnaHQ6IDUwIH07XG59XG5cblxuLy8g8J+OqCBDb21wb25lbnRlIHBhcmEgbW9zdHJhciBib3VuZHMgc2luIHRyYW5zZm9ybWVyIChsw61uZWFzLCBldGMuKVxuY29uc3QgQm91bmRzSW5kaWNhdG9yID0gKHsgc2VsZWN0ZWRFbGVtZW50cywgZWxlbWVudFJlZnMsIG9iamV0b3MgfSkgPT4ge1xuICBjb25zdCBbZm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKDApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZmlyc3RSZWYgPSBlbGVtZW50UmVmcy5jdXJyZW50Py5bc2VsZWN0ZWRFbGVtZW50c1swXV07XG4gICAgY29uc3Qgc3RhZ2UgPSBmaXJzdFJlZj8uZ2V0U3RhZ2U/LigpO1xuICAgIGlmICghc3RhZ2UpIHJldHVybjtcblxuICAgIGNvbnN0IGhhbmRsZURyYWdNb3ZlID0gKCkgPT4ge1xuICAgICAgc2V0Rm9yY2VVcGRhdGUoKHApID0+IHAgKyAxKTtcbiAgICB9O1xuXG4gICAgc3RhZ2Uub24oXCJkcmFnbW92ZVwiLCBoYW5kbGVEcmFnTW92ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YWdlLm9mZihcImRyYWdtb3ZlXCIsIGhhbmRsZURyYWdNb3ZlKTtcbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRFbGVtZW50cy5qb2luKFwiLFwiKV0pO1xuXG4gIGNvbnN0IGVsZW1lbnRvc0RhdGEgPSBzZWxlY3RlZEVsZW1lbnRzXG4gICAgLm1hcCgoaWQpID0+IG9iamV0b3MuZmluZCgob2JqKSA9PiBvYmouaWQgPT09IGlkKSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIGlmIChlbGVtZW50b3NEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG1pblggPSBJbmZpbml0eSxcbiAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gIGVsZW1lbnRvc0RhdGEuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGVsZW1lbnRSZWZzLmN1cnJlbnRbb2JqLmlkXTtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBpZiAob2JqLnRpcG8gPT09IFwiZm9ybWFcIiAmJiBvYmouZmlndXJhID09PSBcImxpbmVcIikge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBvYmoucG9pbnRzIHx8IFswLCAwLCAxMDAsIDBdO1xuXG4gICAgICAgIGNvbnN0IGNsZWFuUG9pbnRzID0gW1xuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzBdKSB8fCAwLFxuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzFdKSB8fCAwLFxuICAgICAgICAgIHBhcnNlRmxvYXQocG9pbnRzWzJdKSB8fCAxMDAsXG4gICAgICAgICAgcGFyc2VGbG9hdChwb2ludHNbM10pIHx8IDAsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgcmVhbFggPSBub2RlLngoKTtcbiAgICAgICAgY29uc3QgcmVhbFkgPSBub2RlLnkoKTtcblxuICAgICAgICBjb25zdCB4MSA9IHJlYWxYICsgY2xlYW5Qb2ludHNbMF07XG4gICAgICAgIGNvbnN0IHkxID0gcmVhbFkgKyBjbGVhblBvaW50c1sxXTtcbiAgICAgICAgY29uc3QgeDIgPSByZWFsWCArIGNsZWFuUG9pbnRzWzJdO1xuICAgICAgICBjb25zdCB5MiA9IHJlYWxZICsgY2xlYW5Qb2ludHNbM107XG5cbiAgICAgICAgY29uc3QgbGluZVBhZGRpbmcgPSA1O1xuXG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4MSAtIGxpbmVQYWRkaW5nLCB4MiAtIGxpbmVQYWRkaW5nKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkxIC0gbGluZVBhZGRpbmcsIHkyIC0gbGluZVBhZGRpbmcpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeDEgKyBsaW5lUGFkZGluZywgeDIgKyBsaW5lUGFkZGluZyk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5MSArIGxpbmVQYWRkaW5nLCB5MiArIGxpbmVQYWRkaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJveCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCByID0gYm94O1xuICAgICAgICBjb25zdCBzeCA9IChub2RlPy5zY2FsZVg/LigpID8/IDEpO1xuICAgICAgICBjb25zdCBzeSA9IChub2RlPy5zY2FsZVk/LigpID8/IDEpO1xuICAgICAgICBzbG9nKFxuICAgICAgICAgIFwiW0JJXVwiLFxuICAgICAgICAgIGBpZD0ke29iai5pZH1gLFxuICAgICAgICAgIGB0aXBvPSR7b2JqLnRpcG99YCxcbiAgICAgICAgICBgc3g9JHtzeC50b0ZpeGVkKDMpfWAsXG4gICAgICAgICAgYHN5PSR7c3kudG9GaXhlZCgzKX1gLFxuICAgICAgICAgIGByZWN0KHc9JHtyLndpZHRoLnRvRml4ZWQoMSl9LGg9JHtyLmhlaWdodC50b0ZpeGVkKDEpfSlgXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVhbFggPSBib3gueDtcbiAgICAgICAgY29uc3QgcmVhbFkgPSBib3gueTtcbiAgICAgICAgbGV0IHdpZHRoID0gYm94LndpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gYm94LmhlaWdodDtcblxuICAgICAgICBpZiAob2JqLnRpcG8gPT09IFwidGV4dG9cIiAmJiBub2RlLmdldFRleHRIZWlnaHQpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gbm9kZS5nZXRUZXh0SGVpZ2h0KCk7XG4gICAgICAgICAgaWYgKHRleHRIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRleHRIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHJlYWxYKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHJlYWxZKTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHJlYWxYICsgd2lkdGgpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcmVhbFkgKyBoZWlnaHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBmYWxsYmFja1ggPSBvYmoueCB8fCAwO1xuICAgICAgY29uc3QgZmFsbGJhY2tZID0gb2JqLnkgfHwgMDtcbiAgICAgIGNvbnN0IGZhbGxiYWNrU2l6ZSA9IDIwO1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgZmFsbGJhY2tYKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBmYWxsYmFja1kpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGZhbGxiYWNrWCArIGZhbGxiYWNrU2l6ZSk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgZmFsbGJhY2tZICsgZmFsbGJhY2tTaXplKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChtaW5YID09PSBJbmZpbml0eSB8fCBtYXhYID09PSAtSW5maW5pdHkpIHtcbiAgICBjb25zdCBwcmltZXJFbGVtZW50byA9IGVsZW1lbnRvc0RhdGFbMF07XG4gICAgaWYgKCFwcmltZXJFbGVtZW50bykgcmV0dXJuIG51bGw7XG4gICAgbWluWCA9IHByaW1lckVsZW1lbnRvLnggfHwgMDtcbiAgICBtaW5ZID0gcHJpbWVyRWxlbWVudG8ueSB8fCAwO1xuICAgIG1heFggPSBtaW5YICsgMTAwO1xuICAgIG1heFkgPSBtaW5ZICsgNTA7XG4gIH1cblxuICBjb25zdCBwYWRkaW5nID0gMTA7XG4gIGNvbnN0IGZpbmFsWCA9IG1pblggLSBwYWRkaW5nO1xuICBjb25zdCBmaW5hbFkgPSBtaW5ZIC0gcGFkZGluZztcbiAgY29uc3QgZmluYWxXaWR0aCA9IG1heFggLSBtaW5YICsgcGFkZGluZyAqIDI7XG4gIGNvbnN0IGZpbmFsSGVpZ2h0ID0gbWF4WSAtIG1pblkgKyBwYWRkaW5nICogMjtcblxuICByZXR1cm4gKFxuICAgIDxSZWN0XG4gICAgICBuYW1lPVwidWlcIlxuICAgICAgeD17ZmluYWxYfVxuICAgICAgeT17ZmluYWxZfVxuICAgICAgd2lkdGg9e2ZpbmFsV2lkdGh9XG4gICAgICBoZWlnaHQ9e2ZpbmFsSGVpZ2h0fVxuICAgICAgZmlsbD1cInRyYW5zcGFyZW50XCJcbiAgICAgIHN0cm9rZT1cIiM5MzMzRUFcIlxuICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICBsaXN0ZW5pbmc9e2ZhbHNlfVxuICAgICAgb3BhY2l0eT17MC43fVxuICAgIC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWxlY3Rpb25Cb3VuZHMoe1xuICBzZWxlY3RlZEVsZW1lbnRzLFxuICBlbGVtZW50UmVmcyxcbiAgb2JqZXRvcyxcbiAgb25UcmFuc2Zvcm0sXG4gIGlzRHJhZ2dpbmcsXG59KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbdHJhbnNmb3JtVGljaywgc2V0VHJhbnNmb3JtVGlja10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgbGFzdE5vZGVzUmVmID0gdXNlUmVmKFtdKTtcbiAgY29uc3QgY2lyY2xlQW5jaG9yUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YSA9IHNlbGVjdGVkRWxlbWVudHNcbiAgICAubWFwKChpZCkgPT4gb2JqZXRvcy5maW5kKChvYmopID0+IG9iai5pZCA9PT0gaWQpKVxuICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgY29uc3QgcHJpbWVyRWxlbWVudG8gPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YVswXSB8fCBudWxsO1xuICBjb25zdCBlc1RleHRvID0gcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwidGV4dG9cIjtcbiAgY29uc3QgZXNDb3VudGRvd24gPSBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJjb3VudGRvd25cIjtcbiAgY29uc3QgZXNHYWxlcmlhID0gc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZ2FsZXJpYVwiO1xuICBjb25zdCBsb2NrQXNwZWN0Q291bnRkb3duID0gc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZXNDb3VudGRvd247XG4gIGNvbnN0IHRyYW5zZm9ybWVyQW5jaG9yU2l6ZSA9IDE0O1xuICBjb25zdCB0cmFuc2Zvcm1lclJvdGF0ZU9mZnNldCA9IDI0O1xuICBjb25zdCB0cmFuc2Zvcm1lckFuY2hvclJhZGl1cyA9IDk5OTtcbiAgY29uc3QgZXNUcmlhbmd1bG8gPVxuICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImZvcm1hXCIgJiZcbiAgICBwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcInRyaWFuZ2xlXCI7XG5cbiAgY29uc3QgaGFzR2FsbGVyeSA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhLnNvbWUoXG4gICAgKG8pID0+IG8udGlwbyA9PT0gXCJnYWxlcmlhXCJcbiAgKTtcblxuICBjb25zdCBoYXlMaW5lYXMgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YS5zb21lKFxuICAgIChvYmopID0+IG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJsaW5lXCJcbiAgKTtcblxuICBjb25zdCBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcyA9IGVsZW1lbnRvc1NlbGVjY2lvbmFkb3NEYXRhLmZpbHRlcihcbiAgICAob2JqKSA9PiAhKG9iai50aXBvID09PSBcImZvcm1hXCIgJiYgb2JqLmZpZ3VyYSA9PT0gXCJsaW5lXCIpXG4gICk7XG5cbiAgY29uc3QgZGViZXJpYVVzYXJUcmFuc2Zvcm1lciA9XG4gICAgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID4gMDtcblxuICBjb25zdCBzZWxlY3RlZEdlb21LZXkgPSBlbGVtZW50b3NTZWxlY2Npb25hZG9zRGF0YVxuICAgIC5tYXAoKG8pID0+XG4gICAgICBbXG4gICAgICAgIG8uaWQsXG4gICAgICAgIG8ueCA/PyAwLFxuICAgICAgICBvLnkgPz8gMCxcbiAgICAgICAgby53aWR0aCA/PyBcIlwiLFxuICAgICAgICBvLmhlaWdodCA/PyBcIlwiLFxuICAgICAgICBvLnNjYWxlWCA/PyAxLFxuICAgICAgICBvLnNjYWxlWSA/PyAxLFxuICAgICAgICBvLnJvdGF0aW9uID8/IDAsXG4gICAgICAgIG8uY2hpcFdpZHRoID8/IFwiXCIsXG4gICAgICAgIG8uZ2FwID8/IFwiXCIsXG4gICAgICAgIG8ucGFkZGluZ1ggPz8gXCJcIixcbiAgICAgICAgby5wYWRkaW5nWSA/PyBcIlwiLFxuICAgICAgXS5qb2luKFwiOlwiKVxuICAgIClcbiAgICAuam9pbihcInxcIik7XG5cbiAgY29uc3QgZ2V0VHJhbnNmb3JtUG9zZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlKSByZXR1cm4geyB4OiAwLCB5OiAwLCByb3RhdGlvbjogMCB9O1xuXG4gICAgaWYgKGVzR2FsZXJpYSAmJiB0eXBlb2Ygbm9kZS5nZXRQYXJlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0eXBlb2YgcGFyZW50LnggPT09IFwiZnVuY3Rpb25cIiA/IHBhcmVudC54KCkgOiAwLFxuICAgICAgICAgIHk6IHR5cGVvZiBwYXJlbnQueSA9PT0gXCJmdW5jdGlvblwiID8gcGFyZW50LnkoKSA6IDAsXG4gICAgICAgICAgcm90YXRpb246IHR5cGVvZiBwYXJlbnQucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IHBhcmVudC5yb3RhdGlvbigpIHx8IDAgOiAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiB0eXBlb2Ygbm9kZS54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IDAsXG4gICAgICB5OiB0eXBlb2Ygbm9kZS55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IDAsXG4gICAgICByb3RhdGlvbjogdHlwZW9mIG5vZGUucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUucm90YXRpb24oKSB8fCAwIDogMCxcbiAgICB9O1xuICB9O1xuXG5cbiAgLy8g8J+UpSBFZmVjdG8gcHJpbmNpcGFsIGRlbCBUcmFuc2Zvcm1lciAoU0lOIHJldHJ5IC8gU0lOIGZsaWNrZXIpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xuICAgIGlmICghdHIpIHJldHVybjtcblxuICAgIGNvbnN0IHNlbEtleSA9IHNlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIik7XG4gICAgVFJEQkcoXCJFRkZFQ1Qgc3RhcnRcIiwge1xuICAgICAgc2VsS2V5LFxuICAgICAgaXNEcmFnZ2luZyxcbiAgICAgIGRlYmVyaWFVc2FyVHJhbnNmb3JtZXIsXG4gICAgICBoYXNHYWxsZXJ5LFxuICAgICAgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXNMZW46IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCxcbiAgICAgIHRyYW5zZm9ybVRpY2ssXG4gICAgICBlZGl0aW5nSWQ6IHdpbmRvdy5lZGl0aW5nPy5pZCB8fCBudWxsLFxuICAgIH0pO1xuXG4gICAgLy8gU2kgbm8gY29ycmVzcG9uZGUgdHJhbnNmb3JtZXIsIG5vIGhhZ2FzIGRldGFjaCBhZ3Jlc2l2byAoZXZpdGEgZmxpY2tlcilcbiAgICBpZiAoIWRlYmVyaWFVc2FyVHJhbnNmb3JtZXIpIHtcbiAgICAgIFRSREJHKFwiRUZGRUNUIGV4aXQ6IG5vIHRyYW5zZm9ybWVyIG9yIGdhbGxlcnlcIiwgeyBzZWxLZXkgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBSZXNvbHZlciBub2RlcyBkZXNkZSByZWZzIChmdWVudGUgZGUgdmVyZGFkKVxuICAgIGxldCBub2Rvc1RyYW5zZm9ybWFibGVzID0gZWxlbWVudG9zVHJhbnNmb3JtYWJsZXNcbiAgICAgIC5tYXAoKG8pID0+IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltvLmlkXSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAvLyBTaW5nbGUgc2VsZWN0OiB1c2FyIHJlZiBmcmVzY28gU0lFTVBSRVxuICAgIGlmIChzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgaWRTZWwgPSBzZWxlY3RlZEVsZW1lbnRzWzBdO1xuICAgICAgY29uc3QgcmVmTm9kZSA9IGVsZW1lbnRSZWZzLmN1cnJlbnQ/LltpZFNlbF0gfHwgbnVsbDtcbiAgICAgIGlmIChyZWZOb2RlICYmIHR5cGVvZiByZWZOb2RlLmdldENsaWVudFJlY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZXNHYWxlcmlhICYmIHR5cGVvZiByZWZOb2RlLmZpbmRPbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IGdhbGxlcnlGcmFtZSA9IHJlZk5vZGUuZmluZE9uZShcIi5nYWxsZXJ5LXRyYW5zZm9ybS1mcmFtZVwiKTtcbiAgICAgICAgICBpZiAoZ2FsbGVyeUZyYW1lICYmIHR5cGVvZiBnYWxsZXJ5RnJhbWUuZ2V0Q2xpZW50UmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBub2Rvc1RyYW5zZm9ybWFibGVzID0gW2dhbGxlcnlGcmFtZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZG9zVHJhbnNmb3JtYWJsZXMgPSBbcmVmTm9kZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZG9zVHJhbnNmb3JtYWJsZXMgPSBbcmVmTm9kZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaSBhw7puIG5vIGhheSBub2RvcyAoaW1hZ2VuIGNhcmdhbmRvLCBldGMuKSwgTk8gZGVzcGVnYXIgKGV2aXRhIHBhcnBhZGVvKVxuICAgIGlmIChub2Rvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgVFJEQkcoXCJFRkZFQ1QgZXhpdDogbm8gbm9kZXMgeWV0XCIsIHtcbiAgICAgICAgc2VsS2V5LFxuICAgICAgICB3YW50ZWRJZHM6IGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLm1hcChvID0+IG8uaWQpLFxuICAgICAgICByZWZzUHJlc2VudDogZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubWFwKG8gPT4gISFlbGVtZW50UmVmcy5jdXJyZW50Py5bby5pZF0pLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBBdHRhY2ggZXN0YWJsZVxuICAgIFRSREJHKFwiQVRUQUNIIHRyeVwiLCB7XG4gICAgICBzZWxLZXksXG4gICAgICBub2Rlc0NvdW50OiBub2Rvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCxcbiAgICAgIG5vZGVJZHM6IG5vZG9zVHJhbnNmb3JtYWJsZXMubWFwKG4gPT4gKHR5cGVvZiBuLmlkID09PSBcImZ1bmN0aW9uXCIgPyBuLmlkKCkgOiBuLmF0dHJzPy5pZCkpLFxuICAgIH0pO1xuXG4gICAgdHIubm9kZXMobm9kb3NUcmFuc2Zvcm1hYmxlcyk7XG5cbiAgICBUUkRCRyhcIkFUVEFDSCBkb25lXCIsIHtcbiAgICAgIHNlbEtleSxcbiAgICAgIHRyTm9kZXNDb3VudDogdHIubm9kZXM/LigpPy5sZW5ndGggfHwgMCxcbiAgICB9KTtcblxuICAgIHRyeSB7IHRyLmZvcmNlVXBkYXRlPy4oKTsgfSBjYXRjaCB7IH1cbiAgICB0ci5nZXRMYXllcigpPy5iYXRjaERyYXcoKTtcblxuICB9LCBbXG4gICAgLy8gRGVwZW5kZW5jaWFzIG3DrW5pbWFzIHJlYWxlc1xuICAgIHNlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIiksXG4gICAgZGViZXJpYVVzYXJUcmFuc2Zvcm1lcixcbiAgICBoYXNHYWxsZXJ5LFxuICAgIGVsZW1lbnRvc1RyYW5zZm9ybWFibGVzLmxlbmd0aCxcbiAgICBzZWxlY3RlZEdlb21LZXksXG4gICAgdHJhbnNmb3JtVGljayxcbiAgICBlbGVtZW50UmVmcyxcbiAgXSk7XG5cblxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IChlKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IGU/LmRldGFpbD8uaWQ7XG4gICAgICBpZiAoIWlkKSByZXR1cm47XG5cbiAgICAgIFRSREJHKFwiUkVGIGV2ZW50XCIsIHtcbiAgICAgICAgaWQsXG4gICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdGVkRWxlbWVudHMuaW5jbHVkZXMoaWQpLFxuICAgICAgICBzZWxLZXk6IHNlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIiksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzZWxlY3RlZEVsZW1lbnRzLmluY2x1ZGVzKGlkKSkgcmV0dXJuO1xuICAgICAgc2V0VHJhbnNmb3JtVGljayh0ID0+IHQgKyAxKTtcbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlbGVtZW50LXJlZi1yZWdpc3RyYWRvXCIsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVsZW1lbnQtcmVmLXJlZ2lzdHJhZG9cIiwgaGFuZGxlcik7XG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmaXJzdElkID0gc2VsZWN0ZWRFbGVtZW50cz8uWzBdO1xuICAgIGlmICghZmlyc3RJZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgZmlyc3ROb2RlID0gZWxlbWVudFJlZnMuY3VycmVudD8uW2ZpcnN0SWRdO1xuICAgIGNvbnN0IHN0YWdlID0gZmlyc3ROb2RlPy5nZXRTdGFnZT8uKCk7XG4gICAgaWYgKCFzdGFnZSkgcmV0dXJuO1xuXG4gICAgbGV0IHJhZklkID0gbnVsbDtcbiAgICBjb25zdCBzeW5jVHJhbnNmb3JtZXIgPSAoKSA9PiB7XG4gICAgICBpZiAocmFmSWQgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByYWZJZCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCF0cikgcmV0dXJuO1xuICAgICAgICB0cnkgeyB0ci5mb3JjZVVwZGF0ZT8uKCk7IH0gY2F0Y2ggeyB9XG4gICAgICAgIHRyLmdldExheWVyPy4oKT8uYmF0Y2hEcmF3Py4oKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzdGFnZS5vbihcImRyYWdtb3ZlXCIsIHN5bmNUcmFuc2Zvcm1lcik7XG4gICAgc3RhZ2Uub24oXCJkcmFnZW5kXCIsIHN5bmNUcmFuc2Zvcm1lcik7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RhZ2Uub2ZmKFwiZHJhZ21vdmVcIiwgc3luY1RyYW5zZm9ybWVyKTtcbiAgICAgIHN0YWdlLm9mZihcImRyYWdlbmRcIiwgc3luY1RyYW5zZm9ybWVyKTtcbiAgICAgIGlmIChyYWZJZCAhPSBudWxsKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgfTtcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHMuam9pbihcIixcIiksIGVsZW1lbnRSZWZzXSk7XG5cblxuXG5cbiAgLy8g8J+UpSBSZW5kZXJcblxuICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIGlmIChoYXlMaW5lYXMgJiYgZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3VuZHNJbmRpY2F0b3JcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50cz17c2VsZWN0ZWRFbGVtZW50c31cbiAgICAgICAgZWxlbWVudFJlZnM9e2VsZW1lbnRSZWZzfVxuICAgICAgICBvYmpldG9zPXtvYmpldG9zfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbiAgaWYgKGhheUxpbmVhcyAmJiBlbGVtZW50b3NUcmFuc2Zvcm1hYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3VuZHNJbmRpY2F0b3JcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50cz17c2VsZWN0ZWRFbGVtZW50c31cbiAgICAgICAgZWxlbWVudFJlZnM9e2VsZW1lbnRSZWZzfVxuICAgICAgICBvYmpldG9zPXtvYmpldG9zfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8VHJhbnNmb3JtZXJcbiAgICAgIG5hbWU9XCJ1aVwiXG4gICAgICByZWY9e3RyYW5zZm9ybWVyUmVmfVxuXG4gICAgICAvLyDwn5S1IGJvcmRlIHNpZW1wcmUgdmlzaWJsZVxuICAgICAgYm9yZGVyRW5hYmxlZD17dHJ1ZX1cblxuICAgICAgYm9yZGVyU3Ryb2tlPVwiIzkzMzNFQVwiXG5cblxuICAgICAgYm9yZGVyU3Ryb2tlV2lkdGg9ezF9XG5cbiAgICAgIC8vIOKdjCBub2RvcyB5IHJvdGFjacOzbiBPRkYgZHVyYW50ZSBkcmFnXG4gICAgICBlbmFibGVkQW5jaG9ycz17aXNEcmFnZ2luZyA/IFtdIDogW1wiYm90dG9tLXJpZ2h0XCJdfVxuICAgICAgcm90YXRlRW5hYmxlZD17IWlzRHJhZ2dpbmcgJiYgIWVzR2FsZXJpYX1cblxuICAgICAgYW5jaG9yRmlsbD1cIiM5MzMzRUFcIlxuICAgICAgYW5jaG9yU3Ryb2tlPVwiI2ZmZmZmZlwiXG4gICAgICBhbmNob3JTdHJva2VXaWR0aD17Mi41fVxuICAgICAgYW5jaG9yU2l6ZT17dHJhbnNmb3JtZXJBbmNob3JTaXplfVxuICAgICAgYW5jaG9yQ29ybmVyUmFkaXVzPXt0cmFuc2Zvcm1lckFuY2hvclJhZGl1c31cbiAgICAgIGFuY2hvclNoYWRvd0NvbG9yPVwicmdiYSgxNDcsIDUxLCAyMzQsIDAuMylcIlxuICAgICAgYW5jaG9yU2hhZG93Qmx1cj17Nn1cbiAgICAgIGFuY2hvclNoYWRvd09mZnNldD17eyB4OiAwLCB5OiAzIH19XG4gICAgICBrZWVwUmF0aW89e2xvY2tBc3BlY3RDb3VudGRvd24gfHwgZXNHYWxlcmlhfVxuICAgICAgY2VudGVyZWRTY2FsaW5nPXtzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBlc1RleHRvfVxuICAgICAgZmxpcEVuYWJsZWQ9e2ZhbHNlfVxuICAgICAgcmVzaXplRW5hYmxlZD17IWlzRHJhZ2dpbmd9XG4gICAgICByb3RhdGlvblNuYXBzPXtbMCwgNDUsIDkwLCAxMzUsIDE4MCwgMjI1LCAyNzAsIDMxNV19XG4gICAgICByb3RhdGVBbmNob3JPZmZzZXQ9e3RyYW5zZm9ybWVyUm90YXRlT2Zmc2V0fVxuICAgICAgcm90YXRpb25TbmFwVG9sZXJhbmNlPXs1fVxuICAgICAgYm91bmRCb3hGdW5jPXsob2xkQm94LCBuZXdCb3gpID0+IHtcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IGVzVGV4dG8gPyAyMCA6IDEwO1xuICAgICAgICBjb25zdCBtYXhTaXplID0gODAwO1xuICAgICAgICBpZiAoZXNHYWxlcmlhKSB7XG4gICAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIE51bWJlcihwcmltZXJFbGVtZW50bz8ucm93cykgfHwgMSk7XG4gICAgICAgICAgY29uc3QgY29scyA9IE1hdGgubWF4KDEsIE51bWJlcihwcmltZXJFbGVtZW50bz8uY29scykgfHwgMSk7XG4gICAgICAgICAgY29uc3QgZ2FwID0gTWF0aC5tYXgoMCwgTnVtYmVyKHByaW1lckVsZW1lbnRvPy5nYXApIHx8IDApO1xuICAgICAgICAgIGNvbnN0IGNlbGxSYXRpbyA9XG4gICAgICAgICAgICBwcmltZXJFbGVtZW50bz8ucmF0aW8gPT09IFwiNDozXCJcbiAgICAgICAgICAgICAgPyAzIC8gNFxuICAgICAgICAgICAgICA6IHByaW1lckVsZW1lbnRvPy5yYXRpbyA9PT0gXCIxNjo5XCJcbiAgICAgICAgICAgICAgICA/IDkgLyAxNlxuICAgICAgICAgICAgICAgIDogMTtcblxuICAgICAgICAgIGNvbnN0IG1pbkdyaWRXaWR0aCA9IGdhcCAqIChjb2xzIC0gMSkgKyBjb2xzO1xuICAgICAgICAgIGNvbnN0IG5leHRXaWR0aCA9IE1hdGgubWluKFxuICAgICAgICAgICAgbWF4U2l6ZSxcbiAgICAgICAgICAgIE1hdGgubWF4KG1pblNpemUsIG1pbkdyaWRXaWR0aCwgTWF0aC5hYnMobmV3Qm94LndpZHRoKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGNlbGxXID0gTWF0aC5tYXgoMSwgKG5leHRXaWR0aCAtIGdhcCAqIChjb2xzIC0gMSkpIC8gY29scyk7XG4gICAgICAgICAgY29uc3QgY2VsbEggPSBjZWxsVyAqIGNlbGxSYXRpbztcbiAgICAgICAgICBjb25zdCBuZXh0SGVpZ2h0ID0gcm93cyAqIGNlbGxIICsgZ2FwICogKHJvd3MgLSAxKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5uZXdCb3gsXG4gICAgICAgICAgICB3aWR0aDogbmV4dFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChtaW5TaXplLCBuZXh0SGVpZ2h0KSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0JveC53aWR0aCA8IG1pblNpemUgfHwgbmV3Qm94LmhlaWdodCA8IG1pblNpemUpIHtcbiAgICAgICAgICByZXR1cm4gb2xkQm94O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2tBc3BlY3RDb3VudGRvd24pIHtcbiAgICAgICAgICBjb25zdCBiYXNlVyA9IE1hdGgubWF4KDEsIG9sZEJveC53aWR0aCk7XG4gICAgICAgICAgY29uc3QgYmFzZUggPSBNYXRoLm1heCgxLCBvbGRCb3guaGVpZ2h0KTtcbiAgICAgICAgICBjb25zdCByYXRpbyA9IGJhc2VXIC8gYmFzZUg7XG5cbiAgICAgICAgICBjb25zdCBkdyA9IE1hdGguYWJzKG5ld0JveC53aWR0aCAtIG9sZEJveC53aWR0aCkgLyBiYXNlVztcbiAgICAgICAgICBjb25zdCBkaCA9IE1hdGguYWJzKG5ld0JveC5oZWlnaHQgLSBvbGRCb3guaGVpZ2h0KSAvIGJhc2VIO1xuXG4gICAgICAgICAgbGV0IHdpZHRoID0gbmV3Qm94LndpZHRoO1xuICAgICAgICAgIGxldCBoZWlnaHQgPSBuZXdCb3guaGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKGRoID4gZHcpIHtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogcmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gcmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld0JveCxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihNYXRoLm1heCh3aWR0aCwgbWluU2l6ZSksIG1heFNpemUpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihNYXRoLm1heChoZWlnaHQsIG1pblNpemUpLCBtYXhTaXplKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVzVGV4dG8pIHtcbiAgICAgICAgICBjb25zdCBzY2FsZVggPSBuZXdCb3gud2lkdGggLyBvbGRCb3gud2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gbmV3Qm94LmhlaWdodCAvIG9sZEJveC5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgdW5pZm9ybVNjYWxlID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuXG4gICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBvbGRCb3gud2lkdGggKiB1bmlmb3JtU2NhbGU7XG4gICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gb2xkQm94LmhlaWdodCAqIHVuaWZvcm1TY2FsZTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5uZXdCb3gsXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oTWF0aC5tYXgobmV3V2lkdGgsIG1pblNpemUpLCBtYXhTaXplKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5taW4oTWF0aC5tYXgobmV3SGVpZ2h0LCBtaW5TaXplKSwgbWF4U2l6ZSksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJmb3JtYVwiICYmXG4gICAgICAgICAgcHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIlxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgobmV3Qm94LndpZHRoLCBuZXdCb3guaGVpZ2h0KTtcbiAgICAgICAgICBjb25zdCBmaW5hbFNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhTaXplKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubmV3Qm94LFxuICAgICAgICAgICAgd2lkdGg6IGZpbmFsU2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogZmluYWxTaXplLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXNUcmlhbmd1bG8pIHtcbiAgICAgICAgICBjb25zdCBzYWZlT2xkVyA9IE1hdGgubWF4KDEsIE1hdGguYWJzKG9sZEJveC53aWR0aCB8fCBtaW5TaXplKSk7XG4gICAgICAgICAgY29uc3Qgc2FmZU9sZEggPSBNYXRoLm1heCgxLCBNYXRoLmFicyhvbGRCb3guaGVpZ2h0IHx8IG1pblNpemUpKTtcbiAgICAgICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhuZXdCb3gud2lkdGgpIC8gc2FmZU9sZFc7XG4gICAgICAgICAgY29uc3Qgc2NhbGVZID0gTWF0aC5hYnMobmV3Qm94LmhlaWdodCkgLyBzYWZlT2xkSDtcbiAgICAgICAgICBjb25zdCB1bmlmb3JtU2NhbGUgPSBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpO1xuXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChzYWZlT2xkVyAqIHVuaWZvcm1TY2FsZSwgbWluU2l6ZSksIG1heFNpemUpO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KHNhZmVPbGRIICogdW5pZm9ybVNjYWxlLCBtaW5TaXplKSwgbWF4U2l6ZSk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubmV3Qm94LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJpbWFnZW5cIiB8fFxuICAgICAgICAgIHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImljb25vXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVYID0gbmV3Qm94LndpZHRoIC8gb2xkQm94LndpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IG5ld0JveC5oZWlnaHQgLyBvbGRCb3guaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHVuaWZvcm1TY2FsZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcblxuICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gb2xkQm94LndpZHRoICogdW5pZm9ybVNjYWxlO1xuICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IG9sZEJveC5oZWlnaHQgKiB1bmlmb3JtU2NhbGU7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubmV3Qm94LFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKE1hdGgubWF4KG5ld1dpZHRoLCBtaW5TaXplKSwgbWF4U2l6ZSksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKE1hdGgubWF4KG5ld0hlaWdodCwgbWluU2l6ZSksIG1heFNpemUpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld0JveCxcbiAgICAgICAgICB3aWR0aDogTWF0aC5taW4obmV3Qm94LndpZHRoLCBtYXhTaXplKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKG5ld0JveC5oZWlnaHQsIG1heFNpemUpLFxuICAgICAgICB9O1xuICAgICAgfX1cbiAgICAgIG9uVHJhbnNmb3JtU3RhcnQ9eygpID0+IHtcbiAgICAgICAgd2luZG93Ll9yZXNpemVEYXRhID0geyBpc1Jlc2l6aW5nOiB0cnVlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xuICAgICAgICAgIGNvbnN0IG5vZGVzID0gdHI/Lm5vZGVzPy4oKSB8fCBbXTtcbiAgICAgICAgICBjaXJjbGVBbmNob3JSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgcHJpbWVyRWxlbWVudG8/LnRpcG8gPT09IFwiZm9ybWFcIiAmJlxuICAgICAgICAgICAgcHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcjAgPSBub2Rlc1swXS5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjaXJjbGVBbmNob3JSZWYuY3VycmVudCA9IHsgbGVmdDogcjAueCwgdG9wOiByMC55IH07XG4gICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBlc1RleHRvKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgICAgICBsZXQgY2VudGVyWCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYmFzZVdpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBiYXNlSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBiYXNlVmlzdWFsV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py54KSAmJiBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IHJlY3QueCArIChyZWN0LndpZHRoIC8gMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py53aWR0aCkgJiYgcmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBiYXNlV2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJhc2VWaXN1YWxXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Py5oZWlnaHQpICYmIHJlY3QuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGJhc2VIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICAgICAgY29uc3Qgc2FmZUJhc2VGb250U2l6ZSA9XG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwcmltZXJFbGVtZW50bz8uZm9udFNpemUpICYmIHByaW1lckVsZW1lbnRvLmZvbnRTaXplID4gMFxuICAgICAgICAgICAgICAgID8gcHJpbWVyRWxlbWVudG8uZm9udFNpemVcbiAgICAgICAgICAgICAgICA6IDI0O1xuICAgICAgICAgICAgdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICB5OiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiAwLFxuICAgICAgICAgICAgICBjZW50ZXJYLFxuICAgICAgICAgICAgICBiYXNlV2lkdGgsXG4gICAgICAgICAgICAgIGJhc2VIZWlnaHQsXG4gICAgICAgICAgICAgIGJhc2VGb250U2l6ZTogc2FmZUJhc2VGb250U2l6ZSxcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdGb250U2l6ZTogc2FmZUJhc2VGb250U2l6ZSxcbiAgICAgICAgICAgICAgbGFzdFByZXZpZXdDZW50ZXJYOiBjZW50ZXJYLFxuICAgICAgICAgICAgICBsYXN0UHJldmlld1Zpc3VhbFdpZHRoOiBiYXNlVmlzdWFsV2lkdGgsXG4gICAgICAgICAgICAgIHByZXZpZXdUaWNrOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFRYVERCRyhcInN0YXJ0XCIsIHtcbiAgICAgICAgICAgICAgaWQ6IHByaW1lckVsZW1lbnRvPy5pZCA/PyBudWxsLFxuICAgICAgICAgICAgICBiYXNlRm9udFNpemU6IHNhZmVCYXNlRm9udFNpemUsXG4gICAgICAgICAgICAgIGJhc2VXaWR0aCxcbiAgICAgICAgICAgICAgYmFzZUhlaWdodCxcbiAgICAgICAgICAgICAgY2VudGVyWCxcbiAgICAgICAgICAgICAgbm9kZVg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5vZGVZOiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxuICAgICAgICAgICAgICBub2RlU2NhbGVYOiB0eXBlb2Ygbm9kZT8uc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgbm9kZVNjYWxlWTogdHlwZW9mIG5vZGU/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB1bmlvbiA9IHJlY3RGcm9tTm9kZXMobm9kZXMpO1xuXG4gICAgICAgICAgY29uc3QgcGFkID0gdHlwZW9mIHRyPy5wYWRkaW5nID09PSBcImZ1bmN0aW9uXCIgPyB0ci5wYWRkaW5nKCkgOiAwO1xuICAgICAgICAgIGNvbnN0IGJvcmRlclJlY3QgPSB1bmlvblxuICAgICAgICAgICAgPyB7IHg6IHVuaW9uLnggLSBwYWQsIHk6IHVuaW9uLnkgLSBwYWQsIHdpZHRoOiB1bmlvbi53aWR0aCArIHBhZCAqIDIsIGhlaWdodDogdW5pb24uaGVpZ2h0ICsgcGFkICogMiB9XG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgICBjb25zdCBuID0gbm9kZXNbMF07XG4gICAgICAgICAgY29uc3QgaWQgPSBuID8gKHR5cGVvZiBuLmlkID09PSBcImZ1bmN0aW9uXCIgPyBuLmlkKCkgOiBuLmF0dHJzPy5pZCkgOiBcIuKIhVwiO1xuICAgICAgICAgIGNvbnN0IHRyUmVjdCA9IHRyPy5nZXRDbGllbnRSZWN0Py4oeyBza2lwVHJhbnNmb3JtOiBmYWxzZSwgc2tpcFNoYWRvdzogdHJ1ZSwgc2tpcFN0cm9rZTogdHJ1ZSB9KTtcblxuICAgICAgICAgIHNsb2coXG4gICAgICAgICAgICBcIltUUl0gc3RhcnRcIixcbiAgICAgICAgICAgIGBpZD0ke2lkfWAsXG4gICAgICAgICAgICBgbm9kZXM9JHtub2Rlcy5sZW5ndGh9YCxcbiAgICAgICAgICAgIHVuaW9uID8gYHVuaW9uKHc9JHt1bmlvbi53aWR0aC50b0ZpeGVkKDEpfSxoPSR7dW5pb24uaGVpZ2h0LnRvRml4ZWQoMSl9KWAgOiBcInVuaW9uKG51bGwpXCIsXG4gICAgICAgICAgICBib3JkZXJSZWN0ID8gYGJvcmRlcih3PSR7Ym9yZGVyUmVjdC53aWR0aC50b0ZpeGVkKDEpfSxoPSR7Ym9yZGVyUmVjdC5oZWlnaHQudG9GaXhlZCgxKX0pYCA6IFwiYm9yZGVyKG51bGwpXCIsXG4gICAgICAgICAgICB0clJlY3QgPyBgdHJSZWN0KHc9JHt0clJlY3Qud2lkdGgudG9GaXhlZCgxKX0saD0ke3RyUmVjdC5oZWlnaHQudG9GaXhlZCgxKX0pYCA6IFwidHJSZWN0KG51bGwpXCIsXG4gICAgICAgICAgICBgcGFkPSR7cGFkfWBcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHsgfVxuICAgICAgfX1cblxuICAgICAgb25UcmFuc2Zvcm09eyhlKSA9PiB7XG4gICAgICAgIGlmICghb25UcmFuc2Zvcm0gfHwgIXRyYW5zZm9ybWVyUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgICBjb25zdCB0ciA9IHRyYW5zZm9ybWVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdHlwZW9mIHRyLm5vZGVzID09PSBcImZ1bmN0aW9uXCIgPyB0ci5ub2RlcygpIHx8IFtdIDogW107XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTsgLy8g4pyFIG5vZG8gcmVhbCAoc2luZ2xlIHNlbGVjdClcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwb3NlID0gZ2V0VHJhbnNmb3JtUG9zZShub2RlKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1EYXRhID0ge1xuICAgICAgICAgICAgeDogcG9zZS54LFxuICAgICAgICAgICAgeTogcG9zZS55LFxuICAgICAgICAgICAgcm90YXRpb246IHBvc2Uucm90YXRpb24sXG4gICAgICAgICAgICBpc1ByZXZpZXc6IHRydWUsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChlc1RleHRvKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcHJpbWVyRWxlbWVudG8uZm9udFNpemUgfHwgMjQ7XG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvckRhdGEgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VGb250U2l6ZSA9XG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy5iYXNlRm9udFNpemUpICYmXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEuYmFzZUZvbnRTaXplID4gMFxuICAgICAgICAgICAgICAgID8gYW5jaG9yRGF0YS5iYXNlRm9udFNpemVcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRm9udFNpemU7XG5cbiAgICAgICAgICAgIGNvbnN0IGF2Z1NjYWxlID0gKE1hdGguYWJzKHNjYWxlWCkgKyBNYXRoLmFicyhzY2FsZVkpKSAvIDI7XG4gICAgICAgICAgICBsZXQgc2NhbGVGcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbGl2ZVJlY3RXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBza2lwU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJiByZWN0LndpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpdmVSZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VXaWR0aCA9IE51bWJlcihhbmNob3JEYXRhPy5iYXNlV2lkdGgpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGJhc2VXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBiYXNlV2lkdGggPiAwICYmXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHJlY3Q/LndpZHRoKSAmJlxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPiAwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbVJlY3QgPSByZWN0LndpZHRoIC8gYmFzZVdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVTY2FsZSA9XG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShzY2FsZUZyb21SZWN0KSAmJiBzY2FsZUZyb21SZWN0ID4gMFxuICAgICAgICAgICAgICAgID8gc2NhbGVGcm9tUmVjdFxuICAgICAgICAgICAgICAgIDogYXZnU2NhbGU7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLmZvbnRTaXplID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgIE51bWJlcigoYmFzZUZvbnRTaXplICogZWZmZWN0aXZlU2NhbGUpLnRvRml4ZWQoMykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB0aWNrID0gTnVtYmVyKHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5wcmV2aWV3VGljayB8fCAwKSArIDE7XG4gICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5wcmV2aWV3VGljayA9IHRpY2s7XG4gICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld0ZvbnRTaXplID0gdHJhbnNmb3JtRGF0YS5mb250U2l6ZTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShsaXZlUmVjdFdpZHRoKSAmJiBsaXZlUmVjdFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5sYXN0UHJldmlld1Zpc3VhbFdpZHRoID0gbGl2ZVJlY3RXaWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGljayA8PSAyIHx8IHRpY2sgJSA1ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgVFhUREJHKFwicHJldmlld1wiLCB7XG4gICAgICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICB0aWNrLFxuICAgICAgICAgICAgICAgICAgc2NhbGVYLFxuICAgICAgICAgICAgICAgICAgc2NhbGVZLFxuICAgICAgICAgICAgICAgICAgYXZnU2NhbGUsXG4gICAgICAgICAgICAgICAgICBzY2FsZUZyb21SZWN0LFxuICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlU2NhbGUsXG4gICAgICAgICAgICAgICAgICBiYXNlRm9udFNpemUsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogdHJhbnNmb3JtRGF0YS5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICAgIGxpdmVSZWN0V2lkdGgsXG4gICAgICAgICAgICAgICAgICBjZW50ZXJYVGFyZ2V0OiB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQ/LmNlbnRlclggPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5vZGVYOiB0eXBlb2Ygbm9kZT8ueCA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS54KCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgbm9kZVk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVYID0gMTtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py55KSkge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnkgPSB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQueTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5vZGUueSh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50Py5jZW50ZXJYKSkge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRleHRDZW50ZXJYID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclg7XG4gICAgICAgICAgICAgIGlmICh0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQubGFzdFByZXZpZXdDZW50ZXJYID1cbiAgICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm1BbmNob3JSZWYuY3VycmVudC5jZW50ZXJYO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgICBza2lwVHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDZW50ZXJYID1cbiAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShyZWN0Py54KSAmJiBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgID8gcmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID1cbiAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShjdXJyZW50Q2VudGVyWClcbiAgICAgICAgICAgICAgICAgICAgPyAodGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50LmNlbnRlclggLSBjdXJyZW50Q2VudGVyWClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZGVsdGFYKSAmJiBNYXRoLmFicyhkZWx0YVgpID4gMC4wMSAmJiB0eXBlb2Ygbm9kZS54ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIFRYVERCRyhcInByZXZpZXctY2VudGVyLWNvcnJlY3Rpb25cIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXJYOiB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQuY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBub2RlLngobm9kZS54KCkgKyBkZWx0YVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcblxuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnNjYWxlWSA9IHNjYWxlWTtcblxuICAgICAgICAgICAgaWYgKHByaW1lckVsZW1lbnRvPy50aXBvID09PSBcImNvdW50ZG93blwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50ZG93blNpemUgPSBnZXRDb3VudGRvd25TY2FsZWRTaXplKG5vZGUpO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLndpZHRoID0gY291bnRkb3duU2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5oZWlnaHQgPSBjb3VudGRvd25TaXplLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXNUcmlhbmd1bG8pIHtcbiAgICAgICAgICAgICAgY29uc3QgYmFzZVJhZGl1cyA9IE51bWJlci5pc0Zpbml0ZShwcmltZXJFbGVtZW50bz8ucmFkaXVzKVxuICAgICAgICAgICAgICAgID8gcHJpbWVyRWxlbWVudG8ucmFkaXVzXG4gICAgICAgICAgICAgICAgOiA2MDtcbiAgICAgICAgICAgICAgY29uc3QgYXZnU2NhbGUgPSAoTWF0aC5hYnMoc2NhbGVYKSArIE1hdGguYWJzKHNjYWxlWSkpIC8gMjtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5yYWRpdXMgPSBNYXRoLm1heCgxLCBiYXNlUmFkaXVzICogYXZnU2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHByaW1lckVsZW1lbnRvLndpZHRoIHx8IDEwMDtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSBwcmltZXJFbGVtZW50by5oZWlnaHQgfHwgMTAwO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLndpZHRoID0gTWF0aC5hYnMob3JpZ2luYWxXaWR0aCAqIHNjYWxlWCk7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEuaGVpZ2h0ID0gTWF0aC5hYnMob3JpZ2luYWxIZWlnaHQgKiBzY2FsZVkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJpbWVyRWxlbWVudG8/LmZpZ3VyYSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpdmVSZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlhbWV0ZXIgPSBNYXRoLm1heCgxLCBNYXRoLm1heChsaXZlUmVjdC53aWR0aCwgbGl2ZVJlY3QuaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS5yYWRpdXMgPSBkaWFtZXRlciAvIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS54ID0gYW5jaG9yLmxlZnQgKyB0cmFuc2Zvcm1EYXRhLnJhZGl1cztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybURhdGEueSA9IGFuY2hvci50b3AgKyB0cmFuc2Zvcm1EYXRhLnJhZGl1cztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS54ID0gbGl2ZVJlY3QueCArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS55ID0gbGl2ZVJlY3QueSArIHRyYW5zZm9ybURhdGEucmFkaXVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9uVHJhbnNmb3JtKHRyYW5zZm9ybURhdGEpO1xuXG4gICAgICAgICAgLy8gLS0tIExPRyBDT01QQUNUTyAob3BjaW9uYWwpIC0tLVxuICAgICAgICAgIGNvbnN0IGlkID0gKHR5cGVvZiBub2RlLmlkID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLmlkKCkgOiBub2RlLmF0dHJzPy5pZCkgfHwgXCLiiIVcIjtcbiAgICAgICAgICBjb25zdCBzeCA9IG5vZGUuc2NhbGVYPy4oKSA/PyAxO1xuICAgICAgICAgIGNvbnN0IHN5ID0gbm9kZS5zY2FsZVk/LigpID8/IDE7XG4gICAgICAgICAgY29uc3QgciA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IGZhbHNlLCBza2lwU2hhZG93OiB0cnVlLCBza2lwU3Ryb2tlOiB0cnVlIH0pO1xuICAgICAgICAgIHNsb2coXG4gICAgICAgICAgICBcIltUUl0gbGl2ZVwiLFxuICAgICAgICAgICAgYGlkPSR7aWR9YCxcbiAgICAgICAgICAgIGB0aXBvPSR7cHJpbWVyRWxlbWVudG8/LnRpcG8gfHwgXCLiiIVcIn1gLFxuICAgICAgICAgICAgYHN4PSR7c3gudG9GaXhlZCgzKX1gLFxuICAgICAgICAgICAgYHN5PSR7c3kudG9GaXhlZCgzKX1gLFxuICAgICAgICAgICAgYHg9JHsobm9kZS54Py4oKSA/PyAwKS50b0ZpeGVkKDEpfWAsXG4gICAgICAgICAgICBgeT0keyhub2RlLnk/LigpID8/IDApLnRvRml4ZWQoMSl9YCxcbiAgICAgICAgICAgIGBub2RlUmVjdCh3PSR7ci53aWR0aC50b0ZpeGVkKDEpfSxoPSR7ci5oZWlnaHQudG9GaXhlZCgxKX0pYCxcbiAgICAgICAgICAgIGB3PSR7dHJhbnNmb3JtRGF0YS53aWR0aCA/PyBcIuKIhVwifWAsXG4gICAgICAgICAgICBgaD0ke3RyYW5zZm9ybURhdGEuaGVpZ2h0ID8/IFwi4oiFXCJ9YFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZW4gb25UcmFuc2Zvcm06XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIG9uVHJhbnNmb3JtRW5kPXsoZSkgPT4ge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybWVyUmVmLmN1cnJlbnQgfHwgIW9uVHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgdHIgPSB0cmFuc2Zvcm1lclJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBub2RlcyA9IHR5cGVvZiB0ci5ub2RlcyA9PT0gXCJmdW5jdGlvblwiID8gdHIubm9kZXMoKSB8fCBbXSA6IFtdO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTVVMVEktU0VMRUNDScOTTlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRTY2FsZVggPSB0eXBlb2YgdHIuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyB0ci5zY2FsZVgoKSB8fCAxIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHRTY2FsZVkgPSB0eXBlb2YgdHIuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyB0ci5zY2FsZVkoKSB8fCAxIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGF2ZyA9IChNYXRoLmFicyh0U2NhbGVYKSArIE1hdGguYWJzKHRTY2FsZVkpKSAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBub2Rlc1xuICAgICAgICAgICAgICAubWFwKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWQgPSAodHlwZW9mIG4uaWQgPT09IFwiZnVuY3Rpb25cIiA/IG4uaWQoKSA6IG4uYXR0cnM/LmlkKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggeyB9XG4gICAgICAgICAgICAgICAgaWYgKCFpZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSAob2JqZXRvcyB8fCBbXSkuZmluZCgobykgPT4gby5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgICAgIGlmICghb2JqKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZCA9IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgeDogdHlwZW9mIG4ueCA9PT0gXCJmdW5jdGlvblwiID8gbi54KCkgOiBvYmoueCxcbiAgICAgICAgICAgICAgICAgIHk6IHR5cGVvZiBuLnkgPT09IFwiZnVuY3Rpb25cIiA/IG4ueSgpIDogb2JqLnksXG4gICAgICAgICAgICAgICAgICByb3RhdGlvbjogdHlwZW9mIG4ucm90YXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IG4ucm90YXRpb24oKSB8fCAwIDogKG9iai5yb3RhdGlvbiB8fCAwKSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai50aXBvID09PSBcInRleHRvXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBvYmouZm9udFNpemUgfHwgMjQ7XG4gICAgICAgICAgICAgICAgICB1cGQuZm9udFNpemUgPSBNYXRoLm1heCg2LCBNYXRoLnJvdW5kKGJhc2UgKiBhdmcpKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VSID0gb2JqLnJhZGl1cyB8fCA1MDtcbiAgICAgICAgICAgICAgICAgIHVwZC5yYWRpdXMgPSBiYXNlUiAqIGF2ZztcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJmb3JtYVwiICYmIG9iai5maWd1cmEgPT09IFwidHJpYW5nbGVcIikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVIgPSBvYmoucmFkaXVzIHx8IDYwO1xuICAgICAgICAgICAgICAgICAgdXBkLnJhZGl1cyA9IE1hdGgubWF4KDEsIGJhc2VSICogYXZnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5zY2FsZVggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbi5zY2FsZVkoMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvYmoudGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY291bnRkb3duU2l6ZSA9IGdldENvdW50ZG93blNjYWxlZFNpemUobik7XG4gICAgICAgICAgICAgICAgICB1cGQud2lkdGggPSBjb3VudGRvd25TaXplLndpZHRoO1xuICAgICAgICAgICAgICAgICAgdXBkLmhlaWdodCA9IGNvdW50ZG93blNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVyA9XG4gICAgICAgICAgICAgICAgICBvYmoud2lkdGggIT0gbnVsbCA/IG9iai53aWR0aCA6ICh0eXBlb2Ygbi53aWR0aCA9PT0gXCJmdW5jdGlvblwiID8gbi53aWR0aCgpIDogMTAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSCA9XG4gICAgICAgICAgICAgICAgICBvYmouaGVpZ2h0ICE9IG51bGwgPyBvYmouaGVpZ2h0IDogKHR5cGVvZiBuLmhlaWdodCA9PT0gXCJmdW5jdGlvblwiID8gbi5oZWlnaHQoKSA6IDEwMCk7XG5cbiAgICAgICAgICAgICAgICB1cGQud2lkdGggPSBNYXRoLmFicyhiYXNlVyAqIHRTY2FsZVgpO1xuICAgICAgICAgICAgICAgIHVwZC5oZWlnaHQgPSBNYXRoLmFicyhiYXNlSCAqIHRTY2FsZVkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICBuLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgICAgIG4uc2NhbGVZKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICAgICAgICBvblRyYW5zZm9ybSh7IGlzRmluYWw6IHRydWUsIGJhdGNoOiB1cGRhdGVzIH0pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRyLnNjYWxlWCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRyLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgdHIuc2NhbGVZKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IHsgaXNSZXNpemluZzogZmFsc2UgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB3aW5kb3cuX3Jlc2l6ZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgfSwgMTAwKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZW4gb25UcmFuc2Zvcm1FbmQgKG11bHRpKTpcIiwgZXJyKTtcbiAgICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTSU5HTEUtU0VMRUNDScOTTlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwb3NlID0gZ2V0VHJhbnNmb3JtUG9zZShub2RlKTtcbiAgICAgICAgICBjb25zdCBmaW5hbERhdGEgPSB7XG4gICAgICAgICAgICB4OiBwb3NlLngsXG4gICAgICAgICAgICB5OiBwb3NlLnksXG4gICAgICAgICAgICByb3RhdGlvbjogcG9zZS5yb3RhdGlvbixcbiAgICAgICAgICAgIGlzRmluYWw6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsZXQgdGV4dFByZXZpZXdFbmRTbmFwc2hvdCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZXNUZXh0bykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHByaW1lckVsZW1lbnRvLmZvbnRTaXplIHx8IDI0O1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gdHlwZW9mIG5vZGUuc2NhbGVYID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWCgpIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlWSA9IHR5cGVvZiBub2RlLnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5zY2FsZVkoKSA6IDE7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JEYXRhID0gdGV4dFRyYW5zZm9ybUFuY2hvclJlZi5jdXJyZW50IHx8IG51bGw7XG4gICAgICAgICAgICBjb25zdCBiYXNlRm9udFNpemUgPVxuICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8uYmFzZUZvbnRTaXplKSAmJlxuICAgICAgICAgICAgICBhbmNob3JEYXRhLmJhc2VGb250U2l6ZSA+IDBcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEuYmFzZUZvbnRTaXplXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEZvbnRTaXplO1xuICAgICAgICAgICAgY29uc3QgYXZnU2NhbGUgPSAoTWF0aC5hYnMoc2NhbGVYKSArIE1hdGguYWJzKHNjYWxlWSkpIC8gMjtcbiAgICAgICAgICAgIGxldCBzY2FsZUZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB2aXN1YWxXaWR0aEZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgICAgICAgIHNraXBUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgc2tpcFN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmIHJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsV2lkdGhGcm9tUmVjdCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYmFzZVdpZHRoID0gTnVtYmVyKGFuY2hvckRhdGE/LmJhc2VXaWR0aCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUoYmFzZVdpZHRoKSAmJlxuICAgICAgICAgICAgICAgIGJhc2VXaWR0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUocmVjdD8ud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA+IDBcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCA9IHJlY3Qud2lkdGggLyBiYXNlV2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVNjYWxlID1cbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHNjYWxlRnJvbVJlY3QpICYmIHNjYWxlRnJvbVJlY3QgPiAwXG4gICAgICAgICAgICAgICAgPyBzY2FsZUZyb21SZWN0XG4gICAgICAgICAgICAgICAgOiBhdmdTY2FsZTtcblxuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICBOdW1iZXIoKGJhc2VGb250U2l6ZSAqIGVmZmVjdGl2ZVNjYWxlKS50b0ZpeGVkKDMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmFsRGF0YS5mb250U2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICBOdW1iZXIoXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3Rm9udFNpemUpICYmXG4gICAgICAgICAgICAgICAgICBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Rm9udFNpemUgPiAwXG4gICAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEubGFzdFByZXZpZXdGb250U2l6ZVxuICAgICAgICAgICAgICAgICAgOiBjb21wdXRlZEZvbnRTaXplXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVYID0gMTtcbiAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShhbmNob3JEYXRhPy55KSkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEueSA9IGFuY2hvckRhdGEueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYW5jaG9yRGF0YT8ubGFzdFByZXZpZXdDZW50ZXJYKSkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dENlbnRlclggPSBhbmNob3JEYXRhLmxhc3RQcmV2aWV3Q2VudGVyWDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/LmNlbnRlclgpKSB7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA9IGFuY2hvckRhdGEuY2VudGVyWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbFdpZHRoID1cbiAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGFuY2hvckRhdGE/Lmxhc3RQcmV2aWV3VmlzdWFsV2lkdGgpICYmXG4gICAgICAgICAgICAgIGFuY2hvckRhdGEubGFzdFByZXZpZXdWaXN1YWxXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICA/IGFuY2hvckRhdGEubGFzdFByZXZpZXdWaXN1YWxXaWR0aFxuICAgICAgICAgICAgICAgIDogdmlzdWFsV2lkdGhGcm9tUmVjdDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmlzdWFsV2lkdGgpICYmIHZpc3VhbFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICBmaW5hbERhdGEudGV4dFZpc3VhbFdpZHRoID0gdmlzdWFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0UHJldmlld0VuZFNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXG4gICAgICAgICAgICAgIHg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXG4gICAgICAgICAgICAgIHk6IHR5cGVvZiBub2RlPy55ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnkoKSA6IG51bGwsXG4gICAgICAgICAgICAgIHNjYWxlWCxcbiAgICAgICAgICAgICAgc2NhbGVZLFxuICAgICAgICAgICAgICBmb250U2l6ZTogdHlwZW9mIG5vZGU/LmZvbnRTaXplID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLmZvbnRTaXplKCkgOiBudWxsLFxuICAgICAgICAgICAgICByZWN0V2lkdGg6IE51bWJlci5pc0Zpbml0ZSh2aXN1YWxXaWR0aEZyb21SZWN0KSA/IHZpc3VhbFdpZHRoRnJvbVJlY3QgOiBudWxsLFxuICAgICAgICAgICAgICByZWN0SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY3RGb3JTbmFwc2hvdCA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShyZWN0Rm9yU25hcHNob3Q/LmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQgPSByZWN0Rm9yU25hcHNob3QuaGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgICBUWFREQkcoXCJlbmRcIiwge1xuICAgICAgICAgICAgICBpZDogcHJpbWVyRWxlbWVudG8/LmlkID8/IG51bGwsXG4gICAgICAgICAgICAgIHNjYWxlWCxcbiAgICAgICAgICAgICAgc2NhbGVZLFxuICAgICAgICAgICAgICBhdmdTY2FsZSxcbiAgICAgICAgICAgICAgc2NhbGVGcm9tUmVjdCxcbiAgICAgICAgICAgICAgZWZmZWN0aXZlU2NhbGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkRm9udFNpemUsXG4gICAgICAgICAgICAgIGZpbmFsRm9udFNpemU6IGZpbmFsRGF0YS5mb250U2l6ZSxcbiAgICAgICAgICAgICAgdGV4dENlbnRlclg6IGZpbmFsRGF0YS50ZXh0Q2VudGVyWCA/PyBudWxsLFxuICAgICAgICAgICAgICB0ZXh0VmlzdWFsV2lkdGg6IGZpbmFsRGF0YS50ZXh0VmlzdWFsV2lkdGggPz8gbnVsbCxcbiAgICAgICAgICAgICAgbm9kZVJlY3RXaWR0aDogdmlzdWFsV2lkdGhGcm9tUmVjdCxcbiAgICAgICAgICAgICAgbm9kZVg6IHR5cGVvZiBub2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLngoKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5vZGVZOiB0eXBlb2Ygbm9kZT8ueSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS55KCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFBhcmEgdGV4dG8gZXZpdGFtb3MgYXBsYW5hciBhbnRlcyBkZWwgY29tbWl0IGVuIFJlYWN0LFxuICAgICAgICAgICAgLy8gYXPDrSBubyBhcGFyZWNlIHVuIGZyYW1lIGludGVybWVkaW8gY29uIHRhbWHDsW8gXCJzYWx0YWRvXCIuXG4gICAgICAgICAgICB0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZVggPSB0eXBlb2Ygbm9kZS5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IG5vZGUuc2NhbGVYKCkgOiAxO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gdHlwZW9mIG5vZGUuc2NhbGVZID09PSBcImZ1bmN0aW9uXCIgPyBub2RlLnNjYWxlWSgpIDogMTtcbiAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8udGlwbyA9PT0gXCJjb3VudGRvd25cIikge1xuICAgICAgICAgICAgICAvLyBDb3VudGRvd246IHBlcnNpc3RpciBlc2NhbGEgcmVhbCBwYXJhIHF1ZSBlbCByZXN1bHRhZG8gZmluYWxcbiAgICAgICAgICAgICAgLy8gc2VhIGV4YWN0YW1lbnRlIGVsIG1pc21vIHF1ZSBzZSB2ZSBhbCBzb2x0YXIuXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50ZG93blNpemUgPSBnZXRDb3VudGRvd25TY2FsZWRTaXplKG5vZGUpO1xuICAgICAgICAgICAgICBmaW5hbERhdGEud2lkdGggPSBjb3VudGRvd25TaXplLndpZHRoO1xuICAgICAgICAgICAgICBmaW5hbERhdGEuaGVpZ2h0ID0gY291bnRkb3duU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVzVHJpYW5ndWxvKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VSYWRpdXMgPSBOdW1iZXIuaXNGaW5pdGUocHJpbWVyRWxlbWVudG8/LnJhZGl1cylcbiAgICAgICAgICAgICAgICA/IHByaW1lckVsZW1lbnRvLnJhZGl1c1xuICAgICAgICAgICAgICAgIDogNjA7XG4gICAgICAgICAgICAgIGNvbnN0IGF2Z1NjYWxlID0gKE1hdGguYWJzKHNjYWxlWCkgKyBNYXRoLmFicyhzY2FsZVkpKSAvIDI7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSAxO1xuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gMTtcbiAgICAgICAgICAgICAgZmluYWxEYXRhLnJhZGl1cyA9IE1hdGgubWF4KDEsIGJhc2VSYWRpdXMgKiBhdmdTY2FsZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWCgxKTtcbiAgICAgICAgICAgICAgICBub2RlLnNjYWxlWSgxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUucmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIG5vZGUucmFkaXVzKGZpbmFsRGF0YS5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIG5vZGUuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGFwbGFuYW5kbyBlc2NhbGEgZGUgdHJpw6FuZ3VsbyAoc3luYyk6XCIsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbmFsRGF0YS5zY2FsZVggPSAxO1xuICAgICAgICAgICAgICBmaW5hbERhdGEuc2NhbGVZID0gMTtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHByaW1lckVsZW1lbnRvLndpZHRoIHx8IDEwMDtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSBwcmltZXJFbGVtZW50by5oZWlnaHQgfHwgMTAwO1xuXG4gICAgICAgICAgICAgIGZpbmFsRGF0YS53aWR0aCA9IE1hdGguYWJzKG9yaWdpbmFsV2lkdGggKiBzY2FsZVgpO1xuICAgICAgICAgICAgICBmaW5hbERhdGEuaGVpZ2h0ID0gTWF0aC5hYnMob3JpZ2luYWxIZWlnaHQgKiBzY2FsZVkpO1xuXG4gICAgICAgICAgICAgIGlmIChwcmltZXJFbGVtZW50bz8uZmlndXJhID09PSBcImNpcmNsZVwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpdmVSZWN0ID0gbm9kZS5nZXRDbGllbnRSZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNraXBTdHJva2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRpYW1ldGVyID0gTWF0aC5tYXgoMSwgTWF0aC5tYXgobGl2ZVJlY3Qud2lkdGgsIGxpdmVSZWN0LmhlaWdodCkpO1xuICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnJhZGl1cyA9IGRpYW1ldGVyIC8gMjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGNpcmNsZUFuY2hvclJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGEueCA9IGFuY2hvci5sZWZ0ICsgZmluYWxEYXRhLnJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEYXRhLnkgPSBhbmNob3IudG9wICsgZmluYWxEYXRhLnJhZGl1cztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS54ID0gbGl2ZVJlY3QueCArIGZpbmFsRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS55ID0gbGl2ZVJlY3QueSArIGZpbmFsRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8g4pyFIEFwbGFuYXIgZXNjYWxhIElOTUVESUFUT1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ3ID0gZmluYWxEYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZoID0gZmluYWxEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIG5vZGUuc2NhbGVYKDEpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2NhbGVZKDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZ3ICE9IG51bGwgJiYgdHlwZW9mIG5vZGUud2lkdGggPT09IFwiZnVuY3Rpb25cIikgbm9kZS53aWR0aChmdyk7XG4gICAgICAgICAgICAgICAgaWYgKGZoICE9IG51bGwgJiYgdHlwZW9mIG5vZGUuaGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIpIG5vZGUuaGVpZ2h0KGZoKTtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHByaW1lckVsZW1lbnRvPy5maWd1cmEgPT09IFwiY2lyY2xlXCIgJiZcbiAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YS5yYWRpdXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUucmFkaXVzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIG5vZGUucmFkaXVzKGZpbmFsRGF0YS5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0TGF5ZXIoKT8uYmF0Y2hEcmF3KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGFwbGFuYW5kbyBlc2NhbGFzIChzeW5jKTpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9uVHJhbnNmb3JtKGZpbmFsRGF0YSk7XG4gICAgICAgICAgY2lyY2xlQW5jaG9yUmVmLmN1cnJlbnQgPSBudWxsO1xuXG5cbiAgICAgICAgICAvLyDinIUgUmVhdGFjaGFyIDEgdmV6LCBjb24gcmVmIGZyZXNjbywgZW4gZWwgcHLDs3hpbW8gZnJhbWVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHIyID0gdHJhbnNmb3JtZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghdHIyKSByZXR1cm47XG5cbiAgICAgICAgICAgIFRSREJHKFwib25UcmFuc2Zvcm1FbmQgLT4gc2NoZWR1bGUgUkFGIHJlYXR0YWNoXCIsIHtcbiAgICAgICAgICAgICAgc2VsS2V5OiBzZWxlY3RlZEVsZW1lbnRzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICBpZFNlbDogc2VsZWN0ZWRFbGVtZW50cz8uWzBdIHx8IG51bGxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpZFNlbCA9IHNlbGVjdGVkRWxlbWVudHM/LlswXTtcbiAgICAgICAgICAgICAgY29uc3QgZnJlc2hOb2RlID0gaWRTZWwgPyBlbGVtZW50UmVmcy5jdXJyZW50Py5baWRTZWxdIDogbnVsbDtcblxuICAgICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIFJBRlwiLCB7XG4gICAgICAgICAgICAgICAgaWRTZWwsXG4gICAgICAgICAgICAgICAgaGFzRnJlc2g6ICEhZnJlc2hOb2RlLFxuICAgICAgICAgICAgICAgIGRlc3Ryb3llZDogISFmcmVzaE5vZGU/Ll9kZXN0cm95ZWQsXG4gICAgICAgICAgICAgICAgaGFzU3RhZ2U6ICEhZnJlc2hOb2RlPy5nZXRTdGFnZT8uKCksXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFNpIGVsIG5vZG8gbm8gZXN0w6EgbGlzdG8sIGRlc3BlZ2FyIHkgc2FsaXJcbiAgICAgICAgICAgICAgaWYgKCFmcmVzaE5vZGUgfHwgZnJlc2hOb2RlLl9kZXN0cm95ZWQgfHwgIWZyZXNoTm9kZS5nZXRTdGFnZT8uKCkpIHtcbiAgICAgICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIFJBRiAtPiBERVRBQ0ggbm9kZXMoW10pXCIsIHsgaWRTZWwgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgdHIyLm5vZGVzKFtdKTsgdHIyLmdldExheWVyPy4oKT8uYmF0Y2hEcmF3KCk7IH0gY2F0Y2ggeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBUUkRCRyhcIm9uVHJhbnNmb3JtRW5kIFJBRiAtPiBERVRBQ0ggbm9kZXMoW10pXCIsIHsgaWRTZWwgfSk7XG4gICAgICAgICAgICAgICAgdHIyLm5vZGVzKFtmcmVzaE5vZGVdKTtcbiAgICAgICAgICAgICAgICB0cjIuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB0cjIuZ2V0TGF5ZXI/LigpPy5iYXRjaERyYXcoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0UHJldmlld0VuZFNuYXBzaG90ICYmIGZyZXNoTm9kZSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdFJlY3QgPSBmcmVzaE5vZGUuZ2V0Q2xpZW50UmVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgc2tpcFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgc2tpcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBza2lwU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgVFhUREJHKFwicG9zdC1jb21taXQ6cmFmMVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkU2VsLFxuICAgICAgICAgICAgICAgICAgICAgIHByZTogdGV4dFByZXZpZXdFbmRTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0eXBlb2YgZnJlc2hOb2RlPy54ID09PSBcImZ1bmN0aW9uXCIgPyBmcmVzaE5vZGUueCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHR5cGVvZiBmcmVzaE5vZGU/LnkgPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS55KCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVYOiB0eXBlb2YgZnJlc2hOb2RlPy5zY2FsZVggPT09IFwiZnVuY3Rpb25cIiA/IGZyZXNoTm9kZS5zY2FsZVgoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IHR5cGVvZiBmcmVzaE5vZGU/LnNjYWxlWSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLnNjYWxlWSgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0eXBlb2YgZnJlc2hOb2RlPy5mb250U2l6ZSA9PT0gXCJmdW5jdGlvblwiID8gZnJlc2hOb2RlLmZvbnRTaXplKCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpZHRoOiBOdW1iZXIuaXNGaW5pdGUocG9zdFJlY3Q/LndpZHRoKSA/IHBvc3RSZWN0LndpZHRoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIZWlnaHQ6IE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8uaGVpZ2h0KSA/IHBvc3RSZWN0LmhlaWdodCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShwb3N0UmVjdD8ud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChwb3N0UmVjdC53aWR0aCAtIHRleHRQcmV2aWV3RW5kU25hcHNob3QucmVjdFdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHBvc3RSZWN0Py5oZWlnaHQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZSh0ZXh0UHJldmlld0VuZFNuYXBzaG90LnJlY3RIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocG9zdFJlY3QuaGVpZ2h0IC0gdGV4dFByZXZpZXdFbmRTbmFwc2hvdC5yZWN0SGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIHsgfVxuXG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBlbiBvblRyYW5zZm9ybUVuZDpcIiwgZXJyb3IpO1xuICAgICAgICAgIHdpbmRvdy5fcmVzaXplRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH19XG5cbiAgICAvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiVHJhbnNmb3JtZXIiLCJSZWN0IiwiREVCVUdfU0VMRUNUSU9OX0JPVU5EUyIsInNiTG9nIiwiYXJncyIsImNvbnNvbGUiLCJsb2ciLCJzbG9nIiwiVFJEQkciLCJ3aW5kb3ciLCJfX0RCR19UUiIsIlRYVERCRyIsIl9fREJHX1RFWFRfUkVTSVpFIiwicmVjdEZyb21Ob2RlcyIsIm5vZGVzIiwibWluWCIsIkluZmluaXR5IiwibWluWSIsIm1heFgiLCJtYXhZIiwibiIsImdldENsaWVudFJlY3QiLCJyIiwic2tpcFRyYW5zZm9ybSIsInNraXBTaGFkb3ciLCJza2lwU3Ryb2tlIiwiTWF0aCIsIm1pbiIsIngiLCJ5IiwibWF4Iiwid2lkdGgiLCJoZWlnaHQiLCJnZXRDb3VudGRvd25TY2FsZWRTaXplIiwibm9kZSIsImhpdGJveCIsImZpbmRPbmUiLCJiYXNlVyIsIk5hTiIsImJhc2VIIiwic3giLCJhYnMiLCJzY2FsZVgiLCJzeSIsInNjYWxlWSIsIk51bWJlciIsImlzRmluaXRlIiwiQm91bmRzSW5kaWNhdG9yIiwic2VsZWN0ZWRFbGVtZW50cyIsImVsZW1lbnRSZWZzIiwib2JqZXRvcyIsImZvcmNlVXBkYXRlIiwic2V0Rm9yY2VVcGRhdGUiLCJmaXJzdFJlZiIsImN1cnJlbnQiLCJzdGFnZSIsImdldFN0YWdlIiwiaGFuZGxlRHJhZ01vdmUiLCJwIiwib24iLCJvZmYiLCJqb2luIiwiZWxlbWVudG9zRGF0YSIsIm1hcCIsImlkIiwiZmluZCIsIm9iaiIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJmb3JFYWNoIiwidGlwbyIsImZpZ3VyYSIsInBvaW50cyIsImNsZWFuUG9pbnRzIiwicGFyc2VGbG9hdCIsInJlYWxYIiwicmVhbFkiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbmVQYWRkaW5nIiwiYm94IiwidG9GaXhlZCIsImdldFRleHRIZWlnaHQiLCJ0ZXh0SGVpZ2h0IiwiZXJyb3IiLCJmYWxsYmFja1giLCJmYWxsYmFja1kiLCJmYWxsYmFja1NpemUiLCJwcmltZXJFbGVtZW50byIsInBhZGRpbmciLCJmaW5hbFgiLCJmaW5hbFkiLCJmaW5hbFdpZHRoIiwiZmluYWxIZWlnaHQiLCJuYW1lIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwibGlzdGVuaW5nIiwib3BhY2l0eSIsIlNlbGVjdGlvbkJvdW5kcyIsIm9uVHJhbnNmb3JtIiwiaXNEcmFnZ2luZyIsInRyYW5zZm9ybWVyUmVmIiwidHJhbnNmb3JtVGljayIsInNldFRyYW5zZm9ybVRpY2siLCJsYXN0Tm9kZXNSZWYiLCJjaXJjbGVBbmNob3JSZWYiLCJ0ZXh0VHJhbnNmb3JtQW5jaG9yUmVmIiwiZWxlbWVudG9zU2VsZWNjaW9uYWRvc0RhdGEiLCJlc1RleHRvIiwiZXNDb3VudGRvd24iLCJlc0dhbGVyaWEiLCJsb2NrQXNwZWN0Q291bnRkb3duIiwidHJhbnNmb3JtZXJBbmNob3JTaXplIiwidHJhbnNmb3JtZXJSb3RhdGVPZmZzZXQiLCJ0cmFuc2Zvcm1lckFuY2hvclJhZGl1cyIsImVzVHJpYW5ndWxvIiwiaGFzR2FsbGVyeSIsInNvbWUiLCJvIiwiaGF5TGluZWFzIiwiZWxlbWVudG9zVHJhbnNmb3JtYWJsZXMiLCJkZWJlcmlhVXNhclRyYW5zZm9ybWVyIiwic2VsZWN0ZWRHZW9tS2V5Iiwicm90YXRpb24iLCJjaGlwV2lkdGgiLCJnYXAiLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwiZ2V0VHJhbnNmb3JtUG9zZSIsImdldFBhcmVudCIsInBhcmVudCIsInRyIiwic2VsS2V5IiwiZWxlbWVudG9zVHJhbnNmb3JtYWJsZXNMZW4iLCJlZGl0aW5nSWQiLCJlZGl0aW5nIiwibm9kb3NUcmFuc2Zvcm1hYmxlcyIsImlkU2VsIiwicmVmTm9kZSIsImdhbGxlcnlGcmFtZSIsIndhbnRlZElkcyIsInJlZnNQcmVzZW50Iiwibm9kZXNDb3VudCIsIm5vZGVJZHMiLCJhdHRycyIsInRyTm9kZXNDb3VudCIsImdldExheWVyIiwiYmF0Y2hEcmF3IiwiaGFuZGxlciIsImUiLCJkZXRhaWwiLCJpc1NlbGVjdGVkIiwiaW5jbHVkZXMiLCJ0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaXJzdE5vZGUiLCJmaXJzdElkIiwicmFmSWQiLCJzeW5jVHJhbnNmb3JtZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlZiIsImJvcmRlckVuYWJsZWQiLCJib3JkZXJTdHJva2UiLCJib3JkZXJTdHJva2VXaWR0aCIsImVuYWJsZWRBbmNob3JzIiwicm90YXRlRW5hYmxlZCIsImFuY2hvckZpbGwiLCJhbmNob3JTdHJva2UiLCJhbmNob3JTdHJva2VXaWR0aCIsImFuY2hvclNpemUiLCJhbmNob3JDb3JuZXJSYWRpdXMiLCJhbmNob3JTaGFkb3dDb2xvciIsImFuY2hvclNoYWRvd0JsdXIiLCJhbmNob3JTaGFkb3dPZmZzZXQiLCJrZWVwUmF0aW8iLCJjZW50ZXJlZFNjYWxpbmciLCJmbGlwRW5hYmxlZCIsInJlc2l6ZUVuYWJsZWQiLCJyb3RhdGlvblNuYXBzIiwicm90YXRlQW5jaG9yT2Zmc2V0Iiwicm90YXRpb25TbmFwVG9sZXJhbmNlIiwiYm91bmRCb3hGdW5jIiwib2xkQm94IiwibmV3Qm94IiwibWluU2l6ZSIsIm1heFNpemUiLCJyb3dzIiwiY29scyIsImNlbGxSYXRpbyIsInJhdGlvIiwibWluR3JpZFdpZHRoIiwibmV4dFdpZHRoIiwiY2VsbFciLCJjZWxsSCIsIm5leHRIZWlnaHQiLCJkdyIsImRoIiwidW5pZm9ybVNjYWxlIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJzaXplIiwiZmluYWxTaXplIiwic2FmZU9sZFciLCJzYWZlT2xkSCIsIm9uVHJhbnNmb3JtU3RhcnQiLCJfcmVzaXplRGF0YSIsImlzUmVzaXppbmciLCJyMCIsImxlZnQiLCJ0b3AiLCJjZW50ZXJYIiwiYmFzZVdpZHRoIiwiYmFzZUhlaWdodCIsImJhc2VWaXN1YWxXaWR0aCIsInJlY3QiLCJzYWZlQmFzZUZvbnRTaXplIiwiZm9udFNpemUiLCJiYXNlRm9udFNpemUiLCJsYXN0UHJldmlld0ZvbnRTaXplIiwibGFzdFByZXZpZXdDZW50ZXJYIiwibGFzdFByZXZpZXdWaXN1YWxXaWR0aCIsInByZXZpZXdUaWNrIiwibm9kZVgiLCJub2RlWSIsIm5vZGVTY2FsZVgiLCJub2RlU2NhbGVZIiwidW5pb24iLCJwYWQiLCJib3JkZXJSZWN0IiwidHJSZWN0IiwicG9zZSIsInRyYW5zZm9ybURhdGEiLCJpc1ByZXZpZXciLCJvcmlnaW5hbEZvbnRTaXplIiwiYW5jaG9yRGF0YSIsImF2Z1NjYWxlIiwic2NhbGVGcm9tUmVjdCIsImxpdmVSZWN0V2lkdGgiLCJlZmZlY3RpdmVTY2FsZSIsInRpY2siLCJjZW50ZXJYVGFyZ2V0IiwidGV4dENlbnRlclgiLCJjdXJyZW50Q2VudGVyWCIsImRlbHRhWCIsInRhcmdldENlbnRlclgiLCJjb3VudGRvd25TaXplIiwiYmFzZVJhZGl1cyIsInJhZGl1cyIsIm9yaWdpbmFsV2lkdGgiLCJvcmlnaW5hbEhlaWdodCIsImxpdmVSZWN0IiwiZGlhbWV0ZXIiLCJhbmNob3IiLCJ3YXJuIiwib25UcmFuc2Zvcm1FbmQiLCJ0U2NhbGVYIiwidFNjYWxlWSIsImF2ZyIsInVwZGF0ZXMiLCJ1cGQiLCJiYXNlIiwicm91bmQiLCJiYXNlUiIsImlzRmluYWwiLCJiYXRjaCIsInNldFRpbWVvdXQiLCJlcnIiLCJmaW5hbERhdGEiLCJ0ZXh0UHJldmlld0VuZFNuYXBzaG90IiwidmlzdWFsV2lkdGhGcm9tUmVjdCIsImNvbXB1dGVkRm9udFNpemUiLCJ2aXN1YWxXaWR0aCIsInRleHRWaXN1YWxXaWR0aCIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJyZWN0Rm9yU25hcHNob3QiLCJmaW5hbEZvbnRTaXplIiwibm9kZVJlY3RXaWR0aCIsImZ3IiwiZmgiLCJ0cjIiLCJmcmVzaE5vZGUiLCJoYXNGcmVzaCIsImRlc3Ryb3llZCIsIl9kZXN0cm95ZWQiLCJoYXNTdGFnZSIsInBvc3RSZWN0IiwicHJlIiwicG9zdCIsImRlbHRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/SelectionBounds.jsx\n"));

/***/ })

});