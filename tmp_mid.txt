  return (
    <div className="space-y-1 text-[11px] font-medium text-slate-600">
      <span>Color del frame</span>
      <div className="grid grid-cols-2 rounded-lg border border-slate-300 bg-white p-0.5">
        <PaintModeButton
          active={!isTransparent}
          onClick={() => onChange(colorValue)}
        >
          Color
        </PaintModeButton>
        <PaintModeButton
          active={isTransparent}
          onClick={() => onChange("transparent")}
        >
          Transparente
        </PaintModeButton>
      </div>

      {!isTransparent ? (
        <div className="flex items-center justify-between gap-2 rounded-lg border border-slate-300 bg-white px-2 py-1.5">
          <span
            className="max-w-[110px] truncate text-[11px] font-semibold text-slate-700"
            title={colorValue}
          >
            {colorValue.toLowerCase().startsWith("linear-gradient(") ? "Gradiente" : colorValue.toUpperCase()}
          </span>
          <UnifiedColorPicker
            value={colorValue}
            onChange={onChange}
            fallbackColor="#773dbe"
            panelWidth={272}
            showGradients={false}
            title="Cambiar color del frame"
            triggerClassName="h-7 w-7 rounded border border-slate-300"
          />
        </div>
      ) : (
        <p className="rounded-lg border border-dashed border-slate-300 bg-white px-2 py-1.5 text-[11px] text-slate-500">
          Sin borde general visible.
        </p>
      )}
    </div>
  );
}

export default function CountdownPresetForm({
  selectedPreset,
  saving,
  publishing,
  archiving,
  deleting,
  onSaveDraft,
  onPublishDraft,
  onToggleArchive,
  onDeletePreset,
  lastMessage,
}) {
  const [formState, setFormState] = useState(() => buildStateFromPreset(null));
  const [targetISO, setTargetISO] = useState(() => createFutureDateISO(45));
  const [errorMessage, setErrorMessage] = useState("");
  const [validationWarnings, setValidationWarnings] = useState([]);

  useEffect(() => {
    setFormState(buildStateFromPreset(selectedPreset));
    setErrorMessage("");
    setValidationWarnings([]);
  }, [selectedPreset]);

  useEffect(() => {
    const sourceUrl = formState?.svgAsset?.downloadUrl || formState?.svgAsset?.previewUrl;
    const hasSvgText = typeof formState?.svgAsset?.svgText === "string" && formState.svgAsset.svgText.trim();
    if (!sourceUrl || hasSvgText) return;
    let cancelled = false;
    (async () => {
      try {
        const response = await fetch(sourceUrl);
        if (!response.ok) return;
        const svgText = await response.text();
        if (cancelled || !svgText.trim()) return;
        setFormState((prev) =>
          !prev?.svgAsset || (prev.svgAsset.svgText || "").trim()
            ? prev
            : { ...prev, svgAsset: { ...prev.svgAsset, svgText } }
        );
      } catch {
        // Non-blocking.
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [formState?.svgAsset?.downloadUrl, formState?.svgAsset?.previewUrl, formState?.svgAsset?.svgText]);

  const setConfigField = (section, key, value) =>
    setFormState((prev) => ({
      ...prev,
      config: { ...prev.config, [section]: { ...prev.config[section], [key]: value } },
    }));

  const visibleUnits = formState.config.layout.visibleUnits || [];
  const canPublish = Boolean(selectedPreset?.id && selectedPreset?.draftVersion);
  const isPublished = selectedPreset?.estado === "published";
  const canDelete = Boolean(selectedPreset?.id && !isPublished);
  const isArchived = selectedPreset?.estado === "archived";
  const isLegacyPreset = isLegacyPresetSource(selectedPreset);
  const useLegacyCanvasPreview =
    isLegacyPreset &&
    !formState?.svgAsset?.isDirty &&
    !String(formState?.svgAsset?.svgText || "").trim();
  const archiveActionLabel = resolveArchiveActionLabel(selectedPreset);
  const currentStatus = selectedPreset?.estado || "draft";
  const svgColorMode = formState.svgAsset?.colorMode || "fixed";
  const svgText = formState.svgAsset?.svgText || "";
  const frameUrl =
    formState?.svgAsset?.previewUrl ||
    formState?.svgAsset?.downloadUrl ||
    selectedPreset?.draft?.svgRef?.downloadUrl ||
    selectedPreset?.svgRef?.downloadUrl ||
    "";
  const previewConfig = useMemo(() => formState.config || createDefaultCountdownPresetConfig(), [formState.config]);

  const toggleUnit = (unit) =>
    setFormState((prev) => {
      const current = prev.config.layout.visibleUnits || [];
      const next = current.includes(unit) ? current.filter((item) => item !== unit) : [...current, unit];
      return { ...prev, config: { ...prev.config, layout: { ...prev.config.layout, visibleUnits: next } } };
    });

  const handleSaveDraft = async () => {
    setErrorMessage("");
    setValidationWarnings([]);
    const validation = validateCountdownPresetInput({
      nombre: formState.nombre,
      categoria: formState.categoria,
      config: { ...formState.config, svgRef: { colorMode: svgColorMode } },
      svgInspection: formState.svgAsset?.inspection || null,
    });
    if (!validation.valid) {
      setErrorMessage(validation.errors.join(" "));
      setValidationWarnings(validation.warnings);
      return;
    }

    const svgTextForPayload = formState.svgAsset?.svgText || "";
    if (!svgTextForPayload && !selectedPreset?.svgRef?.downloadUrl && !isLegacyPreset) {
      setErrorMessage("Debes subir un SVG valido antes de guardar.");
      return;
    }

    try {
      const thumbnailDataUrl = await generateCountdownThumbnailDataUrl({
        config: validation.normalized.config,
        svgText: svgTextForPayload || selectedPreset?.svgRef?.svgText || "",
        svgColorMode,
        frameColor: validation.normalized.config.colores.frameColor,
        size: 320,
        targetISO,
      });
      await onSaveDraft?.({
        presetId: selectedPreset?.id || null,
        nombre: validation.normalized.nombre,
        categoria: validation.normalized.categoria,
        expectedDraftVersion: selectedPreset?.draftVersion ?? null,
        config: { ...validation.normalized.config, svgRef: { colorMode: svgColorMode } },
        assets: {
          svgFileName: formState.svgAsset?.isDirty ? formState.svgAsset?.fileName : null,
          svgBase64: formState.svgAsset?.isDirty ? formState.svgAsset?.svgBase64 : null,
          thumbnailPngBase64: dataUrlToBase64(thumbnailDataUrl),
        },
      });
      setValidationWarnings(validation.warnings);
      setFormState((prev) => ({ ...prev, svgAsset: prev.svgAsset ? { ...prev.svgAsset, isDirty: false } : prev.svgAsset }));
    } catch (error) {
      setErrorMessage(getErrorMessage(error, "No se pudo guardar el borrador."));
    }
  };

  const handlePublish = async () => {
    setErrorMessage("");
    if (!selectedPreset?.id || !selectedPreset?.draftVersion) {
      setErrorMessage("No hay borrador pendiente para publicar.");
      return;
    }
    try {
      await onPublishDraft?.({
        presetId: selectedPreset.id,
        expectedDraftVersion: selectedPreset.draftVersion,
      });
    } catch (error) {
      setErrorMessage(getErrorMessage(error, "No se pudo publicar el preset."));
    }
  };

  const handleArchiveToggle = async () => {
    setErrorMessage("");
    if (!selectedPreset?.id) return;
    try {
      await onToggleArchive?.({ presetId: selectedPreset.id, archived: !isArchived });
    } catch (error) {
      setErrorMessage(getErrorMessage(error, "No se pudo actualizar el estado del preset."));
    }
  };

  const handleDeletePreset = async () => {
    setErrorMessage("");
    if (!selectedPreset?.id || !canDelete) return;
    const confirmed =
      typeof window === "undefined"
        ? true
        : window.confirm("Se eliminara este preset con todas sus versiones y assets. Esta accion no se puede deshacer.");
    if (!confirmed) return;
    try {
      await onDeletePreset?.({ presetId: selectedPreset.id });
    } catch (error) {
      setErrorMessage(getErrorMessage(error, "No se pudo eliminar el preset."));
    }
  };

  return (
    <section className="rounded-2xl border border-slate-200 bg-white p-3 lg:flex lg:h-full lg:min-h-0 lg:flex-col">
      <header className="mb-2 flex flex-wrap items-start justify-between gap-2">
        <div>
          <h2 className="text-sm font-semibold text-slate-900">{selectedPreset?.id ? "Editar preset" : "Nuevo preset"}</h2>
          <p className="text-[11px] text-slate-600">Estado actual: <span className="font-semibold">{currentStatus}</span></p>
        </div>
        <div className="flex flex-wrap gap-2">
          {selectedPreset?.id ? (
            <button
              type="button"
              onClick={handleDeletePreset}
              disabled={deleting || !canDelete}
              title={canDelete ? "Eliminar preset" : "Solo puedes eliminar presets despublicados (draft o archived)."}
              className="rounded-lg border border-rose-300 bg-rose-50 px-3 py-1.5 text-xs font-semibold text-rose-700 hover:bg-rose-100 disabled:cursor-not-allowed disabled:opacity-50"
            >
              {deleting ? "Eliminando..." : "Eliminar"}
            </button>
          ) : null}
          {selectedPreset?.id ? <button type="button" onClick={handleArchiveToggle} disabled={archiving} className="rounded-lg border border-slate-300 px-3 py-1.5 text-xs font-semibold text-slate-700 hover:bg-slate-50 disabled:opacity-50">{archiving ? "Procesando..." : archiveActionLabel}</button> : null}
          <button type="button" onClick={handleSaveDraft} disabled={saving} className="rounded-lg border border-violet-200 bg-violet-50 px-3 py-1.5 text-xs font-semibold text-violet-700 hover:bg-violet-100 disabled:opacity-50">{saving ? "Guardando..." : "Guardar borrador"}</button>
          <button type="button" onClick={handlePublish} disabled={!canPublish || publishing} className="rounded-lg bg-emerald-600 px-3 py-1.5 text-xs font-semibold text-white hover:bg-emerald-700 disabled:opacity-50">{publishing ? "Publicando..." : "Publicar version"}</button>
        </div>
      </header>

      {lastMessage ? <div className="mb-2 rounded-lg border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs text-emerald-700">{lastMessage}</div> : null}
      {errorMessage ? <div className="mb-2 rounded-lg border border-rose-200 bg-rose-50 px-3 py-1.5 text-xs text-rose-700">{errorMessage}</div> : null}
      {validationWarnings.length ? <div className="mb-2 rounded-lg border border-amber-200 bg-amber-50 px-3 py-1.5 text-xs text-amber-700">{validationWarnings.join(" ")}</div> : null}
      {isLegacyPreset && !formState?.svgAsset?.previewUrl ? <div className="mb-2 rounded-lg border border-sky-200 bg-sky-50 px-3 py-1.5 text-xs text-sky-700">Preset legacy sin frame SVG. Puedes editarlo y publicarlo igual, o subir un frame nuevo.</div> : null}

      <div className="grid gap-3 lg:min-h-0 lg:flex-1 lg:grid-cols-[minmax(0,1fr)_minmax(300px,390px)] lg:overflow-hidden">
        <div className="space-y-3 lg:min-h-0 lg:overflow-y-auto lg:pr-2">
          <Card title="Datos">
            <input value={formState.nombre} onChange={(e) => setFormState((prev) => ({ ...prev, nombre: e.target.value }))} className="w-full rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm text-slate-800" placeholder="Ejemplo: Floral premium" />
            <div className="mt-2 grid gap-2 sm:grid-cols-3">
              <select value={formState.categoria.event} onChange={(e) => setFormState((prev) => ({ ...prev, categoria: normalizeCountdownCategory({ ...prev.categoria, event: e.target.value }) }))} className="rounded-lg border border-slate-300 bg-white px-2 py-2 text-xs">{COUNTDOWN_EVENT_CATEGORIES.map((key) => <option key={key} value={key}>{key}</option>)}</select>
              <select value={formState.categoria.style} onChange={(e) => setFormState((prev) => ({ ...prev, categoria: normalizeCountdownCategory({ ...prev.categoria, style: e.target.value }) }))} className="rounded-lg border border-slate-300 bg-white px-2 py-2 text-xs">{COUNTDOWN_STYLE_CATEGORIES.map((key) => <option key={key} value={key}>{key}</option>)}</select>
              <input value={formState.categoria.custom || ""} onChange={(e) => setFormState((prev) => ({ ...prev, categoria: normalizeCountdownCategory({ ...prev.categoria, custom: e.target.value }) }))} className="rounded-lg border border-slate-300 bg-white px-2 py-2 text-xs" placeholder="Custom" />
            </div>
          </Card>

          <SvgUploadInspector value={formState.svgAsset} onChange={(svgAsset) => setFormState((prev) => ({ ...prev, svgAsset }))} />
