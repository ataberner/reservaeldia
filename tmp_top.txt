import { useEffect, useMemo, useState } from "react";
import CountdownPresetLivePreview from "@/components/admin/countdown/CountdownPresetLivePreview";
import SvgUploadInspector from "@/components/admin/countdown/SvgUploadInspector";
import UnifiedColorPicker from "@/components/color/UnifiedColorPicker";
import {
  COUNTDOWN_DISTRIBUTIONS,
  COUNTDOWN_ENTRY_ANIMATIONS,
  COUNTDOWN_EVENT_CATEGORIES,
  COUNTDOWN_FRAME_ANIMATIONS,
  COUNTDOWN_LAYOUT_TYPES,
  COUNTDOWN_STYLE_CATEGORIES,
  COUNTDOWN_TICK_ANIMATIONS,
  COUNTDOWN_UNITS,
  createDefaultCountdownPresetConfig,
} from "@/domain/countdownPresets/contract";
import { createFutureDateISO, generateCountdownThumbnailDataUrl } from "@/domain/countdownPresets/renderModel";
import { normalizeCountdownCategory, validateCountdownPresetInput } from "@/domain/countdownPresets/validators";

const HEX_COLOR = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;

function getErrorMessage(error, fallback) {
  const message = error?.message || error?.details?.message || error?.details || fallback;
  return typeof message === "string" ? message : fallback;
}

function fileNameFromStoragePath(pathname) {
  const safe = String(pathname || "").trim();
  if (!safe) return "";
  const split = safe.split("/");
  return split[split.length - 1] || safe;
}

function dataUrlToBase64(dataUrl) {
  if (typeof dataUrl !== "string") return null;
  const parts = dataUrl.split(",");
  return parts.length < 2 ? null : parts[1] || null;
}

function isLegacyPresetSource(preset) {
  if (preset?.legacyPresetProps && typeof preset.legacyPresetProps === "object") {
    return true;
  }
  const migrationSource = String(preset?.metadata?.migrationSource || "");
  const isLegacySource = migrationSource.toLowerCase() === "legacy-config-v1";
  const activeVersion = Number(preset?.activeVersion || 0);
  const hasNoFrame = !String(preset?.svgRef?.storagePath || "").trim();
  return isLegacySource && activeVersion <= 1 && hasNoFrame;
}

function resolveArchiveActionLabel(preset) {
  if (!preset?.id) return "Archivar";
  if (preset?.estado === "published") return "Despublicar";
  if (preset?.estado === "archived" && Number(preset?.activeVersion || 0) > 0) return "Publicar";
  return "Archivar";
}

function buildUnitStyleFromLegacy(preset, fallback) {
  const legacy = preset?.legacyPresetProps;
  if (!legacy) return fallback;
  return {
    ...fallback,
    showLabels: legacy.showLabels !== false,
    separator: String(legacy.separator || "").slice(0, 4),
    boxBg: String(legacy.boxBg || fallback.boxBg),
    boxBorder: String(legacy.boxBorder || fallback.boxBorder),
    boxRadius: Number.isFinite(legacy.boxRadius) ? Number(legacy.boxRadius) : fallback.boxRadius,
    boxShadow: legacy.boxShadow === true,
  };
}

function buildStateFromPreset(preset) {
  const source = preset?.draft || preset || null;
  const defaults = createDefaultCountdownPresetConfig();
  const legacyUnit = buildUnitStyleFromLegacy(preset, defaults.unidad);
  const config = {
    ...defaults,
    layout: { ...defaults.layout, ...(source?.layout || {}) },
    tipografia: { ...defaults.tipografia, ...(source?.tipografia || {}) },
    colores: { ...defaults.colores, ...(source?.colores || {}) },
    animaciones: { ...defaults.animaciones, ...(source?.animaciones || {}) },
    unidad: { ...legacyUnit, ...(source?.unidad || {}) },
    tamanoBase: Number.isFinite(source?.tamanoBase) ? source.tamanoBase : defaults.tamanoBase,
  };

  const svgRef = source?.svgRef || preset?.svgRef || null;
  return {
    nombre: String(source?.nombre || preset?.nombre || ""),
    categoria: normalizeCountdownCategory(source?.categoria || preset?.categoria),
    config,
    svgAsset: svgRef
      ? {
          valid: true,
          fileName: fileNameFromStoragePath(svgRef.storagePath),
          mimeType: "image/svg+xml",
          byteSize: Number(svgRef.bytes || 0),
          svgText: typeof svgRef.svgText === "string" ? svgRef.svgText : "",
          svgBase64: null,
          previewUrl: svgRef.downloadUrl || null,
          downloadUrl: svgRef.downloadUrl || null,
          colorMode: svgRef.colorMode || "fixed",
          inspection: {
            warnings: [],
            criticalErrors: [],
            checks: {
              fileName: fileNameFromStoragePath(svgRef.storagePath),
              bytes: Number(svgRef.bytes || 0),
              viewBox: svgRef.viewBox || null,
              hasFixedDimensions: Boolean(svgRef.hasFixedDimensions),
              colorMode: svgRef.colorMode || "fixed",
            },
          },
          isDirty: false,
        }
      : null,
  };
}

function Card({ title, children }) {
  return (
    <div className="rounded-xl border border-slate-200 bg-slate-50 p-2.5">
      <h3 className="mb-1.5 text-xs font-semibold text-slate-900">{title}</h3>
      {children}
    </div>
  );
}

function resolvePaintMode(value) {
  const safe = String(value || "").trim().toLowerCase();
  if (!safe || safe === "transparent" || safe === "none") return "transparent";
  if (HEX_COLOR.test(safe)) return "color";
  return "advanced";
}

function resolveHexColor(value, fallback) {
  const safe = String(value || "").trim();
  return HEX_COLOR.test(safe) ? safe : fallback;
}

function PaintModeButton({ active, onClick, children }) {
  return (
    <button
      type="button"
      onClick={onClick}
      className={`rounded-md px-2 py-1 text-[10px] font-semibold transition-colors ${
        active
          ? "bg-slate-800 text-white"
          : "bg-transparent text-slate-600 hover:bg-slate-100"
      }`}
    >
      {children}
    </button>
  );
}

function UnitPaintField({
  label,
  value,
  onChange,
  colorFallback,
  advancedPlaceholder,
}) {
  const mode = resolvePaintMode(value);
  const colorValue = resolveHexColor(value, colorFallback);

  const setMode = (nextMode) => {
    if (nextMode === "transparent") {
      onChange("transparent");
      return;
    }
    if (nextMode === "color") {
      onChange(colorValue);
      return;
    }
    onChange(value && String(value).trim() ? String(value) : "rgba(15,23,42,0.12)");
  };

  return (
    <div className="space-y-1 text-[11px] font-medium text-slate-600">
      <span>{label}</span>
      <div className="grid grid-cols-3 rounded-lg border border-slate-300 bg-white p-0.5">
        <PaintModeButton active={mode === "transparent"} onClick={() => setMode("transparent")}>
          Transparente
        </PaintModeButton>
        <PaintModeButton active={mode === "color"} onClick={() => setMode("color")}>
          Color
        </PaintModeButton>
        <PaintModeButton active={mode === "advanced"} onClick={() => setMode("advanced")}>
          Avanzado
        </PaintModeButton>
      </div>

      {mode === "color" ? (
        <div className="flex items-center justify-between gap-2 rounded-lg border border-slate-300 bg-white px-2 py-1.5">
          <span
            className="max-w-[110px] truncate text-[11px] font-semibold text-slate-700"
            title={colorValue}
          >
            {colorValue.toUpperCase()}
          </span>
          <UnifiedColorPicker
            value={colorValue}
            onChange={onChange}
            fallbackColor={colorFallback}
            panelWidth={272}
            showGradients={false}
            title={`Cambiar ${label.toLowerCase()}`}
            triggerClassName="h-7 w-7 rounded border border-slate-300"
          />
        </div>
      ) : null}

      {mode === "advanced" ? (
        <input
          value={String(value || "")}
          onChange={(e) => onChange(e.target.value)}
          className="w-full rounded-lg border border-slate-300 bg-white px-2 py-1.5 text-xs"
          placeholder={advancedPlaceholder}
        />
      ) : null}

      {mode === "transparent" ? (
        <p className="rounded-lg border border-dashed border-slate-300 bg-white px-2 py-1.5 text-[11px] text-slate-500">
          Sin color aplicado.
        </p>
      ) : null}
    </div>
  );
}

function ColorField({ label, value, onChange, fallback = "#111111" }) {
  const safePaint = String(value || "").trim() || fallback;
  const isGradient = safePaint.toLowerCase().startsWith("linear-gradient(");
  return (
    <label className="space-y-1 text-[11px] font-medium text-slate-600">
      <span>{label}</span>
      <div className="flex items-center justify-between gap-2 rounded-lg border border-slate-300 bg-white px-2 py-1.5">
        <span
          className="max-w-[110px] truncate text-[11px] font-semibold text-slate-700"
          title={safePaint}
        >
          {isGradient ? "Gradiente" : safePaint.toUpperCase()}
        </span>
        <UnifiedColorPicker
          value={safePaint}
          onChange={onChange}
          fallbackColor={fallback}
          panelWidth={272}
          title={`Cambiar ${label.toLowerCase()}`}
          triggerClassName="h-7 w-7 rounded border border-slate-300"
        />
      </div>
    </label>
  );
}

function FrameColorField({ value, onChange }) {
  const safeValue = String(value || "").trim();
  const isTransparent = safeValue.toLowerCase() === "transparent";
  const colorValue = isTransparent ? "#773dbe" : safeValue || "#773dbe";

